(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*  A entry point for the browser bundle version. This gets compiled by:
        
        browserify --debug ./ccxt.browser.js > ./build/ccxt.browser.js
 */

window.ccxt = require ('./ccxt')
},{"./ccxt":2}],2:[function(require,module,exports){
"use strict";

/*

MIT License

Copyright (c) 2017 Igor Kroitor

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

"use strict";

//-----------------------------------------------------------------------------

const Exchange  = require ('./js/base/Exchange')
const functions = require ('./js/base/functions')
const errors    = require ('./js/base/errors')

//-----------------------------------------------------------------------------
// this is updated by vss.js when building

const version = '1.10.280'

Exchange.ccxtVersion = version

//-----------------------------------------------------------------------------

const exchanges = {
    '_1broker':                require ('./js/_1broker.js'),
    '_1btcxe':                 require ('./js/_1btcxe.js'),
    'acx':                     require ('./js/acx.js'),
    'allcoin':                 require ('./js/allcoin.js'),
    'anxpro':                  require ('./js/anxpro.js'),
    'binance':                 require ('./js/binance.js'),
    'bit2c':                   require ('./js/bit2c.js'),
    'bitbay':                  require ('./js/bitbay.js'),
    'bitcoincoid':             require ('./js/bitcoincoid.js'),
    'bitfinex':                require ('./js/bitfinex.js'),
    'bitfinex2':               require ('./js/bitfinex2.js'),
    'bitflyer':                require ('./js/bitflyer.js'),
    'bithumb':                 require ('./js/bithumb.js'),
    'bitlish':                 require ('./js/bitlish.js'),
    'bitmarket':               require ('./js/bitmarket.js'),
    'bitmex':                  require ('./js/bitmex.js'),
    'bitso':                   require ('./js/bitso.js'),
    'bitstamp':                require ('./js/bitstamp.js'),
    'bitstamp1':               require ('./js/bitstamp1.js'),
    'bittrex':                 require ('./js/bittrex.js'),
    'bl3p':                    require ('./js/bl3p.js'),
    'bleutrade':               require ('./js/bleutrade.js'),
    'btcbox':                  require ('./js/btcbox.js'),
    'btcchina':                require ('./js/btcchina.js'),
    'btcexchange':             require ('./js/btcexchange.js'),
    'btcmarkets':              require ('./js/btcmarkets.js'),
    'btctradeua':              require ('./js/btctradeua.js'),
    'btcturk':                 require ('./js/btcturk.js'),
    'btcx':                    require ('./js/btcx.js'),
    'bter':                    require ('./js/bter.js'),
    'bxinth':                  require ('./js/bxinth.js'),
    'ccex':                    require ('./js/ccex.js'),
    'cex':                     require ('./js/cex.js'),
    'chbtc':                   require ('./js/chbtc.js'),
    'chilebit':                require ('./js/chilebit.js'),
    'coincheck':               require ('./js/coincheck.js'),
    'coinfloor':               require ('./js/coinfloor.js'),
    'coingi':                  require ('./js/coingi.js'),
    'coinmarketcap':           require ('./js/coinmarketcap.js'),
    'coinmate':                require ('./js/coinmate.js'),
    'coinsecure':              require ('./js/coinsecure.js'),
    'coinspot':                require ('./js/coinspot.js'),
    'cryptopia':               require ('./js/cryptopia.js'),
    'dsx':                     require ('./js/dsx.js'),
    'exmo':                    require ('./js/exmo.js'),
    'flowbtc':                 require ('./js/flowbtc.js'),
    'foxbit':                  require ('./js/foxbit.js'),
    'fybse':                   require ('./js/fybse.js'),
    'fybsg':                   require ('./js/fybsg.js'),
    'gatecoin':                require ('./js/gatecoin.js'),
    'gateio':                  require ('./js/gateio.js'),
    'gdax':                    require ('./js/gdax.js'),
    'gemini':                  require ('./js/gemini.js'),
    'hitbtc':                  require ('./js/hitbtc.js'),
    'hitbtc2':                 require ('./js/hitbtc2.js'),
    'huobi':                   require ('./js/huobi.js'),
    'huobicny':                require ('./js/huobicny.js'),
    'huobipro':                require ('./js/huobipro.js'),
    'independentreserve':      require ('./js/independentreserve.js'),
    'itbit':                   require ('./js/itbit.js'),
    'jubi':                    require ('./js/jubi.js'),
    'kraken':                  require ('./js/kraken.js'),
    'kuna':                    require ('./js/kuna.js'),
    'lakebtc':                 require ('./js/lakebtc.js'),
    'liqui':                   require ('./js/liqui.js'),
    'livecoin':                require ('./js/livecoin.js'),
    'luno':                    require ('./js/luno.js'),
    'mercado':                 require ('./js/mercado.js'),
    'mixcoins':                require ('./js/mixcoins.js'),
    'nova':                    require ('./js/nova.js'),
    'okcoincny':               require ('./js/okcoincny.js'),
    'okcoinusd':               require ('./js/okcoinusd.js'),
    'okex':                    require ('./js/okex.js'),
    'paymium':                 require ('./js/paymium.js'),
    'poloniex':                require ('./js/poloniex.js'),
    'qryptos':                 require ('./js/qryptos.js'),
    'quadrigacx':              require ('./js/quadrigacx.js'),
    'quoine':                  require ('./js/quoine.js'),
    'southxchange':            require ('./js/southxchange.js'),
    'surbitcoin':              require ('./js/surbitcoin.js'),
    'therock':                 require ('./js/therock.js'),
    'tidex':                   require ('./js/tidex.js'),
    'urdubit':                 require ('./js/urdubit.js'),
    'vaultoro':                require ('./js/vaultoro.js'),
    'vbtc':                    require ('./js/vbtc.js'),
    'virwox':                  require ('./js/virwox.js'),
    'wex':                     require ('./js/wex.js'),
    'xbtce':                   require ('./js/xbtce.js'),
    'yobit':                   require ('./js/yobit.js'),
    'yunbi':                   require ('./js/yunbi.js'),
    'zaif':                    require ('./js/zaif.js'),
    'zb':                      require ('./js/zb.js'),    
}

//-----------------------------------------------------------------------------

module.exports = Object.assign ({ version, Exchange, exchanges: Object.keys (exchanges) }, exchanges, functions, errors)

//-----------------------------------------------------------------------------

},{"./js/_1broker.js":3,"./js/_1btcxe.js":4,"./js/acx.js":5,"./js/allcoin.js":6,"./js/anxpro.js":7,"./js/base/Exchange":8,"./js/base/errors":10,"./js/base/functions":11,"./js/binance.js":13,"./js/bit2c.js":14,"./js/bitbay.js":15,"./js/bitcoincoid.js":16,"./js/bitfinex.js":17,"./js/bitfinex2.js":18,"./js/bitflyer.js":19,"./js/bithumb.js":20,"./js/bitlish.js":21,"./js/bitmarket.js":22,"./js/bitmex.js":23,"./js/bitso.js":24,"./js/bitstamp.js":25,"./js/bitstamp1.js":26,"./js/bittrex.js":27,"./js/bl3p.js":28,"./js/bleutrade.js":29,"./js/btcbox.js":30,"./js/btcchina.js":31,"./js/btcexchange.js":32,"./js/btcmarkets.js":33,"./js/btctradeua.js":34,"./js/btcturk.js":35,"./js/btcx.js":36,"./js/bter.js":37,"./js/bxinth.js":38,"./js/ccex.js":39,"./js/cex.js":40,"./js/chbtc.js":41,"./js/chilebit.js":42,"./js/coincheck.js":43,"./js/coinfloor.js":44,"./js/coingi.js":45,"./js/coinmarketcap.js":46,"./js/coinmate.js":47,"./js/coinsecure.js":48,"./js/coinspot.js":49,"./js/cryptopia.js":50,"./js/dsx.js":51,"./js/exmo.js":52,"./js/flowbtc.js":53,"./js/foxbit.js":54,"./js/fybse.js":55,"./js/fybsg.js":56,"./js/gatecoin.js":57,"./js/gateio.js":58,"./js/gdax.js":59,"./js/gemini.js":60,"./js/hitbtc.js":61,"./js/hitbtc2.js":62,"./js/huobi.js":63,"./js/huobicny.js":64,"./js/huobipro.js":65,"./js/independentreserve.js":66,"./js/itbit.js":67,"./js/jubi.js":68,"./js/kraken.js":69,"./js/kuna.js":70,"./js/lakebtc.js":71,"./js/liqui.js":72,"./js/livecoin.js":73,"./js/luno.js":74,"./js/mercado.js":75,"./js/mixcoins.js":76,"./js/nova.js":77,"./js/okcoincny.js":78,"./js/okcoinusd.js":79,"./js/okex.js":80,"./js/paymium.js":81,"./js/poloniex.js":82,"./js/qryptos.js":83,"./js/quadrigacx.js":84,"./js/quoine.js":85,"./js/southxchange.js":86,"./js/surbitcoin.js":87,"./js/therock.js":88,"./js/tidex.js":89,"./js/urdubit.js":90,"./js/vaultoro.js":91,"./js/vbtc.js":92,"./js/virwox.js":93,"./js/wex.js":94,"./js/xbtce.js":95,"./js/yobit.js":96,"./js/yunbi.js":97,"./js/zaif.js":98,"./js/zb.js":99}],3:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class _1broker extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': '_1broker',
            'name': '1Broker',
            'countries': 'US',
            'rateLimit': 1500,
            'version': 'v2',
            'hasPublicAPI': false,
            'hasCORS': true,
            'hasFetchTrades': false,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '60',
                '15m': '900',
                '1h': '3600',
                '1d': '86400',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766021-420bd9fc-5ecb-11e7-8ed6-56d0081efed2.jpg',
                'api': 'https://1broker.com/api',
                'www': 'https://1broker.com',
                'doc': 'https://1broker.com/?c=en/content/api-documentation',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'api': {
                'private': {
                    'get': [
                        'market/bars',
                        'market/categories',
                        'market/details',
                        'market/list',
                        'market/quotes',
                        'market/ticks',
                        'order/cancel',
                        'order/create',
                        'order/open',
                        'position/close',
                        'position/close_cancel',
                        'position/edit',
                        'position/history',
                        'position/open',
                        'position/shared/get',
                        'social/profile_statistics',
                        'social/profile_trades',
                        'user/bitcoin_deposit_address',
                        'user/details',
                        'user/overview',
                        'user/quota_status',
                        'user/transaction_log',
                    ],
                },
            },
        });
    }

    async fetchCategories () {
        let response = await this.privateGetMarketCategories ();
        // they return an empty string among their categories, wtf?
        let categories = response['response'];
        let result = [];
        for (let i = 0; i < categories.length; i++) {
            if (categories[i])
                result.push (categories[i]);
        }
        return result;
    }

    async fetchMarkets () {
        let this_ = this; // workaround for Babel bug (not passing `this` to _recursive() call)
        let categories = await this.fetchCategories ();
        let result = [];
        for (let c = 0; c < categories.length; c++) {
            let category = categories[c];
            let markets = await this_.privateGetMarketList ({
                'category': category.toLowerCase (),
            });
            for (let p = 0; p < markets['response'].length; p++) {
                let market = markets['response'][p];
                let id = market['symbol'];
                let symbol = undefined;
                let base = undefined;
                let quote = undefined;
                if ((category == 'FOREX') || (category == 'CRYPTO')) {
                    symbol = market['name'];
                    let parts = symbol.split ('/');
                    base = parts[0];
                    quote = parts[1];
                } else {
                    base = id;
                    quote = 'USD';
                    symbol = base + '/' + quote;
                }
                base = this_.commonCurrencyCode (base);
                quote = this_.commonCurrencyCode (quote);
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                    'otherfield': {
                        'onemore': {
                        },
                    },
                });
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privateGetUserOverview ();
        let response = balance['response'];
        let result = {
            'info': response,
        };
        let currencies = Object.keys (this.currencies);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            result[currency] = this.account ();
        }
        let total = parseFloat (response['balance']);
        result['BTC']['free'] = total;
        result['BTC']['total'] = total;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMarketQuotes (this.extend ({
            'symbols': this.marketId (symbol),
        }, params));
        let orderbook = response['response'][0];
        let timestamp = this.parse8601 (orderbook['updated']);
        let bidPrice = parseFloat (orderbook['bid']);
        let askPrice = parseFloat (orderbook['ask']);
        let bid = [ bidPrice, undefined ];
        let ask = [ askPrice, undefined ];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'bids': [ bid ],
            'asks': [ ask ],
        };
    }

    async fetchTrades (symbol) {
        throw new ExchangeError (this.id + ' fetchTrades () method not implemented yet');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let result = await this.privateGetMarketBars (this.extend ({
            'symbol': this.marketId (symbol),
            'resolution': 60,
            'limit': 1,
        }, params));
        let orderbook = await this.fetchOrderBook (symbol);
        let ticker = result['response'][0];
        let timestamp = this.parse8601 (ticker['date']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h']),
            'low': parseFloat (ticker['l']),
            'bid': orderbook['bids'][0][0],
            'ask': orderbook['asks'][0][0],
            'vwap': undefined,
            'open': parseFloat (ticker['o']),
            'close': parseFloat (ticker['c']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date']),
            parseFloat (ohlcv['o']),
            parseFloat (ohlcv['h']),
            parseFloat (ohlcv['l']),
            parseFloat (ohlcv['c']),
            undefined,
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'resolution': this.timeframes[timeframe],
        };
        if (since)
            request['date_start'] = this.iso8601 (since); // they also support date_end
        if (limit)
            request['limit'] = limit;
        let result = await this.privateGetMarketBars (this.extend (request, params));
        return this.parseOHLCVs (result['response'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'margin': amount,
            'direction': (side == 'sell') ? 'short' : 'long',
            'leverage': 1,
            'type': side,
        };
        if (type == 'limit')
            order['price'] = price;
        else
            order['type'] += '_market';
        let result = await this.privateGetOrderCreate (this.extend (order, params));
        return {
            'info': result,
            'id': result['response']['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        this.checkRequiredCredentials ();
        let url = this.urls['api'] + '/' + this.version + '/' + path + '.php';
        let query = this.extend ({ 'token': this.apiKey }, params);
        url += '?' + this.urlencode (query);
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('warning' in response)
            if (response['warning'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],4:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class _1btcxe extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': '_1btcxe',
            'name': '1BTCXE',
            'countries': 'PA', // Panama
            'comment': 'Crypto Capital API',
            'hasCORS': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1d': '1year',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg',
                'api': 'https://1btcxe.com/api',
                'www': 'https://1btcxe.com',
                'doc': 'https://1btcxe.com/api-docs.php',
            },
            'api': {
                'public': {
                    'get': [
                        'stats',
                        'historical-prices',
                        'order-book',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balances-and-info',
                        'open-orders',
                        'user-transactions',
                        'btc-deposit-address/get',
                        'btc-deposit-address/new',
                        'deposits/get',
                        'withdrawals/get',
                        'orders/new',
                        'orders/edit',
                        'orders/cancel',
                        'orders/status',
                        'withdrawals/new',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/CNY': { 'id': 'CNY', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
                'BTC/RUB': { 'id': 'RUB', 'symbol': 'BTC/RUB', 'base': 'BTC', 'quote': 'RUB' },
                'BTC/CHF': { 'id': 'CHF', 'symbol': 'BTC/CHF', 'base': 'BTC', 'quote': 'CHF' },
                'BTC/JPY': { 'id': 'JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                'BTC/GBP': { 'id': 'GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                'BTC/CAD': { 'id': 'CAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
                'BTC/AUD': { 'id': 'AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                'BTC/AED': { 'id': 'AED', 'symbol': 'BTC/AED', 'base': 'BTC', 'quote': 'AED' },
                'BTC/BGN': { 'id': 'BGN', 'symbol': 'BTC/BGN', 'base': 'BTC', 'quote': 'BGN' },
                'BTC/CZK': { 'id': 'CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK' },
                'BTC/DKK': { 'id': 'DKK', 'symbol': 'BTC/DKK', 'base': 'BTC', 'quote': 'DKK' },
                'BTC/HKD': { 'id': 'HKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
                'BTC/HRK': { 'id': 'HRK', 'symbol': 'BTC/HRK', 'base': 'BTC', 'quote': 'HRK' },
                'BTC/HUF': { 'id': 'HUF', 'symbol': 'BTC/HUF', 'base': 'BTC', 'quote': 'HUF' },
                'BTC/ILS': { 'id': 'ILS', 'symbol': 'BTC/ILS', 'base': 'BTC', 'quote': 'ILS' },
                'BTC/INR': { 'id': 'INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
                'BTC/MUR': { 'id': 'MUR', 'symbol': 'BTC/MUR', 'base': 'BTC', 'quote': 'MUR' },
                'BTC/MXN': { 'id': 'MXN', 'symbol': 'BTC/MXN', 'base': 'BTC', 'quote': 'MXN' },
                'BTC/NOK': { 'id': 'NOK', 'symbol': 'BTC/NOK', 'base': 'BTC', 'quote': 'NOK' },
                'BTC/NZD': { 'id': 'NZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
                'BTC/PLN': { 'id': 'PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BTC/RON': { 'id': 'RON', 'symbol': 'BTC/RON', 'base': 'BTC', 'quote': 'RON' },
                'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
                'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                'BTC/THB': { 'id': 'THB', 'symbol': 'BTC/THB', 'base': 'BTC', 'quote': 'THB' },
                'BTC/TRY': { 'id': 'TRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY' },
                'BTC/ZAR': { 'id': 'ZAR', 'symbol': 'BTC/ZAR', 'base': 'BTC', 'quote': 'ZAR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalancesAndInfo ();
        let balance = response['balances-and-info'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            account['free'] = this.safeFloat (balance['available'], currency, 0.0);
            account['used'] = this.safeFloat (balance['on_hold'], currency, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currency': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (response['order-book'], undefined, 'bid', 'ask', 'price', 'order_amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetStats (this.extend ({
            'currency': this.marketId (symbol),
        }, params));
        let ticker = response['stats'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['max']),
            'low': parseFloat (ticker['min']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['daily_change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['total_btc_traded']),
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date'] + ' 00:00:00'),
            undefined,
            undefined,
            undefined,
            parseFloat (ohlcv['price']),
            undefined,
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetHistoricalPrices (this.extend ({
            'currency': market['id'],
            'timeframe': this.timeframes[timeframe],
        }, params));
        let ohlcvs = this.omit (response['historical-prices'], 'request_currency');
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['timestamp']) * 1000;
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['maker_type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currency': market['id'],
        }, params));
        let trades = this.omit (response['transactions'], 'request_currency');
        return this.parseTrades (trades, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'side': side,
            'type': type,
            'currency': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'limit')
            order['limit_price'] = price;
        let result = await this.privatePostOrdersNew (this.extend (order, params));
        return {
            'info': result,
            'id': result,
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrdersCancel ({ 'id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawalsNew (this.extend ({
            'currency': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'cryptocapital')
            throw new ExchangeError (this.id + ' is an abstract base API for _1btcxe');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let query = this.extend ({
                'api_key': this.apiKey,
                'nonce': this.nonce (),
            }, params);
            let request = this.json (query);
            query['signature'] = this.hmac (this.encode (request), this.encode (this.secret));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response) {
            let errors = [];
            for (let e = 0; e < response['errors'].length; e++) {
                let error = response['errors'][e];
                errors.push (error['code'] + ': ' + error['message']);
            }
            errors = errors.join (' ');
            throw new ExchangeError (this.id + ' ' + errors);
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],5:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class acx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'acx',
            'name': 'ACX',
            'countries': 'AU',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg',
                'extension': '.json',
                'api': 'https://acx.io/api',
                'www': 'https://acx.io',
                'doc': 'https://acx.io/documents/api_v2',
            },
            'api': {
                'public': {
                    'get': [
                        'markets', // Get all available markets
                        'tickers', // Get ticker of all markets
                        'tickers/{market}', // Get ticker of specific market
                        'trades', // Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                        'order_book', // Get the order book of specified market
                        'depth', // Get depth or specified market Both asks and bids are sorted from highest price to lowest.
                        'k', // Get OHLC(k line) of specific market
                        'k_with_pending_trades', // Get K data with pending trades, which are the trades not included in K data yet, because there's delay between trade generated and processed by K data generator
                        'timestamp', // Get server current time, in seconds since Unix epoch
                    ],
                },
                'private': {
                    'get': [
                        'members/me', // Get your profile and accounts info
                        'deposits', // Get your deposits history
                        'deposit', // Get details of specific deposit
                        'deposit_address', // Where to deposit The address field could be empty when a new address is generating (e.g. for bitcoin), you should try again later in that case.
                        'orders', // Get your orders, results is paginated
                        'order', // Get information of specified order
                        'trades/my', // Get your executed trades Trades are sorted in reverse creation order.
                        'withdraws', // Get your cryptocurrency withdraws
                        'withdraw', // Get your cryptocurrency withdraw
                    ],
                    'post': [
                        'orders', // Create a Sell/Buy order
                        'orders/multi', // Create multiple sell/buy orders
                        'orders/clear', // Cancel all my orders
                        'order/delete', // Cancel an order
                        'withdraw', // Create a withdraw
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMembersMe ();
        let balances = response['accounts'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': parseFloat (balance['balance']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'market': market['id'],
            'limit': 300,
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['at'] * 1000;
        ticker = ticker['ticker'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high', undefined),
            'low': this.safeFloat (ticker, 'low', undefined),
            'bid': this.safeFloat (ticker, 'buy', undefined),
            'ask': this.safeFloat (ticker, 'sell', undefined),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last', undefined),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'vol', undefined),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                base = base.toUpperCase ();
                quote = quote.toUpperCase ();
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                let symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTickersMarket (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTicker (response, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        // looks like they switched this endpoint off
        // it returns 503 Service Temporarily Unavailable always
        // return this.parseTrades (response, market);
        return response;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!limit)
            limit = 500; // default is 30
        let request = {
            'market': market['id'],
            'period': this.timeframes[timeframe],
            'limit': limit,
        };
        if (since)
            request['timestamp'] = since;
        let response = await this.publicGetK (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseOrder (order, market) {
        let symbol = market['symbol'];
        let timestamp = this.parse8601 (order['created_at']);
        return {
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': symbol,
            'type': order['ord_type'],
            'side': order['side'],
            'price': parseFloat (order['price']),
            'amount': parseFloat (order['volume']),
            'filled': parseFloat (order['executed_volume']),
            'remaining': parseFloat (order['remaining_volume']),
            'trades': undefined,
            'fee': undefined,
            'info': order,
        };
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'market': this.marketId (symbol),
            'side': side,
            'volume': amount.toString (),
            'ord_type': type,
        };
        if (type == 'limit') {
            order['price'] = price.toString ();
        }
        let response = await this.privatePostOrders (this.extend (order, params));
        let market = this.marketsById[response['market']];
        return this.parseOrder (response, market);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderDelete ({ 'id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'sum': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': undefined,
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/api' + '/' + this.version + '/' + this.implodeParams (path, params);
        if ('extension' in this.urls)
            request += this.urls['extension'];
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.urlencode (this.keysort (this.extend ({
                'access_key': this.apiKey,
                'tonce': nonce,
            }, params)));
            let auth = method + '|' + request + '|' + query;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            let suffix = query + '&signature=' + signature;
            if (method == 'GET') {
                url += '?' + suffix;
            } else {
                body = suffix;
                headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],6:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

//  ---------------------------------------------------------------------------

module.exports = class allcoin extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'allcoin',
            'name': 'Allcoin',
            'countries': 'CA',
            'hasCORS': false,
            'extension': '',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31561809-c316b37c-b061-11e7-8d5a-b547b4d730eb.jpg',
                'api': {
                    'web': 'https://allcoin.com',
                    'public': 'https://api.allcoin.com/api',
                    'private': 'https://api.allcoin.com/api',
                },
                'www': 'https://allcoin.com',
                'doc': 'https://allcoin.com/About/APIReference',
            },
            'api': {
                'web': {
                    'get': [
                        'marketoverviews/',
                    ],
                },
                'public': {
                    'get': [
                        'depth',
                        'kline',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'batch_trade',
                        'cancel_order',
                        'order_history',
                        'order_info',
                        'orders_info',
                        'repayment',
                        'trade',
                        'trade_history',
                        'userinfo',
                    ],
                },
            },
            'markets': undefined,
        });
    }

    async fetchMarkets () {
        let currencies = [ 'BTC', 'ETH', 'USD', 'QTUM' ];
        let result = [];
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let response = await this.webGetMarketoverviews ({
                'type': 'full',
                'secondary': currency,
            });
            let markets = response['Markets'];
            for (let k = 0; k < markets.length; k++) {
                let market = markets[k];
                let base = market['Primary'];
                let quote = market['Secondary'];
                let id = base.toLowerCase () + '_' + quote.toLowerCase ();
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'type': 'spot',
                    'spot': true,
                    'future': false,
                    'info': market,
                });
            }
        }
        return result;
    }

    getOrderStatus (status) {
        if (status == -1)
            return 'canceled';
        if (status == 0)
            return 'open';
        if (status == 1)
            return 'partial';
        if (status == 2)
            return 'closed';
        if (status == 10)
            return 'canceled';
        return status;
    }
}

},{"./okcoinusd.js":79}],7:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class anxpro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'anxpro',
            'name': 'ANXPro',
            'countries': [ 'JP', 'SG', 'HK', 'NZ' ],
            'version': '2',
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTrades': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg',
                'api': 'https://anxpro.com/api',
                'www': 'https://anxpro.com',
                'doc': [
                    'http://docs.anxv2.apiary.io',
                    'https://anxpro.com/pages/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{currency_pair}/money/ticker',
                        '{currency_pair}/money/depth/full',
                        '{currency_pair}/money/trade/fetch', // disabled by ANXPro
                    ],
                },
                'private': {
                    'post': [
                        '{currency_pair}/money/order/add',
                        '{currency_pair}/money/order/cancel',
                        '{currency_pair}/money/order/quote',
                        '{currency_pair}/money/order/result',
                        '{currency_pair}/money/orders',
                        'money/{currency}/address',
                        'money/{currency}/send_simple',
                        'money/info',
                        'money/trade/list',
                        'money/wallet/history',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/HKD': { 'id': 'BTCHKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/CAD': { 'id': 'BTCCAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
                'BTC/AUD': { 'id': 'BTCAUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                'BTC/SGD': { 'id': 'BTCSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                'BTC/JPY': { 'id': 'BTCJPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                'BTC/GBP': { 'id': 'BTCGBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                'BTC/NZD': { 'id': 'BTCNZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'DOGE/BTC': { 'id': 'DOGEBTC', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
                'STR/BTC': { 'id': 'STRBTC', 'symbol': 'STR/BTC', 'base': 'STR', 'quote': 'BTC' },
                'XRP/BTC': { 'id': 'XRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.6 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostMoneyInfo ();
        let balance = response['data'];
        let currencies = Object.keys (balance['Wallets']);
        let result = { 'info': balance };
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = this.account ();
            if (currency in balance['Wallets']) {
                let wallet = balance['Wallets'][currency];
                account['free'] = parseFloat (wallet['Available_Balance']['value']);
                account['total'] = parseFloat (wallet['Balance']['value']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetCurrencyPairMoneyDepthFull (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
        let orderbook = response['data'];
        let t = parseInt (orderbook['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetCurrencyPairMoneyTicker (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
        let ticker = response['data'];
        let t = parseInt (ticker['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        let bid = this.safeFloat (ticker['buy'], 'value');
        let ask = this.safeFloat (ticker['sell'], 'value');;
        let vwap = parseFloat (ticker['vwap']['value']);
        let baseVolume = parseFloat (ticker['vol']['value']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']['value']),
            'low': parseFloat (ticker['low']['value']),
            'bid': bid,
            'ask': ask,
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']['value']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']['value']),
            'baseVolume': baseVolume,
            'quoteVolume': baseVolume * vwap,
            'info': ticker,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        throw new ExchangeError (this.id + ' switched off the trades endpoint, see their docs at http://docs.anxv2.apiary.io/reference/market-data/currencypairmoneytradefetch-disabled');
        return this.publicGetCurrencyPairMoneyTradeFetch (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let order = {
            'currency_pair': this.marketId (market),
            'amount_int': parseInt (amount * 100000000), // 10^8
            'type': side,
        };
        if (type == 'limit')
            order['price_int'] = parseInt (price * 100000); // 10^5
        let result = await this.privatePostCurrencyPairOrderAdd (this.extend (order, params));
        return {
            'info': result,
            'id': result['data']
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCurrencyPairOrderCancel ({ 'oid': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostMoneyCurrencySendSimple (this.extend ({
            'currency': currency,
            'amount_int': parseInt (amount * 100000000), // 10^8
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['data']['transactionId'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': this.decode (signature),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] == 'success')
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],8:[function(require,module,exports){
(function (process){
"use strict";

//-----------------------------------------------------------------------------

const isNode    = (typeof window === 'undefined')
    , functions = require ('./functions')
    , throttle  = require ('./throttle')
    , fetch     = require ('fetch-ponyfill')().fetch
    , Market    = require ('./Market')

const { deepExtend
      , extend
      , sleep
      , timeout
      , indexBy
      , sortBy
      , aggregate
      , uuid
      , precisionFromString } = functions

const { ExchangeError
      , NotSupported
      , AuthenticationError
      , DDoSProtection
      , RequestTimeout
      , ExchangeNotAvailable } = require ('./errors')

// stub until we get a better solution for Webpack and React
// const journal = isNode && require ('./journal')
const journal = undefined

module.exports = class Exchange {

    getMarket (symbol) {

        if (!this.marketClasses)
            this.marketClasses = {}

        let marketClass = this.marketClasses[symbol]

        if (marketClass)
            return marketClass

        marketClass = new Market (this, symbol)
        this.marketClasses[symbol] = marketClass // only one Market instance per market
        return marketClass
    }

    describe () { return {} }

    constructor (userConfig = {}) {

        Object.assign (this, functions, { encode: string => string, decode: string => string })

        if (isNode)
            this.nodeVersion = process.version.match (/\d+\.\d+.\d+/) [0]

        // this.initRestRateLimiter ()

        if (isNode) {
            this.userAgent = {
                'User-Agent': 'ccxt/' + Exchange.ccxtVersion +
                    ' (+https://github.com/ccxt/ccxt)' +
                    ' Node.js/' + this.nodeVersion + ' (JavaScript)'
            }
        }

        // prepended to URL, like https://proxy.com/https://exchange.com/api...
        this.proxy = ''

        this.iso8601         = timestamp => new Date (timestamp).toISOString ()
        this.parse8601       = x => Date.parse (((x.indexOf ('+') >= 0) || (x.slice (-1) == 'Z')) ? x : (x + 'Z'))
        this.milliseconds    = Date.now
        this.microseconds    = () => Math.floor (this.milliseconds () * 1000)
        this.seconds         = () => Math.floor (this.milliseconds () / 1000)
        this.id              = undefined

        // rate limiter settings
        this.enableRateLimit = false
        this.rateLimit       = 2000  // milliseconds = seconds * 1000

        this.timeout         = 10000 // milliseconds
        this.verbose         = false
        this.debug           = false
        this.journal         = 'debug.json'
        this.userAgent       = false
        this.twofa           = false // two-factor authentication (2FA)
        this.substituteCommonCurrencyCodes = true
        this.parseBalanceFromOpenOrders = false
        this.timeframes      = undefined
        this.hasPublicAPI         = true
        this.hasPrivateAPI        = true
        this.hasCORS              = false
        this.hasDeposit           = false
        this.hasFetchBalance      = true
        this.hasFetchClosedOrders = false
        this.hasFetchCurrencies   = false
        this.hasFetchMyTrades     = false
        this.hasFetchOHLCV        = false
        this.hasFetchOpenOrders   = false
        this.hasFetchOrder        = false
        this.hasFetchOrderBook    = true
        this.hasFetchOrders       = false
        this.hasFetchTicker       = true
        this.hasFetchTickers      = false
        this.hasFetchTrades       = true
        this.hasWithdraw          = false
        this.hasCreateOrder       = this.hasPrivateAPI
        this.hasCancelOrder       = this.hasPrivateAPI

        this.requiredCredentials = {
            'apiKey':   true,
            'secret':   true,
            'uid':      false,
            'login':    false,
            'password': false,
        }

        this.balance    = {}
        this.orderbooks = {}
        this.tickers    = {}
        this.fees       = {}
        this.orders     = {}
        this.trades     = {}
        this.currencies = {}

        this.last_http_response = undefined
        this.last_json_response = undefined

        // TODO: generate
        this.market_id                   = this.marketId
        this.market_ids                  = this.marketIds
        this.implode_params              = this.implodeParams
        this.extract_params              = this.extractParams
        this.fetch_balance               = this.fetchBalance
        this.fetch_free_balance          = this.fetchFreeBalance
        this.fetch_used_balance          = this.fetchUsedBalance
        this.fetch_total_balance         = this.fetchTotalBalance
        this.fetch_l2_order_book         = this.fetchL2OrderBook
        this.fetch_order_book            = this.fetchOrderBook
        this.fetch_tickers               = this.fetchTickers
        this.fetch_ticker                = this.fetchTicker
        this.fetch_trades                = this.fetchTrades
        this.fetch_order                 = this.fetchOrder
        this.fetch_orders                = this.fetchOrders
        this.fetch_open_orders           = this.fetchOpenOrders
        this.fetch_closed_orders         = this.fetchClosedOrders
        this.fetch_order_status          = this.fetchOrderStatus
        this.fetch_markets               = this.fetchMarkets
        this.load_markets                = this.loadMarkets
        this.set_markets                 = this.setMarkets
        this.parse_balance               = this.parseBalance
        this.parse_bid_ask               = this.parseBidAsk
        this.parse_bids_asks             = this.parseBidsAsks
        this.parse_order_book            = this.parseOrderBook
        this.parse_trades                = this.parseTrades
        this.parse_orders                = this.parseOrders
        this.parse_ohlcv                 = this.parseOHLCV
        this.parse_ohlcvs                = this.parseOHLCVs
        this.edit_limit_buy_order        = this.editLimitBuyOrder
        this.edit_limit_sell_order       = this.editLimitSellOrder
        this.edit_limit_order            = this.editLimitOrder
        this.edit_order                  = this.editOrder
        this.create_limit_buy_order      = this.createLimitBuyOrder
        this.create_limit_sell_order     = this.createLimitSellOrder
        this.create_market_buy_order     = this.createMarketBuyOrder
        this.create_market_sell_order    = this.createMarketSellOrder
        this.create_order                = this.createOrder
        this.calculate_fee               = this.calculateFee
        this.common_currency_code        = this.commonCurrencyCode
        this.price_to_precision          = this.priceToPrecision
        this.amount_to_precision         = this.amountToPrecision
        this.fee_to_precision            = this.feeToPrecision
        this.cost_to_precision           = this.costToPrecision
        this.precisionFromString         = precisionFromString
        this.precision_from_string       = precisionFromString
        this.truncate                    = functions.truncate
        this.uuid                        = uuid

        // API methods metainfo
        this.has = {
            'cancelOrder': this.hasPrivateAPI,
            'createOrder': this.hasPrivateAPI,
            'deposit': false,
            'fetchBalance': this.hasPrivateAPI,
            'fetchClosedOrders': false,
            'fetchCurrencies': false,
            'fetchMarkets': true,
            'fetchMyTrades': false,
            'fetchOHLCV': false,
            'fetchOpenOrders': false,
            'fetchOrder': false,
            'fetchOrderBook': true,
            'fetchOrders': false,
            'fetchTicker': true,
            'fetchTickers': false,
            'fetchTrades': true,
            'withdraw': false,
        }

        // merge configs
        const config = deepExtend (this.describe (), userConfig)

        // merge to this
        for (const [property, value] of Object.entries (config))
            this[property] = deepExtend (this[property], value)

        if (this.api)
            this.defineRestApi (this.api, 'request')

        this.initRestRateLimiter ()

        if (this.markets)
            this.setMarkets (this.markets)

        if (this.debug && journal) {
            journal (() => this.journal, this, Object.keys (this.has))
        }
    }

    defaults () {
        return { /* override me */ }
    }

    nonce () {
        return this.seconds ()
    }

    encodeURIComponent (...args) {
        return encodeURIComponent (...args)
    }

    checkRequiredCredentials () {
        Object.keys (this.requiredCredentials).map (key => {
            if (this.requiredCredentials[key] && !this[key])
                throw new AuthenticationError (this.id + ' requires `' + key + '`')
        })
    }

    initRestRateLimiter () {

        this.tokenBucket = this.extend ({
            refillRate:  1 / this.rateLimit,
            delay:       1,
            capacity:    1,
            defaultCost: 1,
            maxCapacity: 1000,
        }, this.tokenBucket)

        this.throttle = throttle (this.tokenBucket)

        this.executeRestRequest = function (url, method = 'GET', headers = undefined, body = undefined) {

            let promise =
                fetch (url, { 'method': method, 'headers': headers, 'body': body, 'agent': this.tunnelAgent || null})
                    .catch (e => {
                        if (isNode)
                            throw new ExchangeNotAvailable ([ this.id, method, url, e.type, e.message ].join (' '))
                        throw e // rethrow all unknown errors
                    })
                    .then (response => this.handleRestErrors (response, url, method, headers, body))
                    .then (response => this.handleRestResponse (response, url, method, headers, body))

            return timeout (this.timeout, promise).catch (e => {
                if (e instanceof RequestTimeout)
                    throw new RequestTimeout (this.id + ' ' + method + ' ' + url + ' ' + e.message + ' (' + this.timeout + ' ms)')
                throw e
            })
        }
    }

    defineRestApi (api, methodName, options = {}) {

        for (const type of Object.keys (api)) {
            for (const httpMethod of Object.keys (api[type])) {

                let urls = api[type][httpMethod]
                for (let i = 0; i < urls.length; i++) {
                    let url = urls[i].trim ()
                    let splitPath = url.split (/[^a-zA-Z0-9]/)

                    let uppercaseMethod  = httpMethod.toUpperCase ()
                    let lowercaseMethod  = httpMethod.toLowerCase ()
                    let camelcaseMethod  = this.capitalize (lowercaseMethod)
                    let camelcaseSuffix  = splitPath.map (this.capitalize).join ('')
                    let underscoreSuffix = splitPath.map (x => x.trim ().toLowerCase ()).filter (x => x.length > 0).join ('_')

                    if (camelcaseSuffix.indexOf (camelcaseMethod) === 0)
                        camelcaseSuffix = camelcaseSuffix.slice (camelcaseMethod.length)

                    if (underscoreSuffix.indexOf (lowercaseMethod) === 0)
                        underscoreSuffix = underscoreSuffix.slice (lowercaseMethod.length)

                    let camelcase  = type + camelcaseMethod + this.capitalize (camelcaseSuffix)
                    let underscore = type + '_' + lowercaseMethod + '_' + underscoreSuffix

                    if ('suffixes' in options) {
                        if ('camelcase' in options['suffixes'])
                            camelcase += options['suffixes']['camelcase']
                        if ('underscore' in options.suffixes)
                            underscore += options['suffixes']['underscore']
                    }

                    if ('underscore_suffix' in options)
                        underscore += options.underscoreSuffix;
                    if ('camelcase_suffix' in options)
                        camelcase += options.camelcaseSuffix;

                    let partial = async params => this[methodName] (url, type, uppercaseMethod, params || {})

                    this[camelcase]  = partial
                    this[underscore] = partial
                }
            }
        }
    }

    fetch (url, method = 'GET', headers = undefined, body = undefined) {

        if (isNode && this.userAgent) {
            if (typeof this.userAgent == 'string')
                headers = extend ({ 'User-Agent': this.userAgent }, headers)
            else if ((typeof this.userAgent == 'object') && ('User-Agent' in this.userAgent))
                headers = extend (this.userAgent, headers)
        }

        if (typeof this.proxy == 'function') {

            url = this.proxy (url)
            headers = extend ({ 'Origin': '*' }, headers)

        } else if (typeof this.proxy == 'string') {

            if (this.proxy.length)
                headers = extend ({ 'Origin': '*' }, headers)

            url = this.proxy + url
        }

        if (this.verbose)
            console.log (this.id, method, url, "\nRequest:\n", headers, body)

        return this.executeRestRequest (url, method, headers, body)
    }

    async fetch2 (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {

        if (this.enableRateLimit)
            await this.throttle ()

        let request = this.sign (path, api, method, params, headers, body)
        return this.fetch (request.url, request.method, request.headers, request.body)
    }

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        return this.fetch2 (path, api, method, params, headers, body)
    }

    handleErrors (statusCode, statusText, url, method, headers, body) {
        // override me
    }

    defaultErrorHandler (code, reason, url, method, headers, body) {
        if (this.verbose)
            console.log (this.id, method, url, code, reason, body ? ("\nResponse:\n" + body) : '')
        if ((code >= 200) && (code <= 300))
            return body
        let error = undefined
        this.last_http_response = body
        let details = body
        let match = body.match ('\<title\>([^<]+)')
        if (match)
            details = match[1].trim ();
        if ([ 429 ].includes (code)) {
            error = DDoSProtection
        } else if ([ 404, 409, 422, 500, 501, 502, 520, 521, 522, 525 ].includes (code)) {
            error = ExchangeNotAvailable
        } else if ([ 400, 403, 405, 503, 530 ].includes (code)) {
            let ddosProtection = body.match (/cloudflare|incapsula/i)
            if (ddosProtection) {
                error = DDoSProtection
            } else {
                error = ExchangeNotAvailable
                details += ' (possible reasons: ' + [
                    'invalid API keys',
                    'bad or old nonce',
                    'exchange is down or offline',
                    'on maintenance',
                    'DDoS protection',
                    'rate-limiting',
                ].join (', ') + ')'
            }
        } else if ([ 408, 504 ].includes (code)) {
            error = RequestTimeout
        } else if ([ 401, 511 ].includes (code)) {
            error = AuthenticationError
        } else {
            error = ExchangeError
        }
        throw new error ([ this.id, method, url, code, reason, details ].join (' '))
    }

    handleRestErrors (response, url, method = 'GET', headers = undefined, body = undefined) {

        if (typeof response == 'string')
            return response

        return response.text ().then (text => {

            const args = [ response.status, response.statusText, url, method, headers, text ]

            this.handleErrors (...args)
            return this.defaultErrorHandler (...args)
        })
    }

    handleRestResponse (response, url, method = 'GET', headers = undefined, body = undefined) {

        try {

            this.last_http_response = response
            this.last_json_response =
                ((typeof response == 'string') && (response.length > 1)) ?
                    JSON.parse (response) : response
            return this.last_json_response

        } catch (e) {

            let maintenance = response.match (/offline|busy|retry|wait|unavailable|maintain|maintenance|maintenancing/i)
            let ddosProtection = response.match (/cloudflare|incapsula|overload/i)

            if (e instanceof SyntaxError) {

                let error = ExchangeNotAvailable
                let details = 'not accessible from this location at the moment'
                if (maintenance)
                    details = 'offline, on maintenance or unreachable from this location at the moment'
                if (ddosProtection)
                    error = DDoSProtection
                throw new error ([ this.id, method, url, details ].join (' '))
            }

            if (this.verbose)
                console.log (this.id, method, url, 'error', e, "response body:\n'" + response + "'")

            throw e
        }
    }

    setMarkets (markets) {
        let values = Object.values (markets).map (market => deepExtend ({
            'limits': this.limits,
            'precision': this.precision,
        }, this.fees['trading'], market))
        this.markets = deepExtend (this.markets, indexBy (values, 'symbol'))
        this.marketsById = indexBy (markets, 'id')
        this.markets_by_id = this.marketsById
        this.symbols = Object.keys (this.markets).sort ()
        this.ids = Object.keys (this.markets_by_id).sort ()
        const baseCurrencies =
            values.filter (market => 'base' in market)
                .map (market => ({
                    id: market.baseId || market.base,
                    code: market.base,
                }))
        const quoteCurrencies =
            values.filter (market => 'quote' in market)
                .map (market => ({
                    id: market.quoteId || market.quote,
                    code: market.quote,
                }))
        const currencies = sortBy (baseCurrencies.concat (quoteCurrencies), 'code')
        this.currencies = deepExtend (indexBy (currencies, 'code'), this.currencies || {})
        return this.markets
    }

    async loadMarkets (reload = false) {
        if (!reload && this.markets) {
            if (!this.marketsById) {
                return this.setMarkets (this.markets)
            }
            return this.markets
        }
        const markets = await this.fetchMarkets ()
        let currencies = undefined
        if (this.hasFetchCurrencies) {
            currencies = await this.fetchCurrencies ()
        }
        return this.setMarkets (markets, currencies)
    }

    fetchTickers (symbols = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchTickers not supported yet')
    }

    fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not supported yet');
    }

    fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrders not supported yet');
    }

    fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOpenOrders not supported yet');
    }

    fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchClosedOrders not supported yet');
    }

    fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchMyTrades not supported yet');
    }

    fetchCurrencies () {
        throw new NotSupported (this.id + ' fetchCurrencies not supported yet');
    }

    fetchMarkets () {
        return new Promise ((resolve, reject) => resolve (this.markets))
    }

    async fetchOrderStatus (id, market = undefined) {
        let order = await this.fetchOrder (id)
        return order['status']
    }

    account () {
        return {
            'free': 0.0,
            'used': 0.0,
            'total': 0.0,
        }
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency
        if (currency == 'XBT')
            return 'BTC'
        if (currency == 'BCC')
            return 'BCH'
        if (currency == 'DRK')
            return 'DASH'
        return currency
    }

    market (symbol) {

        if (typeof this.markets == 'undefined')
            return new ExchangeError (this.id + ' markets not loaded')

        if ((typeof symbol === 'string') && (symbol in this.markets))
            return this.markets[symbol]

        throw new ExchangeError (this.id + ' does not have market symbol ' + symbol)
    }

    marketId (symbol) {
        return this.market (symbol).id || symbol
    }

    marketIds (symbols) {
        return symbols.map (symbol => this.marketId(symbol));
    }

    symbol (symbol) {
        return this.market (symbol).symbol || symbol
    }

    extractParams (string) {
        let re = /{([a-zA-Z0-9_]+?)}/g
        let matches = []
        let match
        while (match = re.exec (string))
            matches.push (match[1])
        return matches
    }

    implodeParams (string, params) {
        for (let property in params)
            string = string.replace ('{' + property + '}', params[property])
        return string
    }

    url (path, params = {}) {
        let result = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path))
        if (Object.keys (query).length)
            result += '?' + this.urlencode (query)
        return result
    }

    parseBidAsk (bidask, priceKey = 0, amountKey = 1) {
        let price = parseFloat (bidask[priceKey])
        let amount = parseFloat (bidask[amountKey])
        return [ price, amount ]
    }

    parseBidsAsks (bidasks, priceKey = 0, amountKey = 1) {
        return Object.values (bidasks || []).map (bidask => this.parseBidAsk (bidask, priceKey, amountKey))
    }

    async fetchL2OrderBook (symbol, params = {}) {
        let orderbook = await this.fetchOrderBook (symbol, params)
        return extend (orderbook, {
            'bids': sortBy (aggregate (orderbook.bids), 0, true),
            'asks': sortBy (aggregate (orderbook.asks), 0),
        })
    }

    parseOrderBook (orderbook, timestamp = undefined, bidsKey = 'bids', asksKey = 'asks', priceKey = 0, amountKey = 1) {
        timestamp = timestamp || this.milliseconds ();
        return {
            'bids': (bidsKey in orderbook) ? this.parseBidsAsks (orderbook[bidsKey], priceKey, amountKey) : [],
            'asks': (asksKey in orderbook) ? this.parseBidsAsks (orderbook[asksKey], priceKey, amountKey) : [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    getCurrencyUsedOnOpenOrders (currency) {
        return Object.values (this.orders).filter (order => (order['status'] == 'open')).reduce ((total, order) => {
            let symbol = order['symbol'];
            let market = this.markets[symbol];
            let amount = order['remaining']
            if (currency == market['base'] && order['side'] == 'sell') {
                return total + amount
            } else if (currency == market['quote'] && order['side'] == 'buy') {
                return total + (order['cost'] || (order['price'] * amount))
            } else {
                return total
            }
        }, 0)
    }

    parseBalance (balance) {

        const currencies = Object.keys (this.omit (balance, 'info'));

        currencies.forEach (currency => {

            if (typeof balance[currency].used == 'undefined') {

                if (this.parseBalanceFromOpenOrders && ('open_orders' in balance['info'])) {
                    const exchangeOrdersCount = balance['info']['open_orders'];
                    const cachedOrdersCount = Object.values (this.orders).filter (order => (order['status'] == 'open')).length;
                    if (cachedOrdersCount == exchangeOrdersCount) {
                        balance[currency].used = this.getCurrencyUsedOnOpenOrders (currency)
                        balance[currency].total = balance[currency].used + balance[currency].free
                    }
                } else {
                    balance[currency].used = this.getCurrencyUsedOnOpenOrders (currency)
                    balance[currency].total = balance[currency].used + balance[currency].free
                }
            }

            [ 'free', 'used', 'total' ].forEach (account => {
                balance[account] = balance[account] || {}
                balance[account][currency] = balance[currency][account]
            })
        })
        return balance;
    }

    async fetchPartialBalance (part, params = {}) {
        let balance = await this.fetchBalance (params)
        return balance[part]
    }

    fetchFreeBalance (params = {}) {
        return this.fetchPartialBalance ('free', params)
    }

    fetchUsedBalance (params = {}) {
        return this.fetchPartialBalance ('used', params)
    }

    fetchTotalBalance (params = {}) {
        return this.fetchPartialBalance ('total', params)
    }

    parseTrades (trades, market = undefined) {
        return Object.values (trades).map (trade => this.parseTrade (trade, market))
    }

    parseOrders (orders, market = undefined) {
        return Object.values (orders).map (order => this.parseOrder (order, market))
    }

    filterOrdersBySymbol (orders, symbol = undefined) {
        let grouped = this.groupBy (orders, 'symbol')
        if (symbol) {
            if (symbol in grouped)
                return grouped[symbol]
            return []
        }
        return orders
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return ohlcv
    }

    parseOHLCVs (ohlcvs, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        ohlcvs = Object.values (ohlcvs)
        let result = []
        for (let i = 0; i < ohlcvs.length; i++) {
            if (limit && (result.length >= limit))
                break;
            let ohlcv = this.parseOHLCV (ohlcvs[i], market, timeframe, since, limit)
            if (since && (ohlcv[0] < since))
                continue
            result.push (ohlcv)
        }
        return result
    }

    editLimitBuyOrder (id, symbol, ...args) {
        return this.editLimitOrder (id, symbol, 'buy', ...args)
    }

    editLimitSellOrder (id, symbol, ...args) {
        return this.editLimitOrder (id, symbol, 'sell', ...args)
    }

    editLimitOrder (id, symbol, ...args) {
        return this.editOrder (id, symbol, 'limit', ...args)
    }

    async editOrder (id, symbol, ...args) {
        if (!this.enableRateLimit)
            throw new ExchangeError (this.id + ' editOrder() requires enableRateLimit = true')
        await this.cancelOrder (id, symbol);
        return this.createOrder (symbol, ...args)
    }

    createLimitBuyOrder (symbol, ...args) {
        return this.createOrder  (symbol, 'limit', 'buy', ...args)
    }

    createLimitSellOrder (symbol, ...args) {
        return this.createOrder (symbol, 'limit', 'sell', ...args)
    }

    createMarketBuyOrder (symbol, amount, params = {}) {
        return this.createOrder (symbol, 'market', 'buy', amount, undefined, params)
    }

    createMarketSellOrder (symbol, amount, params = {}) {
        return this.createOrder (symbol, 'market', 'sell', amount, undefined, params)
    }

    costToPrecision (symbol, cost) {
        return parseFloat (cost).toFixed (this.markets[symbol].precision.price)
    }

    priceToPrecision (symbol, price) {
        return parseFloat (price).toFixed (this.markets[symbol].precision.price)
    }

    amountToPrecision (symbol, amount) {
        return this.truncate(amount, this.markets[symbol].precision.amount)
    }

    amountToLots (symbol, amount) {
        return this.amountToPrecision (symbol, Math.floor (amount / this.markets[symbol].lot) * this.markets[symbol].lot)
    }

    feeToPrecision (symbol, fee) {
        return parseFloat (fee).toFixed (this.markets[symbol].precision.price)
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol]
        let rate = market[takerOrMaker]
        let cost = parseFloat (this.costToPrecision (symbol, amount * price))
        return {
            'type': takerOrMaker,
            'currency': market['quote'],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, rate * cost)),
        }
    }

    Ymd (timestamp, infix = ' ') {
        let date = new Date (timestamp)
        let Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        return Y + '-' + m + '-' + d
    }

    YmdHMS (timestamp, infix = ' ') {
        let date = new Date (timestamp)
        let Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        let H = date.getUTCHours ()
        let M = date.getUTCMinutes ()
        let S = date.getUTCSeconds ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        H = H < 10 ? ('0' + H) : H
        M = M < 10 ? ('0' + M) : M
        S = S < 10 ? ('0' + S) : S
        return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S
    }
}

}).call(this,require('_process'))

},{"./Market":9,"./errors":10,"./functions":11,"./throttle":12,"_process":135,"fetch-ponyfill":134}],9:[function(require,module,exports){
"use strict";

module.exports = class Market {

    constructor (exchange, symbol) {
        this.exchange = exchange;
        this.symbol = symbol;
        this.market = exchange.markets[symbol];
    }

    amountToPrecision (amount) {
        return this.exchange.amountToPrecision (this.symbol, amount)
    }

    createLimitBuyOrder(amount, price) {
        return this.exchange.createLimitBuyOrder (this.symbol, amount, price)
    }

    createLimitSellOrder(amount, price) {
        return this.exchange.createLimitSellOrder (this.symbol, amount, price)
    }
}

},{}],10:[function(require,module,exports){
class BaseError extends Error {
    constructor (message) {
        super (message)
        // a workaround to make `instanceof BaseError` work in ES5
        this.constructor = BaseError
        this.__proto__   = BaseError.prototype
        this.message     = message
    }
}

class ExchangeError extends BaseError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeError
        this.__proto__   = ExchangeError.prototype
        this.message     = message
    }
}

class NotSupported extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = NotSupported
        this.__proto__   = NotSupported.prototype
        this.message     = message
    }
}

class AuthenticationError extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = AuthenticationError
        this.__proto__   = AuthenticationError.prototype
        this.message     = message
    }
}

class InvalidNonce extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InvalidNonce
        this.__proto__   = InvalidNonce.prototype
        this.message     = message
    }
}

class InsufficientFunds extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InsufficientFunds
        this.__proto__   = InsufficientFunds.prototype
        this.message     = message
    }
}

class InvalidOrder extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InvalidOrder
        this.__proto__   = InvalidOrder.prototype
        this.message     = message
    }
}

class OrderNotFound extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = OrderNotFound
        this.__proto__   = OrderNotFound.prototype
        this.message     = message
    }
}

class OrderNotCached extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = OrderNotCached
        this.__proto__   = OrderNotCached.prototype
        this.message     = message
    }
}

class CancelPending extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = CancelPending
        this.__proto__   = CancelPending.prototype
        this.message     = message
    }
}

class NetworkError extends BaseError {
    constructor (message) {
        super (message)
        this.constructor = NetworkError
        this.__proto__   = NetworkError.prototype
        this.message     = message
    }
}

class DDoSProtection extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = DDoSProtection
        this.__proto__   = DDoSProtection.prototype
        this.message     = message
    }
}

class RequestTimeout extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = RequestTimeout
        this.__proto__   = RequestTimeout.prototype
        this.message     = message
    }
}

class ExchangeNotAvailable extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeNotAvailable
        this.__proto__   = ExchangeNotAvailable.prototype
        this.message     = message
    }
}

module.exports = {

    BaseError,
    ExchangeError,
    NotSupported,
    AuthenticationError,
    InvalidNonce,
    InsufficientFunds,
    InvalidOrder,
    OrderNotFound,
    OrderNotCached,
    CancelPending,
    NetworkError,
    DDoSProtection,
    RequestTimeout,
    ExchangeNotAvailable,
}
},{}],11:[function(require,module,exports){
"use strict";

//-----------------------------------------------------------------------------

const CryptoJS = require ('crypto-js')
    , qs       = require ('qs') // querystring

//-----------------------------------------------------------------------------

const { RequestTimeout } = require ('./errors')

//-----------------------------------------------------------------------------
// utility helpers

const setTimeout_safe = (done, ms, targetTime = Date.now () + ms) => { // setTimeout can fire earlier than specified, so we need to ensure it does not happen...

    setTimeout (() => {
        const rest = targetTime - Date.now ()
        if (rest > 0) {
            setTimeout_safe (done, rest, targetTime) // try sleep more
        } else {
            done ()
        }
    }, ms)
}

const sleep = ms => new Promise (resolve => setTimeout_safe (resolve, ms))

const decimal = float => parseFloat (float).toString ()

const timeout = (ms, promise) =>
        Promise.race ([
            promise,
            sleep (ms).then (() => { throw new RequestTimeout ('request timed out') })
        ])

const capitalize = string => string.length ? (string.charAt (0).toUpperCase () + string.slice (1)) : string

const keysort = object => {
    const result = {}
    Object.keys (object).sort ().forEach (key => result[key] = object[key])
    return result
}

const extend = (...args) => Object.assign ({}, ...args)

const deepExtend = function (...args) {

    // if (args.length < 1)
    //     return args
    // else if (args.length < 2)
    //     return args[0]

    let result = undefined

    for (const arg of args) {

        if (arg && (typeof arg == 'object') && (arg.constructor === Object || !('constructor' in arg))) {

            if (typeof result != 'object') {
                result = {}
            }

            for (const key in arg) {
                result[key] = deepExtend (result[key], arg[key])
            }

        } else {

            result = arg
        }
    }

    return result
}

const omit = (object, ...args) => {
    const result = extend (object)
    for (const x of args) {
        if (typeof x === 'string') {
            delete result[x]
        } else if (Array.isArray (x)) {
            for (const k of x)
                delete result[k]
        }
    }
    return result
}

const groupBy = (array, key) => {
    const result = {}
    Object
        .values (array)
        .filter (entry => entry[key] != 'undefined')
        .forEach (entry => {
            if (typeof result[entry[key]] == 'undefined')
                result[entry[key]] = []
            result[entry[key]].push (entry)
        })
    return result
}

const filterBy = (array, key, value = undefined) => {
    if (value) {
        let grouped = groupBy (array, key)
        if (value in grouped)
            return grouped[value]
        return []
    }
    return array
}

const indexBy = (array, key) => {
    const result = {}
    Object
        .values (array)
        .filter (entry => entry[key] != 'undefined')
        .forEach (entry => {
            result[entry[key]] = entry
        })
    return result
}

const sortBy = (array, key, descending = false) => {
    descending = descending ? -1 : 1
    return array.sort ((a, b) => ((a[key] < b[key]) ? -descending : ((a[key] > b[key]) ? descending : 0)))
}

const flatten = (array, result = []) => {
    for (let i = 0, length = array.length; i < length; i++) {
        const value = array[i]
        if (Array.isArray (value)) {
            flatten (value, result)
        } else {
            result.push (value)
        }
    }
    return result
}

const unique = array => array.filter ((value, index, self) => (self.indexOf (value) == index))

const pluck = (array, key) => array
                                .filter (element => (typeof element[key] != 'undefined'))
                                .map (element => element[key])

const urlencode = object => qs.stringify (object)
const rawencode = object => qs.stringify (object, { encode: false })

const sum = (...args) => {
    const result = args.filter (arg => typeof arg != 'undefined')
    return (result.length > 0) ?
        result.reduce ((sum, value) => sum + value, 0) : undefined
}

const safeFloat = (object, key, defaultValue = undefined) => {
    if (key in object) {
        if (typeof object[key] == 'number')
            return object[key]
        else if ((typeof object[key] == 'string') && object[key])
            return parseFloat (object[key])
    }
    return defaultValue
}

const safeString = (object, key, defaultValue = undefined) => {
    return (object && (key in object) && object[key]) ? object[key].toString () : defaultValue
}

const safeInteger = (object, key, defaultValue = undefined) => {
    return ((key in object) && object[key]) ? parseInt (object[key]) : defaultValue
}

const safeValue = (object, key, defaultValue = undefined) => {
    return ((key in object) && object[key]) ? object[key] : defaultValue
}

const uuid = a => a ?
    (a ^ Math.random () * 16 >> a / 4).toString (16) :
    ([1e7]+-1e3+-4e3+-8e3+-1e11).replace (/[018]/g, uuid)

// See https://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript for discussion

function toFixed (x) { // avoid scientific notation for too large and too small numbers

    if (Math.abs (x) < 1.0) {
        const e = parseInt (x.toString ().split ('e-')[1])
        if (e) {
            x *= Math.pow (10, e-1)
            x = '0.' + (new Array (e)).join ('0') + x.toString ().substring (2)
        }
    } else {
        let e = parseInt (x.toString ().split ('+')[1])
        if (e > 20) {
            e -= 20
            x /= Math.pow (10, e)
            x += (new Array (e+1)).join ('0')
        }
    }
    return x
}

// See https://stackoverflow.com/questions/4912788/truncate-not-round-off-decimal-numbers-in-javascript for discussion

// > So, after all it turned out, rounding bugs will always haunt you, no matter how hard you try to compensate them.
// > Hence the problem should be attacked by representing numbers exactly in decimal notation.

const truncate_regExpCache = []
    , truncate = (num, precision = 0) => {
        num = toFixed (num)
        const re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp("([-]*\\d+\\.\\d{" + precision + "})(\\d)"))
        const [,result] = num.toString ().match (re) || [null, num]
        return parseFloat (result)
    }

const precisionFromString = (string) => {
    const split = string.replace (/0+$/g, '').split ('.')
    return (split.length > 1) ? (split[1].length) : 0
}

const ordered = x => x // a stub to keep assoc keys in order, in JS it does nothing, it's mostly for Python

const aggregate = function (bidasks) {

    let result = {}

    bidasks.forEach (([ price, volume ]) => {
        result[price] = (result[price] || 0) + volume
    })

    return Object.keys (result).map (price => [
        parseFloat (price),
        parseFloat (result[price]),
    ])
}

//-----------------------------------------------------------------------------
// string  binary  base64 conversion routines

const stringToBinary = str => {
    const arr = new Uint8Array (str.length)
    for (let i = 0; i < str.length; i++) { arr[i] = str.charCodeAt(i); }
    return CryptoJS.lib.WordArray.create (arr)
}

const stringToBase64 = string => CryptoJS.enc.Latin1.parse (string).toString (CryptoJS.enc.Base64)
    , utf16ToBase64  = string => CryptoJS.enc.Utf16 .parse (string).toString (CryptoJS.enc.Base64)
    , base64ToBinary = string => CryptoJS.enc.Base64.parse (string)
    , base64ToString = string => CryptoJS.enc.Base64.parse (string).toString (CryptoJS.enc.Utf8)
    , binaryToString = string => string

const binaryConcat = (...args) => args.reduce ((a, b) => a.concat (b))

// url-safe-base64 without equals signs, with + replaced by - and slashes replaced by underscores
const urlencodeBase64 = base64string => base64string.replace (/[=]+$/, '')
                                                    .replace (/\+/g, '-')
                                                    .replace (/\//g, '_')

//-----------------------------------------------------------------------------
// cryptography

const hash = (request, hash = 'md5', digest = 'hex') => {
    const result = CryptoJS[hash.toUpperCase ()] (request)
    return (digest == 'binary') ? result : result.toString (CryptoJS.enc[capitalize (digest)])
}

const hmac = (request, secret, hash = 'sha256', digest = 'hex') => {
    const encoding = (digest == 'binary') ? 'Latin1' : capitalize (digest)
    return CryptoJS['Hmac' + hash.toUpperCase ()] (request, secret).toString (CryptoJS.enc[capitalize (encoding)])
}

//-----------------------------------------------------------------------------
// a JSON Web Token authentication method

const jwt = (request, secret, alg = 'HS256', hash = 'sha256') => {
    const encodedHeader = urlencodeBase64 (stringToBase64 (JSON.stringify ({ 'alg': alg, 'typ': 'JWT' })))
        , encodedData = urlencodeBase64 (stringToBase64 (JSON.stringify (request)))
        , token = [ encodedHeader, encodedData ].join ('.')
        , signature = urlencodeBase64 (utf16ToBase64 (hmac (token, secret, hash, 'utf16')))
    return [ token, signature ].join ('.')
}

//-----------------------------------------------------------------------------

module.exports = {

    // common utility functions

    sleep,
    timeout,
    capitalize,
    keysort,
    extend,
    deepExtend,
    omit,
    groupBy,
    indexBy,
    sortBy,
    filterBy,
    flatten,
    unique,
    pluck,
    urlencode,
    rawencode,
    sum,
    decimal,
    safeFloat,
    safeString,
    safeInteger,
    safeValue,
    ordered,
    aggregate,
    truncate,
    uuid,
    precisionFromString,

    // underscore aliases

    index_by: indexBy,
    sort_by: sortBy,
    group_by: groupBy,
    filter_by: filterBy,
    safe_float: safeFloat,
    safe_string: safeString,
    safe_integer: safeInteger,
    safe_value: safeValue,

    // crypto functions

    binaryConcat,
    stringToBinary,
    binaryToString,
    stringToBase64,
    utf16ToBase64,
    base64ToBinary,
    base64ToString,
    urlencodeBase64,
    hash,
    hmac,
    jwt,

    // json
    json:   JSON.stringify,
    unjson: JSON.parse
}

},{"./errors":10,"crypto-js":108,"qs":137}],12:[function(require,module,exports){
"use strict";

const { sleep }  = require ('./functions')

const throttle = cfg => {

    let lastTimestamp = Date.now ()
        , numTokens = (typeof cfg.numTokens != 'undefined') ? cfg.numTokens : cfg.capacity
        , queue = []
        , running = false
        , counter = 0

    return Object.assign (cost => {

        if (queue.length > cfg.maxCapacity)
            throw new Exception ('Backlog is over max capacity of ' + cfg.maxCapacity)

        return new Promise (async (resolve, reject) => {

            try {

                queue.push ({ cost, resolve, reject })

                if (!running) {
                    running = true
                    while (queue.length > 0) {
                        const hasEnoughTokens = cfg.capacity ? (numTokens > 0) : (numTokens >= 0)
                        if (hasEnoughTokens) {
                            if (queue.length > 0) {
                                let { cost, resolve, reject } = queue[0]
                                cost = (cost || cfg.defaultCost)
                                if (numTokens >= Math.min (cost, cfg.capacity)) {
                                    numTokens -= cost
                                    queue.shift ()
                                    resolve ()
                                }
                            }
                        }
                        let now = Date.now ()
                        let elapsed = now - lastTimestamp
                        lastTimestamp = now
                        numTokens = Math.min (cfg.capacity, numTokens + elapsed * cfg.refillRate)
                        await sleep (cfg.delay)
                    }
                    running = false
                }

            } catch (e) {

                reject (e)
            }
        })

    }, cfg, {
        configure: newCfg => throttle (Object.assign ({}, cfg, newCfg))
    })
}

module.exports = throttle
},{"./functions":11}],13:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, InvalidOrder } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class binance extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'binance',
            'name': 'Binance',
            'countries': 'CN', // China
            'rateLimit': 500,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchMyTrades': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchMyTrades': true,
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
                'api': {
                    'web': 'https://www.binance.com',
                    'wapi': 'https://api.binance.com/wapi/v3',
                    'public': 'https://api.binance.com/api/v1',
                    'private': 'https://api.binance.com/api/v3',
                },
                'www': 'https://www.binance.com',
                'doc': 'https://www.binance.com/restapipub.html',
                'fees': 'https://binance.zendesk.com/hc/en-us/articles/115000429332',
            },
            'api': {
                'web': {
                    'get': [
                        'exchange/public/product',
                    ],
                },
                'wapi': {
                    'post': [
                        'withdraw',
                    ],
                    'get': [
                        'depositHistory',
                        'withdrawHistory',
                        'depositAddress',
                    ],
                },
                'public': {
                    'get': [
                        'ping',
                        'time',
                        'depth',
                        'aggTrades',
                        'klines',
                        'ticker/24hr',
                        'ticker/allPrices',
                        'ticker/allBookTickers',
                    ],
                },
                'private': {
                    'get': [
                        'order',
                        'openOrders',
                        'allOrders',
                        'account',
                        'myTrades',
                    ],
                    'post': [
                        'order',
                        'order/test',
                        'userDataStream',
                    ],
                    'put': [
                        'userDataStream'
                    ],
                    'delete': [
                        'order',
                        'userDataStream',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.001,
                    'maker': 0.001,
                },
                'funding': {
                    'withdraw': {
                        'BNB': 1.0,
                        'BTC': 0.0005,
                        'ETH': 0.005,
                        'LTC': 0.001,
                        'NEO': 0.0,
                        'QTUM': 0.01,
                        'SNT': 50.0,
                        'BNT': 0.6,
                        'EOS': 2.0,
                        'BCH': 0.0005,
                        'GAS': 0.0,
                        'USDT': 5.0,
                        'OAX': 2.0,
                        'DNT': 30.0,
                        'MCO': 0.15,
                        'ICN': 0.5,
                        'WTC': 0.2,
                        'OMG': 0.1,
                        'ZRX': 5.0,
                        'STRAT': 0.1,
                        'SNGLS': 8.0,
                        'BQX': 2.0,
                        'KNC': 1.0,
                        'FUN': 50.0,
                        'SNM': 10.0,
                        'LINK': 5.0,
                        'XVG': 0.1,
                        'CTR': 1.0,
                        'SALT': 0.3,
                        'IOTA': 0.0,
                        'MDA': 0.5,
                        'MTL': 0.15,
                        'SUB': 10.0,
                        'ETC': 0.01,
                        'MTH': 10.0,
                        'ENG': 2.0,
                        'AST': 4.0,
                        'BTG': undefined,
                        'DASH': 0.002,
                        'EVX': 1.0,
                        'REQ': 30.0,
                        'LRC': 7.0,
                        'VIB': 7.0,
                        'HSR': 0.0001,
                        'TRX': 500.0,
                        'POWR': 15.0,
                        'ARK': 0.1,
                        'YOYO': 30.0,
                        'XRP': 0.15,
                        'MOD': 1.0,
                        'ENJ': 1.0,
                        'STORJ': 2.0,
                    },
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.webGetExchangePublicProduct ();
        let markets = response['data'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['symbol'];
            let base = this.commonCurrencyCode (market['baseAsset']);
            let quote = this.commonCurrencyCode (market['quoteAsset']);
            let symbol = base + '/' + quote;
            let lot = parseFloat (market['minTrade']);
            let tickSize = parseFloat (market['tickSize']);
            let precision = {
                'amount': this.precisionFromString (market['tickSize']),
                'price': this.precisionFromString (market['tickSize']),
            };
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'active': market['active'],
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': tickSize,
                        'max': undefined,
                    },
                    'cost': {
                        'min': lot,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, cost)),
        };
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetAccount (params);
        let result = { 'info': response };
        let balances = response['balances'];
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let asset = balance['asset'];
            let currency = this.commonCurrencyCode (asset);
            let account = {
                'free': parseFloat (balance['free']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'symbol': market['id'],
            'limit': 100, // default = maximum = 100
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market) {
        let timestamp = this.safeInteger (ticker, 'closeTime');
        if (typeof timestamp == 'undefined')
            timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'highPrice'),
            'low': this.safeFloat (ticker, 'lowPrice'),
            'bid': this.safeFloat (ticker, 'bidPrice'),
            'ask': this.safeFloat (ticker, 'askPrice'),
            'vwap': this.safeFloat (ticker, 'weightedAvgPrice'),
            'open': this.safeFloat (ticker, 'openPrice'),
            'close': this.safeFloat (ticker, 'prevClosePrice'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'lastPrice'),
            'change': this.safeFloat (ticker, 'priceChangePercent'),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'quoteVolume'),
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTicker24hr (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (response, market);
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickerAllBookTickers (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['symbol'];
            if (id in this.markets_by_id) {
                let market = this.markets_by_id[id];
                let symbol = market['symbol'];
                result[symbol] = this.parseTicker (ticker, market);
            }
        }
        return result;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0],
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[5]),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'interval': this.timeframes[timeframe],
        };
        request['limit'] = (limit) ? limit : 500; // default == max == 500
        if (since)
            request['startTime'] = since;
        let response = await this.publicGetKlines (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestampField = ('T' in trade) ? 'T' : 'time';
        let timestamp = trade[timestampField];
        let priceField = ('p' in trade) ? 'p' : 'price';
        let price = parseFloat (trade[priceField]);
        let amountField = ('q' in trade) ? 'q' : 'qty';
        let amount = parseFloat (trade[amountField]);
        let idField = ('a' in trade) ? 'a' : 'id';
        let id = trade[idField].toString ();
        let side = undefined;
        let order = undefined;
        if ('orderId' in trade)
            order = trade['orderId'].toString ();
        if ('m' in trade) {
            side = trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
        } else {
            side = (trade['isBuyer']) ? 'buy' : 'sell'; // this is a true side
        }
        let fee = undefined;
        if ('commission' in trade) {
            fee = {
                'cost': parseFloat (trade['commission']),
                'currency': this.commonCurrencyCode (trade['commissionAsset']),
            };
        }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': order,
            'type': undefined,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (since)
            request['startTime'] = since;
        if (limit)
            request['limit'] = limit;
        // 'fromId': 123,    // ID to get aggregate trades from INCLUSIVE.
        // 'startTime': 456, // Timestamp in ms to get aggregate trades from INCLUSIVE.
        // 'endTime': 789,   // Timestamp in ms to get aggregate trades until INCLUSIVE.
        // 'limit': 500,     // default = maximum = 500
        let response = await this.publicGetAggTrades (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    parseOrderStatus (status) {
        if (status == 'NEW')
            return 'open';
        if (status == 'PARTIALLY_FILLED')
            return 'partial';
        if (status == 'FILLED')
            return 'closed';
        if (status == 'CANCELED')
            return 'canceled';
        return status.toLowerCase ();
    }

    parseOrder (order, market = undefined) {
        let status = this.parseOrderStatus (order['status']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let id = order['symbol'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = order['time'];
        let price = parseFloat (order['price']);
        let amount = parseFloat (order['origQty']);
        let filled = this.safeFloat (order, 'executedQty', 0.0);
        let remaining = Math.max (amount - filled, 0.0);
        let result = {
            'info': order,
            'id': order['orderId'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': order['type'].toLowerCase (),
            'side': order['side'].toLowerCase (),
            'price': price,
            'amount': amount,
            'cost': price * amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'symbol': market['id'],
            'quantity': this.amountToPrecision (symbol, amount),
            'type': type.toUpperCase (),
            'side': side.toUpperCase (),
        };
        if (type == 'limit') {
            order = this.extend (order, {
                'price': this.priceToPrecision (symbol, price),
                'timeInForce': 'GTC', // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
            });
        }
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderId'].toString (),
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrder requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privateGetOrder (this.extend ({
            'symbol': market['id'],
            'orderId': parseInt (id),
        }, params));
        return this.parseOrder (response, market);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetAllOrders (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privateGetOpenOrders (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseOrders (response, market);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder requires a symbol param');
        let market = this.market (symbol);
        let response = undefined;
        try {
            response = await this.privateDeleteOrder (this.extend ({
                'symbol': market['id'],
                'orderId': parseInt (id),
                // 'origClientOrderId': id,
            }, params));
        } catch (e) {
            if (this.last_http_response.indexOf ('UNKNOWN_ORDER') >= 0)
                throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            throw e;
        }
        return response;
    }

    nonce () {
        return this.milliseconds ();
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchMyTrades requires a symbol');
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetMyTrades (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    commonCurrencyCode (currency) {
        if (currency == 'BCC')
            return 'BCH';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'BCH')
            return 'BCC';
        return currency;
    }

    async fetchDepositAddress (currency, params = {}) {
        let response = await this.wapiGetDepositAddress (this.extend ({
            'asset': this.currencyId (currency),
            'recvWindow': 10000000,
        }, params));
        if ('success' in response) {
            if (response['success']) {
                let address = this.safeString (response, 'address');
                return {
                    'currency': currency,
                    'address': address,
                    'status': 'ok',
                    'info': response,
                };
            }
        }
        throw new ExchangeError (this.id + ' fetchDepositAddress failed: ' + this.last_http_response);
    }

    async withdraw (currency, amount, address, params = {}) {
        let response = await this.wapiPostWithdraw (this.extend ({
            'asset': this.currencyId (currency),
            'address': address,
            'amount': parseFloat (amount),
            'recvWindow': 10000000,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        url += '/' + path;
        if (api == 'wapi')
            url += '.html';
        if ((api == 'private') || (api == 'wapi')) {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let query = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            let signature = this.hmac (this.encode (query), this.encode (this.secret));
            query += '&' + 'signature=' + signature;
            headers = {
                'X-MBX-APIKEY': this.apiKey,
            };
            if ((method == 'GET') || (api == 'wapi')) {
                url += '?' + query;
            } else {
                body = query;
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (body.indexOf ('MIN_NOTIONAL') >= 0)
            throw new InvalidOrder (this.id + ' order cost = amount * price should be > 0.001 BTC ' + body);
        if (body.indexOf ('LOT_SIZE') >= 0)
            throw new InvalidOrder (this.id + ' order amount should be evenly divisible by lot size, use this.amountToLots (symbol, amount) ' + body);
        if (body.indexOf ('PRICE_FILTER') >= 0)
            throw new InvalidOrder (this.id + ' order price exceeds allowed price precision or invalid, use this.priceToPrecision (symbol, amount) ' + body);
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response) {
            if (response['code'] < 0) {
                if (response['code'] == -2010)
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                if (response['code'] == -2011)
                    throw new OrderNotFound (this.id + ' ' + this.json (response));
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],14:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class bit2c extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bit2c',
            'name': 'Bit2C',
            'countries': 'IL', // Israel
            'rateLimit': 3000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
                'api': 'https://www.bit2c.co.il',
                'www': 'https://www.bit2c.co.il',
                'doc': [
                    'https://www.bit2c.co.il/home/api',
                    'https://github.com/OferE/bit2c',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'Exchanges/{pair}/Ticker',
                        'Exchanges/{pair}/orderbook',
                        'Exchanges/{pair}/trades',
                    ],
                },
                'private': {
                    'post': [
                        'Account/Balance',
                        'Account/Balance/v2',
                        'Merchant/CreateCheckout',
                        'Order/AccountHistory',
                        'Order/AddCoinFundsRequest',
                        'Order/AddFund',
                        'Order/AddOrder',
                        'Order/AddOrderMarketPriceBuy',
                        'Order/AddOrderMarketPriceSell',
                        'Order/CancelOrder',
                        'Order/MyOrders',
                        'Payment/GetMyId',
                        'Payment/Send',
                    ],
                },
            },
            'markets': {
                'BTC/NIS': { 'id': 'BtcNis', 'symbol': 'BTC/NIS', 'base': 'BTC', 'quote': 'NIS' },
                'BCH/NIS': { 'id': 'BchNis', 'symbol': 'BCH/NIS', 'base': 'BCH', 'quote': 'NIS' },
                'LTC/NIS': { 'id': 'LtcNis', 'symbol': 'LTC/NIS', 'base': 'LTC', 'quote': 'NIS' },
                'BTG/NIS': { 'id': 'BtgNis', 'symbol': 'BTG/NIS', 'base': 'BTG', 'quote': 'NIS' },
            },
            'fees': {
                'trading': {
                    'maker': 0.5 / 100,
                    'taker': 0.5 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostAccountBalanceV2 ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                let available = 'AVAILABLE_' + currency;
                account['free'] = balance[available];
                account['total'] = balance[currency];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetExchangesPairOrderbook (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetExchangesPairTicker (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let averagePrice = parseFloat (ticker['av']);
        let baseVolume = parseFloat (ticker['a']);
        let quoteVolume = baseVolume * averagePrice;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['h']),
            'ask': parseFloat (ticker['l']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ll']),
            'change': undefined,
            'percentage': undefined,
            'average': averagePrice,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetExchangesPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostOrderAddOrder';
        let order = {
            'Amount': amount,
            'Pair': this.marketId (symbol),
        };
        if (type == 'market') {
            method += 'MarketPrice' + this.capitalize (side);
        } else {
            order['Price'] = price;
            order['Total'] = amount * price;
            order['IsBid'] = (side == 'buy');
        }
        let result = await this[method] (this.extend (order, params));
        return {
            'info': result,
            'id': result['NewOrder']['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrderCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        if (api == 'public') {
            url += '.json';
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let query = this.extend ({ 'nonce': nonce }, params);
            body = this.urlencode (query);
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sign': this.decode (signature),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],15:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitbay extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitbay',
            'name': 'BitBay',
            'countries': [ 'PL', 'EU' ], // Poland
            'rateLimit': 1000,
            'hasCORS': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
                'www': 'https://bitbay.net',
                'api': {
                    'public': 'https://bitbay.net/API/Public',
                    'private': 'https://bitbay.net/API/Trading/tradingApi.php',
                },
                'doc': [
                    'https://bitbay.net/public-api',
                    'https://bitbay.net/account/tab-api',
                    'https://github.com/BitBayNet/API',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{id}/all',
                        '{id}/market',
                        '{id}/orderbook',
                        '{id}/ticker',
                        '{id}/trades',
                    ],
                },
                'private': {
                    'post': [
                        'info',
                        'trade',
                        'cancel',
                        'orderbook',
                        'orders',
                        'transfer',
                        'withdraw',
                        'history',
                        'transactions',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'LTC/USD': { 'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
                'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
                'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'ETH/USD': { 'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
                'ETH/EUR': { 'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR' },
                'ETH/PLN': { 'id': 'ETHPLN', 'symbol': 'ETH/PLN', 'base': 'ETH', 'quote': 'PLN' },
                'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                'LSK/USD': { 'id': 'LSKUSD', 'symbol': 'LSK/USD', 'base': 'LSK', 'quote': 'USD' },
                'LSK/EUR': { 'id': 'LSKEUR', 'symbol': 'LSK/EUR', 'base': 'LSK', 'quote': 'EUR' },
                'LSK/PLN': { 'id': 'LSKPLN', 'symbol': 'LSK/PLN', 'base': 'LSK', 'quote': 'PLN' },
                'LSK/BTC': { 'id': 'LSKBTC', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.0043,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        if ('balances' in response) {
            let balance = response['balances'];
            let result = { 'info': balance };
            let currencies = Object.keys (this.currencies);
            for (let i = 0; i < currencies.length; i++) {
                let currency = currencies[i];
                let account = this.account ();
                if (currency in balance) {
                    account['free'] = parseFloat (balance[currency]['available']);
                    account['used'] = parseFloat (balance[currency]['locked']);
                    account['total'] = this.sum (account['free'], account['used']);
                }
                result[currency] = account;
            }
            return this.parseBalance (result);
        }
        throw new ExchangeError (this.id + ' empty balance response ' + this.json (response));
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetIdOrderbook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetIdTicker (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let baseVolume = this.safeFloat (ticker, 'volume');
        let vwap = this.safeFloat (ticker, 'vwap');
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'max'),
            'low': this.safeFloat (ticker, 'min'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'average'),
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        return this.privatePostTrade (this.extend ({
            'type': side,
            'currency': market['base'],
            'amount': amount,
            'payment_currency': market['quote'],
            'rate': price,
        }, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    isFiat (currency) {
        let fiatCurrencies = {
            'USD': true,
            'EUR': true,
            'PLN': true,
        };
        if (currency in fiatCurrencies)
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdraw';
            // request['account'] = params['account']; // they demand an account number
            // request['express'] = params['express']; // whatever it means, they don't explain
            // request['bic'] = '';
        } else {
            method = 'privatePostTransfer';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params) + '.json';
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'method': path,
                'moment': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],16:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitcoincoid extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitcoincoid',
            'name': 'Bitcoin.co.id',
            'countries': 'ID', // Indonesia
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766138-043c7786-5ecf-11e7-882b-809c14f38b53.jpg',
                'api': {
                    'public': 'https://vip.bitcoin.co.id/api',
                    'private': 'https://vip.bitcoin.co.id/tapi',
                },
                'www': 'https://www.bitcoin.co.id',
                'doc': [
                    'https://vip.bitcoin.co.id/downloads/BITCOINCOID-API-DOCUMENTATION.pdf',
                    'https://vip.bitcoin.co.id/trade_api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{pair}/ticker',
                        '{pair}/trades',
                        '{pair}/depth',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'transHistory',
                        'trade',
                        'tradeHistory',
                        'openOrders',
                        'cancelOrder',
                    ],
                },
            },
            'markets': {
                'BTC/IDR': { 'id': 'btc_idr', 'symbol': 'BTC/IDR', 'base': 'BTC', 'quote': 'IDR', 'baseId': 'btc', 'quoteId': 'idr' },
                'BCH/IDR': { 'id': 'bch_idr', 'symbol': 'BCH/IDR', 'base': 'BCH', 'quote': 'IDR', 'baseId': 'bch', 'quoteId': 'idr' },
                'ETH/IDR': { 'id': 'eth_idr', 'symbol': 'ETH/IDR', 'base': 'ETH', 'quote': 'IDR', 'baseId': 'eth', 'quoteId': 'idr' },
                'ETC/IDR': { 'id': 'etc_idr', 'symbol': 'ETC/IDR', 'base': 'ETC', 'quote': 'IDR', 'baseId': 'etc', 'quoteId': 'idr' },
                'XRP/IDR': { 'id': 'xrp_idr', 'symbol': 'XRP/IDR', 'base': 'XRP', 'quote': 'IDR', 'baseId': 'xrp', 'quoteId': 'idr' },
                'XZC/IDR': { 'id': 'xzc_idr', 'symbol': 'XZC/IDR', 'base': 'XZC', 'quote': 'IDR', 'baseId': 'xzc', 'quoteId': 'idr' },
                'XLM/IDR': {'id': 'str_idr', 'symbol': 'XLM/IDR', 'base': 'XLM', 'quote': 'IDR', 'baseId': 'str', 'quoteId': 'idr'},
                'BTS/BTC': { 'id': 'bts_btc', 'symbol': 'BTS/BTC', 'base': 'BTS', 'quote': 'BTC', 'baseId': 'bts', 'quoteId': 'btc' },
                'DASH/BTC': { 'id': 'drk_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'drk', 'quoteId': 'btc' },
                'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'baseId': 'doge', 'quoteId': 'btc' },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc' },
                'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc' },
                'NXT/BTC': { 'id': 'nxt_btc', 'symbol': 'NXT/BTC', 'base': 'NXT', 'quote': 'BTC', 'baseId': 'nxt', 'quoteId': 'btc' },
                'XLM/BTC': { 'id': 'str_btc', 'symbol': 'XLM/BTC', 'base': 'XLM', 'quote': 'BTC', 'baseId': 'str', 'quoteId': 'btc' },
                'XEM/BTC': { 'id': 'nem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC', 'baseId': 'nem', 'quoteId': 'btc' },
                'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetInfo ();
        let balance = response['return'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balance['balance'], lowercase, 0.0);
            account['used'] = this.safeFloat (balance['balance_hold'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetPairDepth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell');
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTicker (this.extend ({
            'pair': market['id'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseFloat (ticker['server_time']) * 1000;
        let baseVolume = 'vol_' + market['baseId'].toLowerCase ();
        let quoteVolume = 'vol_' + market['quoteId'].toLowerCase ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker[baseVolume]),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'pair': market['id'],
            'type': side,
            'price': price,
        };
        let base = market['baseId'];
        order[base] = amount;
        let result = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['return']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],17:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, NotSupported, InvalidOrder, OrderNotFound } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitfinex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitfinex',
            'name': 'Bitfinex',
            'countries': 'US',
            'version': 'v1',
            'rateLimit': 1500,
            'hasCORS': false,
            // old metainfo interface
            'hasFetchOrder': true,
            'hasFetchTickers': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            'hasFetchOHLCV': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
                'deposit': true,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api': 'https://api.bitfinex.com',
                'www': 'https://www.bitfinex.com',
                'doc': [
                    'https://bitfinex.readme.io/v1/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ],
            },
            'api': {
                'v2': {
                    'get': [
                        'candles/trade:{timeframe}:{symbol}/{section}',
                        'candles/trade:{timeframe}:{symbol}/last',
                        'candles/trade:{timeframe}:{symbol}/hist',
                    ],
                },
                'public': {
                    'get': [
                        'book/{symbol}',
                        // 'candles/{symbol}',
                        'lendbook/{currency}',
                        'lends/{currency}',
                        'pubticker/{symbol}',
                        'stats/{symbol}',
                        'symbols',
                        'symbols_details',
                        'tickers',
                        'today',
                        'trades/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'account_infos',
                        'balances',
                        'basket_manage',
                        'credits',
                        'deposit/new',
                        'funding/close',
                        'history',
                        'history/movements',
                        'key_info',
                        'margin_infos',
                        'mytrades',
                        'mytrades_funding',
                        'offer/cancel',
                        'offer/new',
                        'offer/status',
                        'offers',
                        'offers/hist',
                        'order/cancel',
                        'order/cancel/all',
                        'order/cancel/multi',
                        'order/cancel/replace',
                        'order/new',
                        'order/new/multi',
                        'order/status',
                        'orders',
                        'orders/hist',
                        'position/claim',
                        'positions',
                        'summary',
                        'taken_funds',
                        'total_taken_funds',
                        'transfer',
                        'unused_taken_funds',
                        'withdraw',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.1 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        // issue #4 Bitfinex names Dash as DSH, instead of DASH
        if (currency == 'DSH')
            return 'DASH';
        if (currency == 'QTM')
            return 'QTUM';
        if (currency == 'BCC')
            return 'CST_BCC';
        if (currency == 'BCU')
            return 'CST_BCU';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbolsDetails ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['pair'].toUpperCase ();
            let baseId = id.slice (0, 3);
            let quoteId = id.slice (3, 6);
            let base = this.commonCurrencyCode (baseId);
            let quote = this.commonCurrencyCode (quoteId);
            let symbol = base + '/' + quote;
            let precision = {
                'price': market['price_precision'],
                'amount': market['price_precision'],
            };
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': parseFloat (market['minimum_order_size']),
                        'max': parseFloat (market['maximum_order_size']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balanceType = this.safeString (params, 'type', 'exchange');
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            if (balance['type'] == balanceType) {
                let currency = balance['currency'];
                let uppercase = currency.toUpperCase ();
                uppercase = this.commonCurrencyCode (uppercase);
                let account = this.account ();
                account['free'] = parseFloat (balance['available']);
                account['total'] = parseFloat (balance['amount']);
                account['used'] = account['total'] - account['free'];
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            if ('pair' in ticker) {
                let id = ticker['pair'];
                if (id in this.markets_by_id) {
                    let market = this.markets_by_id[id];
                    let symbol = market['symbol'];
                    result[symbol] = this.parseTicker (ticker, market);
                } else {
                    throw new ExchangeError (this.id + ' fetchTickers() failed to recognize symbol ' + id + ' ' + this.json (ticker));
                }
            } else {
                throw new ExchangeError (this.id + ' fetchTickers() response not recognized ' + this.json (tickers));
            }
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPubtickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseFloat (ticker['timestamp']) * 1000;
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('pair' in ticker) {
            let id = ticker['pair'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                throw new ExchangeError (this.id + ' unrecognized ticker symbol ' + id + ' ' + this.json (ticker));
            }
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['mid']),
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (parseFloat (trade['timestamp'])) * 1000;
        let side = trade['type'].toLowerCase ();
        let orderId = this.safeString (trade, 'order_id');
        let price = parseFloat (trade['price']);
        let amount = parseFloat (trade['amount']);
        let cost = price * amount;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'order': orderId,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': undefined,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = { 'symbol': market['id'] };
        if (limit) {
            request['limit_trades'] = limit;
        }
        if (since) {
            request['timestamp'] = parseInt (since / 1000);
        }
        let response = await this.privatePostMytrades (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = type;
        if ((type == 'limit') || (type == 'market'))
            orderType = 'exchange ' + type;
        // amount = this.amountToPrecision (symbol, amount);
        let order = {
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'side': side,
            'type': orderType,
            'ocoorder': false,
            'buy_price_oco': 0,
            'sell_price_oco': 0,
        };
        if (type == 'market') {
            order['price'] = this.nonce ().toString ();
        } else {
            // price = this.priceToPrecision (symbol, price);
            order['price'] = price.toString ();
        }
        let result = await this.privatePostOrderNew (this.extend (order, params));
        return this.parseOrder(result);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': parseInt (id) });
    }

    parseOrder (order, market = undefined) {
        let side = order['side'];
        let open = order['is_live'];
        let canceled = order['is_cancelled'];
        let status = undefined;
        if (open) {
            status = 'open';
        } else if (canceled) {
            status = 'canceled';
        } else {
            status = 'closed';
        }
        let symbol = undefined;
        if (!market) {
            let exchange = order['symbol'].toUpperCase ();
            if (exchange in this.markets_by_id) {
                market = this.markets_by_id[exchange];
            }
        }
        if (market)
            symbol = market['symbol'];
        let orderType = order['type'];
        let exchange = orderType.indexOf ('exchange ') >= 0;
        if (exchange) {
            let [ prefix, orderType ] = order['type'].split (' ');
        }
        let timestamp = parseInt (parseFloat (order['timestamp']) * 1000);
        let result = {
            'info': order,
            'id': order['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': orderType,
            'side': side,
            'price': parseFloat (order['price']),
            'average': parseFloat (order['avg_execution_price']),
            'amount': parseFloat (order['original_amount']),
            'remaining': parseFloat (order['remaining_amount']),
            'filled': parseFloat (order['executed_amount']),
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrders (params);
        let orders = this.parseOrders (response);
        if (symbol)
            return this.filterBy (orders, 'symbol', symbol);
        return orders;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (limit)
            request['limit'] = limit;
        let response = await this.privatePostOrdersHist (this.extend (request, params));
        let orders = this.parseOrders (response);
        if (symbol)
            return this.filterBy (orders, 'symbol', symbol);
        return orders;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus (this.extend ({
            'order_id': parseInt (id),
        }, params));
        return this.parseOrder (response);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0],
            ohlcv[1],
            ohlcv[3],
            ohlcv[4],
            ohlcv[2],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let v2id = 't' + market['id'];
        let request = {
            'symbol': v2id,
            'timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        if (since)
            request['start'] = since;
        request = this.extend (request, params);
        let response = await this.v2GetCandlesTradeTimeframeSymbolHist (request);
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    getCurrencyName (currency) {
        if (currency == 'BTC') {
            return 'bitcoin';
        } else if (currency == 'LTC') {
            return 'litecoin';
        } else if (currency == 'ETH') {
            return 'ethereum';
        } else if (currency == 'ETC') {
            return 'ethereumc';
        } else if (currency == 'OMNI') {
            return 'mastercoin'; // ???
        } else if (currency == 'ZEC') {
            return 'zcash';
        } else if (currency == 'XMR') {
            return 'monero';
        } else if (currency == 'USD') {
            return 'wire';
        } else if (currency == 'DASH') {
            return 'dash';
        } else if (currency == 'XRP') {
            return 'ripple';
        } else if (currency == 'EOS') {
            return 'eos';
        } else if (currency == 'BCH') {
            return 'bcash';
        } else if (currency == 'USDT') {
            return 'tetheruso';
        }
        throw new NotSupported (this.id + ' ' + currency + ' not supported for withdrawal');
    }

    async createDepositAddress (currency, params = {}) {
        let response = await this.fetchDepositAddress (currency, this.extend ({
            'renew': 1,
        }, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response['info'],
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let name = this.getCurrencyName (currency);
        let request = {
            'method': name,
            'wallet_name': 'exchange',
            'renew': 0, // a value of 1 will generate a new address
        };
        let response = await this.privatePostDepositNew (this.extend (request, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let name = this.getCurrencyName (currency);
        let request = {
            'withdraw_type': name,
            'walletselected': 'exchange',
            'amount': amount.toString (),
            'address': address,
        };
        let responses = await this.privatePostWithdraw (this.extend (request, params));
        let response = responses[0];
        return {
            'info': response,
            'id': response['withdrawal_id'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.implodeParams (path, params);
        if (api == 'v2') {
            request = '/' + api + request;
        } else {
            request = '/' + this.version + request;
        }
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if ((api == 'public') || (path.indexOf ('/hist') >= 0)) {
            if (Object.keys (query).length) {
                let suffix = '?' + this.urlencode (query);
                url += suffix;
                request += suffix;
            }
        }
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            query = this.extend ({
                'nonce': nonce.toString (),
                'request': request,
            }, query);
            query = this.json (query);
            query = this.encode (query);
            let payload = this.stringToBase64 (query);
            let secret = this.encode (this.secret);
            let signature = this.hmac (payload, secret, 'sha384');
            headers = {
                'X-BFX-APIKEY': this.apiKey,
                'X-BFX-PAYLOAD': this.decode (payload),
                'X-BFX-SIGNATURE': signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                let message = response['message'];
                if (message.indexOf ('Key price should be a decimal number') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('Invalid order: not enough exchange balance') >= 0) {
                    throw new InsufficientFunds (this.id + ' ' + message);
                } else if (message.indexOf ('Invalid order') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('Order could not be cancelled.') >= 0) {
                    throw new OrderNotFound (this.id + ' ' + message);
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('message' in response) {
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],18:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bitfinex = require ('./bitfinex.js')
const { ExchangeError, NotSupported, InsufficientFunds } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class bitfinex2 extends bitfinex {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitfinex2',
            'name': 'Bitfinex v2',
            'countries': 'US',
            'version': 'v2',
            'hasCORS': true,
            // old metainfo interface
            'hasFetchOrder': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'hasDeposit': false,
            'hasFetchOpenOrders': false,
            'hasFetchClosedOrders': false,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOpenOrders': false,
                'fetchClosedOrders': false,
                'withdraw': true,
                'deposit': false,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'rateLimit': 1500,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api': 'https://api.bitfinex.com',
                'www': 'https://www.bitfinex.com',
                'doc': [
                    'https://bitfinex.readme.io/v2/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ],
                'fees': 'https://www.bitfinex.com/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'platform/status',
                        'tickers',
                        'ticker/{symbol}',
                        'trades/{symbol}/hist',
                        'book/{symbol}/{precision}',
                        'book/{symbol}/P0',
                        'book/{symbol}/P1',
                        'book/{symbol}/P2',
                        'book/{symbol}/P3',
                        'book/{symbol}/R0',
                        'symbols_details',
                        'stats1/{key}:{size}:{symbol}/{side}/{section}',
                        'stats1/{key}:{size}:{symbol}/long/last',
                        'stats1/{key}:{size}:{symbol}/long/hist',
                        'stats1/{key}:{size}:{symbol}/short/last',
                        'stats1/{key}:{size}:{symbol}/short/hist',
                        'candles/trade:{timeframe}:{symbol}/{section}',
                        'candles/trade:{timeframe}:{symbol}/last',
                        'candles/trade:{timeframe}:{symbol}/hist',
                    ],
                    'post': [
                        'calc/trade/avg',
                    ],
                },
                'private': {
                    'post': [
                        'auth/r/wallets',
                        'auth/r/orders/{symbol}',
                        'auth/r/orders/{symbol}/new',
                        'auth/r/orders/{symbol}/hist',
                        'auth/r/order/{symbol}:{id}/trades',
                        'auth/r/trades/{symbol}/hist',
                        'auth/r/positions',
                        'auth/r/funding/offers/{symbol}',
                        'auth/r/funding/offers/{symbol}/hist',
                        'auth/r/funding/loans/{symbol}',
                        'auth/r/funding/loans/{symbol}/hist',
                        'auth/r/funding/credits/{symbol}',
                        'auth/r/funding/credits/{symbol}/hist',
                        'auth/r/funding/trades/{symbol}/hist',
                        'auth/r/info/margin/{key}',
                        'auth/r/info/funding/{key}',
                        'auth/r/movements/{currency}/hist',
                        'auth/r/stats/perf:{timeframe}/hist',
                        'auth/r/alerts',
                        'auth/w/alert/set',
                        'auth/w/alert/{type}:{symbol}:{price}/del',
                        'auth/calc/order/avail',
                    ],
                },
            },
            'markets': {
                'AVT/BTC': { 'id': 'tAVTBTC', 'symbol': 'AVT/BTC', 'base': 'AVT', 'quote': 'BTC' },
                'AVT/ETH': { 'id': 'tAVTETH', 'symbol': 'AVT/ETH', 'base': 'AVT', 'quote': 'ETH' },
                'AVT/USD': { 'id': 'tAVTUSD', 'symbol': 'AVT/USD', 'base': 'AVT', 'quote': 'USD' },
                'CST_BCC/BTC': { 'id': 'tBCCBTC', 'symbol': 'CST_BCC/BTC', 'base': 'CST_BCC', 'quote': 'BTC' },
                'CST_BCC/USD': { 'id': 'tBCCUSD', 'symbol': 'CST_BCC/USD', 'base': 'CST_BCC', 'quote': 'USD' },
                'BCH/BTC': { 'id': 'tBCHBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
                'BCH/ETH': { 'id': 'tBCHETH', 'symbol': 'BCH/ETH', 'base': 'BCH', 'quote': 'ETH' },
                'BCH/USD': { 'id': 'tBCHUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD' },
                'CST_BCU/BTC': { 'id': 'tBCUBTC', 'symbol': 'CST_BCU/BTC', 'base': 'CST_BCU', 'quote': 'BTC' },
                'CST_BCU/USD': { 'id': 'tBCUUSD', 'symbol': 'CST_BCU/USD', 'base': 'CST_BCU', 'quote': 'USD' },
                'BT1/BTC': { 'id': 'tBT1BTC', 'symbol': 'BT1/BTC', 'base': 'BT1', 'quote': 'BTC' },
                'BT1/USD': { 'id': 'tBT1USD', 'symbol': 'BT1/USD', 'base': 'BT1', 'quote': 'USD' },
                'BT2/BTC': { 'id': 'tBT2BTC', 'symbol': 'BT2/BTC', 'base': 'BT2', 'quote': 'BTC' },
                'BT2/USD': { 'id': 'tBT2USD', 'symbol': 'BT2/USD', 'base': 'BT2', 'quote': 'USD' },
                'BTC/USD': { 'id': 'tBTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'tBTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTG/BTC': { 'id': 'tBTGBTC', 'symbol': 'BTG/BTC', 'base': 'BTG', 'quote': 'BTC' },
                'BTG/USD': { 'id': 'tBTGUSD', 'symbol': 'BTG/USD', 'base': 'BTG', 'quote': 'USD' },
                'DASH/BTC': { 'id': 'tDSHBTC', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
                'DASH/USD': { 'id': 'tDSHUSD', 'symbol': 'DASH/USD', 'base': 'DASH', 'quote': 'USD' },
                'DAT/BTC': { 'id': 'tDATBTC', 'symbol': 'DAT/BTC', 'base': 'DAT', 'quote': 'BTC' },
                'DAT/ETH': { 'id': 'tDATETH', 'symbol': 'DAT/ETH', 'base': 'DAT', 'quote': 'ETH' },
                'DAT/USD': { 'id': 'tDATUSD', 'symbol': 'DAT/USD', 'base': 'DAT', 'quote': 'USD' },
                'EDO/BTC': { 'id': 'tEDOBTC', 'symbol': 'EDO/BTC', 'base': 'EDO', 'quote': 'BTC' },
                'EDO/ETH': { 'id': 'tEDOETH', 'symbol': 'EDO/ETH', 'base': 'EDO', 'quote': 'ETH' },
                'EDO/USD': { 'id': 'tEDOUSD', 'symbol': 'EDO/USD', 'base': 'EDO', 'quote': 'USD' },
                'EOS/BTC': { 'id': 'tEOSBTC', 'symbol': 'EOS/BTC', 'base': 'EOS', 'quote': 'BTC' },
                'EOS/ETH': { 'id': 'tEOSETH', 'symbol': 'EOS/ETH', 'base': 'EOS', 'quote': 'ETH' },
                'EOS/USD': { 'id': 'tEOSUSD', 'symbol': 'EOS/USD', 'base': 'EOS', 'quote': 'USD' },
                'ETC/BTC': { 'id': 'tETCBTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
                'ETC/USD': { 'id': 'tETCUSD', 'symbol': 'ETC/USD', 'base': 'ETC', 'quote': 'USD' },
                'ETH/BTC': { 'id': 'tETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                'ETH/USD': { 'id': 'tETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
                'ETP/BTC': { 'id': 'tETPBTC', 'symbol': 'ETP/BTC', 'base': 'ETP', 'quote': 'BTC' },
                'ETP/ETH': { 'id': 'tETPETH', 'symbol': 'ETP/ETH', 'base': 'ETP', 'quote': 'ETH' },
                'ETP/USD': { 'id': 'tETPUSD', 'symbol': 'ETP/USD', 'base': 'ETP', 'quote': 'USD' },
                'IOT/BTC': { 'id': 'tIOTBTC', 'symbol': 'IOT/BTC', 'base': 'IOT', 'quote': 'BTC' },
                'IOT/ETH': { 'id': 'tIOTETH', 'symbol': 'IOT/ETH', 'base': 'IOT', 'quote': 'ETH' },
                'IOT/USD': { 'id': 'tIOTUSD', 'symbol': 'IOT/USD', 'base': 'IOT', 'quote': 'USD' },
                'LTC/BTC': { 'id': 'tLTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'LTC/USD': { 'id': 'tLTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
                'NEO/BTC': { 'id': 'tNEOBTC', 'symbol': 'NEO/BTC', 'base': 'NEO', 'quote': 'BTC' },
                'NEO/ETH': { 'id': 'tNEOETH', 'symbol': 'NEO/ETH', 'base': 'NEO', 'quote': 'ETH' },
                'NEO/USD': { 'id': 'tNEOUSD', 'symbol': 'NEO/USD', 'base': 'NEO', 'quote': 'USD' },
                'OMG/BTC': { 'id': 'tOMGBTC', 'symbol': 'OMG/BTC', 'base': 'OMG', 'quote': 'BTC' },
                'OMG/ETH': { 'id': 'tOMGETH', 'symbol': 'OMG/ETH', 'base': 'OMG', 'quote': 'ETH' },
                'OMG/USD': { 'id': 'tOMGUSD', 'symbol': 'OMG/USD', 'base': 'OMG', 'quote': 'USD' },
                'QTUM/BTC': { 'id': 'tQTMBTC', 'symbol': 'QTUM/BTC', 'base': 'QTUM', 'quote': 'BTC' },
                'QTUM/ETH': { 'id': 'tQTMETH', 'symbol': 'QTUM/ETH', 'base': 'QTUM', 'quote': 'ETH' },
                'QTUM/USD': { 'id': 'tQTMUSD', 'symbol': 'QTUM/USD', 'base': 'QTUM', 'quote': 'USD' },
                'RRT/BTC': { 'id': 'tRRTBTC', 'symbol': 'RRT/BTC', 'base': 'RRT', 'quote': 'BTC' },
                'RRT/USD': { 'id': 'tRRTUSD', 'symbol': 'RRT/USD', 'base': 'RRT', 'quote': 'USD' },
                'SAN/BTC': { 'id': 'tSANBTC', 'symbol': 'SAN/BTC', 'base': 'SAN', 'quote': 'BTC' },
                'SAN/ETH': { 'id': 'tSANETH', 'symbol': 'SAN/ETH', 'base': 'SAN', 'quote': 'ETH' },
                'SAN/USD': { 'id': 'tSANUSD', 'symbol': 'SAN/USD', 'base': 'SAN', 'quote': 'USD' },
                'XMR/BTC': { 'id': 'tXMRBTC', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC' },
                'XMR/USD': { 'id': 'tXMRUSD', 'symbol': 'XMR/USD', 'base': 'XMR', 'quote': 'USD' },
                'XRP/BTC': { 'id': 'tXRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
                'XRP/USD': { 'id': 'tXRPUSD', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD' },
                'ZEC/BTC': { 'id': 'tZECBTC', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC' },
                'ZEC/USD': { 'id': 'tZECUSD', 'symbol': 'ZEC/USD', 'base': 'ZEC', 'quote': 'USD' },
            },
            'fees': {
                'trading': {
                    'maker': 0.1 / 100,
                    'taker': 0.2 / 100,
                },
                'funding': {
                    'withdraw': {
                        'BTC': 0.0005,
                        'BCH': 0.0005,
                        'ETH': 0.01,
                        'EOS': 0.1,
                        'LTC': 0.001,
                        'OMG': 0.1,
                        'IOT': 0.0,
                        'NEO': 0.0,
                        'ETC': 0.01,
                        'XRP': 0.02,
                        'ETP': 0.01,
                        'ZEC': 0.001,
                        'BTG': 0.0,
                        'DASH': 0.01,
                        'XMR': 0.04,
                        'QTM': 0.01,
                        'EDO': 0.5,
                        'DAT': 1.0,
                        'AVT': 0.5,
                        'SAN': 0.1,
                        'USDT': 5.0,
                    },
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        // issue #4 Bitfinex names Dash as DSH, instead of DASH
        if (currency == 'DSH')
            return 'DASH';
        if (currency == 'QTM')
            return 'QTUM';
        return currency;
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostAuthRWallets ();
        let balanceType = this.safeString (params, 'type', 'exchange');
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let [ accountType, currency, total, interest, available ] = balance;
            if (accountType == balanceType) {
                if (currency[0] == 't')
                    currency = currency.slice (1);
                let uppercase = currency.toUpperCase ();
                uppercase = this.commonCurrencyCode (uppercase);
                let account = this.account ();
                account['free'] = available;
                account['total'] = total;
                if (account['free'])
                    account['used'] = account['total'] - account['free'];
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetBookSymbolPrecision (this.extend ({
            'symbol': this.marketId (symbol),
            'precision': 'R0',
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let i = 0; i < orderbook.length; i++) {
            let order = orderbook[i];
            let price = order[1];
            let amount = order[2];
            let side = (amount > 0) ? 'bids' : 'asks';
            amount = Math.abs (amount);
            result[side].push ([ price, amount ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let length = ticker.length;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker[length - 2],
            'low': ticker[length - 1],
            'bid': ticker[length - 10],
            'ask': ticker[length - 8],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker[length - 4],
            'change': ticker[length - 6],
            'percentage': ticker[length - 5],
            'average': undefined,
            'baseVolume': ticker[length - 3],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        let tickers = await this.publicGetTickers (this.extend ({
            'symbols': this.ids.join (','),
        }, params));
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker[0];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.markets[symbol];
        let ticker = await this.publicGetTickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let [ id, timestamp, amount, price ] = trade;
        let side = (amount < 0) ? 'sell' : 'buy';
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': price,
            'amount': amount,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbolHist (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        if (since)
            request['start'] = since;
        request = this.extend (request, params);
        let response = await this.publicGetCandlesTradeTimeframeSymbolHist (request);
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        throw new NotSupported (this.id + ' createOrder not implemented yet');
    }

    cancelOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' cancelOrder not implemented yet');
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not implemented yet');
    }

    async withdraw (currency, amount, address, params = {}) {
        throw new NotSupported (this.id + ' withdraw not implemented yet');
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length) {
                url += '?' + this.urlencode (query);
            }
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let auth = '/api' + '/' + request + nonce + body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha384');
            headers = {
                'bfx-nonce': nonce,
                'bfx-apikey': this.apiKey,
                'bfx-signature': signature,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (response) {
            if ('message' in response) {
                if (response['message'].indexOf ('not enough exchange balance') >= 0)
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
            return response;
        } else if (response == '') {
            throw new ExchangeError (this.id + ' returned empty response');
        }
        return response;
    }
}

},{"./base/errors":10,"./bitfinex.js":17}],19:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class bitflyer extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitflyer',
            'name': 'bitFlyer',
            'countries': 'JP',
            'version': 'v1',
            'rateLimit': 500,
            'hasCORS': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg',
                'api': 'https://api.bitflyer.jp',
                'www': 'https://bitflyer.jp',
                'doc': 'https://bitflyer.jp/API',
            },
            'api': {
                'public': {
                    'get': [
                        'getmarkets',    // or 'markets'
                        'getboard',      // or 'board'
                        'getticker',     // or 'ticker'
                        'getexecutions', // or 'executions'
                        'gethealth',
                        'getchats',
                    ],
                },
                'private': {
                    'get': [
                        'getpermissions',
                        'getbalance',
                        'getcollateral',
                        'getcollateralaccounts',
                        'getaddresses',
                        'getcoinins',
                        'getcoinouts',
                        'getbankaccounts',
                        'getdeposits',
                        'getwithdrawals',
                        'getchildorders',
                        'getparentorders',
                        'getparentorder',
                        'getexecutions',
                        'getpositions',
                        'gettradingcommission',
                    ],
                    'post': [
                        'sendcoin',
                        'withdraw',
                        'sendchildorder',
                        'cancelchildorder',
                        'sendparentorder',
                        'cancelparentorder',
                        'cancelallchildorders',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.25 / 100,
                    'taker': 0.25 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['product_code'];
            let currencies = id.split ('_');
            let base = undefined;
            let quote = undefined;
            let symbol = id;
            let numCurrencies = currencies.length;
            if (numCurrencies == 1) {
                base = symbol.slice (0, 3);
                quote = symbol.slice (3, 6);
            } else if (numCurrencies == 2) {
                base = currencies[0];
                quote = currencies[1];
                symbol = base + '/' + quote;
            } else {
                base = currencies[1];
                quote = currencies[2];
            }
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = {};
        for (let b = 0; b < response.length; b++) {
            let account = response[b];
            let currency = account['currency_code'];
            balances[currency] = account;
        }
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances) {
                account['total'] = balances[currency]['amount'];
                account['free'] = balances[currency]['available'];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBoard (this.extend ({
            'product_code': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'size');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTicker (this.extend ({
            'product_code': this.marketId (symbol),
        }, params));
        let timestamp = this.parse8601 (ticker['timestamp']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ltp']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_by_product']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('side' in trade)
            if (trade['side']) {
                side = trade['side'].toLowerCase ();
                let id = side + '_child_order_acceptance_id';
                if (id in trade)
                    order = trade[id];
            }
        let timestamp = this.parse8601 (trade['exec_date']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExecutions (this.extend ({
            'product_code': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'product_code': this.marketId (symbol),
            'child_order_type': type.toUpperCase (),
            'side': side.toUpperCase (),
            'price': price,
            'size': amount,
        };
        let result = await this.privatePostSendchildorder (this.extend (order, params));
        return {
            'info': result,
            'id': result['child_order_acceptance_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelchildorder (this.extend ({
            'parent_order_id': id,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdraw (this.extend ({
            'currency_code': currency,
            'amount': amount,
            // 'bank_account_id': 1234,
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.version + '/';
        if (api == 'private')
            request += 'me/';
        request += path;
        if (method == 'GET') {
            if (Object.keys (params).length)
                request += '?' + this.urlencode (params);
        }
        let url = this.urls['api'] + request;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (params);
            let auth = [ nonce, method, request, body ].join ('');
            headers = {
                'ACCESS-KEY': this.apiKey,
                'ACCESS-TIMESTAMP': nonce,
                'ACCESS-SIGN': this.hmac (this.encode (auth), this.encode (this.secret)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],20:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bithumb extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bithumb',
            'name': 'Bithumb',
            'countries': 'KR', // South Korea
            'rateLimit': 500,
            'hasCORS': true,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
                'api': {
                    'public': 'https://api.bithumb.com/public',
                    'private': 'https://api.bithumb.com',
                },
                'www': 'https://www.bithumb.com',
                'doc': 'https://www.bithumb.com/u1/US127',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker/{currency}',
                        'ticker/all',
                        'orderbook/{currency}',
                        'orderbook/all',
                        'recent_transactions/{currency}',
                        'recent_transactions/all',
                    ],
                },
                'private': {
                    'post': [
                        'info/account',
                        'info/balance',
                        'info/wallet_address',
                        'info/ticker',
                        'info/orders',
                        'info/user_transactions',
                        'trade/place',
                        'info/order_detail',
                        'trade/cancel',
                        'trade/btc_withdrawal',
                        'trade/krw_deposit',
                        'trade/krw_withdrawal',
                        'trade/market_buy',
                        'trade/market_sell',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.15 / 100,
                    'taker': 0.15 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTickerAll ();
        let currencies = Object.keys (markets['data']);
        let result = [];
        for (let i = 0; i < currencies.length; i++) {
            let id = currencies[i];
            if (id != 'date') {
                let market = markets[id];
                let base = id;
                let quote = 'KRW';
                let symbol = id + '/' + quote;
                result.push (this.extend (this.fees['trading'], {
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                    'lot': undefined,
                    'active': true,
                    'precision': {
                        'amount': undefined,
                        'price': undefined,
                    },
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                }));
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfoBalance (this.extend ({
            'currency': 'ALL',
        }, params));
        let result = { 'info': response };
        let balances = response['data'];
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            let lowercase = currency.toLowerCase ();
            account['total'] = this.safeFloat (balances, 'total_' + lowercase);
            account['used'] = this.safeFloat (balances, 'in_use_' + lowercase);
            account['free'] = this.safeFloat (balances, 'available_' + lowercase);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetOrderbookCurrency (this.extend ({
            'count': 50, // max = 50
            'currency': market['base'],
        }, params));
        let orderbook = response['data'];
        let timestamp = parseInt (orderbook['timestamp']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseInt (ticker['date']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'max_price'),
            'low': this.safeFloat (ticker, 'min_price'),
            'bid': this.safeFloat (ticker, 'buy_price'),
            'ask': this.safeFloat (ticker, 'sell_price'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'opening_price'),
            'close': this.safeFloat (ticker, 'closing_price'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last_trade'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'average_price'),
            'baseVolume': this.safeFloat (ticker, 'volume_1day'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        let response = await this.publicGetTickerAll (params);
        let result = {};
        let timestamp = response['data']['date'];
        let tickers = this.omit (response['data'], 'date');
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            let ticker = tickers[id];
            ticker['date'] = timestamp;
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTickerCurrency (this.extend ({
            'currency': market['base'],
        }, params));
        return this.parseTicker (response['data'], market);
    }

    parseTrade (trade, market) {
        // a workaround for their bug in date format, hours are not 0-padded
        let [ transaction_date, transaction_time ] = trade['transaction_date'].split (' ');
        let transaction_time_short = transaction_time.length < 8;
        if (transaction_time_short)
            transaction_time = '0' + transaction_time;
        let timestamp = this.parse8601 (transaction_date + ' ' + transaction_time);
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['units_traded']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetRecentTransactionsCurrency (this.extend ({
            'currency': market['base'],
            'count': 100, // max = 100
        }, params));
        return this.parseTrades (response['data'], market);
    }

    createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        throw new NotSupported (this.id + ' private API not implemented yet');
        //     let prefix = '';
        //     if (type == 'market')
        //         prefix = 'market_';
        //     let order = {
        //         'pair': this.marketId (symbol),
        //         'quantity': amount,
        //         'price': price || 0,
        //         'type': prefix + side,
        //     };
        //     let response = await this.privatePostOrderCreate (this.extend (order, params));
        //     return {
        //         'info': response,
        //         'id': response['order_id'].toString (),
        //     };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        let side = ('side' in params);
        if (!side)
            throw new ExchangeError (this.id + ' cancelOrder requires a side parameter (sell or buy)');
        side = (side == 'buy') ? 'purchase' : 'sales';
        let currency = ('currency' in params);
        if (!currency)
            throw new ExchangeError (this.id + ' cancelOrder requires a currency parameter');
        return await this.privatePostTradeCancel ({
            'order_id': id,
            'type': params['side'],
            'currency': params['currency'],
        });
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let endpoint = '/' + this.implodeParams (path, params);
        let url = this.urls['api'][api] + endpoint;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'endpoint': endpoint,
            }, query));
            let nonce = this.nonce ().toString ();
            let auth = endpoint + "\0" + body + "\0" + nonce;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512');
            headers = {
                'Api-Key': this.apiKey,
                'Api-Sign': this.decode (this.stringToBase64 (this.encode (signature))),
                'Api-Nonce': nonce,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response) {
            if (response['status'] == '0000')
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],21:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitlish extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitlish',
            'name': 'bitlish',
            'countries': [ 'GB', 'EU', 'RU' ],
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg',
                'api': 'https://bitlish.com/api',
                'www': 'https://bitlish.com',
                'doc': 'https://bitlish.com/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'api': {
                'public': {
                    'get': [
                        'instruments',
                        'ohlcv',
                        'pairs',
                        'tickers',
                        'trades_depth',
                        'trades_history',
                    ],
                    'post': [
                        'instruments',
                        'ohlcv',
                        'pairs',
                        'tickers',
                        'trades_depth',
                        'trades_history',
                    ],
                },
                'private': {
                    'post': [
                        'accounts_operations',
                        'balance',
                        'cancel_trade',
                        'cancel_trades_by_ids',
                        'cancel_all_trades',
                        'create_bcode',
                        'create_template_wallet',
                        'create_trade',
                        'deposit',
                        'list_accounts_operations_from_ts',
                        'list_active_trades',
                        'list_bcodes',
                        'list_my_matches_from_ts',
                        'list_my_trades',
                        'list_my_trads_from_ts',
                        'list_payment_methods',
                        'list_payments',
                        'redeem_code',
                        'resign',
                        'signin',
                        'signout',
                        'trade_details',
                        'trade_options',
                        'withdraw',
                        'withdraw_by_id',
                    ],
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency;
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'BCC')
            return 'BCH';
        if (currency == 'DRK')
            return 'DASH';
        if (currency == 'DSH')
            currency = 'DASH';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairs ();
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'high': this.safeFloat (ticker, 'max'),
            'low': this.safeFloat (ticker, 'min'),
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': this.safeFloat (ticker, 'first'),
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': this.safeFloat (ticker, 'prc'),
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'sum'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickers (params);
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // let market = this.market (symbol);
        let now = this.seconds ();
        let start = now - 86400 * 30; // last 30 days
        let interval = [ start.toString (), undefined ];
        return await this.publicPostOhlcv (this.extend ({
            'time_range': interval,
        }, params));
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetTradesDepth (this.extend ({
            'pair_id': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (parseInt (orderbook['last']) / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bid', 'ask', 'price', 'volume');
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['dir'] == 'bid') ? 'buy' : 'sell';
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let timestamp = parseInt (trade['created'] / 1000);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesHistory (this.extend ({
            'pair_id': market['id'],
        }, params));
        return this.parseTrades (response['list'], market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        let currencies = Object.keys (response);
        let balance = {};
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = response[currency];
            currency = currency.toUpperCase ();
            // issue #4 bitlish names Dash as DSH, instead of DASH
            if (currency == 'DSH')
                currency = 'DASH';
            balance[currency] = account;
        }
        currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                account['free'] = parseFloat (balance[currency]['funds']);
                account['used'] = parseFloat (balance[currency]['holded']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    signIn () {
        return this.privatePostSignin ({
            'login': this.login,
            'passwd': this.password,
        });
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair_id': this.marketId (symbol),
            'dir': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let result = await this.privatePostCreateTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelTrade ({ 'id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC') {
            // they did not document other types...
            throw new NotSupported (this.id + ' currently supports BTC withdrawals only, until they document other currencies...');
        }
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'amount': parseFloat (amount),
            'account': address,
            'payment_method': 'bitcoin', // they did not document other types...
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (method == 'GET') {
                if (Object.keys (params).length)
                    url += '?' + this.urlencode (params);
            }
            else {
                body = this.json (params);
                headers = { 'Content-Type': 'application/json' };
            }
        } else {
            this.checkRequiredCredentials ();
            body = this.json (this.extend ({ 'token': this.apiKey }, params));
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],22:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitmarket extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitmarket',
            'name': 'BitMarket',
            'countries': [ 'PL', 'EU' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '90m': '90m',
                '6h': '6h',
                '1d': '1d',
                '1w': '7d',
                '1M': '1m',
                '3M': '3m',
                '6M': '6m',
                '1y': '1y',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27767256-a8555200-5ef9-11e7-96fd-469a65e2b0bd.jpg',
                'api': {
                    'public': 'https://www.bitmarket.net',
                    'private': 'https://www.bitmarket.pl/api2/', // last slash is critical
                },
                'www': [
                    'https://www.bitmarket.pl',
                    'https://www.bitmarket.net',
                ],
                'doc': [
                    'https://www.bitmarket.net/docs.php?file=api_public.html',
                    'https://www.bitmarket.net/docs.php?file=api_private.html',
                    'https://github.com/bitmarket-net/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'json/{market}/ticker',
                        'json/{market}/orderbook',
                        'json/{market}/trades',
                        'json/ctransfer',
                        'graphs/{market}/90m',
                        'graphs/{market}/6h',
                        'graphs/{market}/1d',
                        'graphs/{market}/7d',
                        'graphs/{market}/1m',
                        'graphs/{market}/3m',
                        'graphs/{market}/6m',
                        'graphs/{market}/1y',
                    ],
                },
                'private': {
                    'post': [
                        'info',
                        'trade',
                        'cancel',
                        'orders',
                        'trades',
                        'history',
                        'withdrawals',
                        'tradingdesk',
                        'tradingdeskStatus',
                        'tradingdeskConfirm',
                        'cryptotradingdesk',
                        'cryptotradingdeskStatus',
                        'cryptotradingdeskConfirm',
                        'withdraw',
                        'withdrawFiat',
                        'withdrawPLNPP',
                        'withdrawFiatFast',
                        'deposit',
                        'transfer',
                        'transfers',
                        'marginList',
                        'marginOpen',
                        'marginClose',
                        'marginCancel',
                        'marginModify',
                        'marginBalanceAdd',
                        'marginBalanceRemove',
                        'swapList',
                        'swapOpen',
                        'swapClose',
                    ],
                },
            },
            'markets': {
                'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'LiteMineX/BTC': { 'id': 'LiteMineXBTC', 'symbol': 'LiteMineX/BTC', 'base': 'LiteMineX', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.0015,
                    'taker': 0.0045,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfo ();
        let data = response['data'];
        let balance = data['balances'];
        let result = { 'info': data };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance['available'])
                account['free'] = balance['available'][currency];
            if (currency in balance['blocked'])
                account['used'] = balance['blocked'][currency];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetJsonMarketOrderbook (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': orderbook['asks'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetJsonMarketTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetJsonMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '90m', since = undefined, limit = undefined) {
        return [
            ohlcv['time'] * 1000,
            parseFloat (ohlcv['open']),
            parseFloat (ohlcv['high']),
            parseFloat (ohlcv['low']),
            parseFloat (ohlcv['close']),
            parseFloat (ohlcv['vol']),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '90m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'publicGetGraphsMarket' + this.timeframes[timeframe];
        let market = this.market (symbol);
        let response = await this[method] (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'market': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        let result = {
            'info': response,
        };
        if ('id' in response['order'])
            result['id'] = response['id'];
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdrawFiat';
            if ('account' in params) {
                request['account'] = params['account']; // bank account code for withdrawal
            } else {
                throw new ExchangeError (this.id + ' requires account parameter to withdraw fiat currency');
            }
            if ('account2' in params) {
                request['account2'] = params['account2']; // bank SWIFT code (EUR only)
            } else {
                if (currency == 'EUR')
                    throw new ExchangeError (this.id + ' requires account2 parameter to withdraw EUR');
            }
            if ('withdrawal_note' in params) {
                request['withdrawal_note'] = params['withdrawal_note']; // a 10-character user-specified withdrawal note (PLN only)
            } else {
                if (currency == 'PLN')
                    throw new ExchangeError (this.id + ' requires withdrawal_note parameter to withdraw PLN');
            }
        } else {
            method = 'privatePostWithdraw';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': response,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path + '.json', params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let query = this.extend ({
                'tonce': nonce,
                'method': path,
            }, params);
            body = this.urlencode (query);
            headers = {
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],23:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitmex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitmex',
            'name': 'BitMEX',
            'countries': 'SC', // Seychelles
            'version': 'v1',
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '1h': '1h',
                '1d': '1d',
            },
            'urls': {
                'test': 'https://testnet.bitmex.com',
                'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
                'api': 'https://www.bitmex.com',
                'www': 'https://www.bitmex.com',
                'doc': [
                    'https://www.bitmex.com/app/apiOverview',
                    'https://github.com/BitMEX/api-connectors/tree/master/official-http',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'announcement',
                        'announcement/urgent',
                        'funding',
                        'instrument',
                        'instrument/active',
                        'instrument/activeAndIndices',
                        'instrument/activeIntervals',
                        'instrument/compositeIndex',
                        'instrument/indices',
                        'insurance',
                        'leaderboard',
                        'liquidation',
                        'orderBook',
                        'orderBook/L2',
                        'quote',
                        'quote/bucketed',
                        'schema',
                        'schema/websocketHelp',
                        'settlement',
                        'stats',
                        'stats/history',
                        'trade',
                        'trade/bucketed',
                    ],
                },
                'private': {
                    'get': [
                        'apiKey',
                        'chat',
                        'chat/channels',
                        'chat/connected',
                        'execution',
                        'execution/tradeHistory',
                        'notification',
                        'order',
                        'position',
                        'user',
                        'user/affiliateStatus',
                        'user/checkReferralCode',
                        'user/commission',
                        'user/depositAddress',
                        'user/margin',
                        'user/minWithdrawalFee',
                        'user/wallet',
                        'user/walletHistory',
                        'user/walletSummary',
                    ],
                    'post': [
                        'apiKey',
                        'apiKey/disable',
                        'apiKey/enable',
                        'chat',
                        'order',
                        'order/bulk',
                        'order/cancelAllAfter',
                        'order/closePosition',
                        'position/isolate',
                        'position/leverage',
                        'position/riskLimit',
                        'position/transferMargin',
                        'user/cancelWithdrawal',
                        'user/confirmEmail',
                        'user/confirmEnableTFA',
                        'user/confirmWithdrawal',
                        'user/disableTFA',
                        'user/logout',
                        'user/logoutAll',
                        'user/preferences',
                        'user/requestEnableTFA',
                        'user/requestWithdrawal',
                    ],
                    'put': [
                        'order',
                        'order/bulk',
                        'user',
                    ],
                    'delete': [
                        'apiKey',
                        'order',
                        'order/all',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetInstrumentActiveAndIndices ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let active = (market['state'] != 'Unlisted');
            let id = market['symbol'];
            let base = market['underlying'];
            let quote = market['quoteCurrency'];
            let type = undefined;
            let future = false;
            let prediction = false;
            let basequote = base + quote;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let swap = (id == basequote);
            let symbol = id;
            if (swap) {
                type = 'swap';
                symbol = base + '/' + quote;
            } else if (id.indexOf ('B_') >= 0) {
                prediction = true;
                type = 'prediction';
            } else {
                future = true;
                type = 'future';
            }
            let maker = market['makerFee'];
            let taker = market['takerFee'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'taker': taker,
                'maker': maker,
                'type': type,
                'spot': false,
                'swap': swap,
                'future': future,
                'prediction': prediction,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetUserMargin ({ 'currency': 'all' });
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let currency = balance['currency'].toUpperCase ();
            currency = this.commonCurrencyCode (currency);
            let account = {
                'free': balance['availableMargin'],
                'used': 0.0,
                'total': balance['amount'],
            };
            if (currency == 'BTC') {
                account['free'] = account['free'] * 0.00000001;
                account['total'] = account['total'] * 0.00000001;
            }
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookL2 (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let o = 0; o < orderbook.length; o++) {
            let order = orderbook[o];
            let side = (order['side'] == 'Sell') ? 'asks' : 'bids';
            let amount = order['size'];
            let price = order['price'];
            result[side].push ([ price, amount ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!market['active'])
            throw new ExchangeError (this.id + ': symbol ' + symbol + ' is delisted');
        let request = this.extend ({
            'symbol': market['id'],
            'binSize': '1d',
            'partial': true,
            'count': 1,
            'reverse': true,
        }, params);
        let quotes = await this.publicGetQuoteBucketed (request);
        let quotesLength = quotes.length;
        let quote = quotes[quotesLength - 1];
        let tickers = await this.publicGetTradeBucketed (request);
        let ticker = tickers[0];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (quote['bidPrice']),
            'ask': parseFloat (quote['askPrice']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['homeNotional']),
            'quoteVolume': parseFloat (ticker['foreignNotional']),
            'info': ticker,
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['timestamp']);
        return [
            timestamp,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // send JSON key/value pairs, such as {"key": "value"}
        // filter by individual fields and do advanced queries on timestamps
        // let filter = { 'key': 'value' };
        // send a bare series (e.g. XBU) to nearest expiring contract in that series
        // you can also send a timeframe, e.g. XBU:monthly
        // timeframes: daily, weekly, monthly, quarterly, and biquarterly
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'binSize': this.timeframes[timeframe],
            'partial': true,     // true == include yet-incomplete current bins
            // 'filter': filter, // filter by individual fields and do advanced queries
            // 'columns': [],    // will return all columns if omitted
            // 'start': 0,       // starting point for results (wtf?)
            // 'reverse': false, // true == newest first
            // 'endTime': '',    // ending date filter for results
        };
        if (since) {
            let ymdhms = this.YmdHMS (since);
            let ymdhm = ymdhms.slice (0, 16);
            request['startTime'] = ymdhm; // starting date filter for results
        }
        if (limit)
            request['count'] = limit; // default 100
        let response = await this.publicGetTradeBucketed (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let symbol = undefined;
        if (!market) {
            if ('symbol' in trade)
                market = this.markets_by_id[trade['symbol']];
        }
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['trdMatchID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'side': this.capitalize (side),
            'orderQty': amount,
            'ordType': this.capitalize (type),
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrder ({ 'orderID': id });
    }

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC')
            throw new ExchangeError (this.id + ' supoprts BTC withdrawals only, other currencies coming soon...');
        let request = {
            'currency': 'XBt', // temporarily
            'amount': amount,
            'address': address,
            // 'otpToken': '123456', // requires if two-factor auth (OTP) is enabled
            // 'fee': 0.001, // bitcoin network fee
        };
        let response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
        return {
            'info': response,
            'id': response['transactID'],
        };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('error' in response) {
                    if ('message' in response['error']) {
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/api' + '/' + this.version + '/' + path;
        if (Object.keys (params).length)
            query += '?' + this.urlencode (params);
        let url = this.urls['api'] + query;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            if (method == 'POST')
                if (Object.keys (params).length)
                    body = this.json (params);
            let request = [ method, query, nonce, body || ''].join ('');
            headers = {
                'Content-Type': 'application/json',
                'api-nonce': nonce,
                'api-key': this.apiKey,
                'api-signature': this.hmac (this.encode (request), this.encode (this.secret)),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],24:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitso extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitso',
            'name': 'Bitso',
            'countries': 'MX', // Mexico
            'rateLimit': 2000, // 30 requests per minute
            'version': 'v3',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg',
                'api': 'https://api.bitso.com',
                'www': 'https://bitso.com',
                'doc': 'https://bitso.com/api_info',
            },
            'api': {
                'public': {
                    'get': [
                        'available_books',
                        'ticker',
                        'order_book',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'account_status',
                        'balance',
                        'fees',
                        'fundings',
                        'fundings/{fid}',
                        'funding_destination',
                        'kyc_documents',
                        'ledger',
                        'ledger/trades',
                        'ledger/fees',
                        'ledger/fundings',
                        'ledger/withdrawals',
                        'mx_bank_codes',
                        'open_orders',
                        'order_trades/{oid}',
                        'orders/{oid}',
                        'user_trades',
                        'user_trades/{tid}',
                        'withdrawals/',
                        'withdrawals/{wid}',
                    ],
                    'post': [
                        'bitcoin_withdrawal',
                        'debit_card_withdrawal',
                        'ether_withdrawal',
                        'orders',
                        'phone_number',
                        'phone_verification',
                        'phone_withdrawal',
                        'spei_withdrawal',
                    ],
                    'delete': [
                        'orders/{oid}',
                        'orders/all',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetAvailableBooks ();
        let result = [];
        for (let i = 0; i < markets['payload'].length; i++) {
            let market = markets['payload'][i];
            let id = market['book'];
            let symbol = id.toUpperCase ().replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            let limits = {
                'amount': {
                    'min': parseFloat (market['minimum_amount']),
                    'max': parseFloat (market['maximum_amount']),
                },
                'price': {
                    'min': parseFloat (market['minimum_price']),
                    'max': parseFloat (market['maximum_price']),
                },
                'cost': {
                    'min': parseFloat (market['minimum_value']),
                    'max': parseFloat (market['maximum_value']),
                },
            };
            let precision = {
                'amount': this.precisionFromString (market['minimum_amount']),
                'price': this.precisionFromString (market['minimum_price']),
            };
            let lot = limits['amount']['min'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'limits': limits,
                'precision': precision,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['payload']['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'].toUpperCase ();
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['locked']),
                'total': parseFloat (balance['total']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let orderbook = response['payload'];
        let timestamp = this.parse8601 (orderbook['updated_at']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let ticker = response['payload'];
        let timestamp = this.parse8601 (ticker['created_at']);
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (!market) {
            if ('book' in trade)
                market = this.markets_by_id[trade['book']];
        }
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': trade['maker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'book': market['id'],
        }, params));
        return this.parseTrades (response['payload'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'book': this.marketId (symbol),
            'side': side,
            'type': type,
            'major': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['payload']['oid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrders ({ 'oid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/' + this.version + '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + query;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let request = [ nonce, method, query ].join ('');
            if (Object.keys (params).length) {
                body = this.json (params);
                request += body;
            }
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let auth = this.apiKey + ':' + nonce + ':' + signature;
            headers = {
                'Authorization': "Bitso " + auth,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],25:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitstamp extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitstamp',
            'name': 'Bitstamp',
            'countries': 'GB',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                'api': 'https://www.bitstamp.net/api',
                'www': 'https://www.bitstamp.net',
                'doc': 'https://www.bitstamp.net/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'order_book/{pair}/',
                        'ticker_hour/{pair}/',
                        'ticker/{pair}/',
                        'transactions/{pair}/',
                        'trading-pairs-info/',
                    ],
                },
                'private': {
                    'post': [
                        'balance/',
                        'balance/{pair}/',
                        'user_transactions/',
                        'user_transactions/{pair}/',
                        'open_orders/all/',
                        'open_orders/{pair}',
                        'order_status/',
                        'cancel_order/',
                        'buy/{pair}/',
                        'buy/market/{pair}/',
                        'sell/{pair}/',
                        'sell/market/{pair}/',
                        'ltc_withdrawal/',
                        'ltc_address/',
                        'eth_withdrawal/',
                        'eth_address/',
                        'transfer-to-main/',
                        'transfer-from-main/',
                        'xrp_withdrawal/',
                        'xrp_address/',
                        'withdrawal/open/',
                        'withdrawal/status/',
                        'withdrawal/cancel/',
                        'liquidation_address/new/',
                        'liquidation_address/info/',
                    ],
                },
                'v1': {
                    'post': [
                        'bitcoin_deposit_address/',
                        'unconfirmed_btc/',
                        'bitcoin_withdrawal/',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0025,
                    'taker': 0.0025,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTradingPairsInfo ();
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            let id = market['url_symbol'];
            let precision = {
                'amount': market['base_decimals'],
                'price': market['counter_decimals'],
            };
            let [ cost, currency ] = market['minimum_order'].split (' ');
            let active = (market['trading'] == 'Enabled');
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': parseFloat (cost),
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']) * 1000;
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']) * 1000;
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsPair (this.extend ({
            'pair': market['id'],
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            if (free in balance)
                account['free'] = parseFloat (balance[free]);
            if (used in balance)
                account['used'] = parseFloat (balance[used]);
            if (total in balance)
                account['total'] = parseFloat (balance[total]);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'pair': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'market')
            method += 'Market';
        else
            order['price'] = price;
        method += 'Pair';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'pair': pair }, params);
        let response = await this.privatePostOpenOrdersPair (request);
        return this.parseTrades (response, market);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderStatus ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api != 'v1')
            url += this.version + '/';
        url += this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],26:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitstamp1 extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitstamp1',
            'name': 'Bitstamp v1',
            'countries': 'GB',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                'api': 'https://www.bitstamp.net/api',
                'www': 'https://www.bitstamp.net',
                'doc': 'https://www.bitstamp.net/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'ticker_hour',
                        'order_book',
                        'transactions',
                        'eur_usd',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'user_transactions',
                        'open_orders',
                        'order_status',
                        'cancel_order',
                        'cancel_all_orders',
                        'buy',
                        'sell',
                        'bitcoin_deposit_address',
                        'unconfirmed_btc',
                        'ripple_withdrawal',
                        'ripple_address',
                        'withdrawal_requests',
                        'bitcoin_withdrawal',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only');
        let orderbook = await this.publicGetOrderBook (params);
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only');
        let ticker = await this.publicGetTicker (params);
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']) * 1000;
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']) * 1000;
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only');
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            account['free'] = this.safeFloat (balance, free, 0.0);
            account['used'] = this.safeFloat (balance, used, 0.0);
            account['total'] = this.safeFloat (balance, total, 0.0);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type != 'limit')
            throw new ExchangeError (this.id + ' ' + this.version + ' accepts limit orders only');
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' v1 supports BTC/USD orders only');
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'amount': amount,
            'price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'id': pair }, params);
        let response = await this.privatePostOpenOrdersId (request);
        return this.parseTrades (response, market);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        await this.loadMarkets ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}
},{"./base/Exchange":8,"./base/errors":10}],27:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InvalidOrder, InsufficientFunds, OrderNotFound } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bittrex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bittrex',
            'name': 'Bittrex',
            'countries': 'US',
            'version': 'v1.1',
            'rateLimit': 1500,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchMyTrades': false,
            'hasFetchCurrencies': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchMyTrades': false,
                'fetchCurrencies': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': 'oneMin',
                '5m': 'fiveMin',
                '30m': 'thirtyMin',
                '1h': 'hour',
                '1d': 'day',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg',
                'api': {
                    'public': 'https://bittrex.com/api',
                    'account': 'https://bittrex.com/api',
                    'market': 'https://bittrex.com/api',
                    'v2': 'https://bittrex.com/api/v2.0/pub',
                },
                'www': 'https://bittrex.com',
                'doc': [
                    'https://bittrex.com/Home/Api',
                    'https://www.npmjs.org/package/node.bittrex.api',
                ],
                'fees': [
                    'https://bittrex.com/Fees',
                    'https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-',
                ],
            },
            'api': {
                'v2': {
                    'get': [
                        'currencies/GetBTCPrice',
                        'market/GetTicks',
                        'market/GetLatestTick',
                        'Markets/GetMarketSummaries',
                        'market/GetLatestTick',
                    ],
                },
                'public': {
                    'get': [
                        'currencies',
                        'markethistory',
                        'markets',
                        'marketsummaries',
                        'marketsummary',
                        'orderbook',
                        'ticker',
                    ],
                },
                'account': {
                    'get': [
                        'balance',
                        'balances',
                        'depositaddress',
                        'deposithistory',
                        'order',
                        'orderhistory',
                        'withdrawalhistory',
                        'withdraw',
                    ],
                },
                'market': {
                    'get': [
                        'buylimit',
                        'buymarket',
                        'cancel',
                        'openorders',
                        'selllimit',
                        'sellmarket',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0025,
                    'taker': 0.0025,
                },
            },
        });
    }

    costToPrecision (symbol, cost) {
        return this.truncate (parseFloat (cost), this.markets[symbol].precision.price);
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (parseFloat (fee), this.markets[symbol]['precision']['price']);
    }

    async fetchMarkets () {
        let response = await this.v2GetMarketsGetMarketSummaries ();
        let result = [];
        for (let i = 0; i < response['result'].length; i++) {
            let market = response['result'][i]['Market'];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let amountLimits = {
                'min': market['MinTradeSize'],
                'max': undefined,
            };
            let priceLimits = { 'min': undefined, 'max': undefined };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
            };
            let active = market['IsActive'];
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'info': market,
                'lot': Math.pow (10, -precision['amount']),
                'precision': precision,
                'limits': limits,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.accountGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        let indexed = this.indexBy (balances, 'Currency');
        let keys = Object.keys (indexed);
        for (let i = 0; i < keys.length; i++) {
            let id = keys[i];
            let currency = this.commonCurrencyCode (id);
            let account = this.account ();
            let balance = indexed[id];
            let free = parseFloat (balance['Available']);
            let total = parseFloat (balance['Balance']);
            let used = total - free;
            account['free'] = free;
            account['used'] = used;
            account['total'] = total;
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'both',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['TimeStamp']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'High'),
            'low': this.safeFloat (ticker, 'Low'),
            'bid': this.safeFloat (ticker, 'Bid'),
            'ask': this.safeFloat (ticker, 'Ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'Last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'Volume'),
            'quoteVolume': this.safeFloat (ticker, 'BaseVolume'),
            'info': ticker,
        };
    }

    async fetchCurrencies () {
        let response = await this.publicGetCurrencies ();
        let currencies = response['result'];
        let result = [];
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['Currency'];
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            result.push ({
                'id': id,
                'info': currency,
                'name': currency['CurrencyLong'],
                'code': this.commonCurrencyCode (id),
                'active': currency['IsActive'],
                'fees': currency['TxFee'], // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketsummaries (params);
        let tickers = response['result'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['MarketName'];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let [ quote, base ] = id.split ('-');
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketsummary (this.extend ({
            'market': market['id'],
        }, params));
        let ticker = response['result'][0];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        let side = undefined;
        if (trade['OrderType'] == 'BUY') {
            side = 'buy';
        } else if (trade['OrderType'] == 'SELL') {
            side = 'sell';
        }
        let id = undefined;
        if ('Id' in trade)
            id = trade['Id'].toString ();
        return {
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': trade['Price'],
            'amount': trade['Quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': market['id'],
        }, params));
        if ('result' in response) {
            if (typeof response['result'] != 'undefined')
                return this.parseTrades (response['result'], market);
        }
        throw new ExchangeError (this.id + ' fetchTrades() returned undefined response');
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['T']);
        return [
            timestamp,
            ohlcv['O'],
            ohlcv['H'],
            ohlcv['L'],
            ohlcv['C'],
            ohlcv['V'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'tickInterval': this.timeframes[timeframe],
            'marketName': market['id'],
        };
        let response = await this.v2GetMarketGetTicks (this.extend (request, params));
        return this.parseOHLCVs (response['result'], market, timeframe, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['market'] = market['id'];
        }
        let response = await this.marketGetOpenorders (this.extend (request, params));
        let orders = this.parseOrders (response['result'], market);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'marketGet' + this.capitalize (side) + type;
        let order = {
            'market': market['id'],
            'quantity': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['rate'] = this.priceToPrecision (symbol, price);
        let response = await this[method] (this.extend (order, params));
        let result = {
            'info': response,
            'id': response['result']['uuid'],
        };
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.marketGetCancel (this.extend ({
                'uuid': id,
            }, params));
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'message');
                if (message == 'ORDER_NOT_OPEN')
                    throw new InvalidOrder (this.id + ' cancelOrder() error: ' + this.last_http_response);
                if (message == 'UUID_INVALID')
                    throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        if ('OrderType' in order)
            side = (order['OrderType'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        if ('Type' in order)
            side = (order['Type'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        let status = 'open';
        if (order['Closed']) {
            status = 'closed';
        } else if (order['CancelInitiated']) {
            status = 'canceled';
        }
        let symbol = undefined;
        if (!market) {
            if ('Exchange' in order)
                if (order['Exchange'] in this.markets_by_id)
                    market = this.markets_by_id[order['Exchange']];
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = undefined;
        if ('Opened' in order)
            timestamp = this.parse8601 (order['Opened']);
        if ('TimeStamp' in order)
            timestamp = this.parse8601 (order['TimeStamp']);
        let fee = undefined;
        let commission = undefined;
        if ('Commission' in order) {
            commission = 'Commission';
        } else if ('CommissionPaid' in order) {
            commission = 'CommissionPaid';
        }
        if (commission) {
            fee = {
                'cost': parseFloat (order[commission]),
                'currency': market['quote'],
            };
        }
        let price = this.safeFloat (order, 'Limit');
        let cost = this.safeFloat (order, 'Price');
        let amount = this.safeFloat (order, 'Quantity');
        let remaining = this.safeFloat (order, 'QuantityRemaining', 0.0);
        let filled = amount - remaining;
        if (!cost) {
            if (price && amount)
                cost = price * amount;
        }
        if (!price) {
            if (cost && filled)
                price = cost / filled;
        }
        let average = this.safeFloat (order, 'PricePerUnit');
        let result = {
            'info': order,
            'id': order['OrderUuid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        };
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.accountGetOrder ({ 'uuid': id });
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'message');
                if (message == 'UUID_INVALID')
                    throw new OrderNotFound (this.id + ' fetchOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return this.parseOrder (response['result']);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['market'] = market['id'];
        }
        let response = await this.accountGetOrderhistory (this.extend (request, params));
        let orders = this.parseOrders (response['result'], market);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        return this.filterBy (orders, 'status', 'closed');
    }

    currencyId (currency) {
        if (currency == 'BCH')
            return 'BCC';
        return currency;
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.accountGetDepositaddress (this.extend ({
            'currency': currencyId,
        }, params));
        let address = this.safeString (response['result'], 'Address');
        let message = this.safeString (response, 'message');
        let status = 'ok';
        if (!address || message == 'ADDRESS_GENERATING')
            status = 'pending';
        return {
            'currency': currency,
            'address': address,
            'status': status,
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.accountGetWithdraw (this.extend ({
            'currency': currencyId,
            'quantity': amount,
            'address': address,
        }, params));
        let id = undefined;
        if ('result' in response) {
            if ('uuid' in response['result'])
                id = response['result']['uuid'];
        }
        return {
            'info': response,
            'id': id,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api != 'v2')
            url += this.version + '/';
        if (api == 'public') {
            url += api + '/' + method.toLowerCase () + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else if (api == 'v2') {
            url += path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += api + '/';
            if (((api == 'account') && (path != 'withdraw')) || (path == 'openorders'))
                url += method.toLowerCase ();
            url += path + '?' + this.urlencode (this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, params));
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512');
            headers = { 'apisign': signature };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code >= 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('success' in response) {
                    if (!response['success']) {
                        if ('message' in response) {
                            if (response['message'] == 'MIN_TRADE_REQUIREMENT_NOT_MET')
                                throw new InvalidOrder (this.id + ' ' + this.json (response));
                            if (response['message'] == 'APIKEY_INVALID')
                                throw new AuthenticationError (this.id + ' ' + this.json (response));
                        }
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (response['success'])
                return response;
        }
        if ('message' in response) {
            if (response['message'] == 'ADDRESS_GENERATING')
                return response;
            if (response['message'] == "INSUFFICIENT_FUNDS")
                throw new InsufficientFunds (this.id + ' ' + this.json (response));
        }
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],28:[function(require,module,exports){
"use strict"

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

// ---------------------------------------------------------------------------

module.exports = class bl3p extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bl3p',
            'name': 'BL3P',
            'countries': [ 'NL', 'EU' ], // Netherlands, EU
            'rateLimit': 1000,
            'version': '1',
            'comment': 'An exchange market by BitonicNL',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
                'api': 'https://api.bl3p.eu',
                'www': [
                    'https://bl3p.eu',
                    'https://bitonic.nl',
                ],
                'doc': [
                    'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
                    'https://bl3p.eu/api',
                    'https://bitonic.nl/en/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{market}/ticker',
                        '{market}/orderbook',
                        '{market}/trades',
                    ],
                },
                'private': {
                    'post': [
                        '{market}/money/depth/full',
                        '{market}/money/order/add',
                        '{market}/money/order/cancel',
                        '{market}/money/order/result',
                        '{market}/money/orders',
                        '{market}/money/orders/history',
                        '{market}/money/trades/fetch',
                        'GENMKT/money/info',
                        'GENMKT/money/deposit_address',
                        'GENMKT/money/new_deposit_address',
                        'GENMKT/money/wallet/history',
                        'GENMKT/money/withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                // 'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGENMKTMoneyInfo ();
        let data = response['data'];
        let balance = data['wallets'];
        let result = { 'info': data };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                if ('available' in balance[currency]) {
                    account['free'] = parseFloat (balance[currency]['available']['value']);
                }
            }
            if (currency in balance) {
                if ('balance' in balance[currency]) {
                    account['total'] = parseFloat (balance[currency]['balance']['value']);
                }
            }
            if (account['total']) {
                if (account['free']) {
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    parseBidAsk (bidask, priceKey = 0, amountKey = 0) {
        return [
            bidask['price_int'] / 100000.0,
            bidask['amount_int'] / 100000000.0,
        ];
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderbook (this.extend ({
            'market': market['id'],
        }, params));
        let orderbook = response['data'];
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetMarketTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']['24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        return {
            'id': trade['trade_id'],
            'info': trade,
            'timestamp': trade['date'],
            'datetime': this.iso8601 (trade['date']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price_int'] / 100000.0,
            'amount': trade['amount_int'] / 100000000.0,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        let result = this.parseTrades (response['data']['trades'], market);
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'market': market['id'],
            'amount_int': amount,
            'fee_currency': market['quote'],
            'type': (side == 'buy') ? 'bid' : 'ask',
        };
        if (type == 'limit')
            order['price_int'] = price;
        let response = await this.privatePostMarketMoneyOrderAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostMarketMoneyOrderCancel ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],29:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bittrex = require ('./bittrex.js')

// ---------------------------------------------------------------------------

module.exports = class bleutrade extends bittrex {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bleutrade',
            'name': 'Bleutrade',
            'countries': 'BR', // Brazil
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg',
                'api': {
                    'public': 'https://bleutrade.com/api',
                    'account': 'https://bleutrade.com/api',
                    'market': 'https://bleutrade.com/api',
                },
                'www': 'https://bleutrade.com',
                'doc': 'https://bleutrade.com/help/API',
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'ALL',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }
}

},{"./bittrex.js":27}],30:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcbox extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcbox',
            'name': 'BtcBox',
            'countries': 'JP',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31275803-4df755a8-aaa1-11e7-9abb-11ec2fad9f2d.jpg',
                'api': 'https://www.btcbox.co.jp/api',
                'www': 'https://www.btcbox.co.jp/',
                'doc': 'https://www.btcbox.co.jp/help/asm',
            },
            'api': {
                'public': {
                    'get': [
                        'depth',
                        'orders',
                        'ticker',
                        'allticker',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'trade_add',
                        'trade_cancel',
                        'trade_list',
                        'trade_view',
                        'wallet',
                    ],
                },
            },
            'markets': {
                'BTC/JPY': { 'id': 'BTC/JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            if (lowercase == 'dash')
                lowercase = 'drk';
            let account = this.account ();
            let free = lowercase + '_balance';
            let used = lowercase + '_lock';
            if (free in balances)
                account['free'] = parseFloat (balances[free]);
            if (used in balances)
                account['used'] = parseFloat (balances[used]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let orderbook = await this.publicGetDepth (this.extend (request, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'vol'),
            'quoteVolume': this.safeFloat (ticker, 'volume'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetAllticker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let ticker = await this.publicGetTicker (this.extend (request, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let response = await this.publicGetOrders (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'amount': amount,
            'price': price,
            'type': side,
        };
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let response = await this.privatePostTradeAdd (this.extend (request, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostTradeCancel (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, params);
            let request = this.urlencode (query);
            let secret = this.hash (this.encode (this.secret));
            query['signature'] = this.hmac (this.encode (request), this.encode (secret));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],31:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcchina extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcchina',
            'name': 'BTCChina',
            'countries': 'CN',
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg',
                'api': {
                    'plus': 'https://plus-api.btcchina.com/market',
                    'public': 'https://data.btcchina.com/data',
                    'private': 'https://api.btcchina.com/api_trade_v1.php',
                },
                'www': 'https://www.btcchina.com',
                'doc': 'https://www.btcchina.com/apidocs'
            },
            'api': {
                'plus': {
                    'get': [
                        'orderbook',
                        'ticker',
                        'trade',
                    ],
                },
                'public': {
                    'get': [
                        'historydata',
                        'orderbook',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'BuyIcebergOrder',
                        'BuyOrder',
                        'BuyOrder2',
                        'BuyStopOrder',
                        'CancelIcebergOrder',
                        'CancelOrder',
                        'CancelStopOrder',
                        'GetAccountInfo',
                        'getArchivedOrder',
                        'getArchivedOrders',
                        'GetDeposits',
                        'GetIcebergOrder',
                        'GetIcebergOrders',
                        'GetMarketDepth',
                        'GetMarketDepth2',
                        'GetOrder',
                        'GetOrders',
                        'GetStopOrder',
                        'GetStopOrders',
                        'GetTransactions',
                        'GetWithdrawal',
                        'GetWithdrawals',
                        'RequestWithdrawal',
                        'SellIcebergOrder',
                        'SellOrder',
                        'SellOrder2',
                        'SellStopOrder',
                    ],
                },
            },
            'markets': {
                'BTC/CNY': { 'id': 'btccny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                'LTC/CNY': { 'id': 'ltccny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'api': 'public', 'plus': false },
                'BCH/CNY': { 'id': 'bcccny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
                'ETH/CNY': { 'id': 'ethcny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ({
            'market': 'all',
        });
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let key = keys[p];
            let market = markets[key];
            let parts = key.split ('_');
            let id = parts[1];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances['balance'])
                account['total'] = parseFloat (balances['balance'][lowercase]['amount']);
            if (lowercase in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][lowercase]['amount']);
            account['free'] = account['total'] - account['used'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    createMarketRequest (market) {
        let request = {};
        let field = (market['plus']) ? 'symbol' : 'market';
        request[field] = market['id'];
        return request;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetOrderbook';
        let request = this.createMarketRequest (market);
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = orderbook['date'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market) {
        let timestamp = ticker['date'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['prev_close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTickerPlus (ticker, market) {
        let timestamp = ticker['Timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['PrevCls']),
            'first': undefined,
            'last': parseFloat (ticker['Last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['Volume24H']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTicker';
        let request = this.createMarketRequest (market);
        let tickers = await this[method] (this.extend (request, params));
        let ticker = tickers['ticker'];
        if (market['plus'])
            return this.parseTickerPlus (ticker, market);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    parseTradePlus (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    parseTradesPlus (trades, market = undefined) {
        let result = [];
        for (let i = 0; i < trades.length; i++) {
            result.push (this.parseTradePlus (trades[i], market));
        }
        return result;
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTrade';
        let request = this.createMarketRequest (market);
        if (market['plus']) {
            let now = this.milliseconds ();
            request['start_time'] = now - 86400 * 1000;
            request['end_time'] = now;
        } else {
            method += 's'; // trades vs trade
        }
        let response = await this[method] (this.extend (request, params));
        if (market['plus']) {
            return this.parseTradesPlus (response['trades'], market);
        }
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Order2';
        let order = {};
        let id = market['id'].toUpperCase ();
        if (type == 'market') {
            order['params'] = [ undefined, amount, id ];
        } else {
            order['params'] = [ price, amount, id ];
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = params['market']; // TODO fixme
        return await this.privatePostCancelOrder (this.extend ({
            'params': [ id, market ],
        }, params));
    }

    nonce () {
        return this.microseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let p = [];
            if ('params' in params)
                p = params['params'];
            let nonce = this.nonce ();
            let request = {
                'method': path,
                'id': nonce,
                'params': p,
            };
            p = p.join (',');
            body = this.json (request);
            let query = (
                'tonce=' + nonce +
                '&accesskey=' + this.apiKey +
                '&requestmethod=' + method.toLowerCase () +
                '&id=' + nonce +
                '&method=' + path +
                '&params=' + p
            );
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha1');
            let auth = this.apiKey + ':' + signature;
            headers = {
                'Authorization': 'Basic ' + this.stringToBase64 (auth),
                'Json-Rpc-Tonce': nonce,
            };
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],32:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const btcturk = require ('./btcturk.js')

// ---------------------------------------------------------------------------

module.exports = class btcexchange extends btcturk {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcexchange',
            'name': 'BTCExchange',
            'countries': 'PH', // Philippines
            'rateLimit': 1500,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27993052-4c92911a-64aa-11e7-96d8-ec6ac3435757.jpg',
                'api': 'https://www.btcexchange.ph/api',
                'www': 'https://www.btcexchange.ph',
                'doc': 'https://github.com/BTCTrader/broker-api-docs',
            },
            'markets': {
                'BTC/PHP': { 'id': 'BTC/PHP', 'symbol': 'BTC/PHP', 'base': 'BTC', 'quote': 'PHP' },
            },
        });
    }
}

},{"./btcturk.js":35}],33:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcmarkets extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcmarkets',
            'name': 'BTC Markets',
            'countries': 'AU', // Australia
            'rateLimit': 1000, // market data cached for 1 second (trades cached for 2 seconds)
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg',
                'api': 'https://api.btcmarkets.net',
                'www': 'https://btcmarkets.net/',
                'doc': 'https://github.com/BTCMarkets/API',
            },
            'api': {
                'public': {
                    'get': [
                        'market/{id}/tick',
                        'market/{id}/orderbook',
                        'market/{id}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'account/balance',
                        'account/{id}/tradingfee',
                    ],
                    'post': [
                        'fundtransfer/withdrawCrypto',
                        'fundtransfer/withdrawEFT',
                        'order/create',
                        'order/cancel',
                        'order/history',
                        'order/open',
                        'order/trade/history',
                        'order/createBatch', // they promise it's coming soon...
                        'order/detail',
                    ],
                },
            },
            'markets': {
                'BTC/AUD': { 'id': 'BTC/AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'LTC/AUD': { 'id': 'LTC/AUD', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'ETH/AUD': { 'id': 'ETH/AUD', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'ETC/AUD': { 'id': 'ETC/AUD', 'symbol': 'ETC/AUD', 'base': 'ETC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'XRP/AUD': { 'id': 'XRP/AUD', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'BCH/AUD': { 'id': 'BCH/AUD', 'symbol': 'BCH/AUD', 'base': 'BCH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'LTC/BTC': { 'id': 'LTC/BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'ETH/BTC': { 'id': 'ETH/BTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'ETC/BTC': { 'id': 'ETC/BTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'XRP/BTC': { 'id': 'XRP/BTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'BCH/BTC': { 'id': 'BCH/BTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let multiplier = 100000000;
            let free = parseFloat (balance['balance'] / multiplier);
            let used = parseFloat (balance['pendingFunds'] / multiplier);
            let account = {
                'free': free,
                'used': used,
                'total': this.sum (free, used),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetMarketIdOrderbook (this.extend ({
            'id': market['id'],
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bestBid']),
            'ask': parseFloat (ticker['bestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetMarketIdTick (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketIdTrades (this.extend ({
            // 'since': 59868345231,
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let multiplier = 100000000; // for price and volume
        // does BTC Markets support market orders at all?
        let orderSide = (side == 'buy') ? 'Bid' : 'Ask';
        let order = this.ordered ({
            'currency': market['quote'],
            'instrument': market['base'],
            'price': price * multiplier,
            'volume': amount * multiplier,
            'orderSide': orderSide,
            'ordertype': this.capitalize (type),
            'clientRequestId': this.nonce ().toString (),
        });
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrders (ids) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_ids': ids });
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.cancelOrders ([ id ]);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let uri = '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + uri;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = uri + "\n" + nonce + "\n";
            headers = {
                'Content-Type': 'application/json',
                'apikey': this.apiKey,
                'timestamp': nonce,
            };
            if (method == 'POST') {
                body = this.urlencode (query);
                auth += body;
            }
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers['signature'] = this.decode (signature);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private') {
            if ('success' in response)
                if (!response['success'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
            return response;
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],34:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btctradeua extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btctradeua',
            'name': 'BTC Trade UA',
            'countries': 'UA', // Ukraine,
            'rateLimit': 3000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
                'api': 'https://btc-trade.com.ua/api',
                'www': 'https://btc-trade.com.ua',
                'doc': 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit',
            },
            'api': {
                'public': {
                    'get': [
                        'deals/{symbol}',
                        'trades/sell/{symbol}',
                        'trades/buy/{symbol}',
                        'japan_stat/high/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'auth',
                        'ask/{symbol}',
                        'balance',
                        'bid/{symbol}',
                        'buy/{symbol}',
                        'my_orders/{symbol}',
                        'order/status/{id}',
                        'remove/order/{id}',
                        'sell/{symbol}',
                    ],
                },
            },
            'markets': {
                'BTC/UAH': { 'id': 'btc_uah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'precision': { 'price': 1 }, 'limits': { 'amount': { 'min': 0.0000000001 }}},
                'ETH/UAH': { 'id': 'eth_uah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH' },
                'LTC/UAH': { 'id': 'ltc_uah', 'symbol': 'LTC/UAH', 'base': 'LTC', 'quote': 'UAH' },
                'DOGE/UAH': { 'id': 'doge_uah', 'symbol': 'DOGE/UAH', 'base': 'DOGE', 'quote': 'UAH' },
                'DASH/UAH': { 'id': 'dash_uah', 'symbol': 'DASH/UAH', 'base': 'DASH', 'quote': 'UAH' },
                'SIB/UAH': { 'id': 'sib_uah', 'symbol': 'SIB/UAH', 'base': 'SIB', 'quote': 'UAH' },
                'KRB/UAH': { 'id': 'krb_uah', 'symbol': 'KRB/UAH', 'base': 'KRB', 'quote': 'UAH' },
                'NVC/UAH': { 'id': 'nvc_uah', 'symbol': 'NVC/UAH', 'base': 'NVC', 'quote': 'UAH' },
                'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'NVC/BTC': { 'id': 'nvc_btc', 'symbol': 'NVC/BTC', 'base': 'NVC', 'quote': 'BTC' },
                'ITI/UAH': { 'id': 'iti_uah', 'symbol': 'ITI/UAH', 'base': 'ITI', 'quote': 'UAH' },
                'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
                'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.1 / 100,
                    'taker': 0.1 / 100,
                },
            },
        });
    }

    signIn () {
        return this.privatePostAuth ();
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        if ('accounts' in response) {
            let accounts = response['accounts'];
            for (let b = 0; b < accounts.length; b++) {
                let account = accounts[b];
                let currency = account['currency'];
                let balance = parseFloat (account['balance']);
                result[currency] = {
                    'free': balance,
                    'used': 0.0,
                    'total': balance,
                };
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let bids = await this.publicGetTradesBuySymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let asks = await this.publicGetTradesSellSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let orderbook = {
            'bids': [],
            'asks': [],
        };
        if (bids) {
            if ('list' in bids)
                orderbook['bids'] = bids['list'];
        }
        if (asks) {
            if ('list' in asks)
                orderbook['asks'] = asks['list'];
        }
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'currency_trade');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetJapanStatHighSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let orderbook = await this.fetchOrderBook (symbol);
        let bid = undefined;
        let numBids = orderbook['bids'].length;
        if (numBids > 0)
            bid = orderbook['bids'][0][0];
        let ask = undefined;
        let numAsks = orderbook['asks'].length;
        if (numAsks > 0)
            ask = orderbook['asks'][0][0];
        let ticker = response['trades'];
        let timestamp = this.milliseconds ();
        let result = {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
        let tickerLength = ticker.length;
        if (tickerLength > 0) {
            let start = Math.max (tickerLength - 48, 0);
            for (let t = start; t < ticker.length; t++) {
                let candle = ticker[t];
                if (typeof result['open'] == 'undefined')
                    result['open'] = candle[1];
                if ((typeof result['high'] == 'undefined') || (result['high'] < candle[2]))
                    result['high'] = candle[2];
                if ((typeof result['low'] == 'undefined') || (result['low'] > candle[3]))
                    result['low'] = candle[3];
                if (typeof result['baseVolume'] == 'undefined')
                    result['baseVolume'] = -candle[5];
                else
                    result['baseVolume'] -= candle[5];
            }
            let last = tickerLength - 1;
            result['close'] = ticker[last][4];
            result['baseVolume'] = -1 * result['baseVolume'];
        }
        return result;
    }

    convertCyrillicMonthNameToString (cyrillic) {
        let months = [
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
        ];
        let month = undefined;
        for (let i = 0; i < months.length; i++) {
            if (cyrillic == months[i]) {
                month = i + 1;
                month = month.toString ();
                if (i < 9)
                    month = '0' + month;
            }
        }
        return month;
    }

    parseCyrillicDatetime (cyrillic) {
        let parts = cyrillic.split (' ');
        let day = parts[0];
        let month = this.convertCyrillicMonthNameToString (parts[1]);
        if (!month)
            throw new ExchangeError (this.id + ' parseTrade() undefined month name: ' + cyrillic);
        let year = parts[2];
        let hms = parts[4];
        let hmsLength = hms.length;
        if (hmsLength == 7) {
            hms = '0' + hms;
        }
        let ymd = [ year, month, day ].join ('-');
        let ymdhms = ymd + 'T' + hms;
        let timestamp = this.parse8601 (ymdhms);
        timestamp = timestamp - 10800000; // server reports local GMT+3 time, adjust to UTC
        return timestamp;
    }

    parseTrade (trade, market) {
        let timestamp = this.parseCyrillicDatetime (trade['pub_date']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amnt_trade']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDealsSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let trades = [];
        for (let i = 0; i < response.length; i++) {
            if (response[i]['id'] % 2) {
                trades.push (response[i]);
            }
        }
        return this.parseTrades (trades, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Id';
        let order = {
            'count': amount,
            'currency1': market['quote'],
            'currency': market['base'],
            'price': price,
        };
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostRemoveOrderId ({ 'id': id });
    }

    parseOrder (trade, market) {
        let timestamp = this.milliseconds;
        return {
            'id': trade['id'],
            'timestamp': timestamp, // until they fix their timestamp
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amnt_trade'],
            'filled': 0,
            'remaining': trade['amnt_trade'],
            'trades': undefined,
            'info': trade,
        };
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        let market = this.market (symbol);
        let response = await this.privatePostMyOrdersSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let orders = response['your_open_orders'];
        return this.parseOrders (orders, market);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += this.implodeParams (path, query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'out_order_id': nonce,
                'nonce': nonce,
            }, query));
            let auth = body + this.secret;
            headers = {
                'public-key': this.apiKey,
                'api-sign': this.hash (this.encode (auth), 'sha256'),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],35:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcturk extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcturk',
            'name': 'BTCTurk',
            'countries': 'TR', // Turkey
            'rateLimit': 1000,
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1d': '1d',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg',
                'api': 'https://www.btcturk.com/api',
                'www': 'https://www.btcturk.com',
                'doc': 'https://github.com/BTCTrader/broker-api-docs',
            },
            'api': {
                'public': {
                    'get': [
                        'ohlcdata', // ?last=COUNT
                        'orderbook',
                        'ticker',
                        'trades',   // ?last=COUNT (max 50)
                    ],
                },
                'private': {
                    'get': [
                        'balance',
                        'openOrders',
                        'userTransactions', // ?offset=0&limit=25&sort=asc
                    ],
                    'post': [
                        'buy',
                        'cancelOrder',
                        'sell',
                    ],
                },
            },
            'markets': {
                'BTC/TRY': { 'id': 'BTCTRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                'ETH/TRY': { 'id': 'ETHTRY', 'symbol': 'ETH/TRY', 'base': 'ETH', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalance ();
        let result = { 'info': response };
        let base = {
            'free': response['bitcoin_available'],
            'used': response['bitcoin_reserved'],
            'total': response['bitcoin_balance'],
        };
        let quote = {
            'free': response['money_available'],
            'used': response['money_reserved'],
            'total': response['money_balance'],
        };
        let symbol = this.symbols[0];
        let market = this.markets[symbol];
        result[market['base']] = base;
        result[market['quote']] = quote;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pairSymbol': market['id'],
        }, params));
        let timestamp = parseInt (orderbook['timestamp'] * 1000);
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['average']),
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let symbol = ticker['pair'];
            let market = undefined;
            if (symbol in this.markets_by_id) {
                market = this.markets_by_id[symbol];
                symbol = market['symbol'];
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.fetchTickers ();
        let result = undefined;
        if (symbol in tickers)
            result = tickers[symbol];
        return result;
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        // let maxCount = 50;
        let response = await this.publicGetTrades (this.extend ({
            'pairSymbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['Time']);
        return [
            timestamp,
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        if (limit)
            request['last'] = limit;
        let response = await this.publicGetOhlcdata (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'Type': (side == 'buy') ? 'BuyBtc' : 'SelBtc',
            'IsMarketOrder': (type == 'market') ? 1 : 0,
        };
        if (type == 'market') {
            if (side == 'buy')
                order['Total'] = amount;
            else
                order['Amount'] = amount;
        } else {
            order['Price'] = price;
            order['Amount'] = amount;
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'btctrader')
            throw new ExchangeError (this.id + ' is an abstract base API for BTCExchange, BTCTurk');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.urlencode (params);
            let secret = this.base64ToBinary (this.secret);
            let auth = this.apiKey + nonce;
            headers = {
                'X-PCK': this.apiKey,
                'X-Stamp': nonce,
                'X-Signature': this.stringToBase64(this.hmac (this.encode (auth), secret, 'sha256', 'binary')),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],36:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcx',
            'name': 'BTCX',
            'countries': [ 'IS', 'US', 'EU' ],
            'rateLimit': 1500, // support in english is very poor, unable to tell rate limits
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766385-9fdcc98c-5ed6-11e7-8f14-66d5e5cd47e6.jpg',
                'api': 'https://btc-x.is/api',
                'www': 'https://btc-x.is',
                'doc': 'https://btc-x.is/custom/api-document.html',
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{id}/{limit}',
                        'ticker/{id}',
                        'trade/{id}/{limit}',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'cancel',
                        'history',
                        'order',
                        'redeem',
                        'trade',
                        'withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btc/usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'btc/eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balances[currency],
                'used': 0.0,
                'total': balances[currency],
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetDepthIdLimit (this.extend ({
            'id': this.marketId (symbol),
            'limit': 1000,
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTickerId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = ticker['time'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['sell']),
            'ask': parseFloat (ticker['buy']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTradeIdLimit (this.extend ({
            'id': market['id'],
            'limit': 1000,
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'type': side.toUpperCase (),
            'market': this.marketId (symbol),
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['order']['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'order': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'public') {
            url += this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += api;
            body = this.urlencode (this.extend ({
                'Method': path.toUpperCase (),
                'Nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Signature': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],37:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bter extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bter',
            'name': 'Bter',
            'countries': [ 'VG', 'CN' ], // British Virgin Islands, China
            'version': '2',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27980479-cfa3188c-6387-11e7-8191-93fc4184ba5c.jpg',
                'api': {
                    'public': 'https://data.bter.com/api',
                    'private': 'https://api.bter.com/api',
                },
                'www': 'https://bter.com',
                'doc': 'https://bter.com/api2',
            },
            'api': {
                'public': {
                    'get': [
                        'pairs',
                        'marketinfo',
                        'marketlist',
                        'tickers',
                        'ticker/{id}',
                        'orderBook/{id}',
                        'trade/{id}',
                        'tradeHistory/{id}',
                        'tradeHistory/{id}/{tid}',
                    ],
                },
                'private': {
                    'post': [
                        'balances',
                        'depositAddress',
                        'newAddress',
                        'depositsWithdrawals',
                        'buy',
                        'sell',
                        'cancelOrder',
                        'cancelAllOrders',
                        'getOrder',
                        'openOrders',
                        'tradeHistory',
                        'withdraw',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetMarketinfo ();
        let markets = response['pairs'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let keys = Object.keys (market);
            let id = keys[0];
            let details = market[id];
            let [ base, quote ] = id.split ('_');
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': details['decimal_places'],
                'price': details['decimal_places'],
            };
            let amountLimits = {
                'min': details['min_amount'],
                'max': undefined,
            };
            let priceLimits = {
                'min': undefined,
                'max': undefined,
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
            };
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': details['fee'] / 100,
                'taker': details['fee'] / 100,
                'precision': precision,
                'limits': limits,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privatePostBalances ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let code = this.commonCurrencyCode (currency);
            let account = this.account ();
            if ('available' in balance) {
                if (currency in balance['available']) {
                    account['free'] = parseFloat (balance['available'][currency]);
                }
            }
            if ('locked' in balance) {
                if (currency in balance['locked']) {
                    account['used'] = parseFloat (balance['locked'][currency]);
                }
            }
            account['total'] = this.sum (account['free'], account['used']);
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['quoteVolume']),
            'quoteVolume': parseFloat (ticker['baseVolume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let [ baseId, quoteId ] = id.split ('_');
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let ticker = tickers[id];
            let market = undefined;
            if (symbol in this.markets)
                market = this.markets[symbol];
            if (id in this.markets_by_id)
                market = this.markets_by_id[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['date']);
        return {
            'id': trade['tradeID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['rate'],
            'amount': this.safeFloat (trade, 'amount'),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradeHistoryId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['data'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
            'rate': price,
            'amount': amount,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderNumber'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'orderNumber': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'amount': amount,
            'address': address, // Address must exist in you AddressBook in security settings
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let prefix = (api == 'private') ? (api + '/') : '';
        let url = this.urls['api'][api] + this.version + '/1/' + prefix + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = { 'nonce': nonce };
            body = this.urlencode (this.extend (request, query));
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
            headers = {
                'Key': this.apiKey,
                'Sign': signature,
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] != 'true')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],38:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bxinth extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bxinth',
            'name': 'BX.in.th',
            'countries': 'TH', // Thailand
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766412-567b1eb4-5ed7-11e7-94a8-ff6a3884f6c5.jpg',
                'api': 'https://bx.in.th/api',
                'www': 'https://bx.in.th',
                'doc': 'https://bx.in.th/info/api',
            },
            'api': {
                'public': {
                    'get': [
                        '', // ticker
                        'options',
                        'optionbook',
                        'orderbook',
                        'pairing',
                        'trade',
                        'tradehistory',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'biller',
                        'billgroup',
                        'billpay',
                        'cancel',
                        'deposit',
                        'getorders',
                        'history',
                        'option-issue',
                        'option-bid',
                        'option-sell',
                        'option-myissue',
                        'option-mybid',
                        'option-myoptions',
                        'option-exercise',
                        'option-cancel',
                        'option-history',
                        'order',
                        'withdrawal',
                        'withdrawal-history',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.25 / 100,
                    'maker': 0.25 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairing ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['pairing_id'].toString ();
            let base = market['secondary_currency'];
            let quote = market['primary_currency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    commonCurrencyCode (currency) {
        // why would they use three letters instead of four for currency codes
        if (currency == 'DAS')
            return 'DASH';
        if (currency == 'DOG')
            return 'DOGE';
        return currency;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balance = response['balance'];
        let result = { 'info': balance };
        let currencies = Object.keys (balance);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = this.commonCurrencyCode (currency);
            let account = {
                'free': parseFloat (balance[currency]['available']),
                'used': 0.0,
                'total': parseFloat (balance[currency]['total']),
            };
            account['used'] = account['total'] - account['free'];
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pairing': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['orderbook']['bids']['highbid']),
            'ask': parseFloat (ticker['orderbook']['asks']['highbid']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_24hours']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGet (params);
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGet (this.extend ({
            'pairing': market['id'],
        }, params));
        let id = market['id'].toString ();
        let ticker = tickers[id];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['trade_date']);
        return {
            'id': trade['trade_id'],
            'info': trade,
            'order': trade['order_id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['trade_type'],
            'price': parseFloat (trade['rate']),
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'pairing': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrder (this.extend ({
            'pairing': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let pairing = undefined; // TODO fixme
        return await this.privatePostCancel ({
            'order_id': id,
            'pairing': pairing,
        });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (path)
            url += path + '/';
        if (Object.keys (params).length)
            url += '?' + this.urlencode (params);
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = this.apiKey + nonce.toString () + this.secret;
            let signature = this.hash (this.encode (auth), 'sha256');
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
                // twofa: this.twofa,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],39:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class ccex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'ccex',
            'name': 'C-CEX',
            'countries': [ 'DE', 'EU' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766433-16881f90-5ed8-11e7-92f8-3d92cc747a6c.jpg',
                'api': {
                    'tickers': 'https://c-cex.com/t',
                    'public': 'https://c-cex.com/t/api_pub.html',
                    'private': 'https://c-cex.com/t/api.html',
                },
                'www': 'https://c-cex.com',
                'doc': 'https://c-cex.com/?id=api',
            },
            'api': {
                'tickers': {
                    'get': [
                        'coinnames',
                        '{market}',
                        'pairs',
                        'prices',
                        'volume_{coin}',
                    ],
                },
                'public': {
                    'get': [
                        'balancedistribution',
                        'markethistory',
                        'markets',
                        'marketsummaries',
                        'orderbook',
                    ],
                },
                'private': {
                    'get': [
                        'buylimit',
                        'cancel',
                        'getbalance',
                        'getbalances',
                        'getopenorders',
                        'getorder',
                        'getorderhistory',
                        'mytrades',
                        'selllimit',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.2 / 100,
                    'maker': 0.2 / 100,
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'IOT')
            return 'IoTcoin';
        if (currency == 'BLC')
            return 'Cryptobullcoin';
        if (currency == 'XID')
            return 'InternationalDiamond';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets['result'].length; p++) {
            let market = markets['result'][p];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['Currency'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': balance['Available'],
                'used': balance['Pending'],
                'total': balance['Balance'],
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'both',
            'depth': 100,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastprice']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'buysupport'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.tickersGetPrices (params);
        let result = { 'info': tickers };
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let uppercase = id.toUpperCase ();
            let market = undefined;
            let symbol = undefined;
            if (uppercase in this.markets_by_id) {
                market = this.markets_by_id[uppercase];
                symbol = market['symbol'];
            } else {
                let [ base, quote ] = uppercase.split ('-');
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.tickersGetMarket (this.extend ({
            'market': market['id'].toLowerCase (),
        }, params));
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        return {
            'id': trade['Id'],
            'info': trade,
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['OrderType'].toLowerCase (),
            'price': trade['Price'],
            'amount': trade['Quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': market['id'],
            'type': 'both',
            'depth': 100,
        }, params));
        return this.parseTrades (response['result'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privateGet' + this.capitalize (side) + type;
        let response = await this[method] (this.extend ({
            'market': this.marketId (symbol),
            'quantity': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateGetCancel ({ 'uuid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.keysort (this.extend ({
                'a': path,
                'apikey': this.apiKey,
                'nonce': nonce,
            }, params));
            url += '?' + this.urlencode (query);
            headers = { 'apisign': this.hmac (this.encode (url), this.encode (this.secret), 'sha512') };
        } else if (api == 'public') {
            url += '?' + this.urlencode (this.extend ({
                'a': 'get' + path,
            }, params));
        } else {
            url += '/' + this.implodeParams (path, params) + '.json';
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'tickers')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],40:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class cex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'cex',
            'name': 'CEX.IO',
            'countries': [ 'GB', 'EU', 'CY', 'RU' ],
            'rateLimit': 1500,
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOpenOrders': true,
            'timeframes': {
                '1m': '1m',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
                'api': 'https://cex.io/api',
                'www': 'https://cex.io',
                'doc': 'https://cex.io/cex-api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currency_limits/',
                        'last_price/{pair}/',
                        'last_prices/{currencies}/',
                        'ohlcv/hd/{yyyymmdd}/{pair}',
                        'order_book/{pair}/',
                        'ticker/{pair}/',
                        'tickers/{currencies}/',
                        'trade_history/{pair}/',
                    ],
                    'post': [
                        'convert/{pair}',
                        'price_stats/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'active_orders_status/',
                        'archived_orders/{pair}/',
                        'balance/',
                        'cancel_order/',
                        'cancel_orders/{pair}/',
                        'cancel_replace_order/{pair}/',
                        'close_position/{pair}/',
                        'get_address/',
                        'get_myfee/',
                        'get_order/',
                        'get_order_tx/',
                        'open_orders/{pair}/',
                        'open_orders/',
                        'open_position/{pair}/',
                        'open_positions/{pair}/',
                        'place_order/{pair}/',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyLimits ();
        let result = [];
        for (let p = 0; p < markets['data']['pairs'].length; p++) {
            let market = markets['data']['pairs'][p];
            let id = market['symbol1'] + '/' + market['symbol2'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'info': market,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'precision': {
                    'price': this.precisionFromString (market['minPrice']),
                    'amount': -1 * Math.log10 (market['minLotSize']),
                },
                'limits': {
                    'amount': {
                        'min': market['minLotSize'],
                        'max': market['maxLotSize'],
                    },
                    'price': {
                        'min': parseFloat (market['minPrice']),
                        'max': parseFloat (market['maxPrice']),
                    },
                    'cost': {
                        'min': market['minLotSizeS2'],
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            if (currency in balances) {
                let account = {
                    'free': parseFloat (balances[currency]['available']),
                    'used': parseFloat (balances[currency]['orders']),
                    'total': 0.0,
                };
                account['total'] = this.sum (account['free'], account['used']);
                result[currency] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = this.milliseconds () - 86400000; // yesterday
        let ymd = this.Ymd (since);
        ymd = ymd.split ('-');
        ymd = ymd.join ('');
        let request = {
            'pair': market['id'],
            'yyyymmdd': ymd,
        };
        let response = await this.publicGetOhlcvHdYyyymmddPair (this.extend (request, params));
        let key = 'data' + this.timeframes[timeframe];
        let ohlcvs = JSON.parse (response[key]);
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = undefined;
        let iso8601 = undefined;
        if ('timestamp' in ticker) {
            timestamp = parseInt (ticker['timestamp']) * 1000;
            iso8601 = this.iso8601 (timestamp);
        }
        let volume = this.safeFloat (ticker, 'volume');
        let high = this.safeFloat (ticker, 'high');
        let low = this.safeFloat (ticker, 'low');
        let bid = this.safeFloat (ticker, 'bid');
        let ask = this.safeFloat (ticker, 'ask');
        let last = this.safeFloat (ticker, 'last');
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': iso8601,
            'high': high,
            'low': low,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': volume,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let currencies = Object.keys (this.currencies);
        let response = await this.publicGetTickersCurrencies (this.extend ({
            'currencies': currencies.join ('/'),
        }, params));
        let tickers = response['data'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let symbol = ticker['pair'].replace (':', '/');
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradeHistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
        };
        if (type == 'limit') {
            order['price'] = price;
        } else {
            // for market buy CEX.io requires the amount of quote currency to spend
            if (side == 'buy') {
                if (!price) {
                    throw new InvalidOrder ('For market buy orders ' + this.id + " requires the amount of quote currency to spend, to calculate proper costs call createOrder (symbol, 'market', 'buy', amount, price)");
                }
                order['amount'] = amount * price;
            }
            order['order_type'] = type;
        }
        let response = await this.privatePostPlaceOrderPair (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostGetOrder (this.extend ({
            'id': id.toString (),
        }, params));
    }

    parseOrder (order, market = undefined) {
        let timestamp = parseInt (order['time']);
        let symbol = undefined;
        if (!market) {
            let symbol = order['symbol1'] + '/' + order['symbol2'];
            if (symbol in this.markets)
                market = this.market (symbol);
        }
        let status = order['status'];
        if (status == 'cd') {
            status = 'canceled';
        } else if (status == 'c') {
            status = 'canceled';
        } else if (status == 'd') {
            status = 'closed';
        }
        let price = this.safeFloat (order, 'price');
        let amount = this.safeFloat (order, 'amount');
        let remaining = this.safeFloat (order, 'pending');
        if (!remaining)
            remaining = this.safeFloat (order, 'remains');
        let filled = amount - remaining;
        let fee = undefined;
        let cost = undefined;
        if (market) {
            symbol = market['symbol'];
            cost = this.safeFloat (order, 'ta:' + market['quote']);
            let baseFee = 'fa:' + market['base'];
            let quoteFee = 'fa:' + market['quote'];
            let feeRate = this.safeFloat (order, 'tradingFeeMaker');
            if (!feeRate)
                feeRate = this.safeFloat (order, 'tradingFeeTaker', feeRate);
            if (feeRate)
                feeRate /= 100.0; // convert to mathematically-correct percentage coefficients: 1.0 = 100%
            if (baseFee in order) {
                fee = {
                    'currency': market['base'],
                    'rate': feeRate,
                    'cost': this.safeFloat (order, baseFee),
                };
            } else if (quoteFee in order) {
                fee = {
                    'currency': market['quote'],
                    'rate': feeRate,
                    'cost': this.safeFloat (order, quoteFee),
                };
            }
        }
        if (!cost)
            cost = price * filled;
        return {
            'id': order['id'],
            'datetime': this.iso8601 (timestamp),
            'timestamp': timestamp,
            'status': status,
            'symbol': symbol,
            'type': undefined,
            'side': order['type'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': undefined,
            'fee': fee,
            'info': order,
        };
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let method = 'privatePostOpenOrders';
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['pair'] = market['id'];
            method += 'Pair';
        }
        let orders = await this[method] (this.extend (request, params));
        for (let i = 0; i < orders.length; i++) {
            orders[i] = this.extend (orders[i], { 'status': 'open' });
        }
        return this.parseOrders (orders, market);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (!response) {
            throw new ExchangeError (this.id + ' returned ' + this.json (response));
        } else if (response == true) {
            return response;
        } else if ('e' in response) {
            if ('ok' in response)
                if (response['ok'] == 'ok')
                    return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        } else if ('error' in response) {
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],41:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const zb = require ('./zb.js')

// ---------------------------------------------------------------------------

module.exports = class chbtc extends zb {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'chbtc',
            'name': 'CHBTC',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28555659-f0040dc2-7109-11e7-9d99-688a438bf9f4.jpg',
                'api': {
                    'public': 'http://api.chbtc.com/data', // no https for public API
                    'private': 'https://trade.chbtc.com/api',
                },
                'www': 'https://trade.chbtc.com/api',
                'doc': 'https://www.chbtc.com/i/developer',
            },
        });
    }

    getMarketFieldName () {
        return 'currency';
    }

    async fetchMarkets () {
        return {
            'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
            'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY' },
            'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY' },
            'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY' },
            'BTS/CNY': { 'id': 'bts_cny', 'symbol': 'BTS/CNY', 'base': 'BTS', 'quote': 'CNY' },
            // 'EOS/CNY': { 'id': 'eos_cny', 'symbol': 'EOS/CNY', 'base': 'EOS', 'quote': 'CNY' },
            'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY' },
            'HSR/CNY': { 'id': 'hsr_cny', 'symbol': 'HSR/CNY', 'base': 'HSR', 'quote': 'CNY' },
            'QTUM/CNY': { 'id': 'qtum_cny', 'symbol': 'QTUM/CNY', 'base': 'QTUM', 'quote': 'CNY' },
        };
    }
}

},{"./zb.js":99}],42:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class chilebit extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'chilebit',
            'name': 'ChileBit',
            'countries': 'CL',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991414-1298f0d8-647f-11e7-9c40-d56409266336.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://chilebit.net',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],43:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coincheck extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coincheck',
            'name': 'coincheck',
            'countries': [ 'JP', 'ID' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg',
                'api': 'https://coincheck.com/api',
                'www': 'https://coincheck.com',
                'doc': 'https://coincheck.com/documents/exchange/api',
            },
            'api': {
                'public': {
                    'get': [
                        'exchange/orders/rate',
                        'order_books',
                        'rate/{pair}',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'accounts/balance',
                        'accounts/leverage_balance',
                        'bank_accounts',
                        'deposit_money',
                        'exchange/orders/opens',
                        'exchange/orders/transactions',
                        'exchange/orders/transactions_pagination',
                        'exchange/leverage/positions',
                        'lending/borrows/matches',
                        'send_money',
                        'withdraws',
                    ],
                    'post': [
                        'bank_accounts',
                        'deposit_money/{id}/fast',
                        'exchange/orders',
                        'exchange/transfers/to_leverage',
                        'exchange/transfers/from_leverage',
                        'lending/borrows',
                        'lending/borrows/{id}/repay',
                        'send_money',
                        'withdraws',
                    ],
                    'delete': [
                        'bank_accounts/{id}',
                        'exchange/orders/{id}',
                        'withdraws/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/JPY': { 'id': 'btc_jpy', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' }, // the only real pair
                // 'ETH/JPY': { 'id': 'eth_jpy', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY' },
                // 'ETC/JPY': { 'id': 'etc_jpy', 'symbol': 'ETC/JPY', 'base': 'ETC', 'quote': 'JPY' },
                // 'DAO/JPY': { 'id': 'dao_jpy', 'symbol': 'DAO/JPY', 'base': 'DAO', 'quote': 'JPY' },
                // 'LSK/JPY': { 'id': 'lsk_jpy', 'symbol': 'LSK/JPY', 'base': 'LSK', 'quote': 'JPY' },
                // 'FCT/JPY': { 'id': 'fct_jpy', 'symbol': 'FCT/JPY', 'base': 'FCT', 'quote': 'JPY' },
                // 'XMR/JPY': { 'id': 'xmr_jpy', 'symbol': 'XMR/JPY', 'base': 'XMR', 'quote': 'JPY' },
                // 'REP/JPY': { 'id': 'rep_jpy', 'symbol': 'REP/JPY', 'base': 'REP', 'quote': 'JPY' },
                // 'XRP/JPY': { 'id': 'xrp_jpy', 'symbol': 'XRP/JPY', 'base': 'XRP', 'quote': 'JPY' },
                // 'ZEC/JPY': { 'id': 'zec_jpy', 'symbol': 'ZEC/JPY', 'base': 'ZEC', 'quote': 'JPY' },
                // 'XEM/JPY': { 'id': 'xem_jpy', 'symbol': 'XEM/JPY', 'base': 'XEM', 'quote': 'JPY' },
                // 'LTC/JPY': { 'id': 'ltc_jpy', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY' },
                // 'DASH/JPY': { 'id': 'dash_jpy', 'symbol': 'DASH/JPY', 'base': 'DASH', 'quote': 'JPY' },
                // 'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                // 'ETC/BTC': { 'id': 'etc_btc', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
                // 'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
                // 'FCT/BTC': { 'id': 'fct_btc', 'symbol': 'FCT/BTC', 'base': 'FCT', 'quote': 'BTC' },
                // 'XMR/BTC': { 'id': 'xmr_btc', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC' },
                // 'REP/BTC': { 'id': 'rep_btc', 'symbol': 'REP/BTC', 'base': 'REP', 'quote': 'BTC' },
                // 'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
                // 'ZEC/BTC': { 'id': 'zec_btc', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC' },
                // 'XEM/BTC': { 'id': 'xem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC' },
                // 'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                // 'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances)
                account['free'] = parseFloat (balances[lowercase]);
            let reserved = lowercase + '_reserved';
            if (reserved in balances)
                account['used'] = parseFloat (balances[reserved]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchOrderBook () supports BTC/JPY only');
        let orderbook = await this.publicGetOrderBooks (params);
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchTicker () supports BTC/JPY only');
        let ticker = await this.publicGetTicker (params);
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['created_at']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['order_type'],
            'price': parseFloat (trade['rate']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchTrades () supports BTC/JPY only');
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let prefix = '';
        let order = {
            'pair': this.marketId (symbol),
        };
        if (type == 'market') {
            let order_type = type + '_' + side;
            order['order_type'] = order_type;
            let prefix = (side == 'buy') ? (order_type + '_') : '';
            order[prefix + 'amount'] = amount;
        } else {
            order['order_type'] = side;
            order['rate'] = price;
            order['amount'] = amount;
        }
        let response = await this.privatePostExchangeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privateDeleteExchangeOrdersId ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            if (Object.keys (query).length)
                body = this.urlencode (this.keysort (query));
            let auth = nonce + url + (body || '');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'ACCESS-KEY': this.apiKey,
                'ACCESS-NONCE': nonce,
                'ACCESS-SIGNATURE': this.hmac (this.encode (auth), this.encode (this.secret)),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],44:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinfloor extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinfloor',
            'name': 'coinfloor',
            'rateLimit': 1000,
            'countries': 'UK',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg',
                'api': 'https://webapi.coinfloor.co.uk:8090/bist',
                'www': 'https://www.coinfloor.co.uk',
                'doc': [
                    'https://github.com/coinfloor/api',
                    'https://www.coinfloor.co.uk/api',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        '{id}/ticker/',
                        '{id}/order_book/',
                        '{id}/transactions/',
                    ],
                },
                'private': {
                    'post': [
                        '{id}/balance/',
                        '{id}/user_transactions/',
                        '{id}/open_orders/',
                        '{id}/cancel_order/',
                        '{id}/buy/',
                        '{id}/sell/',
                        '{id}/buy_market/',
                        '{id}/sell_market/',
                        '{id}/estimate_sell_market/',
                        '{id}/estimate_buy_market/',
                    ],
                },
            },
            'markets': {
                'BTC/GBP': { 'id': 'XBT/GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                'BTC/EUR': { 'id': 'XBT/EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/USD': { 'id': 'XBT/USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/PLN': { 'id': 'XBT/PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BCH/GBP': { 'id': 'BCH/GBP', 'symbol': 'BCH/GBP', 'base': 'BCH', 'quote': 'GBP' },
            },
        });
    }

    fetchBalance (params = {}) {
        let symbol = undefined;
        if ('symbol' in params)
            symbol = params['symbol'];
        if ('id' in params)
            symbol = params['id'];
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchBalance requires a symbol param');
        // todo parse balance
        return this.privatePostIdBalance ({
            'id': this.marketId (symbol),
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetIdOrderBook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        // rewrite to get the timestamp from HTTP headers
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let vwap = this.safeFloat (ticker, 'vwap');
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let ticker = await this.publicGetIdTicker (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTransactions (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = { 'id': this.marketId (symbol) };
        let method = 'privatePostId' + this.capitalize (side);
        if (type == 'market') {
            order['quantity'] = amount;
            method += 'Market';
        } else {
            order['price'] = price;
            order['amount'] = amount;
        }
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostIdCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        // curl -k -u '[User ID]/[API key]:[Passphrase]' https://webapi.coinfloor.co.uk:8090/bist/XBT/GBP/balance/
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let auth = this.uid + '/' + this.apiKey + ':' + this.password;
            let signature = this.stringToBase64 (auth);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Basic ' + signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],45:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coingi extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coingi',
            'name': 'Coingi',
            'rateLimit': 1000,
            'countries': [ 'PA', 'BG', 'CN', 'US' ], // Panama, Bulgaria, China, US
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg',
                'api': 'https://api.coingi.com',
                'www': 'https://coingi.com',
                'doc': 'http://docs.coingi.apiary.io/',
            },
            'api': {
                'current': {
                    'get': [
                        'order-book/{pair}/{askCount}/{bidCount}/{depth}',
                        'transactions/{pair}/{maxCount}',
                        '24hour-rolling-aggregation',
                    ],
                },
                'user': {
                    'post': [
                        'balance',
                        'add-order',
                        'cancel-order',
                        'orders',
                        'transactions',
                        'create-crypto-withdrawal',
                    ],
                },
            },
            // todo add fetchMarkets
            'markets': {
                'LTC/BTC': { 'id': 'ltc-btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'PPC/BTC': { 'id': 'ppc-btc', 'symbol': 'PPC/BTC', 'base': 'PPC', 'quote': 'BTC' },
                'DOGE/BTC': { 'id': 'doge-btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
                'VTC/BTC': { 'id': 'vtc-btc', 'symbol': 'VTC/BTC', 'base': 'VTC', 'quote': 'BTC' },
                'FTC/BTC': { 'id': 'ftc-btc', 'symbol': 'FTC/BTC', 'base': 'FTC', 'quote': 'BTC' },
                'NMC/BTC': { 'id': 'nmc-btc', 'symbol': 'NMC/BTC', 'base': 'NMC', 'quote': 'BTC' },
                'DASH/BTC': { 'id': 'dash-btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'taker': 0.2 / 100,
                    'maker': 0.2 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let lowercaseCurrencies = [];
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            lowercaseCurrencies.push (currency.toLowerCase ());
        }
        let balances = await this.userPostBalance ({
            'currencies': lowercaseCurrencies.join (',')
        });
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency']['name'];
            currency = currency.toUpperCase ();
            let account = {
                'free': balance['available'],
                'used': balance['blocked'] + balance['inOrders'] + balance['withdrawing'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.currentGetOrderBookPairAskCountBidCountDepth (this.extend ({
            'pair': market['id'],
            'askCount': 512, // maximum returned number of asks 1-512
            'bidCount': 512, // maximum returned number of bids 1-512
            'depth': 32, // maximum number of depth range steps 1-32
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'baseAmount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['highestBid'],
            'ask': ticker['lowestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': ticker['baseVolume'],
            'quoteVolume': ticker['counterVolume'],
            'info': ticker,
        };
        return ticker;
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.currentGet24hourRollingAggregation (params);
        let result = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let base = ticker['currencyPair']['base'].toUpperCase ();
            let quote = ticker['currencyPair']['counter'].toUpperCase ();
            let symbol = base + '/' + quote;
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.fetchTickers (undefined, params);
        if (symbol in tickers)
            return tickers[symbol];
        throw new ExchangeError (this.id + ' return did not contain ' + symbol);
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined, // type
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.currentGetTransactionsPairMaxCount (this.extend ({
            'pair': market['id'],
            'maxCount': 128,
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'currencyPair': this.marketId (symbol),
            'volume': amount,
            'price': price,
            'orderType': (side == 'buy') ? 0 : 1,
        };
        let response = await this.userPostAddOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['result'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.userPostCancelOrder ({ 'orderId': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + api + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'current') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = this.extend ({
                'token': this.apiKey,
                'nonce': nonce,
            }, query);
            let auth = nonce.toString () + '$' + this.apiKey;
            request['signature'] = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (request);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],46:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinmarketcap extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinmarketcap',
            'name': 'CoinMarketCap',
            'rateLimit': 10000,
            'version': 'v1',
            'countries': 'US',
            'hasCORS': true,
            'hasPrivateAPI': false,
            'hasCreateOrder': false,
            'hasCancelOrder': false,
            'hasFetchBalance': false,
            'hasFetchOrderBook': false,
            'hasFetchTrades': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg',
                'api': 'https://api.coinmarketcap.com',
                'www': 'https://coinmarketcap.com',
                'doc': 'https://coinmarketcap.com/api',
            },
            'requiredCredentials': {
                'apiKey': false,
                'secret': false,
            },
            'api': {
                'public': {
                    'get': [
                        'ticker/',
                        'ticker/{id}/',
                        'global/',
                    ],
                },
            },
            'currencyCodes': [
                'AUD',
                'BRL',
                'CAD',
                'CHF',
                'CNY',
                'EUR',
                'GBP',
                'HKD',
                'IDR',
                'INR',
                'JPY',
                'KRW',
                'MXN',
                'RUB',
                'USD',
            ],
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        throw new ExchangeError ('Fetching order books is not supported by the API of ' + this.id);
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ({
            'limit': 0,
        });
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let currencies = this.currencyCodes;
            for (let i = 0; i < currencies.length; i++) {
                let quote = currencies[i];
                let quoteId = quote.toLowerCase ();
                let base = market['symbol'];
                let baseId = market['id'];
                let symbol = base + '/' + quote;
                let id = baseId + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                });
            }
        }
        return result;
    }

    async fetchGlobal (currency = 'USD') {
        await this.loadMarkets ();
        let request = {};
        if (currency)
            request['convert'] = currency;
        return await this.publicGetGlobal (request);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        if ('last_updated' in ticker)
            if (ticker['last_updated'])
                timestamp = parseInt (ticker['last_updated']) * 1000;
        let change = undefined;
        let changeKey = 'percent_change_24h';
        if (changeKey in ticker)
            change = parseFloat (ticker[changeKey]);
        let last = undefined;
        let symbol = undefined;
        let volume = undefined;
        if (market) {
            let price = 'price_' + market['quoteId'];
            if (price in ticker)
                if (ticker[price])
                    last = parseFloat (ticker[price]);
            symbol = market['symbol'];
            let volumeKey = '24h_volume_' + market['quoteId'];
            if (volumeKey in ticker)
                volume = parseFloat (ticker[volumeKey]);
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': change,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    }

    async fetchTickers (currency = 'USD', params = {}) {
        await this.loadMarkets ();
        let request = {
            'limit': 10000,
        };
        if (currency)
            request['convert'] = currency;
        let response = await this.publicGetTicker (this.extend (request, params));
        let tickers = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let id = ticker['id'] + '/' + currency;
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            tickers[symbol] = this.parseTicker (ticker, market);
        }
        return tickers;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = this.extend ({
            'convert': market['quote'],
            'id': market['baseId'],
        }, params);
        let response = await this.publicGetTickerId (request);
        let ticker = response[0];
        return this.parseTicker (ticker, market);
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            if (response['error']) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],47:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinmate extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinmate',
            'name': 'CoinMate',
            'countries': [ 'GB', 'CZ' ], // UK, Czech Republic
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg',
                'api': 'https://coinmate.io/api',
                'www': 'https://coinmate.io',
                'doc': [
                    'http://docs.coinmate.apiary.io',
                    'https://coinmate.io/developers',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'orderBook',
                        'ticker',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balances',
                        'bitcoinWithdrawal',
                        'bitcoinDepositAddresses',
                        'buyInstant',
                        'buyLimit',
                        'cancelOrder',
                        'cancelOrderWithInfo',
                        'createVoucher',
                        'openOrders',
                        'redeemVoucher',
                        'sellInstant',
                        'sellLimit',
                        'transactionHistory',
                        'unconfirmedBitcoinDeposits',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'BTC_EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'precision': { 'amount': 4, 'price': 2 }},
                'BTC/CZK': { 'id': 'BTC_CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK', 'precision': { 'amount': 4, 'price': 2 }},
                'LTC/BTC': { 'id': 'LTC_BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'precision': { 'amount': 4, 'price': 5 }},
            },
            'fees': {
                'trading': {
                    'maker': 0.0005,
                    'taker': 0.0035,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalances ();
        let balances = response['data'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances) {
                account['free'] = balances[currency]['available'];
                account['used'] = balances[currency]['reserved'];
                account['total'] = balances[currency]['balance'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPriceLimit': 'False',
        }, params));
        let orderbook = response['data'];
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetTicker (this.extend ({
            'currencyPair': this.marketId (symbol),
        }, params));
        let ticker = response['data'];
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['amount']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['transactionId'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currencyPair': market['id'],
            'minutesIntoHistory': 10,
        }, params));
        return this.parseTrades (response['data'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
        };
        if (type == 'market') {
            if (side == 'buy')
                order['total'] = amount; // amount in fiat
            else
                order['amount'] = amount; // amount in fiat
            method += 'Instant';
        } else {
            order['amount'] = amount; // amount in crypto
            order['price'] = price;
            method += this.capitalize (type);
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['data'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'orderId': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'clientId': this.uid,
                'nonce': nonce,
                'publicKey': this.apiKey,
                'signature': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],48:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinsecure extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinsecure',
            'name': 'Coinsecure',
            'countries': 'IN', // India
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766472-9cbd200a-5ed9-11e7-9551-2267ad7bac08.jpg',
                'api': 'https://api.coinsecure.in',
                'www': 'https://coinsecure.in',
                'doc': [
                    'https://api.coinsecure.in',
                    'https://github.com/coinsecure/plugins',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'api': {
                'public': {
                    'get': [
                        'bitcoin/search/confirmation/{txid}',
                        'exchange/ask/low',
                        'exchange/ask/orders',
                        'exchange/bid/high',
                        'exchange/bid/orders',
                        'exchange/lastTrade',
                        'exchange/max24Hr',
                        'exchange/min24Hr',
                        'exchange/ticker',
                        'exchange/trades',
                    ],
                },
                'private': {
                    'get': [
                        'mfa/authy/call',
                        'mfa/authy/sms',
                        'netki/search/{netkiName}',
                        'user/bank/otp/{number}',
                        'user/kyc/otp/{number}',
                        'user/profile/phone/otp/{number}',
                        'user/wallet/coin/address/{id}',
                        'user/wallet/coin/deposit/confirmed/all',
                        'user/wallet/coin/deposit/confirmed/{id}',
                        'user/wallet/coin/deposit/unconfirmed/all',
                        'user/wallet/coin/deposit/unconfirmed/{id}',
                        'user/wallet/coin/wallets',
                        'user/exchange/bank/fiat/accounts',
                        'user/exchange/bank/fiat/balance/available',
                        'user/exchange/bank/fiat/balance/pending',
                        'user/exchange/bank/fiat/balance/total',
                        'user/exchange/bank/fiat/deposit/cancelled',
                        'user/exchange/bank/fiat/deposit/unverified',
                        'user/exchange/bank/fiat/deposit/verified',
                        'user/exchange/bank/fiat/withdraw/cancelled',
                        'user/exchange/bank/fiat/withdraw/completed',
                        'user/exchange/bank/fiat/withdraw/unverified',
                        'user/exchange/bank/fiat/withdraw/verified',
                        'user/exchange/ask/cancelled',
                        'user/exchange/ask/completed',
                        'user/exchange/ask/pending',
                        'user/exchange/bid/cancelled',
                        'user/exchange/bid/completed',
                        'user/exchange/bid/pending',
                        'user/exchange/bank/coin/addresses',
                        'user/exchange/bank/coin/balance/available',
                        'user/exchange/bank/coin/balance/pending',
                        'user/exchange/bank/coin/balance/total',
                        'user/exchange/bank/coin/deposit/cancelled',
                        'user/exchange/bank/coin/deposit/unverified',
                        'user/exchange/bank/coin/deposit/verified',
                        'user/exchange/bank/coin/withdraw/cancelled',
                        'user/exchange/bank/coin/withdraw/completed',
                        'user/exchange/bank/coin/withdraw/unverified',
                        'user/exchange/bank/coin/withdraw/verified',
                        'user/exchange/bank/summary',
                        'user/exchange/coin/fee',
                        'user/exchange/fiat/fee',
                        'user/exchange/kycs',
                        'user/exchange/referral/coin/paid',
                        'user/exchange/referral/coin/successful',
                        'user/exchange/referral/fiat/paid',
                        'user/exchange/referrals',
                        'user/exchange/trade/summary',
                        'user/login/token/{token}',
                        'user/summary',
                        'user/wallet/summary',
                        'wallet/coin/withdraw/cancelled',
                        'wallet/coin/withdraw/completed',
                        'wallet/coin/withdraw/unverified',
                        'wallet/coin/withdraw/verified',
                    ],
                    'post': [
                        'login',
                        'login/initiate',
                        'login/password/forgot',
                        'mfa/authy/initiate',
                        'mfa/ga/initiate',
                        'signup',
                        'user/netki/update',
                        'user/profile/image/update',
                        'user/exchange/bank/coin/withdraw/initiate',
                        'user/exchange/bank/coin/withdraw/newVerifycode',
                        'user/exchange/bank/fiat/withdraw/initiate',
                        'user/exchange/bank/fiat/withdraw/newVerifycode',
                        'user/password/change',
                        'user/password/reset',
                        'user/wallet/coin/withdraw/initiate',
                        'wallet/coin/withdraw/newVerifycode',
                    ],
                    'put': [
                        'signup/verify/{token}',
                        'user/exchange/kyc',
                        'user/exchange/bank/fiat/deposit/new',
                        'user/exchange/ask/new',
                        'user/exchange/bid/new',
                        'user/exchange/instant/buy',
                        'user/exchange/instant/sell',
                        'user/exchange/bank/coin/withdraw/verify',
                        'user/exchange/bank/fiat/account/new',
                        'user/exchange/bank/fiat/withdraw/verify',
                        'user/mfa/authy/initiate/enable',
                        'user/mfa/ga/initiate/enable',
                        'user/netki/create',
                        'user/profile/phone/new',
                        'user/wallet/coin/address/new',
                        'user/wallet/coin/new',
                        'user/wallet/coin/withdraw/sendToExchange',
                        'user/wallet/coin/withdraw/verify',
                    ],
                    'delete': [
                        'user/gcm/{code}',
                        'user/logout',
                        'user/exchange/bank/coin/withdraw/unverified/cancel/{withdrawID}',
                        'user/exchange/bank/fiat/deposit/cancel/{depositID}',
                        'user/exchange/ask/cancel/{orderID}',
                        'user/exchange/bid/cancel/{orderID}',
                        'user/exchange/bank/fiat/withdraw/unverified/cancel/{withdrawID}',
                        'user/mfa/authy/disable/{code}',
                        'user/mfa/ga/disable/{code}',
                        'user/profile/phone/delete',
                        'user/profile/image/delete/{netkiName}',
                        'user/wallet/coin/withdraw/unverified/cancel/{withdrawID}',
                    ],
                },
            },
            'markets': {
                'BTC/INR': { 'id': 'BTC/INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
            },
            'fees': {
                'trading': {
                    'maker': 0.4 / 100,
                    'taker': 0.4 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetUserExchangeBankSummary ();
        let balance = response['message'];
        let coin = {
            'free': balance['availableCoinBalance'],
            'used': balance['pendingCoinBalance'],
            'total': balance['totalCoinBalance'],
        };
        let fiat = {
            'free': balance['availableFiatBalance'],
            'used': balance['pendingFiatBalance'],
            'total': balance['totalFiatBalance'],
        };
        let result = {
            'info': balance,
            'BTC': coin,
            'INR': fiat,
        };
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let bids = await this.publicGetExchangeBidOrders (params);
        let asks = await this.publicGetExchangeAskOrders (params);
        let orderbook = {
            'bids': bids['message'],
            'asks': asks['message'],
        };
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'rate', 'vol');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetExchangeTicker (params);
        let ticker = response['message'];
        let timestamp = ticker['timestamp'];
        let baseVolume = parseFloat (ticker['coinvolume']);
        if (symbol == 'BTC/INR') {
            let satoshi = 0.00000001;
            baseVolume = baseVolume * satoshi;
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': parseFloat (ticker['fiatvolume']),
            'info': ticker,
        };
    }

    fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        return this.publicGetExchangeTrades (params);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePutUserExchange';
        let order = {};
        if (type == 'market') {
            method += 'Instant' + this.capitalize (side);
            if (side == 'buy')
                order['maxFiat'] = amount;
            else
                order['maxVol'] = amount;
        } else {
            let direction = (side == 'buy') ? 'Bid' : 'Ask';
            method += direction + 'New';
            order['rate'] = price;
            order['vol'] = amount;
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['message']['orderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privateDeleteUserExchangeAskCancelOrderId'; // TODO fixme, have to specify order side here
        return await this[method] ({ 'orderID': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            headers = { 'Authorization': this.apiKey };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],49:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinspot extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinspot',
            'name': 'CoinSpot',
            'countries': 'AU', // Australia
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
                'api': {
                    'public': 'https://www.coinspot.com.au/pubapi',
                    'private': 'https://www.coinspot.com.au/api',
                },
                'www': 'https://www.coinspot.com.au',
                'doc': 'https://www.coinspot.com.au/api',
            },
            'api': {
                'public': {
                    'get': [
                        'latest',
                    ],
                },
                'private': {
                    'post': [
                        'orders',
                        'orders/history',
                        'my/coin/deposit',
                        'my/coin/send',
                        'quote/buy',
                        'quote/sell',
                        'my/balances',
                        'my/orders',
                        'my/buy',
                        'my/sell',
                        'my/buy/cancel',
                        'my/sell/cancel',
                    ],
                },
            },
            'markets': {
                'BTC/AUD': { 'id': 'BTC', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                'LTC/AUD': { 'id': 'LTC', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD' },
                'DOGE/AUD': { 'id': 'DOGE', 'symbol': 'DOGE/AUD', 'base': 'DOGE', 'quote': 'AUD' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostMyBalances ();
        let result = { 'info': response };
        if ('balance' in response) {
            let balances = response['balance'];
            let currencies = Object.keys (balances);
            for (let c = 0; c < currencies.length; c++) {
                let currency = currencies[c];
                let uppercase = currency.toUpperCase ();
                let account = {
                    'free': balances[currency],
                    'used': 0.0,
                    'total': balances[currency],
                };
                if (uppercase == 'DRK')
                    uppercase = 'DASH';
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.privatePostOrders (this.extend ({
            'cointype': market['id'],
        }, params));
        let result = this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'rate', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetLatest (params);
        let id = this.marketId (symbol);
        id = id.toLowerCase ();
        let ticker = response['prices'][id];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        return this.privatePostOrdersHistory (this.extend ({
            'cointype': this.marketId (symbol),
        }, params));
    }

    createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostMy' + this.capitalize (side);
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let order = {
            'cointype': this.marketId (market),
            'amount': amount,
            'rate': price,
        };
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privatePostMyBuy';
        return await this[method] ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests');
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.json (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/json',
                'key': this.apiKey,
                'sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}
},{"./base/Exchange":8,"./base/errors":10}],50:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, OrderNotCached } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class cryptopia extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'cryptopia',
            'name': 'Cryptopia',
            'rateLimit': 1500,
            'countries': 'NZ', // New Zealand
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOrder': 'emulated',
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchMyTrades': true,
                'deposit': true,
                'withdraw': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg',
                'api': 'https://www.cryptopia.co.nz/api',
                'www': 'https://www.cryptopia.co.nz',
                'doc': [
                    'https://www.cryptopia.co.nz/Forum/Category/45',
                    'https://www.cryptopia.co.nz/Forum/Thread/255',
                    'https://www.cryptopia.co.nz/Forum/Thread/256',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'GetCurrencies',
                        'GetTradePairs',
                        'GetMarkets',
                        'GetMarkets/{id}',
                        'GetMarkets/{hours}',
                        'GetMarkets/{id}/{hours}',
                        'GetMarket/{id}',
                        'GetMarket/{id}/{hours}',
                        'GetMarketHistory/{id}',
                        'GetMarketHistory/{id}/{hours}',
                        'GetMarketOrders/{id}',
                        'GetMarketOrders/{id}/{count}',
                        'GetMarketOrderGroups/{ids}/{count}',
                    ],
                },
                'private': {
                    'post': [
                        'CancelTrade',
                        'GetBalance',
                        'GetDepositAddress',
                        'GetOpenOrders',
                        'GetTradeHistory',
                        'GetTransactions',
                        'SubmitTip',
                        'SubmitTrade',
                        'SubmitTransfer',
                        'SubmitWithdraw',
                    ],
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'CC')
            return 'CCX';
        if (currency == 'FCN')
            return 'Facilecoin';
        if (currency == 'NET')
            return 'NetCoin';
        if (currency == 'BTG')
            return 'Bitgem';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'CCX')
            return 'CC';
        if (currency == 'Facilecoin')
            return 'FCN';
        if (currency == 'NetCoin')
            return 'NET';
        if (currency == 'Bitgem')
            return 'BTG';
        return currency;
    }

    async fetchMarkets () {
        let response = await this.publicGetTradePairs ();
        let result = [];
        let markets = response['Data'];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['Id'];
            let symbol = market['Label'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let amountLimits = {
                'min': market['MinimumTrade'],
                'max': market['MaximumTrade']
            };
            let priceLimits = {
                'min': market['MinimumPrice'],
                'max': market['MaximumPrice'],
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
            };
            let active = market['Status'] == 'OK';
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': market['TradeFee'] / 100,
                'taker': market['TradeFee'] / 100,
                'lot': amountLimits['min'],
                'active': active,
                'precision': precision,
                'limits': limits,
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketOrdersId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let orderbook = response['Data'];
        return this.parseOrderBook (orderbook, undefined, 'Buy', 'Sell', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'info': ticker,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['Close']),
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': parseFloat (ticker['Change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['Volume']),
            'quoteVolume': parseFloat (ticker['BaseVolume']),
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketId (this.extend ({
            'id': market['id'],
        }, params));
        let ticker = response['Data'];
        return this.parseTicker (ticker, market);
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarkets (params);
        let result = {};
        let tickers = response['Data'];
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['TradePairId'];
            let recognized = (id in this.markets_by_id);
            if (!recognized)
                throw new ExchangeError (this.id + ' fetchTickers() returned unrecognized pair id ' + id);
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('Timestamp' in trade) {
            timestamp = trade['Timestamp'] * 1000;
        } else if ('TimeStamp' in trade) {
            timestamp = this.parse8601 (trade['TimeStamp']);
        }
        let price = this.safeFloat (trade, 'Price');
        if (!price)
            price = this.safeFloat (trade, 'Rate');
        let cost = this.safeFloat (trade, 'Total');
        let id = this.safeString (trade, 'TradeId');
        if (!market) {
            if ('TradePairId' in trade)
                if (trade['TradePairId'] in this.markets_by_id)
                    market = this.markets_by_id[trade['TradePairId']];
        }
        let symbol = undefined;
        let fee = undefined;
        if (market) {
            symbol = market['symbol'];
            if ('Fee' in trade) {
                fee = {
                    'currency': market['quote'],
                    'cost': trade['Fee'],
                };
            }
        }
        return {
            'id': id,
            'info': trade,
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': trade['Type'].toLowerCase (),
            'price': price,
            'cost': cost,
            'amount': trade['Amount'],
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketHistoryIdHours (this.extend ({
            'id': market['id'],
            'hours': 24, // default
        }, params));
        let trades = response['Data'];
        return this.parseTrades (trades, market);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchMyTrades requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privatePostGetTradeHistory (this.extend ({
            // 'Market': market['id'],
            'TradePairId': market['id'], // Cryptopia identifier (not required if 'Market' supplied)
            // 'Count': 10, // max = 100
        }, params));
        return this.parseTrades (response['Data'], market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalance ();
        let balances = response['Data'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let code = balance['Symbol'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': balance['Available'],
                'used': 0.0,
                'total': balance['Total'],
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        price = parseFloat (price);
        amount = parseFloat (amount);
        let request = {
            'TradePairId': market['id'],
            'Type': this.capitalize (side),
            'Rate': this.priceToPrecision (symbol, price),
            'Amount': this.amountToPrecision (symbol, amount),
        };
        let response = await this.privatePostSubmitTrade (this.extend (request, params));
        if (!response)
            throw new ExchangeError (this.id + ' createOrder returned unknown error: ' + this.json (response));
        let id = undefined;
        let filled = 0.0;
        if ('Data' in response) {
            if ('OrderId' in response['Data']) {
                if (response['Data']['OrderId']) {
                    id = response['Data']['OrderId'].toString ();
                }
            }
            if ('FilledOrders' in response['Data']) {
                let filledOrders = response['Data']['FilledOrders'];
                let filledOrdersLength = filledOrders.length;
                if (filledOrdersLength) {
                    filled = undefined;
                }
            }
        }
        let timestamp = this.milliseconds ();
        let order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'remaining': amount,
            'filled': filled,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
        if (id)
            this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelTrade (this.extend ({
                'Type': 'Trade',
                'OrderId': id,
            }, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'Error');
                if (message) {
                    if (message.indexOf ('does not exist') >= 0)
                        throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
                }
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('Market' in order) {
            let id = order['Market'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = this.parse8601 (order['TimeStamp']);
        let amount = this.safeFloat (order, 'Amount');
        let remaining = this.safeFloat (order, 'Remaining');
        let filled = amount - remaining;
        return {
            'id': order['OrderId'].toString (),
            'info': this.omit (order, 'status'),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': 'limit',
            'side': order['Type'].toLowerCase (),
            'price': this.safeFloat (order, 'Rate'),
            'cost': this.safeFloat (order, 'Total'),
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privatePostGetOpenOrders ({
            // 'Market': market['id'],
            'TradePairId': market['id'], // Cryptopia identifier (not required if 'Market' supplied)
            // 'Count': 100, // default = 100
        }, params);
        let orders = [];
        for (let i = 0; i < response['Data'].length; i++) {
            orders.push (this.extend (response['Data'][i], { 'status': 'open' }));
        }
        let openOrders = this.parseOrders (orders, market);
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (order['symbol'] == symbol)
                result.push (order);
        }
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        id = id.toString ();
        let orders = await this.fetchOrders (symbol, params);
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['id'] == id)
                return orders[i];
        }
        throw new OrderNotCached (this.id + ' order ' + id + ' not found in cached .orders, fetchOrder requires .orders (de)serialization implemented for this method to work properly');
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'open')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'closed')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostGetDepositAddress (this.extend ({
            'Currency': currencyId
        }, params));
        let address = this.safeString (response['Data'], 'BaseAddress');
        if (!address)
            address = this.safeString (response['Data'], 'Address');
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostSubmitWithdraw (this.extend ({
            'Currency': currencyId,
            'Amount': amount,
            'Address': address, // Address must exist in you AddressBook in security settings
        }, params));
        return {
            'info': response,
            'id': response['Data'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let hash = this.hash (this.encode (body), 'md5', 'base64');
            let secret = this.base64ToBinary (this.secret);
            let uri = this.encodeURIComponent (url);
            let lowercase = uri.toLowerCase ();
            let payload = this.apiKey + method + lowercase + nonce + this.binaryToString (hash);
            let signature = this.hmac (this.encode (payload), secret, 'sha256', 'base64');
            let auth = 'amx ' + this.apiKey + ':' + this.binaryToString (signature) + ':' + nonce;
            headers = {
                'Content-Type': 'application/json',
                'Authorization': auth,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (response) {
            if ('Success' in response)
                if (response['Success']) {
                    return response;
                } else if ('Error' in response) {
                    if (response['Error'] == 'Insufficient Funds.')
                        throw new InsufficientFunds (this.id + ' ' + this.json (response));
                }
        }
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],51:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')

// ---------------------------------------------------------------------------

module.exports = class dsx extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'dsx',
            'name': 'DSX',
            'countries': 'UK',
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasFetchMyTrades': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg',
                'api': {
                    'public': 'https://dsx.uk/mapi', // market data
                    'private': 'https://dsx.uk/tapi', // trading
                    'dwapi': 'https://dsx.uk/dwapi', // deposit/withdraw
                },
                'www': 'https://dsx.uk',
                'doc': [
                    'https://api.dsx.uk',
                    'https://dsx.uk/api_docs/public',
                    'https://dsx.uk/api_docs/private',
                    '',
                ],
            },
            'api': {
                // market data (public)
                'public': {
                    'get': [
                        'barsFromMoment/{id}/{period}/{start}', // empty reply :\
                        'depth/{pair}',
                        'info',
                        'lastBars/{id}/{period}/{amount}', // period is (m, h or d)
                        'periodBars/{id}/{period}/{start}/{end}',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                // trading (private)
                'private': {
                    'post': [
                        'getInfo',
                        'TransHistory',
                        'TradeHistory',
                        'OrderHistory',
                        'ActiveOrders',
                        'Trade',
                        'CancelOrder',
                    ],
                },
                // deposit / withdraw (private)
                'dwapi': {
                    'post': [
                        'getCryptoDepositAddress',
                        'cryptoWithdraw',
                        'fiatWithdraw',
                        'getTransactionStatus',
                        'getTransactions',
                    ],
                },
            },
        });
    }

    getBaseQuoteFromMarketId (id) {
        let uppercase = id.toUpperCase ();
        let base = uppercase.slice (0, 3);
        let quote = uppercase.slice (3, 6);
        base = this.commonCurrencyCode (base);
        quote = this.commonCurrencyCode (quote);
        return [ base, quote ];
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let funds = balances['funds'];
        let currencies = Object.keys (funds);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            uppercase = this.commonCurrencyCode (uppercase);
            let account = {
                'free': funds[currency],
                'used': 0.0,
                'total': balances['total'][currency],
            };
            account['used'] = account['total'] - account['free'];
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': 1 / this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol'),
            'quoteVolume': this.safeFloat (ticker, 'vol_cur'),
            'info': ticker,
        };
    }

    getOrderIdKey () {
        return 'orderId';
    }

    signBodyWithSecret (body) {
        return this.decode (this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64'));
    }

    getVersionString () {
        return ''; // they don't prepend version number to public URLs as other BTC-e clones do
    }
}

},{"./liqui.js":72}],52:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class exmo extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'exmo',
            'name': 'EXMO',
            'countries': [ 'ES', 'RU' ], // Spain, Russia
            'rateLimit': 1000, // once every 350 ms  180 requests per minute  3 requests per second
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
                'api': 'https://api.exmo.com',
                'www': 'https://exmo.me',
                'doc': [
                    'https://exmo.me/en/api_doc',
                    'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'currency',
                        'order_book',
                        'pair_settings',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'user_info',
                        'order_create',
                        'order_cancel',
                        'user_open_orders',
                        'user_trades',
                        'user_cancelled_orders',
                        'order_trades',
                        'required_amount',
                        'deposit_address',
                        'withdraw_crypt',
                        'withdraw_get_txid',
                        'excode_create',
                        'excode_load',
                        'wallet_history',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairSettings ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let symbol = id.replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'limits': {
                    'amount': {
                        'min': market['min_quantity'],
                        'max': market['max_quantity'],
                    },
                    'price': {
                        'min': market['min_price'],
                        'max': market['max_price'],
                    },
                    'cost': {
                        'min': market['min_amount'],
                        'max': market['max_amount'],
                    },
                },
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostUserInfo ();
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in response['balances'])
                account['free'] = parseFloat (response['balances'][currency]);
            if (currency in response['reserved'])
                account['used'] = parseFloat (response['reserved'][currency]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response[market['id']];
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy_price']),
            'ask': parseFloat (ticker['sell_price']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker['vol_curr']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (params);
        let result = {};
        let ids = Object.keys (response);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = response[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (params);
        let market = this.market (symbol);
        return this.parseTicker (response[market['id']], market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response[market['id']], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let prefix = '';
        if (type == 'market')
            prefix = 'market_';
        if (typeof price == 'undefined')
            price = 0;
        let order = {
            'pair': this.marketId (symbol),
            'quantity': amount,
            'price': price,
            'type': prefix + side,
        };
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdrawCrypt (this.extend ({
            'amount': amount,
            'currency': currency,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': result['task_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response) {
            if (response['result'])
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],53:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class flowbtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'flowbtc',
            'name': 'flowBTC',
            'countries': 'BR', // Brazil
            'version': 'v1',
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28162465-cd815d4c-67cf-11e7-8e57-438bea0523a2.jpg',
                'api': 'https://api.flowbtc.com:8400/ajax',
                'www': 'https://trader.flowbtc.com',
                'doc': 'http://www.flowbtc.com.br/api/',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'post': [
                        'GetTicker',
                        'GetTrades',
                        'GetTradesByDate',
                        'GetOrderBook',
                        'GetProductPairs',
                        'GetProducts',
                    ],
                },
                'private': {
                    'post': [
                        'CreateAccount',
                        'GetUserInfo',
                        'SetUserInfo',
                        'GetAccountInfo',
                        'GetAccountTrades',
                        'GetDepositAddresses',
                        'Withdraw',
                        'CreateOrder',
                        'ModifyOrder',
                        'CancelOrder',
                        'CancelAllOrders',
                        'GetAccountOpenOrders',
                        'GetOrderFee',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicPostGetProductPairs ();
        let markets = response['productPairs'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['name'];
            let base = market['product1Label'];
            let quote = market['product2Label'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['currencies'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['name'];
            let account = {
                'free': balance['balance'],
                'used': balance['hold'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicPostGetOrderBook (this.extend ({
            'productPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'px', 'qty');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicPostGetTicker (this.extend ({
            'productPair': market['id'],
        }, params));
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume24hr']),
            'quoteVolume': parseFloat (ticker['volume24hrProduct2']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['unixtime'] * 1000;
        let side = (trade['incomingOrderSide'] == 0) ? 'buy' : 'sell';
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['px'],
            'amount': trade['qty'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicPostGetTrades (this.extend ({
            'ins': market['id'],
            'startIndex': -1,
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = (type == 'market') ? 1 : 0;
        let order = {
            'ins': this.marketId (symbol),
            'side': side,
            'orderType': orderType,
            'qty': amount,
            'px': price,
        };
        let response = await this.privatePostCreateOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['serverOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        if ('ins' in params) {
            return await this.privatePostCancelOrder (this.extend ({
                'serverOrderId': id,
            }, params));
        }
        throw new ExchangeError (this.id + ' requires `ins` symbol parameter for cancelling an order');
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length) {
                body = this.json (params);
            }
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = nonce.toString () + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (this.extend ({
                'apiKey': this.apiKey,
                'apiNonce': nonce,
                'apiSig': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('isAccepted' in response)
            if (response['isAccepted'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}
},{"./base/Exchange":8,"./base/errors":10}],54:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class foxbit extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'foxbit',
            'name': 'FoxBit',
            'countries': 'BR',
            'hasCORS': false,
            'rateLimit': 1000,
            'version': 'v1',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://foxbit.exchange',
                'doc': 'https://blinktrade.com/docs',
            },
            'comment': 'Blinktrade API',
            'api': {
                'public': {
                    'get': [
                        '{currency}/ticker',    // ?crypto_currency=BTC
                        '{currency}/orderbook', // ?crypto_currency=BTC
                        '{currency}/trades',    // ?crypto_currency=BTC&since=<TIMESTAMP>&limit=<NUMBER>
                    ],
                },
                'private': {
                    'post': [
                        'D',   // order
                        'F',   // cancel order
                        'U2',  // balance
                        'U4',  // my orders
                        'U6',  // withdraw
                        'U18', // deposit
                        'U24', // confirm withdrawal
                        'U26', // list withdrawals
                        'U30', // list deposits
                        'U34', // ledger
                        'U70', // cancel withdrawal
                    ],
                },
            },
            'markets': {
                'BTC/VEF': { 'id': 'BTCVEF', 'symbol': 'BTC/VEF', 'base': 'BTC', 'quote': 'VEF', 'brokerId': 1, 'broker': 'SurBitcoin' },
                'BTC/VND': { 'id': 'BTCVND', 'symbol': 'BTC/VND', 'base': 'BTC', 'quote': 'VND', 'brokerId': 3, 'broker': 'VBTC' },
                'BTC/BRL': { 'id': 'BTCBRL', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'brokerId': 4, 'broker': 'FoxBit' },
                'BTC/PKR': { 'id': 'BTCPKR', 'symbol': 'BTC/PKR', 'base': 'BTC', 'quote': 'PKR', 'brokerId': 8, 'broker': 'UrduBit' },
                'BTC/CLP': { 'id': 'BTCCLP', 'symbol': 'BTC/CLP', 'base': 'BTC', 'quote': 'CLP', 'brokerId': 9, 'broker': 'ChileBit' },
            },
        });
    }

    fetchBalance (params = {}) {
        // todo parse balance
        return this.privatePostU2 ({
            'BalanceReqID': this.nonce (),
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetCurrencyOrderbook (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let ticker = await this.publicGetCurrencyTicker (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        let timestamp = this.milliseconds ();
        let lowercaseQuote = market['quote'].toLowerCase ();
        let quoteVolume = 'vol_' + lowercaseQuote;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCurrencyTrades (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let orderSide = (side == 'buy') ? '1' : '2';
        let order = {
            'ClOrdID': this.nonce (),
            'Symbol': market['id'],
            'Side': orderSide,
            'OrdType': '2',
            'Price': price,
            'OrderQty': amount,
            'BrokerID': market['brokerId'],
        };
        let response = await this.privatePostD (this.extend (order, params));
        let indexed = this.indexBy (response['Responses'], 'MsgType');
        let execution = indexed['8'];
        return {
            'info': response,
            'id': execution['OrderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostF (this.extend ({
            'ClOrdID': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let request = this.extend ({ 'MsgType': path }, query);
            body = this.json (request);
            headers = {
                'APIKey': this.apiKey,
                'Nonce': nonce,
                'Signature': this.hmac (this.encode (nonce), this.encode (this.secret)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('Status' in response)
            if (response['Status'] != 200)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],55:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class fybse extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'fybse',
            'name': 'FYB-SE',
            'countries': 'SE', // Sweden
            'hasCORS': false,
            'rateLimit': 1500,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766512-31019772-5edb-11e7-8241-2e675e6797f1.jpg',
                'api': 'https://www.fybse.se/api/SEK',
                'www': 'https://www.fybse.se',
                'doc': 'http://docs.fyb.apiary.io',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'tickerdetailed',
                        'orderbook',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'test',
                        'getaccinfo',
                        'getpendingorders',
                        'getorderhistory',
                        'cancelpendingorder',
                        'placeorder',
                        'withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostGetaccinfo ();
        let btc = parseFloat (balance['btcBal']);
        let symbol = this.symbols[0];
        let quote = this.markets[symbol]['quote'];
        let lowercase = quote.toLowerCase () + 'Bal';
        let fiat = parseFloat (balance[lowercase]);
        let crypto = {
            'free': btc,
            'used': 0.0,
            'total': btc,
        };
        let result = { 'BTC': crypto };
        result[quote] = {
            'free': fiat,
            'used': 0.0,
            'total': fiat,
        };
        result['info'] = balance;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderbook (params);
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTickerdetailed (params);
        let timestamp = this.milliseconds ();
        let last = undefined;
        let volume = undefined;
        if ('last' in ticker)
            last = parseFloat (ticker['last']);
        if ('vol' in ticker)
            volume = parseFloat (ticker['vol']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': volume,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostPlaceorder (this.extend ({
            'qty': amount,
            'price': price,
            'type': side[0].toUpperCase ()
        }, params));
        return {
            'info': response,
            'id': response['pending_oid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelpendingorder ({ 'orderNo': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            url += '.json';
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sig': this.hmac (this.encode (body), this.encode (this.secret), 'sha1')
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private')
            if ('error' in response)
                if (response['error'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],56:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const fybse = require ('./fybse.js')

// ---------------------------------------------------------------------------

module.exports = class fybsg extends fybse {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'fybsg',
            'name': 'FYB-SG',
            'countries': 'SG', // Singapore
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766513-3364d56a-5edb-11e7-9e6b-d5898bb89c81.jpg',
                'api': 'https://www.fybsg.com/api/SGD',
                'www': 'https://www.fybsg.com',
                'doc': 'http://docs.fyb.apiary.io',
            },
            'markets': {
                'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
            },
        });
    }
}

},{"./fybse.js":55}],57:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class gatecoin extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gatecoin',
            'name': 'Gatecoin',
            'rateLimit': 2000,
            'countries': 'HK', // Hong Kong
            'comment': 'a regulated/licensed exchange',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '1m',
                '15m': '15m',
                '1h': '1h',
                '6h': '6h',
                '1d': '24h',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28646817-508457f2-726c-11e7-9eeb-3528d2413a58.jpg',
                'api': 'https://api.gatecoin.com',
                'www': 'https://gatecoin.com',
                'doc': [
                    'https://gatecoin.com/api',
                    'https://github.com/Gatecoin/RESTful-API-Implementation',
                    'https://api.gatecoin.com/swagger-ui/index.html',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'Public/ExchangeRate', // Get the exchange rates
                        'Public/LiveTicker', // Get live ticker for all currency
                        'Public/LiveTicker/{CurrencyPair}', // Get live ticker by currency
                        'Public/LiveTickers', // Get live ticker for all currency
                        'Public/MarketDepth/{CurrencyPair}', // Gets prices and market depth for the currency pair.
                        'Public/NetworkStatistics/{DigiCurrency}', // Get the network status of a specific digital currency
                        'Public/StatisticHistory/{DigiCurrency}/{Typeofdata}', // Get the historical data of a specific digital currency
                        'Public/TickerHistory/{CurrencyPair}/{Timeframe}', // Get ticker history
                        'Public/Transactions/{CurrencyPair}', // Gets recent transactions
                        'Public/TransactionsHistory/{CurrencyPair}', // Gets all transactions
                        'Reference/BusinessNatureList', // Get the business nature list.
                        'Reference/Countries', // Get the country list.
                        'Reference/Currencies', // Get the currency list.
                        'Reference/CurrencyPairs', // Get the currency pair list.
                        'Reference/CurrentStatusList', // Get the current status list.
                        'Reference/IdentydocumentTypes', // Get the different types of identity documents possible.
                        'Reference/IncomeRangeList', // Get the income range list.
                        'Reference/IncomeSourceList', // Get the income source list.
                        'Reference/VerificationLevelList', // Get the verif level list.
                        'Stream/PublicChannel', // Get the public pubnub channel list
                    ],
                    'post': [
                        'Export/Transactions', // Request a export of all trades from based on currencypair, start date and end date
                        'Ping', // Post a string, then get it back.
                        'Public/Unsubscribe/{EmailCode}', // Lets the user unsubscribe from emails
                        'RegisterUser', // Initial trader registration.
                    ],
                },
                'private': {
                    'get': [
                        'Account/CorporateData', // Get corporate account data
                        'Account/DocumentAddress', // Check if residence proof uploaded
                        'Account/DocumentCorporation', // Check if registered document uploaded
                        'Account/DocumentID', // Check if ID document copy uploaded
                        'Account/DocumentInformation', // Get Step3 Data
                        'Account/Email', // Get user email
                        'Account/FeeRate', // Get fee rate of logged in user
                        'Account/Level', // Get verif level of logged in user
                        'Account/PersonalInformation', // Get Step1 Data
                        'Account/Phone', // Get user phone number
                        'Account/Profile', // Get trader profile
                        'Account/Questionnaire', // Fill the questionnaire
                        'Account/Referral', // Get referral information
                        'Account/ReferralCode', // Get the referral code of the logged in user
                        'Account/ReferralNames', // Get names of referred traders
                        'Account/ReferralReward', // Get referral reward information
                        'Account/ReferredCode', // Get referral code
                        'Account/ResidentInformation', // Get Step2 Data
                        'Account/SecuritySettings', // Get verif details of logged in user
                        'Account/User', // Get all user info
                        'APIKey/APIKey', // Get API Key for logged in user
                        'Auth/ConnectionHistory', // Gets connection history of logged in user
                        'Balance/Balances', // Gets the available balance for each currency for the logged in account.
                        'Balance/Balances/{Currency}', // Gets the available balance for s currency for the logged in account.
                        'Balance/Deposits', // Get all account deposits, including wire and digital currency, of the logged in user
                        'Balance/Withdrawals', // Get all account withdrawals, including wire and digital currency, of the logged in user
                        'Bank/Accounts/{Currency}/{Location}', // Get internal bank account for deposit
                        'Bank/Transactions', // Get all account transactions of the logged in user
                        'Bank/UserAccounts', // Gets all the bank accounts related to the logged in user.
                        'Bank/UserAccounts/{Currency}', // Gets all the bank accounts related to the logged in user.
                        'ElectronicWallet/DepositWallets', // Gets all crypto currency addresses related deposits to the logged in user.
                        'ElectronicWallet/DepositWallets/{DigiCurrency}', // Gets all crypto currency addresses related deposits to the logged in user by currency.
                        'ElectronicWallet/Transactions', // Get all digital currency transactions of the logged in user
                        'ElectronicWallet/Transactions/{DigiCurrency}', // Get all digital currency transactions of the logged in user
                        'ElectronicWallet/UserWallets', // Gets all external digital currency addresses related to the logged in user.
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Gets all external digital currency addresses related to the logged in user by currency.
                        'Info/ReferenceCurrency', // Get user's reference currency
                        'Info/ReferenceLanguage', // Get user's reference language
                        'Notification/Messages', // Get from oldest unread + 3 read message to newest messages
                        'Trade/Orders', // Gets open orders for the logged in trader.
                        'Trade/Orders/{OrderID}', // Gets an order for the logged in trader.
                        'Trade/StopOrders', // Gets all stop orders for the logged in trader. Max 1000 record.
                        'Trade/StopOrdersHistory', // Gets all stop orders for the logged in trader. Max 1000 record.
                        'Trade/Trades', // Gets all transactions of logged in user
                        'Trade/UserTrades', // Gets all transactions of logged in user
                    ],
                    'post': [
                        'Account/DocumentAddress', // Upload address proof document
                        'Account/DocumentCorporation', // Upload registered document document
                        'Account/DocumentID', // Upload ID document copy
                        'Account/Email/RequestVerify', // Request for verification email
                        'Account/Email/Verify', // Verification email
                        'Account/GoogleAuth', // Enable google auth
                        'Account/Level', // Request verif level of logged in user
                        'Account/Questionnaire', // Fill the questionnaire
                        'Account/Referral', // Post a referral email
                        'APIKey/APIKey', // Create a new API key for logged in user
                        'Auth/ChangePassword', // Change password.
                        'Auth/ForgotPassword', // Request reset password
                        'Auth/ForgotUserID', // Request user id
                        'Auth/Login', // Trader session log in.
                        'Auth/Logout', // Logout from the current session.
                        'Auth/LogoutOtherSessions', // Logout other sessions.
                        'Auth/ResetPassword', // Reset password
                        'Bank/Transactions', // Request a transfer from the traders account of the logged in user. This is only available for bank account
                        'Bank/UserAccounts', // Add an account the logged in user
                        'ElectronicWallet/DepositWallets/{DigiCurrency}', // Add an digital currency addresses to the logged in user.
                        'ElectronicWallet/Transactions/Deposits/{DigiCurrency}', // Get all internal digital currency transactions of the logged in user
                        'ElectronicWallet/Transactions/Withdrawals/{DigiCurrency}', // Get all external digital currency transactions of the logged in user
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Add an external digital currency addresses to the logged in user.
                        'ElectronicWallet/Withdrawals/{DigiCurrency}', // Request a transfer from the traders account to an external address. This is only available for crypto currencies.
                        'Notification/Messages', // Mark all as read
                        'Notification/Messages/{ID}', // Mark as read
                        'Trade/Orders', // Place an order at the exchange.
                        'Trade/StopOrders', // Place a stop order at the exchange.
                    ],
                    'put': [
                        'Account/CorporateData', // Update user company data for corporate account
                        'Account/DocumentID', // Update ID document meta data
                        'Account/DocumentInformation', // Update Step3 Data
                        'Account/Email', // Update user email
                        'Account/PersonalInformation', // Update Step1 Data
                        'Account/Phone', // Update user phone number
                        'Account/Questionnaire', // update the questionnaire
                        'Account/ReferredCode', // Update referral code
                        'Account/ResidentInformation', // Update Step2 Data
                        'Account/SecuritySettings', // Update verif details of logged in user
                        'Account/User', // Update all user info
                        'Bank/UserAccounts', // Update the label of existing user bank accounnt
                        'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Update the name of an address
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Update the name of an external address
                        'Info/ReferenceCurrency', // User's reference currency
                        'Info/ReferenceLanguage', // Update user's reference language
                    ],
                    'delete': [
                        'APIKey/APIKey/{PublicKey}', // Remove an API key
                        'Bank/Transactions/{RequestID}', // Delete pending account withdraw of the logged in user
                        'Bank/UserAccounts/{Currency}/{Label}', // Delete an account of the logged in user
                        'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Delete an digital currency addresses related to the logged in user.
                        'ElectronicWallet/UserWallets/{DigiCurrency}/{AddressName}', // Delete an external digital currency addresses related to the logged in user.
                        'Trade/Orders', // Cancels all existing order
                        'Trade/Orders/{OrderID}', // Cancels an existing order
                        'Trade/StopOrders', // Cancels all existing stop orders
                        'Trade/StopOrders/{ID}', // Cancels an existing stop order
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0025,
                    'taker': 0.0035,
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetPublicLiveTickers ();
        let markets = response['tickers'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currencyPair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalanceBalances ();
        let balances = response['balances'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': balance['availableBalance'],
                'used': this.sum (
                    balance['pendingIncoming'],
                    balance['pendingOutgoing'],
                    balance['openOrder']),
                'total': balance['balance'],
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetPublicMarketDepthCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseInt (ticker['createDateTime']) * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let baseVolume = parseFloat (ticker['volume']);
        let vwap = parseFloat (ticker['vwap']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetPublicLiveTickers (params);
        let tickers = response['tickers'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['currencyPair'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicLiveTickerCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('way' in trade) {
            side = (trade['way'] == 'bid') ? 'buy' : 'sell';
            let orderId = trade['way'] + 'OrderId';
            order = trade[orderId];
        }
        let timestamp = parseInt (trade['transactionTime']) * 1000;
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'info': trade,
            'id': trade['transactionId'].toString (),
            'order': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicTransactionsCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseTrades (response['transactions'], market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            parseInt (ohlcv['createDateTime']) * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            undefined,
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'CurrencyPair': market['id'],
            'Timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['Count'] = limit;
        request = this.extend (request, params);
        let response = await this.publicGetPublicTickerHistoryCurrencyPairTimeframe (request);
        return this.parseOHLCVs (response['tickers'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'Code': this.marketId (symbol),
            'Way': (side == 'buy') ? 'Bid' : 'Ask',
            'Amount': amount,
        };
        if (type == 'limit')
            order['Price'] = price;
        if (this.twofa) {
            if ('ValidationCode' in params)
                order['ValidationCode'] = params['ValidationCode'];
            else
                throw new AuthenticationError (this.id + ' two-factor authentication requires a missing ValidationCode parameter');
        }
        let response = await this.privatePostTradeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['clOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteTradeOrdersOrderID ({ 'OrderID': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let contentType = (method == 'GET') ? '' : 'application/json';
            let auth = method + url + contentType + nonce.toString ();
            auth = auth.toLowerCase ();
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            headers = {
                'API_PUBLIC_KEY': this.apiKey,
                'API_REQUEST_SIGNATURE': signature,
                'API_REQUEST_DATE': nonce,
            };
            if (method != 'GET') {
                headers['Content-Type'] = contentType;
                body = this.json (this.extend ({ 'nonce': nonce }, params));
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('responseStatus' in response)
            if ('message' in response['responseStatus'])
                if (response['responseStatus']['message'] == 'OK')
                    return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],58:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bter = require ('./bter.js')

// ---------------------------------------------------------------------------

module.exports = class gateio extends bter {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gateio',
            'name': 'Gate.io',
            'countries': 'CN',
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                'api': {
                    'public': 'https://data.gate.io/api',
                    'private': 'https://data.gate.io/api',
                },
                'www': 'https://gate.io/',
                'doc': 'https://gate.io/api2',
            },
        });
    }
}

},{"./bter.js":37}],59:[function(require,module,exports){
"use strict";

// ----------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InvalidOrder, AuthenticationError, NotSupported } = require ('./base/errors')

// ----------------------------------------------------------------------------

module.exports = class gdax extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gdax',
            'name': 'GDAX',
            'countries': 'US',
            'rateLimit': 1000,
            'hasCORS': true,
            'hasFetchOHLCV': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'timeframes': {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '1h': 3600,
                '2h': 7200,
                '4h': 14400,
                '12h': 43200,
                '1d': 86400,
                '1w': 604800,
                '1M': 2592000,
                '1y': 31536000,
            },
            'urls': {
                'test': 'https://api-public.sandbox.gdax.com',
                'logo': 'https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg',
                'api': 'https://api.gdax.com',
                'www': 'https://www.gdax.com',
                'doc': 'https://docs.gdax.com',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'password': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currencies',
                        'products',
                        'products/{id}/book',
                        'products/{id}/candles',
                        'products/{id}/stats',
                        'products/{id}/ticker',
                        'products/{id}/trades',
                        'time',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'accounts/{id}',
                        'accounts/{id}/holds',
                        'accounts/{id}/ledger',
                        'coinbase-accounts',
                        'fills',
                        'funding',
                        'orders',
                        'orders/{id}',
                        'payment-methods',
                        'position',
                        'reports/{id}',
                        'users/self/trailing-volume',
                    ],
                    'post': [
                        'deposits/coinbase-account',
                        'deposits/payment-method',
                        'funding/repay',
                        'orders',
                        'position/close',
                        'profiles/margin-transfer',
                        'reports',
                        'withdrawals/coinbase',
                        'withdrawals/crypto',
                        'withdrawals/payment-method',
                    ],
                    'delete': [
                        'orders',
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0,
                    'taker': 0.25 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quote_currency'];
            let symbol = base + '/' + quote;
            let amountLimits = {
                'min': market['base_min_size'],
                'max': market['base_max_size'],
            };
            let priceLimits = {
                'min': market['quote_increment'],
                'max': undefined,
            };
            let costLimits = {
                'min': priceLimits['min'],
                'max': undefined,
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
                'cost': costLimits,
            };
            let precision = {
                'amount': -Math.log10 (parseFloat (amountLimits['min'])),
                'price': -Math.log10 (parseFloat (priceLimits['min'])),
            };
            let taker = this.fees['trading']['taker'];
            if ((base == 'ETH') || (base == 'LTC')) {
                taker = 0.003;
            }
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'precision': precision,
                'limits': limits,
                'taker': taker,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccounts ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['hold']),
                'total': parseFloat (balance['balance']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdBook (this.extend ({
            'id': this.marketId (symbol),
            'level': 2, // 1 best bidask, 2 aggregated, 3 full
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = this.extend ({
            'id': market['id'],
        }, params);
        let ticker = await this.publicGetProductsIdTicker (request);
        let quote = await this.publicGetProductsIdStats (request);
        let timestamp = this.parse8601 (ticker['time']);
        let bid = undefined;
        let ask = undefined;
        if ('bid' in ticker)
            bid = parseFloat (ticker['bid']);
        if ('ask' in ticker)
            ask = parseFloat (ticker['ask']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (quote['high']),
            'low': parseFloat (quote['low']),
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': parseFloat (quote['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (quote['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['time']);
        let side = (trade['side'] == 'buy') ? 'sell' : 'buy';
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let fee = undefined;
        if ('fill_fees' in trade) {
            fee = {
                'cost': parseFloat (trade['fill_fees']),
                'currency': market['quote'],
            };
        }
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['size']),
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetProductsIdTrades (this.extend ({
            'id': market['id'], // fixes issue #2
        }, params));
        return this.parseTrades (response, market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[3],
            ohlcv[2],
            ohlcv[1],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let granularity = this.timeframes[timeframe];
        let request = {
            'id': market['id'],
            'granularity': granularity,
        };
        if (since) {
            request['start'] = this.iso8601 (since);
            if (!limit)
                limit = 200; // max = 200
            request['end'] = this.iso8601 (limit * granularity * 1000 + since);
        }
        let response = await this.publicGetProductsIdCandles (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchTime () {
        let response = this.publicGetTime ();
        return this.parse8601 (response['iso']);
    }

    getOrderStatus (status) {
        let statuses = {
            'pending': 'open',
            'active': 'open',
            'open': 'open',
            'done': 'closed',
            'canceled': 'canceled',
        };
        return this.safeString (statuses, status, status);
    }

    parseOrder (order, market = undefined) {
        let timestamp = this.parse8601 (order['created_at']);
        let symbol = undefined;
        if (!market) {
            if (order['product_id'] in this.markets_by_id)
                market = this.markets_by_id[order['product_id']];
        }
        let status = this.getOrderStatus (order['status']);
        let price = this.safeFloat (order, 'price');
        let amount = this.safeFloat (order, 'size');
        let filled = this.safeFloat (order, 'filled_size');
        let remaining = amount - filled;
        let cost = this.safeFloat (order, 'executed_value');
        if (market)
            symbol = market['symbol'];
        return {
            'id': order['id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetOrdersId (this.extend ({
            'id': id,
        }, params));
        return this.parseOrder (response);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            'status': 'all',
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            'status': 'done',
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        // let oid = this.nonce ().toString ();
        let order = {
            'product_id': this.marketId (market),
            'side': side,
            'size': amount,
            'type': type,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrdersId ({ 'id': id });
    }

    async getPaymentMethods () {
        let response = await this.privateGetPaymentMethods ();
        return response;
    }

    async deposit (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'currency': currency,
            'amount': amount,
        };
        let method = 'privatePostDeposits';
        if ('payment_method_id' in params) {
            // deposit from a payment_method, like a bank account
            method += 'PaymentMethod';
        } else if ('coinbase_account_id' in params) {
            // deposit into GDAX account from a Coinbase account
            method += 'CoinbaseAccount';
        } else {
            // deposit methodotherwise we did not receive a supported deposit location
            // relevant docs link for the Googlers
            // https://docs.gdax.com/#deposits
            throw NotSupported (this.id + ' deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params');
        }
        let response = await this[method] (this.extend (request, params));
        if (!response)
            throw ExchangeError (this.id + ' deposit() error: ' + this.json (response));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'currency': currency,
            'amount': amount,
        };
        let method = 'privatePostWithdrawals';
        if ('payment_method_id' in params) {
            method += 'PaymentMethod';
        } else if ('coinbase_account_id' in params) {
            method += 'CoinbaseAccount';
        } else {
            method += 'Crypto';
            request['crypto_address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        if (!response)
            throw ExchangeError (this.id + ' withdraw() error: ' + this.json (response));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (method == 'GET') {
            if (Object.keys (query).length)
                request += '?' + this.urlencode (query);
        }
        let url = this.urls['api'] + request;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let payload = '';
            if (method != 'GET') {
                if (Object.keys (query).length) {
                    body = this.json (query);
                    payload = body;
                }
            }
            // let payload = (body) ? body : '';
            let what = nonce + method + request + payload;
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (what), secret, 'sha256', 'base64');
            headers = {
                'CB-ACCESS-KEY': this.apiKey,
                'CB-ACCESS-SIGN': this.decode (signature),
                'CB-ACCESS-TIMESTAMP': nonce,
                'CB-ACCESS-PASSPHRASE': this.password,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                let message = response['message'];
                if (message.indexOf ('price too small') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('price too precise') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message == 'Invalid API Key') {
                    throw new AuthenticationError (this.id + ' ' + message);
                }
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('message' in response) {
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],60:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class gemini extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gemini',
            'name': 'Gemini',
            'countries': 'US',
            'rateLimit': 1500, // 200 for private API
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
                'api': 'https://api.gemini.com',
                'www': 'https://gemini.com',
                'doc': 'https://docs.gemini.com/rest-api',
            },
            'api': {
                'public': {
                    'get': [
                        'symbols',
                        'pubticker/{symbol}',
                        'book/{symbol}',
                        'trades/{symbol}',
                        'auction/{symbol}',
                        'auction/{symbol}/history',
                    ],
                },
                'private': {
                    'post': [
                        'order/new',
                        'order/cancel',
                        'order/cancel/session',
                        'order/cancel/all',
                        'order/status',
                        'orders',
                        'mytrades',
                        'tradevolume',
                        'balances',
                        'deposit/{currency}/newAddress',
                        'withdraw/{currency}',
                        'heartbeat',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let id = markets[p];
            let market = id;
            let uppercase = market.toUpperCase ();
            let base = uppercase.slice (0, 3);
            let quote = uppercase.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'taker': 0.0025
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPubtickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let timestamp = ticker['volume']['timestamp'];
        let baseVolume = market['base'];
        let quoteVolume = market['quote'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume'][baseVolume]),
            'quoteVolume': parseFloat (ticker['volume'][quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['timestampms'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': 0.0,
                'total': parseFloat (balance['amount']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let nonce = this.nonce ();
        let order = {
            'client_order_id': nonce.toString (),
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'price': price.toString (),
            'side': side,
            'type': 'exchange limit', // gemini allows limit orders only
        };
        let response = await this.privatePostOrderNew (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = this.extend ({
                'request': url,
                'nonce': nonce,
            }, query);
            let payload = this.json (request);
            payload = this.stringToBase64 (this.encode (payload));
            let signature = this.hmac (payload, this.encode (this.secret), 'sha384');
            headers = {
                'Content-Type': 'text/plain',
                'X-GEMINI-APIKEY': this.apiKey,
                'X-GEMINI-PAYLOAD': payload,
                'X-GEMINI-SIGNATURE': signature,
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],61:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class hitbtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'hitbtc',
            'name': 'HitBTC',
            'countries': 'HK', // Hong Kong
            'rateLimit': 1500,
            'version': '1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                'api': 'http://api.hitbtc.com',
                'www': 'https://hitbtc.com',
                'doc': 'https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv1.md',
            },
            'api': {
                'public': {
                    'get': [
                        '{symbol}/orderbook',
                        '{symbol}/ticker',
                        '{symbol}/trades',
                        '{symbol}/trades/recent',
                        'symbols',
                        'ticker',
                        'time,'
                    ],
                },
                'trading': {
                    'get': [
                        'balance',
                        'orders/active',
                        'orders/recent',
                        'order',
                        'trades/by/order',
                        'trades',
                    ],
                    'post': [
                        'new_order',
                        'cancel_order',
                        'cancel_orders',
                    ],
                },
                'payment': {
                    'get': [
                        'balance',
                        'address/{currency}',
                        'transactions',
                        'transactions/{transaction}',
                    ],
                    'post': [
                        'transfer_to_trading',
                        'transfer_to_main',
                        'address/{currency}',
                        'payout',
                    ],
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'DRK')
            return 'DASH';
        if (currency == 'CAT')
            return 'BitClave';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets['symbols'].length; p++) {
            let market = markets['symbols'][p];
            let id = market['symbol'];
            let base = market['commodity'];
            let quote = market['currency'];
            let lot = parseFloat (market['lot']);
            let step = parseFloat (market['step']);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'step': step,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let method = this.safeString (params, 'type', 'trading');
        method += 'GetBalance';
        let query = this.omit (params, 'type');
        let response = await this[method] (query);
        let balances = response['balance'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency_code'];
            let currency = this.commonCurrencyCode (code);
            let free = this.safeFloat (balance, 'cash', 0.0);
            free = this.safeFloat (balance, 'balance', free);
            let used = this.safeFloat (balance, 'reserved', 0.0);
            let account = {
                'free': free,
                'used': used,
                'total': this.sum (free, used),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetSymbolOrderbook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'volume_quote'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetSymbolTicker (this.extend ({
            'symbol': market['id'],
        }, params));
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        return {
            'info': trade,
            'id': trade[0],
            'timestamp': trade[3],
            'datetime': this.iso8601 (trade[3]),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade[4],
            'price': parseFloat (trade[1]),
            'amount': parseFloat (trade[2]),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetSymbolTrades (this.extend ({
            'symbol': market['id'],
            // 'from': 0,
            // 'till': 100,
            // 'by': 'ts', // or by trade_id
            // 'sort': 'desc', // or asc
            // 'start_index': 0,
            // 'max_results': 1000,
            // 'format_item': 'object',
            // 'format_price': 'number',
            // 'format_amount': 'number',
            // 'format_tid': 'string',
            // 'format_timestamp': 'millisecond',
            // 'format_wrap': false,
            'side': 'true',
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        // check if amount can be evenly divided into lots
        // they want integer quantity in lot units
        let quantity = parseFloat (amount) / market['lot'];
        let wholeLots = Math.round (quantity);
        let difference = quantity - wholeLots;
        if (Math.abs (difference) > market['step'])
            throw new ExchangeError (this.id + ' order amount should be evenly divisible by lot unit size of ' + market['lot'].toString ());
        let clientOrderId = this.milliseconds ();
        let order = {
            'clientOrderId': clientOrderId.toString (),
            'symbol': market['id'],
            'side': side,
            'quantity': wholeLots.toString (), // quantity in integer lot units
            'type': type,
        };
        if (type == 'limit') {
            order['price'] = price.toFixed (10);
        } else {
            order['timeInForce'] = 'FOK';
        }
        let response = await this.tradingPostNewOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['ExecutionReport']['clientOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.tradingPostCancelOrder (this.extend ({
            'clientOrderId': id,
        }, params));
    }

    getOrderStatus (status) {
        let statuses = {
            'new': 'open',
            'partiallyFilled': 'partial',
            'filled': 'closed',
            'canceled': 'canceled',
            'rejected': 'rejected',
            'expired': 'expired',
        };
        return this.safeString (statuses, status);
    }

    parseOrder (order, market = undefined) {
        let timestamp = parseInt (order['lastTimestamp']);
        let symbol = undefined;
        if (!market)
            market = this.markets_by_id[order['symbol']];
        let status = this.safeString (order, 'orderStatus');
        if (status)
            status = this.getOrderStatus (status);
        let averagePrice = this.safeFloat (order, 'avgPrice', 0.0);
        let price = this.safeFloat (order, 'orderPrice');
        let amount = this.safeFloat (order, 'orderQuantity');
        let remaining = this.safeFloat (order, 'quantityLeaves');
        let filled = undefined;
        let cost = undefined;
        if (market) {
            symbol = market['symbol'];
            amount *= market['lot'];
            remaining *= market['lot'];
        }
        if (amount && remaining) {
            filled = amount - remaining;
            cost = averagePrice * filled;
        }
        return {
            'id': order['clientOrderId'].toString (),
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.tradingGetOrder (this.extend ({
            'client_order_id': id,
        }, params));
        return this.parseOrder (response['orders'][0]);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let statuses = [ 'new', 'partiallyFiiled' ];
        let market = undefined;
        let request = {
            'sort': 'desc',
            'statuses': statuses.join (','),
        };
        if (symbol) {
            market = this.market (symbol);
            request['symbols'] = market['id'];
        }
        let response = await this.tradingGetOrdersActive (this.extend (request, params));
        return this.parseOrders (response['orders'], market);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let statuses = [ 'filled', 'canceled', 'rejected', 'expired' ];
        let request = {
            'sort': 'desc',
            'statuses': statuses.join (','),
            'max_results': 1000,
        };
        if (symbol) {
            market = this.market (symbol);
            request['symbols'] = market['id'];
        }
        let response = await this.tradingGetOrdersRecent (this.extend (request, params));
        return this.parseOrders (response['orders'], market);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.paymentPostPayout (this.extend ({
            'currency_code': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['transaction'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + 'api' + '/' + this.version + '/' + api + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let payload = { 'nonce': nonce, 'apikey': this.apiKey };
            query = this.extend (payload, query);
            if (method == 'GET')
                url += '?' + this.urlencode (query);
            else
                url += '?' + this.urlencode (payload);
            let auth = url;
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    body = this.urlencode (query);
                    auth += body;
                }
            }
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Signature': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512').toLowerCase (),
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response) {
            if ('ExecutionReport' in response) {
                if (response['ExecutionReport']['orderRejectReason'] == 'orderExceedsLimit')
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
            }
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],62:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const hitbtc = require ('./hitbtc')
const { ExchangeError, OrderNotFound } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class hitbtc2 extends hitbtc {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'hitbtc2',
            'name': 'HitBTC v2',
            'countries': 'HK', // Hong Kong
            'rateLimit': 1500,
            'version': '2',
            'hasCORS': true,
            // older metainfo interface
            'hasFetchOHLCV': true,
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOrders': false,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOrders': false,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': 'M1',
                '3m': 'M3',
                '5m': 'M5',
                '15m': 'M15',
                '30m': 'M30', // default
                '1h': 'H1',
                '4h': 'H4',
                '1d': 'D1',
                '1w': 'D7',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                'api': 'https://api.hitbtc.com',
                'www': 'https://hitbtc.com',
                'doc': 'https://api.hitbtc.com',
            },
            'api': {
                'public': {
                    'get': [
                        'symbol', // Available Currency Symbols
                        'symbol/{symbol}', // Get symbol info
                        'currency', // Available Currencies
                        'currency/{currency}', // Get currency info
                        'ticker', // Ticker list for all symbols
                        'ticker/{symbol}', // Ticker for symbol
                        'trades/{symbol}', // Trades
                        'orderbook/{symbol}', // Orderbook
                        'candles/{symbol}', // Candles
                    ],
                },
                'private': {
                    'get': [
                        'order', // List your current open orders
                        'order/{clientOrderId}', // Get a single order by clientOrderId
                        'trading/balance', // Get trading balance
                        'trading/fee/{symbol}', // Get trading fee rate
                        'history/trades', // Get historical trades
                        'history/order', // Get historical orders
                        'history/order/{id}/trades', // Get historical trades by specified order
                        'account/balance', // Get main acccount balance
                        'account/transactions', // Get account transactions
                        'account/transactions/{id}', // Get account transaction by id
                        'account/crypto/address/{currency}', // Get deposit crypro address
                    ],
                    'post': [
                        'order', // Create new order
                        'account/crypto/withdraw', // Withdraw crypro
                        'account/crypto/address/{currency}', // Create new deposit crypro address
                        'account/transfer', // Transfer amount to trading
                    ],
                    'put': [
                        'order/{clientOrderId}', // Create new order
                        'account/crypto/withdraw/{id}', // Commit withdraw crypro
                    ],
                    'delete': [
                        'order', // Cancel all open orders
                        'order/{clientOrderId}', // Cancel order
                        'account/crypto/withdraw/{id}', // Rollback withdraw crypro
                    ],
                    'patch': [
                        'order/{clientOrderId}', // Cancel Replace order
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': -0.01 / 100,
                    'taker': 0.1 / 100,
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'CAT')
            return 'BitClave';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'BitClave')
            return 'CAT';
        return currency;
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (fee, 8);
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbol ();
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['id'];
            let base = market['baseCurrency'];
            let quote = market['quoteCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let lot = parseFloat (market['quantityIncrement']);
            let step = parseFloat (market['tickSize']);
            let precision = {
                'price': this.precisionFromString (market['tickSize']),
                'amount': this.precisionFromString (market['quantityIncrement']),
            };
            let taker = parseFloat (market['takeLiquidityRate']);
            let maker = parseFloat (market['provideLiquidityRate']);
            result.push (this.extend (this.fees['trading'], {
                'info': market,
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': true,
                'lot': lot,
                'step': step,
                'taker': taker,
                'maker': maker,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': step,
                        'max': undefined,
                    },
                    'cost': {
                        'min': lot * step,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let type = this.safeString (params, 'type', 'trading');
        let method = 'privateGet' + this.capitalize (type) + 'Balance';
        let balances = await this[method] ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['reserved']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['timestamp']);
        return [
            timestamp,
            parseFloat (ohlcv['open']),
            parseFloat (ohlcv['max']),
            parseFloat (ohlcv['min']),
            parseFloat (ohlcv['close']),
            parseFloat (ohlcv['volumeQuote']),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'period': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetCandlesSymbol (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask', 'price', 'size');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['timestamp']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': this.safeFloat (ticker, 'close'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'volumeQuote'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['symbol'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let id = trade['symbol'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                symbol = id;
            }
        }
        let fee = undefined;
        if ('fee' in trade) {
            let currency = market ? market['quote'] : undefined;
            fee = {
                'cost': parseFloat (trade['fee']),
                'currency': currency,
            };
        }
        let orderId = undefined;
        if ('clientOrderId' in trade)
            orderId = trade['clientOrderId'];
        let price = parseFloat (trade['price']);
        let amount = parseFloat (trade['quantity']);
        let cost = price * amount;
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': orderId,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': trade['side'],
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let clientOrderId = this.uuid ();
        // their max accepted length is 32 characters
        clientOrderId = clientOrderId.replace ('-', '');
        clientOrderId = clientOrderId.slice (0, 32);
        amount = parseFloat (amount);
        let request = {
            'clientOrderId': clientOrderId,
            'symbol': market['id'],
            'side': side,
            'quantity': this.amountToPrecision (symbol, amount),
            'type': type,
        };
        if (type == 'limit') {
            request['price'] = this.priceToPrecision (symbol, price);
        } else {
            request['timeInForce'] = 'FOK';
        }
        let response = await this.privatePostOrder (this.extend (request, params));
        let order = this.parseOrder (response);
        let id = order['id'];
        this.orders[id] = order;
        return order;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrderClientOrderId (this.extend ({
            'clientOrderId': id,
        }, params));
    }

    parseOrder (order, market = undefined) {
        let created = undefined;
        if ('createdAt' in order)
            created = this.parse8601 (order['createdAt']);
        let updated = undefined;
        if ('updatedAt' in order)
            updated = this.parse8601 (order['updatedAt']);
        if (!market)
            market = this.markets_by_id[order['symbol']];
        let symbol = market['symbol'];
        let amount = this.safeFloat (order, 'quantity');
        let filled = this.safeFloat (order, 'cumQuantity');
        let status = order['status'];
        if (status == 'new') {
            status = 'open';
        } else if (status == 'suspended') {
            status = 'open';
        } else if (status == 'partiallyFilled') {
            status = 'open';
        } else if (status == 'filled') {
            status = 'closed';
        }
        let id = order['clientOrderId'].toString ();
        let price = this.safeFloat (order, 'price');
        if (typeof price == 'undefined') {
            if (id in this.orders)
                price = this.orders[id].price;
        }
        let remaining = undefined;
        let cost = undefined;
        if (typeof amount != 'undefined') {
            if (typeof filled != 'undefined') {
                remaining = amount - filled;
                if (typeof price != 'undefined') {
                    cost = filled * price;
                }
            }
        }
        return {
            'id': id,
            'timestamp': created,
            'datetime': this.iso8601 (created),
            'created': created,
            'updated': updated,
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'amount': amount,
            'cost': cost,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
            'info': order,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetHistoryOrder (this.extend ({
            'clientOrderId': id,
        }, params));
        let numOrders = response.length;
        if (numOrders > 0)
            return this.parseOrder (response[0]);
        throw new OrderNotFound (this.id + ' order ' + id + ' not found');
    }

    async fetchActiveOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetOrderClientOrderId (this.extend ({
            'clientOrderId': id,
        }, params));
        return this.parseOrder (response);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        let response = await this.privateGetOrder (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        if (limit)
            request['limit'] = limit;
        if (since) {
            request['from'] = this.iso8601 (since);
        }
        let response = await this.privateGetHistoryOrder (this.extend (request, params));
        return this.parseOrders (response, market);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            // 'symbol': 'BTC/USD', // optional
            // 'sort': 'DESC', // or 'ASC'
            // 'by': 'timestamp', // or 'id'	String	timestamp by default, or id
            // 'from':	'Datetime or Number', // ISO 8601
            // 'till':	'Datetime or Number',
            // 'limit': 100,
            // 'offset': 0,
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        if (since)
            request['from'] = this.iso8601 (since);
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetHistoryTrades (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    async createDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostAccountCryptoAddressCurrency ({
            'currency': currencyId,
        });
        let address = response['address'];
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privateGetAccountCryptoAddressCurrency ({
            'currency': currencyId,
        });
        let address = response['address'];
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        amount = parseFloat (amount);
        let response = await this.privatePostAccountCryptoWithdraw (this.extend ({
            'currency': currencyId,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/api' + '/' + this.version + '/';
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            url += api + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            url += this.implodeParams (path, params);
            if (method == 'GET') {
                if (Object.keys (query).length)
                    url += '?' + this.urlencode (query);
            } else {
                if (Object.keys (query).length)
                    body = this.json (query);
            }
            let payload = this.encode (this.apiKey + ':' + this.secret);
            let auth = this.stringToBase64 (payload);
            headers = {
                'Authorization': "Basic " + this.decode (auth),
                'Content-Type': 'application/json',
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('error' in response) {
                    if ('message' in response['error']) {
                        let message = response['error']['message'];
                        if (message == 'Order not found') {
                            throw new OrderNotFound (this.id + ' order not found in active orders');
                        } else if (message == 'Insufficient funds') {
                            throw new InsufficientFunds (this.id + ' ' + message);
                        }
                    }
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/errors":10,"./hitbtc":61}],63:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class huobi extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobi',
            'name': 'Huobi',
            'countries': 'CN',
            'rateLimit': 2000,
            'version': 'v3',
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '001',
                '5m': '005',
                '15m': '015',
                '30m': '030',
                '1h': '060',
                '1d': '100',
                '1w': '200',
                '1M': '300',
                '1y': '400',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'http://api.huobi.com',
                'www': 'https://www.huobi.com',
                'doc': 'https://github.com/huobiapi/API_Docs_en/wiki',
            },
            'api': {
                'staticmarket': {
                    'get': [
                        '{id}_kline_{period}',
                        'ticker_{id}',
                        'depth_{id}',
                        'depth_{id}_{length}',
                        'detail_{id}',
                    ],
                },
                'usdmarket': {
                    'get': [
                        '{id}_kline_{period}',
                        'ticker_{id}',
                        'depth_{id}',
                        'depth_{id}_{length}',
                        'detail_{id}',
                    ],
                },
                'trade': {
                    'post': [
                        'get_account_info',
                        'get_orders',
                        'order_info',
                        'buy',
                        'sell',
                        'buy_market',
                        'sell_market',
                        'cancel_order',
                        'get_new_deal_orders',
                        'get_order_id_by_trade_id',
                        'withdraw_coin',
                        'cancel_withdraw_coin',
                        'get_withdraw_coin_result',
                        'transfer',
                        'loan',
                        'repayment',
                        'get_loan_available',
                        'get_loans',
                    ],
                },
            },
            'markets': {
                'BTC/CNY': { 'id': 'btc', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 1 },
                'LTC/CNY': { 'id': 'ltc', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 2 },
                // 'BTC/USD': { 'id': 'btc', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'type': 'usdmarket',    'coinType': 1 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.tradePostGetAccountInfo ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let available = 'available_' + lowercase + '_display';
            let frozen = 'frozen_' + lowercase + '_display';
            let loan = 'loan_' + lowercase + '_display';
            if (available in balances)
                account['free'] = parseFloat (balances[available]);
            if (frozen in balances)
                account['used'] = parseFloat (balances[frozen]);
            if (loan in balances)
                account['used'] = this.sum (account['used'], parseFloat (balances[loan]));
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDepthId';
        let orderbook = await this[method] (this.extend ({ 'id': market['id'] }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetTickerId';
        let response = await this[method] (this.extend ({
            'id': market['id'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseInt (response['time']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDetailId';
        let response = await this[method] (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        // not implemented yet
        return [
            ohlcv[0],
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[6],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetIdKlinePeriod';
        let ohlcvs = await this[method] (this.extend ({
            'id': market['id'],
            'period': this.timeframes[timeframe],
        }, params));
        return ohlcvs;
        // return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let method = 'tradePost' + this.capitalize (side);
        let order = {
            'coin_type': market['coinType'],
            'amount': amount,
            'market': market['quote'].toLowerCase (),
        };
        if (type == 'limit')
            order['price'] = price;
        else
            method += this.capitalize (type);
        let response = this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.tradePostCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'];
        if (api == 'trade') {
            this.checkRequiredCredentials ();
            url += '/api' + this.version;
            let query = this.keysort (this.extend ({
                'method': path,
                'access_key': this.apiKey,
                'created': this.nonce (),
            }, params));
            let queryString = this.urlencode (this.omit (query, 'market'));
            // secret key must be appended to the query before signing
            queryString += '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        } else {
            url += '/' + api + '/' + this.implodeParams (path, params) + '_json.js';
            let query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'trade', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],64:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const huobipro = require ('./huobipro.js')

// ---------------------------------------------------------------------------

module.exports = class huobicny extends huobipro {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobicny',
            'name': 'Huobi CNY',
            'hostname': 'be.huobi.com',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'https://be.huobi.com',
                'www': 'https://www.huobi.com',
                'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
            },
        });
    }
}

},{"./huobipro.js":65}],65:[function(require,module,exports){
"use strict";


//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class huobipro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobipro',
            'name': 'Huobi Pro',
            'countries': 'CN',
            'rateLimit': 2000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'accounts': undefined,
            'accountsById': undefined,
            'hostname': 'api.huobi.pro',
            'timeframes': {
                '1m': '1min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '60min',
                '1d': '1day',
                '1w': '1week',
                '1M': '1mon',
                '1y': '1year',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'https://api.huobi.pro',
                'www': 'https://www.huobi.pro',
                'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
            },
            'api': {
                'market': {
                    'get': [
                        'history/kline', // K
                        'detail/merged', // (Ticker)
                        'depth', //  Market Depth 
                        'trade', //  Trade Detail 
                        'history/trade', // 
                        'detail', //  Market Detail 24
                    ],
                },
                'public': {
                    'get': [
                        'common/symbols', // 
                        'common/currencys', // 
                        'common/timestamp', // 
                    ],
                },
                'private': {
                    'get': [
                        'account/accounts', // (account-id)
                        'account/accounts/{id}/balance', // 
                        'order/orders/{id}', // 
                        'order/orders/{id}/matchresults', // 
                        'order/orders', // 
                        'order/matchresults', // 
                        'dw/withdraw-virtual/addresses', // 
                    ],
                    'post': [
                        'order/orders/place', //  ( )
                        'order/orders', //  
                        'order/orders/{id}/place', //  
                        'order/orders/{id}/submitcancel', // 
                        'order/orders/batchcancel', // 
                        'dw/balance/transfer', // 
                        'dw/withdraw-virtual/create', // 
                        'dw/withdraw-virtual/{id}/place', // 
                        'dw/withdraw-virtual/{id}/cancel', // 
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetCommonSymbols ();
        let markets = response['data'];
        let numMarkets = markets.length;
        if (numMarkets < 1)
            throw new ExchangeError (this.id + ' publicGetCommonSymbols returned empty response: ' + this.json (response));
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let baseId = market['base-currency'];
            let quoteId = market['quote-currency'];
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            let id = baseId + quoteId;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': market['amount-precision'],
                'price': market['price-precision'],
            };
            let lot = Math.pow (10, -precision['amount']);
            let maker = (base == 'OMG') ? 0 : 0.2 / 100;
            let taker = (base == 'OMG') ? 0 : 0.2 / 100;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'precision': precision,
                'taker': taker,
                'maker': maker,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
                'info': market,
            });
        }
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let last = undefined;
        if ('last' in ticker)
            last = ticker['last'];
        let timestamp = this.milliseconds ();
        if ('ts' in ticker)
            timestamp = ticker['ts'];
        let bid = undefined;
        let ask = undefined;
        if ('bid' in ticker) {
            if (ticker['bid'])
                bid = this.safeFloat (ticker['bid'], 0);
        }
        if ('ask' in ticker) {
            if (ticker['ask'])
                ask = this.safeFloat (ticker['ask'], 0);
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': ticker['open'],
            'close': ticker['close'],
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['amount']),
            'quoteVolume': ticker['vol'],
            'info': ticker,
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDepth (this.extend ({
            'symbol': market['id'],
            'type': 'step0',
        }, params));
        return this.parseOrderBook (response['tick'], response['tick']['ts']);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDetailMerged (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (response['tick'], market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    parseTradesData (data, market) {
        let result = [];
        for (let i = 0; i < data.length; i++) {
            let trades = this.parseTrades (data[i]['data'], market);
            for (let k = 0; k < trades.length; k++) {
                result.push (trades[k]);
            }
        }
        return result;
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryTrade (this.extend ({
            'symbol': market['id'],
            'size': 2000,
        }, params));
        return this.parseTradesData (response['data'], market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['id'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['vol'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryKline (this.extend ({
            'symbol': market['id'],
            'period': this.timeframes[timeframe],
            'size': 2000, // max = 2000
        }, params));
        return this.parseOHLCVs (response['data'], market, timeframe, since, limit);
    }

    async loadAccounts (reload = false) {
        if (reload) {
            this.accounts = await this.fetchAccounts ();
        } else {
            if (this.accounts) {
                return this.accounts;
            } else {
                this.accounts = await this.fetchAccounts ();
                this.accountsById = this.indexBy (this.accounts, 'id');
            }
        }
        return this.accounts;
    }

    async fetchAccounts () {
        await this.loadMarkets ();
        let response = await this.privateGetAccountAccounts ();
        return response['data'];
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let response = await this.privateGetAccountAccountsIdBalance (this.extend ({
            'id': this.accounts[0]['id'],
        }, params));
        let balances = response['data']['list'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let uppercase = balance['currency'].toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = undefined;
            if (currency in result)
                account = result[currency];
            else
                account = this.account ();
            if (balance['type'] == 'trade')
                account['free'] = parseFloat (balance['balance']);
            if (balance['type'] == 'frozen')
                account['used'] = parseFloat (balance['balance']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let market = this.market (symbol);
        let order = {
            'account-id': this.accounts[0]['id'],
            'amount': this.amountToPrecision (symbol, amount),
            'symbol': market['id'],
            'type': side + '-' + type,
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostOrderOrdersPlace (this.extend (order, params));
        return {
            'info': response,
            'id': response['data'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrderOrdersIdSubmitcancel ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/';
        if (api == 'market')
            url += api;
        else
            url += this.version;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let timestamp = this.YmdHMS (this.milliseconds (), 'T');
            let request = this.keysort (this.extend ({
                'SignatureMethod': 'HmacSHA256',
                'SignatureVersion': '2',
                'AccessKeyId': this.apiKey,
                'Timestamp': timestamp,
            }, query));
            let auth = this.urlencode (request);
            let payload = [ method, this.hostname, url, auth ].join ("\n");
            let signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
            auth += '&' + this.urlencode ({ 'Signature': signature });
            url += '?' + auth;
            if (method == 'POST') {
                body = this.json (query);
                headers = {
                    'Content-Type': 'application/json',
                };
            }
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],66:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class independentreserve extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'independentreserve',
            'name': 'Independent Reserve',
            'countries': [ 'AU', 'NZ' ], // Australia, New Zealand
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg',
                'api': {
                    'public': 'https://api.independentreserve.com/Public',
                    'private': 'https://api.independentreserve.com/Private',
                },
                'www': 'https://www.independentreserve.com',
                'doc': 'https://www.independentreserve.com/API',
            },
            'api': {
                'public': {
                    'get': [
                        'GetValidPrimaryCurrencyCodes',
                        'GetValidSecondaryCurrencyCodes',
                        'GetValidLimitOrderTypes',
                        'GetValidMarketOrderTypes',
                        'GetValidOrderTypes',
                        'GetValidTransactionTypes',
                        'GetMarketSummary',
                        'GetOrderBook',
                        'GetTradeHistorySummary',
                        'GetRecentTrades',
                        'GetFxRates',
                    ],
                },
                'private': {
                    'post': [
                        'PlaceLimitOrder',
                        'PlaceMarketOrder',
                        'CancelOrder',
                        'GetOpenOrders',
                        'GetClosedOrders',
                        'GetClosedFilledOrders',
                        'GetOrderDetails',
                        'GetAccounts',
                        'GetTransactions',
                        'GetDigitalCurrencyDepositAddress',
                        'GetDigitalCurrencyDepositAddresses',
                        'SynchDigitalCurrencyDepositAddressWithBlockchain',
                        'WithdrawDigitalCurrency',
                        'RequestFiatWithdrawal',
                        'GetTrades',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let baseCurrencies = await this.publicGetValidPrimaryCurrencyCodes ();
        let quoteCurrencies = await this.publicGetValidSecondaryCurrencyCodes ();
        let result = [];
        for (let i = 0; i < baseCurrencies.length; i++) {
            let baseId = baseCurrencies[i];
            let baseIdUppercase = baseId.toUpperCase ();
            let base = this.commonCurrencyCode (baseIdUppercase);
            for (let j = 0; j < quoteCurrencies.length; j++) {
                let quoteId = quoteCurrencies[j];
                let quoteIdUppercase = quoteId.toUpperCase ();
                let quote = this.commonCurrencyCode (quoteIdUppercase);
                let id = baseId + '/' + quoteId;
                let symbol = base + '/' + quote;
                let taker = 0.5 / 100;
                let maker = 0.5 / 100;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'taker': taker,
                    'maker': maker,
                    'info': id,
                });
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostGetAccounts ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let currencyCode = balance['CurrencyCode'];
            let uppercase = currencyCode.toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = this.account ();
            account['free'] = balance['AvailableBalance'];
            account['total'] = balance['TotalBalance'];
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        }, params));
        let timestamp = this.parse8601 (response['CreatedTimestampUtc']);
        return this.parseOrderBook (response, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['CreatedTimestampUtc']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DayHighestPrice'],
            'low': ticker['DayLowestPrice'],
            'bid': ticker['CurrentHighestBidPrice'],
            'ask': ticker['CurrentLowestOfferPrice'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['LastPrice'],
            'change': undefined,
            'percentage': undefined,
            'average': ticker['DayAvgPrice'],
            'baseVolume': ticker['DayVolumeXbtInSecondaryCurrrency'],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketSummary (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        }, params));
        return this.parseTicker (response, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TradeTimestampUtc']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['SecondaryCurrencyTradePrice'],
            'amount': trade['PrimaryCurrencyAmount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetRecentTrades (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'numberOfRecentTradesToRetrieve': 50, // max = 50
        }, params));
        return this.parseTrades (response['Trades'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let capitalizedOrderType = this.capitalize (type);
        let method = 'Place' + capitalizedOrderType + 'Order';
        let orderType = capitalizedOrderType;
        orderType += (side == 'sell') ?  'Offer' : 'Bid';
        let order = this.ordered ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'orderType': orderType,
        });
        if (type == 'limit')
            order['price'] = price;
        order['volume'] = amount;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['OrderGuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'orderGuid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = [
                url,
                'apiKey=' + this.apiKey,
                'nonce=' + nonce.toString (),
            ];
            let keysorted = this.keysort (params);
            let keys = Object.keys (keysorted);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                auth.push (key + '=' + params[key]);
            }
            let message = auth.join (',');
            let signature = this.hmac (this.encode (message), this.encode (this.secret));
            let query = this.keysort (this.extend ({
                'apiKey': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        // todo error handling
        return response;
    }
}

},{"./base/Exchange":8}],67:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class itbit extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'itbit',
            'name': 'itBit',
            'countries': 'US',
            'rateLimit': 2000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
                'api': 'https://api.itbit.com',
                'www': 'https://www.itbit.com',
                'doc': [
                    'https://api.itbit.com/docs',
                    'https://www.itbit.com/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'markets/{symbol}/ticker',
                        'markets/{symbol}/order_book',
                        'markets/{symbol}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'wallets',
                        'wallets/{walletId}',
                        'wallets/{walletId}/balances/{currencyCode}',
                        'wallets/{walletId}/funding_history',
                        'wallets/{walletId}/trades',
                        'wallets/{walletId}/orders/{id}',
                    ],
                    'post': [
                        'wallet_transfers',
                        'wallets',
                        'wallets/{walletId}/cryptocurrency_deposits',
                        'wallets/{walletId}/cryptocurrency_withdrawals',
                        'wallets/{walletId}/orders',
                        'wire_withdrawal',
                    ],
                    'delete': [
                        'wallets/{walletId}/orders/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'XBTUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/SGD': { 'id': 'XBTSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                'BTC/EUR': { 'id': 'XBTEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
            'fees': {
                'trading': {
                    'maker': 0,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetMarketsSymbolOrderBook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetMarketsSymbolTicker (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let serverTimeUTC = ('serverTimeUTC' in ticker);
        if (!serverTimeUTC)
            throw new ExchangeError (this.id + ' fetchTicker returned a bad response: ' + this.json (ticker));
        let timestamp = this.parse8601 (ticker['serverTimeUTC']);
        let vwap = parseFloat (ticker['vwap24h']);
        let baseVolume = parseFloat (ticker['volume24h']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': vwap,
            'open': parseFloat (ticker['openToday']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let id = trade['matchNumber'].toString ();
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': id,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketsSymbolTrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response['recentTrades'], market);
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['availableBalance']),
                'used': 0.0,
                'total': parseFloat (balance['totalBalance']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    fetchWallets () {
        return this.privateGetWallets ();
    }

    nonce () {
        return this.milliseconds ();
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' createOrder requires a walletId parameter');
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'side': side,
            'type': type,
            'currency': market['base'],
            'amount': amount,
            'display': amount,
            'price': price,
            'instrument': market['id'],
        };
        let response = await this.privatePostTradeAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' cancelOrder requires a walletId parameter');
        return await this.privateDeleteWalletsWalletIdOrdersId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            if (Object.keys (query).length)
                body = this.json (query);
            else
                body = '';
            let nonce = this.nonce ().toString ();
            let timestamp = nonce;
            let auth = [ method, url, body, nonce, timestamp ];
            let message = nonce + this.json (auth);
            let hash = this.hash (this.encode (message), 'sha256', 'binary');
            let binhash = this.binaryConcat (url, hash);
            let signature = this.hmac (binhash, this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Authorization': self.apiKey + ':' + signature,
                'Content-Type': 'application/json',
                'X-Auth-Timestamp': timestamp,
                'X-Auth-Nonce': nonce,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],68:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const btcbox = require ('./btcbox.js')

// ---------------------------------------------------------------------------

module.exports = class jubi extends btcbox {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'jubi',
            'name': 'jubi.com',
            'countries': 'CN',
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766581-9d397d9a-5edd-11e7-8fb9-5d8236c0e692.jpg',
                'api': 'https://www.jubi.com/api',
                'www': 'https://www.jubi.com',
                'doc': 'https://www.jubi.com/help/api.html',
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetAllticker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let base = id.toUpperCase ();
            let quote = 'CNY'; // todo
            let symbol = base + '/' + quote;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': id,
            });
        }
        return result;
    }
}

},{"./btcbox.js":30}],69:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeNotAvailable, ExchangeError, OrderNotFound, DDoSProtection, InvalidNonce, InsufficientFunds, CancelPending, InvalidOrder } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class kraken extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'kraken',
            'name': 'Kraken',
            'countries': 'US',
            'version': '0',
            'rateLimit': 3000,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchOrder': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'marketsByAltname': {},
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
                '2w': '21600',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg',
                'api': 'https://api.kraken.com',
                'www': 'https://www.kraken.com',
                'doc': [
                    'https://www.kraken.com/en-us/help/api',
                    'https://github.com/nothingisdead/npm-kraken-api',
                ],
                'fees': 'https://www.kraken.com/en-us/help/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'Assets',
                        'AssetPairs',
                        'Depth',
                        'OHLC',
                        'Spread',
                        'Ticker',
                        'Time',
                        'Trades',
                    ],
                },
                'private': {
                    'post': [
                        'AddOrder',
                        'Balance',
                        'CancelOrder',
                        'ClosedOrders',
                        'DepositAddresses',
                        'DepositMethods',
                        'DepositStatus',
                        'Ledgers',
                        'OpenOrders',
                        'OpenPositions',
                        'QueryLedgers',
                        'QueryOrders',
                        'QueryTrades',
                        'TradeBalance',
                        'TradesHistory',
                        'TradeVolume',
                        'Withdraw',
                        'WithdrawCancel',
                        'WithdrawInfo',
                        'WithdrawStatus',
                    ],
                },
            },
        });
    }

    costToPrecision (symbol, cost) {
        return this.truncate (parseFloat (cost), this.markets[symbol]['precision']['price']);
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (parseFloat (fee), this.markets[symbol]['precision']['amount']);
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (body.indexOf ('Invalid nonce') >= 0)
            throw new InvalidNonce (this.id + ' ' + body);
        if (body.indexOf ('Insufficient funds') >= 0)
            throw new InsufficientFunds (this.id + ' ' + body);
        if (body.indexOf ('Cancel pending') >= 0)
            throw new CancelPending (this.id + ' ' + body);
        if (body.indexOf ('Invalid arguments:volume') >= 0)
            throw new InvalidOrder (this.id + ' ' + body);
    }

    async fetchMarkets () {
        let markets = await this.publicGetAssetPairs ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets['result'][id];
            let base = market['base'];
            let quote = market['quote'];
            if ((base[0] == 'X') || (base[0] == 'Z'))
                base = base.slice (1);
            if ((quote[0] == 'X') || (quote[0] == 'Z'))
                quote = quote.slice (1);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let darkpool = id.indexOf ('.d') >= 0;
            let symbol = darkpool ? market['altname'] : (base + '/' + quote);
            let maker = undefined;
            if ('fees_maker' in market) {
                maker = parseFloat (market['fees_maker'][0][1]) / 100;
            }
            let precision = {
                'amount': market['lot_decimals'],
                'price': market['pair_decimals'],
            };
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'darkpool': darkpool,
                'info': market,
                'altname': market['altname'],
                'maker': maker,
                'taker': parseFloat (market['fees'][0][1]) / 100,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            });
        }
        result = this.appendInactiveMarkets (result);
        this.marketsByAltname = this.indexBy (result, 'altname');
        return result;
    }

    appendInactiveMarkets (result = []) {
        let precision = { 'amount': 8, 'price': 8 };
        let costLimits = { 'min': 0, 'max': undefined };
        let priceLimits = { 'min': Math.pow (10, -precision['price']), 'max': undefined };
        let amountLimits = { 'min': Math.pow (10, -precision['amount']), 'max': Math.pow (10, precision['amount']) };
        let limits = { 'amount': amountLimits, 'price': priceLimits, 'cost': costLimits };
        let defaults = {
            'darkpool': false,
            'info': undefined,
            'maker': undefined,
            'taker': undefined,
            'lot': amountLimits['min'],
            'active': false,
            'precision': precision,
            'limits': limits,
        };
        let markets = [
            { 'id': 'XXLMZEUR', 'symbol': 'XLM/EUR', 'base': 'XLM', 'quote': 'EUR', 'altname': 'XLMEUR' },
        ];
        for (let i = 0; i < markets.length; i++) {
            result.push (this.extend (defaults, markets[i]));
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide an order book for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetDepth (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response['result'][market['id']];
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let baseVolume = parseFloat (ticker['v'][1]);
        let vwap = parseFloat (ticker['p'][1]);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h'][1]),
            'low': parseFloat (ticker['l'][1]),
            'bid': parseFloat (ticker['b'][0]),
            'ask': parseFloat (ticker['a'][0]),
            'vwap': vwap,
            'open': parseFloat (ticker['o']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['c'][0]),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let pairs = [];
        for (let s = 0; s < this.symbols.length; s++) {
            let symbol = this.symbols[s];
            let market = this.markets[symbol];
            if (market['active'])
                if (!market['darkpool'])
                    pairs.push (market['id']);
        }
        let filter = pairs.join (',');
        let response = await this.publicGetTicker (this.extend ({
            'pair': filter,
        }, params));
        let tickers = response['result'];
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide a ticker for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetTicker (this.extend ({
            'pair': market['id'],
        }, params));
        let ticker = response['result'][market['id']];
        return this.parseTicker (ticker, market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[6]),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
            'interval': this.timeframes[timeframe],
        };
        if (since)
            request['since'] = parseInt (since / 1000);
        let response = await this.publicGetOHLC (this.extend (request, params));
        let ohlcvs = response['result'][market['id']];
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        let side = undefined;
        let type = undefined;
        let price = undefined;
        let amount = undefined;
        let id = undefined;
        let order = undefined;
        let fee = undefined;
        if (!market)
            market = this.findMarketByAltnameOrId (trade['pair']);
        if ('ordertxid' in trade) {
            order = trade['ordertxid'];
            id = trade['id'];
            timestamp = parseInt (trade['time'] * 1000);
            side = trade['type'];
            type = trade['ordertype'];
            price = parseFloat (trade['price']);
            amount = parseFloat (trade['vol']);
            if ('fee' in trade) {
                let currency = undefined;
                if (market)
                    currency = market['quote'];
                fee = {
                    'cost': parseFloat (trade['fee']),
                    'currency': currency,
                };
            }
        } else {
            timestamp = parseInt (trade[2] * 1000);
            side = (trade[3] == 's') ? 'sell' : 'buy';
            type = (trade[4] == 'l') ? 'limit' : 'market';
            price = parseFloat (trade[0]);
            amount = parseFloat (trade[1]);
        }
        let symbol = (market) ? market['symbol'] : undefined;
        return {
            'id': id,
            'order': order,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let id = market['id'];
        let response = await this.publicGetTrades (this.extend ({
            'pair': id,
        }, params));
        let trades = response['result'][id];
        return this.parseTrades (trades, market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = currency;
            // X-ISO4217-A3 standard currency codes
            if (code[0] == 'X') {
                code = code.slice (1);
            } else if (code[0] == 'Z') {
                code = code.slice (1);
            }
            code = this.commonCurrencyCode (code);
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'pair': market['id'],
            'type': side,
            'ordertype': type,
            'volume': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostAddOrder (this.extend (order, params));
        let length = response['result']['txid'].length;
        let id = (length > 1) ? response['result']['txid'] : response['result']['txid'][0];
        return {
            'info': response,
            'id': id,
        };
    }

    findMarketByAltnameOrId (id) {
        let result = undefined;
        if (id in this.marketsByAltname) {
            result = this.marketsByAltname[id];
        } else if (id in this.markets_by_id) {
            result = this.markets_by_id[id];
        }
        return result;
    }

    parseOrder (order, market = undefined) {
        let description = order['descr'];
        let side = description['type'];
        let type = description['ordertype'];
        let symbol = undefined;
        if (!market)
            market = this.findMarketByAltnameOrId (description['pair']);
        let timestamp = parseInt (order['opentm'] * 1000);
        let amount = parseFloat (order['vol']);
        let filled = parseFloat (order['vol_exec']);
        let remaining = amount - filled;
        let fee = undefined;
        let cost = this.safeFloat (order, 'cost');
        let price = this.safeFloat (description, 'price');
        if (!price)
            price = this.safeFloat (order, 'price');
        if (market) {
            symbol = market['symbol'];
            if ('fee' in order) {
                let flags = order['oflags'];
                let feeCost = this.safeFloat (order, 'fee');
                fee = {
                    'cost': feeCost,
                    'rate': undefined,
                };
                if (flags.indexOf ('fciq') >= 0) {
                    fee['currency'] = market['quote'];
                } else if (flags.indexOf ('fcib') >= 0) {
                    fee['currency'] = market['base'];
                }
            }
        }
        return {
            'id': order['id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': fee,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    }

    parseOrders (orders, market = undefined) {
        let result = [];
        let ids = Object.keys (orders);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = this.extend ({ 'id': id }, orders[id]);
            result.push (this.parseOrder (order, market));
        }
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostQueryOrders (this.extend ({
            'trades': true, // whether or not to include trades in output (optional, default false)
            'txid': id, // comma delimited list of transaction ids to query info about (20 maximum)
            // 'userref': 'optional', // restrict results to given user reference id (optional)
        }, params));
        let orders = response['result'];
        let order = this.parseOrder (this.extend ({ 'id': id }, orders[id]));
        return this.extend ({ 'info': response }, order);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            // 'type': 'all', // any position, closed position, closing position, no position
            // 'trades': false, // whether or not to include trades related to position in output
            // 'start': 1234567890, // starting unix timestamp or trade tx id of results (exclusive)
            // 'end': 1234567890, // ending unix timestamp or trade tx id of results (inclusive)
            // 'ofs' = result offset
        };
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostTradesHistory (this.extend (request, params));
        let trades = response['result']['trades'];
        let ids = Object.keys (trades);
        for (let i = 0; i < ids.length; i++) {
            trades[ids[i]]['id'] = ids[i];
        }
        return this.parseTrades (trades);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelOrder (this.extend ({
                'txid': id,
            }, params));
        } catch (e) {
            if (this.last_http_response)
                if (this.last_http_response.indexOf ('EOrder:Unknown order') >= 0)
                    throw new OrderNotFound (this.id + ' cancelOrder() error ' + this.last_http_response);
            throw e;
        }
        return response;
    }

    async withdraw (currency, amount, address, params = {}) {
        if ('key' in params) {
            await this.loadMarkets ();
            let response = await this.privatePostWithdraw (this.extend ({
                'asset': currency,
                'amount': amount,
                // 'address': address, // they don't allow withdrawals to direct addresses
            }, params));
            return {
                'info': response,
                'id': response['result'],
            };
        }
        throw new ExchangeError (this.id + " withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)");
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostOpenOrders (this.extend (request, params));
        let orders = this.parseOrders (response['result']['open']);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostClosedOrders (this.extend (request, params));
        let orders = this.parseOrders (response['result']['closed']);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + api + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            let auth = this.encode (nonce + body);
            let hash = this.hash (auth, 'sha256', 'binary');
            let binary = this.stringToBinary (this.encode (url));
            let binhash = this.binaryConcat (binary, hash);
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (binhash, secret, 'sha512', 'base64');
            headers = {
                'API-Key': this.apiKey,
                'API-Sign': this.decode (signature),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    nonce () {
        return this.milliseconds ();
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            let numErrors = response['error'].length;
            if (numErrors) {
                for (let i = 0; i < response['error'].length; i++) {
                    if (response['error'][i] == 'EService:Unavailable')
                        throw new ExchangeNotAvailable (this.id + ' ' + this.json (response));
                    if (response['error'][i] == 'EService:Busy')
                        throw new DDoSProtection (this.id + ' ' + this.json (response));
                }
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],70:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const acx = require ('./acx.js')
const { ExchangeError, InsufficientFunds, OrderNotFound } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class kuna extends acx {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'kuna',
            'name': 'Kuna',
            'countries': 'UA',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchTickers': false,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31697638-912824fa-b3c1-11e7-8c36-cf9606eb94ac.jpg',
                'api': 'https://kuna.io',
                'www': 'https://kuna.io',
                'doc': 'https://kuna.io/documents/api',
            },
            'api': {
                'public': {
                    'get': [
                        'tickers/{market}',
                        'order_book',
                        'order_book/{market}',
                        'trades',
                        'trades/{market}',
                        'timestamp',
                    ],
                },
                'private': {
                    'get': [
                        'members/me',
                        'orders',
                        'trades/my',
                    ],
                    'post': [
                        'orders',
                        'order/delete',
                    ],
                },
            },
            'markets': {
                'BTC/UAH': { 'id': 'btcuah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
                'ETH/UAH': { 'id': 'ethuah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
                'GBG/UAH': { 'id': 'gbguah', 'symbol': 'GBG/UAH', 'base': 'GBG', 'quote': 'UAH', 'precision': { 'amount': 3, 'price': 2 }, 'lot': 0.001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.01, 'max': undefined }}}, // Golos Gold (GBG != GOLOS)
                'KUN/BTC': { 'id': 'kunbtc', 'symbol': 'KUN/BTC', 'base': 'KUN', 'quote': 'BTC', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }}},
                'BCH/BTC': { 'id': 'bchbtc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }}},
                'WAVES/UAH': { 'id': 'wavesuah', 'symbol': 'WAVES/UAH', 'base': 'WAVES', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
            },
            'fees': {
                'trading': {
                    'taker': 0.25 / 100,
                    'maker': 0.25 / 100,
                },
            },
        });
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            let data = JSON.parse (body);
            let error = data['error'];
            let errorMessage = error['message'];
            if (errorMessage.indexOf ('cannot lock funds') >= 0) {
                throw new InsufficientFunds ([ this.id, method, url, code, reason, body ].join (' '));
            } else if (errorMessage.indexOf ("Couldn't find Order") >= 0) {
                throw new OrderNotFound ([ this.id, method, url, code, reason, body ].join (' '));
            }
        }
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderBook = await this.publicGetOrderBook (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseOrderBook (orderBook, undefined, 'bids', 'asks', 'price', 'volume');
    }

    async fetchL3OrderBook (symbol, params) {
        return this.fetchOrderBook (symbol, params);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol argument');
        let market = this.market (symbol);
        let orders = await this.privateGetOrders (this.extend ({
            'market': market['id'],
        }, params));
        // todo emulation of fetchClosedOrders, fetchOrders, fetchOrder
        // with order cache + fetchOpenOrders
        // as in BTC-e, Liqui, Yobit, DSX, Tidex, WEX
        return this.parseOrders (orders, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['volume']),
            'info': trade,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    parseMyTrade (trade, market) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'price': trade['price'],
            'amount': trade['volume'],
            'cost': trade['funds'],
            'symbol': symbol,
            'side': trade['side'],
            'order': trade['order_id'],
        };
    }

    parseMyTrades (trades, market = undefined) {
        let parsedTrades = [];
        for (let i = 0; i < trades.length; i++) {
            let trade = trades[i];
            let parsedTrade = this.parseMyTrade (trade, market);
            parsedTrades.push (parsedTrade);
        }
        return parsedTrades;
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol argument');
        let market = this.market (symbol);
        let response = await this.privateGetTradesMy ({ 'market': market['id'] });
        return this.parseMyTrades (response, market);
    }
}

},{"./acx.js":5,"./base/errors":10}],71:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class lakebtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'lakebtc',
            'name': 'LakeBTC',
            'countries': 'US',
            'version': 'api_v2',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg',
                'api': 'https://api.lakebtc.com',
                'www': 'https://www.lakebtc.com',
                'doc': [
                    'https://www.lakebtc.com/s/api_v2',
                    'https://www.lakebtc.com/s/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'bcorderbook',
                        'bctrades',
                        'ticker',
                    ],
                },
                'private': {
                    'post': [
                        'buyOrder',
                        'cancelOrders',
                        'getAccountInfo',
                        'getExternalAccounts',
                        'getOrders',
                        'getTrades',
                        'openOrders',
                        'sellOrder',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.15 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ();
        let result = [];
        let keys = Object.keys (markets);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let market = markets[id];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['balance'];
        let result = { 'info': response };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBcorderbook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTicker (this.extend ({
            'symbol': market['id'],
        }, params));
        let ticker = tickers[market['id']];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetBctrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePost' + this.capitalize (side) + 'Order';
        let marketId = this.marketId (market);
        let order = {
            'params': [ price, amount, marketId ],
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'params': id });
    }

    nonce () {
        return this.microseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public') {
            url += '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            if (Object.keys (params).length)
                params = params.join (',');
            else
                params = '';
            let query = this.urlencode ({
                'tonce': nonce,
                'accesskey': this.apiKey,
                'requestmethod': method.toLowerCase (),
                'id': nonce,
                'method': path,
                'params': params,
            });
            body = this.json ({
                'method': path,
                'params': params,
                'id': nonce,
            });
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha1');
            let auth = this.encode (this.apiKey + ':' + signature);
            headers = {
                'Json-Rpc-Tonce': nonce,
                'Authorization': "Basic " + this.decode (this.stringToBase64 (auth)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],72:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class liqui extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'liqui',
            'name': 'Liqui',
            'countries': 'UA',
            'rateLimit': 2500,
            'version': '3',
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchOrder': true,
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchTickers': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg',
                'api': {
                    'public': 'https://api.liqui.io/api',
                    'private': 'https://api.liqui.io/tapi',
                },
                'www': 'https://liqui.io',
                'doc': 'https://liqui.io/api',
                'fees': 'https://liqui.io/fee',
            },
            'api': {
                'public': {
                    'get': [
                        'info',
                        'ticker/{pair}',
                        'depth/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'Trade',
                        'ActiveOrders',
                        'OrderInfo',
                        'CancelOrder',
                        'TradeHistory',
                        'TransHistory',
                        'CoinDepositAddress',
                        'WithdrawCoin',
                        'CreateCoupon',
                        'RedeemCoupon',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.001,
                    'taker': 0.0025,
                },
                'funding': 0.0,
            },
        });
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': cost,
        };
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency;
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'BCC')
            return 'BCH';
        if (currency == 'DRK')
            return 'DASH';
        // they misspell DASH as dsh :/
        if (currency == 'DSH')
            return 'DASH';
        return currency;
    }

    getBaseQuoteFromMarketId (id) {
        let uppercase = id.toUpperCase ();
        let [ base, quote ] = uppercase.split ('_');
        base = this.commonCurrencyCode (base);
        quote = this.commonCurrencyCode (quote);
        return [ base, quote ];
    }

    async fetchMarkets () {
        let response = await this.publicGetInfo ();
        let markets = response['pairs'];
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ base, quote ] = this.getBaseQuoteFromMarketId (id);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': this.safeInteger (market, 'decimal_places'),
                'price': this.safeInteger (market, 'decimal_places'),
            };
            let amountLimits = {
                'min': this.safeFloat (market, 'min_amount'),
                'max': this.safeFloat (market, 'max_amount'),
            };
            let priceLimits = {
                'min': this.safeFloat (market, 'min_price'),
                'max': this.safeFloat (market, 'max_price'),
            };
            let costLimits = {
                'min': this.safeFloat (market, 'min_total'),
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
                'cost': costLimits,
            };
            let active = (market['hidden'] == 0);
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'taker': market['fee'] / 100,
                'lot': amountLimits['min'],
                'precision': precision,
                'limits': limits,
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let funds = balances['funds'];
        let currencies = Object.keys (funds);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            uppercase = this.commonCurrencyCode (uppercase);
            let total = undefined;
            let used = undefined;
            if (balances['open_orders'] == 0) {
                total = funds[currency];
                used = 0.0;
            }
            let account = {
                'free': funds[currency],
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetDepthPair (this.extend ({
            'pair': market['id'],
        }, params));
        let market_id_in_reponse = (market['id'] in response);
        if (!market_id_in_reponse)
            throw new ExchangeError (this.id + ' ' + market['symbol'] + ' order book is empty or not available');
        let orderbook = response[market['id']];
        let result = this.parseOrderBook (orderbook);
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol_cur'),
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let ids = undefined;
        if (!symbols) {
            let numIds = this.ids.length;
            if (numIds > 256)
                throw new ExchangeError (this.id + ' fetchTickers() requires symbols argument');
            ids = this.ids;
        } else {
            ids = this.marketIds (symbols);
        }
        let tickers = await this.publicGetTickerPair (this.extend ({
            'pair': ids.join ('-'),
        }, params));
        let result = {};
        let keys = Object.keys (tickers);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let tickers = await this.fetchTickers ([ symbol ], params);
        return tickers[symbol];
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = trade['type'];
        if (side == 'ask')
            side = 'sell';
        if (side == 'bid')
            side = 'buy';
        let price = this.safeFloat (trade, 'price');
        if ('rate' in trade)
            price = this.safeFloat (trade, 'rate');
        let id = this.safeString (trade, 'tid');
        if ('trade_id' in trade)
            id = this.safeString (trade, 'trade_id');
        let order = this.safeString (trade, this.getOrderIdKey ());
        if ('pair' in trade) {
            let marketId = trade['pair'];
            market = this.markets_by_id[marketId];
        }
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let amount = trade['amount'];
        let type = 'limit'; // all trades are still limit trades
        let fee = undefined;
        // this is filled by fetchMyTrades() only
        // is_your_order is always false :\
        // let isYourOrder = this.safeValue (trade, 'is_your_order');
        // let takerOrMaker = 'taker';
        // if (isYourOrder)
        //     takerOrMaker = 'maker';
        // let fee = this.calculateFee (symbol, type, side, amount, price, takerOrMaker);
        return {
            'id': id,
            'order': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'fee': fee,
            'info': trade,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetTradesPair (this.extend (request, params));
        return this.parseTrades (response[market['id']], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
            'type': side,
            'amount': this.amountToPrecision (symbol, amount),
            'rate': this.priceToPrecision (symbol, price),
        };
        let response = await this.privatePostTrade (this.extend (request, params));
        let id = this.safeString (response['return'], this.getOrderIdKey ());
        if (!id)
            id = this.safeString (response['return'], 'init_order_id');
        let timestamp = this.milliseconds ();
        price = parseFloat (price);
        amount = parseFloat (amount);
        let order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'remaining': amount,
            'filled': 0.0,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
        this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    getOrderIdKey () {
        return 'order_id';
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            let request = {};
            let idKey = this.getOrderIdKey ();
            request[idKey] = id;
            response = await this.privatePostCancelOrder (this.extend (request, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'error');
                if (message) {
                    if (message.indexOf ('not found') >= 0)
                        throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
                }
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let id = order['id'].toString ();
        let status = order['status'];
        if (status == 0) {
            status = 'open';
        } else if (status == 1) {
            status = 'closed';
        } else if ((status == 2) || (status == 3)) {
            status = 'canceled';
        }
        let timestamp = parseInt (order['timestamp_created']) * 1000;
        let symbol = undefined;
        if (!market)
            market = this.markets_by_id[order['pair']];
        if (market)
            symbol = market['symbol'];
        let remaining = this.safeFloat (order, 'amount');
        let amount = this.safeFloat (order, 'start_amount', remaining);
        if (typeof amount == 'undefined') {
            if (id in this.orders) {
                amount = this.safeFloat (this.orders[id], 'amount');
            }
        }
        let price = this.safeFloat (order, 'rate');
        let filled = undefined;
        let cost = undefined;
        if (typeof amount != 'undefined') {
            if (typeof remaining != 'undefined') {
                filled = amount - remaining;
                cost = price * filled;
            }
        }
        let fee = undefined;
        let result = {
            'info': order,
            'id': id,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'type': 'limit',
            'side': order['type'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'remaining': remaining,
            'filled': filled,
            'status': status,
            'fee': fee,
        };
        return result;
    }

    parseOrders (orders, market = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderInfo (this.extend ({
            'order_id': parseInt (id),
        }, params));
        id = id.toString ();
        let newOrder = this.parseOrder (this.extend ({ 'id': id }, response['return'][id]));
        let oldOrder = (id in this.orders) ? this.orders[id] : {};
        this.orders[id] = this.extend (oldOrder, newOrder);
        return this.orders[id];
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = { 'pair': market['id'] };
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        let openOrders = [];
        if ('return' in response)
            openOrders = this.parseOrders (response['return'], market);
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (order['symbol'] == symbol)
                result.push (order);
        }
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'open')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'closed')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'from': 123456789, // trade ID, from which the display starts numerical 0
            // 'count': 1000, // the number of trades for display numerical, default = 1000
            // 'from_id': trade ID, from which the display starts numerical 0
            // 'end_id': trade ID on which the display ends numerical 
            // 'order': 'ASC', // sorting, default = DESC
            // 'since': 1234567890, // UTC start time, default = 0
            // 'end': 1234567890, // UTC end time, default = 
            // 'pair': 'eth_btc', // default = all markets
        };
        if (symbol) {
            market = this.market (symbol);
            request['pair'] = market['id'];
        }
        if (limit)
            request['count'] = parseInt (limit);
        if (since)
            request['since'] = parseInt (since / 1000);
        let response = await this.privatePostTradeHistory (this.extend (request, params));
        let trades = [];
        if ('return' in response)
            trades = response['return'];
        return this.parseTrades (trades, market);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawCoin (this.extend ({
            'coinName': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['return']['tId'],
        };
    }

    signBodyWithSecret (body) {
        return this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
    }

    getVersionString () {
        return '/' + this.version;
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
                'method': path,
            }, query));
            let signature = this.signBodyWithSecret (body);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': signature,
            };
        } else {
            url += this.getVersionString () + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (!response['success']) {
                if (response['error'].indexOf ('Not enougth') >= 0) { // not enougTh is a typo inside Liqui's own API...
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                } else if (response['error'] == 'Requests too often') {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else if ((response['error'] == 'not available') || (response['error'] == 'external service unavailable')) {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],73:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class livecoin extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'livecoin',
            'name': 'LiveCoin',
            'countries': [ 'US', 'UK', 'RU' ],
            'rateLimit': 1000,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg',
                'api': 'https://api.livecoin.net',
                'www': 'https://www.livecoin.net',
                'doc': 'https://www.livecoin.net/api?lang=en',
            },
            'api': {
                'public': {
                    'get': [
                        'exchange/all/order_book',
                        'exchange/last_trades',
                        'exchange/maxbid_minask',
                        'exchange/order_book',
                        'exchange/restrictions',
                        'exchange/ticker', // omit params to get all tickers at once
                        'info/coinInfo',
                    ],
                },
                'private': {
                    'get': [
                        'exchange/client_orders',
                        'exchange/order',
                        'exchange/trades',
                        'exchange/commission',
                        'exchange/commissionCommonInfo',
                        'payment/balances',
                        'payment/balance',
                        'payment/get/address',
                        'payment/history/size',
                        'payment/history/transactions',
                    ],
                    'post': [
                        'exchange/buylimit',
                        'exchange/buymarket',
                        'exchange/cancellimit',
                        'exchange/selllimit',
                        'exchange/sellmarket',
                        'payment/out/capitalist',
                        'payment/out/card',
                        'payment/out/coin',
                        'payment/out/okpay',
                        'payment/out/payeer',
                        'payment/out/perfectmoney',
                        'payment/voucher/amount',
                        'payment/voucher/make',
                        'payment/voucher/redeem',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetExchangeTicker ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['symbol'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            let taker = 0.18 / 100;
            let maker = 0.18 / 100;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'maker': maker,
                'taker': taker,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetPaymentBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = undefined;
            if (currency in result)
                account = result[currency];
            else
                account = this.account ();
            if (balance['type'] == 'total')
                account['total'] = parseFloat (balance['value']);
            if (balance['type'] == 'available')
                account['free'] = parseFloat (balance['value']);
            if (balance['type'] == 'trade')
                account['used'] = parseFloat (balance['value']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetExchangeOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPrice': 'false',
            'depth': 100,
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetExchangeTicker (params);
        let tickers = this.indexBy (response, 'symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetExchangeTicker (this.extend ({
            'currencyPair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['time'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['id'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExchangeLastTrades (this.extend ({
            'currencyPair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePostExchange' + this.capitalize (side) + type;
        let market = this.market (symbol);
        let order = {
            'quantity': amount,
            'currencyPair': market['id'],
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderId'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostExchangeCancellimit (this.extend ({
            'orderId': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        let query = this.urlencode (this.keysort (params));
        if (method == 'GET') {
            if (Object.keys (params).length) {
                url += '?' + query;
            }
        }
        if (api == 'private') {
            this.checkRequiredCredentials ();
            if (method == 'POST')
                body = query;
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha256');
            headers = {
                'Api-Key': this.apiKey,
                'Sign': signature.toUpperCase (),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],74:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class luno extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'luno',
            'name': 'luno',
            'countries': [ 'GB', 'SG', 'ZA' ],
            'rateLimit': 3000,
            'version': '1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg',
                'api': 'https://api.mybitx.com/api',
                'www': 'https://www.luno.com',
                'doc': [
                    'https://www.luno.com/en/api',
                    'https://npmjs.org/package/bitx',
                    'https://github.com/bausmeier/node-bitx',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'orderbook',
                        'ticker',
                        'tickers',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/{id}/pending',
                        'accounts/{id}/transactions',
                        'balance',
                        'fee_info',
                        'funding_address',
                        'listorders',
                        'listtrades',
                        'orders/{id}',
                        'quotes/{id}',
                        'withdrawals',
                        'withdrawals/{id}',
                    ],
                    'post': [
                        'accounts',
                        'postorder',
                        'marketorder',
                        'stoporder',
                        'funding_address',
                        'withdrawals',
                        'send',
                        'quotes',
                        'oauth2/grant',
                    ],
                    'put': [
                        'quotes/{id}',
                    ],
                    'delete': [
                        'quotes/{id}',
                        'withdrawals/{id}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['pair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['balance'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = this.commonCurrencyCode (balance['asset']);
            let reserved = parseFloat (balance['reserved']);
            let unconfirmed = parseFloat (balance['unconfirmed']);
            let account = {
                'free': parseFloat (balance['balance']),
                'used': this.sum (reserved, unconfirmed),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['rolling_24_hour_volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTickers (params);
        let tickers = this.indexBy (response['tickers'], 'pair');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTicker (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let side = (trade['is_buy']) ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': undefined,
            'order': undefined,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['volume']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePost';
        let order = { 'pair': this.marketId (market) };
        if (type == 'market') {
            method += 'Marketorder';
            order['type'] = side.toUpperCase ();
            if (side == 'buy')
                order['counter_volume'] = amount;
            else
                order['base_volume'] = amount;
        } else {
            method += 'Order';
            order['volume'] = amount;
            order['price'] = price;
            if (side == 'buy')
                order['type'] = 'BID';
            else
                order['type'] = 'ASK';
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostStoporder ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let auth = this.encode (this.apiKey + ':' + this.secret);
            auth = this.stringToBase64 (auth);
            headers = { 'Authorization': 'Basic ' + this.decode (auth) };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],75:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class mercado extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'mercado',
            'name': 'Mercado Bitcoin',
            'countries': 'BR', // Brazil
            'rateLimit': 1000,
            'version': 'v3',
            'hasCORS': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg',
                'api': {
                    'public': 'https://www.mercadobitcoin.net/api',
                    'private': 'https://www.mercadobitcoin.net/tapi',
                },
                'www': 'https://www.mercadobitcoin.com.br',
                'doc': [
                    'https://www.mercadobitcoin.com.br/api-doc',
                    'https://www.mercadobitcoin.com.br/trade-api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{coin}/orderbook/', // last slash critical
                        '{coin}/ticker/',
                        '{coin}/trades/',
                        '{coin}/trades/{from}/',
                        '{coin}/trades/{from}/{to}',
                        '{coin}/day-summary/{year}/{month}/{day}/',
                    ],
                },
                'private': {
                    'post': [
                        'cancel_order',
                        'get_account_info',
                        'get_order',
                        'get_withdrawal',
                        'list_system_messages',
                        'list_orders',
                        'list_orderbook',
                        'place_buy_order',
                        'place_sell_order',
                        'withdraw_coin',
                    ],
                },
            },
            'markets': {
                'BTC/BRL': { 'id': 'BRLBTC', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'suffix': 'Bitcoin' },
                'LTC/BRL': { 'id': 'BRLLTC', 'symbol': 'LTC/BRL', 'base': 'LTC', 'quote': 'BRL', 'suffix': 'Litecoin' },
                'BCH/BRL': { 'id': 'BRLBCH', 'symbol': 'BCH/BRL', 'base': 'BCH', 'quote': 'BRL', 'suffix': 'BCash' },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.7 / 100,
                },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetCoinOrderbook (this.extend ({
            'coin': market['base'],
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCoinTicker (this.extend ({
            'coin': market['base'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseInt (ticker['date']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCoinTrades (this.extend ({
            'coin': market['base'],
        }, params));
        return this.parseTrades (response, market);
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['response_data']['balance'];
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances) {
                account['free'] = parseFloat (balances[lowercase]['available']);
                account['total'] = parseFloat (balances[lowercase]['total']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePostPlace' + this.capitalize (side) + 'Order';
        let order = {
            'coin_pair': this.marketId (symbol),
            'quantity': amount,
            'limit_price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['response_data']['order']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'coin': currency,
            'quantity': amount.toFixed (10),
            'address': address,
        };
        if (currency == 'BRL') {
            let account_ref = ('account_ref' in params);
            if (!account_ref)
                throw new ExchangeError (this.id + ' requires account_ref parameter to withdraw ' + currency);
        } else if (currency != 'LTC') {
            let tx_fee = ('tx_fee' in params);
            if (!tx_fee)
                throw new ExchangeError (this.id + ' requires tx_fee parameter to withdraw ' + currency);
        }
        let response = await this.privatePostWithdrawCoin (this.extend (request, params));
        return {
            'info': response,
            'id': response['response_data']['withdrawal']['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api == 'public') {
            url += this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            url += this.version + '/';
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'tapi_method': path,
                'tapi_nonce': nonce,
            }, params));
            let auth = '/tapi/' + this.version + '/' + '?' + body;
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'TAPI-ID': this.apiKey,
                'TAPI-MAC': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error_message' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],76:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class mixcoins extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'mixcoins',
            'name': 'MixCoins',
            'countries': [ 'GB', 'HK' ],
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg',
                'api': 'https://mixcoins.com/api',
                'www': 'https://mixcoins.com',
                'doc': 'https://mixcoins.com/help/api/',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'trades',
                        'depth',
                    ],
                },
                'private': {
                    'post': [
                        'cancel',
                        'info',
                        'orders',
                        'order',
                        'transactions',
                        'trade',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0015, 'taker': 0.0025 },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                'BCH/BTC': { 'id': 'bcc_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'maker': 0.0015, 'taker': 0.0025 },
                'BCH/USD': { 'id': 'bcc_usd', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
                'ETH/USD': { 'id': 'eth_usd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        let balance = response['result']['wallet'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balance) {
                account['free'] = parseFloat (balance[lowercase]['avail']);
                account['used'] = parseFloat (balance[lowercase]['lock']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetDepth (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (response['result']);
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let ticker = response['result'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response['result'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'market': this.marketId (symbol),
            'op': side,
            'amount': amount,
        };
        if (type == 'market') {
            order['order_type'] = 1;
            order['price'] = price;
        } else {
            order['order_type'] = 0;
        }
        let response = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['result']['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.secret, 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 200)
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],77:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class nova extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'nova',
            'name': 'Novaexchange',
            'countries': 'TZ', // Tanzania
            'rateLimit': 2000,
            'version': 'v2',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30518571-78ca0bca-9b8a-11e7-8840-64b83a4a94b2.jpg',
                'api': 'https://novaexchange.com/remote',
                'www': 'https://novaexchange.com',
                'doc': 'https://novaexchange.com/remote/faq',
            },
            'api': {
                'public': {
                    'get': [
                        'markets/',
                        'markets/{basecurrency}/',
                        'market/info/{pair}/',
                        'market/orderhistory/{pair}/',
                        'market/openorders/{pair}/buy/',
                        'market/openorders/{pair}/sell/',
                        'market/openorders/{pair}/both/',
                        'market/openorders/{pair}/{ordertype}/',
                    ],
                },
                'private': {
                    'post': [
                        'getbalances/',
                        'getbalance/{currency}/',
                        'getdeposits/',
                        'getwithdrawals/',
                        'getnewdepositaddress/{currency}/',
                        'getdepositaddress/{currency}/',
                        'myopenorders/',
                        'myopenorders_market/{pair}/',
                        'cancelorder/{orderid}/',
                        'withdraw/{currency}/',
                        'trade/{pair}/',
                        'tradehistory/',
                        'getdeposithistory/',
                        'getwithdrawalhistory/',
                        'walletstatus/',
                        'walletstatus/{currency}/',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetMarkets ();
        let markets = response['markets'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            if (!market['disabled']) {
                let id = market['marketname'];
                let [ quote, base ] = id.split ('_');
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                });
            }
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetMarketOpenordersPairBoth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketInfoPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let ticker = response['markets'][0];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change24h']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume24h']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['unix_t_datestamp'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['tradetype'].toLowerCase (),
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderhistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['items'], market);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetbalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let lockbox = parseFloat (balance['amount_lockbox']);
            let trades = parseFloat (balance['amount_trades']);
            let account = {
                'free': parseFloat (balance['amount']),
                'used': this.sum (lockbox, trades),
                'total': parseFloat (balance['amount_total']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'tradetype': side.toUpperCase (),
            'tradeamount': amount,
            'tradeprice': price,
            'tradebase': 1,
            'pair': market['id'],
        };
        let response = await this.privatePostTradePair (this.extend (order, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelorder (this.extend ({
            'orderid': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'private')
            url += api + '/';
        url += this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            url += '?' + this.urlencode ({ 'nonce': nonce });
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512', 'base64');
            body = this.urlencode (this.extend ({
                'apikey': this.apiKey,
                'signature': signature,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] != 'success')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],78:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

// ---------------------------------------------------------------------------

module.exports = class okcoincny extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okcoincny',
            'name': 'OKCoin CNY',
            'countries': 'CN',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766792-8be9157a-5ee5-11e7-926c-6d69b8d3378d.jpg',
                'api': {
                    'web': 'https://www.okcoin.cn',
                    'public': 'https://www.okcoin.cn/pai',
                    'private': 'https://www.okcoin.cn/api',
                },
                'www': 'https://www.okcoin.cn',
                'doc': 'https://www.okcoin.cn/rest_getStarted.html',
            },
            'markets': {
                'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
            },
        });
    }
}

},{"./okcoinusd.js":79}],79:[function(require,module,exports){
"use strict"

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class okcoinusd extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okcoinusd',
            'name': 'OKCoin USD',
            'countries': [ 'CN', 'US' ],
            'hasCORS': false,
            'version': 'v1',
            'rateLimit': 1000, // up to 3000 requests per 5 minutes  600 requests per minute  10 requests per second  100 ms
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'extension': '.do', // appended to endpoint URL
            'hasFutureMarkets': false,
            'timeframes': {
                '1m': '1min',
                '3m': '3min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '1hour',
                '2h': '2hour',
                '4h': '4hour',
                '6h': '6hour',
                '12h': '12hour',
                '1d': '1day',
                '3d': '3day',
                '1w': '1week',
            },
            'api': {
                'web': {
                    'get': [
                        'markets/currencies',
                        'markets/products',
                    ],
                },
                'public': {
                    'get': [
                        'depth',
                        'exchange_rate',
                        'future_depth',
                        'future_estimated_price',
                        'future_hold_amount',
                        'future_index',
                        'future_kline',
                        'future_price_limit',
                        'future_ticker',
                        'future_trades',
                        'kline',
                        'otcs',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'account_records',
                        'batch_trade',
                        'borrow_money',
                        'borrow_order_info',
                        'borrows_info',
                        'cancel_borrow',
                        'cancel_order',
                        'cancel_otc_order',
                        'cancel_withdraw',
                        'future_batch_trade',
                        'future_cancel',
                        'future_devolve',
                        'future_explosive',
                        'future_order_info',
                        'future_orders_info',
                        'future_position',
                        'future_position_4fix',
                        'future_trade',
                        'future_trades_history',
                        'future_userinfo',
                        'future_userinfo_4fix',
                        'lend_depth',
                        'order_fee',
                        'order_history',
                        'order_info',
                        'orders_info',
                        'otc_order_history',
                        'otc_order_info',
                        'repayment',
                        'submit_otc_order',
                        'trade',
                        'trade_history',
                        'trade_otc_order',
                        'withdraw',
                        'withdraw_info',
                        'unrepayments_info',
                        'userinfo',
                    ],
                },
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg',
                'api': {
                    'web': 'https://www.okcoin.com/v2',
                    'public': 'https://www.okcoin.com/api',
                    'private': 'https://www.okcoin.com/api',
                },
                'www': 'https://www.okcoin.com',
                'doc': [
                    'https://www.okcoin.com/rest_getStarted.html',
                    'https://www.npmjs.com/package/okcoin.com',
                ],
            },
        });
    }

    async fetchMarkets () {
        let response = await this.webGetMarketsProducts ();
        let markets = response['data'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let id = markets[i]['symbol'];
            let uppercase = id.toUpperCase ();
            let [ base, quote ] = uppercase.split ('_');
            let symbol = base + '/' + quote;
            let precision = {
                'amount': markets[i]['maxSizeDigit'],
                'price': markets[i]['maxPriceDigit'],
            };
            let lot = Math.pow (10, -precision['amount']);
            let market = this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': markets[i],
                'type': 'spot',
                'spot': true,
                'future': false,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': markets[i]['minTradeSize'],
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            });
            result.push (market);
            if ((this.hasFutureMarkets) && (market['quote'] == 'USDT')) {
                result.push (this.extend (market, {
                    'quote': 'USD',
                    'symbol': market['base'] + '/USD',
                    'id': market['id'].replace ('usdt', 'usd'),
                    'type': 'future',
                    'spot': false,
                    'future': true,
                }));
            }
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Depth';
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': this.sortBy (orderbook['asks'], 0),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Ticker';
        let response = await this[method] (this.extend (request, params));
        let timestamp = parseInt (response['date']) * 1000;
        let ticker = this.extend (response['ticker'], { 'timestamp': timestamp });
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'info': trade,
            'timestamp': trade['date_ms'],
            'datetime': this.iso8601 (trade['date_ms']),
            'symbol': symbol,
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Trades';
        let response = await this[method] (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 1440, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
            'type': this.timeframes[timeframe],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Kline';
        if (limit)
            request['size'] = parseInt (limit);
        if (since) {
            request['since'] = since;
        } else {
            request['since'] = this.milliseconds () - 86400000; // last 24 hours
        }
        let response = await this[method] (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostUserinfo ();
        let balances = response['info']['funds'];
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balances['free'], lowercase, 0.0);
            account['used'] = this.safeFloat (balances['freezed'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let order = {
            'symbol': market['id'],
            'type': side,
        };
        if (market['future']) {
            method += 'Future';
            order = this.extend (order, {
                'contract_type': 'this_week', // next_week, quarter
                'match_price': 0, // match best counter party price? 0 or 1, ignores price if 1
                'lever_rate': 10, // leverage rate value: 10 or 20 (10 by default)
                'price': price,
                'amount': amount,
            });
        } else {
            if (type == 'limit') {
                order['price'] = price;
                order['amount'] = amount;
            } else {
                order['type'] += '_market';
                if (side == 'buy') {
                    order['price'] = this.safeFloat (params, 'cost');
                    if (!order['price'])
                        throw new ExchangeError (this.id + ' market buy orders require an additional cost parameter, cost = price * amount');
                } else {
                    order['amount'] = amount;
                }
            }
        }
        params = this.omit (params, 'cost');
        method += 'Trade';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder() requires a symbol argument');
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'order_id': id,
        };
        let method = 'privatePost';
        if (market['future']) {
            method += 'FutureCancel';
            request['contract_type'] = 'this_week'; // next_week, quarter
        } else {
            method += 'CancelOrder';
        }
        let response = await this[method] (this.extend (request, params));
        return response;
    }

    parseOrderStatus (status) {
        if (status == -1)
            return 'canceled';
        if (status == 0)
            return 'open';
        if (status == 1)
            return 'partial';
        if (status == 2)
            return 'closed';
        if (status == 4)
            return 'canceled';
        return status;
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        let type = undefined;
        if ('type' in order) {
            if ((order['type'] == 'buy') || (order['type'] == 'sell')) {
                side = order['type'];
                type = 'limit';
            } else {
                side = (order['type'] == 'buy_market') ? 'buy' : 'sell';
                type = 'market';
            }
        }
        let status = this.parseOrderStatus (order['status']);
        let symbol = undefined;
        if (!market) {
            if ('symbol' in order)
                if (order['symbol'] in this.markets_by_id)
                    market = this.markets_by_id[order['symbol']];
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = undefined;
        if ('create_date' in order)
            timestamp = order['create_date'];
        let amount = order['amount'];
        let filled = order['deal_amount'];
        let remaining = amount - filled;
        let average = order['avg_price'];
        let cost = average * filled;
        let result = {
            'info': order,
            'id': order['order_id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': order['price'],
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + 'fetchOrders requires a symbol parameter');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let request = {
            'order_id': id,
            'symbol': market['id'],
            // 'status': 0, // 0 for unfilled orders, 1 for filled orders
            // 'current_page': 1, // current page number
            // 'page_length': 200, // number of orders returned per page, maximum 200
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'OrderInfo';
        let response = await this[method] (this.extend (request, params));
        return this.parseOrder (response['orders'][0]);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + 'fetchOrders requires a symbol parameter');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let request = {
            'symbol': market['id'],
        };
        let order_id_in_params = ('order_id' in params);
        if (market['future']) {
            method += 'FutureOrdersInfo';
            request['contract_type'] = 'this_week'; // next_week, quarter
            if (!order_id_in_params)
                throw new ExchangeError (this.id + ' fetchOrders() requires order_id param for futures market ' + symbol + ' (a string of one or more order ids, comma-separated)');
        } else {
            let status = undefined;
            if ('type' in params) {
                status = params['type'];
            } else if ('status' in params) {
                status = params['status'];
            } else {
                throw new ExchangeError (this.id + ' fetchOrders() requires type param or status param for spot market ' + symbol + ' (0 or "open" for unfilled orders, 1 or "closed" for filled orders)');
            }
            if (status == 'open')
                status = 0;
            if (status == 'closed')
                status = 1;
            if (order_id_in_params) {
                method += 'OrdersInfo';
                request = this.extend (request, {
                    'type': status,
                });
            } else {
                method += 'OrderHistory';
                request = this.extend (request, {
                    'status': status,
                    'current_page': 1, // current page number
                    'page_length': 200, // number of orders returned per page, maximum 200
                });
            }
            params = this.omit (params, [ 'type', 'status' ]);
        }
        let response = await this[method] (this.extend (request, params));
        return this.parseOrders (response['orders'], market);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let open = 0; // 0 for unfilled orders, 1 for filled orders
        return await this.fetchOrders (symbol, undefined, undefined, this.extend ({
            'status': open,
        }, params));
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let closed = 1; // 0 for unfilled orders, 1 for filled orders
        return await this.fetchOrders (symbol, undefined, undefined, this.extend ({
            'status': closed,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/';
        if (api != 'web')
            url += this.version + '/';
        url += path + this.extension;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let query = this.keysort (this.extend ({
                'api_key': this.apiKey,
            }, params));
            // secret key must be at the end of query
            let queryString = this.rawencode (query) + '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString)).toUpperCase ();
            body = this.urlencode (query);
            headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        url = this.urls['api'][api] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('error_code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],80:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

// ---------------------------------------------------------------------------

module.exports = class okex extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okex',
            'name': 'OKEX',
            'countries': [ 'CN', 'US' ],
            'hasCORS': false,
            'hasFutureMarkets': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                'api': {
                    'web': 'https://www.okex.com/v2',
                    'public': 'https://www.okex.com/api',
                    'private': 'https://www.okex.com/api',
                },
                'www': 'https://www.okex.com',
                'doc': 'https://www.okex.com/rest_getStarted.html',
            },
        });
    }
}

},{"./okcoinusd.js":79}],81:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class paymium extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'paymium',
            'name': 'Paymium',
            'countries': [ 'FR', 'EU' ],
            'rateLimit': 2000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg',
                'api': 'https://paymium.com/api',
                'www': 'https://www.paymium.com',
                'doc': [
                    'https://github.com/Paymium/api-documentation',
                    'https://www.paymium.com/page/developers',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'countries',
                        'data/{id}/ticker',
                        'data/{id}/trades',
                        'data/{id}/depth',
                        'bitcoin_charts/{id}/trades',
                        'bitcoin_charts/{id}/depth',
                    ],
                },
                'private': {
                    'get': [
                        'merchant/get_payment/{UUID}',
                        'user',
                        'user/addresses',
                        'user/addresses/{btc_address}',
                        'user/orders',
                        'user/orders/{UUID}',
                        'user/price_alerts',
                    ],
                    'post': [
                        'user/orders',
                        'user/addresses',
                        'user/payment_requests',
                        'user/price_alerts',
                        'merchant/create_payment',
                    ],
                    'delete': [
                        'user/orders/{UUID}/cancel',
                        'user/price_alerts/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
            'fees': {
                'trading': {
                    'maker': 0.0059,
                    'taker': 0.0059,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privateGetUser ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let balance = 'balance_' + lowercase;
            let locked = 'locked_' + lowercase;
            if (balance in balances)
                account['free'] = balances[balance];
            if (locked in balances)
                account['used'] = balances[locked];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetDataIdDepth (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetDataIdTicker (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = ticker['at'] * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['price']),
            'change': undefined,
            'percentage': parseFloat (ticker['variation']),
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['created_at_int']) * 1000;
        let volume = 'traded_' + market['base'].toLowerCase ();
        return {
            'info': trade,
            'id': trade['uuid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade[volume],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDataIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let order = {
            'type': this.capitalize (type) + 'Order',
            'currency': this.marketId (market),
            'direction': side,
            'amount': amount,
        };
        if (type == 'market')
            order['price'] = price;
        let response = await this.privatePostUserOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['uuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'orderNumber': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            body = this.json (params);
            let nonce = this.nonce ().toString ();
            let auth = nonce + url + body;
            headers = {
                'Api-Key': this.apiKey,
                'Api-Signature': this.hmac (this.encode (auth), this.secret),
                'Api-Nonce': nonce,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],82:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, OrderNotCached } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class poloniex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'poloniex',
            'name': 'Poloniex',
            'countries': 'US',
            'rateLimit': 1000, // up to 6 calls per second
            'hasCORS': true,
            // obsolete metainfo interface
            'hasFetchMyTrades': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasWithdraw': true,
            'hasFetchOHLCV': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchMyTrades': true,
                'fetchOrder': 'emulated',
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchTickers': true,
                'withdraw': true,
            },
            'timeframes': {
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '2h': 7200,
                '4h': 14400,
                '1d': 86400,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
                'api': {
                    'public': 'https://poloniex.com/public',
                    'private': 'https://poloniex.com/tradingApi',
                },
                'www': 'https://poloniex.com',
                'doc': [
                    'https://poloniex.com/support/api/',
                    'http://pastebin.com/dMX7mZE0',
                ],
                'fees': 'https://poloniex.com/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'return24hVolume',
                        'returnChartData',
                        'returnCurrencies',
                        'returnLoanOrders',
                        'returnOrderBook',
                        'returnTicker',
                        'returnTradeHistory',
                    ],
                },
                'private': {
                    'post': [
                        'buy',
                        'cancelLoanOffer',
                        'cancelOrder',
                        'closeMarginPosition',
                        'createLoanOffer',
                        'generateNewAddress',
                        'getMarginPosition',
                        'marginBuy',
                        'marginSell',
                        'moveOrder',
                        'returnActiveLoans',
                        'returnAvailableAccountBalances',
                        'returnBalances',
                        'returnCompleteBalances',
                        'returnDepositAddresses',
                        'returnDepositsWithdrawals',
                        'returnFeeInfo',
                        'returnLendingHistory',
                        'returnMarginAccountSummary',
                        'returnOpenLoanOffers',
                        'returnOpenOrders',
                        'returnOrderTrades',
                        'returnTradableBalances',
                        'returnTradeHistory',
                        'sell',
                        'toggleAutoRenew',
                        'transferBalance',
                        'withdraw',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0015,
                    'taker': 0.0025,
                },
                'funding': 0.0,
            },
            'limits': {
                'amount': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'price': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'cost': {
                    'min': 0.00000000,
                    'max': 1000000000,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
        });
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, cost)),
        };
    }

    commonCurrencyCode (currency) {
        if (currency == 'BTM')
            return 'Bitmark';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'Bitmark')
            return 'BTM';
        return currency;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '5m', since = undefined, limit = undefined) {
        return [
            ohlcv['date'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = 0;
        let request = {
            'currencyPair': market['id'],
            'period': this.timeframes[timeframe],
            'start': parseInt (since / 1000),
        };
        if (limit)
            request['end'] = this.sum (request['start'], limit * this.timeframes[timeframe]);
        let response = await this.publicGetReturnChartData (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchMarkets () {
        let markets = await this.publicGetReturnTicker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ quote, base ] = id.split ('_');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': true,
                'lot': this.limits['amount']['min'],
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostReturnCompleteBalances (this.extend ({
            'account': 'all',
        }, params));
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let id = currencies[c];
            let balance = balances[id];
            let currency = this.commonCurrencyCode (id);
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['onOrders']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchFees (params = {}) {
        await this.loadMarkets ();
        let fees = await this.privatePostReturnFeeInfo ();
        return {
            'info': fees,
            'maker': parseFloat (fees['makerFee']),
            'taker': parseFloat (fees['takerFee']),
            'withdraw': 0.0,
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetReturnOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['quoteVolume']),
            'quoteVolume': parseFloat (ticker['baseVolume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetReturnTicker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetReturnTicker (params);
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['date']);
        let symbol = undefined;
        if ((!market) && ('currencyPair' in trade))
            market = this.markets_by_id[trade['currencyPair']]['symbol'];
        if (market)
            symbol = market['symbol'];
        let side = trade['type'];
        let fee = undefined;
        let cost = this.safeFloat (trade, 'total');
        let amount = parseFloat (trade['amount']);
        if ('fee' in trade) {
            let rate = parseFloat (trade['fee']);
            let feeCost = undefined;
            let currency = undefined;
            if (side == 'buy') {
                currency = market['base'];
                feeCost = amount * rate;
            } else {
                currency = market['quote'];
                if (typeof cost != 'undefined')
                    feeCost = cost * rate;
            }
            fee = {
                'type': undefined,
                'rate': rate,
                'cost': feeCost,
                'currency': currency,
            };
        }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'id': this.safeString (trade, 'tradeID'),
            'order': this.safeString (trade, 'orderNumber'),
            'type': 'limit',
            'side': side,
            'price': parseFloat (trade['rate']),
            'amount': amount,
            'cost': cost,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'currencyPair': market['id'],
        };
        if (since) {
            request['start'] = parseInt (since / 1000);
            request['end'] = this.seconds (); // last 50000 trades by default
        }
        let trades = await this.publicGetReturnTradeHistory (this.extend (request, params));
        return this.parseTrades (trades, market);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = { 'currencyPair': pair };
        if (since) {
            request['start'] = parseInt (since / 1000);
            request['end'] = this.seconds ();
        }
        // limit is disabled (does not really work as expected)
        // if (limit)
        //     request['limit'] = parseInt (limit);
        let response = await this.privatePostReturnTradeHistory (this.extend (request, params));
        let result = [];
        if (market) {
            result = this.parseTrades (response, market);
        } else {
            if (response) {
                let ids = Object.keys (response);
                for (let i = 0; i < ids.length; i++) {
                    let id = ids[i];
                    let market = this.markets_by_id[id];
                    let symbol = market['symbol'];
                    let trades = this.parseTrades (response[id], market);
                    for (let j = 0; j < trades.length; j++) {
                        result.push (trades[j]);
                    }
                }
            }
        }
        return result;
    }

    parseOrder (order, market = undefined) {
        let timestamp = this.safeInteger (order, 'timestamp');
        if (!timestamp)
            timestamp = this.parse8601 (order['date']);
        let trades = undefined;
        if ('resultingTrades' in order)
            trades = this.parseTrades (order['resultingTrades'], market);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let price = parseFloat (order['price']);
        let cost = this.safeFloat (order, 'total', 0.0);
        let remaining = this.safeFloat (order, 'amount');
        let amount = this.safeFloat (order, 'startingAmount', remaining);
        let filled = amount - remaining;
        return {
            'info': order,
            'id': order['orderNumber'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': trades,
            'fee': undefined,
        };
    }

    parseOpenOrders (orders, market, result = []) {
        for (let i = 0; i < orders.length; i++) {
            let order = orders[i];
            let extended = this.extend (order, {
                'status': 'open',
                'type': 'limit',
                'side': order['type'],
                'price': order['rate'],
            });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let response = await this.privatePostReturnOpenOrders (this.extend ({
            'currencyPair': pair,
        }));
        let openOrders = [];
        if (market) {
            openOrders = this.parseOpenOrders (response, market, openOrders);
        } else {
            let marketIds = Object.keys (response);
            for (let i = 0; i < marketIds.length; i++) {
                let marketId = marketIds[i];
                let orders = response[marketId];
                let m = this.markets_by_id[marketId];
                openOrders = this.parseOpenOrders (orders, m, openOrders);
            }
        }
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (market) {
                if (order['symbol'] == symbol)
                    result.push (order);
            } else {
                result.push (order);
            }
        }
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['id'] == id)
                return orders[i];
        }
        throw OrderNotCached (this.id + ' order id ' + id.toString () + ' not found in cache');
    }

    filterOrdersByStatus (orders, status) {
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == status)
                result.push (orders[i]);
        }
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        return this.filterOrdersByStatus (orders, 'open');
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        return this.filterOrdersByStatus (orders, 'closed');
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let market = this.market (symbol);
        price = parseFloat (price);
        amount = parseFloat (amount);
        let response = await this[method] (this.extend ({
            'currencyPair': market['id'],
            'rate': this.priceToPrecision (symbol, price),
            'amount': this.amountToPrecision (symbol, amount),
        }, params));
        let timestamp = this.milliseconds ();
        let order = this.parseOrder (this.extend ({
            'timestamp': timestamp,
            'status': 'open',
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
        }, response), market);
        let id = order['id'];
        this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        price = parseFloat (price);
        amount = parseFloat (amount);
        let request = {
            'orderNumber': id,
            'rate': this.priceToPrecision (symbol, price),
            'amount': this.amountToPrecision (symbol, amount),
        };
        let response = await this.privatePostMoveOrder (this.extend (request, params));
        let result = undefined;
        if (id in this.orders) {
            this.orders[id] = this.extend (this.orders[id], {
                'price': price,
                'amount': amount,
            });
            result = this.extend (this.orders[id], { 'info': response });
        } else {
            result = {
                'info': response,
                'id': response['orderNumber'],
            };
        }
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelOrder (this.extend ({
                'orderNumber': id,
            }, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_http_response) {
                if (this.last_http_response.indexOf ('Invalid order') >= 0)
                    throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return response;
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let orders = await this.fetchOpenOrders (symbol);
        let indexed = this.indexBy (orders, 'id');
        return (id in indexed) ? 'open' : 'closed';
    }

    async fetchOrderTrades (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let trades = await this.privatePostReturnOrderTrades (this.extend ({
            'orderNumber': id,
        }, params));
        return this.parseTrades (trades);
    }

    async createDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostGenerateNewAddress ({
            'currency': currencyId
        });
        let address = undefined;
        if (response['success'] == 1)
            address = this.safeString (response, 'response');
        if (!address)
            throw new ExchangeError (this.id + ' createDepositAddress failed: ' + this.last_http_response);
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let response = await this.privatePostReturnDepositAddresses ();
        let currencyId = this.currencyId (currency);
        let address = this.safeString (response, currencyId);
        let status = address ? 'ok' : 'none';
        return {
            'currency': currency,
            'address': address,
            'status': status,
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let currencyId = this.currencyId (currency);
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currencyId,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': result['response'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.extend ({ 'command': path }, params);
        if (api == 'public') {
            url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            query['nonce'] = this.nonce ();
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            let error = this.id + ' ' + this.json (response);
            let failed = response['error'].indexOf ('Not enough') >= 0;
            if (failed)
                throw new InsufficientFunds (error);
            throw new ExchangeError (error);
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],83:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, OrderNotFound, InsufficientFunds } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class qryptos extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'qryptos',
            'name': 'QRYPTOS',
            'countries': [ 'CN', 'TW' ],
            'version': '2',
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'has': {
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30953915-b1611dc0-a436-11e7-8947-c95bd5a42086.jpg',
                'api': 'https://api.qryptos.com',
                'www': 'https://www.qryptos.com',
                'doc': 'https://developers.quoine.com',
            },
            'api': {
                'public': {
                    'get': [
                        'products',
                        'products/{id}',
                        'products/{id}/price_levels',
                        'executions',
                        'ir_ladders/{currency}',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/balance',
                        'crypto_accounts',
                        'executions/me',
                        'fiat_accounts',
                        'loan_bids',
                        'loans',
                        'orders',
                        'orders/{id}',
                        'orders/{id}/trades',
                        'trades',
                        'trades/{id}/loans',
                        'trading_accounts',
                        'trading_accounts/{id}',
                    ],
                    'post': [
                        'fiat_accounts',
                        'loan_bids',
                        'orders',
                    ],
                    'put': [
                        'loan_bids/{id}/close',
                        'loans/{id}',
                        'orders/{id}',
                        'orders/{id}/cancel',
                        'trades/{id}',
                        'trades/{id}/close',
                        'trades/close_all',
                        'trading_accounts/{id}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quoted_currency'];
            let symbol = base + '/' + quote;
            let maker = parseFloat (market['maker_fee']);
            let taker = parseFloat (market['taker_fee']);
            let active = !market['disabled'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'maker': maker,
                'taker': taker,
                'active': active,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = parseFloat (balance['balance']);
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdPriceLevels (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy_price_levels', 'sell_price_levels');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let last = undefined;
        if ('last_traded_price' in ticker) {
            if (ticker['last_traded_price']) {
                let length = ticker['last_traded_price'].length;
                if (length > 0)
                    last = parseFloat (ticker['last_traded_price']);
            }
        }
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high_market_ask']),
            'low': parseFloat (ticker['low_market_bid']),
            'bid': parseFloat (ticker['market_bid']),
            'ask': parseFloat (ticker['market_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetProducts (params);
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let base = ticker['base_currency'];
            let quote = ticker['quoted_currency'];
            let symbol = base + '/' + quote;
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetProductsId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['created_at'] * 1000;
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['taker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'product_id': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetExecutions (this.extend (request, params));
        return this.parseTrades (response['models'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'order_type': type,
            'product_id': this.marketId (symbol),
            'side': side,
            'quantity': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend ({
            'order': order,
        }, params));
        return this.parseOrder(response);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePutOrdersIdCancel (this.extend ({
            'id': id,
        }, params));
    }

    parseOrder (order) {
        let timestamp = order['created_at'] * 1000;
        let marketId = order['product_id'];
        let market = this.marketsById[marketId];
        let status = undefined;
        if ('status' in order) {
            if (order['status'] == 'live') {
                status = 'open';
            } else if (order['status'] == 'filled') {
                status = 'closed';
            } else if (order['status'] == 'cancelled') { // 'll' intended
                status = 'canceled';
            }
        }
        let amount = parseFloat (order['quantity']);
        let filled = parseFloat (order['filled_quantity']);
        return {
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'type': order['order_type'],
            'status': status,
            'symbol': market['symbol'],
            'side': order['side'],
            'price': order['price'],
            'amount': amount,
            'filled': filled,
            'remaining': amount - filled,
            'trades': undefined,
            'fee': {
                'currency': undefined,
                'cost': parseFloat (order['order_fee']),
            },
            'info': order,
        };
    }

    async fetchOrder (id) {
        await this.loadMarkets ();
        let order = await this.privateGetOrdersId ({ 'id': id });
        return this.parseOrder (order);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params={}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let status = params['status'];
        if (status == 'open') {
            request['status'] = 'live';
        } else if (status == 'closed') {
            request['status'] = 'filled';
        } else if (status == 'canceled') {
            request['status'] = 'cancelled';
        }
        let result = await this.privateGetOrders (request);
        let orders = result['models'];
        return this.parseOrders (orders, market);
    }

    fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        return this.fetchOrders (symbol, since, limit, this.extend ({ 'status': 'open' }, params));
    }

    fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        return this.fetchOrders (symbol, since, limit, this.extend ({ 'status': 'closed' }, params));
    }

    handleErrors (code, reason, url, method, headers, body) {
        let response = undefined;
        if (code == 200 || code == 404 || code == 422) {
            if ((body[0] == '{') || (body[0] == '[')) {
                response = JSON.parse (body);
            } else {
                // if not a JSON response
                throw new ExchangeError (this.id + ' returned a non-JSON reply: ' + body);
            }
        }
        if (code == 404) {
            if ('message' in response) {
                if (response['message'] == 'Order not found') {
                    throw new OrderNotFound (this.id + ' ' + body);
                }
            }
        } else if (code == 422) {
            if ('errors' in response) {
                let errors = response['errors'];
                if ('user' in errors) {
                    let messages = errors['user'];
                    if (messages.indexOf ('not_enough_free_balance') >= 0) {
                        throw new InsufficientFunds (this.id + ' ' + body);
                    }
                }
            }
        }
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        headers = {
            'X-Quoine-API-Version': this.version,
            'Content-Type': 'application/json',
        };
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            if (method == 'GET') {
                if (Object.keys (query).length)
                    url += '?' + this.urlencode (query);
            } else if (Object.keys (query).length) {
                body = this.json (query);
            }
            let nonce = this.nonce ();
            let request = {
                'path': url,
                'nonce': nonce,
                'token_id': this.apiKey,
                'iat': Math.floor (nonce / 1000), // issued at
            };
            headers['X-Quoine-Auth'] = this.jwt (request, this.secret);
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],84:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class quadrigacx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'quadrigacx',
            'name': 'QuadrigaCX',
            'countries': 'CA',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766825-98a6d0de-5ee7-11e7-9fa4-38e11a2c6f52.jpg',
                'api': 'https://api.quadrigacx.com',
                'www': 'https://www.quadrigacx.com',
                'doc': 'https://www.quadrigacx.com/api_info',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'order_book',
                        'ticker',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'bitcoin_deposit_address',
                        'bitcoin_withdrawal',
                        'buy',
                        'cancel_order',
                        'ether_deposit_address',
                        'ether_withdrawal',
                        'lookup_order',
                        'open_orders',
                        'sell',
                        'user_transactions',
                    ],
                },
            },
            'markets': {
                'BTC/CAD': { 'id': 'btc_cad', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.005, 'taker': 0.005 },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002, 'taker': 0.002 },
                'ETH/CAD': { 'id': 'eth_cad', 'symbol': 'ETH/CAD', 'base': 'ETH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'LTC/CAD': { 'id': 'ltc_cad', 'symbol': 'LTC/CAD', 'base': 'LTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'BCH/CAD': { 'id': 'btc_cad', 'symbol': 'BCH/CAD', 'base': 'BCH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = {
                'free': parseFloat (balances[lowercase + '_available']),
                'used': parseFloat (balances[lowercase + '_reserved']),
                'total': parseFloat (balances[lowercase + '_balance']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTicker (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'book': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'amount': amount,
            'book': this.marketId (symbol),
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = [ nonce.toString (), this.uid, this.apiKey ].join ('');
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],85:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const qryptos = require ('./qryptos.js')

// ---------------------------------------------------------------------------

module.exports = class quoine extends qryptos {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'quoine',
            'name': 'QUOINE',
            'countries': [ 'JP', 'SG', 'VN' ],
            'version': '2',
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766844-9615a4e8-5ee8-11e7-8814-fcd004db8cdd.jpg',
                'api': 'https://api.quoine.com',
                'www': 'https://www.quoine.com',
                'doc': 'https://developers.quoine.com',
            },
        });
    }
}

},{"./qryptos.js":83}],86:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class southxchange extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'southxchange',
            'name': 'SouthXchange',
            'countries': 'AR', // Argentina
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg',
                'api': 'https://www.southxchange.com/api',
                'www': 'https://www.southxchange.com',
                'doc': 'https://www.southxchange.com/Home/Api',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'price/{symbol}',
                        'prices',
                        'book/{symbol}',
                        'trades/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'cancelMarketOrders',
                        'cancelOrder',
                        'generatenewaddress',
                        'listOrders',
                        'listBalances',
                        'placeOrder',
                        'withdraw',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let base = market[0];
            let quote = market[1];
            let symbol = base + '/' + quote;
            let id = symbol;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostListBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.toUpperCase ();
            let free = parseFloat (balance['Available']);
            let used = parseFloat (balance['Unconfirmed']);
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'BuyOrders', 'SellOrders', 'Price', 'Amount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': this.safeFloat (ticker, 'Bid'),
            'ask': this.safeFloat (ticker, 'Ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'Last'),
            'change': this.safeFloat (ticker, 'Variation24Hr'),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'Volume24Hr'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetPrices (params);
        let tickers = this.indexBy (response, 'Market');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPriceSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['At'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['Type'],
            'price': trade['Price'],
            'amount': trade['Amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'listingCurrency': market['base'],
            'referenceCurrency': market['quote'],
            'type': side,
            'amount': amount,
        };
        if (type == 'limit')
            order['limitPrice'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response.toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder (this.extend ({
            'orderCode': id,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'address': address,
            'amount': amount,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, query);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
                'Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        return response;
    }
}

},{"./base/Exchange":8}],87:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class surbitcoin extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'surbitcoin',
            'name': 'SurBitcoin',
            'countries': 'VE',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991511-f0a50194-6481-11e7-99b5-8f02932424cc.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://surbitcoin.com',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],88:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class therock extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'therock',
            'name': 'TheRockTrading',
            'countries': 'MT',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg',
                'api': 'https://api.therocktrading.com',
                'www': 'https://therocktrading.com',
                'doc': [
                    'https://api.therocktrading.com/doc/v1/index.html',
                    'https://api.therocktrading.com/doc/',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'funds/{id}/orderbook',
                        'funds/{id}/ticker',
                        'funds/{id}/trades',
                        'funds/tickers',
                    ],
                },
                'private': {
                    'get': [
                        'balances',
                        'balances/{id}',
                        'discounts',
                        'discounts/{id}',
                        'funds',
                        'funds/{id}',
                        'funds/{id}/trades',
                        'funds/{fund_id}/orders',
                        'funds/{fund_id}/orders/{id}',
                        'funds/{fund_id}/position_balances',
                        'funds/{fund_id}/positions',
                        'funds/{fund_id}/positions/{id}',
                        'transactions',
                        'transactions/{id}',
                        'withdraw_limits/{id}',
                        'withdraw_limits',
                    ],
                    'post': [
                        'atms/withdraw',
                        'funds/{fund_id}/orders',
                    ],
                    'delete': [
                        'funds/{fund_id}/orders/{id}',
                        'funds/{fund_id}/orders/remove_all',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.02 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetFundsTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['fund_id'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let free = balance['trading_balance'];
            let total = balance['balance'];
            let used = total - free;
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetFundsIdOrderbook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = this.parse8601 (orderbook['date']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['date']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_traded']),
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetFundsTickers (params);
        let tickers = this.indexBy (response['tickers'], 'fund_id');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetFundsIdTicker (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['fund_id']];
        let timestamp = this.parse8601 (trade['date']);
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetFundsIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostFundsFundIdOrders (this.extend ({
            'fund_id': this.marketId (symbol),
            'side': side,
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteFundsFundIdOrdersId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + url;
            headers = {
                'X-TRT-KEY': this.apiKey,
                'X-TRT-NONCE': nonce,
                'X-TRT-SIGN': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512'),
            };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],89:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')

// ---------------------------------------------------------------------------

module.exports = class tidex extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'tidex',
            'name': 'Tidex',
            'countries': 'UK',
            'rateLimit': 2000,
            'version': '3',
            // 'hasCORS': false,
            // 'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg',
                'api': {
                    'public': 'https://api.tidex.com/api',
                    'private': 'https://api.tidex.com/tapi',
                },
                'www': 'https://tidex.com',
                'doc': 'https://tidex.com/public-api',
                'fees': 'https://tidex.com/pairs-spec'
            },
        });
    }
}

},{"./liqui.js":72}],90:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class urdubit extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'urdubit',
            'name': 'UrduBit',
            'countries': 'PK',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991453-156bf3ae-6480-11e7-82eb-7295fe1b5bb4.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://urdubit.com',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],91:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

// ---------------------------------------------------------------------------

module.exports = class vaultoro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'vaultoro',
            'name': 'Vaultoro',
            'countries': 'CH',
            'rateLimit': 1000,
            'version': '1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg',
                'api': 'https://api.vaultoro.com',
                'www': 'https://www.vaultoro.com',
                'doc': 'https://api.vaultoro.com',
            },
            'api': {
                'public': {
                    'get': [
                        'bidandask',
                        'buyorders',
                        'latest',
                        'latesttrades',
                        'markets',
                        'orderbook',
                        'sellorders',
                        'transactions/day',
                        'transactions/hour',
                        'transactions/month',
                    ],
                },
                'private': {
                    'get': [
                        'balance',
                        'mytrades',
                        'orders',
                    ],
                    'post': [
                        'buy/{symbol}/{type}',
                        'cancel/{id}',
                        'sell/{symbol}/{type}',
                        'withdraw',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let result = [];
        let markets = await this.publicGetMarkets ();
        let market = markets['data'];
        let base = market['BaseCurrency'];
        let quote = market['MarketCurrency'];
        let symbol = base + '/' + quote;
        let baseId = base;
        let quoteId = quote;
        let id = market['MarketName'];
        result.push ({
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'info': market,
        });
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['data'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency_code'];
            let uppercase = currency.toUpperCase ();
            let free = balance['cash'];
            let used = balance['reserved'];
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (params);
        let orderbook = {
            'bids': response['data'][0]['b'],
            'asks': response['data'][1]['s'],
        };
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'Gold_Price', 'Gold_Amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let quote = await this.publicGetBidandask (params);
        let bidsLength = quote['bids'].length;
        let bid = quote['bids'][bidsLength - 1];
        let ask = quote['asks'][0];
        let response = await this.publicGetMarkets (params);
        let ticker = response['data'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['24hHigh']),
            'low': parseFloat (ticker['24hLow']),
            'bid': bid[0],
            'ask': ask[0],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['24hVolume']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['Time']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['Gold_Price'],
            'amount': trade['Gold_Amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsDay (params);
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'SymbolType';
        let response = await this[method] (this.extend ({
            'symbol': market['quoteId'].toLowerCase (),
            'type': type,
            'gld': amount,
            'price': price || 1,
        }, params));
        return {
            'info': response,
            'id': response['data']['Order_ID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += path;
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += this.version + '/' + this.implodeParams (path, params);
            let query = this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, this.omit (params, this.extractParams (path)));
            url += '?' + this.urlencode (query);
            headers = {
                'Content-Type': 'application/json',
                'X-Signature': this.hmac (this.encode (url), this.encode (this.secret))
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],92:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class vbtc extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'vbtc',
            'name': 'VBTC',
            'countries': 'VN',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991481-1f53d1d8-6481-11e7-884e-21d17e7939db.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://vbtc.exchange',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],93:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class virwox extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'virwox',
            'name': 'VirWoX',
            'countries': [ 'AT', 'EU' ],
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg',
                'api': {
                    'public': 'http://api.virwox.com/api/json.php',
                    'private': 'https://www.virwox.com/api/trading.php',
                },
                'www': 'https://www.virwox.com',
                'doc': 'https://www.virwox.com/developers.php',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
                'login': true,
                'password': true
            },
            'api': {
                'public': {
                    'get': [
                        'getInstruments',
                        'getBestPrices',
                        'getMarketDepth',
                        'estimateMarketOrder',
                        'getTradedPriceVolume',
                        'getRawTradeData',
                        'getStatistics',
                        'getTerminalList',
                        'getGridList',
                        'getGridStatistics',
                    ],
                    'post': [
                        'getInstruments',
                        'getBestPrices',
                        'getMarketDepth',
                        'estimateMarketOrder',
                        'getTradedPriceVolume',
                        'getRawTradeData',
                        'getStatistics',
                        'getTerminalList',
                        'getGridList',
                        'getGridStatistics',
                    ],
                },
                'private': {
                    'get': [
                        'cancelOrder',
                        'getBalances',
                        'getCommissionDiscount',
                        'getOrders',
                        'getTransactions',
                        'placeOrder',
                    ],
                    'post': [
                        'cancelOrder',
                        'getBalances',
                        'getCommissionDiscount',
                        'getOrders',
                        'getTransactions',
                        'placeOrder',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetInstruments ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets['result'][keys[p]];
            let id = market['instrumentID'];
            let symbol = market['symbol'];
            let base = market['longCurrency'];
            let quote = market['shortCurrency'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalances ();
        let balances = response['result']['accountList'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = balance['balance'];
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchMarketPrice (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicPostGetBestPrices (this.extend ({
            'symbols': [ symbol ],
        }, params));
        let result = response['result'];
        return {
            'bid': this.safeFloat (result[0], 'bestBuyPrice'),
            'ask': this.safeFloat (result[0], 'bestSellPrice'),
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicPostGetMarketDepth (this.extend ({
            'symbols': [ symbol ],
            'buyDepth': 100,
            'sellDepth': 100,
        }, params));
        let orderbook = response['result'][0];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'price', 'volume');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let end = this.milliseconds ();
        let start = end - 86400000;
        let response = await this.publicGetTradedPriceVolume (this.extend ({
            'instrument': symbol,
            'endDate': this.YmdHMS (end),
            'startDate': this.YmdHMS (start),
            'HLOC': 1,
        }, params));
        let marketPrice = await this.fetchMarketPrice (symbol, params);
        let tickers = response['result']['priceVolumeList'];
        let keys = Object.keys (tickers);
        let length = keys.length;
        let lastKey = keys[length - 1];
        let ticker = tickers[lastKey];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': marketPrice['bid'],
            'ask': marketPrice['ask'],
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['longVolume']),
            'quoteVolume': parseFloat (ticker['shortVolume']),
            'info': ticker,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        return await this.publicGetRawTradeData (this.extend ({
            'instrument': market['id'],
            'timespan': 3600,
        }, params));
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'instrument': this.symbol (market),
            'orderType': side.toUpperCase (),
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'orderID': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let auth = {};
        if (api == 'private') {
            this.checkRequiredCredentials ();
            auth['key'] = this.apiKey;
            auth['user'] = this.login;
            auth['pass'] = this.password;
        }
        let nonce = this.nonce ();
        if (method == 'GET') {
            url += '?' + this.urlencode (this.extend ({
                'method': path,
                'id': nonce,
            }, auth, params));
        } else {
            headers = { 'Content-Type': 'application/json' };
            body = this.json ({
                'method': path,
                'params': this.extend (auth, params),
                'id': nonce,
            });
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],94:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')
const { ExchangeError, InsufficientFunds, OrderNotFound, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class wex extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'wex',
            'name': 'WEX',
            'countries': 'NZ', // New Zealand
            'version': '3',
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30652751-d74ec8f8-9e31-11e7-98c5-71469fcef03e.jpg',
                'api': {
                    'public': 'https://wex.nz/api',
                    'private': 'https://wex.nz/tapi',
                },
                'www': 'https://wex.nz',
                'doc': [
                    'https://wex.nz/api/3/docs',
                    'https://wex.nz/tapi/docs',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'info',
                        'ticker/{pair}',
                        'depth/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'Trade',
                        'ActiveOrders',
                        'OrderInfo',
                        'CancelOrder',
                        'TradeHistory',
                        'TransHistory',
                        'CoinDepositAddress',
                        'WithdrawCoin',
                        'CreateCoupon',
                        'RedeemCoupon',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'sell'),
            'ask': this.safeFloat (ticker, 'buy'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol_cur'),
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 200) {
            if (body[0] != '{') {
                // response is not JSON
                throw new ExchangeError (this.id + ' returned a non-JSON reply: ' + body);
            }
            let response = JSON.parse (body);
            if ('success' in response) {
                if (!response['success']) {
                    let error = this.safeValue (response, 'error');
                    if (!error) {
                        throw new ExchangeError (this.id + ' returned a malformed error: ' + body);
                    } else if (error == 'bad status') {
                        throw new OrderNotFound (this.id + ' ' + error);
                    } else if (error.indexOf ('It is not enough') >= 0) {
                        throw new InsufficientFunds (this.id + ' ' + error);
                    } else if (error == 'Requests too often') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    } else if (error == 'not available') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    } else if (error == 'external service unavailable') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    // that's what fetchOpenOrders return if no open orders (fix for #489)
                    } else if (error != 'no orders') {
                        throw new ExchangeError (this.id + ' ' + error);
                    }
                }
            }
        }
    }

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        return this.fetch2 (path, api, method, params, headers, body);
    }
}

},{"./base/errors":10,"./liqui.js":72}],95:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported, AuthenticationError } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class xbtce extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'xbtce',
            'name': 'xBTCe',
            'countries': 'RU',
            'rateLimit': 2000, // responses are cached every 2 seconds
            'version': 'v1',
            'hasPublicAPI': false,
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg',
                'api': 'https://cryptottlivewebapi.xbtce.net:8443/api',
                'www': 'https://www.xbtce.com',
                'doc': [
                    'https://www.xbtce.com/tradeapi',
                    'https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currency',
                        'currency/{filter}',
                        'level2',
                        'level2/{filter}',
                        'quotehistory/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/{symbol}/level2',
                        'quotehistory/{symbol}/ticks',
                        'symbol',
                        'symbol/{filter}',
                        'tick',
                        'tick/{filter}',
                        'ticker',
                        'ticker/{filter}',
                        'tradesession',
                    ],
                },
                'private': {
                    'get': [
                        'tradeserverinfo',
                        'tradesession',
                        'currency',
                        'currency/{filter}',
                        'level2',
                        'level2/{filter}',
                        'symbol',
                        'symbol/{filter}',
                        'tick',
                        'tick/{filter}',
                        'account',
                        'asset',
                        'asset/{id}',
                        'position',
                        'position/{id}',
                        'trade',
                        'trade/{id}',
                        'quotehistory/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/{symbol}/{periodicity}/bars/ask/info',
                        'quotehistory/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/{symbol}/{periodicity}/bars/bid/info',
                        'quotehistory/{symbol}/level2',
                        'quotehistory/{symbol}/level2/info',
                        'quotehistory/{symbol}/periodicities',
                        'quotehistory/{symbol}/ticks',
                        'quotehistory/{symbol}/ticks/info',
                        'quotehistory/cache/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/cache/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/cache/{symbol}/level2',
                        'quotehistory/cache/{symbol}/ticks',
                        'quotehistory/symbols',
                        'quotehistory/version',
                    ],
                    'post': [
                        'trade',
                        'tradehistory',
                    ],
                    'put': [
                        'trade',
                    ],
                    'delete': [
                        'trade',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.privateGetSymbol ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['Symbol'];
            let base = market['MarginCurrency'];
            let quote = market['ProfitCurrency'];
            if (base == 'DSH')
                base = 'DASH';
            let symbol = base + '/' + quote;
            symbol = market['IsTradeAllowed'] ? symbol : id;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAsset ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.toUpperCase ();
            // xbtce names DASH incorrectly as DSH
            if (uppercase == 'DSH')
                uppercase = 'DASH';
            let account = {
                'free': balance['FreeAmount'],
                'used': balance['LockedAmount'],
                'total': balance['Amount'],
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.privateGetLevel2Filter (this.extend ({
            'filter': market['id'],
        }, params));
        orderbook = orderbook[0];
        let timestamp = orderbook['Timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'Bids', 'Asks', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = 0;
        let last = undefined;
        if ('LastBuyTimestamp' in ticker)
            if (timestamp < ticker['LastBuyTimestamp']) {
                timestamp = ticker['LastBuyTimestamp'];
                last = ticker['LastBuyPrice'];
            }
        if ('LastSellTimestamp' in ticker)
            if (timestamp < ticker['LastSellTimestamp']) {
                timestamp = ticker['LastSellTimestamp'];
                last = ticker['LastSellPrice'];
            }
        if (!timestamp)
            timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DailyBestBuyPrice'],
            'low': ticker['DailyBestSellPrice'],
            'bid': ticker['BestBid'],
            'ask': ticker['BestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': ticker['DailyTradedTotalVolume'],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        tickers = this.indexBy (tickers, 'Symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                if (base == 'DSH')
                    base = 'DASH';
                if (quote == 'DSH')
                    quote = 'DASH';
                symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickerFilter (this.extend ({
            'filter': market['id'],
        }, params));
        let length = tickers.length;
        if (length < 1)
            throw new ExchangeError (this.id + ' fetchTicker returned empty response, xBTCe public API error');
        tickers = this.indexBy (tickers, 'Symbol');
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // no method for trades?
        return await this.privateGetTrade (params);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['Timestamp'],
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOHLCV is disabled by the exchange');
        let minutes = parseInt (timeframe / 60); // 1 minute by default
        let periodicity = minutes.toString ();
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = this.seconds () - 86400 * 7; // last day by defulat
        if (!limit)
            limit = 1000; // default
        let response = await this.privateGetQuotehistorySymbolPeriodicityBarsBid (this.extend ({
            'symbol': market['id'],
            'periodicity': periodicity,
            'timestamp': since,
            'count': limit,
        }, params));
        return this.parseOHLCVs (response['Bars'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.tapiPostTrade (this.extend ({
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['Id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privateDeleteTrade (this.extend ({
            'Type': 'Cancel',
            'Id': id,
        }, params));
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests, their public API is always busy');
        if (!this.uid)
            throw new AuthenticationError (this.id + ' requires uid property for authentication and trading, their public API is always busy');
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public')
            url += '/' + api;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            headers = { 'Accept-Encoding': 'gzip, deflate' };
            let nonce = this.nonce ().toString ();
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                } else {
                    url += '?' + this.urlencode (query);
                }
            }
            let auth = nonce + this.uid + this.apiKey + method + url;
            if (body)
                auth += body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            let credentials = this.uid + ':' + this.apiKey + ':' + nonce + ':' + this.binaryToString (signature);
            headers['Authorization'] = 'HMAC ' + credentials;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],96:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')
const { ExchangeError, InsufficientFunds, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class yobit extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'yobit',
            'name': 'YoBit',
            'countries': 'RU',
            'rateLimit': 3000, // responses are cached every 2 seconds
            'version': '3',
            'hasCORS': false,
            'hasWithdraw': true,
            'hasFetchTickers': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg',
                'api': {
                    'public': 'https://yobit.net/api',
                    'private': 'https://yobit.net/tapi',
                },
                'www': 'https://www.yobit.net',
                'doc': 'https://www.yobit.net/en/api/',
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{pair}',
                        'info',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'ActiveOrders',
                        'CancelOrder',
                        'GetDepositAddress',
                        'getInfo',
                        'OrderInfo',
                        'Trade',
                        'TradeHistory',
                        'WithdrawCoinsToAddress',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.002,
                    'taker': 0.002,
                },
                'funding': 0.0,
            },
        });
    }

    commonCurrencyCode (currency) {
        let substitutions = {
            'AIR': 'AirCoin',
            'ANI': 'ANICoin',
            'ANT': 'AntsCoin',
            'ATM': 'Autumncoin',
            'BCC': 'BCH',
            'BTS': 'Bitshares2',
            'DCT': 'Discount',
            'DGD': 'DarkGoldCoin',
            'ICN': 'iCoin',
            'LIZI': 'LiZi',
            'LUN': 'LunarCoin',
            'NAV': 'NavajoCoin',
            'OMG': 'OMGame',
            'PAY': 'EPAY',
            'REP': 'Republicoin',
        };
        if (currency in substitutions)
            return substitutions[currency];
        return currency;
    }

    currencyId (commonCode) {
        let substitutions = {
            'AirCoin': 'AIR',
            'ANICoin': 'ANI',
            'AntsCoin': 'ANT',
            'Autumncoin': 'ATM',
            'BCH': 'BCC',
            'Bitshares2': 'BTS',
            'Discount': 'DCT',
            'DarkGoldCoin': 'DGD',
            'iCoin': 'ICN',
            'LiZi': 'LIZI',
            'LunarCoin': 'LUN',
            'NavajoCoin': 'NAV',
            'OMGame': 'OMG',
            'EPAY': 'PAY',
            'Republicoin': 'REP',
        };
        if (commonCode in substitutions)
            return substitutions[commonCode];
        return commonCode;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let sides = { 'free': 'funds', 'total': 'funds_incl_orders' };
        let keys = Object.keys (sides);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let side = sides[key];
            if (side in balances) {
                let currencies = Object.keys (balances[side]);
                for (let j = 0; j < currencies.length; j++) {
                    let lowercase = currencies[j];
                    let uppercase = lowercase.toUpperCase ();
                    let currency = this.commonCurrencyCode (uppercase);
                    let account = undefined;
                    if (currency in result) {
                        account = result[currency];
                    } else {
                        account = this.account ();
                    }
                    account[key] = balances[side][lowercase];
                    if (account['total'] && account['free'])
                        account['used'] = account['total'] - account['free'];
                    result[currency] = account;
                }
            }
        }
        return this.parseBalance (result);
    }

    async createDepositAddress (currency, params = {}) {
        let response = await this.fetchDepositAddress (currency, this.extend ({
            'need_new': 1,
        }, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response['info'],
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let request = {
            'coinName': currencyId,
            'need_new': 0,
        };
        let response = await this.privatePostGetDepositAddress (this.extend (request, params));
        let address = this.safeString (response['return'], 'address');
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawCoinsToAddress (this.extend ({
            'coinName': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (!response['success']) {
                if (response['error'].indexOf ('Insufficient funds') >= 0) { // not enougTh is a typo inside Liqui's own API...
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                } else if (response['error'] == 'Requests too often') {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else if ((response['error'] == 'not available') || (response['error'] == 'external service unavailable')) {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
        }
        return response;
    }

}

},{"./base/errors":10,"./liqui.js":72}],97:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const acx = require ('./acx.js')

// ---------------------------------------------------------------------------

module.exports = class yunbi extends acx {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'yunbi',
            'name': 'YUNBI',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28570548-4d646c40-7147-11e7-9cf6-839b93e6d622.jpg',
                'extension': '.json', // default extension appended to endpoint URLs
                'api': 'https://yunbi.com',
                'www': 'https://yunbi.com',
                'doc': [
                    'https://yunbi.com/documents/api/guide',
                    'https://yunbi.com/swagger/',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'tickers',
                        'tickers/{market}',
                        'markets',
                        'order_book',
                        'k',
                        'depth',
                        'trades',
                        'k_with_pending_trades',
                        'timestamp',
                        'addresses/{address}',
                        'partners/orders/{id}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'deposits',
                        'members/me',
                        'deposit',
                        'deposit_address',
                        'order',
                        'orders',
                        'trades/my',
                    ],
                    'post': [
                        'order/delete',
                        'orders',
                        'orders/multi',
                        'orders/clear',
                    ],
                },
            },
        });
    }
}

},{"./acx.js":5}],98:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class zaif extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'zaif',
            'name': 'Zaif',
            'countries': 'JP',
            'rateLimit': 2000,
            'version': '1',
            'hasCORS': false,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg',
                'api': 'https://api.zaif.jp',
                'www': 'https://zaif.jp',
                'doc': [
                    'http://techbureau-api-document.readthedocs.io/ja/latest/index.html',
                    'https://corp.zaif.jp/api-docs',
                    'https://corp.zaif.jp/api-docs/api_links',
                    'https://www.npmjs.com/package/zaif.jp',
                    'https://github.com/you21979/node-zaif',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{pair}',
                        'currencies/{pair}',
                        'currencies/all',
                        'currency_pairs/{pair}',
                        'currency_pairs/all',
                        'last_price/{pair}',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'active_orders',
                        'cancel_order',
                        'deposit_history',
                        'get_id_info',
                        'get_info',
                        'get_info2',
                        'get_personal_info',
                        'trade',
                        'trade_history',
                        'withdraw',
                        'withdraw_history',
                    ],
                },
                'ecapi': {
                    'post': [
                        'createInvoice',
                        'getInvoice',
                        'getInvoiceIdsByOrderNumber',
                        'cancelInvoice',
                    ],
                },
                'tlapi': {
                    'post': [
                        'get_positions',
                        'position_history',
                        'active_positions',
                        'create_position',
                        'change_position',
                        'cancel_position',
                    ],
                },
                'fapi': {
                    'get': [
                        'groups/{group_id}',
                        'last_price/{group_id}/{pair}',
                        'ticker/{group_id}/{pair}',
                        'trades/{group_id}/{pair}',
                        'depth/{group_id}/{pair}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyPairsAll ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currency_pair'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances['funds']);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = balances['funds'][currency];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            if ('deposit' in balances) {
                if (currency in balances['deposit']) {
                    account['total'] = balances['deposit'][currency];
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetDepthPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let vwap = ticker['vwap'];
        let baseVolume = ticker['volume'];
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['last'],
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        let id = this.safeString (trade, 'id');
        id = this.safeString (trade, 'tid', id);
        if (!market)
            market = this.markets_by_id[trade['currency_pair']];
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostTrade (this.extend ({
            'currency_pair': this.marketId (symbol),
            'action': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['return']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    }

    parseOrder (order, market = undefined) {
        let side = (order['action'] == 'bid') ? 'buy' : 'sell';
        let timestamp = parseInt (order['timestamp']) * 1000;
        if (!market)
            market = this.markets_by_id[order['currency_pair']];
        let price = order['price'];
        let amount = order['amount'];
        return {
            'id': order['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'filled': undefined,
            'remaining': undefined,
            'trades': undefined,
            'fee': undefined,
        };
    }

    parseOrders (orders, market = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'is_token': false,
            // 'is_token_both': false,
        };
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        return this.parseOrders (response['return'], market);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'from': 0,
            // 'count': 1000,
            // 'from_id': 0,
            // 'end_id': 1000,
            // 'order': 'DESC',
            // 'since': 1503821051,
            // 'end': 1503821051,
            // 'is_token': false,
        };
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostTradeHistory (this.extend (request, params));
        return this.parseOrders (response['return'], market);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency == 'JPY')
            throw new ExchangeError (this.id + ' does not allow ' + currency + ' withdrawals');
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'amount': amount,
            'address': address,
            // 'message': 'Hi!', // XEM only
            // 'opt_fee': 0.003, // BTC and MONA only
        }, params));
        return {
            'info': result,
            'id': result['return']['txid'],
            'fee': result['return']['fee'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += 'api/' + this.version + '/' + this.implodeParams (path, params);
        } else if (api == 'fapi') {
            url += 'fapi/' + this.version + '/' + this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            if (api == 'ecapi') {
                url += 'ecapi';
            } else if (api == 'tlapi') {
                url += 'tlapi';
            } else {
                url += 'tapi';
            }
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'api', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],99:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class zb extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'zb',
            'name': 'ZB',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                'api': {
                    'public': 'http://api.zb.com/data', // no https for public API
                    'private': 'https://trade.zb.com/api',
                },
                'www': 'https://trade.zb.com/api',
                'doc': 'https://www.zb.com/i/developer',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'ticker',
                        'depth',
                        'trades',
                        'kline',
                    ],
                },
                'private': {
                    'post': [
                        'order',
                        'cancelOrder',
                        'getOrder',
                        'getOrders',
                        'getOrdersNew',
                        'getOrdersIgnoreTradeType',
                        'getUnfinishedOrdersIgnoreTradeType',
                        'getAccountInfo',
                        'getUserAddress',
                        'getWithdrawAddress',
                        'getWithdrawRecord',
                        'getChargeRecord',
                        'getCnyWithdrawRecord',
                        'getCnyChargeRecord',
                        'withdraw',
                    ],
                },
            },
        });
    }

    getTradingFeeFromBaseQuote (base, quote) {
        // base: quote
        let fees = {
            'BTC': { 'USDT': 0.0 },
            'BCH': { 'BTC': 0.001, 'USDT': 0.001 },
            'LTC': { 'BTC': 0.001, 'USDT': 0.0 },
            'ETH': { 'BTC': 0.001, 'USDT': 0.0 },
            'ETC': { 'BTC': 0.001, 'USDT': 0.0 },
            'BTS': { 'BTC': 0.001, 'USDT': 0.001 },
            'EOS': { 'BTC': 0.001, 'USDT': 0.001 },
            'HSR': { 'BTC': 0.001, 'USDT': 0.001 },
            'QTUM': { 'BTC': 0.001, 'USDT': 0.001 },
            'USDT': { 'BTC': 0.0 },
        };
        if (base in fees) {
            let quoteFees = fees[base];
            if (quote in quoteFees)
                return quoteFees[quote];
        }
        return undefined;
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let keys = Object.keys (markets);
        let result = [];
        for (let i = 0; i < keys.length; i++) {
            let id = keys[i];
            let market = markets[id];
            let [ baseId, quoteId ] = id.split ('_');
            let base = this.commonCurrencyCode (baseId.toUpperCase ());
            let quote = this.commonCurrencyCode (quoteId.toUpperCase ());
            let symbol = base + '/' + quote;
            let fee = this.getTradingFeeFromBaseQuote (base, quote);
            let precision = {
                'amount': market['amountScale'],
                'price': market['priceScale'],
            };
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'baseId': baseId,
                'quoteId': quoteId,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': fee,
                'taker': fee,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances['balance'])
                account['free'] = parseFloat (balances['balance'][currency]['amount']);
            if (currency in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][currency]['amount']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    getMarketFieldName () {
        return 'market';
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let orderbook = await this.publicGetDepth (this.extend (request, params));
        let timestamp = this.milliseconds ();
        let bids = undefined;
        let asks = undefined;
        if ('bids' in orderbook)
            bids = orderbook['bids'];
        if ('asks' in orderbook)
            asks = orderbook['asks'];
        let result = {
            'bids': bids,
            'asks': asks,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        if (result['bids'])
            result['bids'] = this.sortBy (result['bids'], 0, true);
        if (result['asks'])
            result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let response = await this.publicGetTicker (this.extend (request, params));
        let ticker = response['ticker'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['date'] * 1000;
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let response = await this.publicGetTrades (this.extend (request, params));
        return this.parseTrades (response, market);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&price=' + price.toString ();
        paramString += '&amount=' + amount.toString ();
        let tradeType = (side == 'buy') ? '1' : '0';
        paramString += '&tradeType=' + tradeType;
        paramString += '&currency=' + this.marketId (symbol);
        let response = await this.privatePostOrder (paramString);
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return await this.privatePostCancelOrder (paramString);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return await this.privatePostGetOrder (paramString);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.version + '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let paramsLength = params.length; // params should be a string here
            let nonce = this.nonce ();
            let auth = 'method=' + path;
            auth += '&accesskey=' + this.apiKey;
            auth += paramsLength ? params : '';
            let secret = this.hash (this.encode (this.secret), 'sha1');
            let signature = this.hmac (this.encode (auth), this.encode (secret), 'md5');
            let suffix = 'sign=' + signature + '&reqTime=' + nonce.toString ();
            url += '/' + path + '?' + auth + '&' + suffix;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private')
            if ('code' in response)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],100:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
},{"./cipher-core":101,"./core":102,"./enc-base64":103,"./evpkdf":105,"./md5":110}],101:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./evpkdf"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
},{"./core":102,"./evpkdf":105}],102:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
},{}],103:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":102}],104:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));
},{"./core":102}],105:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
},{"./core":102,"./hmac":107,"./sha1":126}],106:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));
},{"./cipher-core":101,"./core":102}],107:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":102}],108:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));
},{"./aes":100,"./cipher-core":101,"./core":102,"./enc-base64":103,"./enc-utf16":104,"./evpkdf":105,"./format-hex":106,"./hmac":107,"./lib-typedarrays":109,"./md5":110,"./mode-cfb":111,"./mode-ctr":113,"./mode-ctr-gladman":112,"./mode-ecb":114,"./mode-ofb":115,"./pad-ansix923":116,"./pad-iso10126":117,"./pad-iso97971":118,"./pad-nopadding":119,"./pad-zeropadding":120,"./pbkdf2":121,"./rabbit":123,"./rabbit-legacy":122,"./rc4":124,"./ripemd160":125,"./sha1":126,"./sha224":127,"./sha256":128,"./sha3":129,"./sha384":130,"./sha512":131,"./tripledes":132,"./x64-core":133}],109:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));
},{"./core":102}],110:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":102}],111:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));
},{"./cipher-core":101,"./core":102}],112:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));
},{"./cipher-core":101,"./core":102}],113:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));
},{"./cipher-core":101,"./core":102}],114:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));
},{"./cipher-core":101,"./core":102}],115:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));
},{"./cipher-core":101,"./core":102}],116:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));
},{"./cipher-core":101,"./core":102}],117:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));
},{"./cipher-core":101,"./core":102}],118:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));
},{"./cipher-core":101,"./core":102}],119:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));
},{"./cipher-core":101,"./core":102}],120:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));
},{"./cipher-core":101,"./core":102}],121:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));
},{"./core":102,"./hmac":107,"./sha1":126}],122:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));
},{"./cipher-core":101,"./core":102,"./enc-base64":103,"./evpkdf":105,"./md5":110}],123:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));
},{"./cipher-core":101,"./core":102,"./enc-base64":103,"./evpkdf":105,"./md5":110}],124:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));
},{"./cipher-core":101,"./core":102,"./enc-base64":103,"./evpkdf":105,"./md5":110}],125:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));
},{"./core":102}],126:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
},{"./core":102}],127:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));
},{"./core":102,"./sha256":128}],128:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
},{"./core":102}],129:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));
},{"./core":102,"./x64-core":133}],130:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));
},{"./core":102,"./sha512":131,"./x64-core":133}],131:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));
},{"./core":102,"./x64-core":133}],132:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));
},{"./cipher-core":101,"./core":102,"./enc-base64":103,"./evpkdf":105,"./md5":110}],133:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));
},{"./core":102}],134:[function(require,module,exports){
(function (self) {
  'use strict';

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {
        'use strict';

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob()
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        }

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ]

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          }

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          }
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name)
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value)
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift()
              return {done: value === undefined, value: value}
            }
          }

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            }
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {}

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value)
            }, this)
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1])
            }, this)
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name])
            }, this)
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name)
          value = normalizeValue(value)
          var oldValue = this.map[name]
          this.map[name] = oldValue ? oldValue+','+value : value
        }

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)]
        }

        Headers.prototype.get = function(name) {
          name = normalizeName(name)
          return this.has(name) ? this.map[name] : null
        }

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this)
            }
          }
        }

        Headers.prototype.keys = function() {
          var items = []
          this.forEach(function(value, name) { items.push(name) })
          return iteratorFor(items)
        }

        Headers.prototype.values = function() {
          var items = []
          this.forEach(function(value) { items.push(value) })
          return iteratorFor(items)
        }

        Headers.prototype.entries = function() {
          var items = []
          this.forEach(function(value, name) { items.push([name, value]) })
          return iteratorFor(items)
        }

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result)
            }
            reader.onerror = function() {
              reject(reader.error)
            }
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsArrayBuffer(blob)
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsText(blob)
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf)
          var chars = new Array(view.length)

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i])
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength)
            view.set(new Uint8Array(buf))
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false

          this._initBody = function(body) {
            this._bodyInit = body
            if (!body) {
              this._bodyText = ''
            } else if (typeof body === 'string') {
              this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString()
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer)
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer])
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body)
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8')
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type)
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
              }
            }
          }

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this)
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            }

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            }
          }

          this.text = function() {
            var rejected = consumed(this)
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          }

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            }
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          }

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

        function normalizeMethod(method) {
          var upcased = method.toUpperCase()
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {}
          var body = options.body

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url
            this.credentials = input.credentials
            if (!options.headers) {
              this.headers = new Headers(input.headers)
            }
            this.method = input.method
            this.mode = input.mode
            if (!body && input._bodyInit != null) {
              body = input._bodyInit
              input.bodyUsed = true
            }
          } else {
            this.url = String(input)
          }

          this.credentials = options.credentials || this.credentials || 'omit'
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers)
          }
          this.method = normalizeMethod(options.method || this.method || 'GET')
          this.mode = options.mode || this.mode || null
          this.referrer = null

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body)
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        }

        function decode(body) {
          var form = new FormData()
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=')
              var name = split.shift().replace(/\+/g, ' ')
              var value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          })
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers()
          rawHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':')
            var key = parts.shift().trim()
            if (key) {
              var value = parts.join(':').trim()
              headers.append(key, value)
            }
          })
          return headers
        }

        Body.call(Request.prototype)

        function Response(bodyInit, options) {
          if (!options) {
            options = {}
          }

          this.type = 'default'
          this.status = 'status' in options ? options.status : 200
          this.ok = this.status >= 200 && this.status < 300
          this.statusText = 'statusText' in options ? options.statusText : 'OK'
          this.headers = new Headers(options.headers)
          this.url = options.url || ''
          this._initBody(bodyInit)
        }

        Body.call(Response.prototype)

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''})
          response.type = 'error'
          return response
        }

        var redirectStatuses = [301, 302, 303, 307, 308]

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        }

        self.Headers = Headers
        self.Request = Request
        self.Response = Response

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init)
            var xhr = new XMLHttpRequest()

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
              xhr.withCredentials = true
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob'
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
          })
        }
        self.fetch.polyfill = true
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return fetchPonyfill;
    });
  } else if (typeof exports === 'object') {
    module.exports = fetchPonyfill;
  } else {
    self.fetchPonyfill = fetchPonyfill;
  }
}(typeof self === 'undefined' ? this : self));


},{}],135:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],136:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],137:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":136,"./parse":138,"./stringify":139}],138:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":140}],139:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":136,"./utils":140}],140:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

exports.arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

exports.isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjY3h0LmJyb3dzZXIuanMiLCJjY3h0LmpzIiwianMvXzFicm9rZXIuanMiLCJqcy9fMWJ0Y3hlLmpzIiwianMvYWN4LmpzIiwianMvYWxsY29pbi5qcyIsImpzL2FueHByby5qcyIsImpzL2Jhc2UvRXhjaGFuZ2UuanMiLCJqcy9iYXNlL01hcmtldC5qcyIsImpzL2Jhc2UvZXJyb3JzLmpzIiwianMvYmFzZS9mdW5jdGlvbnMuanMiLCJqcy9iYXNlL3Rocm90dGxlLmpzIiwianMvYmluYW5jZS5qcyIsImpzL2JpdDJjLmpzIiwianMvYml0YmF5LmpzIiwianMvYml0Y29pbmNvaWQuanMiLCJqcy9iaXRmaW5leC5qcyIsImpzL2JpdGZpbmV4Mi5qcyIsImpzL2JpdGZseWVyLmpzIiwianMvYml0aHVtYi5qcyIsImpzL2JpdGxpc2guanMiLCJqcy9iaXRtYXJrZXQuanMiLCJqcy9iaXRtZXguanMiLCJqcy9iaXRzby5qcyIsImpzL2JpdHN0YW1wLmpzIiwianMvYml0c3RhbXAxLmpzIiwianMvYml0dHJleC5qcyIsImpzL2JsM3AuanMiLCJqcy9ibGV1dHJhZGUuanMiLCJqcy9idGNib3guanMiLCJqcy9idGNjaGluYS5qcyIsImpzL2J0Y2V4Y2hhbmdlLmpzIiwianMvYnRjbWFya2V0cy5qcyIsImpzL2J0Y3RyYWRldWEuanMiLCJqcy9idGN0dXJrLmpzIiwianMvYnRjeC5qcyIsImpzL2J0ZXIuanMiLCJqcy9ieGludGguanMiLCJqcy9jY2V4LmpzIiwianMvY2V4LmpzIiwianMvY2hidGMuanMiLCJqcy9jaGlsZWJpdC5qcyIsImpzL2NvaW5jaGVjay5qcyIsImpzL2NvaW5mbG9vci5qcyIsImpzL2NvaW5naS5qcyIsImpzL2NvaW5tYXJrZXRjYXAuanMiLCJqcy9jb2lubWF0ZS5qcyIsImpzL2NvaW5zZWN1cmUuanMiLCJqcy9jb2luc3BvdC5qcyIsImpzL2NyeXB0b3BpYS5qcyIsImpzL2RzeC5qcyIsImpzL2V4bW8uanMiLCJqcy9mbG93YnRjLmpzIiwianMvZm94Yml0LmpzIiwianMvZnlic2UuanMiLCJqcy9meWJzZy5qcyIsImpzL2dhdGVjb2luLmpzIiwianMvZ2F0ZWlvLmpzIiwianMvZ2RheC5qcyIsImpzL2dlbWluaS5qcyIsImpzL2hpdGJ0Yy5qcyIsImpzL2hpdGJ0YzIuanMiLCJqcy9odW9iaS5qcyIsImpzL2h1b2JpY255LmpzIiwianMvaHVvYmlwcm8uanMiLCJqcy9pbmRlcGVuZGVudHJlc2VydmUuanMiLCJqcy9pdGJpdC5qcyIsImpzL2p1YmkuanMiLCJqcy9rcmFrZW4uanMiLCJqcy9rdW5hLmpzIiwianMvbGFrZWJ0Yy5qcyIsImpzL2xpcXVpLmpzIiwianMvbGl2ZWNvaW4uanMiLCJqcy9sdW5vLmpzIiwianMvbWVyY2Fkby5qcyIsImpzL21peGNvaW5zLmpzIiwianMvbm92YS5qcyIsImpzL29rY29pbmNueS5qcyIsImpzL29rY29pbnVzZC5qcyIsImpzL29rZXguanMiLCJqcy9wYXltaXVtLmpzIiwianMvcG9sb25pZXguanMiLCJqcy9xcnlwdG9zLmpzIiwianMvcXVhZHJpZ2FjeC5qcyIsImpzL3F1b2luZS5qcyIsImpzL3NvdXRoeGNoYW5nZS5qcyIsImpzL3N1cmJpdGNvaW4uanMiLCJqcy90aGVyb2NrLmpzIiwianMvdGlkZXguanMiLCJqcy91cmR1Yml0LmpzIiwianMvdmF1bHRvcm8uanMiLCJqcy92YnRjLmpzIiwianMvdmlyd294LmpzIiwianMvd2V4LmpzIiwianMveGJ0Y2UuanMiLCJqcy95b2JpdC5qcyIsImpzL3l1bmJpLmpzIiwianMvemFpZi5qcyIsImpzL3piLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yaXBlbWQxNjAuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9mZXRjaC1wb255ZmlsbC9idWlsZC9mZXRjaC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNobkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9tQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDandCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogIEEgZW50cnkgcG9pbnQgZm9yIHRoZSBicm93c2VyIGJ1bmRsZSB2ZXJzaW9uLiBUaGlzIGdldHMgY29tcGlsZWQgYnk6XG4gICAgICAgIFxuICAgICAgICBicm93c2VyaWZ5IC0tZGVidWcgLi9jY3h0LmJyb3dzZXIuanMgPiAuL2J1aWxkL2NjeHQuYnJvd3Nlci5qc1xuICovXG5cbndpbmRvdy5jY3h0ID0gcmVxdWlyZSAoJy4vY2N4dCcpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNyBJZ29yIEtyb2l0b3JcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuXG4qL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSAgPSByZXF1aXJlICgnLi9qcy9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IGZ1bmN0aW9ucyA9IHJlcXVpcmUgKCcuL2pzL2Jhc2UvZnVuY3Rpb25zJylcbmNvbnN0IGVycm9ycyAgICA9IHJlcXVpcmUgKCcuL2pzL2Jhc2UvZXJyb3JzJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdGhpcyBpcyB1cGRhdGVkIGJ5IHZzcy5qcyB3aGVuIGJ1aWxkaW5nXG5cbmNvbnN0IHZlcnNpb24gPSAnMS4xMC4yODAnXG5cbkV4Y2hhbmdlLmNjeHRWZXJzaW9uID0gdmVyc2lvblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4Y2hhbmdlcyA9IHtcbiAgICAnXzFicm9rZXInOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9fMWJyb2tlci5qcycpLFxuICAgICdfMWJ0Y3hlJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL18xYnRjeGUuanMnKSxcbiAgICAnYWN4JzogICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9hY3guanMnKSxcbiAgICAnYWxsY29pbic6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9hbGxjb2luLmpzJyksXG4gICAgJ2FueHBybyc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYW54cHJvLmpzJyksXG4gICAgJ2JpbmFuY2UnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYmluYW5jZS5qcycpLFxuICAgICdiaXQyYyc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdDJjLmpzJyksXG4gICAgJ2JpdGJheSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0YmF5LmpzJyksXG4gICAgJ2JpdGNvaW5jb2lkJzogICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0Y29pbmNvaWQuanMnKSxcbiAgICAnYml0ZmluZXgnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRmaW5leC5qcycpLFxuICAgICdiaXRmaW5leDInOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdGZpbmV4Mi5qcycpLFxuICAgICdiaXRmbHllcic6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdGZseWVyLmpzJyksXG4gICAgJ2JpdGh1bWInOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0aHVtYi5qcycpLFxuICAgICdiaXRsaXNoJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdGxpc2guanMnKSxcbiAgICAnYml0bWFya2V0JzogICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRtYXJrZXQuanMnKSxcbiAgICAnYml0bWV4JzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRtZXguanMnKSxcbiAgICAnYml0c28nOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRzby5qcycpLFxuICAgICdiaXRzdGFtcCc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdHN0YW1wLmpzJyksXG4gICAgJ2JpdHN0YW1wMSc6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0c3RhbXAxLmpzJyksXG4gICAgJ2JpdHRyZXgnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0dHJleC5qcycpLFxuICAgICdibDNwJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JsM3AuanMnKSxcbiAgICAnYmxldXRyYWRlJzogICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9ibGV1dHJhZGUuanMnKSxcbiAgICAnYnRjYm94JzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9idGNib3guanMnKSxcbiAgICAnYnRjY2hpbmEnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9idGNjaGluYS5qcycpLFxuICAgICdidGNleGNoYW5nZSc6ICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0Y2V4Y2hhbmdlLmpzJyksXG4gICAgJ2J0Y21hcmtldHMnOiAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYnRjbWFya2V0cy5qcycpLFxuICAgICdidGN0cmFkZXVhJzogICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0Y3RyYWRldWEuanMnKSxcbiAgICAnYnRjdHVyayc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9idGN0dXJrLmpzJyksXG4gICAgJ2J0Y3gnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYnRjeC5qcycpLFxuICAgICdidGVyJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0ZXIuanMnKSxcbiAgICAnYnhpbnRoJzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9ieGludGguanMnKSxcbiAgICAnY2NleCc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jY2V4LmpzJyksXG4gICAgJ2NleCc6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY2V4LmpzJyksXG4gICAgJ2NoYnRjJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY2hidGMuanMnKSxcbiAgICAnY2hpbGViaXQnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jaGlsZWJpdC5qcycpLFxuICAgICdjb2luY2hlY2snOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5jaGVjay5qcycpLFxuICAgICdjb2luZmxvb3InOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5mbG9vci5qcycpLFxuICAgICdjb2luZ2knOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5naS5qcycpLFxuICAgICdjb2lubWFya2V0Y2FwJzogICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5tYXJrZXRjYXAuanMnKSxcbiAgICAnY29pbm1hdGUnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jb2lubWF0ZS5qcycpLFxuICAgICdjb2luc2VjdXJlJzogICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5zZWN1cmUuanMnKSxcbiAgICAnY29pbnNwb3QnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jb2luc3BvdC5qcycpLFxuICAgICdjcnlwdG9waWEnOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NyeXB0b3BpYS5qcycpLFxuICAgICdkc3gnOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2RzeC5qcycpLFxuICAgICdleG1vJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2V4bW8uanMnKSxcbiAgICAnZmxvd2J0Yyc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9mbG93YnRjLmpzJyksXG4gICAgJ2ZveGJpdCc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZm94Yml0LmpzJyksXG4gICAgJ2Z5YnNlJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZnlic2UuanMnKSxcbiAgICAnZnlic2cnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9meWJzZy5qcycpLFxuICAgICdnYXRlY29pbic6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2dhdGVjb2luLmpzJyksXG4gICAgJ2dhdGVpbyc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZ2F0ZWlvLmpzJyksXG4gICAgJ2dkYXgnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZ2RheC5qcycpLFxuICAgICdnZW1pbmknOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2dlbWluaS5qcycpLFxuICAgICdoaXRidGMnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2hpdGJ0Yy5qcycpLFxuICAgICdoaXRidGMyJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2hpdGJ0YzIuanMnKSxcbiAgICAnaHVvYmknOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9odW9iaS5qcycpLFxuICAgICdodW9iaWNueSc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2h1b2JpY255LmpzJyksXG4gICAgJ2h1b2JpcHJvJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvaHVvYmlwcm8uanMnKSxcbiAgICAnaW5kZXBlbmRlbnRyZXNlcnZlJzogICAgICByZXF1aXJlICgnLi9qcy9pbmRlcGVuZGVudHJlc2VydmUuanMnKSxcbiAgICAnaXRiaXQnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9pdGJpdC5qcycpLFxuICAgICdqdWJpJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2p1YmkuanMnKSxcbiAgICAna3Jha2VuJzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9rcmFrZW4uanMnKSxcbiAgICAna3VuYSc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9rdW5hLmpzJyksXG4gICAgJ2xha2VidGMnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbGFrZWJ0Yy5qcycpLFxuICAgICdsaXF1aSc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2xpcXVpLmpzJyksXG4gICAgJ2xpdmVjb2luJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbGl2ZWNvaW4uanMnKSxcbiAgICAnbHVubyc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9sdW5vLmpzJyksXG4gICAgJ21lcmNhZG8nOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbWVyY2Fkby5qcycpLFxuICAgICdtaXhjb2lucyc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL21peGNvaW5zLmpzJyksXG4gICAgJ25vdmEnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbm92YS5qcycpLFxuICAgICdva2NvaW5jbnknOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL29rY29pbmNueS5qcycpLFxuICAgICdva2NvaW51c2QnOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL29rY29pbnVzZC5qcycpLFxuICAgICdva2V4JzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL29rZXguanMnKSxcbiAgICAncGF5bWl1bSc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9wYXltaXVtLmpzJyksXG4gICAgJ3BvbG9uaWV4JzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvcG9sb25pZXguanMnKSxcbiAgICAncXJ5cHRvcyc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9xcnlwdG9zLmpzJyksXG4gICAgJ3F1YWRyaWdhY3gnOiAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvcXVhZHJpZ2FjeC5qcycpLFxuICAgICdxdW9pbmUnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3F1b2luZS5qcycpLFxuICAgICdzb3V0aHhjaGFuZ2UnOiAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3NvdXRoeGNoYW5nZS5qcycpLFxuICAgICdzdXJiaXRjb2luJzogICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3N1cmJpdGNvaW4uanMnKSxcbiAgICAndGhlcm9jayc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy90aGVyb2NrLmpzJyksXG4gICAgJ3RpZGV4JzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvdGlkZXguanMnKSxcbiAgICAndXJkdWJpdCc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy91cmR1Yml0LmpzJyksXG4gICAgJ3ZhdWx0b3JvJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvdmF1bHRvcm8uanMnKSxcbiAgICAndmJ0Yyc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy92YnRjLmpzJyksXG4gICAgJ3ZpcndveCc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvdmlyd294LmpzJyksXG4gICAgJ3dleCc6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvd2V4LmpzJyksXG4gICAgJ3hidGNlJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMveGJ0Y2UuanMnKSxcbiAgICAneW9iaXQnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy95b2JpdC5qcycpLFxuICAgICd5dW5iaSc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3l1bmJpLmpzJyksXG4gICAgJ3phaWYnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvemFpZi5qcycpLFxuICAgICd6Yic6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3piLmpzJyksICAgIFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiAoeyB2ZXJzaW9uLCBFeGNoYW5nZSwgZXhjaGFuZ2VzOiBPYmplY3Qua2V5cyAoZXhjaGFuZ2VzKSB9LCBleGNoYW5nZXMsIGZ1bmN0aW9ucywgZXJyb3JzKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgXzFicm9rZXIgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnXzFicm9rZXInLFxuICAgICAgICAgICAgJ25hbWUnOiAnMUJyb2tlcicsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICAgICAgICAgJ2hhc1B1YmxpY0FQSSc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnNjAnLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnOTAwJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnMzYwMCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzg2NDAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MDIxLTQyMGJkOWZjLTVlY2ItMTFlNy04ZWQ2LTU2ZDAwODFlZmVkMi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly8xYnJva2VyLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly8xYnJva2VyLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovLzFicm9rZXIuY29tLz9jPWVuL2NvbnRlbnQvYXBpLWRvY3VtZW50YXRpb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9iYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvY2F0ZWdvcmllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L2RldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9saXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvcXVvdGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvdGlja3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9jbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24vY2xvc2VfY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9lZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9vcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9zaGFyZWQvZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzb2NpYWwvcHJvZmlsZV9zdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzb2NpYWwvcHJvZmlsZV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYml0Y29pbl9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9vdmVydmlldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9xdW90YV9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvdHJhbnNhY3Rpb25fbG9nJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDYXRlZ29yaWVzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWFya2V0Q2F0ZWdvcmllcyAoKTtcbiAgICAgICAgLy8gdGhleSByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGFtb25nIHRoZWlyIGNhdGVnb3JpZXMsIHd0Zj9cbiAgICAgICAgbGV0IGNhdGVnb3JpZXMgPSByZXNwb25zZVsncmVzcG9uc2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzW2ldKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChjYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCB0aGlzXyA9IHRoaXM7IC8vIHdvcmthcm91bmQgZm9yIEJhYmVsIGJ1ZyAobm90IHBhc3NpbmcgYHRoaXNgIHRvIF9yZWN1cnNpdmUoKSBjYWxsKVxuICAgICAgICBsZXQgY2F0ZWdvcmllcyA9IGF3YWl0IHRoaXMuZmV0Y2hDYXRlZ29yaWVzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2F0ZWdvcmllcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGNhdGVnb3J5ID0gY2F0ZWdvcmllc1tjXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpc18ucHJpdmF0ZUdldE1hcmtldExpc3QgKHtcbiAgICAgICAgICAgICAgICAnY2F0ZWdvcnknOiBjYXRlZ29yeS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydyZXNwb25zZSddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3BvbnNlJ11bcF07XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoKGNhdGVnb3J5ID09ICdGT1JFWCcpIHx8IChjYXRlZ29yeSA9PSAnQ1JZUFRPJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAnVVNEJztcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpc18uY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHRoaXNfLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAgICAgJ290aGVyZmllbGQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnb25lbW9yZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VXNlck92ZXJ2aWV3ICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBiYWxhbmNlWydyZXNwb25zZSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSBwYXJzZUZsb2F0IChyZXNwb25zZVsnYmFsYW5jZSddKTtcbiAgICAgICAgcmVzdWx0WydCVEMnXVsnZnJlZSddID0gdG90YWw7XG4gICAgICAgIHJlc3VsdFsnQlRDJ11bJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE1hcmtldFF1b3RlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2xzJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzcG9uc2UnXVswXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlcmJvb2tbJ3VwZGF0ZWQnXSk7XG4gICAgICAgIGxldCBiaWRQcmljZSA9IHBhcnNlRmxvYXQgKG9yZGVyYm9va1snYmlkJ10pO1xuICAgICAgICBsZXQgYXNrUHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlcmJvb2tbJ2FzayddKTtcbiAgICAgICAgbGV0IGJpZCA9IFsgYmlkUHJpY2UsIHVuZGVmaW5lZCBdO1xuICAgICAgICBsZXQgYXNrID0gWyBhc2tQcmljZSwgdW5kZWZpbmVkIF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2JpZHMnOiBbIGJpZCBdLFxuICAgICAgICAgICAgJ2Fza3MnOiBbIGFzayBdLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVHJhZGVzICgpIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE1hcmtldEJhcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdyZXNvbHV0aW9uJzogNjAsXG4gICAgICAgICAgICAnbGltaXQnOiAxLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXN1bHRbJ3Jlc3BvbnNlJ11bMF07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWydkYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2wnXSksXG4gICAgICAgICAgICAnYmlkJzogb3JkZXJib29rWydiaWRzJ11bMF1bMF0sXG4gICAgICAgICAgICAnYXNrJzogb3JkZXJib29rWydhc2tzJ11bMF1bMF0sXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydjJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ2RhdGUnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnbyddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydoJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2wnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnYyddKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncmVzb2x1dGlvbic6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydkYXRlX3N0YXJ0J10gPSB0aGlzLmlzbzg2MDEgKHNpbmNlKTsgLy8gdGhleSBhbHNvIHN1cHBvcnQgZGF0ZV9lbmRcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWFya2V0QmFycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzdWx0WydyZXNwb25zZSddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdtYXJnaW4nOiBhbW91bnQsXG4gICAgICAgICAgICAnZGlyZWN0aW9uJzogKHNpZGUgPT0gJ3NlbGwnKSA/ICdzaG9ydCcgOiAnbG9uZycsXG4gICAgICAgICAgICAnbGV2ZXJhZ2UnOiAxLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3JkZXJbJ3R5cGUnXSArPSAnX21hcmtldCc7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlckNyZWF0ZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXNwb25zZSddWydvcmRlcl9pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aCArICcucGhwJztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHsgJ3Rva2VuJzogdGhpcy5hcGlLZXkgfSwgcGFyYW1zKTtcbiAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnd2FybmluZycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3dhcm5pbmcnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBfMWJ0Y3hlIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ18xYnRjeGUnLFxuICAgICAgICAgICAgJ25hbWUnOiAnMUJUQ1hFJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnUEEnLCAvLyBQYW5hbWFcbiAgICAgICAgICAgICdjb21tZW50JzogJ0NyeXB0byBDYXBpdGFsIEFQSScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFkJzogJzF5ZWFyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MDQ5LTJiMjk0NDA4LTVlY2MtMTFlNy04NWNjLWFkYWZmMDEzZGMxYS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly8xYnRjeGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovLzFidGN4ZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly8xYnRjeGUuY29tL2FwaS1kb2NzLnBocCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3JpY2FsLXByaWNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXItYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcy1hbmQtaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi1vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXItdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidGMtZGVwb3NpdC1hZGRyZXNzL2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnRjLWRlcG9zaXQtYWRkcmVzcy9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzL2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMvZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DTlknOiB7ICdpZCc6ICdDTlknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvUlVCJzogeyAnaWQnOiAnUlVCJywgJ3N5bWJvbCc6ICdCVEMvUlVCJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1JVQicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0NIRic6IHsgJ2lkJzogJ0NIRicsICdzeW1ib2wnOiAnQlRDL0NIRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDSEYnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9KUFknOiB7ICdpZCc6ICdKUFknLCAnc3ltYm9sJzogJ0JUQy9KUFknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvR0JQJzogeyAnaWQnOiAnR0JQJywgJ3N5bWJvbCc6ICdCVEMvR0JQJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0dCUCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0NBRCc6IHsgJ2lkJzogJ0NBRCcsICdzeW1ib2wnOiAnQlRDL0NBRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDQUQnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9BVUQnOiB7ICdpZCc6ICdBVUQnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQUVEJzogeyAnaWQnOiAnQUVEJywgJ3N5bWJvbCc6ICdCVEMvQUVEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0FFRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0JHTic6IHsgJ2lkJzogJ0JHTicsICdzeW1ib2wnOiAnQlRDL0JHTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdCR04nIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DWksnOiB7ICdpZCc6ICdDWksnLCAnc3ltYm9sJzogJ0JUQy9DWksnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ1pLJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvREtLJzogeyAnaWQnOiAnREtLJywgJ3N5bWJvbCc6ICdCVEMvREtLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0RLSycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0hLRCc6IHsgJ2lkJzogJ0hLRCcsICdzeW1ib2wnOiAnQlRDL0hLRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdIS0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9IUksnOiB7ICdpZCc6ICdIUksnLCAnc3ltYm9sJzogJ0JUQy9IUksnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSFJLJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvSFVGJzogeyAnaWQnOiAnSFVGJywgJ3N5bWJvbCc6ICdCVEMvSFVGJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0hVRicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0lMUyc6IHsgJ2lkJzogJ0lMUycsICdzeW1ib2wnOiAnQlRDL0lMUycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdJTFMnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9JTlInOiB7ICdpZCc6ICdJTlInLCAnc3ltYm9sJzogJ0JUQy9JTlInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSU5SJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvTVVSJzogeyAnaWQnOiAnTVVSJywgJ3N5bWJvbCc6ICdCVEMvTVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ01VUicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL01YTic6IHsgJ2lkJzogJ01YTicsICdzeW1ib2wnOiAnQlRDL01YTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdNWE4nIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9OT0snOiB7ICdpZCc6ICdOT0snLCAnc3ltYm9sJzogJ0JUQy9OT0snLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTk9LJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvTlpEJzogeyAnaWQnOiAnTlpEJywgJ3N5bWJvbCc6ICdCVEMvTlpEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ05aRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1BMTic6IHsgJ2lkJzogJ1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9ST04nOiB7ICdpZCc6ICdST04nLCAnc3ltYm9sJzogJ0JUQy9ST04nLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnUk9OJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvU0VLJzogeyAnaWQnOiAnU0VLJywgJ3N5bWJvbCc6ICdCVEMvU0VLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1NFSycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ1NHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9USEInOiB7ICdpZCc6ICdUSEInLCAnc3ltYm9sJzogJ0JUQy9USEInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVEhCJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvVFJZJzogeyAnaWQnOiAnVFJZJywgJ3N5bWJvbCc6ICdCVEMvVFJZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1RSWScgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1pBUic6IHsgJ2lkJzogJ1pBUicsICdzeW1ib2wnOiAnQlRDL1pBUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdaQVInIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlc0FuZEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2JhbGFuY2VzLWFuZC1pbmZvJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSwgY3VycmVuY3ksIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZVsnb25faG9sZCddLCBjdXJyZW5jeSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZVsnb3JkZXItYm9vayddLCB1bmRlZmluZWQsICdiaWQnLCAnYXNrJywgJ3ByaWNlJywgJ29yZGVyX2Ftb3VudCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0U3RhdHMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydzdGF0cyddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXgnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydtaW4nXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfcHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydkYWlseV9jaGFuZ2UnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3RvdGFsX2J0Y190cmFkZWQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFkJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ2RhdGUnXSArICcgMDA6MDA6MDAnKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydwcmljZSddKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEhpc3RvcmljYWxQcmljZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndGltZWZyYW1lJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb2hsY3ZzID0gdGhpcy5vbWl0IChyZXNwb25zZVsnaGlzdG9yaWNhbC1wcmljZXMnXSwgJ3JlcXVlc3RfY3VycmVuY3knKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKG9obGN2cywgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydtYWtlcl90eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gdGhpcy5vbWl0IChyZXNwb25zZVsndHJhbnNhY3Rpb25zJ10sICdyZXF1ZXN0X2N1cnJlbmN5Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsnbGltaXRfcHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyc05ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyc0NhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3YWxzTmV3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3VsdCddWyd1dWlkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PSAnY3J5cHRvY2FwaXRhbCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgaXMgYW4gYWJzdHJhY3QgYmFzZSBBUEkgZm9yIF8xYnRjeGUnKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgcmVzcG9uc2VbJ2Vycm9ycyddLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gcmVzcG9uc2VbJ2Vycm9ycyddW2VdO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoIChlcnJvclsnY29kZSddICsgJzogJyArIGVycm9yWydtZXNzYWdlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmpvaW4gKCcgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGFjeCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdhY3gnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQUNYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQVUnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMScsXG4gICAgICAgICAgICAgICAgJzVtJzogJzUnLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMTUnLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzAnLFxuICAgICAgICAgICAgICAgICcxaCc6ICc2MCcsXG4gICAgICAgICAgICAgICAgJzJoJzogJzEyMCcsXG4gICAgICAgICAgICAgICAgJzRoJzogJzI0MCcsXG4gICAgICAgICAgICAgICAgJzEyaCc6ICc3MjAnLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxNDQwJyxcbiAgICAgICAgICAgICAgICAnM2QnOiAnNDMyMCcsXG4gICAgICAgICAgICAgICAgJzF3JzogJzEwMDgwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMjQ3NjE0LTFmZTYxYzc0LTk2MjEtMTFlNy05ZThjLWYxYTYyN2FmYTI3OS5qcGcnLFxuICAgICAgICAgICAgICAgICdleHRlbnNpb24nOiAnLmpzb24nLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hY3guaW8vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYWN4LmlvJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYWN4LmlvL2RvY3VtZW50cy9hcGlfdjInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJywgLy8gR2V0IGFsbCBhdmFpbGFibGUgbWFya2V0c1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLCAvLyBHZXQgdGlja2VyIG9mIGFsbCBtYXJrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2Vycy97bWFya2V0fScsIC8vIEdldCB0aWNrZXIgb2Ygc3BlY2lmaWMgbWFya2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJywgLy8gR2V0IHJlY2VudCB0cmFkZXMgb24gbWFya2V0LCBlYWNoIHRyYWRlIGlzIGluY2x1ZGVkIG9ubHkgb25jZSBUcmFkZXMgYXJlIHNvcnRlZCBpbiByZXZlcnNlIGNyZWF0aW9uIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2snLCAvLyBHZXQgdGhlIG9yZGVyIGJvb2sgb2Ygc3BlY2lmaWVkIG1hcmtldFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoJywgLy8gR2V0IGRlcHRoIG9yIHNwZWNpZmllZCBtYXJrZXQgQm90aCBhc2tzIGFuZCBiaWRzIGFyZSBzb3J0ZWQgZnJvbSBoaWdoZXN0IHByaWNlIHRvIGxvd2VzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdrJywgLy8gR2V0IE9ITEMoayBsaW5lKSBvZiBzcGVjaWZpYyBtYXJrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICdrX3dpdGhfcGVuZGluZ190cmFkZXMnLCAvLyBHZXQgSyBkYXRhIHdpdGggcGVuZGluZyB0cmFkZXMsIHdoaWNoIGFyZSB0aGUgdHJhZGVzIG5vdCBpbmNsdWRlZCBpbiBLIGRhdGEgeWV0LCBiZWNhdXNlIHRoZXJlJ3MgZGVsYXkgYmV0d2VlbiB0cmFkZSBnZW5lcmF0ZWQgYW5kIHByb2Nlc3NlZCBieSBLIGRhdGEgZ2VuZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZXN0YW1wJywgLy8gR2V0IHNlcnZlciBjdXJyZW50IHRpbWUsIGluIHNlY29uZHMgc2luY2UgVW5peCBlcG9jaFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWVtYmVycy9tZScsIC8vIEdldCB5b3VyIHByb2ZpbGUgYW5kIGFjY291bnRzIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0cycsIC8vIEdldCB5b3VyIGRlcG9zaXRzIGhpc3RvcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0JywgLy8gR2V0IGRldGFpbHMgb2Ygc3BlY2lmaWMgZGVwb3NpdFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRfYWRkcmVzcycsIC8vIFdoZXJlIHRvIGRlcG9zaXQgVGhlIGFkZHJlc3MgZmllbGQgY291bGQgYmUgZW1wdHkgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIGdlbmVyYXRpbmcgKGUuZy4gZm9yIGJpdGNvaW4pLCB5b3Ugc2hvdWxkIHRyeSBhZ2FpbiBsYXRlciBpbiB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJywgLy8gR2V0IHlvdXIgb3JkZXJzLCByZXN1bHRzIGlzIHBhZ2luYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJywgLy8gR2V0IGluZm9ybWF0aW9uIG9mIHNwZWNpZmllZCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9teScsIC8vIEdldCB5b3VyIGV4ZWN1dGVkIHRyYWRlcyBUcmFkZXMgYXJlIHNvcnRlZCBpbiByZXZlcnNlIGNyZWF0aW9uIG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3cycsIC8vIEdldCB5b3VyIGNyeXB0b2N1cnJlbmN5IHdpdGhkcmF3c1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JywgLy8gR2V0IHlvdXIgY3J5cHRvY3VycmVuY3kgd2l0aGRyYXdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJywgLy8gQ3JlYXRlIGEgU2VsbC9CdXkgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvbXVsdGknLCAvLyBDcmVhdGUgbXVsdGlwbGUgc2VsbC9idXkgb3JkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2NsZWFyJywgLy8gQ2FuY2VsIGFsbCBteSBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9kZWxldGUnLCAvLyBDYW5jZWwgYW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsIC8vIENyZWF0ZSBhIHdpdGhkcmF3XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWVtYmVyc01lICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYWNjb3VudHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2xvY2tlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2xpbWl0JzogMzAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnYXQnXSAqIDEwMDA7XG4gICAgICAgIHRpY2tlciA9IHRpY2tlclsndGlja2VyJ107XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnc2VsbCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gaWQuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnNNYXJrZXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gJ2JpZCcpID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIC8vIGxvb2tzIGxpa2UgdGhleSBzd2l0Y2hlZCB0aGlzIGVuZHBvaW50IG9mZlxuICAgICAgICAvLyBpdCByZXR1cm5zIDUwMyBTZXJ2aWNlIFRlbXBvcmFyaWx5IFVuYXZhaWxhYmxlIGFsd2F5c1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdICogMTAwMCxcbiAgICAgICAgICAgIG9obGN2WzFdLFxuICAgICAgICAgICAgb2hsY3ZbMl0sXG4gICAgICAgICAgICBvaGxjdlszXSxcbiAgICAgICAgICAgIG9obGN2WzRdLFxuICAgICAgICAgICAgb2hsY3ZbNV0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgaWYgKCFsaW1pdClcbiAgICAgICAgICAgIGxpbWl0ID0gNTAwOyAvLyBkZWZhdWx0IGlzIDMwXG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdsaW1pdCc6IGxpbWl0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0Wyd0aW1lc3RhbXAnXSA9IHNpbmNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEsgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydjcmVhdGVkX2F0J10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ2lkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvcGVuJyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWydvcmRfdHlwZSddLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAob3JkZXJbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKG9yZGVyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnZmlsbGVkJzogcGFyc2VGbG9hdCAob3JkZXJbJ2V4ZWN1dGVkX3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBwYXJzZUZsb2F0IChvcmRlclsncmVtYWluaW5nX3ZvbHVtZSddKSxcbiAgICAgICAgICAgICd0cmFkZXMnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICd2b2x1bWUnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkX3R5cGUnOiB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKSB7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlLnRvU3RyaW5nICgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlcnMgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNCeUlkW3Jlc3BvbnNlWydtYXJrZXQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyRGVsZXRlICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3kudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAnc3VtJzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSAnL2FwaScgKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGlmICgnZXh0ZW5zaW9uJyBpbiB0aGlzLnVybHMpXG4gICAgICAgICAgICByZXF1ZXN0ICs9IHRoaXMudXJsc1snZXh0ZW5zaW9uJ107XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhY2Nlc3Nfa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3RvbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG1ldGhvZCArICd8JyArIHJlcXVlc3QgKyAnfCcgKyBxdWVyeTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gcXVlcnkgKyAnJnNpZ25hdHVyZT0nICsgc2lnbmF0dXJlO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBzdWZmaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBzdWZmaXg7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9rY29pbnVzZCA9IHJlcXVpcmUgKCcuL29rY29pbnVzZC5qcycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhbGxjb2luIGV4dGVuZHMgb2tjb2ludXNkIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdhbGxjb2luJyxcbiAgICAgICAgICAgICduYW1lJzogJ0FsbGNvaW4nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDQScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2V4dGVuc2lvbic6ICcnLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMTU2MTgwOS1jMzE2YjM3Yy1iMDYxLTExZTctOGQ1YS1iNTQ3YjRkNzMwZWIuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vYWxsY29pbi5jb20nLFxuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmFsbGNvaW4uY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmFsbGNvaW4uY29tL2FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYWxsY29pbi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9hbGxjb2luLmNvbS9BYm91dC9BUElSZWZlcmVuY2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3dlYic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRvdmVydmlld3MvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2tsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmF0Y2hfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcGF5bWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IFsgJ0JUQycsICdFVEgnLCAnVVNEJywgJ1FUVU0nIF07XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53ZWJHZXRNYXJrZXRvdmVydmlld3MgKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdmdWxsJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kYXJ5JzogY3VycmVuY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ01hcmtldHMnXTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbWFya2V0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2tdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydQcmltYXJ5J107XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0WydTZWNvbmRhcnknXTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBiYXNlLnRvTG93ZXJDYXNlICgpICsgJ18nICsgcXVvdGUudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3BvdCcsXG4gICAgICAgICAgICAgICAgICAgICdzcG90JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZSc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldE9yZGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDApXG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICBpZiAoc3RhdHVzID09IDEpXG4gICAgICAgICAgICByZXR1cm4gJ3BhcnRpYWwnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDIpXG4gICAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gMTApXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhbnhwcm8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYW54cHJvJyxcbiAgICAgICAgICAgICduYW1lJzogJ0FOWFBybycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnSlAnLCAnU0cnLCAnSEsnLCAnTlonIF0sXG4gICAgICAgICAgICAndmVyc2lvbic6ICcyJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRyYWRlcyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjU5ODMtZmQ4NTk1ZGEtNWVjOS0xMWU3LTgyZTMtYWRiM2FiOGMyNjEyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FueHByby5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYW54cHJvLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9kb2NzLmFueHYyLmFwaWFyeS5pbycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FueHByby5jb20vcGFnZXMvYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvZGVwdGgvZnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L3RyYWRlL2ZldGNoJywgLy8gZGlzYWJsZWQgYnkgQU5YUHJvXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL3F1b3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXIvcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb25leS97Y3VycmVuY3l9L2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3tjdXJyZW5jeX0vc2VuZF9zaW1wbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3RyYWRlL2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3dhbGxldC9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnQlRDVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0hLRCc6IHsgJ2lkJzogJ0JUQ0hLRCcsICdzeW1ib2wnOiAnQlRDL0hLRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdIS0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdCVENFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQ0FEJzogeyAnaWQnOiAnQlRDQ0FEJywgJ3N5bWJvbCc6ICdCVEMvQ0FEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NBRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0FVRCc6IHsgJ2lkJzogJ0JUQ0FVRCcsICdzeW1ib2wnOiAnQlRDL0FVRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9TR0QnOiB7ICdpZCc6ICdCVENTR0QnLCAnc3ltYm9sJzogJ0JUQy9TR0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0dEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvSlBZJzogeyAnaWQnOiAnQlRDSlBZJywgJ3N5bWJvbCc6ICdCVEMvSlBZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0dCUCc6IHsgJ2lkJzogJ0JUQ0dCUCcsICdzeW1ib2wnOiAnQlRDL0dCUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdHQlAnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9OWkQnOiB7ICdpZCc6ICdCVENOWkQnLCAnc3ltYm9sJzogJ0JUQy9OWkQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTlpEJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnRE9HRS9CVEMnOiB7ICdpZCc6ICdET0dFQlRDJywgJ3N5bWJvbCc6ICdET0dFL0JUQycsICdiYXNlJzogJ0RPR0UnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdTVFIvQlRDJzogeyAnaWQnOiAnU1RSQlRDJywgJ3N5bWJvbCc6ICdTVFIvQlRDJywgJ2Jhc2UnOiAnU1RSJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ1hSUEJUQycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMyAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC42IC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNb25leUluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZVsnV2FsbGV0cyddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VbJ1dhbGxldHMnXSkge1xuICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBiYWxhbmNlWydXYWxsZXRzJ11bY3VycmVuY3ldO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKHdhbGxldFsnQXZhaWxhYmxlX0JhbGFuY2UnXVsndmFsdWUnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKHdhbGxldFsnQmFsYW5jZSddWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lQYWlyTW9uZXlEZXB0aEZ1bGwgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lfcGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHQgPSBwYXJzZUludCAob3JkZXJib29rWydkYXRhVXBkYXRlVGltZSddKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0IC8gMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5UGFpck1vbmV5VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0ID0gcGFyc2VJbnQgKHRpY2tlclsnZGF0YVVwZGF0ZVRpbWUnXSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodCAvIDEwMDApO1xuICAgICAgICBsZXQgYmlkID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlclsnYnV5J10sICd2YWx1ZScpO1xuICAgICAgICBsZXQgYXNrID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlclsnc2VsbCddLCAndmFsdWUnKTs7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ11bJ3ZhbHVlJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ11bJ3ZhbHVlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddWyd2YWx1ZSddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddWyd2YWx1ZSddKSxcbiAgICAgICAgICAgICdiaWQnOiBiaWQsXG4gICAgICAgICAgICAnYXNrJzogYXNrLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddWyd2YWx1ZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogcGFyc2VGbG9hdCAodGlja2VyWydhdmcnXVsndmFsdWUnXSksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBiYXNlVm9sdW1lICogdndhcCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHN3aXRjaGVkIG9mZiB0aGUgdHJhZGVzIGVuZHBvaW50LCBzZWUgdGhlaXIgZG9jcyBhdCBodHRwOi8vZG9jcy5hbnh2Mi5hcGlhcnkuaW8vcmVmZXJlbmNlL21hcmtldC1kYXRhL2N1cnJlbmN5cGFpcm1vbmV5dHJhZGVmZXRjaC1kaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVBhaXJNb25leVRyYWRlRmV0Y2ggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lfcGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgICAgICdhbW91bnRfaW50JzogcGFyc2VJbnQgKGFtb3VudCAqIDEwMDAwMDAwMCksIC8vIDEwXjhcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZV9pbnQnXSA9IHBhcnNlSW50IChwcmljZSAqIDEwMDAwMCk7IC8vIDEwXjVcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDdXJyZW5jeVBhaXJPcmRlckFkZCAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydkYXRhJ11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDdXJyZW5jeVBhaXJPcmRlckNhbmNlbCAoeyAnb2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNb25leUN1cnJlbmN5U2VuZFNpbXBsZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudF9pbnQnOiBwYXJzZUludCAoYW1vdW50ICogMTAwMDAwMDAwKSwgLy8gMTBeOFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnZGF0YSddWyd0cmFuc2FjdGlvbklkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHJlcXVlc3Q7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHJlcXVlc3QgKyBcIlxcMFwiICsgYm9keTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ1Jlc3QtS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1Jlc3QtU2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddID09ICdzdWNjZXNzJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGlzTm9kZSAgICA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAsIGZ1bmN0aW9ucyA9IHJlcXVpcmUgKCcuL2Z1bmN0aW9ucycpXG4gICAgLCB0aHJvdHRsZSAgPSByZXF1aXJlICgnLi90aHJvdHRsZScpXG4gICAgLCBmZXRjaCAgICAgPSByZXF1aXJlICgnZmV0Y2gtcG9ueWZpbGwnKSgpLmZldGNoXG4gICAgLCBNYXJrZXQgICAgPSByZXF1aXJlICgnLi9NYXJrZXQnKVxuXG5jb25zdCB7IGRlZXBFeHRlbmRcbiAgICAgICwgZXh0ZW5kXG4gICAgICAsIHNsZWVwXG4gICAgICAsIHRpbWVvdXRcbiAgICAgICwgaW5kZXhCeVxuICAgICAgLCBzb3J0QnlcbiAgICAgICwgYWdncmVnYXRlXG4gICAgICAsIHV1aWRcbiAgICAgICwgcHJlY2lzaW9uRnJvbVN0cmluZyB9ID0gZnVuY3Rpb25zXG5cbmNvbnN0IHsgRXhjaGFuZ2VFcnJvclxuICAgICAgLCBOb3RTdXBwb3J0ZWRcbiAgICAgICwgQXV0aGVudGljYXRpb25FcnJvclxuICAgICAgLCBERG9TUHJvdGVjdGlvblxuICAgICAgLCBSZXF1ZXN0VGltZW91dFxuICAgICAgLCBFeGNoYW5nZU5vdEF2YWlsYWJsZSB9ID0gcmVxdWlyZSAoJy4vZXJyb3JzJylcblxuLy8gc3R1YiB1bnRpbCB3ZSBnZXQgYSBiZXR0ZXIgc29sdXRpb24gZm9yIFdlYnBhY2sgYW5kIFJlYWN0XG4vLyBjb25zdCBqb3VybmFsID0gaXNOb2RlICYmIHJlcXVpcmUgKCcuL2pvdXJuYWwnKVxuY29uc3Qgam91cm5hbCA9IHVuZGVmaW5lZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEV4Y2hhbmdlIHtcblxuICAgIGdldE1hcmtldCAoc3ltYm9sKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLm1hcmtldENsYXNzZXMpXG4gICAgICAgICAgICB0aGlzLm1hcmtldENsYXNzZXMgPSB7fVxuXG4gICAgICAgIGxldCBtYXJrZXRDbGFzcyA9IHRoaXMubWFya2V0Q2xhc3Nlc1tzeW1ib2xdXG5cbiAgICAgICAgaWYgKG1hcmtldENsYXNzKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtldENsYXNzXG5cbiAgICAgICAgbWFya2V0Q2xhc3MgPSBuZXcgTWFya2V0ICh0aGlzLCBzeW1ib2wpXG4gICAgICAgIHRoaXMubWFya2V0Q2xhc3Nlc1tzeW1ib2xdID0gbWFya2V0Q2xhc3MgLy8gb25seSBvbmUgTWFya2V0IGluc3RhbmNlIHBlciBtYXJrZXRcbiAgICAgICAgcmV0dXJuIG1hcmtldENsYXNzXG4gICAgfVxuXG4gICAgZGVzY3JpYmUgKCkgeyByZXR1cm4ge30gfVxuXG4gICAgY29uc3RydWN0b3IgKHVzZXJDb25maWcgPSB7fSkge1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24gKHRoaXMsIGZ1bmN0aW9ucywgeyBlbmNvZGU6IHN0cmluZyA9PiBzdHJpbmcsIGRlY29kZTogc3RyaW5nID0+IHN0cmluZyB9KVxuXG4gICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICB0aGlzLm5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uLm1hdGNoICgvXFxkK1xcLlxcZCsuXFxkKy8pIFswXVxuXG4gICAgICAgIC8vIHRoaXMuaW5pdFJlc3RSYXRlTGltaXRlciAoKVxuXG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50ID0ge1xuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogJ2NjeHQvJyArIEV4Y2hhbmdlLmNjeHRWZXJzaW9uICtcbiAgICAgICAgICAgICAgICAgICAgJyAoK2h0dHBzOi8vZ2l0aHViLmNvbS9jY3h0L2NjeHQpJyArXG4gICAgICAgICAgICAgICAgICAgICcgTm9kZS5qcy8nICsgdGhpcy5ub2RlVmVyc2lvbiArICcgKEphdmFTY3JpcHQpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGVuZGVkIHRvIFVSTCwgbGlrZSBodHRwczovL3Byb3h5LmNvbS9odHRwczovL2V4Y2hhbmdlLmNvbS9hcGkuLi5cbiAgICAgICAgdGhpcy5wcm94eSA9ICcnXG5cbiAgICAgICAgdGhpcy5pc284NjAxICAgICAgICAgPSB0aW1lc3RhbXAgPT4gbmV3IERhdGUgKHRpbWVzdGFtcCkudG9JU09TdHJpbmcgKClcbiAgICAgICAgdGhpcy5wYXJzZTg2MDEgICAgICAgPSB4ID0+IERhdGUucGFyc2UgKCgoeC5pbmRleE9mICgnKycpID49IDApIHx8ICh4LnNsaWNlICgtMSkgPT0gJ1onKSkgPyB4IDogKHggKyAnWicpKVxuICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcyAgICA9IERhdGUubm93XG4gICAgICAgIHRoaXMubWljcm9zZWNvbmRzICAgID0gKCkgPT4gTWF0aC5mbG9vciAodGhpcy5taWxsaXNlY29uZHMgKCkgKiAxMDAwKVxuICAgICAgICB0aGlzLnNlY29uZHMgICAgICAgICA9ICgpID0+IE1hdGguZmxvb3IgKHRoaXMubWlsbGlzZWNvbmRzICgpIC8gMTAwMClcbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgICAgPSB1bmRlZmluZWRcblxuICAgICAgICAvLyByYXRlIGxpbWl0ZXIgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5lbmFibGVSYXRlTGltaXQgPSBmYWxzZVxuICAgICAgICB0aGlzLnJhdGVMaW1pdCAgICAgICA9IDIwMDAgIC8vIG1pbGxpc2Vjb25kcyA9IHNlY29uZHMgKiAxMDAwXG5cbiAgICAgICAgdGhpcy50aW1lb3V0ICAgICAgICAgPSAxMDAwMCAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgdGhpcy52ZXJib3NlICAgICAgICAgPSBmYWxzZVxuICAgICAgICB0aGlzLmRlYnVnICAgICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuam91cm5hbCAgICAgICAgID0gJ2RlYnVnLmpzb24nXG4gICAgICAgIHRoaXMudXNlckFnZW50ICAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy50d29mYSAgICAgICAgICAgPSBmYWxzZSAvLyB0d28tZmFjdG9yIGF1dGhlbnRpY2F0aW9uICgyRkEpXG4gICAgICAgIHRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMgPSB0cnVlXG4gICAgICAgIHRoaXMucGFyc2VCYWxhbmNlRnJvbU9wZW5PcmRlcnMgPSBmYWxzZVxuICAgICAgICB0aGlzLnRpbWVmcmFtZXMgICAgICA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmhhc1B1YmxpY0FQSSAgICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc1ByaXZhdGVBUEkgICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc0NPUlMgICAgICAgICAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNEZXBvc2l0ICAgICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hCYWxhbmNlICAgICAgPSB0cnVlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hDbG9zZWRPcmRlcnMgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoQ3VycmVuY2llcyAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaE15VHJhZGVzICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPSExDViAgICAgICAgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoT3Blbk9yZGVycyAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaE9yZGVyICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPcmRlckJvb2sgICAgPSB0cnVlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPcmRlcnMgICAgICAgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoVGlja2VyICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc0ZldGNoVGlja2VycyAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaFRyYWRlcyAgICAgICA9IHRydWVcbiAgICAgICAgdGhpcy5oYXNXaXRoZHJhdyAgICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzQ3JlYXRlT3JkZXIgICAgICAgPSB0aGlzLmhhc1ByaXZhdGVBUElcbiAgICAgICAgdGhpcy5oYXNDYW5jZWxPcmRlciAgICAgICA9IHRoaXMuaGFzUHJpdmF0ZUFQSVxuXG4gICAgICAgIHRoaXMucmVxdWlyZWRDcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgICdhcGlLZXknOiAgIHRydWUsXG4gICAgICAgICAgICAnc2VjcmV0JzogICB0cnVlLFxuICAgICAgICAgICAgJ3VpZCc6ICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnbG9naW4nOiAgICBmYWxzZSxcbiAgICAgICAgICAgICdwYXNzd29yZCc6IGZhbHNlLFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYWxhbmNlICAgID0ge31cbiAgICAgICAgdGhpcy5vcmRlcmJvb2tzID0ge31cbiAgICAgICAgdGhpcy50aWNrZXJzICAgID0ge31cbiAgICAgICAgdGhpcy5mZWVzICAgICAgID0ge31cbiAgICAgICAgdGhpcy5vcmRlcnMgICAgID0ge31cbiAgICAgICAgdGhpcy50cmFkZXMgICAgID0ge31cbiAgICAgICAgdGhpcy5jdXJyZW5jaWVzID0ge31cblxuICAgICAgICB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmxhc3RfanNvbl9yZXNwb25zZSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIFRPRE86IGdlbmVyYXRlXG4gICAgICAgIHRoaXMubWFya2V0X2lkICAgICAgICAgICAgICAgICAgID0gdGhpcy5tYXJrZXRJZFxuICAgICAgICB0aGlzLm1hcmtldF9pZHMgICAgICAgICAgICAgICAgICA9IHRoaXMubWFya2V0SWRzXG4gICAgICAgIHRoaXMuaW1wbG9kZV9wYXJhbXMgICAgICAgICAgICAgID0gdGhpcy5pbXBsb2RlUGFyYW1zXG4gICAgICAgIHRoaXMuZXh0cmFjdF9wYXJhbXMgICAgICAgICAgICAgID0gdGhpcy5leHRyYWN0UGFyYW1zXG4gICAgICAgIHRoaXMuZmV0Y2hfYmFsYW5jZSAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaEJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF9mcmVlX2JhbGFuY2UgICAgICAgICAgPSB0aGlzLmZldGNoRnJlZUJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF91c2VkX2JhbGFuY2UgICAgICAgICAgPSB0aGlzLmZldGNoVXNlZEJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF90b3RhbF9iYWxhbmNlICAgICAgICAgPSB0aGlzLmZldGNoVG90YWxCYWxhbmNlXG4gICAgICAgIHRoaXMuZmV0Y2hfbDJfb3JkZXJfYm9vayAgICAgICAgID0gdGhpcy5mZXRjaEwyT3JkZXJCb29rXG4gICAgICAgIHRoaXMuZmV0Y2hfb3JkZXJfYm9vayAgICAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyQm9va1xuICAgICAgICB0aGlzLmZldGNoX3RpY2tlcnMgICAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUaWNrZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfdGlja2VyICAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaFRpY2tlclxuICAgICAgICB0aGlzLmZldGNoX3RyYWRlcyAgICAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUcmFkZXNcbiAgICAgICAgdGhpcy5mZXRjaF9vcmRlciAgICAgICAgICAgICAgICAgPSB0aGlzLmZldGNoT3JkZXJcbiAgICAgICAgdGhpcy5mZXRjaF9vcmRlcnMgICAgICAgICAgICAgICAgPSB0aGlzLmZldGNoT3JkZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfb3Blbl9vcmRlcnMgICAgICAgICAgID0gdGhpcy5mZXRjaE9wZW5PcmRlcnNcbiAgICAgICAgdGhpcy5mZXRjaF9jbG9zZWRfb3JkZXJzICAgICAgICAgPSB0aGlzLmZldGNoQ2xvc2VkT3JkZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfb3JkZXJfc3RhdHVzICAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyU3RhdHVzXG4gICAgICAgIHRoaXMuZmV0Y2hfbWFya2V0cyAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaE1hcmtldHNcbiAgICAgICAgdGhpcy5sb2FkX21hcmtldHMgICAgICAgICAgICAgICAgPSB0aGlzLmxvYWRNYXJrZXRzXG4gICAgICAgIHRoaXMuc2V0X21hcmtldHMgICAgICAgICAgICAgICAgID0gdGhpcy5zZXRNYXJrZXRzXG4gICAgICAgIHRoaXMucGFyc2VfYmFsYW5jZSAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZUJhbGFuY2VcbiAgICAgICAgdGhpcy5wYXJzZV9iaWRfYXNrICAgICAgICAgICAgICAgPSB0aGlzLnBhcnNlQmlkQXNrXG4gICAgICAgIHRoaXMucGFyc2VfYmlkc19hc2tzICAgICAgICAgICAgID0gdGhpcy5wYXJzZUJpZHNBc2tzXG4gICAgICAgIHRoaXMucGFyc2Vfb3JkZXJfYm9vayAgICAgICAgICAgID0gdGhpcy5wYXJzZU9yZGVyQm9va1xuICAgICAgICB0aGlzLnBhcnNlX3RyYWRlcyAgICAgICAgICAgICAgICA9IHRoaXMucGFyc2VUcmFkZXNcbiAgICAgICAgdGhpcy5wYXJzZV9vcmRlcnMgICAgICAgICAgICAgICAgPSB0aGlzLnBhcnNlT3JkZXJzXG4gICAgICAgIHRoaXMucGFyc2Vfb2hsY3YgICAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZU9ITENWXG4gICAgICAgIHRoaXMucGFyc2Vfb2hsY3ZzICAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZU9ITENWc1xuICAgICAgICB0aGlzLmVkaXRfbGltaXRfYnV5X29yZGVyICAgICAgICA9IHRoaXMuZWRpdExpbWl0QnV5T3JkZXJcbiAgICAgICAgdGhpcy5lZGl0X2xpbWl0X3NlbGxfb3JkZXIgICAgICAgPSB0aGlzLmVkaXRMaW1pdFNlbGxPcmRlclxuICAgICAgICB0aGlzLmVkaXRfbGltaXRfb3JkZXIgICAgICAgICAgICA9IHRoaXMuZWRpdExpbWl0T3JkZXJcbiAgICAgICAgdGhpcy5lZGl0X29yZGVyICAgICAgICAgICAgICAgICAgPSB0aGlzLmVkaXRPcmRlclxuICAgICAgICB0aGlzLmNyZWF0ZV9saW1pdF9idXlfb3JkZXIgICAgICA9IHRoaXMuY3JlYXRlTGltaXRCdXlPcmRlclxuICAgICAgICB0aGlzLmNyZWF0ZV9saW1pdF9zZWxsX29yZGVyICAgICA9IHRoaXMuY3JlYXRlTGltaXRTZWxsT3JkZXJcbiAgICAgICAgdGhpcy5jcmVhdGVfbWFya2V0X2J1eV9vcmRlciAgICAgPSB0aGlzLmNyZWF0ZU1hcmtldEJ1eU9yZGVyXG4gICAgICAgIHRoaXMuY3JlYXRlX21hcmtldF9zZWxsX29yZGVyICAgID0gdGhpcy5jcmVhdGVNYXJrZXRTZWxsT3JkZXJcbiAgICAgICAgdGhpcy5jcmVhdGVfb3JkZXIgICAgICAgICAgICAgICAgPSB0aGlzLmNyZWF0ZU9yZGVyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlX2ZlZSAgICAgICAgICAgICAgID0gdGhpcy5jYWxjdWxhdGVGZWVcbiAgICAgICAgdGhpcy5jb21tb25fY3VycmVuY3lfY29kZSAgICAgICAgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZVxuICAgICAgICB0aGlzLnByaWNlX3RvX3ByZWNpc2lvbiAgICAgICAgICA9IHRoaXMucHJpY2VUb1ByZWNpc2lvblxuICAgICAgICB0aGlzLmFtb3VudF90b19wcmVjaXNpb24gICAgICAgICA9IHRoaXMuYW1vdW50VG9QcmVjaXNpb25cbiAgICAgICAgdGhpcy5mZWVfdG9fcHJlY2lzaW9uICAgICAgICAgICAgPSB0aGlzLmZlZVRvUHJlY2lzaW9uXG4gICAgICAgIHRoaXMuY29zdF90b19wcmVjaXNpb24gICAgICAgICAgID0gdGhpcy5jb3N0VG9QcmVjaXNpb25cbiAgICAgICAgdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nICAgICAgICAgPSBwcmVjaXNpb25Gcm9tU3RyaW5nXG4gICAgICAgIHRoaXMucHJlY2lzaW9uX2Zyb21fc3RyaW5nICAgICAgID0gcHJlY2lzaW9uRnJvbVN0cmluZ1xuICAgICAgICB0aGlzLnRydW5jYXRlICAgICAgICAgICAgICAgICAgICA9IGZ1bmN0aW9ucy50cnVuY2F0ZVxuICAgICAgICB0aGlzLnV1aWQgICAgICAgICAgICAgICAgICAgICAgICA9IHV1aWRcblxuICAgICAgICAvLyBBUEkgbWV0aG9kcyBtZXRhaW5mb1xuICAgICAgICB0aGlzLmhhcyA9IHtcbiAgICAgICAgICAgICdjYW5jZWxPcmRlcic6IHRoaXMuaGFzUHJpdmF0ZUFQSSxcbiAgICAgICAgICAgICdjcmVhdGVPcmRlcic6IHRoaXMuaGFzUHJpdmF0ZUFQSSxcbiAgICAgICAgICAgICdkZXBvc2l0JzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hCYWxhbmNlJzogdGhpcy5oYXNQcml2YXRlQVBJLFxuICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hDdXJyZW5jaWVzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hNYXJrZXRzJzogdHJ1ZSxcbiAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaE9yZGVyQm9vayc6IHRydWUsXG4gICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaFRpY2tlcic6IHRydWUsXG4gICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ3dpdGhkcmF3JzogZmFsc2UsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZXJnZSBjb25maWdzXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGRlZXBFeHRlbmQgKHRoaXMuZGVzY3JpYmUgKCksIHVzZXJDb25maWcpXG5cbiAgICAgICAgLy8gbWVyZ2UgdG8gdGhpc1xuICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzIChjb25maWcpKVxuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWVwRXh0ZW5kICh0aGlzW3Byb3BlcnR5XSwgdmFsdWUpXG5cbiAgICAgICAgaWYgKHRoaXMuYXBpKVxuICAgICAgICAgICAgdGhpcy5kZWZpbmVSZXN0QXBpICh0aGlzLmFwaSwgJ3JlcXVlc3QnKVxuXG4gICAgICAgIHRoaXMuaW5pdFJlc3RSYXRlTGltaXRlciAoKVxuXG4gICAgICAgIGlmICh0aGlzLm1hcmtldHMpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtldHMgKHRoaXMubWFya2V0cylcblxuICAgICAgICBpZiAodGhpcy5kZWJ1ZyAmJiBqb3VybmFsKSB7XG4gICAgICAgICAgICBqb3VybmFsICgoKSA9PiB0aGlzLmpvdXJuYWwsIHRoaXMsIE9iamVjdC5rZXlzICh0aGlzLmhhcykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZhdWx0cyAoKSB7XG4gICAgICAgIHJldHVybiB7IC8qIG92ZXJyaWRlIG1lICovIH1cbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKClcbiAgICB9XG5cbiAgICBlbmNvZGVVUklDb21wb25lbnQgKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCAoLi4uYXJncylcbiAgICB9XG5cbiAgICBjaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCkge1xuICAgICAgICBPYmplY3Qua2V5cyAodGhpcy5yZXF1aXJlZENyZWRlbnRpYWxzKS5tYXAgKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlZENyZWRlbnRpYWxzW2tleV0gJiYgIXRoaXNba2V5XSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYCcgKyBrZXkgKyAnYCcpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaW5pdFJlc3RSYXRlTGltaXRlciAoKSB7XG5cbiAgICAgICAgdGhpcy50b2tlbkJ1Y2tldCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICByZWZpbGxSYXRlOiAgMSAvIHRoaXMucmF0ZUxpbWl0LFxuICAgICAgICAgICAgZGVsYXk6ICAgICAgIDEsXG4gICAgICAgICAgICBjYXBhY2l0eTogICAgMSxcbiAgICAgICAgICAgIGRlZmF1bHRDb3N0OiAxLFxuICAgICAgICAgICAgbWF4Q2FwYWNpdHk6IDEwMDAsXG4gICAgICAgIH0sIHRoaXMudG9rZW5CdWNrZXQpXG5cbiAgICAgICAgdGhpcy50aHJvdHRsZSA9IHRocm90dGxlICh0aGlzLnRva2VuQnVja2V0KVxuXG4gICAgICAgIHRoaXMuZXhlY3V0ZVJlc3RSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgbGV0IHByb21pc2UgPVxuICAgICAgICAgICAgICAgIGZldGNoICh1cmwsIHsgJ21ldGhvZCc6IG1ldGhvZCwgJ2hlYWRlcnMnOiBoZWFkZXJzLCAnYm9keSc6IGJvZHksICdhZ2VudCc6IHRoaXMudHVubmVsQWdlbnQgfHwgbnVsbH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCAoZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZU5vdEF2YWlsYWJsZSAoWyB0aGlzLmlkLCBtZXRob2QsIHVybCwgZS50eXBlLCBlLm1lc3NhZ2UgXS5qb2luICgnICcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZSAvLyByZXRocm93IGFsbCB1bmtub3duIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbiAocmVzcG9uc2UgPT4gdGhpcy5oYW5kbGVSZXN0RXJyb3JzIChyZXNwb25zZSwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbiAocmVzcG9uc2UgPT4gdGhpcy5oYW5kbGVSZXN0UmVzcG9uc2UgKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkpXG5cbiAgICAgICAgICAgIHJldHVybiB0aW1lb3V0ICh0aGlzLnRpbWVvdXQsIHByb21pc2UpLmNhdGNoIChlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcXVlc3RUaW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdFRpbWVvdXQgKHRoaXMuaWQgKyAnICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICcgKyBlLm1lc3NhZ2UgKyAnICgnICsgdGhpcy50aW1lb3V0ICsgJyBtcyknKVxuICAgICAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZpbmVSZXN0QXBpIChhcGksIG1ldGhvZE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3Qua2V5cyAoYXBpKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBodHRwTWV0aG9kIG9mIE9iamVjdC5rZXlzIChhcGlbdHlwZV0pKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgdXJscyA9IGFwaVt0eXBlXVtodHRwTWV0aG9kXVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gdXJsc1tpXS50cmltICgpXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdFBhdGggPSB1cmwuc3BsaXQgKC9bXmEtekEtWjAtOV0vKVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cHBlcmNhc2VNZXRob2QgID0gaHR0cE1ldGhvZC50b1VwcGVyQ2FzZSAoKVxuICAgICAgICAgICAgICAgICAgICBsZXQgbG93ZXJjYXNlTWV0aG9kICA9IGh0dHBNZXRob2QudG9Mb3dlckNhc2UgKClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbWVsY2FzZU1ldGhvZCAgPSB0aGlzLmNhcGl0YWxpemUgKGxvd2VyY2FzZU1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbWVsY2FzZVN1ZmZpeCAgPSBzcGxpdFBhdGgubWFwICh0aGlzLmNhcGl0YWxpemUpLmpvaW4gKCcnKVxuICAgICAgICAgICAgICAgICAgICBsZXQgdW5kZXJzY29yZVN1ZmZpeCA9IHNwbGl0UGF0aC5tYXAgKHggPT4geC50cmltICgpLnRvTG93ZXJDYXNlICgpKS5maWx0ZXIgKHggPT4geC5sZW5ndGggPiAwKS5qb2luICgnXycpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbWVsY2FzZVN1ZmZpeC5pbmRleE9mIChjYW1lbGNhc2VNZXRob2QpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWxjYXNlU3VmZml4ID0gY2FtZWxjYXNlU3VmZml4LnNsaWNlIChjYW1lbGNhc2VNZXRob2QubGVuZ3RoKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmRlcnNjb3JlU3VmZml4LmluZGV4T2YgKGxvd2VyY2FzZU1ldGhvZCkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlcnNjb3JlU3VmZml4ID0gdW5kZXJzY29yZVN1ZmZpeC5zbGljZSAobG93ZXJjYXNlTWV0aG9kLmxlbmd0aClcblxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FtZWxjYXNlICA9IHR5cGUgKyBjYW1lbGNhc2VNZXRob2QgKyB0aGlzLmNhcGl0YWxpemUgKGNhbWVsY2FzZVN1ZmZpeClcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuZGVyc2NvcmUgPSB0eXBlICsgJ18nICsgbG93ZXJjYXNlTWV0aG9kICsgJ18nICsgdW5kZXJzY29yZVN1ZmZpeFxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgnc3VmZml4ZXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnY2FtZWxjYXNlJyBpbiBvcHRpb25zWydzdWZmaXhlcyddKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVsY2FzZSArPSBvcHRpb25zWydzdWZmaXhlcyddWydjYW1lbGNhc2UnXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCd1bmRlcnNjb3JlJyBpbiBvcHRpb25zLnN1ZmZpeGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVyc2NvcmUgKz0gb3B0aW9uc1snc3VmZml4ZXMnXVsndW5kZXJzY29yZSddXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3VuZGVyc2NvcmVfc3VmZml4JyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJzY29yZSArPSBvcHRpb25zLnVuZGVyc2NvcmVTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2FtZWxjYXNlX3N1ZmZpeCcgaW4gb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVsY2FzZSArPSBvcHRpb25zLmNhbWVsY2FzZVN1ZmZpeDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGlhbCA9IGFzeW5jIHBhcmFtcyA9PiB0aGlzW21ldGhvZE5hbWVdICh1cmwsIHR5cGUsIHVwcGVyY2FzZU1ldGhvZCwgcGFyYW1zIHx8IHt9KVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbY2FtZWxjYXNlXSAgPSBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbdW5kZXJzY29yZV0gPSBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmV0Y2ggKHVybCwgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICBpZiAoaXNOb2RlICYmIHRoaXMudXNlckFnZW50KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudXNlckFnZW50ID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBleHRlbmQgKHsgJ1VzZXItQWdlbnQnOiB0aGlzLnVzZXJBZ2VudCB9LCBoZWFkZXJzKVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiB0aGlzLnVzZXJBZ2VudCA9PSAnb2JqZWN0JykgJiYgKCdVc2VyLUFnZW50JyBpbiB0aGlzLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IGV4dGVuZCAodGhpcy51c2VyQWdlbnQsIGhlYWRlcnMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJveHkgPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICB1cmwgPSB0aGlzLnByb3h5ICh1cmwpXG4gICAgICAgICAgICBoZWFkZXJzID0gZXh0ZW5kICh7ICdPcmlnaW4nOiAnKicgfSwgaGVhZGVycylcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnByb3h5ID09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3h5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gZXh0ZW5kICh7ICdPcmlnaW4nOiAnKicgfSwgaGVhZGVycylcblxuICAgICAgICAgICAgdXJsID0gdGhpcy5wcm94eSArIHVybFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nICh0aGlzLmlkLCBtZXRob2QsIHVybCwgXCJcXG5SZXF1ZXN0OlxcblwiLCBoZWFkZXJzLCBib2R5KVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXN0UmVxdWVzdCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpXG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2gyIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUmF0ZUxpbWl0KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy50aHJvdHRsZSAoKVxuXG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5zaWduIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCAocmVxdWVzdC51cmwsIHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmhlYWRlcnMsIHJlcXVlc3QuYm9keSlcbiAgICB9XG5cbiAgICByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSlcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIG1lXG4gICAgfVxuXG4gICAgZGVmYXVsdEVycm9ySGFuZGxlciAoY29kZSwgcmVhc29uLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlKVxuICAgICAgICAgICAgY29uc29sZS5sb2cgKHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGJvZHkgPyAoXCJcXG5SZXNwb25zZTpcXG5cIiArIGJvZHkpIDogJycpXG4gICAgICAgIGlmICgoY29kZSA+PSAyMDApICYmIChjb2RlIDw9IDMwMCkpXG4gICAgICAgICAgICByZXR1cm4gYm9keVxuICAgICAgICBsZXQgZXJyb3IgPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UgPSBib2R5XG4gICAgICAgIGxldCBkZXRhaWxzID0gYm9keVxuICAgICAgICBsZXQgbWF0Y2ggPSBib2R5Lm1hdGNoICgnXFw8dGl0bGVcXD4oW148XSspJylcbiAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgZGV0YWlscyA9IG1hdGNoWzFdLnRyaW0gKCk7XG4gICAgICAgIGlmIChbIDQyOSBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBERG9TUHJvdGVjdGlvblxuICAgICAgICB9IGVsc2UgaWYgKFsgNDA0LCA0MDksIDQyMiwgNTAwLCA1MDEsIDUwMiwgNTIwLCA1MjEsIDUyMiwgNTI1IF0uaW5jbHVkZXMgKGNvZGUpKSB7XG4gICAgICAgICAgICBlcnJvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgIH0gZWxzZSBpZiAoWyA0MDAsIDQwMywgNDA1LCA1MDMsIDUzMCBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgbGV0IGRkb3NQcm90ZWN0aW9uID0gYm9keS5tYXRjaCAoL2Nsb3VkZmxhcmV8aW5jYXBzdWxhL2kpXG4gICAgICAgICAgICBpZiAoZGRvc1Byb3RlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgICAgICAgICBkZXRhaWxzICs9ICcgKHBvc3NpYmxlIHJlYXNvbnM6ICcgKyBbXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIEFQSSBrZXlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhZCBvciBvbGQgbm9uY2UnLFxuICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UgaXMgZG93biBvciBvZmZsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ29uIG1haW50ZW5hbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ0REb1MgcHJvdGVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdyYXRlLWxpbWl0aW5nJyxcbiAgICAgICAgICAgICAgICBdLmpvaW4gKCcsICcpICsgJyknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoWyA0MDgsIDUwNCBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBSZXF1ZXN0VGltZW91dFxuICAgICAgICB9IGVsc2UgaWYgKFsgNDAxLCA1MTEgXS5pbmNsdWRlcyAoY29kZSkpIHtcbiAgICAgICAgICAgIGVycm9yID0gQXV0aGVudGljYXRpb25FcnJvclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBFeGNoYW5nZUVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGRldGFpbHMgXS5qb2luICgnICcpKVxuICAgIH1cblxuICAgIGhhbmRsZVJlc3RFcnJvcnMgKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0ICgpLnRoZW4gKHRleHQgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gWyByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCB0ZXh0IF1cblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcnMgKC4uLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyICguLi5hcmdzKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGhhbmRsZVJlc3RSZXNwb25zZSAocmVzcG9uc2UsIHVybCwgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSA9IHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLmxhc3RfanNvbl9yZXNwb25zZSA9XG4gICAgICAgICAgICAgICAgKCh0eXBlb2YgcmVzcG9uc2UgPT0gJ3N0cmluZycpICYmIChyZXNwb25zZS5sZW5ndGggPiAxKSkgP1xuICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlIChyZXNwb25zZSkgOiByZXNwb25zZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdF9qc29uX3Jlc3BvbnNlXG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICBsZXQgbWFpbnRlbmFuY2UgPSByZXNwb25zZS5tYXRjaCAoL29mZmxpbmV8YnVzeXxyZXRyeXx3YWl0fHVuYXZhaWxhYmxlfG1haW50YWlufG1haW50ZW5hbmNlfG1haW50ZW5hbmNpbmcvaSlcbiAgICAgICAgICAgIGxldCBkZG9zUHJvdGVjdGlvbiA9IHJlc3BvbnNlLm1hdGNoICgvY2xvdWRmbGFyZXxpbmNhcHN1bGF8b3ZlcmxvYWQvaSlcblxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICdub3QgYWNjZXNzaWJsZSBmcm9tIHRoaXMgbG9jYXRpb24gYXQgdGhlIG1vbWVudCdcbiAgICAgICAgICAgICAgICBpZiAobWFpbnRlbmFuY2UpXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnb2ZmbGluZSwgb24gbWFpbnRlbmFuY2Ugb3IgdW5yZWFjaGFibGUgZnJvbSB0aGlzIGxvY2F0aW9uIGF0IHRoZSBtb21lbnQnXG4gICAgICAgICAgICAgICAgaWYgKGRkb3NQcm90ZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBkZXRhaWxzIF0uam9pbiAoJyAnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyAodGhpcy5pZCwgbWV0aG9kLCB1cmwsICdlcnJvcicsIGUsIFwicmVzcG9uc2UgYm9keTpcXG4nXCIgKyByZXNwb25zZSArIFwiJ1wiKVxuXG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRNYXJrZXRzIChtYXJrZXRzKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzIChtYXJrZXRzKS5tYXAgKG1hcmtldCA9PiBkZWVwRXh0ZW5kICh7XG4gICAgICAgICAgICAnbGltaXRzJzogdGhpcy5saW1pdHMsXG4gICAgICAgICAgICAncHJlY2lzaW9uJzogdGhpcy5wcmVjaXNpb24sXG4gICAgICAgIH0sIHRoaXMuZmVlc1sndHJhZGluZyddLCBtYXJrZXQpKVxuICAgICAgICB0aGlzLm1hcmtldHMgPSBkZWVwRXh0ZW5kICh0aGlzLm1hcmtldHMsIGluZGV4QnkgKHZhbHVlcywgJ3N5bWJvbCcpKVxuICAgICAgICB0aGlzLm1hcmtldHNCeUlkID0gaW5kZXhCeSAobWFya2V0cywgJ2lkJylcbiAgICAgICAgdGhpcy5tYXJrZXRzX2J5X2lkID0gdGhpcy5tYXJrZXRzQnlJZFxuICAgICAgICB0aGlzLnN5bWJvbHMgPSBPYmplY3Qua2V5cyAodGhpcy5tYXJrZXRzKS5zb3J0ICgpXG4gICAgICAgIHRoaXMuaWRzID0gT2JqZWN0LmtleXMgKHRoaXMubWFya2V0c19ieV9pZCkuc29ydCAoKVxuICAgICAgICBjb25zdCBiYXNlQ3VycmVuY2llcyA9XG4gICAgICAgICAgICB2YWx1ZXMuZmlsdGVyIChtYXJrZXQgPT4gJ2Jhc2UnIGluIG1hcmtldClcbiAgICAgICAgICAgICAgICAubWFwIChtYXJrZXQgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG1hcmtldC5iYXNlSWQgfHwgbWFya2V0LmJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IG1hcmtldC5iYXNlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICBjb25zdCBxdW90ZUN1cnJlbmNpZXMgPVxuICAgICAgICAgICAgdmFsdWVzLmZpbHRlciAobWFya2V0ID0+ICdxdW90ZScgaW4gbWFya2V0KVxuICAgICAgICAgICAgICAgIC5tYXAgKG1hcmtldCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBpZDogbWFya2V0LnF1b3RlSWQgfHwgbWFya2V0LnF1b3RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBtYXJrZXQucXVvdGUsXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgIGNvbnN0IGN1cnJlbmNpZXMgPSBzb3J0QnkgKGJhc2VDdXJyZW5jaWVzLmNvbmNhdCAocXVvdGVDdXJyZW5jaWVzKSwgJ2NvZGUnKVxuICAgICAgICB0aGlzLmN1cnJlbmNpZXMgPSBkZWVwRXh0ZW5kIChpbmRleEJ5IChjdXJyZW5jaWVzLCAnY29kZScpLCB0aGlzLmN1cnJlbmNpZXMgfHwge30pXG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtldHNcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkTWFya2V0cyAocmVsb2FkID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFyZWxvYWQgJiYgdGhpcy5tYXJrZXRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWFya2V0c0J5SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXJrZXRzICh0aGlzLm1hcmtldHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXRzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2V0cyA9IGF3YWl0IHRoaXMuZmV0Y2hNYXJrZXRzICgpXG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gdW5kZWZpbmVkXG4gICAgICAgIGlmICh0aGlzLmhhc0ZldGNoQ3VycmVuY2llcykge1xuICAgICAgICAgICAgY3VycmVuY2llcyA9IGF3YWl0IHRoaXMuZmV0Y2hDdXJyZW5jaWVzICgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFya2V0cyAobWFya2V0cywgY3VycmVuY2llcylcbiAgICB9XG5cbiAgICBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VycyBub3Qgc3VwcG9ydGVkIHlldCcpXG4gICAgfVxuXG4gICAgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlciBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGZldGNoT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9wZW5PcmRlcnMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoQ2xvc2VkT3JkZXJzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoTXlUcmFkZXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBmZXRjaEN1cnJlbmNpZXMgKCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaEN1cnJlbmNpZXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHJlc29sdmUgKHRoaXMubWFya2V0cykpXG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlclN0YXR1cyAoaWQsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgb3JkZXIgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXIgKGlkKVxuICAgICAgICByZXR1cm4gb3JkZXJbJ3N0YXR1cyddXG4gICAgfVxuXG4gICAgYWNjb3VudCAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZnJlZSc6IDAuMCxcbiAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3lcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdYQlQnKVxuICAgICAgICAgICAgcmV0dXJuICdCVEMnXG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQkNDJylcbiAgICAgICAgICAgIHJldHVybiAnQkNIJ1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RSSycpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnXG4gICAgICAgIHJldHVybiBjdXJyZW5jeVxuICAgIH1cblxuICAgIG1hcmtldCAoc3ltYm9sKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcmtldHMgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIG1hcmtldHMgbm90IGxvYWRlZCcpXG5cbiAgICAgICAgaWYgKCh0eXBlb2Ygc3ltYm9sID09PSAnc3RyaW5nJykgJiYgKHN5bWJvbCBpbiB0aGlzLm1hcmtldHMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFya2V0c1tzeW1ib2xdXG5cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGRvZXMgbm90IGhhdmUgbWFya2V0IHN5bWJvbCAnICsgc3ltYm9sKVxuICAgIH1cblxuICAgIG1hcmtldElkIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2V0IChzeW1ib2wpLmlkIHx8IHN5bWJvbFxuICAgIH1cblxuICAgIG1hcmtldElkcyAoc3ltYm9scykge1xuICAgICAgICByZXR1cm4gc3ltYm9scy5tYXAgKHN5bWJvbCA9PiB0aGlzLm1hcmtldElkKHN5bWJvbCkpO1xuICAgIH1cblxuICAgIHN5bWJvbCAoc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtldCAoc3ltYm9sKS5zeW1ib2wgfHwgc3ltYm9sXG4gICAgfVxuXG4gICAgZXh0cmFjdFBhcmFtcyAoc3RyaW5nKSB7XG4gICAgICAgIGxldCByZSA9IC97KFthLXpBLVowLTlfXSs/KX0vZ1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IFtdXG4gICAgICAgIGxldCBtYXRjaFxuICAgICAgICB3aGlsZSAobWF0Y2ggPSByZS5leGVjIChzdHJpbmcpKVxuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoIChtYXRjaFsxXSlcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICB9XG5cbiAgICBpbXBsb2RlUGFyYW1zIChzdHJpbmcsIHBhcmFtcykge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBwYXJhbXMpXG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSAoJ3snICsgcHJvcGVydHkgKyAnfScsIHBhcmFtc1twcm9wZXJ0eV0pXG4gICAgICAgIHJldHVybiBzdHJpbmdcbiAgICB9XG5cbiAgICB1cmwgKHBhdGgsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bHQgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgcGFyc2VCaWRBc2sgKGJpZGFzaywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAxKSB7XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKGJpZGFza1twcmljZUtleV0pXG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0IChiaWRhc2tbYW1vdW50S2V5XSlcbiAgICAgICAgcmV0dXJuIFsgcHJpY2UsIGFtb3VudCBdXG4gICAgfVxuXG4gICAgcGFyc2VCaWRzQXNrcyAoYmlkYXNrcywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAxKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzIChiaWRhc2tzIHx8IFtdKS5tYXAgKGJpZGFzayA9PiB0aGlzLnBhcnNlQmlkQXNrIChiaWRhc2ssIHByaWNlS2V5LCBhbW91bnRLZXkpKVxuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTDJPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zKVxuICAgICAgICByZXR1cm4gZXh0ZW5kIChvcmRlcmJvb2ssIHtcbiAgICAgICAgICAgICdiaWRzJzogc29ydEJ5IChhZ2dyZWdhdGUgKG9yZGVyYm9vay5iaWRzKSwgMCwgdHJ1ZSksXG4gICAgICAgICAgICAnYXNrcyc6IHNvcnRCeSAoYWdncmVnYXRlIChvcmRlcmJvb2suYXNrcyksIDApLFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCA9IHVuZGVmaW5lZCwgYmlkc0tleSA9ICdiaWRzJywgYXNrc0tleSA9ICdhc2tzJywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAxKSB7XG4gICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogKGJpZHNLZXkgaW4gb3JkZXJib29rKSA/IHRoaXMucGFyc2VCaWRzQXNrcyAob3JkZXJib29rW2JpZHNLZXldLCBwcmljZUtleSwgYW1vdW50S2V5KSA6IFtdLFxuICAgICAgICAgICAgJ2Fza3MnOiAoYXNrc0tleSBpbiBvcmRlcmJvb2spID8gdGhpcy5wYXJzZUJpZHNBc2tzIChvcmRlcmJvb2tbYXNrc0tleV0sIHByaWNlS2V5LCBhbW91bnRLZXkpIDogW10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEN1cnJlbmN5VXNlZE9uT3Blbk9yZGVycyAoY3VycmVuY3kpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMgKHRoaXMub3JkZXJzKS5maWx0ZXIgKG9yZGVyID0+IChvcmRlclsnc3RhdHVzJ10gPT0gJ29wZW4nKSkucmVkdWNlICgodG90YWwsIG9yZGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gb3JkZXJbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgbGV0IGFtb3VudCA9IG9yZGVyWydyZW1haW5pbmcnXVxuICAgICAgICAgICAgaWYgKGN1cnJlbmN5ID09IG1hcmtldFsnYmFzZSddICYmIG9yZGVyWydzaWRlJ10gPT0gJ3NlbGwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgYW1vdW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09IG1hcmtldFsncXVvdGUnXSAmJiBvcmRlclsnc2lkZSddID09ICdidXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgKG9yZGVyWydjb3N0J10gfHwgKG9yZGVyWydwcmljZSddICogYW1vdW50KSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgcGFyc2VCYWxhbmNlIChiYWxhbmNlKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLm9taXQgKGJhbGFuY2UsICdpbmZvJykpO1xuXG4gICAgICAgIGN1cnJlbmNpZXMuZm9yRWFjaCAoY3VycmVuY3kgPT4ge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJhbGFuY2VbY3VycmVuY3ldLnVzZWQgPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlQmFsYW5jZUZyb21PcGVuT3JkZXJzICYmICgnb3Blbl9vcmRlcnMnIGluIGJhbGFuY2VbJ2luZm8nXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjaGFuZ2VPcmRlcnNDb3VudCA9IGJhbGFuY2VbJ2luZm8nXVsnb3Blbl9vcmRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkT3JkZXJzQ291bnQgPSBPYmplY3QudmFsdWVzICh0aGlzLm9yZGVycykuZmlsdGVyIChvcmRlciA9PiAob3JkZXJbJ3N0YXR1cyddID09ICdvcGVuJykpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9yZGVyc0NvdW50ID09IGV4Y2hhbmdlT3JkZXJzQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbY3VycmVuY3ldLnVzZWQgPSB0aGlzLmdldEN1cnJlbmN5VXNlZE9uT3Blbk9yZGVycyAoY3VycmVuY3kpXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW2N1cnJlbmN5XS50b3RhbCA9IGJhbGFuY2VbY3VycmVuY3ldLnVzZWQgKyBiYWxhbmNlW2N1cnJlbmN5XS5mcmVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW2N1cnJlbmN5XS51c2VkID0gdGhpcy5nZXRDdXJyZW5jeVVzZWRPbk9wZW5PcmRlcnMgKGN1cnJlbmN5KVxuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW2N1cnJlbmN5XS50b3RhbCA9IGJhbGFuY2VbY3VycmVuY3ldLnVzZWQgKyBiYWxhbmNlW2N1cnJlbmN5XS5mcmVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBbICdmcmVlJywgJ3VzZWQnLCAndG90YWwnIF0uZm9yRWFjaCAoYWNjb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgYmFsYW5jZVthY2NvdW50XSA9IGJhbGFuY2VbYWNjb3VudF0gfHwge31cbiAgICAgICAgICAgICAgICBiYWxhbmNlW2FjY291bnRdW2N1cnJlbmN5XSA9IGJhbGFuY2VbY3VycmVuY3ldW2FjY291bnRdXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gYmFsYW5jZTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFBhcnRpYWxCYWxhbmNlIChwYXJ0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IHRoaXMuZmV0Y2hCYWxhbmNlIChwYXJhbXMpXG4gICAgICAgIHJldHVybiBiYWxhbmNlW3BhcnRdXG4gICAgfVxuXG4gICAgZmV0Y2hGcmVlQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hQYXJ0aWFsQmFsYW5jZSAoJ2ZyZWUnLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgZmV0Y2hVc2VkQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hQYXJ0aWFsQmFsYW5jZSAoJ3VzZWQnLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgZmV0Y2hUb3RhbEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoUGFydGlhbEJhbGFuY2UgKCd0b3RhbCcsIHBhcmFtcylcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMgKHRyYWRlcykubWFwICh0cmFkZSA9PiB0aGlzLnBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpKVxuICAgIH1cblxuICAgIHBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyAob3JkZXJzKS5tYXAgKG9yZGVyID0+IHRoaXMucGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCkpXG4gICAgfVxuXG4gICAgZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBncm91cGVkID0gdGhpcy5ncm91cEJ5IChvcmRlcnMsICdzeW1ib2wnKVxuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIGdyb3VwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRbc3ltYm9sXVxuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yZGVyc1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2hsY3ZcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWcyAob2hsY3ZzLCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBvaGxjdnMgPSBPYmplY3QudmFsdWVzIChvaGxjdnMpXG4gICAgICAgIGxldCByZXN1bHQgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9obGN2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbWl0ICYmIChyZXN1bHQubGVuZ3RoID49IGxpbWl0KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvaGxjdiA9IHRoaXMucGFyc2VPSExDViAob2hsY3ZzW2ldLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KVxuICAgICAgICAgICAgaWYgKHNpbmNlICYmIChvaGxjdlswXSA8IHNpbmNlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9obGN2KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBlZGl0TGltaXRCdXlPcmRlciAoaWQsIHN5bWJvbCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0TGltaXRPcmRlciAoaWQsIHN5bWJvbCwgJ2J1eScsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgZWRpdExpbWl0U2VsbE9yZGVyIChpZCwgc3ltYm9sLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRMaW1pdE9yZGVyIChpZCwgc3ltYm9sLCAnc2VsbCcsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgZWRpdExpbWl0T3JkZXIgKGlkLCBzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdE9yZGVyIChpZCwgc3ltYm9sLCAnbGltaXQnLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGFzeW5jIGVkaXRPcmRlciAoaWQsIHN5bWJvbCwgLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUmF0ZUxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGVkaXRPcmRlcigpIHJlcXVpcmVzIGVuYWJsZVJhdGVMaW1pdCA9IHRydWUnKVxuICAgICAgICBhd2FpdCB0aGlzLmNhbmNlbE9yZGVyIChpZCwgc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgLi4uYXJncylcbiAgICB9XG5cbiAgICBjcmVhdGVMaW1pdEJ1eU9yZGVyIChzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgIChzeW1ib2wsICdsaW1pdCcsICdidXknLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGNyZWF0ZUxpbWl0U2VsbE9yZGVyIChzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ2xpbWl0JywgJ3NlbGwnLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGNyZWF0ZU1hcmtldEJ1eU9yZGVyIChzeW1ib2wsIGFtb3VudCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ21hcmtldCcsICdidXknLCBhbW91bnQsIHVuZGVmaW5lZCwgcGFyYW1zKVxuICAgIH1cblxuICAgIGNyZWF0ZU1hcmtldFNlbGxPcmRlciAoc3ltYm9sLCBhbW91bnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yZGVyIChzeW1ib2wsICdtYXJrZXQnLCAnc2VsbCcsIGFtb3VudCwgdW5kZWZpbmVkLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgY29zdFRvUHJlY2lzaW9uIChzeW1ib2wsIGNvc3QpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKGNvc3QpLnRvRml4ZWQgKHRoaXMubWFya2V0c1tzeW1ib2xdLnByZWNpc2lvbi5wcmljZSlcbiAgICB9XG5cbiAgICBwcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0IChwcmljZSkudG9GaXhlZCAodGhpcy5tYXJrZXRzW3N5bWJvbF0ucHJlY2lzaW9uLnByaWNlKVxuICAgIH1cblxuICAgIGFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZShhbW91bnQsIHRoaXMubWFya2V0c1tzeW1ib2xdLnByZWNpc2lvbi5hbW91bnQpXG4gICAgfVxuXG4gICAgYW1vdW50VG9Mb3RzIChzeW1ib2wsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBNYXRoLmZsb29yIChhbW91bnQgLyB0aGlzLm1hcmtldHNbc3ltYm9sXS5sb3QpICogdGhpcy5tYXJrZXRzW3N5bWJvbF0ubG90KVxuICAgIH1cblxuICAgIGZlZVRvUHJlY2lzaW9uIChzeW1ib2wsIGZlZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCAoZmVlKS50b0ZpeGVkICh0aGlzLm1hcmtldHNbc3ltYm9sXS5wcmVjaXNpb24ucHJpY2UpXG4gICAgfVxuXG4gICAgY2FsY3VsYXRlRmVlIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UsIHRha2VyT3JNYWtlciA9ICd0YWtlcicsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXVxuICAgICAgICBsZXQgcmF0ZSA9IG1hcmtldFt0YWtlck9yTWFrZXJdXG4gICAgICAgIGxldCBjb3N0ID0gcGFyc2VGbG9hdCAodGhpcy5jb3N0VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50ICogcHJpY2UpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAncmF0ZSc6IHJhdGUsXG4gICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKHRoaXMuZmVlVG9QcmVjaXNpb24gKHN5bWJvbCwgcmF0ZSAqIGNvc3QpKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFltZCAodGltZXN0YW1wLCBpbmZpeCA9ICcgJykge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlICh0aW1lc3RhbXApXG4gICAgICAgIGxldCBZID0gZGF0ZS5nZXRVVENGdWxsWWVhciAoKVxuICAgICAgICBsZXQgbSA9IGRhdGUuZ2V0VVRDTW9udGggKCkgKyAxXG4gICAgICAgIGxldCBkID0gZGF0ZS5nZXRVVENEYXRlICgpXG4gICAgICAgIG0gPSBtIDwgMTAgPyAoJzAnICsgbSkgOiBtXG4gICAgICAgIGQgPSBkIDwgMTAgPyAoJzAnICsgZCkgOiBkXG4gICAgICAgIHJldHVybiBZICsgJy0nICsgbSArICctJyArIGRcbiAgICB9XG5cbiAgICBZbWRITVMgKHRpbWVzdGFtcCwgaW5maXggPSAnICcpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSAodGltZXN0YW1wKVxuICAgICAgICBsZXQgWSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIgKClcbiAgICAgICAgbGV0IG0gPSBkYXRlLmdldFVUQ01vbnRoICgpICsgMVxuICAgICAgICBsZXQgZCA9IGRhdGUuZ2V0VVRDRGF0ZSAoKVxuICAgICAgICBsZXQgSCA9IGRhdGUuZ2V0VVRDSG91cnMgKClcbiAgICAgICAgbGV0IE0gPSBkYXRlLmdldFVUQ01pbnV0ZXMgKClcbiAgICAgICAgbGV0IFMgPSBkYXRlLmdldFVUQ1NlY29uZHMgKClcbiAgICAgICAgbSA9IG0gPCAxMCA/ICgnMCcgKyBtKSA6IG1cbiAgICAgICAgZCA9IGQgPCAxMCA/ICgnMCcgKyBkKSA6IGRcbiAgICAgICAgSCA9IEggPCAxMCA/ICgnMCcgKyBIKSA6IEhcbiAgICAgICAgTSA9IE0gPCAxMCA/ICgnMCcgKyBNKSA6IE1cbiAgICAgICAgUyA9IFMgPCAxMCA/ICgnMCcgKyBTKSA6IFNcbiAgICAgICAgcmV0dXJuIFkgKyAnLScgKyBtICsgJy0nICsgZCArIGluZml4ICsgSCArICc6JyArIE0gKyAnOicgKyBTXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWFya2V0IHtcblxuICAgIGNvbnN0cnVjdG9yIChleGNoYW5nZSwgc3ltYm9sKSB7XG4gICAgICAgIHRoaXMuZXhjaGFuZ2UgPSBleGNoYW5nZTtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubWFya2V0ID0gZXhjaGFuZ2UubWFya2V0c1tzeW1ib2xdO1xuICAgIH1cblxuICAgIGFtb3VudFRvUHJlY2lzaW9uIChhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjaGFuZ2UuYW1vdW50VG9QcmVjaXNpb24gKHRoaXMuc3ltYm9sLCBhbW91bnQpXG4gICAgfVxuXG4gICAgY3JlYXRlTGltaXRCdXlPcmRlcihhbW91bnQsIHByaWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2hhbmdlLmNyZWF0ZUxpbWl0QnV5T3JkZXIgKHRoaXMuc3ltYm9sLCBhbW91bnQsIHByaWNlKVxuICAgIH1cblxuICAgIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKGFtb3VudCwgcHJpY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjaGFuZ2UuY3JlYXRlTGltaXRTZWxsT3JkZXIgKHRoaXMuc3ltYm9sLCBhbW91bnQsIHByaWNlKVxuICAgIH1cbn1cbiIsImNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgLy8gYSB3b3JrYXJvdW5kIHRvIG1ha2UgYGluc3RhbmNlb2YgQmFzZUVycm9yYCB3b3JrIGluIEVTNVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQmFzZUVycm9yXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBCYXNlRXJyb3IucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBFeGNoYW5nZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEV4Y2hhbmdlRXJyb3JcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEV4Y2hhbmdlRXJyb3IucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWQgZXh0ZW5kcyBFeGNoYW5nZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IE5vdFN1cHBvcnRlZFxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gTm90U3VwcG9ydGVkLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQXV0aGVudGljYXRpb25FcnJvclxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gQXV0aGVudGljYXRpb25FcnJvci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEludmFsaWROb25jZSBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gSW52YWxpZE5vbmNlXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBJbnZhbGlkTm9uY2UucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBJbnN1ZmZpY2llbnRGdW5kcyBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gSW5zdWZmaWNpZW50RnVuZHNcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEluc3VmZmljaWVudEZ1bmRzLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgSW52YWxpZE9yZGVyIGV4dGVuZHMgRXhjaGFuZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBJbnZhbGlkT3JkZXJcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEludmFsaWRPcmRlci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE9yZGVyTm90Rm91bmQgZXh0ZW5kcyBJbnZhbGlkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gT3JkZXJOb3RGb3VuZFxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gT3JkZXJOb3RGb3VuZC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE9yZGVyTm90Q2FjaGVkIGV4dGVuZHMgSW52YWxpZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IE9yZGVyTm90Q2FjaGVkXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBPcmRlck5vdENhY2hlZC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIENhbmNlbFBlbmRpbmcgZXh0ZW5kcyBJbnZhbGlkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2FuY2VsUGVuZGluZ1xuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gQ2FuY2VsUGVuZGluZy5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBOZXR3b3JrRXJyb3JcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IE5ldHdvcmtFcnJvci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEREb1NQcm90ZWN0aW9uIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBERG9TUHJvdGVjdGlvbi5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIFJlcXVlc3RUaW1lb3V0IGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IFJlcXVlc3RUaW1lb3V0XG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBSZXF1ZXN0VGltZW91dC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEV4Y2hhbmdlTm90QXZhaWxhYmxlIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBFeGNoYW5nZU5vdEF2YWlsYWJsZS5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQmFzZUVycm9yLFxuICAgIEV4Y2hhbmdlRXJyb3IsXG4gICAgTm90U3VwcG9ydGVkLFxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gICAgSW52YWxpZE5vbmNlLFxuICAgIEluc3VmZmljaWVudEZ1bmRzLFxuICAgIEludmFsaWRPcmRlcixcbiAgICBPcmRlck5vdEZvdW5kLFxuICAgIE9yZGVyTm90Q2FjaGVkLFxuICAgIENhbmNlbFBlbmRpbmcsXG4gICAgTmV0d29ya0Vycm9yLFxuICAgIEREb1NQcm90ZWN0aW9uLFxuICAgIFJlcXVlc3RUaW1lb3V0LFxuICAgIEV4Y2hhbmdlTm90QXZhaWxhYmxlLFxufSIsIlwidXNlIHN0cmljdFwiO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IENyeXB0b0pTID0gcmVxdWlyZSAoJ2NyeXB0by1qcycpXG4gICAgLCBxcyAgICAgICA9IHJlcXVpcmUgKCdxcycpIC8vIHF1ZXJ5c3RyaW5nXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgeyBSZXF1ZXN0VGltZW91dCB9ID0gcmVxdWlyZSAoJy4vZXJyb3JzJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdXRpbGl0eSBoZWxwZXJzXG5cbmNvbnN0IHNldFRpbWVvdXRfc2FmZSA9IChkb25lLCBtcywgdGFyZ2V0VGltZSA9IERhdGUubm93ICgpICsgbXMpID0+IHsgLy8gc2V0VGltZW91dCBjYW4gZmlyZSBlYXJsaWVyIHRoYW4gc3BlY2lmaWVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCBkb2VzIG5vdCBoYXBwZW4uLi5cblxuICAgIHNldFRpbWVvdXQgKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdCA9IHRhcmdldFRpbWUgLSBEYXRlLm5vdyAoKVxuICAgICAgICBpZiAocmVzdCA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXRfc2FmZSAoZG9uZSwgcmVzdCwgdGFyZ2V0VGltZSkgLy8gdHJ5IHNsZWVwIG1vcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgKClcbiAgICAgICAgfVxuICAgIH0sIG1zKVxufVxuXG5jb25zdCBzbGVlcCA9IG1zID0+IG5ldyBQcm9taXNlIChyZXNvbHZlID0+IHNldFRpbWVvdXRfc2FmZSAocmVzb2x2ZSwgbXMpKVxuXG5jb25zdCBkZWNpbWFsID0gZmxvYXQgPT4gcGFyc2VGbG9hdCAoZmxvYXQpLnRvU3RyaW5nICgpXG5cbmNvbnN0IHRpbWVvdXQgPSAobXMsIHByb21pc2UpID0+XG4gICAgICAgIFByb21pc2UucmFjZSAoW1xuICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgIHNsZWVwIChtcykudGhlbiAoKCkgPT4geyB0aHJvdyBuZXcgUmVxdWVzdFRpbWVvdXQgKCdyZXF1ZXN0IHRpbWVkIG91dCcpIH0pXG4gICAgICAgIF0pXG5cbmNvbnN0IGNhcGl0YWxpemUgPSBzdHJpbmcgPT4gc3RyaW5nLmxlbmd0aCA/IChzdHJpbmcuY2hhckF0ICgwKS50b1VwcGVyQ2FzZSAoKSArIHN0cmluZy5zbGljZSAoMSkpIDogc3RyaW5nXG5cbmNvbnN0IGtleXNvcnQgPSBvYmplY3QgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgT2JqZWN0LmtleXMgKG9iamVjdCkuc29ydCAoKS5mb3JFYWNoIChrZXkgPT4gcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XSlcbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGV4dGVuZCA9ICguLi5hcmdzKSA9PiBPYmplY3QuYXNzaWduICh7fSwgLi4uYXJncylcblxuY29uc3QgZGVlcEV4dGVuZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAvLyBpZiAoYXJncy5sZW5ndGggPCAxKVxuICAgIC8vICAgICByZXR1cm4gYXJnc1xuICAgIC8vIGVsc2UgaWYgKGFyZ3MubGVuZ3RoIDwgMilcbiAgICAvLyAgICAgcmV0dXJuIGFyZ3NbMF1cblxuICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWRcblxuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcblxuICAgICAgICBpZiAoYXJnICYmICh0eXBlb2YgYXJnID09ICdvYmplY3QnKSAmJiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgISgnY29uc3RydWN0b3InIGluIGFyZykpKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwRXh0ZW5kIChyZXN1bHRba2V5XSwgYXJnW2tleV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IG9taXQgPSAob2JqZWN0LCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXh0ZW5kIChvYmplY3QpXG4gICAgZm9yIChjb25zdCB4IG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFt4XVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkgKHgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgeClcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tdXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBncm91cEJ5ID0gKGFycmF5LCBrZXkpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fVxuICAgIE9iamVjdFxuICAgICAgICAudmFsdWVzIChhcnJheSlcbiAgICAgICAgLmZpbHRlciAoZW50cnkgPT4gZW50cnlba2V5XSAhPSAndW5kZWZpbmVkJylcbiAgICAgICAgLmZvckVhY2ggKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2VudHJ5W2tleV1dID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtlbnRyeVtrZXldXSA9IFtdXG4gICAgICAgICAgICByZXN1bHRbZW50cnlba2V5XV0ucHVzaCAoZW50cnkpXG4gICAgICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBmaWx0ZXJCeSA9IChhcnJheSwga2V5LCB2YWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBsZXQgZ3JvdXBlZCA9IGdyb3VwQnkgKGFycmF5LCBrZXkpXG4gICAgICAgIGlmICh2YWx1ZSBpbiBncm91cGVkKVxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRbdmFsdWVdXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbn1cblxuY29uc3QgaW5kZXhCeSA9IChhcnJheSwga2V5KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge31cbiAgICBPYmplY3RcbiAgICAgICAgLnZhbHVlcyAoYXJyYXkpXG4gICAgICAgIC5maWx0ZXIgKGVudHJ5ID0+IGVudHJ5W2tleV0gIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIC5mb3JFYWNoIChlbnRyeSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbZW50cnlba2V5XV0gPSBlbnRyeVxuICAgICAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuY29uc3Qgc29ydEJ5ID0gKGFycmF5LCBrZXksIGRlc2NlbmRpbmcgPSBmYWxzZSkgPT4ge1xuICAgIGRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nID8gLTEgOiAxXG4gICAgcmV0dXJuIGFycmF5LnNvcnQgKChhLCBiKSA9PiAoKGFba2V5XSA8IGJba2V5XSkgPyAtZGVzY2VuZGluZyA6ICgoYVtrZXldID4gYltrZXldKSA/IGRlc2NlbmRpbmcgOiAwKSkpXG59XG5cbmNvbnN0IGZsYXR0ZW4gPSAoYXJyYXksIHJlc3VsdCA9IFtdKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkgKHZhbHVlKSkge1xuICAgICAgICAgICAgZmxhdHRlbiAodmFsdWUsIHJlc3VsdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IHVuaXF1ZSA9IGFycmF5ID0+IGFycmF5LmZpbHRlciAoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gKHNlbGYuaW5kZXhPZiAodmFsdWUpID09IGluZGV4KSlcblxuY29uc3QgcGx1Y2sgPSAoYXJyYXksIGtleSkgPT4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlciAoZWxlbWVudCA9PiAodHlwZW9mIGVsZW1lbnRba2V5XSAhPSAndW5kZWZpbmVkJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAgKGVsZW1lbnQgPT4gZWxlbWVudFtrZXldKVxuXG5jb25zdCB1cmxlbmNvZGUgPSBvYmplY3QgPT4gcXMuc3RyaW5naWZ5IChvYmplY3QpXG5jb25zdCByYXdlbmNvZGUgPSBvYmplY3QgPT4gcXMuc3RyaW5naWZ5IChvYmplY3QsIHsgZW5jb2RlOiBmYWxzZSB9KVxuXG5jb25zdCBzdW0gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGFyZ3MuZmlsdGVyIChhcmcgPT4gdHlwZW9mIGFyZyAhPSAndW5kZWZpbmVkJylcbiAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPiAwKSA/XG4gICAgICAgIHJlc3VsdC5yZWR1Y2UgKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgOiB1bmRlZmluZWRcbn1cblxuY29uc3Qgc2FmZUZsb2F0ID0gKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpID0+IHtcbiAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtrZXldID09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlb2Ygb2JqZWN0W2tleV0gPT0gJ3N0cmluZycpICYmIG9iamVjdFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKG9iamVjdFtrZXldKVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlXG59XG5cbmNvbnN0IHNhZmVTdHJpbmcgPSAob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiAob2JqZWN0ICYmIChrZXkgaW4gb2JqZWN0KSAmJiBvYmplY3Rba2V5XSkgPyBvYmplY3Rba2V5XS50b1N0cmluZyAoKSA6IGRlZmF1bHRWYWx1ZVxufVxuXG5jb25zdCBzYWZlSW50ZWdlciA9IChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgcmV0dXJuICgoa2V5IGluIG9iamVjdCkgJiYgb2JqZWN0W2tleV0pID8gcGFyc2VJbnQgKG9iamVjdFtrZXldKSA6IGRlZmF1bHRWYWx1ZVxufVxuXG5jb25zdCBzYWZlVmFsdWUgPSAob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiAoKGtleSBpbiBvYmplY3QpICYmIG9iamVjdFtrZXldKSA/IG9iamVjdFtrZXldIDogZGVmYXVsdFZhbHVlXG59XG5cbmNvbnN0IHV1aWQgPSBhID0+IGEgP1xuICAgIChhIF4gTWF0aC5yYW5kb20gKCkgKiAxNiA+PiBhIC8gNCkudG9TdHJpbmcgKDE2KSA6XG4gICAgKFsxZTddKy0xZTMrLTRlMystOGUzKy0xZTExKS5yZXBsYWNlICgvWzAxOF0vZywgdXVpZClcblxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2ODU2ODAvaG93LXRvLWF2b2lkLXNjaWVudGlmaWMtbm90YXRpb24tZm9yLWxhcmdlLW51bWJlcnMtaW4tamF2YXNjcmlwdCBmb3IgZGlzY3Vzc2lvblxuXG5mdW5jdGlvbiB0b0ZpeGVkICh4KSB7IC8vIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gZm9yIHRvbyBsYXJnZSBhbmQgdG9vIHNtYWxsIG51bWJlcnNcblxuICAgIGlmIChNYXRoLmFicyAoeCkgPCAxLjApIHtcbiAgICAgICAgY29uc3QgZSA9IHBhcnNlSW50ICh4LnRvU3RyaW5nICgpLnNwbGl0ICgnZS0nKVsxXSlcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHggKj0gTWF0aC5wb3cgKDEwLCBlLTEpXG4gICAgICAgICAgICB4ID0gJzAuJyArIChuZXcgQXJyYXkgKGUpKS5qb2luICgnMCcpICsgeC50b1N0cmluZyAoKS5zdWJzdHJpbmcgKDIpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZSA9IHBhcnNlSW50ICh4LnRvU3RyaW5nICgpLnNwbGl0ICgnKycpWzFdKVxuICAgICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgICAgICBlIC09IDIwXG4gICAgICAgICAgICB4IC89IE1hdGgucG93ICgxMCwgZSlcbiAgICAgICAgICAgIHggKz0gKG5ldyBBcnJheSAoZSsxKSkuam9pbiAoJzAnKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4XG59XG5cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTEyNzg4L3RydW5jYXRlLW5vdC1yb3VuZC1vZmYtZGVjaW1hbC1udW1iZXJzLWluLWphdmFzY3JpcHQgZm9yIGRpc2N1c3Npb25cblxuLy8gPiBTbywgYWZ0ZXIgYWxsIGl0IHR1cm5lZCBvdXQsIHJvdW5kaW5nIGJ1Z3Mgd2lsbCBhbHdheXMgaGF1bnQgeW91LCBubyBtYXR0ZXIgaG93IGhhcmQgeW91IHRyeSB0byBjb21wZW5zYXRlIHRoZW0uXG4vLyA+IEhlbmNlIHRoZSBwcm9ibGVtIHNob3VsZCBiZSBhdHRhY2tlZCBieSByZXByZXNlbnRpbmcgbnVtYmVycyBleGFjdGx5IGluIGRlY2ltYWwgbm90YXRpb24uXG5cbmNvbnN0IHRydW5jYXRlX3JlZ0V4cENhY2hlID0gW11cbiAgICAsIHRydW5jYXRlID0gKG51bSwgcHJlY2lzaW9uID0gMCkgPT4ge1xuICAgICAgICBudW0gPSB0b0ZpeGVkIChudW0pXG4gICAgICAgIGNvbnN0IHJlID0gdHJ1bmNhdGVfcmVnRXhwQ2FjaGVbcHJlY2lzaW9uXSB8fCAodHJ1bmNhdGVfcmVnRXhwQ2FjaGVbcHJlY2lzaW9uXSA9IG5ldyBSZWdFeHAoXCIoWy1dKlxcXFxkK1xcXFwuXFxcXGR7XCIgKyBwcmVjaXNpb24gKyBcIn0pKFxcXFxkKVwiKSlcbiAgICAgICAgY29uc3QgWyxyZXN1bHRdID0gbnVtLnRvU3RyaW5nICgpLm1hdGNoIChyZSkgfHwgW251bGwsIG51bV1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKHJlc3VsdClcbiAgICB9XG5cbmNvbnN0IHByZWNpc2lvbkZyb21TdHJpbmcgPSAoc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc3BsaXQgPSBzdHJpbmcucmVwbGFjZSAoLzArJC9nLCAnJykuc3BsaXQgKCcuJylcbiAgICByZXR1cm4gKHNwbGl0Lmxlbmd0aCA+IDEpID8gKHNwbGl0WzFdLmxlbmd0aCkgOiAwXG59XG5cbmNvbnN0IG9yZGVyZWQgPSB4ID0+IHggLy8gYSBzdHViIHRvIGtlZXAgYXNzb2Mga2V5cyBpbiBvcmRlciwgaW4gSlMgaXQgZG9lcyBub3RoaW5nLCBpdCdzIG1vc3RseSBmb3IgUHl0aG9uXG5cbmNvbnN0IGFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIChiaWRhc2tzKSB7XG5cbiAgICBsZXQgcmVzdWx0ID0ge31cblxuICAgIGJpZGFza3MuZm9yRWFjaCAoKFsgcHJpY2UsIHZvbHVtZSBdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtwcmljZV0gPSAocmVzdWx0W3ByaWNlXSB8fCAwKSArIHZvbHVtZVxuICAgIH0pXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMgKHJlc3VsdCkubWFwIChwcmljZSA9PiBbXG4gICAgICAgIHBhcnNlRmxvYXQgKHByaWNlKSxcbiAgICAgICAgcGFyc2VGbG9hdCAocmVzdWx0W3ByaWNlXSksXG4gICAgXSlcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RyaW5nIOKGkOKGkiBiaW5hcnkg4oaQ4oaSIGJhc2U2NCBjb252ZXJzaW9uIHJvdXRpbmVzXG5cbmNvbnN0IHN0cmluZ1RvQmluYXJ5ID0gc3RyID0+IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSAoc3RyLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykgeyBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsgfVxuICAgIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSAoYXJyKVxufVxuXG5jb25zdCBzdHJpbmdUb0Jhc2U2NCA9IHN0cmluZyA9PiBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlIChzdHJpbmcpLnRvU3RyaW5nIChDcnlwdG9KUy5lbmMuQmFzZTY0KVxuICAgICwgdXRmMTZUb0Jhc2U2NCAgPSBzdHJpbmcgPT4gQ3J5cHRvSlMuZW5jLlV0ZjE2IC5wYXJzZSAoc3RyaW5nKS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jLkJhc2U2NClcbiAgICAsIGJhc2U2NFRvQmluYXJ5ID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZylcbiAgICAsIGJhc2U2NFRvU3RyaW5nID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZykudG9TdHJpbmcgKENyeXB0b0pTLmVuYy5VdGY4KVxuICAgICwgYmluYXJ5VG9TdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nXG5cbmNvbnN0IGJpbmFyeUNvbmNhdCA9ICguLi5hcmdzKSA9PiBhcmdzLnJlZHVjZSAoKGEsIGIpID0+IGEuY29uY2F0IChiKSlcblxuLy8gdXJsLXNhZmUtYmFzZTY0IHdpdGhvdXQgZXF1YWxzIHNpZ25zLCB3aXRoICsgcmVwbGFjZWQgYnkgLSBhbmQgc2xhc2hlcyByZXBsYWNlZCBieSB1bmRlcnNjb3Jlc1xuY29uc3QgdXJsZW5jb2RlQmFzZTY0ID0gYmFzZTY0c3RyaW5nID0+IGJhc2U2NHN0cmluZy5yZXBsYWNlICgvWz1dKyQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSAoL1xcKy9nLCAnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UgKC9cXC8vZywgJ18nKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjcnlwdG9ncmFwaHlcblxuY29uc3QgaGFzaCA9IChyZXF1ZXN0LCBoYXNoID0gJ21kNScsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gQ3J5cHRvSlNbaGFzaC50b1VwcGVyQ2FzZSAoKV0gKHJlcXVlc3QpXG4gICAgcmV0dXJuIChkaWdlc3QgPT0gJ2JpbmFyeScpID8gcmVzdWx0IDogcmVzdWx0LnRvU3RyaW5nIChDcnlwdG9KUy5lbmNbY2FwaXRhbGl6ZSAoZGlnZXN0KV0pXG59XG5cbmNvbnN0IGhtYWMgPSAocmVxdWVzdCwgc2VjcmV0LCBoYXNoID0gJ3NoYTI1NicsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSAoZGlnZXN0ID09ICdiaW5hcnknKSA/ICdMYXRpbjEnIDogY2FwaXRhbGl6ZSAoZGlnZXN0KVxuICAgIHJldHVybiBDcnlwdG9KU1snSG1hYycgKyBoYXNoLnRvVXBwZXJDYXNlICgpXSAocmVxdWVzdCwgc2VjcmV0KS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jW2NhcGl0YWxpemUgKGVuY29kaW5nKV0pXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGEgSlNPTiBXZWIgVG9rZW4gYXV0aGVudGljYXRpb24gbWV0aG9kXG5cbmNvbnN0IGp3dCA9IChyZXF1ZXN0LCBzZWNyZXQsIGFsZyA9ICdIUzI1NicsIGhhc2ggPSAnc2hhMjU2JykgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRIZWFkZXIgPSB1cmxlbmNvZGVCYXNlNjQgKHN0cmluZ1RvQmFzZTY0IChKU09OLnN0cmluZ2lmeSAoeyAnYWxnJzogYWxnLCAndHlwJzogJ0pXVCcgfSkpKVxuICAgICAgICAsIGVuY29kZWREYXRhID0gdXJsZW5jb2RlQmFzZTY0IChzdHJpbmdUb0Jhc2U2NCAoSlNPTi5zdHJpbmdpZnkgKHJlcXVlc3QpKSlcbiAgICAgICAgLCB0b2tlbiA9IFsgZW5jb2RlZEhlYWRlciwgZW5jb2RlZERhdGEgXS5qb2luICgnLicpXG4gICAgICAgICwgc2lnbmF0dXJlID0gdXJsZW5jb2RlQmFzZTY0ICh1dGYxNlRvQmFzZTY0IChobWFjICh0b2tlbiwgc2VjcmV0LCBoYXNoLCAndXRmMTYnKSkpXG4gICAgcmV0dXJuIFsgdG9rZW4sIHNpZ25hdHVyZSBdLmpvaW4gKCcuJylcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vIGNvbW1vbiB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgc2xlZXAsXG4gICAgdGltZW91dCxcbiAgICBjYXBpdGFsaXplLFxuICAgIGtleXNvcnQsXG4gICAgZXh0ZW5kLFxuICAgIGRlZXBFeHRlbmQsXG4gICAgb21pdCxcbiAgICBncm91cEJ5LFxuICAgIGluZGV4QnksXG4gICAgc29ydEJ5LFxuICAgIGZpbHRlckJ5LFxuICAgIGZsYXR0ZW4sXG4gICAgdW5pcXVlLFxuICAgIHBsdWNrLFxuICAgIHVybGVuY29kZSxcbiAgICByYXdlbmNvZGUsXG4gICAgc3VtLFxuICAgIGRlY2ltYWwsXG4gICAgc2FmZUZsb2F0LFxuICAgIHNhZmVTdHJpbmcsXG4gICAgc2FmZUludGVnZXIsXG4gICAgc2FmZVZhbHVlLFxuICAgIG9yZGVyZWQsXG4gICAgYWdncmVnYXRlLFxuICAgIHRydW5jYXRlLFxuICAgIHV1aWQsXG4gICAgcHJlY2lzaW9uRnJvbVN0cmluZyxcblxuICAgIC8vIHVuZGVyc2NvcmUgYWxpYXNlc1xuXG4gICAgaW5kZXhfYnk6IGluZGV4QnksXG4gICAgc29ydF9ieTogc29ydEJ5LFxuICAgIGdyb3VwX2J5OiBncm91cEJ5LFxuICAgIGZpbHRlcl9ieTogZmlsdGVyQnksXG4gICAgc2FmZV9mbG9hdDogc2FmZUZsb2F0LFxuICAgIHNhZmVfc3RyaW5nOiBzYWZlU3RyaW5nLFxuICAgIHNhZmVfaW50ZWdlcjogc2FmZUludGVnZXIsXG4gICAgc2FmZV92YWx1ZTogc2FmZVZhbHVlLFxuXG4gICAgLy8gY3J5cHRvIGZ1bmN0aW9uc1xuXG4gICAgYmluYXJ5Q29uY2F0LFxuICAgIHN0cmluZ1RvQmluYXJ5LFxuICAgIGJpbmFyeVRvU3RyaW5nLFxuICAgIHN0cmluZ1RvQmFzZTY0LFxuICAgIHV0ZjE2VG9CYXNlNjQsXG4gICAgYmFzZTY0VG9CaW5hcnksXG4gICAgYmFzZTY0VG9TdHJpbmcsXG4gICAgdXJsZW5jb2RlQmFzZTY0LFxuICAgIGhhc2gsXG4gICAgaG1hYyxcbiAgICBqd3QsXG5cbiAgICAvLyBqc29uXG4gICAganNvbjogICBKU09OLnN0cmluZ2lmeSxcbiAgICB1bmpzb246IEpTT04ucGFyc2Vcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IHNsZWVwIH0gID0gcmVxdWlyZSAoJy4vZnVuY3Rpb25zJylcblxuY29uc3QgdGhyb3R0bGUgPSBjZmcgPT4ge1xuXG4gICAgbGV0IGxhc3RUaW1lc3RhbXAgPSBEYXRlLm5vdyAoKVxuICAgICAgICAsIG51bVRva2VucyA9ICh0eXBlb2YgY2ZnLm51bVRva2VucyAhPSAndW5kZWZpbmVkJykgPyBjZmcubnVtVG9rZW5zIDogY2ZnLmNhcGFjaXR5XG4gICAgICAgICwgcXVldWUgPSBbXVxuICAgICAgICAsIHJ1bm5pbmcgPSBmYWxzZVxuICAgICAgICAsIGNvdW50ZXIgPSAwXG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbiAoY29zdCA9PiB7XG5cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IGNmZy5tYXhDYXBhY2l0eSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24gKCdCYWNrbG9nIGlzIG92ZXIgbWF4IGNhcGFjaXR5IG9mICcgKyBjZmcubWF4Q2FwYWNpdHkpXG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlIChhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoICh7IGNvc3QsIHJlc29sdmUsIHJlamVjdCB9KVxuXG4gICAgICAgICAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNFbm91Z2hUb2tlbnMgPSBjZmcuY2FwYWNpdHkgPyAobnVtVG9rZW5zID4gMCkgOiAobnVtVG9rZW5zID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRW5vdWdoVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgY29zdCwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBxdWV1ZVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3N0ID0gKGNvc3QgfHwgY2ZnLmRlZmF1bHRDb3N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVG9rZW5zID49IE1hdGgubWluIChjb3N0LCBjZmcuY2FwYWNpdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Ub2tlbnMgLT0gY29zdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuc2hpZnQgKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3cgPSBEYXRlLm5vdyAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsYXBzZWQgPSBub3cgLSBsYXN0VGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGltZXN0YW1wID0gbm93XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1Ub2tlbnMgPSBNYXRoLm1pbiAoY2ZnLmNhcGFjaXR5LCBudW1Ub2tlbnMgKyBlbGFwc2VkICogY2ZnLnJlZmlsbFJhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCAoY2ZnLmRlbGF5KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0IChlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgfSwgY2ZnLCB7XG4gICAgICAgIGNvbmZpZ3VyZTogbmV3Q2ZnID0+IHRocm90dGxlIChPYmplY3QuYXNzaWduICh7fSwgY2ZnLCBuZXdDZmcpKVxuICAgIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGUiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgSW52YWxpZE9yZGVyIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaW5hbmNlIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpbmFuY2UnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQmluYW5jZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJywgLy8gQ2hpbmFcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiA1MDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgLy8gb2Jzb2xldGUgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW0nLFxuICAgICAgICAgICAgICAgICczbSc6ICczbScsXG4gICAgICAgICAgICAgICAgJzVtJzogJzVtJyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1bScsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICczMG0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzJoJzogJzJoJyxcbiAgICAgICAgICAgICAgICAnNGgnOiAnNGgnLFxuICAgICAgICAgICAgICAgICc2aCc6ICc2aCcsXG4gICAgICAgICAgICAgICAgJzhoJzogJzhoJyxcbiAgICAgICAgICAgICAgICAnMTJoJzogJzEyaCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFkJyxcbiAgICAgICAgICAgICAgICAnM2QnOiAnM2QnLFxuICAgICAgICAgICAgICAgICcxdyc6ICcxdycsXG4gICAgICAgICAgICAgICAgJzFNJzogJzFNJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI5NjA0MDIwLWQ1NDgzY2RjLTg3ZWUtMTFlNy05NGM3LWQxYThkOTE2OTI5My5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICd3ZWInOiAnaHR0cHM6Ly93d3cuYmluYW5jZS5jb20nLFxuICAgICAgICAgICAgICAgICAgICAnd2FwaSc6ICdodHRwczovL2FwaS5iaW5hbmNlLmNvbS93YXBpL3YzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjEnLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5iaW5hbmNlLmNvbS9hcGkvdjMnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaW5hbmNlLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5iaW5hbmNlLmNvbS9yZXN0YXBpcHViLmh0bWwnLFxuICAgICAgICAgICAgICAgICdmZWVzJzogJ2h0dHBzOi8vYmluYW5jZS56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8xMTUwMDA0MjkzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3dlYic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9wdWJsaWMvcHJvZHVjdCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd0hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAncGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FnZ1RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2xpbmVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIvMjRocicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbFByaWNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbEJvb2tUaWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbGxPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL3Rlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJEYXRhU3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyRGF0YVN0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlckRhdGFTdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQk5CJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORU8nOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05UJzogNTAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTlQnOiAwLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMi4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDSCc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHQVMnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEVCc6IDUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPQVgnOiAyLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE5UJzogMzAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQ08nOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTic6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXVEMnOiAwLjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pSWCc6IDUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVFJBVCc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTkdMUyc6IDguMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCUVgnOiAyLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnS05DJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVTic6IDUwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05NJzogMTAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMSU5LJzogNS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hWRyc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFInOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0FMVCc6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJT1RBJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01EQSc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEwnOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NVQic6IDEwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRDJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEgnOiAxMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VORyc6IDIuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBU1QnOiA0LjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVlgnOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVRJzogMzAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMUkMnOiA3LjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVklCJzogNy4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hTUic6IDAuMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUUlgnOiA1MDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT1dSJzogMTUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBUksnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWU9ZTyc6IDMwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFJQJzogMC4xNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNT0QnOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5KJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUT1JKJzogMi4wLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndlYkdldEV4Y2hhbmdlUHVibGljUHJvZHVjdCAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAobWFya2V0WydiYXNlQXNzZXQnXSk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAobWFya2V0WydxdW90ZUFzc2V0J10pO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ21pblRyYWRlJ10pO1xuICAgICAgICAgICAgbGV0IHRpY2tTaXplID0gcGFyc2VGbG9hdCAobWFya2V0Wyd0aWNrU2l6ZSddKTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0Wyd0aWNrU2l6ZSddKSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB0aGlzLnByZWNpc2lvbkZyb21TdHJpbmcgKG1hcmtldFsndGlja1NpemUnXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IG1hcmtldFsnYWN0aXZlJ10sXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB0aWNrU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZUZlZSAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIgPSAndGFrZXInLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgIGxldCBrZXkgPSAncXVvdGUnO1xuICAgICAgICBsZXQgcmF0ZSA9IG1hcmtldFt0YWtlck9yTWFrZXJdO1xuICAgICAgICBsZXQgY29zdCA9IHBhcnNlRmxvYXQgKHRoaXMuY29zdFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCAqIHJhdGUpKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gJ3NlbGwnKSB7XG4gICAgICAgICAgICBjb3N0ICo9IHByaWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gJ2Jhc2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndHlwZSc6IHRha2VyT3JNYWtlcixcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFtrZXldLFxuICAgICAgICAgICAgJ3JhdGUnOiByYXRlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0aGlzLmZlZVRvUHJlY2lzaW9uIChzeW1ib2wsIGNvc3QpKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnQgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaV07XG4gICAgICAgICAgICBsZXQgYXNzZXQgPSBiYWxhbmNlWydhc3NldCddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGFzc2V0KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnZnJlZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2xvY2tlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnbGltaXQnOiAxMDAsIC8vIGRlZmF1bHQgPSBtYXhpbXVtID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuc2FmZUludGVnZXIgKHRpY2tlciwgJ2Nsb3NlVGltZScpO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaFByaWNlJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvd1ByaWNlJyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZFByaWNlJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2Fza1ByaWNlJyksXG4gICAgICAgICAgICAndndhcCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd3ZWlnaHRlZEF2Z1ByaWNlJyksXG4gICAgICAgICAgICAnb3Blbic6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdvcGVuUHJpY2UnKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdwcmV2Q2xvc2VQcmljZScpLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdFByaWNlJyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ByaWNlQ2hhbmdlUGVyY2VudCcpLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3F1b3RlVm9sdW1lJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyMjRociAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyQWxsQm9va1RpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsnc3ltYm9sJ107XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbMV0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbMl0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbM10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbNF0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbNV0pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdpbnRlcnZhbCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gKGxpbWl0KSA/IGxpbWl0IDogNTAwOyAvLyBkZWZhdWx0ID09IG1heCA9PSA1MDBcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnRUaW1lJ10gPSBzaW5jZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRLbGluZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXBGaWVsZCA9ICgnVCcgaW4gdHJhZGUpID8gJ1QnIDogJ3RpbWUnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbdGltZXN0YW1wRmllbGRdO1xuICAgICAgICBsZXQgcHJpY2VGaWVsZCA9ICgncCcgaW4gdHJhZGUpID8gJ3AnIDogJ3ByaWNlJztcbiAgICAgICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCAodHJhZGVbcHJpY2VGaWVsZF0pO1xuICAgICAgICBsZXQgYW1vdW50RmllbGQgPSAoJ3EnIGluIHRyYWRlKSA/ICdxJyA6ICdxdHknO1xuICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VGbG9hdCAodHJhZGVbYW1vdW50RmllbGRdKTtcbiAgICAgICAgbGV0IGlkRmllbGQgPSAoJ2EnIGluIHRyYWRlKSA/ICdhJyA6ICdpZCc7XG4gICAgICAgIGxldCBpZCA9IHRyYWRlW2lkRmllbGRdLnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ29yZGVySWQnIGluIHRyYWRlKVxuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICBpZiAoJ20nIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBzaWRlID0gdHJhZGVbJ20nXSA/ICdzZWxsJyA6ICdidXknOyAvLyB0aGlzIGlzIHJldmVyc2VkIGludGVudGlvbmFsbHlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZGUgPSAodHJhZGVbJ2lzQnV5ZXInXSkgPyAnYnV5JyA6ICdzZWxsJzsgLy8gdGhpcyBpcyBhIHRydWUgc2lkZVxuICAgICAgICB9XG4gICAgICAgIGxldCBmZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnY29tbWlzc2lvbicgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKHRyYWRlWydjb21taXNzaW9uJ10pLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh0cmFkZVsnY29tbWlzc2lvbkFzc2V0J10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBwcmljZSAqIGFtb3VudCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0VGltZSddID0gc2luY2U7XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgLy8gJ2Zyb21JZCc6IDEyMywgICAgLy8gSUQgdG8gZ2V0IGFnZ3JlZ2F0ZSB0cmFkZXMgZnJvbSBJTkNMVVNJVkUuXG4gICAgICAgIC8vICdzdGFydFRpbWUnOiA0NTYsIC8vIFRpbWVzdGFtcCBpbiBtcyB0byBnZXQgYWdncmVnYXRlIHRyYWRlcyBmcm9tIElOQ0xVU0lWRS5cbiAgICAgICAgLy8gJ2VuZFRpbWUnOiA3ODksICAgLy8gVGltZXN0YW1wIGluIG1zIHRvIGdldCBhZ2dyZWdhdGUgdHJhZGVzIHVudGlsIElOQ0xVU0lWRS5cbiAgICAgICAgLy8gJ2xpbWl0JzogNTAwLCAgICAgLy8gZGVmYXVsdCA9IG1heGltdW0gPSA1MDBcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBZ2dUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXJTdGF0dXMgKHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09ICdORVcnKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAnUEFSVElBTExZX0ZJTExFRCcpXG4gICAgICAgICAgICByZXR1cm4gJ3BhcnRpYWwnO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdGSUxMRUQnKVxuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdDQU5DRUxFRCcpXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgcmV0dXJuIHN0YXR1cy50b0xvd2VyQ2FzZSAoKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzdGF0dXMgPSB0aGlzLnBhcnNlT3JkZXJTdGF0dXMgKG9yZGVyWydzdGF0dXMnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBvcmRlclsnc3ltYm9sJ107XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlclsndGltZSddO1xuICAgICAgICBsZXQgcHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlclsncHJpY2UnXSk7XG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0IChvcmRlclsnb3JpZ1F0eSddKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2V4ZWN1dGVkUXR5JywgMC4wKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IE1hdGgubWF4IChhbW91bnQgLSBmaWxsZWQsIDAuMCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ29yZGVySWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiBvcmRlclsndHlwZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnc2lkZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Nvc3QnOiBwcmljZSAqIGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKSB7XG4gICAgICAgICAgICBvcmRlciA9IHRoaXMuZXh0ZW5kIChvcmRlciwge1xuICAgICAgICAgICAgICAgICdwcmljZSc6IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSksXG4gICAgICAgICAgICAgICAgJ3RpbWVJbkZvcmNlJzogJ0dUQycsIC8vICdHVEMnID0gR29vZCBUbyBDYW5jZWwgKGRlZmF1bHQpLCAnSU9DJyA9IEltbWVkaWF0ZSBPciBDYW5jZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXIgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW0nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnb3JkZXJJZCc6IHBhcnNlSW50IChpZCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFsbE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcGVuT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3Blbk9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgICAgICdvcmRlcklkJzogcGFyc2VJbnQgKGlkKSxcbiAgICAgICAgICAgICAgICAvLyAnb3JpZ0NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UuaW5kZXhPZiAoJ1VOS05PV05fT1JERVInKSA+PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoTXlUcmFkZXMgcmVxdWlyZXMgYSBzeW1ib2wnKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TXlUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0gnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgY3VycmVuY3lJZCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0gnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0MnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FwaUdldERlcG9zaXRBZGRyZXNzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Fzc2V0JzogdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSksXG4gICAgICAgICAgICAncmVjdldpbmRvdyc6IDEwMDAwMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdWNjZXNzJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsICdhZGRyZXNzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hEZXBvc2l0QWRkcmVzcyBmYWlsZWQ6ICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FwaVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdhc3NldCc6IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpLFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKGFtb3VudCksXG4gICAgICAgICAgICAncmVjdldpbmRvdyc6IDEwMDAwMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICB1cmwgKz0gJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAnd2FwaScpXG4gICAgICAgICAgICB1cmwgKz0gJy5odG1sJztcbiAgICAgICAgaWYgKChhcGkgPT0gJ3ByaXZhdGUnKSB8fCAoYXBpID09ICd3YXBpJykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAndGltZXN0YW1wJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocXVlcnkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5ICs9ICcmJyArICdzaWduYXR1cmU9JyArIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtTUJYLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgobWV0aG9kID09ICdHRVQnKSB8fCAoYXBpID09ICd3YXBpJykpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ01JTl9OT1RJT05BTCcpID49IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyBvcmRlciBjb3N0ID0gYW1vdW50ICogcHJpY2Ugc2hvdWxkIGJlID4gMC4wMDEgQlRDICcgKyBib2R5KTtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ0xPVF9TSVpFJykgPj0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKHRoaXMuaWQgKyAnIG9yZGVyIGFtb3VudCBzaG91bGQgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSBsb3Qgc2l6ZSwgdXNlIHRoaXMuYW1vdW50VG9Mb3RzIChzeW1ib2wsIGFtb3VudCkgJyArIGJvZHkpO1xuICAgICAgICBpZiAoYm9keS5pbmRleE9mICgnUFJJQ0VfRklMVEVSJykgPj0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKHRoaXMuaWQgKyAnIG9yZGVyIHByaWNlIGV4Y2VlZHMgYWxsb3dlZCBwcmljZSBwcmVjaXNpb24gb3IgaW52YWxpZCwgdXNlIHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpICcgKyBib2R5KTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydjb2RlJ10gPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydjb2RlJ10gPT0gLTIwMTApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2NvZGUnXSA9PSAtMjAxMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXQyYyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXQyYycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXQyQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0lMJywgLy8gSXNyYWVsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMzAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MTE5LTM1OTMyMjBlLTVlY2UtMTFlNy04YjNhLTVhMDQxZjZiY2MzZi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuYml0MmMuY28uaWwnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0MmMuY28uaWwnLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXQyYy5jby5pbC9ob21lL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vT2ZlckUvYml0MmMnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0V4Y2hhbmdlcy97cGFpcn0vVGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFeGNoYW5nZXMve3BhaXJ9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRXhjaGFuZ2VzL3twYWlyfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9CYWxhbmNlL3YyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNZXJjaGFudC9DcmVhdGVDaGVja291dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXIvQWNjb3VudEhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZENvaW5GdW5kc1JlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZEZ1bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlci9BZGRPcmRlck1hcmtldFByaWNlQnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlci9BZGRPcmRlck1hcmtldFByaWNlU2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXIvQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL015T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQYXltZW50L0dldE15SWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BheW1lbnQvU2VuZCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL05JUyc6IHsgJ2lkJzogJ0J0Y05pcycsICdzeW1ib2wnOiAnQlRDL05JUycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdOSVMnIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9OSVMnOiB7ICdpZCc6ICdCY2hOaXMnLCAnc3ltYm9sJzogJ0JDSC9OSVMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnTklTJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvTklTJzogeyAnaWQnOiAnTHRjTmlzJywgJ3N5bWJvbCc6ICdMVEMvTklTJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ05JUycgfSxcbiAgICAgICAgICAgICAgICAnQlRHL05JUyc6IHsgJ2lkJzogJ0J0Z05pcycsICdzeW1ib2wnOiAnQlRHL05JUycsICdiYXNlJzogJ0JURycsICdxdW90ZSc6ICdOSVMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC41IC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjY291bnRCYWxhbmNlVjIgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9ICdBVkFJTEFCTEVfJyArIGN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbYXZhaWxhYmxlXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZVtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZXNQYWlyT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VzUGFpclRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGF2ZXJhZ2VQcmljZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsnYXYnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWydhJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogYXZlcmFnZVByaWNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydoJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGwnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2VQcmljZSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlc1BhaXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0T3JkZXJBZGRPcmRlcic7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdBbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnUGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ01hcmtldFByaWNlJyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnUHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ1RvdGFsJ10gPSBhbW91bnQgKiBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWydJc0JpZCddID0gKHNpZGUgPT0gJ2J1eScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsnTmV3T3JkZXInXVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckNhbmNlbE9yZGVyICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmpzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduJzogdGhpcy5kZWNvZGUgKHNpZ25hdHVyZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0YmF5IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdGJheScsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRCYXknLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ1BMJywgJ0VVJyBdLCAvLyBQb2xhbmRcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYxMzItOTc4YTdiZDgtNWVjZS0xMWU3LTk1NDAtYmM5NmQxZTliYmI4LmpwZycsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdGJheS5uZXQnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9iaXRiYXkubmV0L0FQSS9QdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2JpdGJheS5uZXQvQVBJL1RyYWRpbmcvdHJhZGluZ0FwaS5waHAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYml0YmF5Lm5ldC9wdWJsaWMtYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYml0YmF5Lm5ldC9hY2NvdW50L3RhYi1hcGknLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL0JpdEJheU5ldC9BUEknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L21hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9vcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnQlRDVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9QTE4nOiB7ICdpZCc6ICdCVENQTE4nLCAnc3ltYm9sJzogJ0JUQy9QTE4nLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvVVNEJzogeyAnaWQnOiAnTFRDVVNEJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0VVUic6IHsgJ2lkJzogJ0xUQ0VVUicsICdzeW1ib2wnOiAnTFRDL0VVUicsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9QTE4nOiB7ICdpZCc6ICdMVENQTE4nLCAnc3ltYm9sJzogJ0xUQy9QTE4nLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnRVRIL1VTRCc6IHsgJ2lkJzogJ0VUSFVTRCcsICdzeW1ib2wnOiAnRVRIL1VTRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9FVVInOiB7ICdpZCc6ICdFVEhFVVInLCAnc3ltYm9sJzogJ0VUSC9FVVInLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvUExOJzogeyAnaWQnOiAnRVRIUExOJywgJ3N5bWJvbCc6ICdFVEgvUExOJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ0VUSEJUQycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0xTSy9VU0QnOiB7ICdpZCc6ICdMU0tVU0QnLCAnc3ltYm9sJzogJ0xTSy9VU0QnLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdMU0svRVVSJzogeyAnaWQnOiAnTFNLRVVSJywgJ3N5bWJvbCc6ICdMU0svRVVSJywgJ2Jhc2UnOiAnTFNLJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgICAgICAnTFNLL1BMTic6IHsgJ2lkJzogJ0xTS1BMTicsICdzeW1ib2wnOiAnTFNLL1BMTicsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICAgICAgICAgJ0xTSy9CVEMnOiB7ICdpZCc6ICdMU0tCVEMnLCAnc3ltYm9sJzogJ0xTSy9CVEMnLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjMgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDA0MyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0SW5mbyAoKTtcbiAgICAgICAgaWYgKCdiYWxhbmNlcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2UgfTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydhdmFpbGFibGUnXSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydsb2NrZWQnXSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZW1wdHkgYmFsYW5jZSByZXNwb25zZSAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyk7XG4gICAgICAgIGxldCB2d2FwID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3Z3YXAnKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ21heCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdtaW4nKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhdmVyYWdlJyksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwYXltZW50X2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGlzRmlhdCAoY3VycmVuY3kpIHtcbiAgICAgICAgbGV0IGZpYXRDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgJ1VTRCc6IHRydWUsXG4gICAgICAgICAgICAnRVVSJzogdHJ1ZSxcbiAgICAgICAgICAgICdQTE4nOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVuY3kgaW4gZmlhdEN1cnJlbmNpZXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0ZpYXQgKGN1cnJlbmN5KSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXcnO1xuICAgICAgICAgICAgLy8gcmVxdWVzdFsnYWNjb3VudCddID0gcGFyYW1zWydhY2NvdW50J107IC8vIHRoZXkgZGVtYW5kIGFuIGFjY291bnQgbnVtYmVyXG4gICAgICAgICAgICAvLyByZXF1ZXN0WydleHByZXNzJ10gPSBwYXJhbXNbJ2V4cHJlc3MnXTsgLy8gd2hhdGV2ZXIgaXQgbWVhbnMsIHRoZXkgZG9uJ3QgZXhwbGFpblxuICAgICAgICAgICAgLy8gcmVxdWVzdFsnYmljJ10gPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdwcml2YXRlUG9zdFRyYW5zZmVyJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2FkZHJlc3MnXSA9IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICcuanNvbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnbW9tZW50JzogdGhpcy5ub25jZSAoKSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0FQSS1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQVBJLUhhc2gnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdGNvaW5jb2lkIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdGNvaW5jb2lkJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdGNvaW4uY28uaWQnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdJRCcsIC8vIEluZG9uZXNpYVxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYxMzgtMDQzYzc3ODYtNWVjZi0xMWU3LTg4MmItODA5YzE0ZjM4YjUzLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3ZpcC5iaXRjb2luLmNvLmlkL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vdmlwLmJpdGNvaW4uY28uaWQvdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJpdGNvaW4uY28uaWQnLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3ZpcC5iaXRjb2luLmNvLmlkL2Rvd25sb2Fkcy9CSVRDT0lOQ09JRC1BUEktRE9DVU1FTlRBVElPTi5wZGYnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly92aXAuYml0Y29pbi5jby5pZC90cmFkZV9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3twYWlyfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3twYWlyfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3twYWlyfS9kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0lEUic6IHsgJ2lkJzogJ2J0Y19pZHInLCAnc3ltYm9sJzogJ0JUQy9JRFInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSURSJywgJ2Jhc2VJZCc6ICdidGMnLCAncXVvdGVJZCc6ICdpZHInIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9JRFInOiB7ICdpZCc6ICdiY2hfaWRyJywgJ3N5bWJvbCc6ICdCQ0gvSURSJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0lEUicsICdiYXNlSWQnOiAnYmNoJywgJ3F1b3RlSWQnOiAnaWRyJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvSURSJzogeyAnaWQnOiAnZXRoX2lkcicsICdzeW1ib2wnOiAnRVRIL0lEUicsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2V0aCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0lEUic6IHsgJ2lkJzogJ2V0Y19pZHInLCAnc3ltYm9sJzogJ0VUQy9JRFInLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnSURSJywgJ2Jhc2VJZCc6ICdldGMnLCAncXVvdGVJZCc6ICdpZHInIH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9JRFInOiB7ICdpZCc6ICd4cnBfaWRyJywgJ3N5bWJvbCc6ICdYUlAvSURSJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0lEUicsICdiYXNlSWQnOiAneHJwJywgJ3F1b3RlSWQnOiAnaWRyJyB9LFxuICAgICAgICAgICAgICAgICdYWkMvSURSJzogeyAnaWQnOiAneHpjX2lkcicsICdzeW1ib2wnOiAnWFpDL0lEUicsICdiYXNlJzogJ1haQycsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ3h6YycsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgICAgICAgICAnWExNL0lEUic6IHsnaWQnOiAnc3RyX2lkcicsICdzeW1ib2wnOiAnWExNL0lEUicsICdiYXNlJzogJ1hMTScsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ3N0cicsICdxdW90ZUlkJzogJ2lkcid9LFxuICAgICAgICAgICAgICAgICdCVFMvQlRDJzogeyAnaWQnOiAnYnRzX2J0YycsICdzeW1ib2wnOiAnQlRTL0JUQycsICdiYXNlJzogJ0JUUycsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2J0cycsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgICAgICAgICAnREFTSC9CVEMnOiB7ICdpZCc6ICdkcmtfYnRjJywgJ3N5bWJvbCc6ICdEQVNIL0JUQycsICdiYXNlJzogJ0RBU0gnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICdkcmsnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ0RPR0UvQlRDJzogeyAnaWQnOiAnZG9nZV9idGMnLCAnc3ltYm9sJzogJ0RPR0UvQlRDJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2RvZ2UnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICdldGhfYnRjJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnZXRoJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnbHRjX2J0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2x0YycsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgICAgICAgICAnTlhUL0JUQyc6IHsgJ2lkJzogJ254dF9idGMnLCAnc3ltYm9sJzogJ05YVC9CVEMnLCAnYmFzZSc6ICdOWFQnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICdueHQnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ1hMTS9CVEMnOiB7ICdpZCc6ICdzdHJfYnRjJywgJ3N5bWJvbCc6ICdYTE0vQlRDJywgJ2Jhc2UnOiAnWExNJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnc3RyJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgICAgICdYRU0vQlRDJzogeyAnaWQnOiAnbmVtX2J0YycsICdzeW1ib2wnOiAnWEVNL0JUQycsICdiYXNlJzogJ1hFTScsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ25lbScsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ3hycF9idGMnLCAnc3ltYm9sJzogJ1hSUC9CVEMnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICd4cnAnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSwgbG93ZXJjYXNlLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2VfaG9sZCddLCBsb3dlcmNhc2UsIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQYWlyRGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdidXknLCAnc2VsbCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQYWlyVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VGbG9hdCAodGlja2VyWydzZXJ2ZXJfdGltZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gJ3ZvbF8nICsgbWFya2V0WydiYXNlSWQnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gJ3ZvbF8nICsgbWFya2V0WydxdW90ZUlkJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbYmFzZVZvbHVtZV0pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyW3F1b3RlVm9sdW1lXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpclRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VJZCddO1xuICAgICAgICBvcmRlcltiYXNlXSA9IGFtb3VudDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXR1cm4nXVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgcmVzcG9uc2VbJ2Vycm9yJ10pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE5vdFN1cHBvcnRlZCwgSW52YWxpZE9yZGVyLCBPcmRlck5vdEZvdW5kIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRmaW5leCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRmaW5leCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRmaW5leCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9sZCBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0RlcG9zaXQnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW0nLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1bScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW0nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnMWgnLFxuICAgICAgICAgICAgICAgICczaCc6ICczaCcsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMTJoJzogJzEyaCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFEJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnN0QnLFxuICAgICAgICAgICAgICAgICcydyc6ICcxNEQnLFxuICAgICAgICAgICAgICAgICcxTSc6ICcxTScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjI0NC1lMzI4YTUwYy01ZWQyLTExZTctOTQ3Yi0wNDE0MTY1NzliYjMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZpbmV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRmaW5leC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdGZpbmV4LnJlYWRtZS5pby92MS9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRmaW5leGNvbS9iaXRmaW5leC1hcGktbm9kZScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd2Mic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L3tzZWN0aW9ufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuZGxlcy90cmFkZTp7dGltZWZyYW1lfTp7c3ltYm9sfS9sYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdjYW5kbGVzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kYm9vay97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kcy97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwdWJ0aWNrZXIve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2xzX2RldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvZGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRfaW5mb3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYXNrZXRfbWFuYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVkaXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0L25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZGluZy9jbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeS9tb3ZlbWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2tleV9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5faW5mb3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215dHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteXRyYWRlc19mdW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvZmZlci9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29mZmVyL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2ZmZXIvc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvZmZlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29mZmVycy9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbC9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbC9tdWx0aScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL3JlcGxhY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvbmV3L211bHRpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2NsYWltJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rha2VuX2Z1bmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3RhbF90YWtlbl9mdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VudXNlZF90YWtlbl9mdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIC8vIGlzc3VlICM0IEJpdGZpbmV4IG5hbWVzIERhc2ggYXMgRFNILCBpbnN0ZWFkIG9mIERBU0hcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEU0gnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdRVE0nKVxuICAgICAgICAgICAgcmV0dXJuICdRVFVNJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdDU1RfQkNDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ1UnKVxuICAgICAgICAgICAgcmV0dXJuICdDU1RfQkNVJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xzRGV0YWlscyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydwYWlyJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYmFzZUlkID0gaWQuc2xpY2UgKDAsIDMpO1xuICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlSWQpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlSWQpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0WydwcmljZV9wcmVjaXNpb24nXSxcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogbWFya2V0WydwcmljZV9wcmVjaXNpb24nXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2Jhc2VJZCc6IGJhc2VJZCxcbiAgICAgICAgICAgICAgICAncXVvdGVJZCc6IHF1b3RlSWQsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWluaW11bV9vcmRlcl9zaXplJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWF4aW11bV9vcmRlcl9zaXplJ10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VUeXBlID0gdGhpcy5zYWZlU3RyaW5nIChwYXJhbXMsICd0eXBlJywgJ2V4Y2hhbmdlJyk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VbJ3R5cGUnXSA9PSBiYWxhbmNlVHlwZSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYW1vdW50J10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICAgICAgcmVzdWx0W3VwcGVyY2FzZV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCb29rU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2ldO1xuICAgICAgICAgICAgaWYgKCdwYWlyJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ3BhaXInXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VycygpIGZhaWxlZCB0byByZWNvZ25pemUgc3ltYm9sICcgKyBpZCArICcgJyArIHRoaXMuanNvbiAodGlja2VyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXJzKCkgcmVzcG9uc2Ugbm90IHJlY29nbml6ZWQgJyArIHRoaXMuanNvbiAodGlja2VycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJ0aWNrZXJTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIGlmICgncGFpcicgaW4gdGlja2VyKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ3BhaXInXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyB1bnJlY29nbml6ZWQgdGlja2VyIHN5bWJvbCAnICsgaWQgKyAnICcgKyB0aGlzLmpzb24gKHRpY2tlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21pZCddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VGbG9hdCAodHJhZGVbJ3RpbWVzdGFtcCddKSkgKiAxMDAwO1xuICAgICAgICBsZXQgc2lkZSA9IHRyYWRlWyd0eXBlJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIGxldCBvcmRlcklkID0gdGhpcy5zYWZlU3RyaW5nICh0cmFkZSwgJ29yZGVyX2lkJyk7XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSk7XG4gICAgICAgIGxldCBjb3N0ID0gcHJpY2UgKiBhbW91bnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcklkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTXlUcmFkZXMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0geyAnc3ltYm9sJzogbWFya2V0WydpZCddIH07XG4gICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXRfdHJhZGVzJ10gPSBsaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3RpbWVzdGFtcCddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE15dHJhZGVzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKCh0eXBlID09ICdsaW1pdCcpIHx8ICh0eXBlID09ICdtYXJrZXQnKSlcbiAgICAgICAgICAgIG9yZGVyVHlwZSA9ICdleGNoYW5nZSAnICsgdHlwZTtcbiAgICAgICAgLy8gYW1vdW50ID0gdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdvY29vcmRlcic6IGZhbHNlLFxuICAgICAgICAgICAgJ2J1eV9wcmljZV9vY28nOiAwLFxuICAgICAgICAgICAgJ3NlbGxfcHJpY2Vfb2NvJzogMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHByaWNlID0gdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2UudG9TdHJpbmcgKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlck5ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcihyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IHBhcnNlSW50IChpZCkgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IG9yZGVyWydzaWRlJ107XG4gICAgICAgIGxldCBvcGVuID0gb3JkZXJbJ2lzX2xpdmUnXTtcbiAgICAgICAgbGV0IGNhbmNlbGVkID0gb3JkZXJbJ2lzX2NhbmNlbGxlZCddO1xuICAgICAgICBsZXQgc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2FuY2VsZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGxldCBleGNoYW5nZSA9IG9yZGVyWydzeW1ib2wnXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGlmIChleGNoYW5nZSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbZXhjaGFuZ2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgb3JkZXJUeXBlID0gb3JkZXJbJ3R5cGUnXTtcbiAgICAgICAgbGV0IGV4Y2hhbmdlID0gb3JkZXJUeXBlLmluZGV4T2YgKCdleGNoYW5nZSAnKSA+PSAwO1xuICAgICAgICBpZiAoZXhjaGFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbIHByZWZpeCwgb3JkZXJUeXBlIF0gPSBvcmRlclsndHlwZSddLnNwbGl0ICgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VGbG9hdCAob3JkZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDApO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKSxcbiAgICAgICAgICAgICdhdmVyYWdlJzogcGFyc2VGbG9hdCAob3JkZXJbJ2F2Z19leGVjdXRpb25fcHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAob3JkZXJbJ29yaWdpbmFsX2Ftb3VudCddKSxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBwYXJzZUZsb2F0IChvcmRlclsncmVtYWluaW5nX2Ftb3VudCddKSxcbiAgICAgICAgICAgICdmaWxsZWQnOiBwYXJzZUZsb2F0IChvcmRlclsnZXhlY3V0ZWRfYW1vdW50J10pLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5IChvcmRlcnMsICdzeW1ib2wnLCBzeW1ib2wpO1xuICAgICAgICByZXR1cm4gb3JkZXJzO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzSGlzdCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UpO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnkgKG9yZGVycywgJ3N5bWJvbCcsIHN5bWJvbCk7XG4gICAgICAgIHJldHVybiBvcmRlcnM7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyU3RhdHVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogcGFyc2VJbnQgKGlkKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdLFxuICAgICAgICAgICAgb2hsY3ZbMV0sXG4gICAgICAgICAgICBvaGxjdlszXSxcbiAgICAgICAgICAgIG9obGN2WzRdLFxuICAgICAgICAgICAgb2hsY3ZbMl0sXG4gICAgICAgICAgICBvaGxjdls1XSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdjJpZCA9ICd0JyArIG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdjJpZCxcbiAgICAgICAgICAgICd0aW1lZnJhbWUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gc2luY2U7XG4gICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy52MkdldENhbmRsZXNUcmFkZVRpbWVmcmFtZVN5bWJvbEhpc3QgKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGdldEN1cnJlbmN5TmFtZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpdGNvaW4nO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdMVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpdGVjb2luJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnRVRIJykge1xuICAgICAgICAgICAgcmV0dXJuICdldGhlcmV1bSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ0VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAnZXRoZXJldW1jJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnT01OSScpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFzdGVyY29pbic7IC8vID8/P1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdaRUMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3pjYXNoJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWE1SJykge1xuICAgICAgICAgICAgcmV0dXJuICdtb25lcm8nO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdVU0QnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3dpcmUnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdEQVNIJykge1xuICAgICAgICAgICAgcmV0dXJuICdkYXNoJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWFJQJykge1xuICAgICAgICAgICAgcmV0dXJuICdyaXBwbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdFT1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Vvcyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ0JDSCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmNhc2gnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdVU0RUJykge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXRoZXJ1c28nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnICcgKyBjdXJyZW5jeSArICcgbm90IHN1cHBvcnRlZCBmb3Igd2l0aGRyYXdhbCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZURlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdyZW5ldyc6IDEsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IHJlc3BvbnNlWydhZGRyZXNzJ10sXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2VbJ2luZm8nXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmdldEN1cnJlbmN5TmFtZSAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdtZXRob2QnOiBuYW1lLFxuICAgICAgICAgICAgJ3dhbGxldF9uYW1lJzogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICdyZW5ldyc6IDAsIC8vIGEgdmFsdWUgb2YgMSB3aWxsIGdlbmVyYXRlIGEgbmV3IGFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdERlcG9zaXROZXcgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiByZXNwb25zZVsnYWRkcmVzcyddLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuZ2V0Q3VycmVuY3lOYW1lIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3dpdGhkcmF3X3R5cGUnOiBuYW1lLFxuICAgICAgICAgICAgJ3dhbGxldHNlbGVjdGVkJzogJ2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gcmVzcG9uc2VzWzBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWyd3aXRoZHJhd2FsX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgaWYgKGFwaSA9PSAndjInKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gJy8nICsgYXBpICsgcmVxdWVzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSAnLycgKyB0aGlzLnZlcnNpb24gKyByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyByZXF1ZXN0O1xuICAgICAgICBpZiAoKGFwaSA9PSAncHVibGljJykgfHwgKHBhdGguaW5kZXhPZiAoJy9oaXN0JykgPj0gMCkpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzdWZmaXggPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgICAgIHVybCArPSBzdWZmaXg7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCArPSBzdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICAgICAncmVxdWVzdCc6IHJlcXVlc3QsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSB0aGlzLnN0cmluZ1RvQmFzZTY0IChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHBheWxvYWQsIHNlY3JldCwgJ3NoYTM4NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnWC1CRlgtQVBJS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1gtQkZYLVBBWUxPQUQnOiB0aGlzLmRlY29kZSAocGF5bG9hZCksXG4gICAgICAgICAgICAgICAgJ1gtQkZYLVNJR05BVFVSRSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keVswXSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5pbmRleE9mICgnS2V5IHByaWNlIHNob3VsZCBiZSBhIGRlY2ltYWwgbnVtYmVyJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmluZGV4T2YgKCdJbnZhbGlkIG9yZGVyOiBub3QgZW5vdWdoIGV4Y2hhbmdlIGJhbGFuY2UnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pbmRleE9mICgnSW52YWxpZCBvcmRlcicpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pbmRleE9mICgnT3JkZXIgY291bGQgbm90IGJlIGNhbmNlbGxlZC4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBiaXRmaW5leCA9IHJlcXVpcmUgKCcuL2JpdGZpbmV4LmpzJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgTm90U3VwcG9ydGVkLCBJbnN1ZmZpY2llbnRGdW5kcyB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRmaW5leDIgZXh0ZW5kcyBiaXRmaW5leCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0ZmluZXgyJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdGZpbmV4IHYyJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgLy8gb2xkIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0RlcG9zaXQnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IGZhbHNlLFxuICAgICAgICAgICAgLy8gbmV3IG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhcyc6IHtcbiAgICAgICAgICAgICAgICAnZmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNW0nLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMTVtJyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzMwbScsXG4gICAgICAgICAgICAgICAgJzFoJzogJzFoJyxcbiAgICAgICAgICAgICAgICAnM2gnOiAnM2gnLFxuICAgICAgICAgICAgICAgICc2aCc6ICc2aCcsXG4gICAgICAgICAgICAgICAgJzEyaCc6ICcxMmgnLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxRCcsXG4gICAgICAgICAgICAgICAgJzF3JzogJzdEJyxcbiAgICAgICAgICAgICAgICAnMncnOiAnMTREJyxcbiAgICAgICAgICAgICAgICAnMU0nOiAnMU0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjI0NC1lMzI4YTUwYy01ZWQyLTExZTctOTQ3Yi0wNDE0MTY1NzliYjMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZpbmV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRmaW5leC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdGZpbmV4LnJlYWRtZS5pby92Mi9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRmaW5leGNvbS9iaXRmaW5leC1hcGktbm9kZScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnZmVlcyc6ICdodHRwczovL3d3dy5iaXRmaW5leC5jb20vZmVlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYXRmb3JtL3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS97cHJlY2lzaW9ufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9QMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9QMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9QMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9QMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9SMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ltYm9sc19kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L3tzaWRlfS97c2VjdGlvbn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzMS97a2V5fTp7c2l6ZX06e3N5bWJvbH0vbG9uZy9sYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L2xvbmcvaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMxL3trZXl9OntzaXplfTp7c3ltYm9sfS9zaG9ydC9sYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L3Nob3J0L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmRsZXMvdHJhZGU6e3RpbWVmcmFtZX06e3N5bWJvbH0ve3NlY3Rpb259JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L2xhc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmRsZXMvdHJhZGU6e3RpbWVmcmFtZX06e3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbGMvdHJhZGUvYXZnJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3Ivd2FsbGV0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVycy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVycy97c3ltYm9sfS9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9vcmRlcnMve3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVyL3tzeW1ib2x9OntpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvdHJhZGVzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9wb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9mdW5kaW5nL29mZmVycy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvb2ZmZXJzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9mdW5kaW5nL2xvYW5zL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9sb2Fucy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9jcmVkaXRzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9jcmVkaXRzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9mdW5kaW5nL3RyYWRlcy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvaW5mby9tYXJnaW4ve2tleX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9pbmZvL2Z1bmRpbmcve2tleX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9tb3ZlbWVudHMve2N1cnJlbmN5fS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3Ivc3RhdHMvcGVyZjp7dGltZWZyYW1lfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvYWxlcnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3cvYWxlcnQvc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3cvYWxlcnQve3R5cGV9OntzeW1ib2x9OntwcmljZX0vZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL2NhbGMvb3JkZXIvYXZhaWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0FWVC9CVEMnOiB7ICdpZCc6ICd0QVZUQlRDJywgJ3N5bWJvbCc6ICdBVlQvQlRDJywgJ2Jhc2UnOiAnQVZUJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnQVZUL0VUSCc6IHsgJ2lkJzogJ3RBVlRFVEgnLCAnc3ltYm9sJzogJ0FWVC9FVEgnLCAnYmFzZSc6ICdBVlQnLCAncXVvdGUnOiAnRVRIJyB9LFxuICAgICAgICAgICAgICAgICdBVlQvVVNEJzogeyAnaWQnOiAndEFWVFVTRCcsICdzeW1ib2wnOiAnQVZUL1VTRCcsICdiYXNlJzogJ0FWVCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0NTVF9CQ0MvQlRDJzogeyAnaWQnOiAndEJDQ0JUQycsICdzeW1ib2wnOiAnQ1NUX0JDQy9CVEMnLCAnYmFzZSc6ICdDU1RfQkNDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnQ1NUX0JDQy9VU0QnOiB7ICdpZCc6ICd0QkNDVVNEJywgJ3N5bWJvbCc6ICdDU1RfQkNDL1VTRCcsICdiYXNlJzogJ0NTVF9CQ0MnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAndEJDSEJUQycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9FVEgnOiB7ICdpZCc6ICd0QkNIRVRIJywgJ3N5bWJvbCc6ICdCQ0gvRVRIJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnQkNIL1VTRCc6IHsgJ2lkJzogJ3RCQ0hVU0QnLCAnc3ltYm9sJzogJ0JDSC9VU0QnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdDU1RfQkNVL0JUQyc6IHsgJ2lkJzogJ3RCQ1VCVEMnLCAnc3ltYm9sJzogJ0NTVF9CQ1UvQlRDJywgJ2Jhc2UnOiAnQ1NUX0JDVScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0NTVF9CQ1UvVVNEJzogeyAnaWQnOiAndEJDVVVTRCcsICdzeW1ib2wnOiAnQ1NUX0JDVS9VU0QnLCAnYmFzZSc6ICdDU1RfQkNVJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlQxL0JUQyc6IHsgJ2lkJzogJ3RCVDFCVEMnLCAnc3ltYm9sJzogJ0JUMS9CVEMnLCAnYmFzZSc6ICdCVDEnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdCVDEvVVNEJzogeyAnaWQnOiAndEJUMVVTRCcsICdzeW1ib2wnOiAnQlQxL1VTRCcsICdiYXNlJzogJ0JUMScsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUMi9CVEMnOiB7ICdpZCc6ICd0QlQyQlRDJywgJ3N5bWJvbCc6ICdCVDIvQlRDJywgJ2Jhc2UnOiAnQlQyJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnQlQyL1VTRCc6IHsgJ2lkJzogJ3RCVDJVU0QnLCAnc3ltYm9sJzogJ0JUMi9VU0QnLCAnYmFzZSc6ICdCVDInLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAndEJUQ1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICd0QlRDRVVSJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgICAgICAnQlRHL0JUQyc6IHsgJ2lkJzogJ3RCVEdCVEMnLCAnc3ltYm9sJzogJ0JURy9CVEMnLCAnYmFzZSc6ICdCVEcnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdCVEcvVVNEJzogeyAnaWQnOiAndEJUR1VTRCcsICdzeW1ib2wnOiAnQlRHL1VTRCcsICdiYXNlJzogJ0JURycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAndERTSEJUQycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnREFTSC9VU0QnOiB7ICdpZCc6ICd0RFNIVVNEJywgJ3N5bWJvbCc6ICdEQVNIL1VTRCcsICdiYXNlJzogJ0RBU0gnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdEQVQvQlRDJzogeyAnaWQnOiAndERBVEJUQycsICdzeW1ib2wnOiAnREFUL0JUQycsICdiYXNlJzogJ0RBVCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0RBVC9FVEgnOiB7ICdpZCc6ICd0REFURVRIJywgJ3N5bWJvbCc6ICdEQVQvRVRIJywgJ2Jhc2UnOiAnREFUJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnREFUL1VTRCc6IHsgJ2lkJzogJ3REQVRVU0QnLCAnc3ltYm9sJzogJ0RBVC9VU0QnLCAnYmFzZSc6ICdEQVQnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdFRE8vQlRDJzogeyAnaWQnOiAndEVET0JUQycsICdzeW1ib2wnOiAnRURPL0JUQycsICdiYXNlJzogJ0VETycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0VETy9FVEgnOiB7ICdpZCc6ICd0RURPRVRIJywgJ3N5bWJvbCc6ICdFRE8vRVRIJywgJ2Jhc2UnOiAnRURPJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnRURPL1VTRCc6IHsgJ2lkJzogJ3RFRE9VU0QnLCAnc3ltYm9sJzogJ0VETy9VU0QnLCAnYmFzZSc6ICdFRE8nLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdFT1MvQlRDJzogeyAnaWQnOiAndEVPU0JUQycsICdzeW1ib2wnOiAnRU9TL0JUQycsICdiYXNlJzogJ0VPUycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0VPUy9FVEgnOiB7ICdpZCc6ICd0RU9TRVRIJywgJ3N5bWJvbCc6ICdFT1MvRVRIJywgJ2Jhc2UnOiAnRU9TJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnRU9TL1VTRCc6IHsgJ2lkJzogJ3RFT1NVU0QnLCAnc3ltYm9sJzogJ0VPUy9VU0QnLCAnYmFzZSc6ICdFT1MnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdFVEMvQlRDJzogeyAnaWQnOiAndEVUQ0JUQycsICdzeW1ib2wnOiAnRVRDL0JUQycsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0VUQy9VU0QnOiB7ICdpZCc6ICd0RVRDVVNEJywgJ3N5bWJvbCc6ICdFVEMvVVNEJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ3RFVEhCVEMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvVVNEJzogeyAnaWQnOiAndEVUSFVTRCcsICdzeW1ib2wnOiAnRVRIL1VTRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0VUUC9CVEMnOiB7ICdpZCc6ICd0RVRQQlRDJywgJ3N5bWJvbCc6ICdFVFAvQlRDJywgJ2Jhc2UnOiAnRVRQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnRVRQL0VUSCc6IHsgJ2lkJzogJ3RFVFBFVEgnLCAnc3ltYm9sJzogJ0VUUC9FVEgnLCAnYmFzZSc6ICdFVFAnLCAncXVvdGUnOiAnRVRIJyB9LFxuICAgICAgICAgICAgICAgICdFVFAvVVNEJzogeyAnaWQnOiAndEVUUFVTRCcsICdzeW1ib2wnOiAnRVRQL1VTRCcsICdiYXNlJzogJ0VUUCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0lPVC9CVEMnOiB7ICdpZCc6ICd0SU9UQlRDJywgJ3N5bWJvbCc6ICdJT1QvQlRDJywgJ2Jhc2UnOiAnSU9UJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnSU9UL0VUSCc6IHsgJ2lkJzogJ3RJT1RFVEgnLCAnc3ltYm9sJzogJ0lPVC9FVEgnLCAnYmFzZSc6ICdJT1QnLCAncXVvdGUnOiAnRVRIJyB9LFxuICAgICAgICAgICAgICAgICdJT1QvVVNEJzogeyAnaWQnOiAndElPVFVTRCcsICdzeW1ib2wnOiAnSU9UL1VTRCcsICdiYXNlJzogJ0lPVCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICd0TFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnTFRDL1VTRCc6IHsgJ2lkJzogJ3RMVENVU0QnLCAnc3ltYm9sJzogJ0xUQy9VU0QnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdORU8vQlRDJzogeyAnaWQnOiAndE5FT0JUQycsICdzeW1ib2wnOiAnTkVPL0JUQycsICdiYXNlJzogJ05FTycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ05FTy9FVEgnOiB7ICdpZCc6ICd0TkVPRVRIJywgJ3N5bWJvbCc6ICdORU8vRVRIJywgJ2Jhc2UnOiAnTkVPJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnTkVPL1VTRCc6IHsgJ2lkJzogJ3RORU9VU0QnLCAnc3ltYm9sJzogJ05FTy9VU0QnLCAnYmFzZSc6ICdORU8nLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdPTUcvQlRDJzogeyAnaWQnOiAndE9NR0JUQycsICdzeW1ib2wnOiAnT01HL0JUQycsICdiYXNlJzogJ09NRycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ09NRy9FVEgnOiB7ICdpZCc6ICd0T01HRVRIJywgJ3N5bWJvbCc6ICdPTUcvRVRIJywgJ2Jhc2UnOiAnT01HJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnT01HL1VTRCc6IHsgJ2lkJzogJ3RPTUdVU0QnLCAnc3ltYm9sJzogJ09NRy9VU0QnLCAnYmFzZSc6ICdPTUcnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdRVFVNL0JUQyc6IHsgJ2lkJzogJ3RRVE1CVEMnLCAnc3ltYm9sJzogJ1FUVU0vQlRDJywgJ2Jhc2UnOiAnUVRVTScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ1FUVU0vRVRIJzogeyAnaWQnOiAndFFUTUVUSCcsICdzeW1ib2wnOiAnUVRVTS9FVEgnLCAnYmFzZSc6ICdRVFVNJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnUVRVTS9VU0QnOiB7ICdpZCc6ICd0UVRNVVNEJywgJ3N5bWJvbCc6ICdRVFVNL1VTRCcsICdiYXNlJzogJ1FUVU0nLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdSUlQvQlRDJzogeyAnaWQnOiAndFJSVEJUQycsICdzeW1ib2wnOiAnUlJUL0JUQycsICdiYXNlJzogJ1JSVCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ1JSVC9VU0QnOiB7ICdpZCc6ICd0UlJUVVNEJywgJ3N5bWJvbCc6ICdSUlQvVVNEJywgJ2Jhc2UnOiAnUlJUJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnU0FOL0JUQyc6IHsgJ2lkJzogJ3RTQU5CVEMnLCAnc3ltYm9sJzogJ1NBTi9CVEMnLCAnYmFzZSc6ICdTQU4nLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdTQU4vRVRIJzogeyAnaWQnOiAndFNBTkVUSCcsICdzeW1ib2wnOiAnU0FOL0VUSCcsICdiYXNlJzogJ1NBTicsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ1NBTi9VU0QnOiB7ICdpZCc6ICd0U0FOVVNEJywgJ3N5bWJvbCc6ICdTQU4vVVNEJywgJ2Jhc2UnOiAnU0FOJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnWE1SL0JUQyc6IHsgJ2lkJzogJ3RYTVJCVEMnLCAnc3ltYm9sJzogJ1hNUi9CVEMnLCAnYmFzZSc6ICdYTVInLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdYTVIvVVNEJzogeyAnaWQnOiAndFhNUlVTRCcsICdzeW1ib2wnOiAnWE1SL1VTRCcsICdiYXNlJzogJ1hNUicsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9CVEMnOiB7ICdpZCc6ICd0WFJQQlRDJywgJ3N5bWJvbCc6ICdYUlAvQlRDJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnWFJQL1VTRCc6IHsgJ2lkJzogJ3RYUlBVU0QnLCAnc3ltYm9sJzogJ1hSUC9VU0QnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdaRUMvQlRDJzogeyAnaWQnOiAndFpFQ0JUQycsICdzeW1ib2wnOiAnWkVDL0JUQycsICdiYXNlJzogJ1pFQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ1pFQy9VU0QnOiB7ICdpZCc6ICd0WkVDVVNEJywgJ3N5bWJvbCc6ICdaRUMvVVNEJywgJ2Jhc2UnOiAnWkVDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ0gnOiAwLjAwMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFT1MnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMC4wMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lPVCc6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORU8nOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRDJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYUlAnOiAwLjAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUUCc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkVDJzogMC4wMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hNUic6IDAuMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRNJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFRE8nOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREFUJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FWVCc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQU4nOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEVCc6IDUuMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICAvLyBpc3N1ZSAjNCBCaXRmaW5leCBuYW1lcyBEYXNoIGFzIERTSCwgaW5zdGVhZCBvZiBEQVNIXG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRFNIJylcbiAgICAgICAgICAgIHJldHVybiAnREFTSCc7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnUVRNJylcbiAgICAgICAgICAgIHJldHVybiAnUVRVTSc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBdXRoUldhbGxldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlVHlwZSA9IHRoaXMuc2FmZVN0cmluZyAocGFyYW1zLCAndHlwZScsICdleGNoYW5nZScpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgcmVzcG9uc2UubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbYl07XG4gICAgICAgICAgICBsZXQgWyBhY2NvdW50VHlwZSwgY3VycmVuY3ksIHRvdGFsLCBpbnRlcmVzdCwgYXZhaWxhYmxlIF0gPSBiYWxhbmNlO1xuICAgICAgICAgICAgaWYgKGFjY291bnRUeXBlID09IGJhbGFuY2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5WzBdID09ICd0JylcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeS5zbGljZSAoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGF2YWlsYWJsZTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRbJ2ZyZWUnXSlcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2xQcmVjaXNpb24gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdwcmVjaXNpb24nOiAnUjAnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBbXSxcbiAgICAgICAgICAgICdhc2tzJzogW10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyYm9vay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJib29rW2ldO1xuICAgICAgICAgICAgbGV0IHByaWNlID0gb3JkZXJbMV07XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbMl07XG4gICAgICAgICAgICBsZXQgc2lkZSA9IChhbW91bnQgPiAwKSA/ICdiaWRzJyA6ICdhc2tzJztcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGguYWJzIChhbW91bnQpO1xuICAgICAgICAgICAgcmVzdWx0W3NpZGVdLnB1c2ggKFsgcHJpY2UsIGFtb3VudCBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRpY2tlci5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyW2xlbmd0aCAtIDJdLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlcltsZW5ndGggLSAxXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbbGVuZ3RoIC0gMTBdLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlcltsZW5ndGggLSA4XSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRpY2tlcltsZW5ndGggLSA0XSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB0aWNrZXJbbGVuZ3RoIC0gNl0sXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHRpY2tlcltsZW5ndGggLSA1XSxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aWNrZXJbbGVuZ3RoIC0gM10sXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbHMnOiB0aGlzLmlkcy5qb2luICgnLCcpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWzBdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCBbIGlkLCB0aW1lc3RhbXAsIGFtb3VudCwgcHJpY2UgXSA9IHRyYWRlO1xuICAgICAgICBsZXQgc2lkZSA9IChhbW91bnQgPCAwKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzU3ltYm9sSGlzdCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZSc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBzaW5jZTtcbiAgICAgICAgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldENhbmRsZXNUcmFkZVRpbWVmcmFtZVN5bWJvbEhpc3QgKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGNyZWF0ZU9yZGVyIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXIgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyB3aXRoZHJhdyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHJlcXVlc3Q7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnL2FwaScgKyAnLycgKyByZXF1ZXN0ICsgbm9uY2UgKyBib2R5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMzg0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdiZngtbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYmZ4LWFwaWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdiZngtc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddLmluZGV4T2YgKCdub3QgZW5vdWdoIGV4Y2hhbmdlIGJhbGFuY2UnKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UgPT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXR1cm5lZCBlbXB0eSByZXNwb25zZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0Zmx5ZXIgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0Zmx5ZXInLFxuICAgICAgICAgICAgJ25hbWUnOiAnYml0Rmx5ZXInLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdKUCcsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDUxNjQyLTU2MTU0MTgyLTY2MGUtMTFlNy05YjBkLTYwNDJkMWU2ZWRkOC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYml0Zmx5ZXIuanAnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9iaXRmbHllci5qcCcsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JpdGZseWVyLmpwL0FQSScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldG1hcmtldHMnLCAgICAvLyBvciAnbWFya2V0cydcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRib2FyZCcsICAgICAgLy8gb3IgJ2JvYXJkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHRpY2tlcicsICAgICAvLyBvciAndGlja2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGV4ZWN1dGlvbnMnLCAvLyBvciAnZXhlY3V0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRoZWFsdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGNoYXRzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHBlcm1pc3Npb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRjb2xsYXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRjb2xsYXRlcmFsYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Y29pbmlucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Y29pbm91dHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGJhbmthY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0ZGVwb3NpdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHdpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRjaGlsZG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0cGFyZW50b3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRwYXJlbnRvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0ZXhlY3V0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0cG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXR0cmFkaW5nY29tbWlzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbmRjb2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VuZGNoaWxkb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbGNoaWxkb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbmRwYXJlbnRvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VscGFyZW50b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbGFsbGNoaWxkb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjI1IC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjI1IC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0Wydwcm9kdWN0X2NvZGUnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGxldCBudW1DdXJyZW5jaWVzID0gY3VycmVuY2llcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtQ3VycmVuY2llcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN5bWJvbC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBzeW1ib2wuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1DdXJyZW5jaWVzID09IDIpIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gY3VycmVuY2llc1swXTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IGN1cnJlbmNpZXNbMV07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gY3VycmVuY2llc1sxXTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IGN1cnJlbmNpZXNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHJlc3BvbnNlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHJlc3BvbnNlW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYWNjb3VudFsnY3VycmVuY3lfY29kZSddO1xuICAgICAgICAgICAgYmFsYW5jZXNbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsnYW1vdW50J107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYmFsYW5jZXNbY3VycmVuY3ldWydhdmFpbGFibGUnXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvYXJkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RfY29kZSc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnc2l6ZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcm9kdWN0X2NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9iaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydiZXN0X2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbHRwJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lX2J5X3Byb2R1Y3QnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnc2lkZScgaW4gdHJhZGUpXG4gICAgICAgICAgICBpZiAodHJhZGVbJ3NpZGUnXSkge1xuICAgICAgICAgICAgICAgIHNpZGUgPSB0cmFkZVsnc2lkZSddLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNpZGUgKyAnX2NoaWxkX29yZGVyX2FjY2VwdGFuY2VfaWQnO1xuICAgICAgICAgICAgICAgIGlmIChpZCBpbiB0cmFkZSlcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2V4ZWNfZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnc2l6ZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4ZWN1dGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdF9jb2RlJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2NoaWxkX29yZGVyX3R5cGUnOiB0eXBlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnc2l6ZSc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RTZW5kY2hpbGRvcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydjaGlsZF9vcmRlcl9hY2NlcHRhbmNlX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsY2hpbGRvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYXJlbnRfb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9jb2RlJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgLy8gJ2JhbmtfYWNjb3VudF9pZCc6IDEyMzQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydtZXNzYWdlX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpXG4gICAgICAgICAgICByZXF1ZXN0ICs9ICdtZS8nO1xuICAgICAgICByZXF1ZXN0ICs9IHBhdGg7XG4gICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVxdWVzdCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHJlcXVlc3Q7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBbIG5vbmNlLCBtZXRob2QsIHJlcXVlc3QsIGJvZHkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FDQ0VTUy1USU1FU1RBTVAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQUNDRVNTLVNJR04nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBOb3RTdXBwb3J0ZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdGh1bWIgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0aHVtYicsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRodW1iJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnS1InLCAvLyBTb3V0aCBLb3JlYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDU5NzE3Ny1lYTgwMDE3Mi05ZDVlLTExZTctODA0Yy1iOWQ0ZmE5YjU2YjAuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJpdGh1bWIuY29tL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJpdGh1bWIuY29tJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20vdTEvVVMxMjcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vay9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlY2VudF90cmFuc2FjdGlvbnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVjZW50X3RyYW5zYWN0aW9ucy9hbGwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8vYWNjb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mby9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL3dhbGxldF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mby9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8vdXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3BsYWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL29yZGVyX2RldGFpbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9idGNfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUva3J3X2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL2tyd193aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9tYXJrZXRfYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9tYXJrZXRfc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckFsbCAoKTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAobWFya2V0c1snZGF0YSddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBpZiAoaWQgIT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaWRdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gaWQ7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gJ0tSVyc7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgICAgICdsb3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICdhY3RpdmUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvQmFsYW5jZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6ICdBTEwnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZXMsICd0b3RhbF8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlcywgJ2luX3VzZV8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlcywgJ2F2YWlsYWJsZV8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rQ3VycmVuY3kgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY291bnQnOiA1MCwgLy8gbWF4ID0gNTBcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJib29rWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdxdWFudGl0eScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnZGF0ZSddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ21heF9wcmljZScpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdtaW5fcHJpY2UnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5X3ByaWNlJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGxfcHJpY2UnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlbmluZ19wcmljZScpLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2Nsb3NpbmdfcHJpY2UnKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3RfdHJhZGUnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2F2ZXJhZ2VfcHJpY2UnKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZV8xZGF5JyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyQWxsIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSByZXNwb25zZVsnZGF0YSddWydkYXRlJ107XG4gICAgICAgIGxldCB0aWNrZXJzID0gdGhpcy5vbWl0IChyZXNwb25zZVsnZGF0YSddLCAnZGF0ZScpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICB0aWNrZXJbJ2RhdGUnXSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckN1cnJlbmN5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIC8vIGEgd29ya2Fyb3VuZCBmb3IgdGhlaXIgYnVnIGluIGRhdGUgZm9ybWF0LCBob3VycyBhcmUgbm90IDAtcGFkZGVkXG4gICAgICAgIGxldCBbIHRyYW5zYWN0aW9uX2RhdGUsIHRyYW5zYWN0aW9uX3RpbWUgXSA9IHRyYWRlWyd0cmFuc2FjdGlvbl9kYXRlJ10uc3BsaXQgKCcgJyk7XG4gICAgICAgIGxldCB0cmFuc2FjdGlvbl90aW1lX3Nob3J0ID0gdHJhbnNhY3Rpb25fdGltZS5sZW5ndGggPCA4O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25fdGltZV9zaG9ydClcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWUgPSAnMCcgKyB0cmFuc2FjdGlvbl90aW1lO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYW5zYWN0aW9uX2RhdGUgKyAnICcgKyB0cmFuc2FjdGlvbl90aW1lKTtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYXNrJykgPyAnc2VsbCcgOiAnYnV5JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsndW5pdHNfdHJhZGVkJ10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJlY2VudFRyYW5zYWN0aW9uc0N1cnJlbmN5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgICAgICAnY291bnQnOiAxMDAsIC8vIG1heCA9IDEwMFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgcHJpdmF0ZSBBUEkgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICAvLyAgICAgbGV0IHByZWZpeCA9ICcnO1xuICAgICAgICAvLyAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgIC8vICAgICAgICAgcHJlZml4ID0gJ21hcmtldF8nO1xuICAgICAgICAvLyAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAvLyAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgLy8gICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIC8vICAgICAgICAgJ3ByaWNlJzogcHJpY2UgfHwgMCxcbiAgICAgICAgLy8gICAgICAgICAndHlwZSc6IHByZWZpeCArIHNpZGUsXG4gICAgICAgIC8vICAgICB9O1xuICAgICAgICAvLyAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ3JlYXRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAvLyAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAvLyAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoJ3NpZGUnIGluIHBhcmFtcyk7XG4gICAgICAgIGlmICghc2lkZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlciByZXF1aXJlcyBhIHNpZGUgcGFyYW1ldGVyIChzZWxsIG9yIGJ1eSknKTtcbiAgICAgICAgc2lkZSA9IChzaWRlID09ICdidXknKSA/ICdwdXJjaGFzZScgOiAnc2FsZXMnO1xuICAgICAgICBsZXQgY3VycmVuY3kgPSAoJ2N1cnJlbmN5JyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIWN1cnJlbmN5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIHJlcXVpcmVzIGEgY3VycmVuY3kgcGFyYW1ldGVyJyk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVDYW5jZWwgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICAgICAgJ3R5cGUnOiBwYXJhbXNbJ3NpZGUnXSxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IHBhcmFtc1snY3VycmVuY3knXSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgZW5kcG9pbnQgPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyBlbmRwb2ludDtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnZW5kcG9pbnQnOiBlbmRwb2ludCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBlbmRwb2ludCArIFwiXFwwXCIgKyBib2R5ICsgXCJcXDBcIiArIG5vbmNlO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBcGktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FwaS1TaWduJzogdGhpcy5kZWNvZGUgKHRoaXMuc3RyaW5nVG9CYXNlNjQgKHRoaXMuZW5jb2RlIChzaWduYXR1cmUpKSksXG4gICAgICAgICAgICAgICAgJ0FwaS1Ob25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJzAwMDAnKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBOb3RTdXBwb3J0ZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdGxpc2ggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0bGlzaCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdiaXRsaXNoJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdHQicsICdFVScsICdSVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYyNzUtZGNmYzZjMzAtNWVkMy0xMWU3LTgzOWQtMDBhODQ2Mzg1ZDBiLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2JpdGxpc2guY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdGxpc2guY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYml0bGlzaC5jb20vYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luc3RydW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvaGxjdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFpcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc19kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2hsY3YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXNfZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50c19vcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF90cmFkZXNfYnlfaWRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfYWxsX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3JlYXRlX2Jjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVhdGVfdGVtcGxhdGVfd2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVhdGVfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfYWNjb3VudHNfb3BlcmF0aW9uc19mcm9tX3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X2FjdGl2ZV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfYmNvZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X215X21hdGNoZXNfZnJvbV90cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9teV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfbXlfdHJhZHNfZnJvbV90cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9wYXltZW50X21ldGhvZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfcGF5bWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZGVlbV9jb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXNpZ24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ25pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2lnbm91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfb3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2J5X2lkJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWEJUJylcbiAgICAgICAgICAgIHJldHVybiAnQlRDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RSSycpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RTSCcpXG4gICAgICAgICAgICBjdXJyZW5jeSA9ICdEQVNIJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQYWlycyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1trZXlzW3BdXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ25hbWUnXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ21heCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdtaW4nKSxcbiAgICAgICAgICAgICdiaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXNrJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdmaXJzdCcpLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ByYycpLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzdW0nKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG5vdyA9IHRoaXMuc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbm93IC0gODY0MDAgKiAzMDsgLy8gbGFzdCAzMCBkYXlzXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IFsgc3RhcnQudG9TdHJpbmcgKCksIHVuZGVmaW5lZCBdO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wdWJsaWNQb3N0T2hsY3YgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndGltZV9yYW5nZSc6IGludGVydmFsLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNEZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyX2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VJbnQgKG9yZGVyYm9va1snbGFzdCddKSAvIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXAsICdiaWQnLCAnYXNrJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ2RpciddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnY3JlYXRlZCddIC8gMTAwMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNIaXN0b3J5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJfaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2xpc3QnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHJlc3BvbnNlKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSByZXNwb25zZVtjdXJyZW5jeV07XG4gICAgICAgICAgICBjdXJyZW5jeSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgLy8gaXNzdWUgIzQgYml0bGlzaCBuYW1lcyBEYXNoIGFzIERTSCwgaW5zdGVhZCBvZiBEQVNIXG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RTSCcpXG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnREFTSCc7XG4gICAgICAgICAgICBiYWxhbmNlW2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2Z1bmRzJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydob2xkZWQnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2lnbkluICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RTaWduaW4gKHtcbiAgICAgICAgICAgICdsb2dpbic6IHRoaXMubG9naW4sXG4gICAgICAgICAgICAncGFzc3dkJzogdGhpcy5wYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXJfaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Rpcic6IChzaWRlID09ICdidXknKSA/ICdiaWQnIDogJ2FzaycsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDcmVhdGVUcmFkZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbFRyYWRlICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAoY3VycmVuY3kgIT0gJ0JUQycpIHtcbiAgICAgICAgICAgIC8vIHRoZXkgZGlkIG5vdCBkb2N1bWVudCBvdGhlciB0eXBlcy4uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgY3VycmVudGx5IHN1cHBvcnRzIEJUQyB3aXRoZHJhd2FscyBvbmx5LCB1bnRpbCB0aGV5IGRvY3VtZW50IG90aGVyIGN1cnJlbmNpZXMuLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChhbW91bnQpLFxuICAgICAgICAgICAgJ2FjY291bnQnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3BheW1lbnRfbWV0aG9kJzogJ2JpdGNvaW4nLCAvLyB0aGV5IGRpZCBub3QgZG9jdW1lbnQgb3RoZXIgdHlwZXMuLi5cbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ21lc3NhZ2VfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoeyAndG9rZW4nOiB0aGlzLmFwaUtleSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdG1hcmtldCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRtYXJrZXQnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQml0TWFya2V0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdQTCcsICdFVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnOTBtJzogJzkwbScsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWQnLFxuICAgICAgICAgICAgICAgICcxdyc6ICc3ZCcsXG4gICAgICAgICAgICAgICAgJzFNJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnM00nOiAnM20nLFxuICAgICAgICAgICAgICAgICc2TSc6ICc2bScsXG4gICAgICAgICAgICAgICAgJzF5JzogJzF5JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY3MjU2LWE4NTU1MjAwLTVlZjktMTFlNy05NmZkLTQ2OWE2NWUyYjBiZC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldCcsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd3d3LmJpdG1hcmtldC5wbC9hcGkyLycsIC8vIGxhc3Qgc2xhc2ggaXMgY3JpdGljYWxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQucGwnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldC9kb2NzLnBocD9maWxlPWFwaV9wdWJsaWMuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQubmV0L2RvY3MucGhwP2ZpbGU9YXBpX3ByaXZhdGUuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0bWFya2V0LW5ldC9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2pzb24ve21hcmtldH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdqc29uL3ttYXJrZXR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnanNvbi97bWFya2V0fS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2pzb24vY3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vOTBtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vNmgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYXBocy97bWFya2V0fS8xZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ3JhcGhzL3ttYXJrZXR9LzdkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYXBocy97bWFya2V0fS8zbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ3JhcGhzL3ttYXJrZXR9LzZtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMXknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ2Rlc2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRpbmdkZXNrU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkaW5nZGVza0NvbmZpcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyeXB0b3RyYWRpbmdkZXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcnlwdG90cmFkaW5nZGVza1N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3J5cHRvdHJhZGluZ2Rlc2tDb25maXJtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdGaWF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd1BMTlBQJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd0ZpYXRGYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5MaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5PcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5DbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luQ2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5Nb2RpZnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbkJhbGFuY2VBZGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbkJhbGFuY2VSZW1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N3YXBMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzd2FwT3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3dhcENsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvUExOJzogeyAnaWQnOiAnQlRDUExOJywgJ3N5bWJvbCc6ICdCVEMvUExOJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9QTE4nOiB7ICdpZCc6ICdMVENQTE4nLCAnc3ltYm9sJzogJ0xUQy9QTE4nLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnTGl0ZU1pbmVYL0JUQyc6IHsgJ2lkJzogJ0xpdGVNaW5lWEJUQycsICdzeW1ib2wnOiAnTGl0ZU1pbmVYL0JUQycsICdiYXNlJzogJ0xpdGVNaW5lWCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDAxNSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDQ1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBiYWxhbmNlID0gZGF0YVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBkYXRhIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VbJ2F2YWlsYWJsZSddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbJ2F2YWlsYWJsZSddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydibG9ja2VkJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYmFsYW5jZVsnYmxvY2tlZCddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogb3JkZXJib29rWydiaWRzJ10sXG4gICAgICAgICAgICAnYXNrcyc6IG9yZGVyYm9va1snYXNrcyddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRKc29uTWFya2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICc5MG0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2Wyd0aW1lJ10gKiAxMDAwLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ29wZW4nXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnaGlnaCddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2Wydsb3cnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnY2xvc2UnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsndm9sJ10pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzkwbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwdWJsaWNHZXRHcmFwaHNNYXJrZXQnICsgdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV07XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2lkJyBpbiByZXNwb25zZVsnb3JkZXInXSlcbiAgICAgICAgICAgIHJlc3VsdFsnaWQnXSA9IHJlc3BvbnNlWydpZCddO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBpc0ZpYXQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRVVSJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1BMTicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0ZpYXQgKGN1cnJlbmN5KSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXdGaWF0JztcbiAgICAgICAgICAgIGlmICgnYWNjb3VudCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFsnYWNjb3VudCddID0gcGFyYW1zWydhY2NvdW50J107IC8vIGJhbmsgYWNjb3VudCBjb2RlIGZvciB3aXRoZHJhd2FsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhY2NvdW50IHBhcmFtZXRlciB0byB3aXRoZHJhdyBmaWF0IGN1cnJlbmN5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2FjY291bnQyJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0WydhY2NvdW50MiddID0gcGFyYW1zWydhY2NvdW50MiddOyAvLyBiYW5rIFNXSUZUIGNvZGUgKEVVUiBvbmx5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0VVUicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhY2NvdW50MiBwYXJhbWV0ZXIgdG8gd2l0aGRyYXcgRVVSJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3dpdGhkcmF3YWxfbm90ZScgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFsnd2l0aGRyYXdhbF9ub3RlJ10gPSBwYXJhbXNbJ3dpdGhkcmF3YWxfbm90ZSddOyAvLyBhIDEwLWNoYXJhY3RlciB1c2VyLXNwZWNpZmllZCB3aXRoZHJhd2FsIG5vdGUgKFBMTiBvbmx5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1BMTicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyB3aXRoZHJhd2FsX25vdGUgcGFyYW1ldGVyIHRvIHdpdGhkcmF3IFBMTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXcnO1xuICAgICAgICAgICAgcmVxdWVzdFsnYWRkcmVzcyddID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGggKyAnLmpzb24nLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAndG9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FQSS1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQVBJLUhhc2gnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdG1leCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRtZXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQml0TUVYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnU0MnLCAvLyBTZXljaGVsbGVzXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNW0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAndGVzdCc6ICdodHRwczovL3Rlc3RuZXQuYml0bWV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjMxOS1mNjUzYzZlNi01ZWQ0LTExZTctOTMzZC1mMGJjMzY5OWFlOGYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0bWV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20vYXBwL2FwaU92ZXJ2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9CaXRNRVgvYXBpLWNvbm5lY3RvcnMvdHJlZS9tYXN0ZXIvb2ZmaWNpYWwtaHR0cCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5ub3VuY2VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbm5vdW5jZW1lbnQvdXJnZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50L2FjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9hY3RpdmVBbmRJbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50L2FjdGl2ZUludGVydmFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9jb21wb3NpdGVJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9pbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN1cmFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlYWRlcmJvYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJCb29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlckJvb2svTDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZS9idWNrZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2NoZW1hJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzY2hlbWEvd2Vic29ja2V0SGVscCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2V0dGxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9idWNrZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQvY2hhbm5lbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQvY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGVjdXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbi90cmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2FmZmlsaWF0ZVN0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9jaGVja1JlZmVycmFsQ29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9jb21taXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2RlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL21hcmdpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9taW5XaXRoZHJhd2FsRmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXRIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FwaUtleS9kaXNhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXkvZW5hYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvYnVsaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsQWxsQWZ0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2Nsb3NlUG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2lzb2xhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2xldmVyYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9yaXNrTGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL3RyYW5zZmVyTWFyZ2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2NhbmNlbFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvY29uZmlybUVtYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2NvbmZpcm1FbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvY29uZmlybVdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZGlzYWJsZVRGQScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbG9nb3V0QWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3ByZWZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3JlcXVlc3RFbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcmVxdWVzdFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9idWxrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9hbGwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0SW5zdHJ1bWVudEFjdGl2ZUFuZEluZGljZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSAobWFya2V0WydzdGF0ZSddICE9ICdVbmxpc3RlZCcpO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0Wyd1bmRlcmx5aW5nJ107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGZ1dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZWRpY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBiYXNlcXVvdGUgPSBiYXNlICsgcXVvdGU7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN3YXAgPSAoaWQgPT0gYmFzZXF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGlmIChzd2FwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdzd2FwJztcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkLmluZGV4T2YgKCdCXycpID49IDApIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ByZWRpY3Rpb24nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdXR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnZnV0dXJlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYWtlciA9IG1hcmtldFsnbWFrZXJGZWUnXTtcbiAgICAgICAgICAgIGxldCB0YWtlciA9IG1hcmtldFsndGFrZXJGZWUnXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAgICAgJ3Nwb3QnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnc3dhcCc6IHN3YXAsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZSc6IGZ1dHVyZSxcbiAgICAgICAgICAgICAgICAncHJlZGljdGlvbic6IHByZWRpY3Rpb24sXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VXNlck1hcmdpbiAoeyAnY3VycmVuY3knOiAnYWxsJyB9KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHJlc3BvbnNlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlTWFyZ2luJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnYW1vdW50J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCVEMnKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYWNjb3VudFsnZnJlZSddICogMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYWNjb3VudFsndG90YWwnXSAqIDAuMDAwMDAwMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9va0wyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IFtdLFxuICAgICAgICAgICAgJ2Fza3MnOiBbXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgb3JkZXJib29rLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlcmJvb2tbb107XG4gICAgICAgICAgICBsZXQgc2lkZSA9IChvcmRlclsnc2lkZSddID09ICdTZWxsJykgPyAnYXNrcycgOiAnYmlkcyc7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbJ3NpemUnXTtcbiAgICAgICAgICAgIGxldCBwcmljZSA9IG9yZGVyWydwcmljZSddO1xuICAgICAgICAgICAgcmVzdWx0W3NpZGVdLnB1c2ggKFsgcHJpY2UsIGFtb3VudCBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGlmICghbWFya2V0WydhY3RpdmUnXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJzogc3ltYm9sICcgKyBzeW1ib2wgKyAnIGlzIGRlbGlzdGVkJyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnYmluU2l6ZSc6ICcxZCcsXG4gICAgICAgICAgICAncGFydGlhbCc6IHRydWUsXG4gICAgICAgICAgICAnY291bnQnOiAxLFxuICAgICAgICAgICAgJ3JldmVyc2UnOiB0cnVlLFxuICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVvdGVzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRRdW90ZUJ1Y2tldGVkIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IHF1b3Rlc0xlbmd0aCA9IHF1b3Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBxdW90ZSA9IHF1b3Rlc1txdW90ZXNMZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlQnVja2V0ZWQgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1swXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0IChxdW90ZVsnYmlkUHJpY2UnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAocXVvdGVbJ2Fza1ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnY2xvc2UnXSksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hvbWVOb3Rpb25hbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnZm9yZWlnbk5vdGlvbmFsJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9obGN2WydvcGVuJ10sXG4gICAgICAgICAgICBvaGxjdlsnaGlnaCddLFxuICAgICAgICAgICAgb2hsY3ZbJ2xvdyddLFxuICAgICAgICAgICAgb2hsY3ZbJ2Nsb3NlJ10sXG4gICAgICAgICAgICBvaGxjdlsndm9sdW1lJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIHNlbmQgSlNPTiBrZXkvdmFsdWUgcGFpcnMsIHN1Y2ggYXMge1wia2V5XCI6IFwidmFsdWVcIn1cbiAgICAgICAgLy8gZmlsdGVyIGJ5IGluZGl2aWR1YWwgZmllbGRzIGFuZCBkbyBhZHZhbmNlZCBxdWVyaWVzIG9uIHRpbWVzdGFtcHNcbiAgICAgICAgLy8gbGV0IGZpbHRlciA9IHsgJ2tleSc6ICd2YWx1ZScgfTtcbiAgICAgICAgLy8gc2VuZCBhIGJhcmUgc2VyaWVzIChlLmcuIFhCVSkgdG8gbmVhcmVzdCBleHBpcmluZyBjb250cmFjdCBpbiB0aGF0IHNlcmllc1xuICAgICAgICAvLyB5b3UgY2FuIGFsc28gc2VuZCBhIHRpbWVmcmFtZSwgZS5nLiBYQlU6bW9udGhseVxuICAgICAgICAvLyB0aW1lZnJhbWVzOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIGFuZCBiaXF1YXJ0ZXJseVxuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdiaW5TaXplJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgICAgICAncGFydGlhbCc6IHRydWUsICAgICAvLyB0cnVlID09IGluY2x1ZGUgeWV0LWluY29tcGxldGUgY3VycmVudCBiaW5zXG4gICAgICAgICAgICAvLyAnZmlsdGVyJzogZmlsdGVyLCAvLyBmaWx0ZXIgYnkgaW5kaXZpZHVhbCBmaWVsZHMgYW5kIGRvIGFkdmFuY2VkIHF1ZXJpZXNcbiAgICAgICAgICAgIC8vICdjb2x1bW5zJzogW10sICAgIC8vIHdpbGwgcmV0dXJuIGFsbCBjb2x1bW5zIGlmIG9taXR0ZWRcbiAgICAgICAgICAgIC8vICdzdGFydCc6IDAsICAgICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciByZXN1bHRzICh3dGY/KVxuICAgICAgICAgICAgLy8gJ3JldmVyc2UnOiBmYWxzZSwgLy8gdHJ1ZSA9PSBuZXdlc3QgZmlyc3RcbiAgICAgICAgICAgIC8vICdlbmRUaW1lJzogJycsICAgIC8vIGVuZGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIGxldCB5bWRobXMgPSB0aGlzLlltZEhNUyAoc2luY2UpO1xuICAgICAgICAgICAgbGV0IHltZGhtID0geW1kaG1zLnNsaWNlICgwLCAxNik7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydFRpbWUnXSA9IHltZGhtOyAvLyBzdGFydGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvdW50J10gPSBsaW1pdDsgLy8gZGVmYXVsdCAxMDBcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZUJ1Y2tldGVkICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAoJ3N5bWJvbCcgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydzeW1ib2wnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJkTWF0Y2hJRCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnc2l6ZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogdGhpcy5jYXBpdGFsaXplIChzaWRlKSxcbiAgICAgICAgICAgICdvcmRlclF0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdvcmRUeXBlJzogdGhpcy5jYXBpdGFsaXplICh0eXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJJRCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlT3JkZXIgKHsgJ29yZGVySUQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBpc0ZpYXQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRVVSJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1BMTicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAoY3VycmVuY3kgIT0gJ0JUQycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgc3Vwb3BydHMgQlRDIHdpdGhkcmF3YWxzIG9ubHksIG90aGVyIGN1cnJlbmNpZXMgY29taW5nIHNvb24uLi4nKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiAnWEJ0JywgLy8gdGVtcG9yYXJpbHlcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyAnb3RwVG9rZW4nOiAnMTIzNDU2JywgLy8gcmVxdWlyZXMgaWYgdHdvLWZhY3RvciBhdXRoIChPVFApIGlzIGVuYWJsZWRcbiAgICAgICAgICAgIC8vICdmZWUnOiAwLjAwMSwgLy8gYml0Y29pbiBuZXR3b3JrIGZlZVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VXNlclJlcXVlc3RXaXRoZHJhd2FsICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3RyYW5zYWN0SUQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keVswXSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2VbJ2Vycm9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gJy9hcGknICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgIHF1ZXJ5ICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHF1ZXJ5O1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnUE9TVCcpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gWyBtZXRob2QsIHF1ZXJ5LCBub25jZSwgYm9keSB8fCAnJ10uam9pbiAoJycpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdhcGktbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYXBpLWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdhcGktc2lnbmF0dXJlJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAocmVxdWVzdCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdHNvIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdHNvJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdHNvJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnTVgnLCAvLyBNZXhpY29cbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLCAvLyAzMCByZXF1ZXN0cyBwZXIgbWludXRlXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MycsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MzM1LTcxNWNlN2FhLTVlZDUtMTFlNy04OGE4LTE3M2EyN2JiMzBmZS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYml0c28uY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYml0c28uY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYml0c28uY29tL2FwaV9pbmZvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXZhaWxhYmxlX2Jvb2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50X3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZGluZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRpbmdzL3tmaWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nX2Rlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdreWNfZG9jdW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWRnZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZGdlci90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZGdlci9mZWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWRnZXIvZnVuZGluZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZGdlci93aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXhfYmFua19jb2RlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbl9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX3RyYWRlcy97b2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tvaWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFkZXMve3RpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMve3dpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlYml0X2NhcmRfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXRoZXJfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwaG9uZV9udW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bob25lX3ZlcmlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGhvbmVfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3BlaV93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMve29pZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9hbGwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0QXZhaWxhYmxlQm9va3MgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzWydwYXlsb2FkJ10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydwYXlsb2FkJ11baV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2Jvb2snXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZC50b1VwcGVyQ2FzZSAoKS5yZXBsYWNlICgnXycsICcvJyk7XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgbGV0IGxpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogcGFyc2VGbG9hdCAobWFya2V0WydtaW5pbXVtX2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWF4aW11bV9hbW91bnQnXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4nOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21pbmltdW1fcHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICdtYXgnOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21heGltdW1fcHJpY2UnXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21pbic6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWluaW11bV92YWx1ZSddKSxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWF4aW11bV92YWx1ZSddKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0WydtaW5pbXVtX2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB0aGlzLnByZWNpc2lvbkZyb21TdHJpbmcgKG1hcmtldFsnbWluaW11bV9wcmljZSddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbG90ID0gbGltaXRzWydhbW91bnQnXVsnbWluJ107XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IGxpbWl0cyxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydwYXlsb2FkJ11bJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2xvY2tlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBwYXJzZUZsb2F0IChiYWxhbmNlWyd0b3RhbCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlcmJvb2tbJ3VwZGF0ZWRfYXQnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdib29rJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsncGF5bG9hZCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydjcmVhdGVkX2F0J10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldCkge1xuICAgICAgICAgICAgaWYgKCdib29rJyBpbiB0cmFkZSlcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ2Jvb2snXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ21ha2VyX3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdib29rJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydwYXlsb2FkJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ21ham9yJzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydwYXlsb2FkJ11bJ29pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlT3JkZXJzICh7ICdvaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBxdWVyeSA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyBxdWVyeTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IFsgbm9uY2UsIG1ldGhvZCwgcXVlcnkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ICs9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocmVxdWVzdCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmFwaUtleSArICc6JyArIG5vbmNlICsgJzonICsgc2lnbmF0dXJlO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IFwiQml0c28gXCIgKyBhdXRoLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdHN0YW1wIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdHN0YW1wJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdHN0YW1wJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnR0InLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc4NjM3Ny04YzhhYjU3ZS01ZmU5LTExZTctOGVhNC0yYjA1YjZiY2NlZWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl9ob3VyL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZy1wYWlycy1pbmZvLycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2Uve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyX3RyYW5zYWN0aW9ucy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy9hbGwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX3N0YXR1cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXkvbWFya2V0L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGwve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbC9tYXJrZXQve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbHRjX3dpdGhkcmF3YWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsdGNfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V0aF93aXRoZHJhd2FsLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXRoX2FkZHJlc3MvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zlci10by1tYWluLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXItZnJvbS1tYWluLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAneHJwX3dpdGhkcmF3YWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd4cnBfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwvb3Blbi8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwvc3RhdHVzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbC9jYW5jZWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbl9hZGRyZXNzL25ldy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpcXVpZGF0aW9uX2FkZHJlc3MvaW5mby8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3YxJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luX2RlcG9zaXRfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VuY29uZmlybWVkX2J0Yy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fd2l0aGRyYXdhbC8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDAyNSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGluZ1BhaXJzSW5mbyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsndXJsX3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogbWFya2V0WydiYXNlX2RlY2ltYWxzJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0Wydjb3VudGVyX2RlY2ltYWxzJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IFsgY29zdCwgY3VycmVuY3kgXSA9IG1hcmtldFsnbWluaW11bV9vcmRlciddLnNwbGl0ICgnICcpO1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IChtYXJrZXRbJ3RyYWRpbmcnXSA9PSAnRW5hYmxlZCcpO1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogcGFyc2VGbG9hdCAoY29zdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9va1BhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyYm9va1sndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdkYXRlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICgnZGF0ZXRpbWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2RhdGV0aW1lJ10pO1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRldGltZSddKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAwKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnb3JkZXJfaWQnIGluIHRyYWRlKVxuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeV9wYWlyJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgaWYgKHRyYWRlWydjdXJyZW5jeV9wYWlyJ10gaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnY3VycmVuY3lfcGFpciddXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnNQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndGltZSc6ICdtaW51dGUnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGxvd2VyY2FzZSArICdfYmFsYW5jZSc7XG4gICAgICAgICAgICBsZXQgZnJlZSA9IGxvd2VyY2FzZSArICdfYXZhaWxhYmxlJztcbiAgICAgICAgICAgIGxldCB1c2VkID0gbG93ZXJjYXNlICsgJ19yZXNlcnZlZCc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChmcmVlIGluIGJhbGFuY2UpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtmcmVlXSk7XG4gICAgICAgICAgICBpZiAodXNlZCBpbiBiYWxhbmNlKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbdXNlZF0pO1xuICAgICAgICAgICAgaWYgKHRvdGFsIGluIGJhbGFuY2UpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbdG90YWxdKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgbWV0aG9kICs9ICdNYXJrZXQnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBtZXRob2QgKz0gJ1BhaXInO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlclN0YXR1cyAob3JkZXIpIHtcbiAgICAgICAgaWYgKChvcmRlclsnc3RhdHVzJ10gPT0gJ1F1ZXVlJykgfHwgKG9yZGVyWydzdGF0dXMnXSA9PSAnT3BlbicpKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnRmluaXNoZWQnKVxuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICByZXR1cm4gb3JkZXJbJ3N0YXR1cyddO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJTdGF0dXMgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyU3RhdHVzICh7ICdpZCc6IGlkIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyU3RhdHVzIChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiAnYWxsJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoeyAncGFpcic6IHBhaXIgfSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9wZW5PcmRlcnNQYWlyIChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJTdGF0dXMgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJztcbiAgICAgICAgaWYgKGFwaSAhPSAndjEnKVxuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmVuY29kZSAodGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0c3RhbXAxIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdHN0YW1wMScsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRzdGFtcCB2MScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0dCJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc4NjM3Ny04YzhhYjU3ZS01ZmU5LTExZTctOGVhNC0yYjA1YjZiY2NlZWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl9ob3VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V1cl91c2QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9hbGxfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bmNvbmZpcm1lZF9idGMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JpcHBsZV93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyaXBwbGVfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbF9yZXF1ZXN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjdXNkJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdidGNldXInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnRVVSL1VTRCc6IHsgJ2lkJzogJ2V1cnVzZCcsICdzeW1ib2wnOiAnRVVSL1VTRCcsICdiYXNlJzogJ0VVUicsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdYUlAvVVNEJzogeyAnaWQnOiAneHJwdXNkJywgJ3N5bWJvbCc6ICdYUlAvVVNEJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9FVVInOiB7ICdpZCc6ICd4cnBldXInLCAnc3ltYm9sJzogJ1hSUC9FVVInLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ3hycGJ0YycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdMVEMvVVNEJzogeyAnaWQnOiAnbHRjdXNkJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9FVVInOiB7ICdpZCc6ICdsdGNldXInLCAnc3ltYm9sJzogJ0xUQy9FVVInLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y2J0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdFVEgvVVNEJzogeyAnaWQnOiAnZXRodXNkJywgJ3N5bWJvbCc6ICdFVEgvVVNEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9FVVInOiB7ICdpZCc6ICdldGhldXInLCAnc3ltYm9sJzogJ0VUSC9FVVInLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aGJ0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPSAnQlRDL1VTRCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArIFwiIGZldGNoT3JkZXJCb29rIGRvZXNuJ3Qgc3VwcG9ydCBcIiArIHN5bWJvbCArICcsIHVzZSBpdCBmb3IgQlRDL1VTRCBvbmx5Jyk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPSAnQlRDL1VTRCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArIFwiIGZldGNoVGlja2VyIGRvZXNuJ3Qgc3VwcG9ydCBcIiArIHN5bWJvbCArICcsIHVzZSBpdCBmb3IgQlRDL1VTRCBvbmx5Jyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdkYXRlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICgnZGF0ZXRpbWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2RhdGV0aW1lJ10pO1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRldGltZSddKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAwKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnb3JkZXJfaWQnIGluIHRyYWRlKVxuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeV9wYWlyJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgaWYgKHRyYWRlWydjdXJyZW5jeV9wYWlyJ10gaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnY3VycmVuY3lfcGFpciddXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT0gJ0JUQy9VU0QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLnZlcnNpb24gKyBcIiBmZXRjaFRyYWRlcyBkb2Vzbid0IHN1cHBvcnQgXCIgKyBzeW1ib2wgKyAnLCB1c2UgaXQgZm9yIEJUQy9VU0Qgb25seScpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3RpbWUnOiAnbWludXRlJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBsb3dlcmNhc2UgKyAnX2JhbGFuY2UnO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBsb3dlcmNhc2UgKyAnX2F2YWlsYWJsZSc7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IGxvd2VyY2FzZSArICdfcmVzZXJ2ZWQnO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZSwgZnJlZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCB1c2VkLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCB0b3RhbCwgMC4wKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSAhPSAnbGltaXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLnZlcnNpb24gKyAnIGFjY2VwdHMgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgaWYgKHN5bWJvbCAhPSAnQlRDL1VTRCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgdjEgc3VwcG9ydHMgQlRDL1VTRCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXJTdGF0dXMgKG9yZGVyKSB7XG4gICAgICAgIGlmICgob3JkZXJbJ3N0YXR1cyddID09ICdRdWV1ZScpIHx8IChvcmRlclsnc3RhdHVzJ10gPT0gJ09wZW4nKSlcbiAgICAgICAgICAgIHJldHVybiAnb3Blbic7XG4gICAgICAgIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ0ZpbmlzaGVkJylcbiAgICAgICAgICAgIHJldHVybiAnY2xvc2VkJztcbiAgICAgICAgcmV0dXJuIG9yZGVyWydzdGF0dXMnXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyU3RhdHVzIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlclN0YXR1cyAoeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlclN0YXR1cyAocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTXlUcmFkZXMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBwYWlyID0gbWFya2V0ID8gbWFya2V0WydpZCddIDogJ2FsbCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHsgJ2lkJzogcGFpciB9LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3Blbk9yZGVyc0lkIChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXIgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5lbmNvZGUgKHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW52YWxpZE9yZGVyLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0dHJleCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXR0cmV4JyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdHRyZXgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MS4xJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoTXlUcmFkZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaENsb3NlZE9yZGVycyc6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoTXlUcmFkZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDdXJyZW5jaWVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICdvbmVNaW4nLFxuICAgICAgICAgICAgICAgICc1bSc6ICdmaXZlTWluJyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJ3RoaXJ0eU1pbicsXG4gICAgICAgICAgICAgICAgJzFoJzogJ2hvdXInLFxuICAgICAgICAgICAgICAgICcxZCc6ICdkYXknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYzNTItY2YwYjNjMjYtNWVkNS0xMWU3LTgyYjctZjM4MjZiN2E5N2Q4LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2JpdHRyZXguY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdhY2NvdW50JzogJ2h0dHBzOi8vYml0dHJleC5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ21hcmtldCc6ICdodHRwczovL2JpdHRyZXguY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICd2Mic6ICdodHRwczovL2JpdHRyZXguY29tL2FwaS92Mi4wL3B1YicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYml0dHJleC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdHRyZXguY29tL0hvbWUvQXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lm5wbWpzLm9yZy9wYWNrYWdlL25vZGUuYml0dHJleC5hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdHRyZXguY29tL0ZlZXMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zdXBwb3J0LmJpdHRyZXguY29tL2hjL2VuLXVzL2FydGljbGVzLzExNTAwMDE5OTY1MS1XaGF0LWZlZXMtZG9lcy1CaXR0cmV4LWNoYXJnZS0nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAndjInOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY2llcy9HZXRCVENQcmljZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L0dldFRpY2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvR2V0TGF0ZXN0VGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTWFya2V0cy9HZXRNYXJrZXRTdW1tYXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9HZXRMYXRlc3RUaWNrJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY2llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0aGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0c3VtbWFyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWNjb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdGFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2FsaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21hcmtldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5bWFya2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbG1hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAwMjUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvc3RUb1ByZWNpc2lvbiAoc3ltYm9sLCBjb3N0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRydW5jYXRlIChwYXJzZUZsb2F0IChjb3N0KSwgdGhpcy5tYXJrZXRzW3N5bWJvbF0ucHJlY2lzaW9uLnByaWNlKTtcbiAgICB9XG5cbiAgICBmZWVUb1ByZWNpc2lvbiAoc3ltYm9sLCBmZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ1bmNhdGUgKHBhcnNlRmxvYXQgKGZlZSksIHRoaXMubWFya2V0c1tzeW1ib2xdWydwcmVjaXNpb24nXVsncHJpY2UnXSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy52MkdldE1hcmtldHNHZXRNYXJrZXRTdW1tYXJpZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZVsncmVzdWx0J10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSByZXNwb25zZVsncmVzdWx0J11baV1bJ01hcmtldCddO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYW1vdW50TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ01pblRyYWRlU2l6ZSddLFxuICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByaWNlTGltaXRzID0geyAnbWluJzogdW5kZWZpbmVkLCAnbWF4JzogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBsZXQgbGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnRMaW1pdHMsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2VMaW1pdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG1hcmtldFsnSXNBY3RpdmUnXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiBsaW1pdHMsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSB0aGlzLmluZGV4QnkgKGJhbGFuY2VzLCAnQ3VycmVuY3knKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAoaW5kZXhlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gaW5kZXhlZFtpZF07XG4gICAgICAgICAgICBsZXQgZnJlZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0JhbGFuY2UnXSk7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHRvdGFsIC0gZnJlZTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGZyZWU7XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB1c2VkO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDUwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnLCAnUmF0ZScsICdRdWFudGl0eScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnVGltZVN0YW1wJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnSGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdMb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnVm9sdW1lJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQmFzZVZvbHVtZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jaWVzICgpO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSBjdXJyZW5jeVsnQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsIC8vIGRlZmF1bHQgcHJlY2lzaW9uLCB0b2RvOiBmaXggXCJtYWdpYyBjb25zdGFudHNcIlxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gdG9kbzogd2lsbCBuZWVkIHRvIHJldGhpbmsgdGhlIGZlZXNcbiAgICAgICAgICAgIC8vIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB3aXRoZHJhd2FsL2RlcG9zaXQgbWV0aG9kcyBhbmRcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudGlhdGVkIGZlZXMgZm9yIGVhY2ggcGFydGljdWxhciBtZXRob2RcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IGN1cnJlbmN5WydDdXJyZW5jeUxvbmcnXSxcbiAgICAgICAgICAgICAgICAnY29kZSc6IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCksXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGN1cnJlbmN5WydJc0FjdGl2ZSddLFxuICAgICAgICAgICAgICAgICdmZWVzJzogY3VycmVuY3lbJ1R4RmVlJ10sIC8vIHRvZG86IHJlZGVzaWduXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0c3VtbWFyaWVzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IFsgcXVvdGUsIGJhc2UgXSA9IGlkLnNwbGl0ICgnLScpO1xuICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHN1bW1hcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFkZVsnT3JkZXJUeXBlJ10gPT0gJ0JVWScpIHtcbiAgICAgICAgICAgIHNpZGUgPSAnYnV5JztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFkZVsnT3JkZXJUeXBlJ10gPT0gJ1NFTEwnKSB7XG4gICAgICAgICAgICBzaWRlID0gJ3NlbGwnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdJZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBpZCA9IHRyYWRlWydJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ1ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ1F1YW50aXR5J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0aGlzdG9yeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VbJ3Jlc3VsdCddICE9ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsncmVzdWx0J10sIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVHJhZGVzKCkgcmV0dXJuZWQgdW5kZWZpbmVkIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFkJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ1QnXSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBvaGxjdlsnTyddLFxuICAgICAgICAgICAgb2hsY3ZbJ0gnXSxcbiAgICAgICAgICAgIG9obGN2WydMJ10sXG4gICAgICAgICAgICBvaGxjdlsnQyddLFxuICAgICAgICAgICAgb2hsY3ZbJ1YnXSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICd0aWNrSW50ZXJ2YWwnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdtYXJrZXROYW1lJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnYyR2V0TWFya2V0R2V0VGlja3MgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlWydyZXN1bHQnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydtYXJrZXQnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldE9wZW5vcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXN1bHQnXSwgbWFya2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAnbWFya2V0R2V0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyB0eXBlO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3JhdGUnXSA9IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J11bJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldENhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAndXVpZCc6IGlkLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5zYWZlU3RyaW5nICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSwgJ21lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PSAnT1JERVJfTk9UX09QRU4nKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09ICdVVUlEX0lOVkFMSUQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIoKSBlcnJvcjogJyArIHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnT3JkZXJUeXBlJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHNpZGUgPSAob3JkZXJbJ09yZGVyVHlwZSddID09ICdMSU1JVF9CVVknKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBpZiAoJ1R5cGUnIGluIG9yZGVyKVxuICAgICAgICAgICAgc2lkZSA9IChvcmRlclsnVHlwZSddID09ICdMSU1JVF9CVVknKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICBpZiAob3JkZXJbJ0Nsb3NlZCddKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfSBlbHNlIGlmIChvcmRlclsnQ2FuY2VsSW5pdGlhdGVkJ10pIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnRXhjaGFuZ2UnIGluIG9yZGVyKVxuICAgICAgICAgICAgICAgIGlmIChvcmRlclsnRXhjaGFuZ2UnXSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnRXhjaGFuZ2UnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnT3BlbmVkJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnT3BlbmVkJ10pO1xuICAgICAgICBpZiAoJ1RpbWVTdGFtcCcgaW4gb3JkZXIpXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbW1pc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnQ29tbWlzc2lvbicgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbW1pc3Npb24gPSAnQ29tbWlzc2lvbic7XG4gICAgICAgIH0gZWxzZSBpZiAoJ0NvbW1pc3Npb25QYWlkJyBpbiBvcmRlcikge1xuICAgICAgICAgICAgY29tbWlzc2lvbiA9ICdDb21taXNzaW9uUGFpZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1pc3Npb24pIHtcbiAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKG9yZGVyW2NvbW1pc3Npb25dKSxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ0xpbWl0Jyk7XG4gICAgICAgIGxldCBjb3N0ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnUHJpY2UnKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1F1YW50aXR5Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdRdWFudGl0eVJlbWFpbmluZycsIDAuMCk7XG4gICAgICAgIGxldCBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgIGlmICghY29zdCkge1xuICAgICAgICAgICAgaWYgKHByaWNlICYmIGFtb3VudClcbiAgICAgICAgICAgICAgICBjb3N0ID0gcHJpY2UgKiBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmljZSkge1xuICAgICAgICAgICAgaWYgKGNvc3QgJiYgZmlsbGVkKVxuICAgICAgICAgICAgICAgIHByaWNlID0gY29zdCAvIGZpbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXZlcmFnZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1ByaWNlUGVyVW5pdCcpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydPcmRlclV1aWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldE9yZGVyICh7ICd1dWlkJzogaWQgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5zYWZlU3RyaW5nICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSwgJ21lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PSAnVVVJRF9JTlZBTElEJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXIoKSBlcnJvcjogJyArIHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ3Jlc3VsdCddKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnbWFya2V0J10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hY2NvdW50R2V0T3JkZXJoaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcnMgPSB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmVzdWx0J10sIG1hcmtldCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck9yZGVyc0J5U3ltYm9sIChvcmRlcnMsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeSAob3JkZXJzLCAnc3RhdHVzJywgJ2Nsb3NlZCcpO1xuICAgIH1cblxuICAgIGN1cnJlbmN5SWQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQkNIJylcbiAgICAgICAgICAgIHJldHVybiAnQkNDJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFjY291bnRHZXREZXBvc2l0YWRkcmVzcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5SWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2VbJ3Jlc3VsdCddLCAnQWRkcmVzcycpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsICdtZXNzYWdlJyk7XG4gICAgICAgIGxldCBzdGF0dXMgPSAnb2snO1xuICAgICAgICBpZiAoIWFkZHJlc3MgfHwgbWVzc2FnZSA9PSAnQUREUkVTU19HRU5FUkFUSU5HJylcbiAgICAgICAgICAgIHN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3lJZCxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdyZXN1bHQnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoJ3V1aWQnIGluIHJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3BvbnNlWydyZXN1bHQnXVsndXVpZCddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nO1xuICAgICAgICBpZiAoYXBpICE9ICd2MicpXG4gICAgICAgICAgICB1cmwgKz0gdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gYXBpICsgJy8nICsgbWV0aG9kLnRvTG93ZXJDYXNlICgpICsgcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFwaSA9PSAndjInKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgdXJsICs9IGFwaSArICcvJztcbiAgICAgICAgICAgIGlmICgoKGFwaSA9PSAnYWNjb3VudCcpICYmIChwYXRoICE9ICd3aXRoZHJhdycpKSB8fCAocGF0aCA9PSAnb3Blbm9yZGVycycpKVxuICAgICAgICAgICAgICAgIHVybCArPSBtZXRob2QudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aCArICc/JyArIHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHVybCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdhcGlzaWduJzogc2lnbmF0dXJlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keVswXSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10gPT0gJ01JTl9UUkFERV9SRVFVSVJFTUVOVF9OT1RfTUVUJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnQVBJS0VZX0lOVkFMSUQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnQUREUkVTU19HRU5FUkFUSU5HJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSBcIklOU1VGRklDSUVOVF9GVU5EU1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYmwzcCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdibDNwJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JMM1AnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ05MJywgJ0VVJyBdLCAvLyBOZXRoZXJsYW5kcywgRVVcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMScsXG4gICAgICAgICAgICAnY29tbWVudCc6ICdBbiBleGNoYW5nZSBtYXJrZXQgYnkgQml0b25pY05MJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4NTAxNzUyLTYwYzIxYjgyLTZmZWItMTFlNy04MThiLTA1NWVlNmQwZTc1NC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYmwzcC5ldScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYmwzcC5ldScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdG9uaWMubmwnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9CaXRvbmljTkwvYmwzcC1hcGkvdHJlZS9tYXN0ZXIvZG9jcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JsM3AuZXUvYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYml0b25pYy5ubC9lbi9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7bWFya2V0fS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L2RlcHRoL2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L29yZGVyL2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7bWFya2V0fS9tb25leS9vcmRlci9yZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L3RyYWRlcy9mZXRjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR0VOTUtUL21vbmV5L2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS9uZXdfZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHRU5NS1QvbW9uZXkvd2FsbGV0L2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS93aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgIC8vICdMVEMvRVVSJzogeyAnaWQnOiAnTFRDRVVSJywgJ3N5bWJvbCc6ICdMVEMvRVVSJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdFTk1LVE1vbmV5SW5mbyAoKTtcbiAgICAgICAgbGV0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGRhdGFbJ3dhbGxldHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBkYXRhIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2F2YWlsYWJsZScgaW4gYmFsYW5jZVtjdXJyZW5jeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2F2YWlsYWJsZSddWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICgnYmFsYW5jZScgaW4gYmFsYW5jZVtjdXJyZW5jeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydiYWxhbmNlJ11bJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NvdW50Wyd0b3RhbCddKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRbJ2ZyZWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBwYXJzZUJpZEFzayAoYmlkYXNrLCBwcmljZUtleSA9IDAsIGFtb3VudEtleSA9IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJpZGFza1sncHJpY2VfaW50J10gLyAxMDAwMDAuMCxcbiAgICAgICAgICAgIGJpZGFza1snYW1vdW50X2ludCddIC8gMTAwMDAwMDAwLjAsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldE9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ11bJzI0aCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsnZGF0ZSddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsnZGF0ZSddKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZV9pbnQnXSAvIDEwMDAwMC4wLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnRfaW50J10gLyAxMDAwMDAwMDAuMCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ11bJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdhbW91bnRfaW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZlZV9jdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICd0eXBlJzogKHNpZGUgPT0gJ2J1eScpID8gJ2JpZCcgOiAnYXNrJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZV9pbnQnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TWFya2V0TW9uZXlPcmRlckFkZCAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNYXJrZXRNb25leU9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcmVxdWVzdDtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSByZXF1ZXN0ICsgXCJcXDBcIiArIGJvZHk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHNlY3JldCwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdSZXN0LUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdSZXN0LVNpZ24nOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBiaXR0cmV4ID0gcmVxdWlyZSAoJy4vYml0dHJleC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJsZXV0cmFkZSBleHRlbmRzIGJpdHRyZXgge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JsZXV0cmFkZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdCbGV1dHJhZGUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdCUicsIC8vIEJyYXppbFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMzAzMDAwLWI2MDJkYmU2LTk3NmQtMTFlNy05NTZkLTM2YzUwNDljMDFlNy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9ibGV1dHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdhY2NvdW50JzogJ2h0dHBzOi8vYmxldXRyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAnbWFya2V0JzogJ2h0dHBzOi8vYmxldXRyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2JsZXV0cmFkZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9ibGV1dHJhZGUuY29tL2hlbHAvQVBJJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdBTEwnLFxuICAgICAgICAgICAgJ2RlcHRoJzogNTAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdidXknLCAnc2VsbCcsICdSYXRlJywgJ1F1YW50aXR5Jyk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYnRjYm94IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y2JveCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCdGNCb3gnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdKUCcsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMTI3NTgwMy00ZGY3NTVhOC1hYWExLTExZTctOWFiYi0xMWVjMmZhZDlmMmQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJ0Y2JveC5jby5qcC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjYm94LmNvLmpwLycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5idGNib3guY28uanAvaGVscC9hc20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FsbHRpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfYWRkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX3ZpZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0pQWSc6IHsgJ2lkJzogJ0JUQy9KUFknLCAnc3ltYm9sJzogJ0JUQy9KUFknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlID09ICdkYXNoJylcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2UgPSAnZHJrJztcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBsb3dlcmNhc2UgKyAnX2JhbGFuY2UnO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBsb3dlcmNhc2UgKyAnX2xvY2snO1xuICAgICAgICAgICAgaWYgKGZyZWUgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbZnJlZV0pO1xuICAgICAgICAgICAgaWYgKHVzZWQgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbdXNlZF0pO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbnVtU3ltYm9scyA9IHRoaXMuc3ltYm9scy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TeW1ib2xzID4gMSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvaW4nXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGwnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0QWxsdGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBudW1TeW1ib2xzID0gdGhpcy5zeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVN5bWJvbHMgPiAxKVxuICAgICAgICAgICAgcmVxdWVzdFsnY29pbiddID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbnVtU3ltYm9scyA9IHRoaXMuc3ltYm9scy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TeW1ib2xzID4gMSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvaW4nXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBudW1TeW1ib2xzID0gdGhpcy5zeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVN5bWJvbHMgPiAxKVxuICAgICAgICAgICAgcmVxdWVzdFsnY29pbiddID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVBZGQgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUNhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAoc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y2NoaW5hIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y2NoaW5hJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JUQ0NoaW5hJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MzY4LTQ2NWIzMjg2LTVlZDYtMTFlNy05YTExLTBmNjQ2N2UxZDgyYi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwbHVzJzogJ2h0dHBzOi8vcGx1cy1hcGkuYnRjY2hpbmEuY29tL21hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9kYXRhLmJ0Y2NoaW5hLmNvbS9kYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYnRjY2hpbmEuY29tL2FwaV90cmFkZV92MS5waHAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5idGNjaGluYS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYnRjY2hpbmEuY29tL2FwaWRvY3MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncGx1cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5ZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQnV5SWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCdXlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQnV5T3JkZXIyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCdXlTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbEljZWJlcmdPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbFN0b3BPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEFyY2hpdmVkT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEFyY2hpdmVkT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0SWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRJY2ViZXJnT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXREZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0RGVwdGgyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFN0b3BPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0V2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0V2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlcXVlc3RXaXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWxsSWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWxsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlbGxPcmRlcjInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlbGxTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9DTlknOiB7ICdpZCc6ICdidGNjbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNjbnknLCAnc3ltYm9sJzogJ0xUQy9DTlknLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNidGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9DTlknOiB7ICdpZCc6ICdiY2NjbnknLCAnc3ltYm9sJzogJ0JDSC9DTlknLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwbHVzJywgJ3BsdXMnOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9DTlknOiB7ICdpZCc6ICdldGhjbnknLCAnc3ltYm9sJzogJ0VUSC9DTlknLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwbHVzJywgJ3BsdXMnOiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnbWFya2V0JzogJ2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNba2V5XTtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCAoJ18nKTtcbiAgICAgICAgICAgIGxldCBpZCA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UgaW4gYmFsYW5jZXNbJ2JhbGFuY2UnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbJ2JhbGFuY2UnXVtsb3dlcmNhc2VdWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzWydmcm96ZW4nXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1snZnJvemVuJ11bbG93ZXJjYXNlXVsnYW1vdW50J10pO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ3VzZWQnXTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBjcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgbGV0IGZpZWxkID0gKG1hcmtldFsncGx1cyddKSA/ICdzeW1ib2wnIDogJ21hcmtldCc7XG4gICAgICAgIHJlcXVlc3RbZmllbGRdID0gbWFya2V0WydpZCddO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ2FwaSddICsgJ0dldE9yZGVyYm9vayc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKSxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydwcmV2X2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlclBsdXMgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ1RpbWVzdGFtcCddO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydMb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydCaWRQcmljZSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Fza1ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnT3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnUHJldkNscyddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydMYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnVm9sdW1lMjRIJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0WydhcGknXSArICdHZXRUaWNrZXInO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuY3JlYXRlTWFya2V0UmVxdWVzdCAobWFya2V0KTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbJ3RpY2tlciddO1xuICAgICAgICBpZiAobWFya2V0WydwbHVzJ10pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlclBsdXMgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZVBsdXMgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ3NpemUnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlc1BsdXMgKHRyYWRlcywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlVHJhZGVQbHVzICh0cmFkZXNbaV0sIG1hcmtldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ2FwaSddICsgJ0dldFRyYWRlJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZU1hcmtldFJlcXVlc3QgKG1hcmtldCk7XG4gICAgICAgIGlmIChtYXJrZXRbJ3BsdXMnXSkge1xuICAgICAgICAgICAgbGV0IG5vdyA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnRfdGltZSddID0gbm93IC0gODY0MDAgKiAxMDAwO1xuICAgICAgICAgICAgcmVxdWVzdFsnZW5kX3RpbWUnXSA9IG5vdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAncyc7IC8vIHRyYWRlcyB2cyB0cmFkZVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBpZiAobWFya2V0WydwbHVzJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzUGx1cyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdPcmRlcjInO1xuICAgICAgICBsZXQgb3JkZXIgPSB7fTtcbiAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgb3JkZXJbJ3BhcmFtcyddID0gWyB1bmRlZmluZWQsIGFtb3VudCwgaWQgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWydwYXJhbXMnXSA9IFsgcHJpY2UsIGFtb3VudCwgaWQgXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSBwYXJhbXNbJ21hcmtldCddOyAvLyBUT0RPIGZpeG1lXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFyYW1zJzogWyBpZCwgbWFya2V0IF0sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWljcm9zZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBwID0gW107XG4gICAgICAgICAgICBpZiAoJ3BhcmFtcycgaW4gcGFyYW1zKVxuICAgICAgICAgICAgICAgIHAgPSBwYXJhbXNbJ3BhcmFtcyddO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdwYXJhbXMnOiBwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHAgPSBwLmpvaW4gKCcsJyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IChcbiAgICAgICAgICAgICAgICAndG9uY2U9JyArIG5vbmNlICtcbiAgICAgICAgICAgICAgICAnJmFjY2Vzc2tleT0nICsgdGhpcy5hcGlLZXkgK1xuICAgICAgICAgICAgICAgICcmcmVxdWVzdG1ldGhvZD0nICsgbWV0aG9kLnRvTG93ZXJDYXNlICgpICtcbiAgICAgICAgICAgICAgICAnJmlkPScgKyBub25jZSArXG4gICAgICAgICAgICAgICAgJyZtZXRob2Q9JyArIHBhdGggK1xuICAgICAgICAgICAgICAgICcmcGFyYW1zPScgKyBwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHF1ZXJ5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTEnKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5hcGlLZXkgKyAnOicgKyBzaWduYXR1cmU7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyB0aGlzLnN0cmluZ1RvQmFzZTY0IChhdXRoKSxcbiAgICAgICAgICAgICAgICAnSnNvbi1ScGMtVG9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYnRjdHVyayA9IHJlcXVpcmUgKCcuL2J0Y3R1cmsuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBidGNleGNoYW5nZSBleHRlbmRzIGJ0Y3R1cmsge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y2V4Y2hhbmdlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JUQ0V4Y2hhbmdlJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnUEgnLCAvLyBQaGlsaXBwaW5lc1xuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MzA1Mi00YzkyOTExYS02NGFhLTExZTctOTZkOC1lYzZhYzM0MzU3NTcuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJ0Y2V4Y2hhbmdlLnBoL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5idGNleGNoYW5nZS5waCcsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vQlRDVHJhZGVyL2Jyb2tlci1hcGktZG9jcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9QSFAnOiB7ICdpZCc6ICdCVEMvUEhQJywgJ3N5bWJvbCc6ICdCVEMvUEhQJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BIUCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y21hcmtldHMgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYnRjbWFya2V0cycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCVEMgTWFya2V0cycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0FVJywgLy8gQXVzdHJhbGlhXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCwgLy8gbWFya2V0IGRhdGEgY2FjaGVkIGZvciAxIHNlY29uZCAodHJhZGVzIGNhY2hlZCBmb3IgMiBzZWNvbmRzKVxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjkxNDI5MTEtMGUxYWNmYzItN2Q1Yy0xMWU3LTk4YzQtMDdkOTUzMmIyOWQ3LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5idGNtYXJrZXRzLm5ldCcsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0Y21hcmtldHMubmV0LycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vQlRDTWFya2V0cy9BUEknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQve2lkfS90aWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQve2lkfS9vcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQve2lkfS90cmFkaW5nZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHRyYW5zZmVyL3dpdGhkcmF3Q3J5cHRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kdHJhbnNmZXIvd2l0aGRyYXdFRlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci90cmFkZS9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jcmVhdGVCYXRjaCcsIC8vIHRoZXkgcHJvbWlzZSBpdCdzIGNvbWluZyBzb29uLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvZGV0YWlsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvQVVEJzogeyAnaWQnOiAnQlRDL0FVRCcsICdzeW1ib2wnOiAnQlRDL0FVRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdMVEMvQVVEJzogeyAnaWQnOiAnTFRDL0FVRCcsICdzeW1ib2wnOiAnTFRDL0FVRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdFVEgvQVVEJzogeyAnaWQnOiAnRVRIL0FVRCcsICdzeW1ib2wnOiAnRVRIL0FVRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdFVEMvQVVEJzogeyAnaWQnOiAnRVRDL0FVRCcsICdzeW1ib2wnOiAnRVRDL0FVRCcsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdYUlAvQVVEJzogeyAnaWQnOiAnWFJQL0FVRCcsICdzeW1ib2wnOiAnWFJQL0FVRCcsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdCQ0gvQVVEJzogeyAnaWQnOiAnQkNIL0FVRCcsICdzeW1ib2wnOiAnQkNIL0FVRCcsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdBVUQnLCAnbWFrZXInOiAwLjAwODUsICd0YWtlcic6IDAuMDA4NSB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDL0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjIsICd0YWtlcic6IDAuMDAyMiB9LFxuICAgICAgICAgICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnRVRIL0JUQycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjIsICd0YWtlcic6IDAuMDAyMiB9LFxuICAgICAgICAgICAgICAgICdFVEMvQlRDJzogeyAnaWQnOiAnRVRDL0JUQycsICdzeW1ib2wnOiAnRVRDL0JUQycsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjIsICd0YWtlcic6IDAuMDAyMiB9LFxuICAgICAgICAgICAgICAgICdYUlAvQlRDJzogeyAnaWQnOiAnWFJQL0JUQycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjIsICd0YWtlcic6IDAuMDAyMiB9LFxuICAgICAgICAgICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAnQkNIL0JUQycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjIsICd0YWtlcic6IDAuMDAyMiB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBtdWx0aXBsaWVyID0gMTAwMDAwMDAwO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBwYXJzZUZsb2F0IChiYWxhbmNlWydiYWxhbmNlJ10gLyBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIGxldCB1c2VkID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsncGVuZGluZ0Z1bmRzJ10gLyBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnJlZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHVzZWQsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdGhpcy5zdW0gKGZyZWUsIHVzZWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldElkT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiZXN0QmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdEFzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdFByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lMjRoJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRJZFRpY2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0SWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAvLyAnc2luY2UnOiA1OTg2ODM0NTIzMSxcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMTAwMDAwMDAwOyAvLyBmb3IgcHJpY2UgYW5kIHZvbHVtZVxuICAgICAgICAvLyBkb2VzIEJUQyBNYXJrZXRzIHN1cHBvcnQgbWFya2V0IG9yZGVycyBhdCBhbGw/XG4gICAgICAgIGxldCBvcmRlclNpZGUgPSAoc2lkZSA9PSAnYnV5JykgPyAnQmlkJyA6ICdBc2snO1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyZWQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdpbnN0cnVtZW50JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgICAndm9sdW1lJzogYW1vdW50ICogbXVsdGlwbGllcixcbiAgICAgICAgICAgICdvcmRlclNpZGUnOiBvcmRlclNpZGUsXG4gICAgICAgICAgICAnb3JkZXJ0eXBlJzogdGhpcy5jYXBpdGFsaXplICh0eXBlKSxcbiAgICAgICAgICAgICdjbGllbnRSZXF1ZXN0SWQnOiB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ3JlYXRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVycyAoaWRzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJDYW5jZWwgKHsgJ29yZGVyX2lkcyc6IGlkcyB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FuY2VsT3JkZXJzIChbIGlkIF0pO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVyaSA9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHVyaSArIFwiXFxuXCIgKyBub25jZSArIFwiXFxuXCI7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ2FwaWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICd0aW1lc3RhbXAnOiBub25jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgICAgIGF1dGggKz0gYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHNlY3JldCwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnNbJ3NpZ25hdHVyZSddID0gdGhpcy5kZWNvZGUgKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYnRjdHJhZGV1YSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdidGN0cmFkZXVhJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JUQyBUcmFkZSBVQScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VBJywgLy8gVWtyYWluZSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAzMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk0MTQ4My03OWZjNzM1MC02MmQ5LTExZTctOWY2MS1hYzQ3ZjI4ZmNkOTYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYnRjLXRyYWRlLmNvbS51YS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9idGMtdHJhZGUuY29tLnVhJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMW9jWUEweU15X1JYZDU2MXNmRzNxRVBaODBreWxsMzZIVXh2Q1JlNUdiaEUvZWRpdCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlYWxzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMvc2VsbC97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL2J1eS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnamFwYW5fc3RhdC9oaWdoL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhc2sve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpZC97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5L3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteV9vcmRlcnMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL3N0YXR1cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1vdmUvb3JkZXIve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbC97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1VBSCc6IHsgJ2lkJzogJ2J0Y191YWgnLCAnc3ltYm9sJzogJ0JUQy9VQUgnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVUFIJywgJ3ByZWNpc2lvbic6IHsgJ3ByaWNlJzogMSB9LCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDAwMDAxIH19fSxcbiAgICAgICAgICAgICAgICAnRVRIL1VBSCc6IHsgJ2lkJzogJ2V0aF91YWgnLCAnc3ltYm9sJzogJ0VUSC9VQUgnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvVUFIJzogeyAnaWQnOiAnbHRjX3VhaCcsICdzeW1ib2wnOiAnTFRDL1VBSCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ0RPR0UvVUFIJzogeyAnaWQnOiAnZG9nZV91YWgnLCAnc3ltYm9sJzogJ0RPR0UvVUFIJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvVUFIJzogeyAnaWQnOiAnZGFzaF91YWgnLCAnc3ltYm9sJzogJ0RBU0gvVUFIJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ1NJQi9VQUgnOiB7ICdpZCc6ICdzaWJfdWFoJywgJ3N5bWJvbCc6ICdTSUIvVUFIJywgJ2Jhc2UnOiAnU0lCJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnS1JCL1VBSCc6IHsgJ2lkJzogJ2tyYl91YWgnLCAnc3ltYm9sJzogJ0tSQi9VQUgnLCAnYmFzZSc6ICdLUkInLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAgICAgICAgICdOVkMvVUFIJzogeyAnaWQnOiAnbnZjX3VhaCcsICdzeW1ib2wnOiAnTlZDL1VBSCcsICdiYXNlJzogJ05WQycsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNfYnRjJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnTlZDL0JUQyc6IHsgJ2lkJzogJ252Y19idGMnLCAnc3ltYm9sJzogJ05WQy9CVEMnLCAnYmFzZSc6ICdOVkMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdJVEkvVUFIJzogeyAnaWQnOiAnaXRpX3VhaCcsICdzeW1ib2wnOiAnSVRJL1VBSCcsICdiYXNlJzogJ0lUSScsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ0RPR0UvQlRDJzogeyAnaWQnOiAnZG9nZV9idGMnLCAnc3ltYm9sJzogJ0RPR0UvQlRDJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAnZGFzaF9idGMnLCAnc3ltYm9sJzogJ0RBU0gvQlRDJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4xIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzaWduSW4gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdEF1dGggKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBpZiAoJ2FjY291bnRzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGFjY291bnRzID0gcmVzcG9uc2VbJ2FjY291bnRzJ107XG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGFjY291bnRzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSBhY2NvdW50c1tiXTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBhY2NvdW50WydjdXJyZW5jeSddO1xuICAgICAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcGFyc2VGbG9hdCAoYWNjb3VudFsnYmFsYW5jZSddKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0ge1xuICAgICAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGJpZHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc0J1eVN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgYXNrcyA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzU2VsbFN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBbXSxcbiAgICAgICAgICAgICdhc2tzJzogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChiaWRzKSB7XG4gICAgICAgICAgICBpZiAoJ2xpc3QnIGluIGJpZHMpXG4gICAgICAgICAgICAgICAgb3JkZXJib29rWydiaWRzJ10gPSBiaWRzWydsaXN0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFza3MpIHtcbiAgICAgICAgICAgIGlmICgnbGlzdCcgaW4gYXNrcylcbiAgICAgICAgICAgICAgICBvcmRlcmJvb2tbJ2Fza3MnXSA9IGFza3NbJ2xpc3QnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnY3VycmVuY3lfdHJhZGUnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEphcGFuU3RhdEhpZ2hTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJCb29rIChzeW1ib2wpO1xuICAgICAgICBsZXQgYmlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbnVtQmlkcyA9IG9yZGVyYm9va1snYmlkcyddLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bUJpZHMgPiAwKVxuICAgICAgICAgICAgYmlkID0gb3JkZXJib29rWydiaWRzJ11bMF1bMF07XG4gICAgICAgIGxldCBhc2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1Bc2tzID0gb3JkZXJib29rWydhc2tzJ10ubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQXNrcyA+IDApXG4gICAgICAgICAgICBhc2sgPSBvcmRlcmJvb2tbJ2Fza3MnXVswXVswXTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0cmFkZXMnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogYmlkLFxuICAgICAgICAgICAgJ2Fzayc6IGFzayxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRpY2tlckxlbmd0aCA9IHRpY2tlci5sZW5ndGg7XG4gICAgICAgIGlmICh0aWNrZXJMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCAodGlja2VyTGVuZ3RoIC0gNDgsIDApO1xuICAgICAgICAgICAgZm9yIChsZXQgdCA9IHN0YXJ0OyB0IDwgdGlja2VyLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbmRsZSA9IHRpY2tlclt0XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFsnb3BlbiddID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ29wZW4nXSA9IGNhbmRsZVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiByZXN1bHRbJ2hpZ2gnXSA9PSAndW5kZWZpbmVkJykgfHwgKHJlc3VsdFsnaGlnaCddIDwgY2FuZGxlWzJdKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydoaWdoJ10gPSBjYW5kbGVbMl07XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0Wydsb3cnXSA9PSAndW5kZWZpbmVkJykgfHwgKHJlc3VsdFsnbG93J10gPiBjYW5kbGVbM10pKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ2xvdyddID0gY2FuZGxlWzNdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0WydiYXNlVm9sdW1lJ10gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnYmFzZVZvbHVtZSddID0gLWNhbmRsZVs1XTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnYmFzZVZvbHVtZSddIC09IGNhbmRsZVs1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGlja2VyTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJlc3VsdFsnY2xvc2UnXSA9IHRpY2tlcltsYXN0XVs0XTtcbiAgICAgICAgICAgIHJlc3VsdFsnYmFzZVZvbHVtZSddID0gLTEgKiByZXN1bHRbJ2Jhc2VWb2x1bWUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGNvbnZlcnRDeXJpbGxpY01vbnRoTmFtZVRvU3RyaW5nIChjeXJpbGxpYykge1xuICAgICAgICBsZXQgbW9udGhzID0gW1xuICAgICAgICAgICAgJ9GP0L3QstCw0YDRjycsXG4gICAgICAgICAgICAn0YTQtdCy0YDQsNC70Y8nLFxuICAgICAgICAgICAgJ9C80LDRgNGC0LAnLFxuICAgICAgICAgICAgJ9Cw0L/RgNC10LvRjycsXG4gICAgICAgICAgICAn0LzQsNGPJyxcbiAgICAgICAgICAgICfQuNGO0L3RjycsXG4gICAgICAgICAgICAn0LjRjtC70Y8nLFxuICAgICAgICAgICAgJ9Cw0LLQs9GD0YHRgtCwJyxcbiAgICAgICAgICAgICfRgdC10L3RgtGP0LHRgNGPJyxcbiAgICAgICAgICAgICfQvtC60YLRj9Cx0YDRjycsXG4gICAgICAgICAgICAn0L3QvtGP0LHRgNGPJyxcbiAgICAgICAgICAgICfQtNC10LrQsNCx0YDRjycsXG4gICAgICAgIF07XG4gICAgICAgIGxldCBtb250aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb250aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjeXJpbGxpYyA9PSBtb250aHNbaV0pIHtcbiAgICAgICAgICAgICAgICBtb250aCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIG1vbnRoID0gbW9udGgudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCA5KVxuICAgICAgICAgICAgICAgICAgICBtb250aCA9ICcwJyArIG1vbnRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb250aDtcbiAgICB9XG5cbiAgICBwYXJzZUN5cmlsbGljRGF0ZXRpbWUgKGN5cmlsbGljKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IGN5cmlsbGljLnNwbGl0ICgnICcpO1xuICAgICAgICBsZXQgZGF5ID0gcGFydHNbMF07XG4gICAgICAgIGxldCBtb250aCA9IHRoaXMuY29udmVydEN5cmlsbGljTW9udGhOYW1lVG9TdHJpbmcgKHBhcnRzWzFdKTtcbiAgICAgICAgaWYgKCFtb250aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBwYXJzZVRyYWRlKCkgdW5kZWZpbmVkIG1vbnRoIG5hbWU6ICcgKyBjeXJpbGxpYyk7XG4gICAgICAgIGxldCB5ZWFyID0gcGFydHNbMl07XG4gICAgICAgIGxldCBobXMgPSBwYXJ0c1s0XTtcbiAgICAgICAgbGV0IGhtc0xlbmd0aCA9IGhtcy5sZW5ndGg7XG4gICAgICAgIGlmIChobXNMZW5ndGggPT0gNykge1xuICAgICAgICAgICAgaG1zID0gJzAnICsgaG1zO1xuICAgICAgICB9XG4gICAgICAgIGxldCB5bWQgPSBbIHllYXIsIG1vbnRoLCBkYXkgXS5qb2luICgnLScpO1xuICAgICAgICBsZXQgeW1kaG1zID0geW1kICsgJ1QnICsgaG1zO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHltZGhtcyk7XG4gICAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCAtIDEwODAwMDAwOyAvLyBzZXJ2ZXIgcmVwb3J0cyBsb2NhbCBHTVQrMyB0aW1lLCBhZGp1c3QgdG8gVVRDXG4gICAgICAgIHJldHVybiB0aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZUN5cmlsbGljRGF0ZXRpbWUgKHRyYWRlWydwdWJfZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2FtbnRfdHJhZGUnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVhbHNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbaV1bJ2lkJ10gJSAyKSB7XG4gICAgICAgICAgICAgICAgdHJhZGVzLnB1c2ggKHJlc3BvbnNlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdJZCc7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdjdXJyZW5jeTEnOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJlbW92ZU9yZGVySWQgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsIC8vIHVudGlsIHRoZXkgZml4IHRoZWlyIHRpbWVzdGFtcFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvcGVuJyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1udF90cmFkZSddLFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IDAsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogdHJhZGVbJ2FtbnRfdHJhZGUnXSxcbiAgICAgICAgICAgICd0cmFkZXMnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3Blbk9yZGVycyByZXF1aXJlcyBhIHN5bWJvbCBwYXJhbScpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNeU9yZGVyc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gcmVzcG9uc2VbJ3lvdXJfb3Blbl9vcmRlcnMnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0KTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ291dF9vcmRlcl9pZCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gYm9keSArIHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAncHVibGljLWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdhcGktc2lnbic6IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGF1dGgpLCAnc2hhMjU2JyksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y3R1cmsgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYnRjdHVyaycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCVENUdXJrJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVFInLCAvLyBUdXJrZXlcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTI3MDktMThlMTU2NDYtNjRhMy0xMWU3LTlmYTItYjA5NTBlYzc3MTJmLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5idGN0dXJrLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjdHVyay5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ1RyYWRlci9icm9rZXItYXBpLWRvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvaGxjZGF0YScsIC8vID9sYXN0PUNPVU5UXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsICAgLy8gP2xhc3Q9Q09VTlQgKG1heCA1MClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJUcmFuc2FjdGlvbnMnLCAvLyA/b2Zmc2V0PTAmbGltaXQ9MjUmc29ydD1hc2NcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1RSWSc6IHsgJ2lkJzogJ0JUQ1RSWScsICdzeW1ib2wnOiAnQlRDL1RSWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdUUlknLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgICAgICAnRVRIL1RSWSc6IHsgJ2lkJzogJ0VUSFRSWScsICdzeW1ib2wnOiAnRVRIL1RSWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdUUlknLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ0VUSEJUQycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgYmFzZSA9IHtcbiAgICAgICAgICAgICdmcmVlJzogcmVzcG9uc2VbJ2JpdGNvaW5fYXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAndXNlZCc6IHJlc3BvbnNlWydiaXRjb2luX3Jlc2VydmVkJ10sXG4gICAgICAgICAgICAndG90YWwnOiByZXNwb25zZVsnYml0Y29pbl9iYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBxdW90ZSA9IHtcbiAgICAgICAgICAgICdmcmVlJzogcmVzcG9uc2VbJ21vbmV5X2F2YWlsYWJsZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiByZXNwb25zZVsnbW9uZXlfcmVzZXJ2ZWQnXSxcbiAgICAgICAgICAgICd0b3RhbCc6IHJlc3BvbnNlWydtb25leV9iYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzeW1ib2wgPSB0aGlzLnN5bWJvbHNbMF07XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgcmVzdWx0W21hcmtldFsnYmFzZSddXSA9IGJhc2U7XG4gICAgICAgIHJlc3VsdFttYXJrZXRbJ3F1b3RlJ11dID0gcXVvdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyU3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZlcmFnZSddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aWNrZXJbJ3BhaXInXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtzeW1ib2xdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5mZXRjaFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wgaW4gdGlja2VycylcbiAgICAgICAgICAgIHJlc3VsdCA9IHRpY2tlcnNbc3ltYm9sXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAvLyBsZXQgbWF4Q291bnQgPSA1MDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpclN5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvaGxjdlsnVGltZSddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9obGN2WydPcGVuJ10sXG4gICAgICAgICAgICBvaGxjdlsnSGlnaCddLFxuICAgICAgICAgICAgb2hsY3ZbJ0xvdyddLFxuICAgICAgICAgICAgb2hsY3ZbJ0Nsb3NlJ10sXG4gICAgICAgICAgICBvaGxjdlsnVm9sdW1lJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGFzdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T2hsY2RhdGEgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdUeXBlJzogKHNpZGUgPT0gJ2J1eScpID8gJ0J1eUJ0YycgOiAnU2VsQnRjJyxcbiAgICAgICAgICAgICdJc01hcmtldE9yZGVyJzogKHR5cGUgPT0gJ21hcmtldCcpID8gMSA6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsnVG90YWwnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnQW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnUHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ0Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09ICdidGN0cmFkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGlzIGFuIGFic3RyYWN0IGJhc2UgQVBJIGZvciBCVENFeGNoYW5nZSwgQlRDVHVyaycpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5hcGlLZXkgKyBub25jZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtUENLJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1gtU3RhbXAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnWC1TaWduYXR1cmUnOiB0aGlzLnN0cmluZ1RvQmFzZTY0KHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCBzZWNyZXQsICdzaGEyNTYnLCAnYmluYXJ5JykpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBidGN4IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y3gnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQlRDWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnSVMnLCAnVVMnLCAnRVUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCwgLy8gc3VwcG9ydCBpbiBlbmdsaXNoIGlzIHZlcnkgcG9vciwgdW5hYmxlIHRvIHRlbGwgcmF0ZSBsaW1pdHNcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2Mzg1LTlmZGNjOThjLTVlZDYtMTFlNy04ZjE0LTY2ZDVlNWNkNDdlNi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9idGMteC5pcy9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9idGMteC5pcycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2J0Yy14LmlzL2N1c3RvbS9hcGktZG9jdW1lbnQuaHRtbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3tpZH0ve2xpbWl0fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3tpZH0ve2xpbWl0fScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVkZWVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICdidGMvdXNkJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ2J0Yy9ldXInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VzW2N1cnJlbmN5XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoSWRMaW1pdCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnbGltaXQnOiAxMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Ftb3VudCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcklkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RpbWUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gJ2FzaycpID8gJ3NlbGwnIDogJ2J1eSc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZUlkTGltaXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnbGltaXQnOiAxMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0eXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXInXVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWwgKHsgJ29yZGVyJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHVybCArPSBhcGk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ01ldGhvZCc6IHBhdGgudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ05vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbmF0dXJlJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0ZXIgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYnRlcicsXG4gICAgICAgICAgICAnbmFtZSc6ICdCdGVyJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdWRycsICdDTicgXSwgLy8gQnJpdGlzaCBWaXJnaW4gSXNsYW5kcywgQ2hpbmFcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJzInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5ODA0NzktY2ZhMzE4OGMtNjM4Ny0xMWU3LTgxOTEtOTNmYzQxODRiYTVjLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2RhdGEuYnRlci5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYnRlci5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9idGVyLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2J0ZXIuY29tL2FwaTInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWlycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0aW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0bGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyQm9vay97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZUhpc3Rvcnkve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVIaXN0b3J5L3tpZH0ve3RpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV3QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdHNXaXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsQWxsT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0aW5mbyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsncGFpcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0KTtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbMF07XG4gICAgICAgICAgICBsZXQgZGV0YWlscyA9IG1hcmtldFtpZF07XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGRldGFpbHNbJ2RlY2ltYWxfcGxhY2VzJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogZGV0YWlsc1snZGVjaW1hbF9wbGFjZXMnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYW1vdW50TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBkZXRhaWxzWydtaW5fYW1vdW50J10sXG4gICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJpY2VMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudExpbWl0cyxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBwcmljZUxpbWl0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdtYWtlcic6IGRldGFpbHNbJ2ZlZSddIC8gMTAwLFxuICAgICAgICAgICAgICAgICd0YWtlcic6IGRldGFpbHNbJ2ZlZSddIC8gMTAwLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IGxpbWl0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKCdhdmFpbGFibGUnIGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZVsnYXZhaWxhYmxlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2xvY2tlZCcgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydsb2NrZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWydsb2NrZWQnXVtjdXJyZW5jeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gyNGhyJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRociddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2hlc3RCaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dlc3RBc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydwZXJjZW50Q2hhbmdlJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydxdW90ZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmFzZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2VJZCwgcXVvdGVJZCBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGJhc2VJZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHF1b3RlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0cylcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydkYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYWRlSUQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydyYXRlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdGhpcy5zYWZlRmxvYXQgKHRyYWRlLCAnYW1vdW50JyksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVIaXN0b3J5SWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyTnVtYmVyJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyTnVtYmVyJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcywgLy8gQWRkcmVzcyBtdXN0IGV4aXN0IGluIHlvdSBBZGRyZXNzQm9vayBpbiBzZWN1cml0eSBzZXR0aW5nc1xuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcHJlZml4ID0gKGFwaSA9PSAncHJpdmF0ZScpID8gKGFwaSArICcvJykgOiAnJztcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArIHRoaXMudmVyc2lvbiArICcvMS8nICsgcHJlZml4ICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0geyAnbm9uY2UnOiBub25jZSB9O1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddICE9ICd0cnVlJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ4aW50aCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdieGludGgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQlguaW4udGgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdUSCcsIC8vIFRoYWlsYW5kXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0MTItNTY3YjFlYjQtNWVkNy0xMWU3LTk0YTgtZmY2YTM4ODRmNmM1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2J4LmluLnRoL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2J4LmluLnRoJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYnguaW4udGgvaW5mby9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICcnLCAvLyB0aWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpbGxlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmlsbGdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaWxscGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLWlzc3VlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tYmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLW15aXNzdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbi1teWJpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLW15b3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLWV4ZXJjaXNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24taGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwtaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJpbmcgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3BhaXJpbmdfaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydzZWNvbmRhcnlfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncHJpbWFyeV9jdXJyZW5jeSddO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIC8vIHdoeSB3b3VsZCB0aGV5IHVzZSB0aHJlZSBsZXR0ZXJzIGluc3RlYWQgb2YgZm91ciBmb3IgY3VycmVuY3kgY29kZXNcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEQVMnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdET0cnKVxuICAgICAgICAgICAgcmV0dXJuICdET0dFJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2UpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ3RvdGFsJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY29kZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3JkZXJib29rJ11bJ2JpZHMnXVsnaGlnaGJpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29yZGVyYm9vayddWydhc2tzJ11bJ2hpZ2hiaWQnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfcHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydjaGFuZ2UnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV8yNGhvdXJzJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0IChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsndHJhZGVfZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdvcmRlcic6IHRyYWRlWydvcmRlcl9pZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0cmFkZV90eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncmF0ZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJpbmcnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFpcmluZyA9IHVuZGVmaW5lZDsgLy8gVE9ETyBmaXhtZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgICAgICAncGFpcmluZyc6IHBhaXJpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLyc7XG4gICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgdXJsICs9IHBhdGggKyAnLyc7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuYXBpS2V5ICsgbm9uY2UudG9TdHJpbmcgKCkgKyB0aGlzLnNlY3JldDtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChhdXRoKSwgJ3NoYTI1NicpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHR3b2ZhOiB0aGlzLnR3b2ZhLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY2NleCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjY2V4JyxcbiAgICAgICAgICAgICduYW1lJzogJ0MtQ0VYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdERScsICdFVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQzMy0xNjg4MWY5MC01ZWQ4LTExZTctOTJmOC0zZDkyY2M3NDdhNmMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAndGlja2Vycyc6ICdodHRwczovL2MtY2V4LmNvbS90JyxcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2MtY2V4LmNvbS90L2FwaV9wdWIuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYy1jZXguY29tL3QvYXBpLmh0bWwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2MtY2V4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2MtY2V4LmNvbS8/aWQ9YXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd0aWNrZXJzJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvaW5uYW1lcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZvbHVtZV97Y29pbn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlZGlzdHJpYnV0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzdW1tYXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0b3Blbm9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldG9yZGVyaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdJT1QnKVxuICAgICAgICAgICAgcmV0dXJuICdJb1Rjb2luJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCTEMnKVxuICAgICAgICAgICAgcmV0dXJuICdDcnlwdG9idWxsY29pbic7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWElEJylcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuYXRpb25hbERpYW1vbmQnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydyZXN1bHQnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGNvZGUpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydBdmFpbGFibGUnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ1BlbmRpbmcnXSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWydCYWxhbmNlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eScsICdzZWxsJywgJ1JhdGUnLCAnUXVhbnRpdHknKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndXBkYXRlZCddICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdHByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2ZyddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eXN1cHBvcnQnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnRpY2tlcnNHZXRQcmljZXMgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogdGlja2VycyB9O1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodXBwZXJjYXNlIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt1cHBlcmNhc2VdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSB1cHBlcmNhc2Uuc3BsaXQgKCctJyk7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudGlja2Vyc0dldE1hcmtldCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVGltZVN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ0lkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydPcmRlclR5cGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydRdWFudGl0eSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldGhpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiAnYm90aCcsXG4gICAgICAgICAgICAnZGVwdGgnOiAxMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZUdldCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgdHlwZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J11bJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZUdldENhbmNlbCAoeyAndXVpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMua2V5c29ydCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYSc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ2FwaWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdhcGlzaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAodXJsKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2EnOiAnZ2V0JyArIHBhdGgsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcykgKyAnLmpzb24nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3RpY2tlcnMnKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdWNjZXNzJ10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBjZXggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY2V4JyxcbiAgICAgICAgICAgICduYW1lJzogJ0NFWC5JTycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnR0InLCAnRVUnLCAnQ1knLCAnUlUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0NDItOGRkYzMzYjAtNWVkOC0xMWU3LThiOTgtZjc4NmFlZjBmM2M5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2NleC5pby9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jZXguaW8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9jZXguaW8vY2V4LWFwaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3VpZCc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5X2xpbWl0cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhc3RfcHJpY2Uve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZXMve2N1cnJlbmNpZXN9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2hsY3YvaGQve3l5eXltbWRkfS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2sve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMve2N1cnJlbmNpZXN9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfaGlzdG9yeS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29udmVydC97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaWNlX3N0YXRzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlX29yZGVyc19zdGF0dXMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmNoaXZlZF9vcmRlcnMve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcnMve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX3JlcGxhY2Vfb3JkZXIve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xvc2VfcG9zaXRpb24ve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X2FkZHJlc3MvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfbXlmZWUvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfb3JkZXIvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfb3JkZXJfdHgvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5fcG9zaXRpb24ve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbl9wb3NpdGlvbnMve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vfb3JkZXIve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lMaW1pdHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydkYXRhJ11bJ3BhaXJzJ10ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydkYXRhJ11bJ3BhaXJzJ11bcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3N5bWJvbDEnXSArICcvJyArIG1hcmtldFsnc3ltYm9sMiddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzogdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nIChtYXJrZXRbJ21pblByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAnYW1vdW50JzogLTEgKiBNYXRoLmxvZzEwIChtYXJrZXRbJ21pbkxvdFNpemUnXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldFsnbWluTG90U2l6ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnbWF4TG90U2l6ZSddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogcGFyc2VGbG9hdCAobWFya2V0WydtaW5QcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21heFByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ21pbkxvdFNpemVTMiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldWydvcmRlcnMnXSksXG4gICAgICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2tQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0gKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbMV0sXG4gICAgICAgICAgICBvaGxjdlsyXSxcbiAgICAgICAgICAgIG9obGN2WzNdLFxuICAgICAgICAgICAgb2hsY3ZbNF0sXG4gICAgICAgICAgICBvaGxjdls1XSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBpZiAoIXNpbmNlKVxuICAgICAgICAgICAgc2luY2UgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKSAtIDg2NDAwMDAwOyAvLyB5ZXN0ZXJkYXlcbiAgICAgICAgbGV0IHltZCA9IHRoaXMuWW1kIChzaW5jZSk7XG4gICAgICAgIHltZCA9IHltZC5zcGxpdCAoJy0nKTtcbiAgICAgICAgeW1kID0geW1kLmpvaW4gKCcnKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd5eXl5bW1kZCc6IHltZCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPaGxjdkhkWXl5eW1tZGRQYWlyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBrZXkgPSAnZGF0YScgKyB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXTtcbiAgICAgICAgbGV0IG9obGN2cyA9IEpTT04ucGFyc2UgKHJlc3BvbnNlW2tleV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAob2hsY3ZzLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGlzbzg2MDEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgndGltZXN0YW1wJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgICAgICBpc284NjAxID0gdGhpcy5pc284NjAxICh0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2b2x1bWUgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyk7XG4gICAgICAgIGxldCBoaWdoID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKTtcbiAgICAgICAgbGV0IGxvdyA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKTtcbiAgICAgICAgbGV0IGJpZCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKTtcbiAgICAgICAgbGV0IGFzayA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogaXNvODYwMSxcbiAgICAgICAgICAgICdoaWdoJzogaGlnaCxcbiAgICAgICAgICAgICdsb3cnOiBsb3csXG4gICAgICAgICAgICAnYmlkJzogYmlkLFxuICAgICAgICAgICAgJ2Fzayc6IGFzayxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnNDdXJyZW5jaWVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmNpZXMnOiBjdXJyZW5jaWVzLmpvaW4gKCcvJyksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aWNrZXJzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1t0XTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aWNrZXJbJ3BhaXInXS5yZXBsYWNlICgnOicsICcvJyk7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVIaXN0b3J5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3IgbWFya2V0IGJ1eSBDRVguaW8gcmVxdWlyZXMgdGhlIGFtb3VudCBvZiBxdW90ZSBjdXJyZW5jeSB0byBzcGVuZFxuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKCdGb3IgbWFya2V0IGJ1eSBvcmRlcnMgJyArIHRoaXMuaWQgKyBcIiByZXF1aXJlcyB0aGUgYW1vdW50IG9mIHF1b3RlIGN1cnJlbmN5IHRvIHNwZW5kLCB0byBjYWxjdWxhdGUgcHJvcGVyIGNvc3RzIGNhbGwgY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ21hcmtldCcsICdidXknLCBhbW91bnQsIHByaWNlKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50ICogcHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UGxhY2VPcmRlclBhaXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLnRvU3RyaW5nICgpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJbJ3RpbWUnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gb3JkZXJbJ3N5bWJvbDEnXSArICcvJyArIG9yZGVyWydzeW1ib2wyJ107XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0cylcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gb3JkZXJbJ3N0YXR1cyddO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdjZCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdjJykge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ2QnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwcmljZScpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnYW1vdW50Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwZW5kaW5nJyk7XG4gICAgICAgIGlmICghcmVtYWluaW5nKVxuICAgICAgICAgICAgcmVtYWluaW5nID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncmVtYWlucycpO1xuICAgICAgICBsZXQgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICd0YTonICsgbWFya2V0WydxdW90ZSddKTtcbiAgICAgICAgICAgIGxldCBiYXNlRmVlID0gJ2ZhOicgKyBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgICAgIGxldCBxdW90ZUZlZSA9ICdmYTonICsgbWFya2V0WydxdW90ZSddO1xuICAgICAgICAgICAgbGV0IGZlZVJhdGUgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICd0cmFkaW5nRmVlTWFrZXInKTtcbiAgICAgICAgICAgIGlmICghZmVlUmF0ZSlcbiAgICAgICAgICAgICAgICBmZWVSYXRlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAndHJhZGluZ0ZlZVRha2VyJywgZmVlUmF0ZSk7XG4gICAgICAgICAgICBpZiAoZmVlUmF0ZSlcbiAgICAgICAgICAgICAgICBmZWVSYXRlIC89IDEwMC4wOyAvLyBjb252ZXJ0IHRvIG1hdGhlbWF0aWNhbGx5LWNvcnJlY3QgcGVyY2VudGFnZSBjb2VmZmljaWVudHM6IDEuMCA9IDEwMCVcbiAgICAgICAgICAgIGlmIChiYXNlRmVlIGluIG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgZmVlID0ge1xuICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgYmFzZUZlZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXVvdGVGZWUgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgcXVvdGVGZWUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3N0KVxuICAgICAgICAgICAgY29zdCA9IHByaWNlICogZmlsbGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ2lkJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3RyYWRlcyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RPcGVuT3JkZXJzJztcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydwYWlyJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBtZXRob2QgKz0gJ1BhaXInO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9yZGVyc1tpXSA9IHRoaXMuZXh0ZW5kIChvcmRlcnNbaV0sIHsgJ3N0YXR1cyc6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAob3JkZXJzLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmV0dXJuZWQgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZSA9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoJ29rJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ29rJ10gPT0gJ29rJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHpiID0gcmVxdWlyZSAoJy4vemIuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBjaGJ0YyBleHRlbmRzIHpiIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjaGJ0YycsXG4gICAgICAgICAgICAnbmFtZSc6ICdDSEJUQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjg1NTU2NTktZjAwNDBkYzItNzEwOS0xMWU3LTlkOTktNjg4YTQzOGJmOWY0LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwOi8vYXBpLmNoYnRjLmNvbS9kYXRhJywgLy8gbm8gaHR0cHMgZm9yIHB1YmxpYyBBUElcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly90cmFkZS5jaGJ0Yy5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly90cmFkZS5jaGJ0Yy5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmNoYnRjLmNvbS9pL2RldmVsb3BlcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRNYXJrZXRGaWVsZE5hbWUgKCkge1xuICAgICAgICByZXR1cm4gJ2N1cnJlbmN5JztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ0JUQy9DTlknOiB7ICdpZCc6ICdidGNfY255JywgJ3N5bWJvbCc6ICdCVEMvQ05ZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICdMVEMvQ05ZJzogeyAnaWQnOiAnbHRjX2NueScsICdzeW1ib2wnOiAnTFRDL0NOWScsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICAgICAnRVRIL0NOWSc6IHsgJ2lkJzogJ2V0aF9jbnknLCAnc3ltYm9sJzogJ0VUSC9DTlknLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgJ0VUQy9DTlknOiB7ICdpZCc6ICdldGNfY255JywgJ3N5bWJvbCc6ICdFVEMvQ05ZJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICdCVFMvQ05ZJzogeyAnaWQnOiAnYnRzX2NueScsICdzeW1ib2wnOiAnQlRTL0NOWScsICdiYXNlJzogJ0JUUycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICAgICAvLyAnRU9TL0NOWSc6IHsgJ2lkJzogJ2Vvc19jbnknLCAnc3ltYm9sJzogJ0VPUy9DTlknLCAnYmFzZSc6ICdFT1MnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgJ0JDSC9DTlknOiB7ICdpZCc6ICdiY2NfY255JywgJ3N5bWJvbCc6ICdCQ0gvQ05ZJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICdIU1IvQ05ZJzogeyAnaWQnOiAnaHNyX2NueScsICdzeW1ib2wnOiAnSFNSL0NOWScsICdiYXNlJzogJ0hTUicsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICAgICAnUVRVTS9DTlknOiB7ICdpZCc6ICdxdHVtX2NueScsICdzeW1ib2wnOiAnUVRVTS9DTlknLCAnYmFzZSc6ICdRVFVNJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGZveGJpdCA9IHJlcXVpcmUgKCcuL2ZveGJpdC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNoaWxlYml0IGV4dGVuZHMgZm94Yml0IHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjaGlsZWJpdCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdDaGlsZUJpdCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NMJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkxNDE0LTEyOThmMGQ4LTY0N2YtMTFlNy05YzQwLWQ1NjQwOTI2NjMzNi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY2hpbGViaXQubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBOb3RTdXBwb3J0ZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNvaW5jaGVjayBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjb2luY2hlY2snLFxuICAgICAgICAgICAgJ25hbWUnOiAnY29pbmNoZWNrJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdKUCcsICdJRCcgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0NjQtM2I1YzNjNzQtNWVkOS0xMWU3LTg0MGUtMzFiMzI5NjhlMWRhLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2NvaW5jaGVjay5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbmNoZWNrLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2NvaW5jaGVjay5jb20vZG9jdW1lbnRzL2V4Y2hhbmdlL2FwaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy9yYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmF0ZS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cy9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cy9sZXZlcmFnZV9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYW5rX2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0X21vbmV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9vcmRlcnMvb3BlbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy90cmFuc2FjdGlvbnNfcGFnaW5hdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvbGV2ZXJhZ2UvcG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kaW5nL2JvcnJvd3MvbWF0Y2hlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VuZF9tb25leScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFua19hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdF9tb25leS97aWR9L2Zhc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdHJhbnNmZXJzL3RvX2xldmVyYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFuc2ZlcnMvZnJvbV9sZXZlcmFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVuZGluZy9ib3Jyb3dzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kaW5nL2JvcnJvd3Mve2lkfS9yZXBheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VuZF9tb25leScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYW5rX2FjY291bnRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd3Mve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0pQWSc6IHsgJ2lkJzogJ2J0Y19qcHknLCAnc3ltYm9sJzogJ0JUQy9KUFknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSlBZJyB9LCAvLyB0aGUgb25seSByZWFsIHBhaXJcbiAgICAgICAgICAgICAgICAvLyAnRVRIL0pQWSc6IHsgJ2lkJzogJ2V0aF9qcHknLCAnc3ltYm9sJzogJ0VUSC9KUFknLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdFVEMvSlBZJzogeyAnaWQnOiAnZXRjX2pweScsICdzeW1ib2wnOiAnRVRDL0pQWScsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0RBTy9KUFknOiB7ICdpZCc6ICdkYW9fanB5JywgJ3N5bWJvbCc6ICdEQU8vSlBZJywgJ2Jhc2UnOiAnREFPJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnTFNLL0pQWSc6IHsgJ2lkJzogJ2xza19qcHknLCAnc3ltYm9sJzogJ0xTSy9KUFknLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdGQ1QvSlBZJzogeyAnaWQnOiAnZmN0X2pweScsICdzeW1ib2wnOiAnRkNUL0pQWScsICdiYXNlJzogJ0ZDVCcsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1hNUi9KUFknOiB7ICdpZCc6ICd4bXJfanB5JywgJ3N5bWJvbCc6ICdYTVIvSlBZJywgJ2Jhc2UnOiAnWE1SJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnUkVQL0pQWSc6IHsgJ2lkJzogJ3JlcF9qcHknLCAnc3ltYm9sJzogJ1JFUC9KUFknLCAnYmFzZSc6ICdSRVAnLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdYUlAvSlBZJzogeyAnaWQnOiAneHJwX2pweScsICdzeW1ib2wnOiAnWFJQL0pQWScsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1pFQy9KUFknOiB7ICdpZCc6ICd6ZWNfanB5JywgJ3N5bWJvbCc6ICdaRUMvSlBZJywgJ2Jhc2UnOiAnWkVDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnWEVNL0pQWSc6IHsgJ2lkJzogJ3hlbV9qcHknLCAnc3ltYm9sJzogJ1hFTS9KUFknLCAnYmFzZSc6ICdYRU0nLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdMVEMvSlBZJzogeyAnaWQnOiAnbHRjX2pweScsICdzeW1ib2wnOiAnTFRDL0pQWScsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0RBU0gvSlBZJzogeyAnaWQnOiAnZGFzaF9qcHknLCAnc3ltYm9sJzogJ0RBU0gvSlBZJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0VUSC9CVEMnOiB7ICdpZCc6ICdldGhfYnRjJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnRVRDL0JUQyc6IHsgJ2lkJzogJ2V0Y19idGMnLCAnc3ltYm9sJzogJ0VUQy9CVEMnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdMU0svQlRDJzogeyAnaWQnOiAnbHNrX2J0YycsICdzeW1ib2wnOiAnTFNLL0JUQycsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0ZDVC9CVEMnOiB7ICdpZCc6ICdmY3RfYnRjJywgJ3N5bWJvbCc6ICdGQ1QvQlRDJywgJ2Jhc2UnOiAnRkNUJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnWE1SL0JUQyc6IHsgJ2lkJzogJ3htcl9idGMnLCAnc3ltYm9sJzogJ1hNUi9CVEMnLCAnYmFzZSc6ICdYTVInLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdSRVAvQlRDJzogeyAnaWQnOiAncmVwX2J0YycsICdzeW1ib2wnOiAnUkVQL0JUQycsICdiYXNlJzogJ1JFUCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1hSUC9CVEMnOiB7ICdpZCc6ICd4cnBfYnRjJywgJ3N5bWJvbCc6ICdYUlAvQlRDJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnWkVDL0JUQyc6IHsgJ2lkJzogJ3plY19idGMnLCAnc3ltYm9sJzogJ1pFQy9CVEMnLCAnYmFzZSc6ICdaRUMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdYRU0vQlRDJzogeyAnaWQnOiAneGVtX2J0YycsICdzeW1ib2wnOiAnWEVNL0JUQycsICdiYXNlJzogJ1hFTScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNfYnRjJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnREFTSC9CVEMnOiB7ICdpZCc6ICdkYXNoX2J0YycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudHNCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZSBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2VdKTtcbiAgICAgICAgICAgIGxldCByZXNlcnZlZCA9IGxvd2VyY2FzZSArICdfcmVzZXJ2ZWQnO1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW3Jlc2VydmVkXSk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvSlBZJylcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJCb29rICgpIHN1cHBvcnRzIEJUQy9KUFkgb25seScpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2tzIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvSlBZJylcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VyICgpIHN1cHBvcnRzIEJUQy9KUFkgb25seScpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2NyZWF0ZWRfYXQnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ29yZGVyX3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydyYXRlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvSlBZJylcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoVHJhZGVzICgpIHN1cHBvcnRzIEJUQy9KUFkgb25seScpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHByZWZpeCA9ICcnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBsZXQgb3JkZXJfdHlwZSA9IHR5cGUgKyAnXycgKyBzaWRlO1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IG9yZGVyX3R5cGU7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gKHNpZGUgPT0gJ2J1eScpID8gKG9yZGVyX3R5cGUgKyAnXycpIDogJyc7XG4gICAgICAgICAgICBvcmRlcltwcmVmaXggKyAnYW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gc2lkZTtcbiAgICAgICAgICAgIG9yZGVyWydyYXRlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RXhjaGFuZ2VPcmRlcnMgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVFeGNoYW5nZU9yZGVyc0lkICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0IChxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybCArIChib2R5IHx8ICcnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FDQ0VTUy1OT05DRSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdBQ0NFU1MtU0lHTkFUVVJFJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdWNjZXNzJ10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBjb2luZmxvb3IgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY29pbmZsb29yJyxcbiAgICAgICAgICAgICduYW1lJzogJ2NvaW5mbG9vcicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVUsnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjgyNDYwODEtNjIzZmMxNjQtNmExYy0xMWU3LTkxM2YtYmFjMGQ1NTc2YzkwLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3dlYmFwaS5jb2luZmxvb3IuY28udWs6ODA5MC9iaXN0JyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmNvaW5mbG9vci5jby51aycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jb2luZmxvb3IvYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmNvaW5mbG9vci5jby51ay9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3VpZCc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vdGlja2VyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9vcmRlcl9ib29rLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS90cmFuc2FjdGlvbnMvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L2JhbGFuY2UvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L3VzZXJfdHJhbnNhY3Rpb25zLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9vcGVuX29yZGVycy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vY2FuY2VsX29yZGVyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9idXkvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L3NlbGwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L2J1eV9tYXJrZXQvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L3NlbGxfbWFya2V0LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9lc3RpbWF0ZV9zZWxsX21hcmtldC8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vZXN0aW1hdGVfYnV5X21hcmtldC8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9HQlAnOiB7ICdpZCc6ICdYQlQvR0JQJywgJ3N5bWJvbCc6ICdCVEMvR0JQJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0dCUCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ1hCVC9FVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnWEJUL1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9QTE4nOiB7ICdpZCc6ICdYQlQvUExOJywgJ3N5bWJvbCc6ICdCVEMvUExOJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0dCUCc6IHsgJ2lkJzogJ0JDSC9HQlAnLCAnc3ltYm9sJzogJ0JDSC9HQlAnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnR0JQJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3N5bWJvbCcgaW4gcGFyYW1zKVxuICAgICAgICAgICAgc3ltYm9sID0gcGFyYW1zWydzeW1ib2wnXTtcbiAgICAgICAgaWYgKCdpZCcgaW4gcGFyYW1zKVxuICAgICAgICAgICAgc3ltYm9sID0gcGFyYW1zWydpZCddO1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaEJhbGFuY2UgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW0nKTtcbiAgICAgICAgLy8gdG9kbyBwYXJzZSBiYWxhbmNlXG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0SWRCYWxhbmNlICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmV3cml0ZSB0byBnZXQgdGhlIHRpbWVzdGFtcCBmcm9tIEhUVFAgaGVhZGVyc1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgdndhcCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2d2FwJyk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkVHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHsgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSB9O1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0SWQnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydxdWFudGl0eSddID0gYW1vdW50O1xuICAgICAgICAgICAgbWV0aG9kICs9ICdNYXJrZXQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdElkQ2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBjdXJsIC1rIC11ICdbVXNlciBJRF0vW0FQSSBrZXldOltQYXNzcGhyYXNlXScgaHR0cHM6Ly93ZWJhcGkuY29pbmZsb29yLmNvLnVrOjgwOTAvYmlzdC9YQlQvR0JQL2JhbGFuY2UvXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy51aWQgKyAnLycgKyB0aGlzLmFwaUtleSArICc6JyArIHRoaXMucGFzc3dvcmQ7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAoYXV0aCk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNvaW5naSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjb2luZ2knLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ29pbmdpJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ1BBJywgJ0JHJywgJ0NOJywgJ1VTJyBdLCAvLyBQYW5hbWEsIEJ1bGdhcmlhLCBDaGluYSwgVVNcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjg2MTk3MDctNWM5MjMyYTgtNzIxMi0xMWU3LTg2ZDYtOThmZTVkMTVjYzZlLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2luZ2kuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbmdpLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwOi8vZG9jcy5jb2luZ2kuYXBpYXJ5LmlvLycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAnY3VycmVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci1ib29rL3twYWlyfS97YXNrQ291bnR9L3tiaWRDb3VudH0ve2RlcHRofScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL3twYWlyfS97bWF4Q291bnR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcyNGhvdXItcm9sbGluZy1hZ2dyZWdhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndXNlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWRkLW9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwtb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVhdGUtY3J5cHRvLXdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdG9kbyBhZGQgZmV0Y2hNYXJrZXRzXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Yy1idGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdQUEMvQlRDJzogeyAnaWQnOiAncHBjLWJ0YycsICdzeW1ib2wnOiAnUFBDL0JUQycsICdiYXNlJzogJ1BQQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0RPR0UvQlRDJzogeyAnaWQnOiAnZG9nZS1idGMnLCAnc3ltYm9sJzogJ0RPR0UvQlRDJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ1ZUQy9CVEMnOiB7ICdpZCc6ICd2dGMtYnRjJywgJ3N5bWJvbCc6ICdWVEMvQlRDJywgJ2Jhc2UnOiAnVlRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnRlRDL0JUQyc6IHsgJ2lkJzogJ2Z0Yy1idGMnLCAnc3ltYm9sJzogJ0ZUQy9CVEMnLCAnYmFzZSc6ICdGVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdOTUMvQlRDJzogeyAnaWQnOiAnbm1jLWJ0YycsICdzeW1ib2wnOiAnTk1DL0JUQycsICdiYXNlJzogJ05NQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAnZGFzaC1idGMnLCAnc3ltYm9sJzogJ0RBU0gvQlRDJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBsb3dlcmNhc2VDdXJyZW5jaWVzID0gW107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxvd2VyY2FzZUN1cnJlbmNpZXMucHVzaCAoY3VycmVuY3kudG9Mb3dlckNhc2UgKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMudXNlclBvc3RCYWxhbmNlICh7XG4gICAgICAgICAgICAnY3VycmVuY2llcyc6IGxvd2VyY2FzZUN1cnJlbmNpZXMuam9pbiAoJywnKVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXVsnbmFtZSddO1xuICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBiYWxhbmNlWydibG9ja2VkJ10gKyBiYWxhbmNlWydpbk9yZGVycyddICsgYmFsYW5jZVsnd2l0aGRyYXdpbmcnXSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5jdXJyZW50R2V0T3JkZXJCb29rUGFpckFza0NvdW50QmlkQ291bnREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2Fza0NvdW50JzogNTEyLCAvLyBtYXhpbXVtIHJldHVybmVkIG51bWJlciBvZiBhc2tzIDEtNTEyXG4gICAgICAgICAgICAnYmlkQ291bnQnOiA1MTIsIC8vIG1heGltdW0gcmV0dXJuZWQgbnVtYmVyIG9mIGJpZHMgMS01MTJcbiAgICAgICAgICAgICdkZXB0aCc6IDMyLCAvLyBtYXhpbXVtIG51bWJlciBvZiBkZXB0aCByYW5nZSBzdGVwcyAxLTMyXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYmFzZUFtb3VudCcpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRpY2tlclsnaGlnaCddLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlclsnbG93J10sXG4gICAgICAgICAgICAnYmlkJzogdGlja2VyWydoaWdoZXN0QmlkJ10sXG4gICAgICAgICAgICAnYXNrJzogdGlja2VyWydsb3dlc3RBc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aWNrZXJbJ2Jhc2VWb2x1bWUnXSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRpY2tlclsnY291bnRlclZvbHVtZSddLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aWNrZXI7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmN1cnJlbnRHZXQyNGhvdXJSb2xsaW5nQWdncmVnYXRpb24gKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCByZXNwb25zZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlW3RdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aWNrZXJbJ2N1cnJlbmN5UGFpciddWydiYXNlJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB0aWNrZXJbJ2N1cnJlbmN5UGFpciddWydjb3VudGVyJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMuZmV0Y2hUaWNrZXJzICh1bmRlZmluZWQsIHBhcmFtcyk7XG4gICAgICAgIGlmIChzeW1ib2wgaW4gdGlja2VycylcbiAgICAgICAgICAgIHJldHVybiB0aWNrZXJzW3N5bWJvbF07XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXR1cm4gZGlkIG5vdCBjb250YWluICcgKyBzeW1ib2wpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFtYXJrZXQpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ2N1cnJlbmN5UGFpciddXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsndGltZXN0YW1wJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsIC8vIHR5cGVcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jdXJyZW50R2V0VHJhbnNhY3Rpb25zUGFpck1heENvdW50ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnbWF4Q291bnQnOiAxMjgsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndm9sdW1lJzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogKHNpZGUgPT0gJ2J1eScpID8gMCA6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudXNlclBvc3RBZGRPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVySWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3Rva2VuJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlLnRvU3RyaW5nICgpICsgJyQnICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICByZXF1ZXN0WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNvaW5tYXJrZXRjYXAgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY29pbm1hcmtldGNhcCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdDb2luTWFya2V0Q2FwJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1ByaXZhdGVBUEknOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNDcmVhdGVPcmRlcic6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0NhbmNlbE9yZGVyJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hCYWxhbmNlJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlckJvb2snOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRyYWRlcyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MjQ0MjQ0LTliZTYzMTJhLTY5ZWQtMTFlNy05OWMxLTdjMTc5NzI3NTI2NS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuY29pbm1hcmtldGNhcC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2lubWFya2V0Y2FwLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2NvaW5tYXJrZXRjYXAuY29tL2FwaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnbG9iYWwvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjdXJyZW5jeUNvZGVzJzogW1xuICAgICAgICAgICAgICAgICdBVUQnLFxuICAgICAgICAgICAgICAgICdCUkwnLFxuICAgICAgICAgICAgICAgICdDQUQnLFxuICAgICAgICAgICAgICAgICdDSEYnLFxuICAgICAgICAgICAgICAgICdDTlknLFxuICAgICAgICAgICAgICAgICdFVVInLFxuICAgICAgICAgICAgICAgICdHQlAnLFxuICAgICAgICAgICAgICAgICdIS0QnLFxuICAgICAgICAgICAgICAgICdJRFInLFxuICAgICAgICAgICAgICAgICdJTlInLFxuICAgICAgICAgICAgICAgICdKUFknLFxuICAgICAgICAgICAgICAgICdLUlcnLFxuICAgICAgICAgICAgICAgICdNWE4nLFxuICAgICAgICAgICAgICAgICdSVUInLFxuICAgICAgICAgICAgICAgICdVU0QnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKCdGZXRjaGluZyBvcmRlciBib29rcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBUEkgb2YgJyArIHRoaXMuaWQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHtcbiAgICAgICAgICAgICdsaW1pdCc6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgY3VycmVuY2llcyA9IHRoaXMuY3VycmVuY3lDb2RlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBxdW90ZS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2VJZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGJhc2VJZCArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZUlkJzogYmFzZUlkLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGVJZCc6IHF1b3RlSWQsXG4gICAgICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hHbG9iYWwgKGN1cnJlbmN5ID0gJ1VTRCcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKGN1cnJlbmN5KVxuICAgICAgICAgICAgcmVxdWVzdFsnY29udmVydCddID0gY3VycmVuY3k7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnB1YmxpY0dldEdsb2JhbCAocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgaWYgKCdsYXN0X3VwZGF0ZWQnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGlmICh0aWNrZXJbJ2xhc3RfdXBkYXRlZCddKVxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ2xhc3RfdXBkYXRlZCddKSAqIDEwMDA7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGFuZ2VLZXkgPSAncGVyY2VudF9jaGFuZ2VfMjRoJztcbiAgICAgICAgaWYgKGNoYW5nZUtleSBpbiB0aWNrZXIpXG4gICAgICAgICAgICBjaGFuZ2UgPSBwYXJzZUZsb2F0ICh0aWNrZXJbY2hhbmdlS2V5XSk7XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdm9sdW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBsZXQgcHJpY2UgPSAncHJpY2VfJyArIG1hcmtldFsncXVvdGVJZCddO1xuICAgICAgICAgICAgaWYgKHByaWNlIGluIHRpY2tlcilcbiAgICAgICAgICAgICAgICBpZiAodGlja2VyW3ByaWNlXSlcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBhcnNlRmxvYXQgKHRpY2tlcltwcmljZV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB2b2x1bWVLZXkgPSAnMjRoX3ZvbHVtZV8nICsgbWFya2V0WydxdW90ZUlkJ107XG4gICAgICAgICAgICBpZiAodm9sdW1lS2V5IGluIHRpY2tlcilcbiAgICAgICAgICAgICAgICB2b2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbdm9sdW1lS2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhc2snOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IGNoYW5nZSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoY3VycmVuY3kgPSAnVVNEJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnbGltaXQnOiAxMDAwMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN1cnJlbmN5KVxuICAgICAgICAgICAgcmVxdWVzdFsnY29udmVydCddID0gY3VycmVuY3k7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXJzID0ge307XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgcmVzcG9uc2UubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVt0XTtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsnaWQnXSArICcvJyArIGN1cnJlbmN5O1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aWNrZXJzW3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tlcnM7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29udmVydCc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnYmFzZUlkJ10sXG4gICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VySWQgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbMF07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBjb2lubWF0ZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjb2lubWF0ZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdDb2luTWF0ZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnR0InLCAnQ1onIF0sIC8vIFVLLCBDemVjaCBSZXB1YmxpY1xuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3ODExMjI5LWMxZWZiNTEwLTYwNmMtMTFlNy05YTM2LTg0YmEyY2U0MTJkOC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9jb2lubWF0ZS5pby9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2lubWF0ZS5pbycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9kb2NzLmNvaW5tYXRlLmFwaWFyeS5pbycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvaW5tYXRlLmlvL2RldmVsb3BlcnMnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3VpZCc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyQm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luV2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbkRlcG9zaXRBZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eUluc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eUxpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXJXaXRoSW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3JlYXRlVm91Y2hlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVkZWVtVm91Y2hlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbEluc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxMaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25IaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bmNvbmZpcm1lZEJpdGNvaW5EZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ19FVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDQsICdwcmljZSc6IDIgfX0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DWksnOiB7ICdpZCc6ICdCVENfQ1pLJywgJ3N5bWJvbCc6ICdCVEMvQ1pLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NaSycsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA0LCAncHJpY2UnOiAyIH19LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDX0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAncHJlY2lzaW9uJzogeyAnYW1vdW50JzogNCwgJ3ByaWNlJzogNSB9fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMDA1LFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAwMzUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYmFsYW5jZXNbY3VycmVuY3ldWydhdmFpbGFibGUnXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBiYWxhbmNlc1tjdXJyZW5jeV1bJ3Jlc2VydmVkJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsnYmFsYW5jZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnZ3JvdXBCeVByaWNlTGltaXQnOiAnRmFsc2UnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Ftb3VudCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFtYXJrZXQpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ2N1cnJlbmN5UGFpciddXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFuc2FjdGlvbklkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRyYWRlWyd0aW1lc3RhbXAnXSxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ21pbnV0ZXNJbnRvSGlzdG9yeSc6IDEwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdidXknKVxuICAgICAgICAgICAgICAgIG9yZGVyWyd0b3RhbCddID0gYW1vdW50OyAvLyBhbW91bnQgaW4gZmlhdFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDsgLy8gYW1vdW50IGluIGZpYXRcbiAgICAgICAgICAgIG1ldGhvZCArPSAnSW5zdGFudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7IC8vIGFtb3VudCBpbiBjcnlwdG9cbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICBtZXRob2QgKz0gdGhpcy5jYXBpdGFsaXplICh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHNlbGYuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJJZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbm9uY2UgKyB0aGlzLnVpZCArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnY2xpZW50SWQnOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAncHVibGljS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbnNlY3VyZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjb2luc2VjdXJlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0NvaW5zZWN1cmUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdJTicsIC8vIEluZGlhXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0NzItOWNiZDIwMGEtNWVkOS0xMWU3LTk1NTEtMjI2N2FkN2JhYzA4LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2luc2VjdXJlLmluJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbnNlY3VyZS5pbicsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmNvaW5zZWN1cmUuaW4nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NvaW5zZWN1cmUvcGx1Z2lucycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW4vc2VhcmNoL2NvbmZpcm1hdGlvbi97dHhpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2Fzay9sb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2Fzay9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2JpZC9oaWdoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9iaWQvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9sYXN0VHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21heDI0SHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21pbjI0SHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21mYS9hdXRoeS9jYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZmEvYXV0aHkvc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXRraS9zZWFyY2gve25ldGtpTmFtZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYmFuay9vdHAve251bWJlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIva3ljL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wcm9maWxlL3Bob25lL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi9hZGRyZXNzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC9jb25maXJtZWQvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL2RlcG9zaXQvY29uZmlybWVkL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC91bmNvbmZpcm1lZC9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC91bmNvbmZpcm1lZC97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL3dhbGxldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9iYWxhbmNlL2F2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvYmFsYW5jZS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9iYWxhbmNlL3RvdGFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvZGVwb3NpdC91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L3ZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYXNrL2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9hc2svY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JpZC9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iaWQvcGVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9iYWxhbmNlL2F2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYmFsYW5jZS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9iYWxhbmNlL3RvdGFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9kZXBvc2l0L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vZGVwb3NpdC91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9kZXBvc2l0L3ZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2NvaW4vZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2ZpYXQvZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2t5Y3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvcmVmZXJyYWwvY29pbi9wYWlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3JlZmVycmFsL2NvaW4vc3VjY2Vzc2Z1bCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9yZWZlcnJhbC9maWF0L3BhaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvcmVmZXJyYWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3RyYWRlL3N1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbG9naW4vdG9rZW4ve3Rva2VufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXQvY29pbi93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldC9jb2luL3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0L2NvaW4vd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0L2NvaW4vd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2dpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9naW4vaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvZ2luL3Bhc3N3b3JkL2ZvcmdvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWZhL2F1dGh5L2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZmEvZ2EvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ251cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9uZXRraS91cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcHJvZmlsZS9pbWFnZS91cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy9uZXdWZXJpZnljb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9pbml0aWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvbmV3VmVyaWZ5Y29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wYXNzd29yZC9jaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcGFzc3dvcmQvcmVzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vd2l0aGRyYXcvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldC9jb2luL3dpdGhkcmF3L25ld1ZlcmlmeWNvZGUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ251cC92ZXJpZnkve3Rva2VufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9reWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2RlcG9zaXQvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9pbnN0YW50L2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9pbnN0YW50L3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvYWNjb3VudC9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9tZmEvYXV0aHkvaW5pdGlhdGUvZW5hYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL21mYS9nYS9pbml0aWF0ZS9lbmFibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbmV0a2kvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvcGhvbmUvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL2FkZHJlc3MvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy9zZW5kVG9FeGNoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy92ZXJpZnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZ2NtL3tjb2RlfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvZGVwb3NpdC9jYW5jZWwve2RlcG9zaXRJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYXNrL2NhbmNlbC97b3JkZXJJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL2NhbmNlbC97b3JkZXJJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9tZmEvYXV0aHkvZGlzYWJsZS97Y29kZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbWZhL2dhL2Rpc2FibGUve2NvZGV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvcGhvbmUvZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvaW1hZ2UvZGVsZXRlL3tuZXRraU5hbWV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0lOUic6IHsgJ2lkJzogJ0JUQy9JTlInLCAnc3ltYm9sJzogJ0JUQy9JTlInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSU5SJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjQgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuNCAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRVc2VyRXhjaGFuZ2VCYW5rU3VtbWFyeSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsnbWVzc2FnZSddO1xuICAgICAgICBsZXQgY29pbiA9IHtcbiAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlQ29pbkJhbGFuY2UnXSxcbiAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsncGVuZGluZ0NvaW5CYWxhbmNlJ10sXG4gICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWyd0b3RhbENvaW5CYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBmaWF0ID0ge1xuICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVGaWF0QmFsYW5jZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiBiYWxhbmNlWydwZW5kaW5nRmlhdEJhbGFuY2UnXSxcbiAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ3RvdGFsRmlhdEJhbGFuY2UnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogYmFsYW5jZSxcbiAgICAgICAgICAgICdCVEMnOiBjb2luLFxuICAgICAgICAgICAgJ0lOUic6IGZpYXQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmlkcyA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VCaWRPcmRlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBhc2tzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZUFza09yZGVycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHtcbiAgICAgICAgICAgICdiaWRzJzogYmlkc1snbWVzc2FnZSddLFxuICAgICAgICAgICAgJ2Fza3MnOiBhc2tzWydtZXNzYWdlJ10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdyYXRlJywgJ3ZvbCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnbWVzc2FnZSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2NvaW52b2x1bWUnXSk7XG4gICAgICAgIGlmIChzeW1ib2wgPT0gJ0JUQy9JTlInKSB7XG4gICAgICAgICAgICBsZXQgc2F0b3NoaSA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgICBiYXNlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHNhdG9zaGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydmaWF0dm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRyYWRlcyAocGFyYW1zKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQdXRVc2VyRXhjaGFuZ2UnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7fTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnSW5zdGFudCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpXG4gICAgICAgICAgICAgICAgb3JkZXJbJ21heEZpYXQnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnbWF4Vm9sJ10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gKHNpZGUgPT0gJ2J1eScpID8gJ0JpZCcgOiAnQXNrJztcbiAgICAgICAgICAgIG1ldGhvZCArPSBkaXJlY3Rpb24gKyAnTmV3JztcbiAgICAgICAgICAgIG9yZGVyWydyYXRlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWyd2b2wnXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHNlbGYuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ21lc3NhZ2UnXVsnb3JkZXJJRCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgKCkgaXMgbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVEZWxldGVVc2VyRXhjaGFuZ2VBc2tDYW5jZWxPcmRlcklkJzsgLy8gVE9ETyBmaXhtZSwgaGF2ZSB0byBzcGVjaWZ5IG9yZGVyIHNpZGUgaGVyZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpc1ttZXRob2RdICh7ICdvcmRlcklEJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQXV0aG9yaXphdGlvbic6IHRoaXMuYXBpS2V5IH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbnNwb3QgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY29pbnNwb3QnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ29pblNwb3QnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdBVScsIC8vIEF1c3RyYWxpYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODIwODQyOS0zY2FjZGY5YS02ODk2LTExZTctODU0ZS00Yzc5YTc3MmEzMGYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3LmNvaW5zcG90LmNvbS5hdS9wdWJhcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5jb2luc3BvdC5jb20uYXUvYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuY29pbnNwb3QuY29tLmF1JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmNvaW5zcG90LmNvbS5hdS9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2NvaW4vZGVwb3NpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvY29pbi9zZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZS9idXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlL3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvYnV5L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvc2VsbC9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9BVUQnOiB7ICdpZCc6ICdCVEMnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQVVEJzogeyAnaWQnOiAnTFRDJywgJ3N5bWJvbCc6ICdMVEMvQVVEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0FVRCcgfSxcbiAgICAgICAgICAgICAgICAnRE9HRS9BVUQnOiB7ICdpZCc6ICdET0dFJywgJ3N5bWJvbCc6ICdET0dFL0FVRCcsICdiYXNlJzogJ0RPR0UnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TXlCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBpZiAoJ2JhbGFuY2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFJLJylcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJjYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2ludHlwZSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eW9yZGVycycsICdzZWxsb3JkZXJzJywgJ3JhdGUnLCAnYW1vdW50Jyk7XG4gICAgICAgIHJlc3VsdFsnYmlkcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYmlkcyddLCAwLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TGF0ZXN0IChwYXJhbXMpO1xuICAgICAgICBsZXQgaWQgPSB0aGlzLm1hcmtldElkIChzeW1ib2wpO1xuICAgICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3ByaWNlcyddW2lkXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyc0hpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbnR5cGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0TXknICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjb2ludHlwZSc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyICgpIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdE15QnV5JztcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXNbbWV0aG9kXSAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYXBpS2V5IGZvciBhbGwgcmVxdWVzdHMnKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgT3JkZXJOb3RDYWNoZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNyeXB0b3BpYSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjcnlwdG9waWEnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ3J5cHRvcGlhJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdOWicsIC8vIE5ldyBaZWFsYW5kXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgLy8gb2Jzb2xldGUgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRGVwb3NpdCc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgLy8gbmV3IG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhcyc6IHtcbiAgICAgICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogJ2VtdWxhdGVkJyxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI5NDg0Mzk0LTdiNGVhNmUyLTg0YzYtMTFlNy04M2U1LTFmY2NmNGIyZGM4MS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuY3J5cHRvcGlhLmNvLm56L2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5jcnlwdG9waWEuY28ubnonLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5jcnlwdG9waWEuY28ubnovRm9ydW0vQ2F0ZWdvcnkvNDUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuY3J5cHRvcGlhLmNvLm56L0ZvcnVtL1RocmVhZC8yNTUnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuY3J5cHRvcGlhLmNvLm56L0ZvcnVtL1RocmVhZC8yNTYnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldEN1cnJlbmNpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRyYWRlUGFpcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0cy97aG91cnN9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXRzL3tpZH0ve2hvdXJzfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0L3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldC97aWR9L3tob3Vyc30nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldEhpc3Rvcnkve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0SGlzdG9yeS97aWR9L3tob3Vyc30nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldE9yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXRPcmRlcnMve2lkfS97Y291bnR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXRPcmRlckdyb3Vwcy97aWRzfS97Y291bnR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdDYW5jZWxUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0RGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTdWJtaXRUaXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1N1Ym1pdFRyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTdWJtaXRUcmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3VibWl0V2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdDQ1gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0ZDTicpXG4gICAgICAgICAgICByZXR1cm4gJ0ZhY2lsZWNvaW4nO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ05FVCcpXG4gICAgICAgICAgICByZXR1cm4gJ05ldENvaW4nO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JURycpXG4gICAgICAgICAgICByZXR1cm4gJ0JpdGdlbSc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBjdXJyZW5jeUlkIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0NDWCcpXG4gICAgICAgICAgICByZXR1cm4gJ0NDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdGYWNpbGVjb2luJylcbiAgICAgICAgICAgIHJldHVybiAnRkNOJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdOZXRDb2luJylcbiAgICAgICAgICAgIHJldHVybiAnTkVUJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCaXRnZW0nKVxuICAgICAgICAgICAgcmV0dXJuICdCVEcnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZVBhaXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnSWQnXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ0xhYmVsJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYW1vdW50TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ01pbmltdW1UcmFkZSddLFxuICAgICAgICAgICAgICAgICdtYXgnOiBtYXJrZXRbJ01heGltdW1UcmFkZSddXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByaWNlTGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ01pbmltdW1QcmljZSddLFxuICAgICAgICAgICAgICAgICdtYXgnOiBtYXJrZXRbJ01heGltdW1QcmljZSddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudExpbWl0cyxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBwcmljZUxpbWl0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbWFya2V0WydTdGF0dXMnXSA9PSAnT0snO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYXJrZXRbJ1RyYWRlRmVlJ10gLyAxMDAsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogbWFya2V0WydUcmFkZUZlZSddIC8gMTAwLFxuICAgICAgICAgICAgICAgICdsb3QnOiBhbW91bnRMaW1pdHNbJ21pbiddLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzogbGltaXRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdCdXknLCAnU2VsbCcsICdQcmljZScsICdWb2x1bWUnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnSGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0JpZFByaWNlJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnQXNrUHJpY2UnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydPcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydDbG9zZSddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydMYXN0UHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydDaGFuZ2UnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ1ZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnQmFzZVZvbHVtZSddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0SWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydEYXRhJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ1RyYWRlUGFpcklkJ107XG4gICAgICAgICAgICBsZXQgcmVjb2duaXplZCA9IChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpO1xuICAgICAgICAgICAgaWYgKCFyZWNvZ25pemVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaFRpY2tlcnMoKSByZXR1cm5lZCB1bnJlY29nbml6ZWQgcGFpciBpZCAnICsgaWQpO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ1RpbWVzdGFtcCcgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRyYWRlWydUaW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIH0gZWxzZSBpZiAoJ1RpbWVTdGFtcCcgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVGltZVN0YW1wJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ1ByaWNlJyk7XG4gICAgICAgIGlmICghcHJpY2UpXG4gICAgICAgICAgICBwcmljZSA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ1JhdGUnKTtcbiAgICAgICAgbGV0IGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAodHJhZGUsICdUb3RhbCcpO1xuICAgICAgICBsZXQgaWQgPSB0aGlzLnNhZmVTdHJpbmcgKHRyYWRlLCAnVHJhZGVJZCcpO1xuICAgICAgICBpZiAoIW1hcmtldCkge1xuICAgICAgICAgICAgaWYgKCdUcmFkZVBhaXJJZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWRlWydUcmFkZVBhaXJJZCddIGluIHRoaXMubWFya2V0c19ieV9pZClcbiAgICAgICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydUcmFkZVBhaXJJZCddXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgaWYgKCdGZWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAgICAgZmVlID0ge1xuICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0JzogdHJhZGVbJ0ZlZSddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnVHlwZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ0Ftb3VudCddLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRIaXN0b3J5SWRIb3VycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdob3Vycyc6IDI0LCAvLyBkZWZhdWx0XG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHRyYWRlcywgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hNeVRyYWRlcyByZXF1aXJlcyBhIHN5bWJvbCcpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRUcmFkZUhpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAvLyAnTWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1RyYWRlUGFpcklkJzogbWFya2V0WydpZCddLCAvLyBDcnlwdG9waWEgaWRlbnRpZmllciAobm90IHJlcXVpcmVkIGlmICdNYXJrZXQnIHN1cHBsaWVkKVxuICAgICAgICAgICAgLy8gJ0NvdW50JzogMTAsIC8vIG1heCA9IDEwMFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydEYXRhJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydTeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjb2RlKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnQXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnVG90YWwnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0IChwcmljZSk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ1RyYWRlUGFpcklkJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1R5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHNpZGUpLFxuICAgICAgICAgICAgJ1JhdGUnOiB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpLFxuICAgICAgICAgICAgJ0Ftb3VudCc6IHRoaXMuYW1vdW50VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFN1Ym1pdFRyYWRlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY3JlYXRlT3JkZXIgcmV0dXJuZWQgdW5rbm93biBlcnJvcjogJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZmlsbGVkID0gMC4wO1xuICAgICAgICBpZiAoJ0RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoJ09yZGVySWQnIGluIHJlc3BvbnNlWydEYXRhJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ0RhdGEnXVsnT3JkZXJJZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcmVzcG9uc2VbJ0RhdGEnXVsnT3JkZXJJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnRmlsbGVkT3JkZXJzJyBpbiByZXNwb25zZVsnRGF0YSddKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGxlZE9yZGVycyA9IHJlc3BvbnNlWydEYXRhJ11bJ0ZpbGxlZE9yZGVycyddO1xuICAgICAgICAgICAgICAgIGxldCBmaWxsZWRPcmRlcnNMZW5ndGggPSBmaWxsZWRPcmRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsZWRPcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IHByaWNlICogYW1vdW50LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpZClcbiAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IG9yZGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQgKHsgJ2luZm8nOiByZXNwb25zZSB9LCBvcmRlcik7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdUeXBlJzogJ1RyYWRlJyxcbiAgICAgICAgICAgICAgICAnT3JkZXJJZCc6IGlkLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5vcmRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdWydzdGF0dXMnXSA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5zYWZlU3RyaW5nICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSwgJ0Vycm9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ2RvZXMgbm90IGV4aXN0JykgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIGlmICgnTWFya2V0JyBpbiBvcmRlcikge1xuICAgICAgICAgICAgbGV0IGlkID0gb3JkZXJbJ01hcmtldCddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydUaW1lU3RhbXAnXSk7XG4gICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdBbW91bnQnKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1JlbWFpbmluZycpO1xuICAgICAgICBsZXQgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ09yZGVySWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdGhpcy5vbWl0IChvcmRlciwgJ3N0YXR1cycpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBvcmRlclsnc3RhdHVzJ10sXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnVHlwZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnUmF0ZScpLFxuICAgICAgICAgICAgJ2Nvc3QnOiB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdUb3RhbCcpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9yZGVycyByZXF1aXJlcyBhIHN5bWJvbCBwYXJhbScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcGVuT3JkZXJzICh7XG4gICAgICAgICAgICAvLyAnTWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1RyYWRlUGFpcklkJzogbWFya2V0WydpZCddLCAvLyBDcnlwdG9waWEgaWRlbnRpZmllciAobm90IHJlcXVpcmVkIGlmICdNYXJrZXQnIHN1cHBsaWVkKVxuICAgICAgICAgICAgLy8gJ0NvdW50JzogMTAwLCAvLyBkZWZhdWx0ID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCBvcmRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZVsnRGF0YSddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvcmRlcnMucHVzaCAodGhpcy5leHRlbmQgKHJlc3BvbnNlWydEYXRhJ11baV0sIHsgJ3N0YXR1cyc6ICdvcGVuJyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZW5PcmRlcnMgPSB0aGlzLnBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3Blbk9yZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbb3Blbk9yZGVyc1tqXVsnaWQnXV0gPSBvcGVuT3JkZXJzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQgPSB0aGlzLmluZGV4QnkgKG9wZW5PcmRlcnMsICdpZCcpO1xuICAgICAgICBsZXQgY2FjaGVkT3JkZXJJZHMgPSBPYmplY3Qua2V5cyAodGhpcy5vcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2FjaGVkT3JkZXJJZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGNhY2hlZE9yZGVySWRzW2tdO1xuICAgICAgICAgICAgaWYgKGlkIGluIG9wZW5PcmRlcnNJbmRleGVkQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIG9wZW5PcmRlcnNJbmRleGVkQnlJZFtpZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IG9yZGVyWydhbW91bnQnXSAqIG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxlZCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1haW5pbmcnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChvcmRlclsnc3ltYm9sJ10gPT0gc3ltYm9sKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChvcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZCA9IGlkLnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9yZGVyc1tpXVsnaWQnXSA9PSBpZClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcmRlck5vdENhY2hlZCAodGhpcy5pZCArICcgb3JkZXIgJyArIGlkICsgJyBub3QgZm91bmQgaW4gY2FjaGVkIC5vcmRlcnMsIGZldGNoT3JkZXIgcmVxdWlyZXMgLm9yZGVycyAoZGUpc2VyaWFsaXphdGlvbiBpbXBsZW1lbnRlZCBmb3IgdGhpcyBtZXRob2QgdG8gd29yayBwcm9wZXJseScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09ICdvcGVuJylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAob3JkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlcnMgKHN5bWJvbCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9yZGVyc1tpXVsnc3RhdHVzJ10gPT0gJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGN1cnJlbmN5SWQgPSB0aGlzLmN1cnJlbmN5SWQgKGN1cnJlbmN5KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldERlcG9zaXRBZGRyZXNzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ0N1cnJlbmN5JzogY3VycmVuY3lJZFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLnNhZmVTdHJpbmcgKHJlc3BvbnNlWydEYXRhJ10sICdCYXNlQWRkcmVzcycpO1xuICAgICAgICBpZiAoIWFkZHJlc3MpXG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZVsnRGF0YSddLCAnQWRkcmVzcycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RTdWJtaXRXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeSc6IGN1cnJlbmN5SWQsXG4gICAgICAgICAgICAnQW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ0FkZHJlc3MnOiBhZGRyZXNzLCAvLyBBZGRyZXNzIG11c3QgZXhpc3QgaW4geW91IEFkZHJlc3NCb29rIGluIHNlY3VyaXR5IHNldHRpbmdzXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydEYXRhJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGJvZHkpLCAnbWQ1JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCB1cmkgPSB0aGlzLmVuY29kZVVSSUNvbXBvbmVudCAodXJsKTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSB1cmkudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IHRoaXMuYXBpS2V5ICsgbWV0aG9kICsgbG93ZXJjYXNlICsgbm9uY2UgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChoYXNoKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChwYXlsb2FkKSwgc2VjcmV0LCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnYW14ICcgKyB0aGlzLmFwaUtleSArICc6JyArIHRoaXMuYmluYXJ5VG9TdHJpbmcgKHNpZ25hdHVyZSkgKyAnOicgKyBub25jZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGF1dGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCdTdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ1N1Y2Nlc3MnXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgnRXJyb3InIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnRXJyb3InXSA9PSAnSW5zdWZmaWNpZW50IEZ1bmRzLicpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgbGlxdWkgPSByZXF1aXJlICgnLi9saXF1aS5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGRzeCBleHRlbmRzIGxpcXVpIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdkc3gnLFxuICAgICAgICAgICAgJ25hbWUnOiAnRFNYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVUsnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MDI3NS0xNDEzMTU4YS02NDVhLTExZTctOTMxYy05NDcxN2Y3NTEwZTMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vZHN4LnVrL21hcGknLCAvLyBtYXJrZXQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2RzeC51ay90YXBpJywgLy8gdHJhZGluZ1xuICAgICAgICAgICAgICAgICAgICAnZHdhcGknOiAnaHR0cHM6Ly9kc3gudWsvZHdhcGknLCAvLyBkZXBvc2l0L3dpdGhkcmF3XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZHN4LnVrJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGkuZHN4LnVrJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZHN4LnVrL2FwaV9kb2NzL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2RzeC51ay9hcGlfZG9jcy9wcml2YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgIC8vIG1hcmtldCBkYXRhIChwdWJsaWMpXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYXJzRnJvbU1vbWVudC97aWR9L3twZXJpb2R9L3tzdGFydH0nLCAvLyBlbXB0eSByZXBseSA6XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aC97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhc3RCYXJzL3tpZH0ve3BlcmlvZH0ve2Ftb3VudH0nLCAvLyBwZXJpb2QgaXMgKG0sIGggb3IgZClcbiAgICAgICAgICAgICAgICAgICAgICAgICdwZXJpb2RCYXJzL3tpZH0ve3BlcmlvZH0ve3N0YXJ0fS97ZW5kfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyB0cmFkaW5nIChwcml2YXRlKVxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFuc0hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXJIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY3RpdmVPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBkZXBvc2l0IC8gd2l0aGRyYXcgKHByaXZhdGUpXG4gICAgICAgICAgICAgICAgJ2R3YXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDcnlwdG9EZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3J5cHRvV2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpYXRXaXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25TdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEJhc2VRdW90ZUZyb21NYXJrZXRJZCAoaWQpIHtcbiAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICBsZXQgYmFzZSA9IHVwcGVyY2FzZS5zbGljZSAoMCwgMyk7XG4gICAgICAgIGxldCBxdW90ZSA9IHVwcGVyY2FzZS5zbGljZSAoMywgNik7XG4gICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgcmV0dXJuIFsgYmFzZSwgcXVvdGUgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGZ1bmRzID0gYmFsYW5jZXNbJ2Z1bmRzJ107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGZ1bmRzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgdXBwZXJjYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHVwcGVyY2FzZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZ1bmRzW2N1cnJlbmN5XSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlc1sndG90YWwnXVtjdXJyZW5jeV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvdycpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdidXknKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnc2VsbCcpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogMSAvIHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhdmcnKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbF9jdXInKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldE9yZGVySWRLZXkgKCkge1xuICAgICAgICByZXR1cm4gJ29yZGVySWQnO1xuICAgIH1cblxuICAgIHNpZ25Cb2R5V2l0aFNlY3JldCAoYm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUgKHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJywgJ2Jhc2U2NCcpKTtcbiAgICB9XG5cbiAgICBnZXRWZXJzaW9uU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuICcnOyAvLyB0aGV5IGRvbid0IHByZXBlbmQgdmVyc2lvbiBudW1iZXIgdG8gcHVibGljIFVSTHMgYXMgb3RoZXIgQlRDLWUgY2xvbmVzIGRvXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgZXhtbyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdleG1vJyxcbiAgICAgICAgICAgICduYW1lJzogJ0VYTU8nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0VTJywgJ1JVJyBdLCAvLyBTcGFpbiwgUnVzc2lhXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCwgLy8gb25jZSBldmVyeSAzNTAgbXMg4omIIDE4MCByZXF1ZXN0cyBwZXIgbWludXRlIOKJiCAzIHJlcXVlc3RzIHBlciBzZWNvbmRcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NDkxLTFiMGVhOTU2LTVlZGEtMTFlNy05MjI1LTQwZDY3YjQ4MWI4ZC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuZXhtby5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9leG1vLm1lJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9leG1vLm1lL2VuL2FwaV9kb2MnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2V4bW8tZGV2L2V4bW9fYXBpX2xpYi90cmVlL21hc3Rlci9ub2RlanMnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWlyX3NldHRpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9jcmVhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl9vcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfY2FuY2VsbGVkX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXF1aXJlZF9hbW91bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdfY3J5cHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2dldF90eGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNvZGVfY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNvZGVfbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0X2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpclNldHRpbmdzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQucmVwbGFjZSAoJ18nLCAnLycpO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ21pbl9xdWFudGl0eSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnbWF4X3F1YW50aXR5J10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ21pbl9wcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnbWF4X3ByaWNlJ10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldFsnbWluX2Ftb3VudCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnbWF4X2Ftb3VudCddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VXNlckluZm8gKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzcG9uc2VbJ2JhbGFuY2VzJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAocmVzcG9uc2VbJ2JhbGFuY2VzJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiByZXNwb25zZVsncmVzZXJ2ZWQnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChyZXNwb25zZVsncmVzZXJ2ZWQnXVtjdXJyZW5jeV0pO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZCcsICdhc2snKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndXBkYXRlZCddICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5X3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbF9wcmljZSddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF90cmFkZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogcGFyc2VGbG9hdCAodGlja2VyWydhdmcnXSksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2xfY3VyciddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChyZXNwb25zZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlW21hcmtldFsnaWQnXV0sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJhZGVfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsncXVhbnRpdHknXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbbWFya2V0WydpZCddXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgcHJlZml4ID0gJ21hcmtldF8nO1xuICAgICAgICBpZiAodHlwZW9mIHByaWNlID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcHJpY2UgPSAwO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICd0eXBlJzogcHJlZml4ICsgc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ3JlYXRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3Q3J5cHQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHRbJ3Rhc2tfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdyZXN1bHQnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBmbG93YnRjIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2Zsb3didGMnLFxuICAgICAgICAgICAgJ25hbWUnOiAnZmxvd0JUQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0JSJywgLy8gQnJhemlsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjgxNjI0NjUtY2Q4MTVkNGMtNjdjZi0xMWU3LThlNTctNDM4YmVhMDUyM2EyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5mbG93YnRjLmNvbTo4NDAwL2FqYXgnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly90cmFkZXIuZmxvd2J0Yy5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cDovL3d3dy5mbG93YnRjLmNvbS5ici9hcGkvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndWlkJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFkZXNCeURhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9yZGVyQm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0UHJvZHVjdFBhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRQcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ3JlYXRlQWNjb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VXNlckluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NldFVzZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRBY2NvdW50SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudFRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0RGVwb3NpdEFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NyZWF0ZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNb2RpZnlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbEFsbE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudE9wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9yZGVyRmVlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0UHJvZHVjdFBhaXJzICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydwcm9kdWN0UGFpcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsncHJvZHVjdDFMYWJlbCddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0Wydwcm9kdWN0MkxhYmVsJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydjdXJyZW5jaWVzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ25hbWUnXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYmFsYW5jZSddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsnaG9sZCddLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY1Bvc3RHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdFBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHgnLCAncXR5Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aHInXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aHJQcm9kdWN0MiddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd1bml4dGltZSddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ2luY29taW5nT3JkZXJTaWRlJ10gPT0gMCkgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydweCddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydxdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lucyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdzdGFydEluZGV4JzogLTEsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlclR5cGUgPSAodHlwZSA9PSAnbWFya2V0JykgPyAxIDogMDtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2lucyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogb3JkZXJUeXBlLFxuICAgICAgICAgICAgJ3F0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdweCc6IHByaWNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q3JlYXRlT3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3NlcnZlck9yZGVySWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKCdpbnMnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnc2VydmVyT3JkZXJJZCc6IGlkLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGBpbnNgIHN5bWJvbCBwYXJhbWV0ZXIgZm9yIGNhbmNlbGxpbmcgYW4gb3JkZXInKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlLnRvU3RyaW5nICgpICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYXBpTm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYXBpU2lnJzogc2lnbmF0dXJlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnaXNBY2NlcHRlZCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2lzQWNjZXB0ZWQnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBmb3hiaXQgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZm94Yml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ0ZveEJpdCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0JSJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE0MTMtMTFiNDBkNDItNjQ3Zi0xMWU3LTkxZWUtNzhjZWQ4NzRkZDA5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9mb3hiaXQuZXhjaGFuZ2UnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9ibGlua3RyYWRlLmNvbS9kb2NzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY29tbWVudCc6ICdCbGlua3RyYWRlIEFQSScsXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5fS90aWNrZXInLCAgICAvLyA/Y3J5cHRvX2N1cnJlbmN5PUJUQ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tjdXJyZW5jeX0vb3JkZXJib29rJywgLy8gP2NyeXB0b19jdXJyZW5jeT1CVENcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3l9L3RyYWRlcycsICAgIC8vID9jcnlwdG9fY3VycmVuY3k9QlRDJnNpbmNlPTxUSU1FU1RBTVA+JmxpbWl0PTxOVU1CRVI+XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnRCcsICAgLy8gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdGJywgICAvLyBjYW5jZWwgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdVMicsICAvLyBiYWxhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAnVTQnLCAgLy8gbXkgb3JkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAnVTYnLCAgLy8gd2l0aGRyYXdcbiAgICAgICAgICAgICAgICAgICAgICAgICdVMTgnLCAvLyBkZXBvc2l0XG4gICAgICAgICAgICAgICAgICAgICAgICAnVTI0JywgLy8gY29uZmlybSB3aXRoZHJhd2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVTI2JywgLy8gbGlzdCB3aXRoZHJhd2Fsc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1UzMCcsIC8vIGxpc3QgZGVwb3NpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICdVMzQnLCAvLyBsZWRnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdVNzAnLCAvLyBjYW5jZWwgd2l0aGRyYXdhbFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9WRUYnOiB7ICdpZCc6ICdCVENWRUYnLCAnc3ltYm9sJzogJ0JUQy9WRUYnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVkVGJywgJ2Jyb2tlcklkJzogMSwgJ2Jyb2tlcic6ICdTdXJCaXRjb2luJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvVk5EJzogeyAnaWQnOiAnQlRDVk5EJywgJ3N5bWJvbCc6ICdCVEMvVk5EJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1ZORCcsICdicm9rZXJJZCc6IDMsICdicm9rZXInOiAnVkJUQycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0JSTCc6IHsgJ2lkJzogJ0JUQ0JSTCcsICdzeW1ib2wnOiAnQlRDL0JSTCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdCUkwnLCAnYnJva2VySWQnOiA0LCAnYnJva2VyJzogJ0ZveEJpdCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1BLUic6IHsgJ2lkJzogJ0JUQ1BLUicsICdzeW1ib2wnOiAnQlRDL1BLUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQS1InLCAnYnJva2VySWQnOiA4LCAnYnJva2VyJzogJ1VyZHVCaXQnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DTFAnOiB7ICdpZCc6ICdCVENDTFAnLCAnc3ltYm9sJzogJ0JUQy9DTFAnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ0xQJywgJ2Jyb2tlcklkJzogOSwgJ2Jyb2tlcic6ICdDaGlsZUJpdCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgLy8gdG9kbyBwYXJzZSBiYWxhbmNlXG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0VTIgKHtcbiAgICAgICAgICAgICdCYWxhbmNlUmVxSUQnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2NyeXB0b19jdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdjcnlwdG9fY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGxvd2VyY2FzZVF1b3RlID0gbWFya2V0WydxdW90ZSddLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSAndm9sXycgKyBsb3dlcmNhc2VRdW90ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyW3F1b3RlVm9sdW1lXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdjcnlwdG9fY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJTaWRlID0gKHNpZGUgPT0gJ2J1eScpID8gJzEnIDogJzInO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnQ2xPcmRJRCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICAnU3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1NpZGUnOiBvcmRlclNpZGUsXG4gICAgICAgICAgICAnT3JkVHlwZSc6ICcyJyxcbiAgICAgICAgICAgICdQcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ09yZGVyUXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ0Jyb2tlcklEJzogbWFya2V0Wydicm9rZXJJZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RCAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSB0aGlzLmluZGV4QnkgKHJlc3BvbnNlWydSZXNwb25zZXMnXSwgJ01zZ1R5cGUnKTtcbiAgICAgICAgbGV0IGV4ZWN1dGlvbiA9IGluZGV4ZWRbJzgnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiBleGVjdXRpb25bJ09yZGVySUQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RGICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ0NsT3JkSUQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHsgJ01zZ1R5cGUnOiBwYXRoIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ05vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKG5vbmNlKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdTdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydTdGF0dXMnXSAhPSAyMDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBmeWJzZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdmeWJzZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdGWUItU0UnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdTRScsIC8vIFN3ZWRlblxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjUxMi0zMTAxOTc3Mi01ZWRiLTExZTctODI0MS0yZTY3NWU2Nzk3ZjEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmZ5YnNlLnNlL2FwaS9TRUsnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuZnlic2Uuc2UnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cDovL2RvY3MuZnliLmFwaWFyeS5pbycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyZGV0YWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRhY2NpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRwZW5kaW5nb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRvcmRlcmhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbHBlbmRpbmdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2VvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9TRUsnOiB7ICdpZCc6ICdTRUsnLCAnc3ltYm9sJzogJ0JUQy9TRUsnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0VLJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRhY2NpbmZvICgpO1xuICAgICAgICBsZXQgYnRjID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYnRjQmFsJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdGhpcy5zeW1ib2xzWzBdO1xuICAgICAgICBsZXQgcXVvdGUgPSB0aGlzLm1hcmtldHNbc3ltYm9sXVsncXVvdGUnXTtcbiAgICAgICAgbGV0IGxvd2VyY2FzZSA9IHF1b3RlLnRvTG93ZXJDYXNlICgpICsgJ0JhbCc7XG4gICAgICAgIGxldCBmaWF0ID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtsb3dlcmNhc2VdKTtcbiAgICAgICAgbGV0IGNyeXB0byA9IHtcbiAgICAgICAgICAgICdmcmVlJzogYnRjLFxuICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAndG90YWwnOiBidGMsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdCVEMnOiBjcnlwdG8gfTtcbiAgICAgICAgcmVzdWx0W3F1b3RlXSA9IHtcbiAgICAgICAgICAgICdmcmVlJzogZmlhdCxcbiAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgJ3RvdGFsJzogZmlhdCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0WydpbmZvJ10gPSBiYWxhbmNlO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJkZXRhaWxlZCAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHZvbHVtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdsYXN0JyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBsYXN0ID0gcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pO1xuICAgICAgICBpZiAoJ3ZvbCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgdm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlb3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHlwZSc6IHNpZGVbMF0udG9VcHBlckNhc2UgKClcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3BlbmRpbmdfb2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VscGVuZGluZ29yZGVyICh7ICdvcmRlck5vJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmpzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAndGltZXN0YW1wJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZyc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMScpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKVxuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZnlic2UgPSByZXF1aXJlICgnLi9meWJzZS5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGZ5YnNnIGV4dGVuZHMgZnlic2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2Z5YnNnJyxcbiAgICAgICAgICAgICduYW1lJzogJ0ZZQi1TRycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1NHJywgLy8gU2luZ2Fwb3JlXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjUxMy0zMzY0ZDU2YS01ZWRiLTExZTctOWU2Yi1kNTg5OGJiODljODEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmZ5YnNnLmNvbS9hcGkvU0dEJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmZ5YnNnLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwOi8vZG9jcy5meWIuYXBpYXJ5LmlvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ1NHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBnYXRlY29pbiBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdnYXRlY29pbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdHYXRlY29pbicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAgICAgICAgICdjb21tZW50JzogJ2EgcmVndWxhdGVkL2xpY2Vuc2VkIGV4Y2hhbmdlJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMjRoJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4NjQ2ODE3LTUwODQ1N2YyLTcyNmMtMTFlNy05ZWViLTM1MjhkMjQxM2E1OC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuZ2F0ZWNvaW4uY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZ2F0ZWNvaW4uY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9nYXRlY29pbi5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9HYXRlY29pbi9SRVNUZnVsLUFQSS1JbXBsZW1lbnRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS5nYXRlY29pbi5jb20vc3dhZ2dlci11aS9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvRXhjaGFuZ2VSYXRlJywgLy8gR2V0IHRoZSBleGNoYW5nZSByYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9MaXZlVGlja2VyJywgLy8gR2V0IGxpdmUgdGlja2VyIGZvciBhbGwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvTGl2ZVRpY2tlci97Q3VycmVuY3lQYWlyfScsIC8vIEdldCBsaXZlIHRpY2tlciBieSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9MaXZlVGlja2VycycsIC8vIEdldCBsaXZlIHRpY2tlciBmb3IgYWxsIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL01hcmtldERlcHRoL3tDdXJyZW5jeVBhaXJ9JywgLy8gR2V0cyBwcmljZXMgYW5kIG1hcmtldCBkZXB0aCBmb3IgdGhlIGN1cnJlbmN5IHBhaXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL05ldHdvcmtTdGF0aXN0aWNzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IHRoZSBuZXR3b3JrIHN0YXR1cyBvZiBhIHNwZWNpZmljIGRpZ2l0YWwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvU3RhdGlzdGljSGlzdG9yeS97RGlnaUN1cnJlbmN5fS97VHlwZW9mZGF0YX0nLCAvLyBHZXQgdGhlIGhpc3RvcmljYWwgZGF0YSBvZiBhIHNwZWNpZmljIGRpZ2l0YWwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvVGlja2VySGlzdG9yeS97Q3VycmVuY3lQYWlyfS97VGltZWZyYW1lfScsIC8vIEdldCB0aWNrZXIgaGlzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9UcmFuc2FjdGlvbnMve0N1cnJlbmN5UGFpcn0nLCAvLyBHZXRzIHJlY2VudCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvVHJhbnNhY3Rpb25zSGlzdG9yeS97Q3VycmVuY3lQYWlyfScsIC8vIEdldHMgYWxsIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9CdXNpbmVzc05hdHVyZUxpc3QnLCAvLyBHZXQgdGhlIGJ1c2luZXNzIG5hdHVyZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9Db3VudHJpZXMnLCAvLyBHZXQgdGhlIGNvdW50cnkgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvQ3VycmVuY2llcycsIC8vIEdldCB0aGUgY3VycmVuY3kgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvQ3VycmVuY3lQYWlycycsIC8vIEdldCB0aGUgY3VycmVuY3kgcGFpciBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9DdXJyZW50U3RhdHVzTGlzdCcsIC8vIEdldCB0aGUgY3VycmVudCBzdGF0dXMgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSWRlbnR5ZG9jdW1lbnRUeXBlcycsIC8vIEdldCB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGlkZW50aXR5IGRvY3VtZW50cyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSW5jb21lUmFuZ2VMaXN0JywgLy8gR2V0IHRoZSBpbmNvbWUgcmFuZ2UgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSW5jb21lU291cmNlTGlzdCcsIC8vIEdldCB0aGUgaW5jb21lIHNvdXJjZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9WZXJpZmljYXRpb25MZXZlbExpc3QnLCAvLyBHZXQgdGhlIHZlcmlmIGxldmVsIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3RyZWFtL1B1YmxpY0NoYW5uZWwnLCAvLyBHZXQgdGhlIHB1YmxpYyBwdWJudWIgY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0V4cG9ydC9UcmFuc2FjdGlvbnMnLCAvLyBSZXF1ZXN0IGEgZXhwb3J0IG9mIGFsbCB0cmFkZXMgZnJvbSBiYXNlZCBvbiBjdXJyZW5jeXBhaXIsIHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAnUGluZycsIC8vIFBvc3QgYSBzdHJpbmcsIHRoZW4gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL1Vuc3Vic2NyaWJlL3tFbWFpbENvZGV9JywgLy8gTGV0cyB0aGUgdXNlciB1bnN1YnNjcmliZSBmcm9tIGVtYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZ2lzdGVyVXNlcicsIC8vIEluaXRpYWwgdHJhZGVyIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvQ29ycG9yYXRlRGF0YScsIC8vIEdldCBjb3Jwb3JhdGUgYWNjb3VudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudEFkZHJlc3MnLCAvLyBDaGVjayBpZiByZXNpZGVuY2UgcHJvb2YgdXBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50Q29ycG9yYXRpb24nLCAvLyBDaGVjayBpZiByZWdpc3RlcmVkIGRvY3VtZW50IHVwbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudElEJywgLy8gQ2hlY2sgaWYgSUQgZG9jdW1lbnQgY29weSB1cGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJbmZvcm1hdGlvbicsIC8vIEdldCBTdGVwMyBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbCcsIC8vIEdldCB1c2VyIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9GZWVSYXRlJywgLy8gR2V0IGZlZSByYXRlIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9MZXZlbCcsIC8vIEdldCB2ZXJpZiBsZXZlbCBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUGVyc29uYWxJbmZvcm1hdGlvbicsIC8vIEdldCBTdGVwMSBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9QaG9uZScsIC8vIEdldCB1c2VyIHBob25lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUHJvZmlsZScsIC8vIEdldCB0cmFkZXIgcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIEZpbGwgdGhlIHF1ZXN0aW9ubmFpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsJywgLy8gR2V0IHJlZmVycmFsIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbENvZGUnLCAvLyBHZXQgdGhlIHJlZmVycmFsIGNvZGUgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbE5hbWVzJywgLy8gR2V0IG5hbWVzIG9mIHJlZmVycmVkIHRyYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsUmV3YXJkJywgLy8gR2V0IHJlZmVycmFsIHJld2FyZCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUmVmZXJyZWRDb2RlJywgLy8gR2V0IHJlZmVycmFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1Jlc2lkZW50SW5mb3JtYXRpb24nLCAvLyBHZXQgU3RlcDIgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvU2VjdXJpdHlTZXR0aW5ncycsIC8vIEdldCB2ZXJpZiBkZXRhaWxzIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Vc2VyJywgLy8gR2V0IGFsbCB1c2VyIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdBUElLZXkvQVBJS2V5JywgLy8gR2V0IEFQSSBLZXkgZm9yIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Db25uZWN0aW9uSGlzdG9yeScsIC8vIEdldHMgY29ubmVjdGlvbiBoaXN0b3J5IG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9CYWxhbmNlcycsIC8vIEdldHMgdGhlIGF2YWlsYWJsZSBiYWxhbmNlIGZvciBlYWNoIGN1cnJlbmN5IGZvciB0aGUgbG9nZ2VkIGluIGFjY291bnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9CYWxhbmNlcy97Q3VycmVuY3l9JywgLy8gR2V0cyB0aGUgYXZhaWxhYmxlIGJhbGFuY2UgZm9yIHMgY3VycmVuY3kgZm9yIHRoZSBsb2dnZWQgaW4gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdCYWxhbmNlL0RlcG9zaXRzJywgLy8gR2V0IGFsbCBhY2NvdW50IGRlcG9zaXRzLCBpbmNsdWRpbmcgd2lyZSBhbmQgZGlnaXRhbCBjdXJyZW5jeSwgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9XaXRoZHJhd2FscycsIC8vIEdldCBhbGwgYWNjb3VudCB3aXRoZHJhd2FscywgaW5jbHVkaW5nIHdpcmUgYW5kIGRpZ2l0YWwgY3VycmVuY3ksIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvQWNjb3VudHMve0N1cnJlbmN5fS97TG9jYXRpb259JywgLy8gR2V0IGludGVybmFsIGJhbmsgYWNjb3VudCBmb3IgZGVwb3NpdFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zJywgLy8gR2V0IGFsbCBhY2NvdW50IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cycsIC8vIEdldHMgYWxsIHRoZSBiYW5rIGFjY291bnRzIHJlbGF0ZWQgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzL3tDdXJyZW5jeX0nLCAvLyBHZXRzIGFsbCB0aGUgYmFuayBhY2NvdW50cyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzJywgLy8gR2V0cyBhbGwgY3J5cHRvIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIGRlcG9zaXRzIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0cyBhbGwgY3J5cHRvIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIGRlcG9zaXRzIHRvIHRoZSBsb2dnZWQgaW4gdXNlciBieSBjdXJyZW5jeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1RyYW5zYWN0aW9ucycsIC8vIEdldCBhbGwgZGlnaXRhbCBjdXJyZW5jeSB0cmFuc2FjdGlvbnMgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9UcmFuc2FjdGlvbnMve0RpZ2lDdXJyZW5jeX0nLCAvLyBHZXQgYWxsIGRpZ2l0YWwgY3VycmVuY3kgdHJhbnNhY3Rpb25zIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVXNlcldhbGxldHMnLCAvLyBHZXRzIGFsbCBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0cyBhbGwgZXh0ZXJuYWwgZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIgYnkgY3VycmVuY3kuXG4gICAgICAgICAgICAgICAgICAgICAgICAnSW5mby9SZWZlcmVuY2VDdXJyZW5jeScsIC8vIEdldCB1c2VyJ3MgcmVmZXJlbmNlIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAnSW5mby9SZWZlcmVuY2VMYW5ndWFnZScsIC8vIEdldCB1c2VyJ3MgcmVmZXJlbmNlIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm90aWZpY2F0aW9uL01lc3NhZ2VzJywgLy8gR2V0IGZyb20gb2xkZXN0IHVucmVhZCArIDMgcmVhZCBtZXNzYWdlIHRvIG5ld2VzdCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycycsIC8vIEdldHMgb3BlbiBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycy97T3JkZXJJRH0nLCAvLyBHZXRzIGFuIG9yZGVyIGZvciB0aGUgbG9nZ2VkIGluIHRyYWRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzJywgLy8gR2V0cyBhbGwgc3RvcCBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLiBNYXggMTAwMCByZWNvcmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVyc0hpc3RvcnknLCAvLyBHZXRzIGFsbCBzdG9wIG9yZGVycyBmb3IgdGhlIGxvZ2dlZCBpbiB0cmFkZXIuIE1heCAxMDAwIHJlY29yZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9UcmFkZXMnLCAvLyBHZXRzIGFsbCB0cmFuc2FjdGlvbnMgb2YgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9Vc2VyVHJhZGVzJywgLy8gR2V0cyBhbGwgdHJhbnNhY3Rpb25zIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRBZGRyZXNzJywgLy8gVXBsb2FkIGFkZHJlc3MgcHJvb2YgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50Q29ycG9yYXRpb24nLCAvLyBVcGxvYWQgcmVnaXN0ZXJlZCBkb2N1bWVudCBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJRCcsIC8vIFVwbG9hZCBJRCBkb2N1bWVudCBjb3B5XG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbC9SZXF1ZXN0VmVyaWZ5JywgLy8gUmVxdWVzdCBmb3IgdmVyaWZpY2F0aW9uIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbC9WZXJpZnknLCAvLyBWZXJpZmljYXRpb24gZW1haWxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0dvb2dsZUF1dGgnLCAvLyBFbmFibGUgZ29vZ2xlIGF1dGhcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0xldmVsJywgLy8gUmVxdWVzdCB2ZXJpZiBsZXZlbCBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIEZpbGwgdGhlIHF1ZXN0aW9ubmFpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsJywgLy8gUG9zdCBhIHJlZmVycmFsIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVBJS2V5L0FQSUtleScsIC8vIENyZWF0ZSBhIG5ldyBBUEkga2V5IGZvciBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvQ2hhbmdlUGFzc3dvcmQnLCAvLyBDaGFuZ2UgcGFzc3dvcmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Gb3Jnb3RQYXNzd29yZCcsIC8vIFJlcXVlc3QgcmVzZXQgcGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBdXRoL0ZvcmdvdFVzZXJJRCcsIC8vIFJlcXVlc3QgdXNlciBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvTG9naW4nLCAvLyBUcmFkZXIgc2Vzc2lvbiBsb2cgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Mb2dvdXQnLCAvLyBMb2dvdXQgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvTG9nb3V0T3RoZXJTZXNzaW9ucycsIC8vIExvZ291dCBvdGhlciBzZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICdBdXRoL1Jlc2V0UGFzc3dvcmQnLCAvLyBSZXNldCBwYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zJywgLy8gUmVxdWVzdCBhIHRyYW5zZmVyIGZyb20gdGhlIHRyYWRlcnMgYWNjb3VudCBvZiB0aGUgbG9nZ2VkIGluIHVzZXIuIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJhbmsgYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzJywgLy8gQWRkIGFuIGFjY291bnQgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cy97RGlnaUN1cnJlbmN5fScsIC8vIEFkZCBhbiBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9UcmFuc2FjdGlvbnMvRGVwb3NpdHMve0RpZ2lDdXJyZW5jeX0nLCAvLyBHZXQgYWxsIGludGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgdHJhbnNhY3Rpb25zIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVHJhbnNhY3Rpb25zL1dpdGhkcmF3YWxzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IGFsbCBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gQWRkIGFuIGV4dGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgYWRkcmVzc2VzIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1dpdGhkcmF3YWxzL3tEaWdpQ3VycmVuY3l9JywgLy8gUmVxdWVzdCBhIHRyYW5zZmVyIGZyb20gdGhlIHRyYWRlcnMgYWNjb3VudCB0byBhbiBleHRlcm5hbCBhZGRyZXNzLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBjcnlwdG8gY3VycmVuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICdOb3RpZmljYXRpb24vTWVzc2FnZXMnLCAvLyBNYXJrIGFsbCBhcyByZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm90aWZpY2F0aW9uL01lc3NhZ2VzL3tJRH0nLCAvLyBNYXJrIGFzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9PcmRlcnMnLCAvLyBQbGFjZSBhbiBvcmRlciBhdCB0aGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVycycsIC8vIFBsYWNlIGEgc3RvcCBvcmRlciBhdCB0aGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwdXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Db3Jwb3JhdGVEYXRhJywgLy8gVXBkYXRlIHVzZXIgY29tcGFueSBkYXRhIGZvciBjb3Jwb3JhdGUgYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJRCcsIC8vIFVwZGF0ZSBJRCBkb2N1bWVudCBtZXRhIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50SW5mb3JtYXRpb24nLCAvLyBVcGRhdGUgU3RlcDMgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRW1haWwnLCAvLyBVcGRhdGUgdXNlciBlbWFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUGVyc29uYWxJbmZvcm1hdGlvbicsIC8vIFVwZGF0ZSBTdGVwMSBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9QaG9uZScsIC8vIFVwZGF0ZSB1c2VyIHBob25lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIHVwZGF0ZSB0aGUgcXVlc3Rpb25uYWlyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUmVmZXJyZWRDb2RlJywgLy8gVXBkYXRlIHJlZmVycmFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1Jlc2lkZW50SW5mb3JtYXRpb24nLCAvLyBVcGRhdGUgU3RlcDIgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvU2VjdXJpdHlTZXR0aW5ncycsIC8vIFVwZGF0ZSB2ZXJpZiBkZXRhaWxzIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Vc2VyJywgLy8gVXBkYXRlIGFsbCB1c2VyIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cycsIC8vIFVwZGF0ZSB0aGUgbGFiZWwgb2YgZXhpc3RpbmcgdXNlciBiYW5rIGFjY291bm50XG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cy97RGlnaUN1cnJlbmN5fS97QWRkcmVzc05hbWV9JywgLy8gVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbmZvL1JlZmVyZW5jZUN1cnJlbmN5JywgLy8gVXNlcidzIHJlZmVyZW5jZSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0luZm8vUmVmZXJlbmNlTGFuZ3VhZ2UnLCAvLyBVcGRhdGUgdXNlcidzIHJlZmVyZW5jZSBsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FQSUtleS9BUElLZXkve1B1YmxpY0tleX0nLCAvLyBSZW1vdmUgYW4gQVBJIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zL3tSZXF1ZXN0SUR9JywgLy8gRGVsZXRlIHBlbmRpbmcgYWNjb3VudCB3aXRoZHJhdyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cy97Q3VycmVuY3l9L3tMYWJlbH0nLCAvLyBEZWxldGUgYW4gYWNjb3VudCBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzL3tEaWdpQ3VycmVuY3l9L3tBZGRyZXNzTmFtZX0nLCAvLyBEZWxldGUgYW4gZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9Vc2VyV2FsbGV0cy97RGlnaUN1cnJlbmN5fS97QWRkcmVzc05hbWV9JywgLy8gRGVsZXRlIGFuIGV4dGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgYWRkcmVzc2VzIHJlbGF0ZWQgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycycsIC8vIENhbmNlbHMgYWxsIGV4aXN0aW5nIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvT3JkZXJzL3tPcmRlcklEfScsIC8vIENhbmNlbHMgYW4gZXhpc3Rpbmcgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzJywgLy8gQ2FuY2VscyBhbGwgZXhpc3Rpbmcgc3RvcCBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzL3tJRH0nLCAvLyBDYW5jZWxzIGFuIGV4aXN0aW5nIHN0b3Agb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMjUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDAzNSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VycyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsndGlja2VycyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2N1cnJlbmN5UGFpciddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlQmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVCYWxhbmNlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB0aGlzLnN1bSAoXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbJ3BlbmRpbmdJbmNvbWluZyddLFxuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlWydwZW5kaW5nT3V0Z29pbmcnXSxcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVsnb3Blbk9yZGVyJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ2JhbGFuY2UnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNNYXJrZXREZXB0aEN1cnJlbmN5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAndm9sdW1lJyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWydjcmVhdGVEYXRlVGltZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcXVvdGVWb2x1bWUsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHVibGljTGl2ZVRpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ3RpY2tlcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydjdXJyZW5jeVBhaXInXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VyQ3VycmVuY3lQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ0N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsndGlja2VyJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3dheScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHNpZGUgPSAodHJhZGVbJ3dheSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICAgICAgbGV0IG9yZGVySWQgPSB0cmFkZVsnd2F5J10gKyAnT3JkZXJJZCc7XG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlW29yZGVySWRdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ3RyYW5zYWN0aW9uVGltZSddKSAqIDEwMDA7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYW5zYWN0aW9uSWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNUcmFuc2FjdGlvbnNDdXJyZW5jeVBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnQ3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWyd0cmFuc2FjdGlvbnMnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcnNlSW50IChvaGxjdlsnY3JlYXRlRGF0ZVRpbWUnXSkgKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbJ29wZW4nXSxcbiAgICAgICAgICAgIG9obGN2WydoaWdoJ10sXG4gICAgICAgICAgICBvaGxjdlsnbG93J10sXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBvaGxjdlsndm9sdW1lJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnQ3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1RpbWVmcmFtZSc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydDb3VudCddID0gbGltaXQ7XG4gICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNUaWNrZXJIaXN0b3J5Q3VycmVuY3lQYWlyVGltZWZyYW1lIChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlWyd0aWNrZXJzJ10sIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdDb2RlJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdXYXknOiAoc2lkZSA9PSAnYnV5JykgPyAnQmlkJyA6ICdBc2snLFxuICAgICAgICAgICAgJ0Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydQcmljZSddID0gcHJpY2U7XG4gICAgICAgIGlmICh0aGlzLnR3b2ZhKSB7XG4gICAgICAgICAgICBpZiAoJ1ZhbGlkYXRpb25Db2RlJyBpbiBwYXJhbXMpXG4gICAgICAgICAgICAgICAgb3JkZXJbJ1ZhbGlkYXRpb25Db2RlJ10gPSBwYXJhbXNbJ1ZhbGlkYXRpb25Db2RlJ107XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHR3by1mYWN0b3IgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBtaXNzaW5nIFZhbGlkYXRpb25Db2RlIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZU9yZGVycyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnY2xPcmRlcklkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVUcmFkZU9yZGVyc09yZGVySUQgKHsgJ09yZGVySUQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IChtZXRob2QgPT0gJ0dFVCcpID8gJycgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG1ldGhvZCArIHVybCArIGNvbnRlbnRUeXBlICsgbm9uY2UudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBhdXRoID0gYXV0aC50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTI1NicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FQSV9QVUJMSUNfS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FQSV9SRVFVRVNUX1NJR05BVFVSRSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAnQVBJX1JFUVVFU1RfREFURSc6IG5vbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgIT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgncmVzcG9uc2VTdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZVsncmVzcG9uc2VTdGF0dXMnXSlcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3BvbnNlU3RhdHVzJ11bJ21lc3NhZ2UnXSA9PSAnT0snKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYnRlciA9IHJlcXVpcmUgKCcuL2J0ZXIuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBnYXRlaW8gZXh0ZW5kcyBidGVyIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdnYXRlaW8nLFxuICAgICAgICAgICAgJ25hbWUnOiAnR2F0ZS5pbycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzE3ODQwMjktMDMxM2M3MDItYjUwOS0xMWU3LTljY2MtYmMwZGE2YTBlNDM1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2RhdGEuZ2F0ZS5pby9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2RhdGEuZ2F0ZS5pby9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2dhdGUuaW8vJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZ2F0ZS5pby9hcGkyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEludmFsaWRPcmRlciwgQXV0aGVudGljYXRpb25FcnJvciwgTm90U3VwcG9ydGVkIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBnZGF4IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2dkYXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnR0RBWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0RlcG9zaXQnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiA2MCxcbiAgICAgICAgICAgICAgICAnNW0nOiAzMDAsXG4gICAgICAgICAgICAgICAgJzE1bSc6IDkwMCxcbiAgICAgICAgICAgICAgICAnMzBtJzogMTgwMCxcbiAgICAgICAgICAgICAgICAnMWgnOiAzNjAwLFxuICAgICAgICAgICAgICAgICcyaCc6IDcyMDAsXG4gICAgICAgICAgICAgICAgJzRoJzogMTQ0MDAsXG4gICAgICAgICAgICAgICAgJzEyaCc6IDQzMjAwLFxuICAgICAgICAgICAgICAgICcxZCc6IDg2NDAwLFxuICAgICAgICAgICAgICAgICcxdyc6IDYwNDgwMCxcbiAgICAgICAgICAgICAgICAnMU0nOiAyNTkyMDAwLFxuICAgICAgICAgICAgICAgICcxeSc6IDMxNTM2MDAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICd0ZXN0JzogJ2h0dHBzOi8vYXBpLXB1YmxpYy5zYW5kYm94LmdkYXguY29tJyxcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTI3LWIxYmU0MWM2LTVlZGItMTFlNy05NWY2LTViNDk2YzQ2OWUyYy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuZ2RheC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuZ2RheC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kb2NzLmdkYXguY29tJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncGFzc3dvcmQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L2NhbmRsZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2R1Y3RzL3tpZH0vc3RhdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2R1Y3RzL3tpZH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfS9ob2xkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfS9sZWRnZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvaW5iYXNlLWFjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC1tZXRob2RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVwb3J0cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2Vycy9zZWxmL3RyYWlsaW5nLXZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzL2NvaW5iYXNlLWFjY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzL3BheW1lbnQtbWV0aG9kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nL3JlcGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9maWxlcy9tYXJnaW4tdHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcG9ydHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL2NvaW5iYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy9jcnlwdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3BheW1lbnQtbWV0aG9kJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMjUgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncXVvdGVfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgYW1vdW50TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ2Jhc2VfbWluX3NpemUnXSxcbiAgICAgICAgICAgICAgICAnbWF4JzogbWFya2V0WydiYXNlX21heF9zaXplJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByaWNlTGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ3F1b3RlX2luY3JlbWVudCddLFxuICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGNvc3RMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IHByaWNlTGltaXRzWydtaW4nXSxcbiAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudExpbWl0cyxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBwcmljZUxpbWl0cyxcbiAgICAgICAgICAgICAgICAnY29zdCc6IGNvc3RMaW1pdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogLU1hdGgubG9nMTAgKHBhcnNlRmxvYXQgKGFtb3VudExpbWl0c1snbWluJ10pKSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiAtTWF0aC5sb2cxMCAocGFyc2VGbG9hdCAocHJpY2VMaW1pdHNbJ21pbiddKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHRha2VyID0gdGhpcy5mZWVzWyd0cmFkaW5nJ11bJ3Rha2VyJ107XG4gICAgICAgICAgICBpZiAoKGJhc2UgPT0gJ0VUSCcpIHx8IChiYXNlID09ICdMVEMnKSkge1xuICAgICAgICAgICAgICAgIHRha2VyID0gMC4wMDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzogbGltaXRzLFxuICAgICAgICAgICAgICAgICd0YWtlcic6IHRha2VyLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnaG9sZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydiYWxhbmNlJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnbGV2ZWwnOiAyLCAvLyAxIGJlc3QgYmlkYXNrLCAyIGFnZ3JlZ2F0ZWQsIDMgZnVsbFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWRUaWNrZXIgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgcXVvdGUgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWRTdGF0cyAocmVxdWVzdCk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWyd0aW1lJ10pO1xuICAgICAgICBsZXQgYmlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYXNrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2JpZCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgYmlkID0gcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSk7XG4gICAgICAgIGlmICgnYXNrJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBhc2sgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0IChxdW90ZVsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0IChxdW90ZVsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IGJpZCxcbiAgICAgICAgICAgICdhc2snOiBhc2ssXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAocXVvdGVbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHF1b3RlWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lJ10pO1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsnc2lkZSddID09ICdidXknKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdmaWxsX2ZlZXMnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0cmFkZVsnZmlsbF9mZWVzJ10pLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3NpemUnXSksXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sIC8vIGZpeGVzIGlzc3VlICMyXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlswXSAqIDEwMDAsXG4gICAgICAgICAgICBvaGxjdlszXSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbMV0sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzVdLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBncmFudWxhcml0eSA9IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdncmFudWxhcml0eSc6IGdyYW51bGFyaXR5LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSB0aGlzLmlzbzg2MDEgKHNpbmNlKTtcbiAgICAgICAgICAgIGlmICghbGltaXQpXG4gICAgICAgICAgICAgICAgbGltaXQgPSAyMDA7IC8vIG1heCA9IDIwMFxuICAgICAgICAgICAgcmVxdWVzdFsnZW5kJ10gPSB0aGlzLmlzbzg2MDEgKGxpbWl0ICogZ3JhbnVsYXJpdHkgKiAxMDAwICsgc2luY2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHNJZENhbmRsZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpbWUgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnB1YmxpY0dldFRpbWUgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlODYwMSAocmVzcG9uc2VbJ2lzbyddKTtcbiAgICB9XG5cbiAgICBnZXRPcmRlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgICAgIGxldCBzdGF0dXNlcyA9IHtcbiAgICAgICAgICAgICdwZW5kaW5nJzogJ29wZW4nLFxuICAgICAgICAgICAgJ2FjdGl2ZSc6ICdvcGVuJyxcbiAgICAgICAgICAgICdvcGVuJzogJ29wZW4nLFxuICAgICAgICAgICAgJ2RvbmUnOiAnY2xvc2VkJyxcbiAgICAgICAgICAgICdjYW5jZWxlZCc6ICdjYW5jZWxlZCcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVTdHJpbmcgKHN0YXR1c2VzLCBzdGF0dXMsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydjcmVhdGVkX2F0J10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldCkge1xuICAgICAgICAgICAgaWYgKG9yZGVyWydwcm9kdWN0X2lkJ10gaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsncHJvZHVjdF9pZCddXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gdGhpcy5nZXRPcmRlclN0YXR1cyAob3JkZXJbJ3N0YXR1cyddKTtcbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncHJpY2UnKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3NpemUnKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2ZpbGxlZF9zaXplJyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBhbW91bnQgLSBmaWxsZWQ7XG4gICAgICAgIGxldCBjb3N0ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnZXhlY3V0ZWRfdmFsdWUnKTtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHJlbWFpbmluZyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N0YXR1cyc6ICdhbGwnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3Byb2R1Y3RfaWQnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncHJvZHVjdF9pZCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzdGF0dXMnOiAnZG9uZScsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncHJvZHVjdF9pZCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgLy8gbGV0IG9pZCA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdzaXplJzogYW1vdW50LFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZURlbGV0ZU9yZGVyc0lkICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGdldFBheW1lbnRNZXRob2RzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0UGF5bWVudE1ldGhvZHMgKCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBhc3luYyBkZXBvc2l0IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdERlcG9zaXRzJztcbiAgICAgICAgaWYgKCdwYXltZW50X21ldGhvZF9pZCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBkZXBvc2l0IGZyb20gYSBwYXltZW50X21ldGhvZCwgbGlrZSBhIGJhbmsgYWNjb3VudFxuICAgICAgICAgICAgbWV0aG9kICs9ICdQYXltZW50TWV0aG9kJztcbiAgICAgICAgfSBlbHNlIGlmICgnY29pbmJhc2VfYWNjb3VudF9pZCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBkZXBvc2l0IGludG8gR0RBWCBhY2NvdW50IGZyb20gYSBDb2luYmFzZSBhY2NvdW50XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0NvaW5iYXNlQWNjb3VudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZXBvc2l0IG1ldGhvZG90aGVyd2lzZSB3ZSBkaWQgbm90IHJlY2VpdmUgYSBzdXBwb3J0ZWQgZGVwb3NpdCBsb2NhdGlvblxuICAgICAgICAgICAgLy8gcmVsZXZhbnQgZG9jcyBsaW5rIGZvciB0aGUgR29vZ2xlcnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5nZGF4LmNvbS8jZGVwb3NpdHNcbiAgICAgICAgICAgIHRocm93IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZGVwb3NpdCgpIHJlcXVpcmVzIG9uZSBvZiBgY29pbmJhc2VfYWNjb3VudF9pZGAgb3IgYHBheW1lbnRfbWV0aG9kX2lkYCBleHRyYSBwYXJhbXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGRlcG9zaXQoKSBlcnJvcjogJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RXaXRoZHJhd2Fscyc7XG4gICAgICAgIGlmICgncGF5bWVudF9tZXRob2RfaWQnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdQYXltZW50TWV0aG9kJztcbiAgICAgICAgfSBlbHNlIGlmICgnY29pbmJhc2VfYWNjb3VudF9pZCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0NvaW5iYXNlQWNjb3VudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0NyeXB0byc7XG4gICAgICAgICAgICByZXF1ZXN0WydjcnlwdG9fYWRkcmVzcyddID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHdpdGhkcmF3KCkgZXJyb3I6ICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAobWV0aG9kID09ICdHRVQnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVxdWVzdCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgcmVxdWVzdDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gJyc7XG4gICAgICAgICAgICBpZiAobWV0aG9kICE9ICdHRVQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IGJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGV0IHBheWxvYWQgPSAoYm9keSkgPyBib2R5IDogJyc7XG4gICAgICAgICAgICBsZXQgd2hhdCA9IG5vbmNlICsgbWV0aG9kICsgcmVxdWVzdCArIHBheWxvYWQ7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHdoYXQpLCBzZWNyZXQsICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDQi1BQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0NCLUFDQ0VTUy1TSUdOJzogdGhpcy5kZWNvZGUgKHNpZ25hdHVyZSksXG4gICAgICAgICAgICAgICAgJ0NCLUFDQ0VTUy1USU1FU1RBTVAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQ0ItQUNDRVNTLVBBU1NQSFJBU0UnOiB0aGlzLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID09IDQwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlIChib2R5KTtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ3ByaWNlIHRvbyBzbWFsbCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pbmRleE9mICgncHJpY2UgdG9vIHByZWNpc2UnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKHRoaXMuaWQgKyAnICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT0gJ0ludmFsaWQgQVBJIEtleScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBnZW1pbmkgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZ2VtaW5pJyxcbiAgICAgICAgICAgICduYW1lJzogJ0dlbWluaScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLCAvLyAyMDAgZm9yIHByaXZhdGUgQVBJXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzgxNjg1Ny1jZTdiZTY0NC02MDk2LTExZTctODJkNi0zYzI1NzI2MzIyOWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmdlbWluaS5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9nZW1pbmkuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZG9jcy5nZW1pbmkuY29tL3Jlc3QtYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ltYm9scycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHVidGlja2VyL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1Y3Rpb24ve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1Y3Rpb24ve3N5bWJvbH0vaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbC9zZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRldm9sdW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdC97Y3VycmVuY3l9L25ld0FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3L3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlYXJ0YmVhdCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBpZDtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBtYXJrZXQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHVwcGVyY2FzZS5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB1cHBlcmNhc2Uuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFB1YnRpY2tlclN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd2b2x1bWUnXVsndGltZXN0YW1wJ107XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gbWFya2V0WydiYXNlJ107XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ11bYmFzZVZvbHVtZV0pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXVtxdW90ZVZvbHVtZV0pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcG1zJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYW1vdW50J10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjbGllbnRfb3JkZXJfaWQnOiBub25jZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiAnZXhjaGFuZ2UgbGltaXQnLCAvLyBnZW1pbmkgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5XG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlck5ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJfaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdyZXF1ZXN0JzogdXJsLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHRoaXMuc3RyaW5nVG9CYXNlNjQgKHRoaXMuZW5jb2RlIChwYXlsb2FkKSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjIChwYXlsb2FkLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMzg0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICAgICAgJ1gtR0VNSU5JLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdYLUdFTUlOSS1QQVlMT0FEJzogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAnWC1HRU1JTkktU0lHTkFUVVJFJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEluc3VmZmljaWVudEZ1bmRzIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGhpdGJ0YyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdoaXRidGMnLFxuICAgICAgICAgICAgJ25hbWUnOiAnSGl0QlRDJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU1NS04ZWFlYzIwZS01ZWRjLTExZTctOWM1Yi02ZGM2OWZjNDJmNWUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHA6Ly9hcGkuaGl0YnRjLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2hpdGJ0Yy5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2hpdGJ0Yy1jb20vaGl0YnRjLWFwaS9ibG9iL21hc3Rlci9BUEl2MS5tZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tzeW1ib2x9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3N5bWJvbH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7c3ltYm9sfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tzeW1ib2x9L3RyYWRlcy9yZWNlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZSwnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvcmVjZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL2J5L29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXdfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGF5bWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhZGRyZXNzL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zlcl90b190cmFkaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zlcl90b19tYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhZGRyZXNzL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW91dCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdYQlQnKVxuICAgICAgICAgICAgcmV0dXJuICdCVEMnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RSSycpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0NBVCcpXG4gICAgICAgICAgICByZXR1cm4gJ0JpdENsYXZlJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1snc3ltYm9scyddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1snc3ltYm9scyddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0Wydjb21tb2RpdHknXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ2xvdCddKTtcbiAgICAgICAgICAgIGxldCBzdGVwID0gcGFyc2VGbG9hdCAobWFya2V0WydzdGVwJ10pO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ3N0ZXAnOiBzdGVwLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSB0aGlzLnNhZmVTdHJpbmcgKHBhcmFtcywgJ3R5cGUnLCAndHJhZGluZycpO1xuICAgICAgICBtZXRob2QgKz0gJ0dldEJhbGFuY2UnO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgJ3R5cGUnKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdIChxdWVyeSk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gYmFsYW5jZVsnY3VycmVuY3lfY29kZSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGNvZGUpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZSwgJ2Nhc2gnLCAwLjApO1xuICAgICAgICAgICAgZnJlZSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCAnYmFsYW5jZScsIGZyZWUpO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZSwgJ3Jlc2VydmVkJywgMC4wKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnJlZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHVzZWQsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdGhpcy5zdW0gKGZyZWUsIHVzZWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlbicpLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWUnKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWVfcXVvdGUnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRpY2tlclsnbWVzc2FnZSddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbMF0sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbM10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWzNdKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWzRdLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbMV0pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWzJdKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgLy8gJ2Zyb20nOiAwLFxuICAgICAgICAgICAgLy8gJ3RpbGwnOiAxMDAsXG4gICAgICAgICAgICAvLyAnYnknOiAndHMnLCAvLyBvciBieSB0cmFkZV9pZFxuICAgICAgICAgICAgLy8gJ3NvcnQnOiAnZGVzYycsIC8vIG9yIGFzY1xuICAgICAgICAgICAgLy8gJ3N0YXJ0X2luZGV4JzogMCxcbiAgICAgICAgICAgIC8vICdtYXhfcmVzdWx0cyc6IDEwMDAsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X2l0ZW0nOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfcHJpY2UnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfYW1vdW50JzogJ251bWJlcicsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X3RpZCc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF90aW1lc3RhbXAnOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF93cmFwJzogZmFsc2UsXG4gICAgICAgICAgICAnc2lkZSc6ICd0cnVlJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAvLyBjaGVjayBpZiBhbW91bnQgY2FuIGJlIGV2ZW5seSBkaXZpZGVkIGludG8gbG90c1xuICAgICAgICAvLyB0aGV5IHdhbnQgaW50ZWdlciBxdWFudGl0eSBpbiBsb3QgdW5pdHNcbiAgICAgICAgbGV0IHF1YW50aXR5ID0gcGFyc2VGbG9hdCAoYW1vdW50KSAvIG1hcmtldFsnbG90J107XG4gICAgICAgIGxldCB3aG9sZUxvdHMgPSBNYXRoLnJvdW5kIChxdWFudGl0eSk7XG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gcXVhbnRpdHkgLSB3aG9sZUxvdHM7XG4gICAgICAgIGlmIChNYXRoLmFicyAoZGlmZmVyZW5jZSkgPiBtYXJrZXRbJ3N0ZXAnXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBvcmRlciBhbW91bnQgc2hvdWxkIGJlIGV2ZW5seSBkaXZpc2libGUgYnkgbG90IHVuaXQgc2l6ZSBvZiAnICsgbWFya2V0Wydsb3QnXS50b1N0cmluZyAoKSk7XG4gICAgICAgIGxldCBjbGllbnRPcmRlcklkID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogY2xpZW50T3JkZXJJZC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncXVhbnRpdHknOiB3aG9sZUxvdHMudG9TdHJpbmcgKCksIC8vIHF1YW50aXR5IGluIGludGVnZXIgbG90IHVuaXRzXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2UudG9GaXhlZCAoMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ3RpbWVJbkZvcmNlJ10gPSAnRk9LJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYWRpbmdQb3N0TmV3T3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ0V4ZWN1dGlvblJlcG9ydCddWydjbGllbnRPcmRlcklkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYWRpbmdQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY2xpZW50T3JkZXJJZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBnZXRPcmRlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgICAgIGxldCBzdGF0dXNlcyA9IHtcbiAgICAgICAgICAgICduZXcnOiAnb3BlbicsXG4gICAgICAgICAgICAncGFydGlhbGx5RmlsbGVkJzogJ3BhcnRpYWwnLFxuICAgICAgICAgICAgJ2ZpbGxlZCc6ICdjbG9zZWQnLFxuICAgICAgICAgICAgJ2NhbmNlbGVkJzogJ2NhbmNlbGVkJyxcbiAgICAgICAgICAgICdyZWplY3RlZCc6ICdyZWplY3RlZCcsXG4gICAgICAgICAgICAnZXhwaXJlZCc6ICdleHBpcmVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVN0cmluZyAoc3RhdHVzZXMsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWydsYXN0VGltZXN0YW1wJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnc3ltYm9sJ11dO1xuICAgICAgICBsZXQgc3RhdHVzID0gdGhpcy5zYWZlU3RyaW5nIChvcmRlciwgJ29yZGVyU3RhdHVzJyk7XG4gICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICBzdGF0dXMgPSB0aGlzLmdldE9yZGVyU3RhdHVzIChzdGF0dXMpO1xuICAgICAgICBsZXQgYXZlcmFnZVByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnYXZnUHJpY2UnLCAwLjApO1xuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdvcmRlclByaWNlJyk7XG4gICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdvcmRlclF1YW50aXR5Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdxdWFudGl0eUxlYXZlcycpO1xuICAgICAgICBsZXQgZmlsbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGFtb3VudCAqPSBtYXJrZXRbJ2xvdCddO1xuICAgICAgICAgICAgcmVtYWluaW5nICo9IG1hcmtldFsnbG90J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFtb3VudCAmJiByZW1haW5pbmcpIHtcbiAgICAgICAgICAgIGZpbGxlZCA9IGFtb3VudCAtIHJlbWFpbmluZztcbiAgICAgICAgICAgIGNvc3QgPSBhdmVyYWdlUHJpY2UgKiBmaWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydjbGllbnRPcmRlcklkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXMsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiBvcmRlclsndHlwZSddLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhZGluZ0dldE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NsaWVudF9vcmRlcl9pZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ29yZGVycyddWzBdKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgc3RhdHVzZXMgPSBbICduZXcnLCAncGFydGlhbGx5RmlpbGVkJyBdO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzb3J0JzogJ2Rlc2MnLFxuICAgICAgICAgICAgJ3N0YXR1c2VzJzogc3RhdHVzZXMuam9pbiAoJywnKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydzeW1ib2xzJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFkaW5nR2V0T3JkZXJzQWN0aXZlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsnb3JkZXJzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3RhdHVzZXMgPSBbICdmaWxsZWQnLCAnY2FuY2VsZWQnLCAncmVqZWN0ZWQnLCAnZXhwaXJlZCcgXTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc29ydCc6ICdkZXNjJyxcbiAgICAgICAgICAgICdzdGF0dXNlcyc6IHN0YXR1c2VzLmpvaW4gKCcsJyksXG4gICAgICAgICAgICAnbWF4X3Jlc3VsdHMnOiAxMDAwLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N5bWJvbHMnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYWRpbmdHZXRPcmRlcnNSZWNlbnQgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydvcmRlcnMnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wYXltZW50UG9zdFBheW91dCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9jb2RlJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsndHJhbnNhY3Rpb24nXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLycgKyAnYXBpJyArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIGFwaSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IHsgJ25vbmNlJzogbm9uY2UsICdhcGlrZXknOiB0aGlzLmFwaUtleSB9O1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmV4dGVuZCAocGF5bG9hZCwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJylcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBheWxvYWQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB1cmw7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aCArPSBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdYLVNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJykudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnY29kZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnRXhlY3V0aW9uUmVwb3J0JyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnRXhlY3V0aW9uUmVwb3J0J11bJ29yZGVyUmVqZWN0UmVhc29uJ10gPT0gJ29yZGVyRXhjZWVkc0xpbWl0JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgaGl0YnRjID0gcmVxdWlyZSAoJy4vaGl0YnRjJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgT3JkZXJOb3RGb3VuZCB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBoaXRidGMyIGV4dGVuZHMgaGl0YnRjIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdoaXRidGMyJyxcbiAgICAgICAgICAgICduYW1lJzogJ0hpdEJUQyB2MicsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0hLJywgLy8gSG9uZyBLb25nXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJzInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgLy8gb2xkZXIgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICdNMScsXG4gICAgICAgICAgICAgICAgJzNtJzogJ00zJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnTTUnLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnTTE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJ00zMCcsIC8vIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAnMWgnOiAnSDEnLFxuICAgICAgICAgICAgICAgICc0aCc6ICdINCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJ0QxJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnRDcnLFxuICAgICAgICAgICAgICAgICcxTSc6ICcxTScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU1NS04ZWFlYzIwZS01ZWRjLTExZTctOWM1Yi02ZGM2OWZjNDJmNWUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmhpdGJ0Yy5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9oaXRidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYXBpLmhpdGJ0Yy5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wnLCAvLyBBdmFpbGFibGUgQ3VycmVuY3kgU3ltYm9sc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbC97c3ltYm9sfScsIC8vIEdldCBzeW1ib2wgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JywgLy8gQXZhaWxhYmxlIEN1cnJlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeS97Y3VycmVuY3l9JywgLy8gR2V0IGN1cnJlbmN5IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLCAvLyBUaWNrZXIgbGlzdCBmb3IgYWxsIHN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve3N5bWJvbH0nLCAvLyBUaWNrZXIgZm9yIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsIC8vIFRyYWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vay97c3ltYm9sfScsIC8vIE9yZGVyYm9va1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmRsZXMve3N5bWJvbH0nLCAvLyBDYW5kbGVzXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIExpc3QgeW91ciBjdXJyZW50IG9wZW4gb3JkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIve2NsaWVudE9yZGVySWR9JywgLy8gR2V0IGEgc2luZ2xlIG9yZGVyIGJ5IGNsaWVudE9yZGVySWRcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkaW5nL2JhbGFuY2UnLCAvLyBHZXQgdHJhZGluZyBiYWxhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZy9mZWUve3N5bWJvbH0nLCAvLyBHZXQgdHJhZGluZyBmZWUgcmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3RvcnkvdHJhZGVzJywgLy8gR2V0IGhpc3RvcmljYWwgdHJhZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeS9vcmRlcicsIC8vIEdldCBoaXN0b3JpY2FsIG9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3Rvcnkvb3JkZXIve2lkfS90cmFkZXMnLCAvLyBHZXQgaGlzdG9yaWNhbCB0cmFkZXMgYnkgc3BlY2lmaWVkIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9iYWxhbmNlJywgLy8gR2V0IG1haW4gYWNjY291bnQgYmFsYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQvdHJhbnNhY3Rpb25zJywgLy8gR2V0IGFjY291bnQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC90cmFuc2FjdGlvbnMve2lkfScsIC8vIEdldCBhY2NvdW50IHRyYW5zYWN0aW9uIGJ5IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vYWRkcmVzcy97Y3VycmVuY3l9JywgLy8gR2V0IGRlcG9zaXQgY3J5cHJvIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLCAvLyBDcmVhdGUgbmV3IG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcnLCAvLyBXaXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2NyeXB0by9hZGRyZXNzL3tjdXJyZW5jeX0nLCAvLyBDcmVhdGUgbmV3IGRlcG9zaXQgY3J5cHJvIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L3RyYW5zZmVyJywgLy8gVHJhbnNmZXIgYW1vdW50IHRvIHRyYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDcmVhdGUgbmV3IG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcve2lkfScsIC8vIENvbW1pdCB3aXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIENhbmNlbCBhbGwgb3BlbiBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDYW5jZWwgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2NyeXB0by93aXRoZHJhdy97aWR9JywgLy8gUm9sbGJhY2sgd2l0aGRyYXcgY3J5cHJvXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwYXRjaCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDYW5jZWwgUmVwbGFjZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IC0wLjAxIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjEgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdDQVQnKVxuICAgICAgICAgICAgcmV0dXJuICdCaXRDbGF2ZSc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBjdXJyZW5jeUlkIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JpdENsYXZlJylcbiAgICAgICAgICAgIHJldHVybiAnQ0FUJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGZlZVRvUHJlY2lzaW9uIChzeW1ib2wsIGZlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZSAoZmVlLCA4KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnYmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IGxvdCA9IHBhcnNlRmxvYXQgKG1hcmtldFsncXVhbnRpdHlJbmNyZW1lbnQnXSk7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHBhcnNlRmxvYXQgKG1hcmtldFsndGlja1NpemUnXSk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdwcmljZSc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0Wyd0aWNrU2l6ZSddKSxcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nIChtYXJrZXRbJ3F1YW50aXR5SW5jcmVtZW50J10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCB0YWtlciA9IHBhcnNlRmxvYXQgKG1hcmtldFsndGFrZUxpcXVpZGl0eVJhdGUnXSk7XG4gICAgICAgICAgICBsZXQgbWFrZXIgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3Byb3ZpZGVMaXF1aWRpdHlSYXRlJ10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ3N0ZXAnOiBzdGVwLFxuICAgICAgICAgICAgICAgICd0YWtlcic6IHRha2VyLFxuICAgICAgICAgICAgICAgICdtYWtlcic6IG1ha2VyLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCAqIHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zYWZlU3RyaW5nIChwYXJhbXMsICd0eXBlJywgJ3RyYWRpbmcnKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlR2V0JyArIHRoaXMuY2FwaXRhbGl6ZSAodHlwZSkgKyAnQmFsYW5jZSc7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXNbbWV0aG9kXSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGNvZGUpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydyZXNlcnZlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFkJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydvcGVuJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ21heCddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydtaW4nXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnY2xvc2UnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsndm9sdW1lUXVvdGUnXSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q2FuZGxlc1N5bWJvbCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9va1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkJywgJ2FzaycsICdwcmljZScsICdzaXplJyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvdycpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ29wZW4nKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdjbG9zZScpLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWUnKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWVRdW90ZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRpY2tlclsnbWVzc2FnZSddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpZCA9IHRyYWRlWydzeW1ib2wnXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnZmVlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gbWFya2V0ID8gbWFya2V0WydxdW90ZSddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZmVlID0ge1xuICAgICAgICAgICAgICAgICdjb3N0JzogcGFyc2VGbG9hdCAodHJhZGVbJ2ZlZSddKSxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yZGVySWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnY2xpZW50T3JkZXJJZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBvcmRlcklkID0gdHJhZGVbJ2NsaWVudE9yZGVySWQnXTtcbiAgICAgICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pO1xuICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VGbG9hdCAodHJhZGVbJ3F1YW50aXR5J10pO1xuICAgICAgICBsZXQgY29zdCA9IHByaWNlICogYW1vdW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXJJZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgY2xpZW50T3JkZXJJZCA9IHRoaXMudXVpZCAoKTtcbiAgICAgICAgLy8gdGhlaXIgbWF4IGFjY2VwdGVkIGxlbmd0aCBpcyAzMiBjaGFyYWN0ZXJzXG4gICAgICAgIGNsaWVudE9yZGVySWQgPSBjbGllbnRPcmRlcklkLnJlcGxhY2UgKCctJywgJycpO1xuICAgICAgICBjbGllbnRPcmRlcklkID0gY2xpZW50T3JkZXJJZC5zbGljZSAoMCwgMzIpO1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0IChhbW91bnQpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogY2xpZW50T3JkZXJJZCxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncXVhbnRpdHknOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3ByaWNlJ10gPSB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFsndGltZUluRm9yY2UnXSA9ICdGT0snO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlciAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlKTtcbiAgICAgICAgbGV0IGlkID0gb3JkZXJbJ2lkJ107XG4gICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IG9yZGVyO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVPcmRlckNsaWVudE9yZGVySWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY2xpZW50T3JkZXJJZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBjcmVhdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2NyZWF0ZWRBdCcgaW4gb3JkZXIpXG4gICAgICAgICAgICBjcmVhdGVkID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydjcmVhdGVkQXQnXSk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3VwZGF0ZWRBdCcgaW4gb3JkZXIpXG4gICAgICAgICAgICB1cGRhdGVkID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWyd1cGRhdGVkQXQnXSk7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydzeW1ib2wnXV07XG4gICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncXVhbnRpdHknKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2N1bVF1YW50aXR5Jyk7XG4gICAgICAgIGxldCBzdGF0dXMgPSBvcmRlclsnc3RhdHVzJ107XG4gICAgICAgIGlmIChzdGF0dXMgPT0gJ25ldycpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdvcGVuJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdvcGVuJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ3BhcnRpYWxseUZpbGxlZCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdvcGVuJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ2ZpbGxlZCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZCA9IG9yZGVyWydjbGllbnRPcmRlcklkJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3ByaWNlJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJpY2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm9yZGVycylcbiAgICAgICAgICAgICAgICBwcmljZSA9IHRoaXMub3JkZXJzW2lkXS5wcmljZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVtYWluaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbGVkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gYW1vdW50IC0gZmlsbGVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJpY2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29zdCA9IGZpbGxlZCAqIHByaWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogY3JlYXRlZCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAoY3JlYXRlZCksXG4gICAgICAgICAgICAnY3JlYXRlZCc6IGNyZWF0ZWQsXG4gICAgICAgICAgICAndXBkYXRlZCc6IHVwZGF0ZWQsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0SGlzdG9yeU9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBudW1PcmRlcnMgPSByZXNwb25zZS5sZW5ndGg7XG4gICAgICAgIGlmIChudW1PcmRlcnMgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbMF0pO1xuICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgb3JkZXIgJyArIGlkICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEFjdGl2ZU9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlckNsaWVudE9yZGVySWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY2xpZW50T3JkZXJJZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnc3ltYm9sJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydzeW1ib2wnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGlmIChzaW5jZSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnZnJvbSddID0gdGhpcy5pc284NjAxIChzaW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0SGlzdG9yeU9yZGVyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAvLyAnc3ltYm9sJzogJ0JUQy9VU0QnLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgLy8gJ3NvcnQnOiAnREVTQycsIC8vIG9yICdBU0MnXG4gICAgICAgICAgICAvLyAnYnknOiAndGltZXN0YW1wJywgLy8gb3IgJ2lkJ1x0U3RyaW5nXHR0aW1lc3RhbXAgYnkgZGVmYXVsdCwgb3IgaWRcbiAgICAgICAgICAgIC8vICdmcm9tJzpcdCdEYXRldGltZSBvciBOdW1iZXInLCAvLyBJU08gODYwMVxuICAgICAgICAgICAgLy8gJ3RpbGwnOlx0J0RhdGV0aW1lIG9yIE51bWJlcicsXG4gICAgICAgICAgICAvLyAnbGltaXQnOiAxMDAsXG4gICAgICAgICAgICAvLyAnb2Zmc2V0JzogMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydzeW1ib2wnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0Wydmcm9tJ10gPSB0aGlzLmlzbzg2MDEgKHNpbmNlKTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRIaXN0b3J5VHJhZGVzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBY2NvdW50Q3J5cHRvQWRkcmVzc0N1cnJlbmN5ICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeUlkLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSByZXNwb25zZVsnYWRkcmVzcyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRDcnlwdG9BZGRyZXNzQ3VycmVuY3kgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHJlc3BvbnNlWydhZGRyZXNzJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGN1cnJlbmN5SWQgPSB0aGlzLmN1cnJlbmN5SWQgKGN1cnJlbmN5KTtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAoYW1vdW50KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjY291bnRDcnlwdG9XaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5SWQsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnL2FwaScgKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9IGFwaSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5lbmNvZGUgKHRoaXMuYXBpS2V5ICsgJzonICsgdGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLnN0cmluZ1RvQmFzZTY0IChwYXlsb2FkKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBcIkJhc2ljIFwiICsgdGhpcy5kZWNvZGUgKGF1dGgpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID09IDQwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlIChib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlWydlcnJvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHJlc3BvbnNlWydlcnJvciddWydtZXNzYWdlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PSAnT3JkZXIgbm90IGZvdW5kJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBvcmRlciBub3QgZm91bmQgaW4gYWN0aXZlIG9yZGVycycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlID09ICdJbnN1ZmZpY2llbnQgZnVuZHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBodW9iaSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdodW9iaScsXG4gICAgICAgICAgICAnbmFtZSc6ICdIdW9iaScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjMnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcwMDEnLFxuICAgICAgICAgICAgICAgICc1bSc6ICcwMDUnLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMDE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzAzMCcsXG4gICAgICAgICAgICAgICAgJzFoJzogJzA2MCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzEwMCcsXG4gICAgICAgICAgICAgICAgJzF3JzogJzIwMCcsXG4gICAgICAgICAgICAgICAgJzFNJzogJzMwMCcsXG4gICAgICAgICAgICAgICAgJzF5JzogJzQwMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU2OS0xNWFhN2I5YS01ZWRkLTExZTctOWU3Zi00NDc5MWY0ZWU0OWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHA6Ly9hcGkuaHVvYmkuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lmh1b2JpLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vaHVvYmlhcGkvQVBJX0RvY3NfZW4vd2lraScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAnc3RhdGljbWFya2V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH1fa2xpbmVfe3BlcmlvZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aF97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aF97aWR9X3tsZW5ndGh9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWxfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndXNkbWFya2V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH1fa2xpbmVfe3BlcmlvZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aF97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aF97aWR9X3tsZW5ndGh9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWxfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHJhZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9hY2NvdW50X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5X21hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbF9tYXJrZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X25ld19kZWFsX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X29yZGVyX2lkX2J5X3RyYWRlX2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd19jb2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfd2l0aGRyYXdfY29pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3dpdGhkcmF3X2NvaW5fcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVwYXltZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfbG9hbl9hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9sb2FucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0YycsICdzeW1ib2wnOiAnQlRDL0NOWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzdGF0aWNtYXJrZXQnLCAnY29pblR5cGUnOiAxIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGMnLCAnc3ltYm9sJzogJ0xUQy9DTlknLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3RhdGljbWFya2V0JywgJ2NvaW5UeXBlJzogMiB9LFxuICAgICAgICAgICAgICAgIC8vICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcsICd0eXBlJzogJ3VzZG1hcmtldCcsICAgICdjb2luVHlwZSc6IDEgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy50cmFkZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSAnYXZhaWxhYmxlXycgKyBsb3dlcmNhc2UgKyAnX2Rpc3BsYXknO1xuICAgICAgICAgICAgbGV0IGZyb3plbiA9ICdmcm96ZW5fJyArIGxvd2VyY2FzZSArICdfZGlzcGxheSc7XG4gICAgICAgICAgICBsZXQgbG9hbiA9ICdsb2FuXycgKyBsb3dlcmNhc2UgKyAnX2Rpc3BsYXknO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1thdmFpbGFibGVdKTtcbiAgICAgICAgICAgIGlmIChmcm96ZW4gaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbZnJvemVuXSk7XG4gICAgICAgICAgICBpZiAobG9hbiBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsndXNlZCddLCBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb2FuXSkpO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0Wyd0eXBlJ10gKyAnR2V0RGVwdGhJZCc7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7ICdpZCc6IG1hcmtldFsnaWQnXSB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0Wyd0eXBlJ10gKyAnR2V0VGlja2VySWQnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHJlc3BvbnNlWyd0aW1lJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGwnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlbicpLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2wnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0cyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydkaXJlY3Rpb24nXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IG1hcmtldFsndHlwZSddICsgJ0dldERldGFpbElkJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWyd0cmFkZXMnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkIHlldFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0sXG4gICAgICAgICAgICBvaGxjdlsxXSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzZdLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ3R5cGUnXSArICdHZXRJZEtsaW5lUGVyaW9kJztcbiAgICAgICAgbGV0IG9obGN2cyA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiBvaGxjdnM7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChvaGxjdnMsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICd0cmFkZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NvaW5fdHlwZSc6IG1hcmtldFsnY29pblR5cGUnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydxdW90ZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWV0aG9kICs9IHRoaXMuY2FwaXRhbGl6ZSAodHlwZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhZGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXTtcbiAgICAgICAgaWYgKGFwaSA9PSAndHJhZGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIHVybCArPSAnL2FwaScgKyB0aGlzLnZlcnNpb247XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmtleXNvcnQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ2FjY2Vzc19rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnY3JlYXRlZCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9IHRoaXMudXJsZW5jb2RlICh0aGlzLm9taXQgKHF1ZXJ5LCAnbWFya2V0JykpO1xuICAgICAgICAgICAgLy8gc2VjcmV0IGtleSBtdXN0IGJlIGFwcGVuZGVkIHRvIHRoZSBxdWVyeSBiZWZvcmUgc2lnbmluZ1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgKz0gJyZzZWNyZXRfa2V5PScgKyB0aGlzLnNlY3JldDtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduJ10gPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChxdWVyeVN0cmluZykpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpICsgJ19qc29uLmpzJztcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICd0cmFkZScsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBodW9iaXBybyA9IHJlcXVpcmUgKCcuL2h1b2JpcHJvLmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaHVvYmljbnkgZXh0ZW5kcyBodW9iaXBybyB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaHVvYmljbnknLFxuICAgICAgICAgICAgJ25hbWUnOiAnSHVvYmkgQ05ZJyxcbiAgICAgICAgICAgICdob3N0bmFtZSc6ICdiZS5odW9iaS5jb20nLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1NjktMTVhYTdiOWEtNWVkZC0xMWU3LTllN2YtNDQ3OTFmNGVlNDljLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2JlLmh1b2JpLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5odW9iaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2h1b2JpYXBpL0FQSV9Eb2NzL3dpa2kvUkVTVF9hcGlfcmVmZXJlbmNlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaHVvYmlwcm8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaHVvYmlwcm8nLFxuICAgICAgICAgICAgJ25hbWUnOiAnSHVvYmkgUHJvJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2FjY291bnRzJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2FjY291bnRzQnlJZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdob3N0bmFtZSc6ICdhcGkuaHVvYmkucHJvJyxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbWluJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNW1pbicsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW1pbicsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICczMG1pbicsXG4gICAgICAgICAgICAgICAgJzFoJzogJzYwbWluJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWRheScsXG4gICAgICAgICAgICAgICAgJzF3JzogJzF3ZWVrJyxcbiAgICAgICAgICAgICAgICAnMU0nOiAnMW1vbicsXG4gICAgICAgICAgICAgICAgJzF5JzogJzF5ZWFyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTY5LTE1YWE3YjlhLTVlZGQtMTFlNy05ZTdmLTQ0NzkxZjRlZTQ5Yy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuaHVvYmkucHJvJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lmh1b2JpLnBybycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vaHVvYmlhcGkvQVBJX0RvY3Mvd2lraS9SRVNUX2FwaV9yZWZlcmVuY2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ21hcmtldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5L2tsaW5lJywgLy8g6I635Y+WS+e6v+aVsOaNrlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RldGFpbC9tZXJnZWQnLCAvLyDojrflj5bogZrlkIjooYzmg4UoVGlja2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoJywgLy8g6I635Y+WIE1hcmtldCBEZXB0aCDmlbDmja5cbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsIC8vIOiOt+WPliBUcmFkZSBEZXRhaWwg5pWw5o2uXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeS90cmFkZScsIC8vIOaJuemHj+iOt+WPluacgOi/keeahOS6pOaYk+iusOW9lVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RldGFpbCcsIC8vIOiOt+WPliBNYXJrZXQgRGV0YWlsIDI05bCP5pe25oiQ5Lqk6YeP5pWw5o2uXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbW1vbi9zeW1ib2xzJywgLy8g5p+l6K+i57O757uf5pSv5oyB55qE5omA5pyJ5Lqk5piT5a+5XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29tbW9uL2N1cnJlbmN5cycsIC8vIOafpeivouezu+e7n+aUr+aMgeeahOaJgOacieW4geenjVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbW1vbi90aW1lc3RhbXAnLCAvLyDmn6Xor6Lns7vnu5/lvZPliY3ml7bpl7RcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQvYWNjb3VudHMnLCAvLyDmn6Xor6LlvZPliY3nlKjmiLfnmoTmiYDmnInotKbmiLco5Y2zYWNjb3VudC1pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2FjY291bnRzL3tpZH0vYmFsYW5jZScsIC8vIOafpeivouaMh+Wumui0puaIt+eahOS9meminVxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycy97aWR9JywgLy8g5p+l6K+i5p+Q5Liq6K6i5Y2V6K+m5oOFXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL3tpZH0vbWF0Y2hyZXN1bHRzJywgLy8g5p+l6K+i5p+Q5Liq6K6i5Y2V55qE5oiQ5Lqk5piO57uGXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzJywgLy8g5p+l6K+i5b2T5YmN5aeU5omY44CB5Y6G5Y+y5aeU5omYXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvbWF0Y2hyZXN1bHRzJywgLy8g5p+l6K+i5b2T5YmN5oiQ5Lqk44CB5Y6G5Y+y5oiQ5LqkXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHcvd2l0aGRyYXctdmlydHVhbC9hZGRyZXNzZXMnLCAvLyDmn6Xor6LomZrmi5/luIHmj5DnjrDlnLDlnYBcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL3BsYWNlJywgLy8g5Yib5bu65bm25omn6KGM5LiA5Liq5paw6K6i5Y2VICjkuIDmraXkuIvljZXvvIwg5o6o6I2Q5L2/55SoKVxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycycsIC8vIOWIm+W7uuS4gOS4quaWsOeahOiuouWNleivt+axgiDvvIjku4XliJvlu7rorqLljZXvvIzkuI3miafooYzkuIvljZXvvIlcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMve2lkfS9wbGFjZScsIC8vIOaJp+ihjOS4gOS4quiuouWNlSDvvIjku4XmiafooYzlt7LliJvlu7rnmoTorqLljZXvvIlcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMve2lkfS9zdWJtaXRjYW5jZWwnLCAvLyDnlLPor7fmkqTplIDkuIDkuKrorqLljZXor7fmsYJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMvYmF0Y2hjYW5jZWwnLCAvLyDmibnph4/mkqTplIDorqLljZVcbiAgICAgICAgICAgICAgICAgICAgICAgICdkdy9iYWxhbmNlL3RyYW5zZmVyJywgLy8g6LWE5Lqn5YiS6L2sXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHcvd2l0aGRyYXctdmlydHVhbC9jcmVhdGUnLCAvLyDnlLPor7fmj5DnjrDomZrmi5/luIFcbiAgICAgICAgICAgICAgICAgICAgICAgICdkdy93aXRoZHJhdy12aXJ0dWFsL3tpZH0vcGxhY2UnLCAvLyDnoa7orqTnlLPor7fomZrmi5/luIHmj5DnjrBcbiAgICAgICAgICAgICAgICAgICAgICAgICdkdy93aXRoZHJhdy12aXJ0dWFsL3tpZH0vY2FuY2VsJywgLy8g55Sz6K+35Y+W5raI5o+Q546w6Jma5ouf5biBXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q29tbW9uU3ltYm9scyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgbnVtTWFya2V0cyA9IG1hcmtldHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtTWFya2V0cyA8IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcHVibGljR2V0Q29tbW9uU3ltYm9scyByZXR1cm5lZCBlbXB0eSByZXNwb25zZTogJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IGJhc2VJZCA9IG1hcmtldFsnYmFzZS1jdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBtYXJrZXRbJ3F1b3RlLWN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGJhc2VJZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHF1b3RlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgaWQgPSBiYXNlSWQgKyBxdW90ZUlkO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ2Ftb3VudC1wcmVjaXNpb24nXSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBtYXJrZXRbJ3ByaWNlLXByZWNpc2lvbiddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIGxldCBtYWtlciA9IChiYXNlID09ICdPTUcnKSA/IDAgOiAwLjIgLyAxMDA7XG4gICAgICAgICAgICBsZXQgdGFrZXIgPSAoYmFzZSA9PSAnT01HJykgPyAwIDogMC4yIC8gMTAwO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogdGFrZXIsXG4gICAgICAgICAgICAgICAgJ21ha2VyJzogbWFrZXIsXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2xhc3QnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGxhc3QgPSB0aWNrZXJbJ2xhc3QnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBpZiAoJ3RzJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RzJ107XG4gICAgICAgIGxldCBiaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBhc2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnYmlkJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aWNrZXJbJ2JpZCddKVxuICAgICAgICAgICAgICAgIGJpZCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXJbJ2JpZCddLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2FzaycgaW4gdGlja2VyKSB7XG4gICAgICAgICAgICBpZiAodGlja2VyWydhc2snXSlcbiAgICAgICAgICAgICAgICBhc2sgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyWydhc2snXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aWNrZXJbJ2hpZ2gnXSxcbiAgICAgICAgICAgICdsb3cnOiB0aWNrZXJbJ2xvdyddLFxuICAgICAgICAgICAgJ2JpZCc6IGJpZCxcbiAgICAgICAgICAgICdhc2snOiBhc2ssXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdGlja2VyWydvcGVuJ10sXG4gICAgICAgICAgICAnY2xvc2UnOiB0aWNrZXJbJ2Nsb3NlJ10sXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydhbW91bnQnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aWNrZXJbJ3ZvbCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0eXBlJzogJ3N0ZXAwJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZVsndGljayddLCByZXNwb25zZVsndGljayddWyd0cyddKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFya2V0R2V0RGV0YWlsTWVyZ2VkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZVsndGljayddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0cyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydkaXJlY3Rpb24nXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlc0RhdGEgKGRhdGEsIG1hcmtldCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHRoaXMucGFyc2VUcmFkZXMgKGRhdGFbaV1bJ2RhdGEnXSwgbWFya2V0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdHJhZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRyYWRlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXRIaXN0b3J5VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3NpemUnOiAyMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXNEYXRhIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbJ2lkJ10gKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbJ29wZW4nXSxcbiAgICAgICAgICAgIG9obGN2WydoaWdoJ10sXG4gICAgICAgICAgICBvaGxjdlsnbG93J10sXG4gICAgICAgICAgICBvaGxjdlsnY2xvc2UnXSxcbiAgICAgICAgICAgIG9obGN2Wyd2b2wnXSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldEhpc3RvcnlLbGluZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncGVyaW9kJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgICAgICAnc2l6ZSc6IDIwMDAsIC8vIG1heCA9IDIwMDBcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkQWNjb3VudHMgKHJlbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChyZWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudHMgPSBhd2FpdCB0aGlzLmZldGNoQWNjb3VudHMgKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY2NvdW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYXdhaXQgdGhpcy5mZXRjaEFjY291bnRzICgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHNCeUlkID0gdGhpcy5pbmRleEJ5ICh0aGlzLmFjY291bnRzLCAnaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEFjY291bnRzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudEFjY291bnRzICgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEFjY291bnRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50QWNjb3VudHNJZEJhbGFuY2UgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLmFjY291bnRzWzBdWydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2RhdGEnXVsnbGlzdCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaV07XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gYmFsYW5jZVsnY3VycmVuY3knXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzdWx0KVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSByZXN1bHRbY3VycmVuY3ldO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09ICd0cmFkZScpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlWyd0eXBlJ10gPT0gJ2Zyb3plbicpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEFjY291bnRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdhY2NvdW50LWlkJzogdGhpcy5hY2NvdW50c1swXVsnaWQnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlICsgJy0nICsgdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyT3JkZXJzUGxhY2UgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlck9yZGVyc0lkU3VibWl0Y2FuY2VsICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9ICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHVybCArPSBhcGk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVybCArPSB0aGlzLnZlcnNpb247XG4gICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuWW1kSE1TICh0aGlzLm1pbGxpc2Vjb25kcyAoKSwgJ1QnKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdTaWduYXR1cmVNZXRob2QnOiAnSG1hY1NIQTI1NicsXG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZVZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAgICAgJ0FjY2Vzc0tleUlkJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMudXJsZW5jb2RlIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gWyBtZXRob2QsIHRoaXMuaG9zdG5hbWUsIHVybCwgYXV0aCBdLmpvaW4gKFwiXFxuXCIpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHBheWxvYWQpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgYXV0aCArPSAnJicgKyB0aGlzLnVybGVuY29kZSAoeyAnU2lnbmF0dXJlJzogc2lnbmF0dXJlIH0pO1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIGF1dGg7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaW5kZXBlbmRlbnRyZXNlcnZlIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2luZGVwZW5kZW50cmVzZXJ2ZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdJbmRlcGVuZGVudCBSZXNlcnZlJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdBVScsICdOWicgXSwgLy8gQXVzdHJhbGlhLCBOZXcgWmVhbGFuZFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDUyMTY2Mi1jZjNmNDc3Yy05YmNiLTExZTctODliYy1kMWFjODUwMTJlZGEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmluZGVwZW5kZW50cmVzZXJ2ZS5jb20vUHVibGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuaW5kZXBlbmRlbnRyZXNlcnZlLmNvbS9Qcml2YXRlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuaW5kZXBlbmRlbnRyZXNlcnZlLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5pbmRlcGVuZGVudHJlc2VydmUuY29tL0FQSScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFZhbGlkUHJpbWFyeUN1cnJlbmN5Q29kZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFZhbGlkU2Vjb25kYXJ5Q3VycmVuY3lDb2RlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VmFsaWRMaW1pdE9yZGVyVHlwZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFZhbGlkTWFya2V0T3JkZXJUeXBlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VmFsaWRPcmRlclR5cGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRWYWxpZFRyYW5zYWN0aW9uVHlwZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9yZGVyQm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhZGVIaXN0b3J5U3VtbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0UmVjZW50VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRGeFJhdGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdQbGFjZUxpbWl0T3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsYWNlTWFya2V0T3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRPcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRDbG9zZWRPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldENsb3NlZEZpbGxlZE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0T3JkZXJEZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREaWdpdGFsQ3VycmVuY3lEZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0RGlnaXRhbEN1cnJlbmN5RGVwb3NpdEFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3luY2hEaWdpdGFsQ3VycmVuY3lEZXBvc2l0QWRkcmVzc1dpdGhCbG9ja2NoYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0RpZ2l0YWxDdXJyZW5jeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVxdWVzdEZpYXRXaXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgYmFzZUN1cnJlbmNpZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFZhbGlkUHJpbWFyeUN1cnJlbmN5Q29kZXMgKCk7XG4gICAgICAgIGxldCBxdW90ZUN1cnJlbmNpZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFZhbGlkU2Vjb25kYXJ5Q3VycmVuY3lDb2RlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VDdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFzZUlkID0gYmFzZUN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYmFzZUlkVXBwZXJjYXNlID0gYmFzZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZUlkVXBwZXJjYXNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVvdGVDdXJyZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBxdW90ZUN1cnJlbmNpZXNbal07XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlSWRVcHBlcmNhc2UgPSBxdW90ZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZUlkVXBwZXJjYXNlKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBiYXNlSWQgKyAnLycgKyBxdW90ZUlkO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgbGV0IHRha2VyID0gMC41IC8gMTAwO1xuICAgICAgICAgICAgICAgIGxldCBtYWtlciA9IDAuNSAvIDEwMDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2VJZCc6IGJhc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlSWQnOiBxdW90ZUlkLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogbWFrZXIsXG4gICAgICAgICAgICAgICAgICAgICdpbmZvJzogaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5Q29kZSA9IGJhbGFuY2VbJ0N1cnJlbmN5Q29kZSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5Q29kZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBiYWxhbmNlWydBdmFpbGFibGVCYWxhbmNlJ107XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZVsnVG90YWxCYWxhbmNlJ107XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJpbWFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsnYmFzZUlkJ10sXG4gICAgICAgICAgICAnc2Vjb25kYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydxdW90ZUlkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHJlc3BvbnNlWydDcmVhdGVkVGltZXN0YW1wVXRjJ10pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAocmVzcG9uc2UsIHRpbWVzdGFtcCwgJ0J1eU9yZGVycycsICdTZWxsT3JkZXJzJywgJ1ByaWNlJywgJ1ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnQ3JlYXRlZFRpbWVzdGFtcFV0YyddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydEYXlIaWdoZXN0UHJpY2UnXSxcbiAgICAgICAgICAgICdsb3cnOiB0aWNrZXJbJ0RheUxvd2VzdFByaWNlJ10sXG4gICAgICAgICAgICAnYmlkJzogdGlja2VyWydDdXJyZW50SGlnaGVzdEJpZFByaWNlJ10sXG4gICAgICAgICAgICAnYXNrJzogdGlja2VyWydDdXJyZW50TG93ZXN0T2ZmZXJQcmljZSddLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGlja2VyWydMYXN0UHJpY2UnXSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdGlja2VyWydEYXlBdmdQcmljZSddLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aWNrZXJbJ0RheVZvbHVtZVhidEluU2Vjb25kYXJ5Q3VycnJlbmN5J10sXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0U3VtbWFyeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcmltYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgICAgICdzZWNvbmRhcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ3F1b3RlSWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ1RyYWRlVGltZXN0YW1wVXRjJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsnU2Vjb25kYXJ5Q3VycmVuY3lUcmFkZVByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ1ByaW1hcnlDdXJyZW5jeUFtb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJlY2VudFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcmltYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgICAgICdzZWNvbmRhcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ3F1b3RlSWQnXSxcbiAgICAgICAgICAgICdudW1iZXJPZlJlY2VudFRyYWRlc1RvUmV0cmlldmUnOiA1MCwgLy8gbWF4ID0gNTBcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsnVHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgY2FwaXRhbGl6ZWRPcmRlclR5cGUgPSB0aGlzLmNhcGl0YWxpemUgKHR5cGUpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ1BsYWNlJyArIGNhcGl0YWxpemVkT3JkZXJUeXBlICsgJ09yZGVyJztcbiAgICAgICAgbGV0IG9yZGVyVHlwZSA9IGNhcGl0YWxpemVkT3JkZXJUeXBlO1xuICAgICAgICBvcmRlclR5cGUgKz0gKHNpZGUgPT0gJ3NlbGwnKSA/ICAnT2ZmZXInIDogJ0JpZCc7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJlZCAoe1xuICAgICAgICAgICAgJ3ByaW1hcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ2Jhc2VJZCddLFxuICAgICAgICAgICAgJ3NlY29uZGFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsncXVvdGVJZCddLFxuICAgICAgICAgICAgJ29yZGVyVHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBvcmRlclsndm9sdW1lJ10gPSBhbW91bnQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnT3JkZXJHdWlkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyR3VpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBbXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICdhcGlLZXk9JyArIHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZT0nICsgbm9uY2UudG9TdHJpbmcgKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGtleXNvcnRlZCA9IHRoaXMua2V5c29ydCAocGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKGtleXNvcnRlZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBhdXRoLnB1c2ggKGtleSArICc9JyArIHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYXV0aC5qb2luICgnLCcpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKG1lc3NhZ2UpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMua2V5c29ydCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIC8vIHRvZG8gZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGl0Yml0IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2l0Yml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ2l0Qml0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3ODIyMTU5LTY2MTUzNjIwLTYwYWQtMTFlNy04OWU3LTAwNWY2ZDdmM2RlMC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuaXRiaXQuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lml0Yml0LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLml0Yml0LmNvbS9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lml0Yml0LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMve3N5bWJvbH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzL3tzeW1ib2x9L29yZGVyX2Jvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMve3N5bWJvbH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L2JhbGFuY2VzL3tjdXJyZW5jeUNvZGV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vZnVuZGluZ19oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRfdHJhbnNmZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vY3J5cHRvY3VycmVuY3lfZGVwb3NpdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfS9jcnlwdG9jdXJyZW5jeV93aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2lyZV93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICdYQlRVU0QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvU0dEJzogeyAnaWQnOiAnWEJUU0dEJywgJ3N5bWJvbCc6ICdCVEMvU0dEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1NHRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ1hCVEVVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0c1N5bWJvbE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0c1N5bWJvbFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHNlcnZlclRpbWVVVEMgPSAoJ3NlcnZlclRpbWVVVEMnIGluIHRpY2tlcik7XG4gICAgICAgIGlmICghc2VydmVyVGltZVVUQylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaFRpY2tlciByZXR1cm5lZCBhIGJhZCByZXNwb25zZTogJyArIHRoaXMuanNvbiAodGlja2VyKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWydzZXJ2ZXJUaW1lVVRDJ10pO1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcDI0aCddKTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aCddKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoMjRoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRoJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlblRvZGF5J10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcXVvdGVWb2x1bWUsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IGlkID0gdHJhZGVbJ21hdGNoTnVtYmVyJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnb3JkZXInOiBpZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzU3ltYm9sVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsncmVjZW50VHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZUJhbGFuY2UnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsndG90YWxCYWxhbmNlJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZmV0Y2hXYWxsZXRzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZUdldFdhbGxldHMgKCk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCB3YWxsZXRJZEluUGFyYW1zID0gKCd3YWxsZXRJZCcgaW4gcGFyYW1zKTtcbiAgICAgICAgaWYgKCF3YWxsZXRJZEluUGFyYW1zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNyZWF0ZU9yZGVyIHJlcXVpcmVzIGEgd2FsbGV0SWQgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFtb3VudCA9IGFtb3VudC50b1N0cmluZyAoKTtcbiAgICAgICAgcHJpY2UgPSBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZGlzcGxheSc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUFkZCAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHdhbGxldElkSW5QYXJhbXMgPSAoJ3dhbGxldElkJyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIXdhbGxldElkSW5QYXJhbXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgcmVxdWlyZXMgYSB3YWxsZXRJZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZURlbGV0ZVdhbGxldHNXYWxsZXRJZE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gbm9uY2U7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IFsgbWV0aG9kLCB1cmwsIGJvZHksIG5vbmNlLCB0aW1lc3RhbXAgXTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gbm9uY2UgKyB0aGlzLmpzb24gKGF1dGgpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChtZXNzYWdlKSwgJ3NoYTI1NicsICdiaW5hcnknKTtcbiAgICAgICAgICAgIGxldCBiaW5oYXNoID0gdGhpcy5iaW5hcnlDb25jYXQgKHVybCwgaGFzaCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjIChiaW5oYXNoLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHNlbGYuYXBpS2V5ICsgJzonICsgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ1gtQXV0aC1UaW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgJ1gtQXV0aC1Ob25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2NvZGUnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGJ0Y2JveCA9IHJlcXVpcmUgKCcuL2J0Y2JveC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGp1YmkgZXh0ZW5kcyBidGNib3gge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2p1YmknLFxuICAgICAgICAgICAgJ25hbWUnOiAnanViaS5jb20nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1ODEtOWQzOTdkOWEtNWVkZC0xMWU3LThmYjktNWQ4MjM2YzBlNjkyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5qdWJpLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuanViaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuanViaS5jb20vaGVscC9hcGkuaHRtbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0QWxsdGlja2VyICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gJ0NOWSc7IC8vIHRvZG9cbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZU5vdEF2YWlsYWJsZSwgRXhjaGFuZ2VFcnJvciwgT3JkZXJOb3RGb3VuZCwgRERvU1Byb3RlY3Rpb24sIEludmFsaWROb25jZSwgSW5zdWZmaWNpZW50RnVuZHMsIENhbmNlbFBlbmRpbmcsIEludmFsaWRPcmRlciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mga3Jha2VuIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2tyYWtlbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdLcmFrZW4nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcwJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAzMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgLy8gbmV3IG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhcyc6IHtcbiAgICAgICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHNCeUFsdG5hbWUnOiB7fSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNScsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICczMCcsXG4gICAgICAgICAgICAgICAgJzFoJzogJzYwJyxcbiAgICAgICAgICAgICAgICAnNGgnOiAnMjQwJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMTQ0MCcsXG4gICAgICAgICAgICAgICAgJzF3JzogJzEwMDgwJyxcbiAgICAgICAgICAgICAgICAnMncnOiAnMjE2MDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1OTktMjI3MDkzMDQtNWVkZS0xMWU3LTlkZTEtOWYzMzczMmUxNTA5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5rcmFrZW4uY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmtyYWtlbi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5rcmFrZW4uY29tL2VuLXVzL2hlbHAvYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9ub3RoaW5naXNkZWFkL25wbS1rcmFrZW4tYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICdmZWVzJzogJ2h0dHBzOi8vd3d3LmtyYWtlbi5jb20vZW4tdXMvaGVscC9mZWVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXNzZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBc3NldFBhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT0hMQycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3ByZWFkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RpbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWRkT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDbG9zZWRPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RlcG9zaXRBZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RlcG9zaXRNZXRob2RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEZXBvc2l0U3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMZWRnZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcGVuUG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRdWVyeUxlZGdlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1F1ZXJ5T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRdWVyeVRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGVCYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZXNIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZVZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dpdGhkcmF3Q2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dpdGhkcmF3U3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29zdFRvUHJlY2lzaW9uIChzeW1ib2wsIGNvc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ1bmNhdGUgKHBhcnNlRmxvYXQgKGNvc3QpLCB0aGlzLm1hcmtldHNbc3ltYm9sXVsncHJlY2lzaW9uJ11bJ3ByaWNlJ10pO1xuICAgIH1cblxuICAgIGZlZVRvUHJlY2lzaW9uIChzeW1ib2wsIGZlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZSAocGFyc2VGbG9hdCAoZmVlKSwgdGhpcy5tYXJrZXRzW3N5bWJvbF1bJ3ByZWNpc2lvbiddWydhbW91bnQnXSk7XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChib2R5LmluZGV4T2YgKCdJbnZhbGlkIG5vbmNlJykgPj0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTm9uY2UgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ0luc3VmZmljaWVudCBmdW5kcycpID49IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ0NhbmNlbCBwZW5kaW5nJykgPj0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBDYW5jZWxQZW5kaW5nICh0aGlzLmlkICsgJyAnICsgYm9keSk7XG4gICAgICAgIGlmIChib2R5LmluZGV4T2YgKCdJbnZhbGlkIGFyZ3VtZW50czp2b2x1bWUnKSA+PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBc3NldFBhaXJzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydyZXN1bHQnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW2lkXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydiYXNlJ107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlJ107XG4gICAgICAgICAgICBpZiAoKGJhc2VbMF0gPT0gJ1gnKSB8fCAoYmFzZVswXSA9PSAnWicpKVxuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnNsaWNlICgxKTtcbiAgICAgICAgICAgIGlmICgocXVvdGVbMF0gPT0gJ1gnKSB8fCAocXVvdGVbMF0gPT0gJ1onKSlcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHF1b3RlLnNsaWNlICgxKTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgZGFya3Bvb2wgPSBpZC5pbmRleE9mICgnLmQnKSA+PSAwO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGRhcmtwb29sID8gbWFya2V0WydhbHRuYW1lJ10gOiAoYmFzZSArICcvJyArIHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBtYWtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnZmVlc19tYWtlcicgaW4gbWFya2V0KSB7XG4gICAgICAgICAgICAgICAgbWFrZXIgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ2ZlZXNfbWFrZXInXVswXVsxXSkgLyAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ2xvdF9kZWNpbWFscyddLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IG1hcmtldFsncGFpcl9kZWNpbWFscyddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2Rhcmtwb29sJzogZGFya3Bvb2wsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ2FsdG5hbWUnOiBtYXJrZXRbJ2FsdG5hbWUnXSxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAndGFrZXInOiBwYXJzZUZsb2F0IChtYXJrZXRbJ2ZlZXMnXVswXVsxXSkgLyAxMDAsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IGxvdCxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwZW5kSW5hY3RpdmVNYXJrZXRzIChyZXN1bHQpO1xuICAgICAgICB0aGlzLm1hcmtldHNCeUFsdG5hbWUgPSB0aGlzLmluZGV4QnkgKHJlc3VsdCwgJ2FsdG5hbWUnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhcHBlbmRJbmFjdGl2ZU1hcmtldHMgKHJlc3VsdCA9IFtdKSB7XG4gICAgICAgIGxldCBwcmVjaXNpb24gPSB7ICdhbW91bnQnOiA4LCAncHJpY2UnOiA4IH07XG4gICAgICAgIGxldCBjb3N0TGltaXRzID0geyAnbWluJzogMCwgJ21heCc6IHVuZGVmaW5lZCB9O1xuICAgICAgICBsZXQgcHJpY2VMaW1pdHMgPSB7ICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLCAnbWF4JzogdW5kZWZpbmVkIH07XG4gICAgICAgIGxldCBhbW91bnRMaW1pdHMgPSB7ICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSwgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSkgfTtcbiAgICAgICAgbGV0IGxpbWl0cyA9IHsgJ2Ftb3VudCc6IGFtb3VudExpbWl0cywgJ3ByaWNlJzogcHJpY2VMaW1pdHMsICdjb3N0JzogY29zdExpbWl0cyB9O1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAnZGFya3Bvb2wnOiBmYWxzZSxcbiAgICAgICAgICAgICdpbmZvJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ21ha2VyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3Rha2VyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdCc6IGFtb3VudExpbWl0c1snbWluJ10sXG4gICAgICAgICAgICAnYWN0aXZlJzogZmFsc2UsXG4gICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgJ2xpbWl0cyc6IGxpbWl0cyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBbXG4gICAgICAgICAgICB7ICdpZCc6ICdYWExNWkVVUicsICdzeW1ib2wnOiAnWExNL0VVUicsICdiYXNlJzogJ1hMTScsICdxdW90ZSc6ICdFVVInLCAnYWx0bmFtZSc6ICdYTE1FVVInIH0sXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kIChkZWZhdWx0cywgbWFya2V0c1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGRhcmtwb29sID0gc3ltYm9sLmluZGV4T2YgKCcuZCcpID49IDA7XG4gICAgICAgIGlmIChkYXJrcG9vbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkb2VzIG5vdCBwcm92aWRlIGFuIG9yZGVyIGJvb2sgZm9yIGRhcmtwb29sIHN5bWJvbCAnICsgc3ltYm9sKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3VsdCddW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndiddWzFdKTtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3AnXVsxXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaCddWzFdKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2wnXVsxXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiJ11bMF0pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYSddWzBdKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2MnXVswXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLnN5bWJvbHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aGlzLnN5bWJvbHNbc107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICBpZiAobWFya2V0WydhY3RpdmUnXSlcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtldFsnZGFya3Bvb2wnXSlcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMucHVzaCAobWFya2V0WydpZCddKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsdGVyID0gcGFpcnMuam9pbiAoJywnKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IGZpbHRlcixcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgZGFya3Bvb2wgPSBzeW1ib2wuaW5kZXhPZiAoJy5kJykgPj0gMDtcbiAgICAgICAgaWYgKGRhcmtwb29sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGRvZXMgbm90IHByb3ZpZGUgYSB0aWNrZXIgZm9yIGRhcmtwb29sIHN5bWJvbCAnICsgc3ltYm9sKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0gKiAxMDAwLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbMV0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbMl0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbM10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbNF0pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbNl0pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnaW50ZXJ2YWwnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc2luY2UnXSA9IHBhcnNlSW50IChzaW5jZSAvIDEwMDApO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9ITEMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9obGN2cyA9IHJlc3BvbnNlWydyZXN1bHQnXVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAob2hsY3ZzLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHByaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYW1vdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBvcmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLmZpbmRNYXJrZXRCeUFsdG5hbWVPcklkICh0cmFkZVsncGFpciddKTtcbiAgICAgICAgaWYgKCdvcmRlcnR4aWQnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlWydvcmRlcnR4aWQnXTtcbiAgICAgICAgICAgIGlkID0gdHJhZGVbJ2lkJ107XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ3RpbWUnXSAqIDEwMDApO1xuICAgICAgICAgICAgc2lkZSA9IHRyYWRlWyd0eXBlJ107XG4gICAgICAgICAgICB0eXBlID0gdHJhZGVbJ29yZGVydHlwZSddO1xuICAgICAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSk7XG4gICAgICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0ICh0cmFkZVsndm9sJ10pO1xuICAgICAgICAgICAgaWYgKCdmZWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gbWFya2V0WydxdW90ZSddO1xuICAgICAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0cmFkZVsnZmVlJ10pLFxuICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWzJdICogMTAwMCk7XG4gICAgICAgICAgICBzaWRlID0gKHRyYWRlWzNdID09ICdzJykgPyAnc2VsbCcgOiAnYnV5JztcbiAgICAgICAgICAgIHR5cGUgPSAodHJhZGVbNF0gPT0gJ2wnKSA/ICdsaW1pdCcgOiAnbWFya2V0JztcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCAodHJhZGVbMF0pO1xuICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAodHJhZGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzeW1ib2wgPSAobWFya2V0KSA/IG1hcmtldFsnc3ltYm9sJ10gOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gcmVzcG9uc2VbJ3Jlc3VsdCddW2lkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHRyYWRlcywgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZXMpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgY29kZSA9IGN1cnJlbmN5O1xuICAgICAgICAgICAgLy8gWC1JU080MjE3LUEzIHN0YW5kYXJkIGN1cnJlbmN5IGNvZGVzXG4gICAgICAgICAgICBpZiAoY29kZVswXSA9PSAnWCcpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5zbGljZSAoMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVbMF0gPT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUuc2xpY2UgKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjb2RlKTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnb3JkZXJ0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICd2b2x1bWUnOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBZGRPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHJlc3BvbnNlWydyZXN1bHQnXVsndHhpZCddLmxlbmd0aDtcbiAgICAgICAgbGV0IGlkID0gKGxlbmd0aCA+IDEpID8gcmVzcG9uc2VbJ3Jlc3VsdCddWyd0eGlkJ10gOiByZXNwb25zZVsncmVzdWx0J11bJ3R4aWQnXVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmaW5kTWFya2V0QnlBbHRuYW1lT3JJZCAoaWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c0J5QWx0bmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXJrZXRzQnlBbHRuYW1lW2lkXTtcbiAgICAgICAgfSBlbHNlIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IG9yZGVyWydkZXNjciddO1xuICAgICAgICBsZXQgc2lkZSA9IGRlc2NyaXB0aW9uWyd0eXBlJ107XG4gICAgICAgIGxldCB0eXBlID0gZGVzY3JpcHRpb25bJ29yZGVydHlwZSddO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMuZmluZE1hcmtldEJ5QWx0bmFtZU9ySWQgKGRlc2NyaXB0aW9uWydwYWlyJ10pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWydvcGVudG0nXSAqIDEwMDApO1xuICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VGbG9hdCAob3JkZXJbJ3ZvbCddKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHBhcnNlRmxvYXQgKG9yZGVyWyd2b2xfZXhlYyddKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdjb3N0Jyk7XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChkZXNjcmlwdGlvbiwgJ3ByaWNlJyk7XG4gICAgICAgIGlmICghcHJpY2UpXG4gICAgICAgICAgICBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3ByaWNlJyk7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBpZiAoJ2ZlZScgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBvcmRlclsnb2ZsYWdzJ107XG4gICAgICAgICAgICAgICAgbGV0IGZlZUNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdmZWUnKTtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjb3N0JzogZmVlQ29zdCxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZiAoJ2ZjaXEnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZVsnY3VycmVuY3knXSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmluZGV4T2YgKCdmY2liJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZWVbJ2N1cnJlbmN5J10gPSBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogb3JkZXJbJ3N0YXR1cyddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChvcmRlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5leHRlbmQgKHsgJ2lkJzogaWQgfSwgb3JkZXJzW2lkXSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5wYXJzZU9yZGVyIChvcmRlciwgbWFya2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UXVlcnlPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndHJhZGVzJzogdHJ1ZSwgLy8gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0cmFkZXMgaW4gb3V0cHV0IChvcHRpb25hbCwgZGVmYXVsdCBmYWxzZSlcbiAgICAgICAgICAgICd0eGlkJzogaWQsIC8vIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIHRyYW5zYWN0aW9uIGlkcyB0byBxdWVyeSBpbmZvIGFib3V0ICgyMCBtYXhpbXVtKVxuICAgICAgICAgICAgLy8gJ3VzZXJyZWYnOiAnb3B0aW9uYWwnLCAvLyByZXN0cmljdCByZXN1bHRzIHRvIGdpdmVuIHVzZXIgcmVmZXJlbmNlIGlkIChvcHRpb25hbClcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcnMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMucGFyc2VPcmRlciAodGhpcy5leHRlbmQgKHsgJ2lkJzogaWQgfSwgb3JkZXJzW2lkXSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQgKHsgJ2luZm8nOiByZXNwb25zZSB9LCBvcmRlcik7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLy8gJ3R5cGUnOiAnYWxsJywgLy8gYW55IHBvc2l0aW9uLCBjbG9zZWQgcG9zaXRpb24sIGNsb3NpbmcgcG9zaXRpb24sIG5vIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyAndHJhZGVzJzogZmFsc2UsIC8vIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdHJhZGVzIHJlbGF0ZWQgdG8gcG9zaXRpb24gaW4gb3V0cHV0XG4gICAgICAgICAgICAvLyAnc3RhcnQnOiAxMjM0NTY3ODkwLCAvLyBzdGFydGluZyB1bml4IHRpbWVzdGFtcCBvciB0cmFkZSB0eCBpZCBvZiByZXN1bHRzIChleGNsdXNpdmUpXG4gICAgICAgICAgICAvLyAnZW5kJzogMTIzNDU2Nzg5MCwgLy8gZW5kaW5nIHVuaXggdGltZXN0YW1wIG9yIHRyYWRlIHR4IGlkIG9mIHJlc3VsdHMgKGluY2x1c2l2ZSlcbiAgICAgICAgICAgIC8vICdvZnMnID0gcmVzdWx0IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZXNIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0cmFkZXMgPSByZXNwb25zZVsncmVzdWx0J11bJ3RyYWRlcyddO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRyYWRlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFkZXNbaWRzW2ldXVsnaWQnXSA9IGlkc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3R4aWQnOiBpZCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlLmluZGV4T2YgKCdFT3JkZXI6VW5rbm93biBvcmRlcicpID49IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCdrZXknIGluIHBhcmFtcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXNzZXQnOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgICAgIC8vICdhZGRyZXNzJzogYWRkcmVzcywgLy8gdGhleSBkb24ndCBhbGxvdyB3aXRoZHJhd2FscyB0byBkaXJlY3QgYWRkcmVzc2VzXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgXCIgd2l0aGRyYXcgcmVxdWlyZXMgYSAna2V5JyBwYXJhbWV0ZXIgKHdpdGhkcmF3YWwga2V5IG5hbWUsIGFzIHNldCB1cCBvbiB5b3VyIGFjY291bnQpXCIpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9wZW5PcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXN1bHQnXVsnb3BlbiddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENsb3NlZE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddWydjbG9zZWQnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck9yZGVyc0J5U3ltYm9sIChvcmRlcnMsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgYXBpICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmVuY29kZSAobm9uY2UgKyBib2R5KTtcbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoIChhdXRoLCAnc2hhMjU2JywgJ2JpbmFyeScpO1xuICAgICAgICAgICAgbGV0IGJpbmFyeSA9IHRoaXMuc3RyaW5nVG9CaW5hcnkgKHRoaXMuZW5jb2RlICh1cmwpKTtcbiAgICAgICAgICAgIGxldCBiaW5oYXNoID0gdGhpcy5iaW5hcnlDb25jYXQgKGJpbmFyeSwgaGFzaCk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAoYmluaGFzaCwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBUEktU2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBudW1FcnJvcnMgPSByZXNwb25zZVsnZXJyb3InXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZVsnZXJyb3InXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ11baV0gPT0gJ0VTZXJ2aWNlOlVuYXZhaWxhYmxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZU5vdEF2YWlsYWJsZSAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddW2ldID09ICdFU2VydmljZTpCdXN5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYWN4ID0gcmVxdWlyZSAoJy4vYWN4LmpzJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mga3VuYSBleHRlbmRzIGFjeCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAna3VuYScsXG4gICAgICAgICAgICAnbmFtZSc6ICdLdW5hJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVUEnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzE2OTc2MzgtOTEyODI0ZmEtYjNjMS0xMWU3LThjMzYtY2Y5NjA2ZWI5NGFjLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2t1bmEuaW8nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9rdW5hLmlvJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8va3VuYS5pby9kb2N1bWVudHMvYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2Vycy97bWFya2V0fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfYm9vay97bWFya2V0fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve21hcmtldH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZW1iZXJzL21lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9teScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVUFIJzogeyAnaWQnOiAnYnRjdWFoJywgJ3N5bWJvbCc6ICdCVEMvVUFIJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VBSCcsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA2LCAncHJpY2UnOiAwIH0sICdsb3QnOiAwLjAwMDAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgICAgICdFVEgvVUFIJzogeyAnaWQnOiAnZXRodWFoJywgJ3N5bWJvbCc6ICdFVEgvVUFIJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VBSCcsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA2LCAncHJpY2UnOiAwIH0sICdsb3QnOiAwLjAwMDAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgICAgICdHQkcvVUFIJzogeyAnaWQnOiAnZ2JndWFoJywgJ3N5bWJvbCc6ICdHQkcvVUFIJywgJ2Jhc2UnOiAnR0JHJywgJ3F1b3RlJzogJ1VBSCcsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiAzLCAncHJpY2UnOiAyIH0sICdsb3QnOiAwLjAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDAuMDEsICdtYXgnOiB1bmRlZmluZWQgfX19LCAvLyBHb2xvcyBHb2xkIChHQkcgIT0gR09MT1MpXG4gICAgICAgICAgICAgICAgJ0tVTi9CVEMnOiB7ICdpZCc6ICdrdW5idGMnLCAnc3ltYm9sJzogJ0tVTi9CVEMnLCAnYmFzZSc6ICdLVU4nLCAncXVvdGUnOiAnQlRDJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDYsICdwcmljZSc6IDYgfSwgJ2xvdCc6IDAuMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAnYmNoYnRjJywgJ3N5bWJvbCc6ICdCQ0gvQlRDJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0JUQycsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA2LCAncHJpY2UnOiA2IH0sICdsb3QnOiAwLjAwMDAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH19fSxcbiAgICAgICAgICAgICAgICAnV0FWRVMvVUFIJzogeyAnaWQnOiAnd2F2ZXN1YWgnLCAnc3ltYm9sJzogJ1dBVkVTL1VBSCcsICdiYXNlJzogJ1dBVkVTJywgJ3F1b3RlJzogJ1VBSCcsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA2LCAncHJpY2UnOiAwIH0sICdsb3QnOiAwLjAwMDAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjI1IC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjI1IC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT0gNDAwKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZGF0YVsnZXJyb3InXTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlcnJvclsnbWVzc2FnZSddO1xuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmRleE9mICgnY2Fubm90IGxvY2sgZnVuZHMnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGJvZHkgXS5qb2luICgnICcpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JNZXNzYWdlLmluZGV4T2YgKFwiQ291bGRuJ3QgZmluZCBPcmRlclwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKFsgdGhpcy5pZCwgbWV0aG9kLCB1cmwsIGNvZGUsIHJlYXNvbiwgYm9keSBdLmpvaW4gKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJCb29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyQm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTDNPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcGVuT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAvLyB0b2RvIGVtdWxhdGlvbiBvZiBmZXRjaENsb3NlZE9yZGVycywgZmV0Y2hPcmRlcnMsIGZldGNoT3JkZXJcbiAgICAgICAgLy8gd2l0aCBvcmRlciBjYWNoZSArIGZldGNoT3Blbk9yZGVyc1xuICAgICAgICAvLyBhcyBpbiBCVEMtZSwgTGlxdWksIFlvYml0LCBEU1gsIFRpZGV4LCBXRVhcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2NyZWF0ZWRfYXQnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZU15VHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsndm9sdW1lJ10sXG4gICAgICAgICAgICAnY29zdCc6IHRyYWRlWydmdW5kcyddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHRyYWRlWydvcmRlcl9pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlTXlUcmFkZXMgKHRyYWRlcywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBwYXJzZWRUcmFkZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFkZSA9IHRyYWRlc1tpXTtcbiAgICAgICAgICAgIGxldCBwYXJzZWRUcmFkZSA9IHRoaXMucGFyc2VNeVRyYWRlICh0cmFkZSwgbWFya2V0KTtcbiAgICAgICAgICAgIHBhcnNlZFRyYWRlcy5wdXNoIChwYXJzZWRUcmFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRyYWRlcztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcGVuT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VHJhZGVzTXkgKHsgJ21hcmtldCc6IG1hcmtldFsnaWQnXSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNeVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbGFrZWJ0YyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdsYWtlYnRjJyxcbiAgICAgICAgICAgICduYW1lJzogJ0xha2VCVEMnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAndmVyc2lvbic6ICdhcGlfdjInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODA3NDEyMC03MmI3YzM4YS02NjYwLTExZTctOTJkOS1kOTAyNzUwMjI4MWQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmxha2VidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lmxha2VidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cubGFrZWJ0Yy5jb20vcy9hcGlfdjInLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cubGFrZWJ0Yy5jb20vcy9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jjb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiY3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRBY2NvdW50SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0RXh0ZXJuYWxBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUcmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNba107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCY29yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW21hcmtldFsnaWQnXV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QmN0cmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyAnT3JkZXInO1xuICAgICAgICBsZXQgbWFya2V0SWQgPSB0aGlzLm1hcmtldElkIChtYXJrZXQpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFyYW1zJzogWyBwcmljZSwgYW1vdW50LCBtYXJrZXRJZCBdLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ3BhcmFtcyc6IGlkIH0pO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWljcm9zZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb247XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyBwYXRoO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcy5qb2luICgnLCcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmFtcyA9ICcnO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy51cmxlbmNvZGUgKHtcbiAgICAgICAgICAgICAgICAndG9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYWNjZXNza2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3JlcXVlc3RtZXRob2QnOiBtZXRob2QudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ2lkJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHBhcmFtcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdwYXJhbXMnOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgJ2lkJzogbm9uY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChxdWVyeSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGExJyk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuZW5jb2RlICh0aGlzLmFwaUtleSArICc6JyArIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdKc29uLVJwYy1Ub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogXCJCYXNpYyBcIiArIHRoaXMuZGVjb2RlICh0aGlzLnN0cmluZ1RvQmFzZTY0IChhdXRoKSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQsIEREb1NQcm90ZWN0aW9uIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGxpcXVpIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2xpcXVpJyxcbiAgICAgICAgICAgICduYW1lJzogJ0xpcXVpJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVUEnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDI1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICczJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAvLyBvYnNvbGV0ZSBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaENsb3NlZE9yZGVycyc6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk4MjAyMi03NWFlYTgyOC02M2EwLTExZTctOTUxMS1jYTU4NGE4ZWRkNzQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmxpcXVpLmlvL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmxpcXVpLmlvL3RhcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2xpcXVpLmlvJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vbGlxdWkuaW8vYXBpJyxcbiAgICAgICAgICAgICAgICAnZmVlcyc6ICdodHRwczovL2xpcXVpLmlvL2ZlZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjdGl2ZU9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFuc0hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvaW5EZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXdDb2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDcmVhdGVDb3Vwb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZGVlbUNvdXBvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMDEsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDAyNSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzogMC4wLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlRmVlIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UsIHRha2VyT3JNYWtlciA9ICd0YWtlcicsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgbGV0IGtleSA9ICdxdW90ZSc7XG4gICAgICAgIGxldCByYXRlID0gbWFya2V0W3Rha2VyT3JNYWtlcl07XG4gICAgICAgIGxldCBjb3N0ID0gcGFyc2VGbG9hdCAodGhpcy5jb3N0VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50ICogcmF0ZSkpO1xuICAgICAgICBpZiAoc2lkZSA9PSAnc2VsbCcpIHtcbiAgICAgICAgICAgIGNvc3QgKj0gcHJpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSAnYmFzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0eXBlJzogdGFrZXJPck1ha2VyLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0W2tleV0sXG4gICAgICAgICAgICAncmF0ZSc6IHJhdGUsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWEJUJylcbiAgICAgICAgICAgIHJldHVybiAnQlRDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RSSycpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnO1xuICAgICAgICAvLyB0aGV5IG1pc3NwZWxsIERBU0ggYXMgZHNoIDovXG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRFNIJylcbiAgICAgICAgICAgIHJldHVybiAnREFTSCc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBnZXRCYXNlUXVvdGVGcm9tTWFya2V0SWQgKGlkKSB7XG4gICAgICAgIGxldCB1cHBlcmNhc2UgPSBpZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHVwcGVyY2FzZS5zcGxpdCAoJ18nKTtcbiAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICByZXR1cm4gWyBiYXNlLCBxdW90ZSBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsncGFpcnMnXTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaWRdO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHRoaXMuZ2V0QmFzZVF1b3RlRnJvbU1hcmtldElkIChpZCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogdGhpcy5zYWZlSW50ZWdlciAobWFya2V0LCAnZGVjaW1hbF9wbGFjZXMnKSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB0aGlzLnNhZmVJbnRlZ2VyIChtYXJrZXQsICdkZWNpbWFsX3BsYWNlcycpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhbW91bnRMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IHRoaXMuc2FmZUZsb2F0IChtYXJrZXQsICdtaW5fYW1vdW50JyksXG4gICAgICAgICAgICAgICAgJ21heCc6IHRoaXMuc2FmZUZsb2F0IChtYXJrZXQsICdtYXhfYW1vdW50JyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByaWNlTGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiB0aGlzLnNhZmVGbG9hdCAobWFya2V0LCAnbWluX3ByaWNlJyksXG4gICAgICAgICAgICAgICAgJ21heCc6IHRoaXMuc2FmZUZsb2F0IChtYXJrZXQsICdtYXhfcHJpY2UnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29zdExpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnbWluJzogdGhpcy5zYWZlRmxvYXQgKG1hcmtldCwgJ21pbl90b3RhbCcpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBsaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudExpbWl0cyxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBwcmljZUxpbWl0cyxcbiAgICAgICAgICAgICAgICAnY29zdCc6IGNvc3RMaW1pdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IChtYXJrZXRbJ2hpZGRlbiddID09IDApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogbWFya2V0WydmZWUnXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAnbG90JzogYW1vdW50TGltaXRzWydtaW4nXSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiBsaW1pdHMsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGZ1bmRzID0gYmFsYW5jZXNbJ2Z1bmRzJ107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGZ1bmRzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgdXBwZXJjYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHVwcGVyY2FzZSk7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlc1snb3Blbl9vcmRlcnMnXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSBmdW5kc1tjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgdXNlZCA9IDAuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnVuZHNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgICd1c2VkJzogdXNlZCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiB0b3RhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aFBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBtYXJrZXRfaWRfaW5fcmVwb25zZSA9IChtYXJrZXRbJ2lkJ10gaW4gcmVzcG9uc2UpO1xuICAgICAgICBpZiAoIW1hcmtldF9pZF9pbl9yZXBvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyBtYXJrZXRbJ3N5bWJvbCddICsgJyBvcmRlciBib29rIGlzIGVtcHR5IG9yIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlW21hcmtldFsnaWQnXV07XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndXBkYXRlZCddICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXZnJyksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2xfY3VyJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBpZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3ltYm9scykge1xuICAgICAgICAgICAgbGV0IG51bUlkcyA9IHRoaXMuaWRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1JZHMgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VycygpIHJlcXVpcmVzIHN5bWJvbHMgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIGlkcyA9IHRoaXMuaWRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWRzID0gdGhpcy5tYXJrZXRJZHMgKHN5bWJvbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBpZHMuam9pbiAoJy0nKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwga2V5cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1trXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5mZXRjaFRpY2tlcnMgKFsgc3ltYm9sIF0sIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aWNrZXJzW3N5bWJvbF07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSB0cmFkZVsndHlwZSddO1xuICAgICAgICBpZiAoc2lkZSA9PSAnYXNrJylcbiAgICAgICAgICAgIHNpZGUgPSAnc2VsbCc7XG4gICAgICAgIGlmIChzaWRlID09ICdiaWQnKVxuICAgICAgICAgICAgc2lkZSA9ICdidXknO1xuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAodHJhZGUsICdwcmljZScpO1xuICAgICAgICBpZiAoJ3JhdGUnIGluIHRyYWRlKVxuICAgICAgICAgICAgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAodHJhZGUsICdyYXRlJyk7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICd0aWQnKTtcbiAgICAgICAgaWYgKCd0cmFkZV9pZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICd0cmFkZV9pZCcpO1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLnNhZmVTdHJpbmcgKHRyYWRlLCB0aGlzLmdldE9yZGVySWRLZXkgKCkpO1xuICAgICAgICBpZiAoJ3BhaXInIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0SWQgPSB0cmFkZVsncGFpciddO1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW21hcmtldElkXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRyYWRlWydhbW91bnQnXTtcbiAgICAgICAgbGV0IHR5cGUgPSAnbGltaXQnOyAvLyBhbGwgdHJhZGVzIGFyZSBzdGlsbCBsaW1pdCB0cmFkZXNcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgYnkgZmV0Y2hNeVRyYWRlcygpIG9ubHlcbiAgICAgICAgLy8gaXNfeW91cl9vcmRlciBpcyBhbHdheXMgZmFsc2UgOlxcXG4gICAgICAgIC8vIGxldCBpc1lvdXJPcmRlciA9IHRoaXMuc2FmZVZhbHVlICh0cmFkZSwgJ2lzX3lvdXJfb3JkZXInKTtcbiAgICAgICAgLy8gbGV0IHRha2VyT3JNYWtlciA9ICd0YWtlcic7XG4gICAgICAgIC8vIGlmIChpc1lvdXJPcmRlcilcbiAgICAgICAgLy8gICAgIHRha2VyT3JNYWtlciA9ICdtYWtlcic7XG4gICAgICAgIC8vIGxldCBmZWUgPSB0aGlzLmNhbGN1bGF0ZUZlZSAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNQYWlyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVttYXJrZXRbJ2lkJ11dLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICAgICAgJ3JhdGUnOiB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZVsncmV0dXJuJ10sIHRoaXMuZ2V0T3JkZXJJZEtleSAoKSk7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICBpZCA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2VbJ3JldHVybiddLCAnaW5pdF9vcmRlcl9pZCcpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCAocHJpY2UpO1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0IChhbW91bnQpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBwcmljZSAqIGFtb3VudCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IDAuMCxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyAndHJhZGVzJzogdGhpcy5wYXJzZVRyYWRlcyAob3JkZXJbJ3RyYWRlcyddLCBtYXJrZXQpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9yZGVyc1tpZF0gPSBvcmRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kICh7ICdpbmZvJzogcmVzcG9uc2UgfSwgb3JkZXIpO1xuICAgIH1cblxuICAgIGdldE9yZGVySWRLZXkgKCkge1xuICAgICAgICByZXR1cm4gJ29yZGVyX2lkJztcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgICAgIGxldCBpZEtleSA9IHRoaXMuZ2V0T3JkZXJJZEtleSAoKTtcbiAgICAgICAgICAgIHJlcXVlc3RbaWRLZXldID0gaWQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMub3JkZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXVsnc3RhdHVzJ10gPSAnY2FuY2VsZWQnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2pzb25fcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuc2FmZVN0cmluZyAodGhpcy5sYXN0X2pzb25fcmVzcG9uc2UsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmluZGV4T2YgKCdub3QgZm91bmQnKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyKCkgZXJyb3I6ICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgaWQgPSBvcmRlclsnaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHN0YXR1cyA9IG9yZGVyWydzdGF0dXMnXTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAwKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09IDEpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGF0dXMgPT0gMikgfHwgKHN0YXR1cyA9PSAzKSkge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWyd0aW1lc3RhbXBfY3JlYXRlZCddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydwYWlyJ11dO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2Ftb3VudCcpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnc3RhcnRfYW1vdW50JywgcmVtYWluaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm9yZGVycykge1xuICAgICAgICAgICAgICAgIGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0ICh0aGlzLm9yZGVyc1tpZF0sICdhbW91bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdyYXRlJyk7XG4gICAgICAgIGxldCBmaWxsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZW1haW5pbmcgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgY29zdCA9IHByaWNlICogZmlsbGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAob3JkZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBleHRlbmRlZCA9IHRoaXMuZXh0ZW5kIChvcmRlciwgeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKGV4dGVuZGVkLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckluZm8gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBwYXJzZUludCAoaWQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgaWQgPSBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG5ld09yZGVyID0gdGhpcy5wYXJzZU9yZGVyICh0aGlzLmV4dGVuZCAoeyAnaWQnOiBpZCB9LCByZXNwb25zZVsncmV0dXJuJ11baWRdKSk7XG4gICAgICAgIGxldCBvbGRPcmRlciA9IChpZCBpbiB0aGlzLm9yZGVycykgPyB0aGlzLm9yZGVyc1tpZF0gOiB7fTtcbiAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9sZE9yZGVyLCBuZXdPcmRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyc1tpZF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9yZGVycyByZXF1aXJlcyBhIHN5bWJvbCcpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0geyAncGFpcic6IG1hcmtldFsnaWQnXSB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QWN0aXZlT3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcGVuT3JkZXJzID0gW107XG4gICAgICAgIGlmICgncmV0dXJuJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIG9wZW5PcmRlcnMgPSB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmV0dXJuJ10sIG1hcmtldCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3Blbk9yZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbb3Blbk9yZGVyc1tqXVsnaWQnXV0gPSBvcGVuT3JkZXJzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQgPSB0aGlzLmluZGV4QnkgKG9wZW5PcmRlcnMsICdpZCcpO1xuICAgICAgICBsZXQgY2FjaGVkT3JkZXJJZHMgPSBPYmplY3Qua2V5cyAodGhpcy5vcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2FjaGVkT3JkZXJJZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGNhY2hlZE9yZGVySWRzW2tdO1xuICAgICAgICAgICAgaWYgKGlkIGluIG9wZW5PcmRlcnNJbmRleGVkQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIG9wZW5PcmRlcnNJbmRleGVkQnlJZFtpZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IG9yZGVyWydhbW91bnQnXSAqIG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxlZCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1haW5pbmcnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChvcmRlclsnc3ltYm9sJ10gPT0gc3ltYm9sKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChvcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3JkZXJzW2ldWydzdGF0dXMnXSA9PSAnb3BlbicpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09ICdjbG9zZWQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChvcmRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLy8gJ2Zyb20nOiAxMjM0NTY3ODksIC8vIHRyYWRlIElELCBmcm9tIHdoaWNoIHRoZSBkaXNwbGF5IHN0YXJ0cyBudW1lcmljYWwgMFxuICAgICAgICAgICAgLy8gJ2NvdW50JzogMTAwMCwgLy8gdGhlIG51bWJlciBvZiB0cmFkZXMgZm9yIGRpc3BsYXkgbnVtZXJpY2FsLCBkZWZhdWx0ID0gMTAwMFxuICAgICAgICAgICAgLy8gJ2Zyb21faWQnOiB0cmFkZSBJRCwgZnJvbSB3aGljaCB0aGUgZGlzcGxheSBzdGFydHMgbnVtZXJpY2FsIDBcbiAgICAgICAgICAgIC8vICdlbmRfaWQnOiB0cmFkZSBJRCBvbiB3aGljaCB0aGUgZGlzcGxheSBlbmRzIG51bWVyaWNhbCDiiJ5cbiAgICAgICAgICAgIC8vICdvcmRlcic6ICdBU0MnLCAvLyBzb3J0aW5nLCBkZWZhdWx0ID0gREVTQ1xuICAgICAgICAgICAgLy8gJ3NpbmNlJzogMTIzNDU2Nzg5MCwgLy8gVVRDIHN0YXJ0IHRpbWUsIGRlZmF1bHQgPSAwXG4gICAgICAgICAgICAvLyAnZW5kJzogMTIzNDU2Nzg5MCwgLy8gVVRDIGVuZCB0aW1lLCBkZWZhdWx0ID0g4oieXG4gICAgICAgICAgICAvLyAncGFpcic6ICdldGhfYnRjJywgLy8gZGVmYXVsdCA9IGFsbCBtYXJrZXRzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncGFpciddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvdW50J10gPSBwYXJzZUludCAobGltaXQpO1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUhpc3RvcnkgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IFtdO1xuICAgICAgICBpZiAoJ3JldHVybicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0cmFkZXMgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhd0NvaW4gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbk5hbWUnOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChhbW91bnQpLFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmV0dXJuJ11bJ3RJZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ25Cb2R5V2l0aFNlY3JldCAoYm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICB9XG5cbiAgICBnZXRWZXJzaW9uU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuICcvJyArIHRoaXMudmVyc2lvbjtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5zaWduQm9keVdpdGhTZWNyZXQgKGJvZHkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLmdldFZlcnNpb25TdHJpbmcgKCkgKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddLmluZGV4T2YgKCdOb3QgZW5vdWd0aCcpID49IDApIHsgLy8gbm90IGVub3VnVGggaXMgYSB0eXBvIGluc2lkZSBMaXF1aSdzIG93biBBUEkuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VbJ2Vycm9yJ10gPT0gJ1JlcXVlc3RzIHRvbyBvZnRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlWydlcnJvciddID09ICdub3QgYXZhaWxhYmxlJykgfHwgKHJlc3BvbnNlWydlcnJvciddID09ICdleHRlcm5hbCBzZXJ2aWNlIHVuYXZhaWxhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbGl2ZWNvaW4gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnbGl2ZWNvaW4nLFxuICAgICAgICAgICAgJ25hbWUnOiAnTGl2ZUNvaW4nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ1VTJywgJ1VLJywgJ1JVJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTgwNzY4LWYyMmZjNDI0LTYzOGEtMTFlNy04OWM5LTYwMTBhNTRmZjliZS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkubGl2ZWNvaW4ubmV0JyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmxpdmVjb2luLm5ldCcsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5saXZlY29pbi5uZXQvYXBpP2xhbmc9ZW4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9hbGwvb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvbGFzdF90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21heGJpZF9taW5hc2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVyX2Jvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3Jlc3RyaWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdGlja2VyJywgLy8gb21pdCBwYXJhbXMgdG8gZ2V0IGFsbCB0aWNrZXJzIGF0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL2NvaW5JbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2NsaWVudF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2NvbW1pc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2NvbW1pc3Npb25Db21tb25JbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvZ2V0L2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvaGlzdG9yeS9zaXplJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L2hpc3RvcnkvdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvYnV5bGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2J1eW1hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvY2FuY2VsbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3NlbGxsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvc2VsbG1hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvY2FwaXRhbGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvY2FyZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvY29pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvb2twYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L3BheWVlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvcGVyZmVjdG1vbmV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L3ZvdWNoZXIvYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L3ZvdWNoZXIvbWFrZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC92b3VjaGVyL3JlZGVlbScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRpY2tlciAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICBsZXQgdGFrZXIgPSAwLjE4IC8gMTAwO1xuICAgICAgICAgICAgbGV0IG1ha2VyID0gMC4xOCAvIDEwMDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ21ha2VyJzogbWFrZXIsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogdGFrZXIsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0UGF5bWVudEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzdWx0KVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSByZXN1bHRbY3VycmVuY3ldO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09ICd0b3RhbCcpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VbJ3R5cGUnXSA9PSAnYXZhaWxhYmxlJylcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlWyd0eXBlJ10gPT0gJ3RyYWRlJylcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZU9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2dyb3VwQnlQcmljZSc6ICdmYWxzZScsXG4gICAgICAgICAgICAnZGVwdGgnOiAxMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jlc3RfYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9hc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKSxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlVGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2UsICdzeW1ib2wnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZUxhc3RUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RFeGNoYW5nZScgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgdHlwZTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcklkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RXhjaGFuZ2VDYW5jZWxsaW1pdCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0IChwYXJhbXMpKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJylcbiAgICAgICAgICAgICAgICBib2R5ID0gcXVlcnk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocXVlcnkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBcGktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbHVubyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdsdW5vJyxcbiAgICAgICAgICAgICduYW1lJzogJ2x1bm8nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0dCJywgJ1NHJywgJ1pBJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDMwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY2MDctOGMxYTY5ZDgtNWVkZS0xMWU3LTkzMGMtNTQwYjVlYjliZTI0LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5teWJpdHguY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5sdW5vLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lmx1bm8uY29tL2VuL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL25wbWpzLm9yZy9wYWNrYWdlL2JpdHgnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2JhdXNtZWllci9ub2RlLWJpdHgnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cy97aWR9L3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmVlX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRpbmdfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdHRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3Rlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3N0b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdG9wb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRpbmdfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2F1dGgyL2dyYW50JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZXMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VycyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ3RpY2tlcnMnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3RpY2tlcnMnXVtwXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsncGFpciddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhbGFuY2VbJ2Fzc2V0J10pO1xuICAgICAgICAgICAgbGV0IHJlc2VydmVkID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsncmVzZXJ2ZWQnXSk7XG4gICAgICAgICAgICBsZXQgdW5jb25maXJtZWQgPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd1bmNvbmZpcm1lZCddKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHRoaXMuc3VtIChyZXNlcnZlZCwgdW5jb25maXJtZWQpLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF90cmFkZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3JvbGxpbmdfMjRfaG91cl92b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHJlc3BvbnNlWyd0aWNrZXJzJ10sICdwYWlyJyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ2lzX2J1eSddKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsndGltZXN0YW1wJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWyd2b2x1bWUnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7ICdwYWlyJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdNYXJrZXRvcmRlcic7XG4gICAgICAgICAgICBvcmRlclsndHlwZSddID0gc2lkZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdidXknKVxuICAgICAgICAgICAgICAgIG9yZGVyWydjb3VudGVyX3ZvbHVtZSddID0gYW1vdW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWydiYXNlX3ZvbHVtZSddID0gYW1vdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdPcmRlcic7XG4gICAgICAgICAgICBvcmRlclsndm9sdW1lJ10gPSBhbW91bnQ7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpXG4gICAgICAgICAgICAgICAgb3JkZXJbJ3R5cGUnXSA9ICdCSUQnO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWyd0eXBlJ10gPSAnQVNLJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0U3RvcG9yZGVyICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5lbmNvZGUgKHRoaXMuYXBpS2V5ICsgJzonICsgdGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgYXV0aCA9IHRoaXMuc3RyaW5nVG9CYXNlNjQgKGF1dGgpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIHRoaXMuZGVjb2RlIChhdXRoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBtZXJjYWRvIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ21lcmNhZG8nLFxuICAgICAgICAgICAgJ25hbWUnOiAnTWVyY2FkbyBCaXRjb2luJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQlInLCAvLyBCcmF6aWxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjMnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4MzcwNjAtZTdjNTg3MTQtNjBlYS0xMWU3LTkxOTItZjA1ZTg2YWRiODNmLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3d3dy5tZXJjYWRvYml0Y29pbi5uZXQvYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cubWVyY2Fkb2JpdGNvaW4ubmV0L3RhcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5tZXJjYWRvYml0Y29pbi5jb20uYnInLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5tZXJjYWRvYml0Y29pbi5jb20uYnIvYXBpLWRvYycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5tZXJjYWRvYml0Y29pbi5jb20uYnIvdHJhZGUtYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y29pbn0vb3JkZXJib29rLycsIC8vIGxhc3Qgc2xhc2ggY3JpdGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y29pbn0vdGlja2VyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2NvaW59L3RyYWRlcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tjb2lufS90cmFkZXMve2Zyb219LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2NvaW59L3RyYWRlcy97ZnJvbX0ve3RvfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2NvaW59L2RheS1zdW1tYXJ5L3t5ZWFyfS97bW9udGh9L3tkYXl9LycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfYWNjb3VudF9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X3N5c3RlbV9tZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3Rfb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZV9idXlfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlX3NlbGxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2NvaW4nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9CUkwnOiB7ICdpZCc6ICdCUkxCVEMnLCAnc3ltYm9sJzogJ0JUQy9CUkwnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQlJMJywgJ3N1ZmZpeCc6ICdCaXRjb2luJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlJMJzogeyAnaWQnOiAnQlJMTFRDJywgJ3N5bWJvbCc6ICdMVEMvQlJMJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JSTCcsICdzdWZmaXgnOiAnTGl0ZWNvaW4nIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9CUkwnOiB7ICdpZCc6ICdCUkxCQ0gnLCAnc3ltYm9sJzogJ0JDSC9CUkwnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQlJMJywgJ3N1ZmZpeCc6ICdCQ2FzaCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4zIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjcgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Q29pbk9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luJzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q29pblRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luJzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldENvaW5UcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbic6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEFjY291bnRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzcG9uc2VfZGF0YSddWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlXVsnYXZhaWxhYmxlJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2VdWyd0b3RhbCddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0UGxhY2UnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdPcmRlcic7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjb2luX3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ2xpbWl0X3ByaWNlJzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzcG9uc2VfZGF0YSddWydvcmRlciddWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjb2luJzogY3VycmVuY3ksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQudG9GaXhlZCAoMTApLFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JSTCcpIHtcbiAgICAgICAgICAgIGxldCBhY2NvdW50X3JlZiA9ICgnYWNjb3VudF9yZWYnIGluIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRfcmVmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhY2NvdW50X3JlZiBwYXJhbWV0ZXIgdG8gd2l0aGRyYXcgJyArIGN1cnJlbmN5KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSAhPSAnTFRDJykge1xuICAgICAgICAgICAgbGV0IHR4X2ZlZSA9ICgndHhfZmVlJyBpbiBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKCF0eF9mZWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIHR4X2ZlZSBwYXJhbWV0ZXIgdG8gd2l0aGRyYXcgJyArIGN1cnJlbmN5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXdDb2luICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3BvbnNlX2RhdGEnXVsnd2l0aGRyYXdhbCddWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3RhcGlfbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAndGFwaV9ub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9ICcvdGFwaS8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgJz8nICsgYm9keTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdUQVBJLUlEJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1RBUEktTUFDJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcl9tZXNzYWdlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbWl4Y29pbnMgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnbWl4Y29pbnMnLFxuICAgICAgICAgICAgJ25hbWUnOiAnTWl4Q29pbnMnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0dCJywgJ0hLJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDIzNzIxMi1lZDI5MzAzYy05NTM1LTExZTctOGFmOC1mY2QzODFjZmEyMGMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vbWl4Y29pbnMuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL21peGNvaW5zLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL21peGNvaW5zLmNvbS9oZWxwL2FwaS8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y191c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJywgJ21ha2VyJzogMC4wMDE1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDEsICd0YWtlcic6IDAuMDAxNSB9LFxuICAgICAgICAgICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAnYmNjX2J0YycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMSwgJ3Rha2VyJzogMC4wMDE1IH0sXG4gICAgICAgICAgICAgICAgJ0xTSy9CVEMnOiB7ICdpZCc6ICdsc2tfYnRjJywgJ3N5bWJvbCc6ICdMU0svQlRDJywgJ2Jhc2UnOiAnTFNLJywgJ3F1b3RlJzogJ0JUQycsICdtYWtlcic6IDAuMDAxNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9VU0QnOiB7ICdpZCc6ICdiY2NfdXNkJywgJ3N5bWJvbCc6ICdCQ0gvVVNEJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAxLCAndGFrZXInOiAwLjAwMTUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL1VTRCc6IHsgJ2lkJzogJ2V0aF91c2QnLCAnc3ltYm9sJzogJ0VUSC9VU0QnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVVNEJywgJ21ha2VyJzogMC4wMDEsICd0YWtlcic6IDAuMDAxNSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsncmVzdWx0J11bJ3dhbGxldCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2UgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW2xvd2VyY2FzZV1bJ2F2YWlsJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbbG93ZXJjYXNlXVsnbG9jayddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAocmVzcG9uc2VbJ3Jlc3VsdCddKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ29wJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gMTtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3VsdCddWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLnNlY3JldCwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIG5vdmEgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnbm92YScsXG4gICAgICAgICAgICAnbmFtZSc6ICdOb3ZhZXhjaGFuZ2UnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdUWicsIC8vIFRhbnphbmlhXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwNTE4NTcxLTc4Y2EwYmNhLTliOGEtMTFlNy04ODQwLTY0YjgzYTRhOTRiMi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9ub3ZhZXhjaGFuZ2UuY29tL3JlbW90ZScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL25vdmFleGNoYW5nZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9ub3ZhZXhjaGFuZ2UuY29tL3JlbW90ZS9mYXEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cy97YmFzZWN1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9pbmZvL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9vcmRlcmhpc3Rvcnkve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L29wZW5vcmRlcnMve3BhaXJ9L2J1eS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9vcGVub3JkZXJzL3twYWlyfS9zZWxsLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L29wZW5vcmRlcnMve3BhaXJ9L2JvdGgvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbm9yZGVycy97cGFpcn0ve29yZGVydHlwZX0vJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGJhbGFuY2Uve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGRlcG9zaXRzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0d2l0aGRyYXdhbHMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRuZXdkZXBvc2l0YWRkcmVzcy97Y3VycmVuY3l9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0ZGVwb3NpdGFkZHJlc3Mve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215b3Blbm9yZGVycy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215b3Blbm9yZGVyc19tYXJrZXQve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2Vsb3JkZXIve29yZGVyaWR9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlaGlzdG9yeS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGRlcG9zaXRoaXN0b3J5LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0d2l0aGRyYXdhbGhpc3RvcnkvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzdGF0dXMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzdGF0dXMve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ21hcmtldHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgaWYgKCFtYXJrZXRbJ2Rpc2FibGVkJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ21hcmtldG5hbWUnXTtcbiAgICAgICAgICAgICAgICBsZXQgWyBxdW90ZSwgYmFzZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRPcGVub3JkZXJzUGFpckJvdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdidXlvcmRlcnMnLCAnc2VsbG9yZGVycycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldEluZm9QYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydtYXJrZXRzJ11bMF07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gyNGgnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cyNGgnXSksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF9wcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2NoYW5nZTI0aCddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lMjRoJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3VuaXhfdF9kYXRlc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0cmFkZXR5cGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldE9yZGVyaGlzdG9yeVBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsnaXRlbXMnXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRiYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbG9ja2JveCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF9sb2NrYm94J10pO1xuICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90cmFkZXMnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHRoaXMuc3VtIChsb2NrYm94LCB0cmFkZXMpLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90b3RhbCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGFtb3VudCA9IGFtb3VudC50b1N0cmluZyAoKTtcbiAgICAgICAgcHJpY2UgPSBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAndHJhZGV0eXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICd0cmFkZWFtb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICd0cmFkZXByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHJhZGViYXNlJzogMSxcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVQYWlyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcmlkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKVxuICAgICAgICAgICAgdXJsICs9IGFwaSArICcvJztcbiAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHsgJ25vbmNlJzogbm9uY2UgfSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAodXJsKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdGF0dXMnXSAhPSAnc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9rY29pbnVzZCA9IHJlcXVpcmUgKCcuL29rY29pbnVzZC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIG9rY29pbmNueSBleHRlbmRzIG9rY29pbnVzZCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnb2tjb2luY255JyxcbiAgICAgICAgICAgICduYW1lJzogJ09LQ29pbiBDTlknLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njc5Mi04YmU5MTU3YS01ZWU1LTExZTctOTI2Yy02ZDY5YjhkMzM3OGQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jbicsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNuL3BhaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jbi9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5va2NvaW4uY24nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNuL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0Y19jbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNfY255JywgJ3N5bWJvbCc6ICdMVEMvQ05ZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICdFVEgvQ05ZJzogeyAnaWQnOiAnZXRoX2NueScsICdzeW1ib2wnOiAnRVRIL0NOWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0NOWSc6IHsgJ2lkJzogJ2V0Y19jbnknLCAnc3ltYm9sJzogJ0VUQy9DTlknLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9DTlknOiB7ICdpZCc6ICdiY2NfY255JywgJ3N5bWJvbCc6ICdCQ0gvQ05ZJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBva2NvaW51c2QgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnb2tjb2ludXNkJyxcbiAgICAgICAgICAgICduYW1lJzogJ09LQ29pbiBVU0QnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0NOJywgJ1VTJyBdLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLCAvLyB1cCB0byAzMDAwIHJlcXVlc3RzIHBlciA1IG1pbnV0ZXMg4omIIDYwMCByZXF1ZXN0cyBwZXIgbWludXRlIOKJiCAxMCByZXF1ZXN0cyBwZXIgc2Vjb25kIOKJiCAxMDAgbXNcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnZXh0ZW5zaW9uJzogJy5kbycsIC8vIGFwcGVuZGVkIHRvIGVuZHBvaW50IFVSTFxuICAgICAgICAgICAgJ2hhc0Z1dHVyZU1hcmtldHMnOiBmYWxzZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbWluJyxcbiAgICAgICAgICAgICAgICAnM20nOiAnM21pbicsXG4gICAgICAgICAgICAgICAgJzVtJzogJzVtaW4nLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMTVtaW4nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtaW4nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaG91cicsXG4gICAgICAgICAgICAgICAgJzJoJzogJzJob3VyJyxcbiAgICAgICAgICAgICAgICAnNGgnOiAnNGhvdXInLFxuICAgICAgICAgICAgICAgICc2aCc6ICc2aG91cicsXG4gICAgICAgICAgICAgICAgJzEyaCc6ICcxMmhvdXInLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxZGF5JyxcbiAgICAgICAgICAgICAgICAnM2QnOiAnM2RheScsXG4gICAgICAgICAgICAgICAgJzF3JzogJzF3ZWVrJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd3ZWInOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cy9jdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzL3Byb2R1Y3RzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlX3JhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX2VzdGltYXRlZF9wcmljZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX2hvbGRfYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9rbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3ByaWNlX2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrbGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3RjcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRfcmVjb3JkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmF0Y2hfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcnJvd19tb25leScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9ycm93X29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcnJvd3NfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX2JvcnJvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3RjX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9iYXRjaF90cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX2Rldm9sdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9leHBsb3NpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9vcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfb3JkZXJzX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9wb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3Bvc2l0aW9uXzRmaXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV90cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfdXNlcmluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV91c2VyaW5mb180Zml4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kX2RlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9mZWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyc19pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvdGNfb3JkZXJfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3RjX29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcGF5bWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3VibWl0X290Y19vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX290Y19vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VucmVwYXltZW50c19pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyaW5mbycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NzkxLTg5ZmZiNTAyLTVlZTUtMTFlNy04YTViLWM1OTUwYjY4YWM2NS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICd3ZWInOiAnaHR0cHM6Ly93d3cub2tjb2luLmNvbS92MicsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5va2NvaW4uY29tL2FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5va2NvaW4uY29tL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29rY29pbi5jb20nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndlYkdldE1hcmtldHNQcm9kdWN0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0c1tpXVsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gaWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gdXBwZXJjYXNlLnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IG1hcmtldHNbaV1bJ21heFNpemVEaWdpdCddLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IG1hcmtldHNbaV1bJ21heFByaWNlRGlnaXQnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbG90ID0gTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSk7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXRzW2ldLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3Nwb3QnLFxuICAgICAgICAgICAgICAgICdzcG90JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZnV0dXJlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IGxvdCxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0c1tpXVsnbWluVHJhZGVTaXplJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAobWFya2V0KTtcbiAgICAgICAgICAgIGlmICgodGhpcy5oYXNGdXR1cmVNYXJrZXRzKSAmJiAobWFya2V0WydxdW90ZSddID09ICdVU0RUJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKG1hcmtldCwge1xuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiAnVVNEJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnYmFzZSddICsgJy9VU0QnLFxuICAgICAgICAgICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10ucmVwbGFjZSAoJ3VzZHQnLCAndXNkJyksXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Z1dHVyZScsXG4gICAgICAgICAgICAgICAgICAgICdzcG90JzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdmdXR1cmUnOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwdWJsaWNHZXQnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZSc7XG4gICAgICAgICAgICByZXF1ZXN0Wydjb250cmFjdF90eXBlJ10gPSAndGhpc193ZWVrJzsgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kICs9ICdEZXB0aCc7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2JpZHMnOiBvcmRlcmJvb2tbJ2JpZHMnXSxcbiAgICAgICAgICAgICdhc2tzJzogdGhpcy5zb3J0QnkgKG9yZGVyYm9va1snYXNrcyddLCAwKSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RpbWVzdGFtcCddO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ1RpY2tlcic7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHJlc3BvbnNlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRoaXMuZXh0ZW5kIChyZXNwb25zZVsndGlja2VyJ10sIHsgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsnZGF0ZV9tcyddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsnZGF0ZV9tcyddKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ1RyYWRlcyc7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSAxNDQwLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ0tsaW5lJztcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnc2l6ZSddID0gcGFyc2VJbnQgKGxpbWl0KTtcbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gc2luY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gdGhpcy5taWxsaXNlY29uZHMgKCkgLSA4NjQwMDAwMDsgLy8gbGFzdCAyNCBob3Vyc1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJpbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnaW5mbyddWydmdW5kcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VzWydmcmVlJ10sIGxvd2VyY2FzZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlc1snZnJlZXplZCddLCBsb3dlcmNhc2UsIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmUnO1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHtcbiAgICAgICAgICAgICAgICAnY29udHJhY3RfdHlwZSc6ICd0aGlzX3dlZWsnLCAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICAnbWF0Y2hfcHJpY2UnOiAwLCAvLyBtYXRjaCBiZXN0IGNvdW50ZXIgcGFydHkgcHJpY2U/IDAgb3IgMSwgaWdub3JlcyBwcmljZSBpZiAxXG4gICAgICAgICAgICAgICAgJ2xldmVyX3JhdGUnOiAxMCwgLy8gbGV2ZXJhZ2UgcmF0ZSB2YWx1ZTogMTAgb3IgMjAgKDEwIGJ5IGRlZmF1bHQpXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0Jykge1xuICAgICAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmRlclsndHlwZSddICs9ICdfbWFya2V0JztcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5Jykge1xuICAgICAgICAgICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHRoaXMuc2FmZUZsb2F0IChwYXJhbXMsICdjb3N0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JkZXJbJ3ByaWNlJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgbWFya2V0IGJ1eSBvcmRlcnMgcmVxdWlyZSBhbiBhZGRpdGlvbmFsIGNvc3QgcGFyYW1ldGVyLCBjb3N0ID0gcHJpY2UgKiBhbW91bnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHRoaXMub21pdCAocGFyYW1zLCAnY29zdCcpO1xuICAgICAgICBtZXRob2QgKz0gJ1RyYWRlJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmVDYW5jZWwnO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdDYW5jZWxPcmRlcic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDApXG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICBpZiAoc3RhdHVzID09IDEpXG4gICAgICAgICAgICByZXR1cm4gJ3BhcnRpYWwnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDIpXG4gICAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gNClcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3R5cGUnIGluIG9yZGVyKSB7XG4gICAgICAgICAgICBpZiAoKG9yZGVyWyd0eXBlJ10gPT0gJ2J1eScpIHx8IChvcmRlclsndHlwZSddID09ICdzZWxsJykpIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gb3JkZXJbJ3R5cGUnXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2xpbWl0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lkZSA9IChvcmRlclsndHlwZSddID09ICdidXlfbWFya2V0JykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ21hcmtldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXR1cyA9IHRoaXMucGFyc2VPcmRlclN0YXR1cyAob3JkZXJbJ3N0YXR1cyddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnc3ltYm9sJyBpbiBvcmRlcilcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddIGluIHRoaXMubWFya2V0c19ieV9pZClcbiAgICAgICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydzeW1ib2wnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnY3JlYXRlX2RhdGUnIGluIG9yZGVyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gb3JkZXJbJ2NyZWF0ZV9kYXRlJ107XG4gICAgICAgIGxldCBhbW91bnQgPSBvcmRlclsnYW1vdW50J107XG4gICAgICAgIGxldCBmaWxsZWQgPSBvcmRlclsnZGVhbF9hbW91bnQnXTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgbGV0IGF2ZXJhZ2UgPSBvcmRlclsnYXZnX3ByaWNlJ107XG4gICAgICAgIGxldCBjb3N0ID0gYXZlcmFnZSAqIGZpbGxlZDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnb3JkZXJfaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJ2ZldGNoT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtZXRlcicpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIC8vICdzdGF0dXMnOiAwLCAvLyAwIGZvciB1bmZpbGxlZCBvcmRlcnMsIDEgZm9yIGZpbGxlZCBvcmRlcnNcbiAgICAgICAgICAgIC8vICdjdXJyZW50X3BhZ2UnOiAxLCAvLyBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAvLyAncGFnZV9sZW5ndGgnOiAyMDAsIC8vIG51bWJlciBvZiBvcmRlcnMgcmV0dXJuZWQgcGVyIHBhZ2UsIG1heGltdW0gMjAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZSc7XG4gICAgICAgICAgICByZXF1ZXN0Wydjb250cmFjdF90eXBlJ10gPSAndGhpc193ZWVrJzsgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kICs9ICdPcmRlckluZm8nO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ29yZGVycyddWzBdKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnZmV0Y2hPcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW1ldGVyJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9yZGVyX2lkX2luX3BhcmFtcyA9ICgnb3JkZXJfaWQnIGluIHBhcmFtcyk7XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZU9yZGVyc0luZm8nO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICAgICAgaWYgKCFvcmRlcl9pZF9pbl9wYXJhbXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzKCkgcmVxdWlyZXMgb3JkZXJfaWQgcGFyYW0gZm9yIGZ1dHVyZXMgbWFya2V0ICcgKyBzeW1ib2wgKyAnIChhIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBvcmRlciBpZHMsIGNvbW1hLXNlcGFyYXRlZCknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHBhcmFtc1sndHlwZSddO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RhdHVzJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBwYXJhbXNbJ3N0YXR1cyddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMoKSByZXF1aXJlcyB0eXBlIHBhcmFtIG9yIHN0YXR1cyBwYXJhbSBmb3Igc3BvdCBtYXJrZXQgJyArIHN5bWJvbCArICcgKDAgb3IgXCJvcGVuXCIgZm9yIHVuZmlsbGVkIG9yZGVycywgMSBvciBcImNsb3NlZFwiIGZvciBmaWxsZWQgb3JkZXJzKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAnb3BlbicpXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMTtcbiAgICAgICAgICAgIGlmIChvcmRlcl9pZF9pbl9wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgKz0gJ09yZGVyc0luZm8nO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kICs9ICdPcmRlckhpc3RvcnknO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAnY3VycmVudF9wYWdlJzogMSwgLy8gY3VycmVudCBwYWdlIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAncGFnZV9sZW5ndGgnOiAyMDAsIC8vIG51bWJlciBvZiBvcmRlcnMgcmV0dXJuZWQgcGVyIHBhZ2UsIG1heGltdW0gMjAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLm9taXQgKHBhcmFtcywgWyAndHlwZScsICdzdGF0dXMnIF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ29yZGVycyddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcGVuID0gMDsgLy8gMCBmb3IgdW5maWxsZWQgb3JkZXJzLCAxIGZvciBmaWxsZWQgb3JkZXJzXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N0YXR1cyc6IG9wZW4sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IDE7IC8vIDAgZm9yIHVuZmlsbGVkIG9yZGVycywgMSBmb3IgZmlsbGVkIG9yZGVyc1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzdGF0dXMnOiBjbG9zZWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9ICcvJztcbiAgICAgICAgaWYgKGFwaSAhPSAnd2ViJylcbiAgICAgICAgICAgIHVybCArPSB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgIHVybCArPSBwYXRoICsgdGhpcy5leHRlbnNpb247XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMua2V5c29ydCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICAvLyBzZWNyZXQga2V5IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBxdWVyeVxuICAgICAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0gdGhpcy5yYXdlbmNvZGUgKHF1ZXJ5KSArICcmc2VjcmV0X2tleT0nICsgdGhpcy5zZWNyZXQ7XG4gICAgICAgICAgICBxdWVyeVsnc2lnbiddID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAocXVlcnlTdHJpbmcpKS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgncmVzdWx0JyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3Jlc3VsdCddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICBpZiAoJ2Vycm9yX2NvZGUnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9rY29pbnVzZCA9IHJlcXVpcmUgKCcuL29rY29pbnVzZC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIG9rZXggZXh0ZW5kcyBva2NvaW51c2Qge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ29rZXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnT0tFWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnQ04nLCAnVVMnIF0sXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0Z1dHVyZU1hcmtldHMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMjU1Mjc2OC0wZDZkZDNjNi1jNGE2LTExZTctOTBmOC1jMDQzYjY0NzU2YTcuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vd3d3Lm9rZXguY29tL3YyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3d3dy5va2V4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5va2V4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5va2V4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5va2V4LmNvbS9yZXN0X2dldFN0YXJ0ZWQuaHRtbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBwYXltaXVtIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3BheW1pdW0nLFxuICAgICAgICAgICAgJ25hbWUnOiAnUGF5bWl1bScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnRlInLCAnRVUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3OTA1NjQtYTk0NWE5ZDQtNWZmOS0xMWU3LTlkMmQtYjYzNTc2M2YyZjI0LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3BheW1pdW0uY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5wYXltaXVtLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9QYXltaXVtL2FwaS1kb2N1bWVudGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnBheW1pdW0uY29tL3BhZ2UvZGV2ZWxvcGVycycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY291bnRyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhL3tpZH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhL3tpZH0vZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fY2hhcnRzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luX2NoYXJ0cy97aWR9L2RlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21lcmNoYW50L2dldF9wYXltZW50L3tVVUlEfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9hZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYWRkcmVzc2VzL3tidGNfYWRkcmVzc30nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL29yZGVycy97VVVJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcHJpY2VfYWxlcnRzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3BheW1lbnRfcmVxdWVzdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcHJpY2VfYWxlcnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXJjaGFudC9jcmVhdGVfcGF5bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9vcmRlcnMve1VVSUR9L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wcmljZV9hbGVydHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ2V1cicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDA1OSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDU5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFVzZXIgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9ICdiYWxhbmNlXycgKyBsb3dlcmNhc2U7XG4gICAgICAgICAgICBsZXQgbG9ja2VkID0gJ2xvY2tlZF8nICsgbG93ZXJjYXNlO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2UgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYmFsYW5jZXNbYmFsYW5jZV07XG4gICAgICAgICAgICBpZiAobG9ja2VkIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGJhbGFuY2VzW2xvY2tlZF07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREYXRhSWREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgICAgIHJlc3VsdFsnYmlkcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYmlkcyddLCAwLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREYXRhSWRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnYXQnXSAqIDEwMDA7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydwcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndmFyaWF0aW9uJ10pLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnY3JlYXRlZF9hdF9pbnQnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgdm9sdW1lID0gJ3RyYWRlZF8nICsgbWFya2V0WydiYXNlJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3V1aWQnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbdm9sdW1lXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREYXRhSWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpICsgJ09yZGVyJyxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnZGlyZWN0aW9uJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJPcmRlcnMgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlck51bWJlcic6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdXJsICsgYm9keTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FwaS1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQXBpLVNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLnNlY3JldCksXG4gICAgICAgICAgICAgICAgJ0FwaS1Ob25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3JzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQsIE9yZGVyTm90Q2FjaGVkIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBwb2xvbmlleCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdwb2xvbmlleCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdQb2xvbmlleCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLCAvLyB1cCB0byA2IGNhbGxzIHBlciBzZWNvbmRcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogJ2VtdWxhdGVkJyxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzVtJzogMzAwLFxuICAgICAgICAgICAgICAgICcxNW0nOiA5MDAsXG4gICAgICAgICAgICAgICAgJzMwbSc6IDE4MDAsXG4gICAgICAgICAgICAgICAgJzJoJzogNzIwMCxcbiAgICAgICAgICAgICAgICAnNGgnOiAxNDQwMCxcbiAgICAgICAgICAgICAgICAnMWQnOiA4NjQwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODE3LWU5NDU2MzEyLTVlZTYtMTFlNy05YjNjLWI2MjhjYTU2MjZhNS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vcHVibGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vdHJhZGluZ0FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vcG9sb25pZXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2xvbmlleC5jb20vc3VwcG9ydC9hcGkvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9wYXN0ZWJpbi5jb20vZE1YN21aRTAnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vZmVlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybjI0aFZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuQ2hhcnREYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5DdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5Mb2FuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVyblRpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbExvYW5PZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nsb3NlTWFyZ2luUG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZUxvYW5PZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2VuZXJhdGVOZXdBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRNYXJnaW5Qb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luQnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5TZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3ZlT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybkFjdGl2ZUxvYW5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5BdmFpbGFibGVBY2NvdW50QmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybkJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5Db21wbGV0ZUJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5EZXBvc2l0QWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5EZXBvc2l0c1dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5GZWVJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5MZW5kaW5nSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuTWFyZ2luQWNjb3VudFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybk9wZW5Mb2FuT2ZmZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcmRlclRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGFibGVCYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2dnbGVBdXRvUmVuZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDAxNSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiAwLjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogMC4wMDAwMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IDEwMDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLjAwMDAwMDAxLFxuICAgICAgICAgICAgICAgICAgICAnbWF4JzogMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogMC4wMDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IDEwMDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHJlY2lzaW9uJzoge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVGZWUgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSwgdGFrZXJPck1ha2VyID0gJ3Rha2VyJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQga2V5ID0gJ3F1b3RlJztcbiAgICAgICAgbGV0IHJhdGUgPSBtYXJrZXRbdGFrZXJPck1ha2VyXTtcbiAgICAgICAgbGV0IGNvc3QgPSBwYXJzZUZsb2F0ICh0aGlzLmNvc3RUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQgKiByYXRlKSk7XG4gICAgICAgIGlmIChzaWRlID09ICdzZWxsJykge1xuICAgICAgICAgICAgY29zdCAqPSBwcmljZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9ICdiYXNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRba2V5XSxcbiAgICAgICAgICAgICdyYXRlJzogcmF0ZSxcbiAgICAgICAgICAgICdjb3N0JzogcGFyc2VGbG9hdCAodGhpcy5mZWVUb1ByZWNpc2lvbiAoc3ltYm9sLCBjb3N0KSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JUTScpXG4gICAgICAgICAgICByZXR1cm4gJ0JpdG1hcmsnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgY3VycmVuY3lJZCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCaXRtYXJrJylcbiAgICAgICAgICAgIHJldHVybiAnQlRNJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICc1bScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbJ2RhdGUnXSAqIDEwMDAsXG4gICAgICAgICAgICBvaGxjdlsnb3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ2hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2Wydsb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydjbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ3ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzVtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGlmICghc2luY2UpXG4gICAgICAgICAgICBzaW5jZSA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdzdGFydCc6IHBhcnNlSW50IChzaW5jZSAvIDEwMDApLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydlbmQnXSA9IHRoaXMuc3VtIChyZXF1ZXN0WydzdGFydCddLCBsaW1pdCAqIHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRSZXR1cm5DaGFydERhdGEgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVGlja2VyICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgWyBxdW90ZSwgYmFzZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogdGhpcy5saW1pdHNbJ2Ftb3VudCddWydtaW4nXSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybkNvbXBsZXRlQmFsYW5jZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYWNjb3VudCc6ICdhbGwnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaWRdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGlkKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnb25PcmRlcnMnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRmVlcyAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGZlZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuRmVlSW5mbyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogZmVlcyxcbiAgICAgICAgICAgICdtYWtlcic6IHBhcnNlRmxvYXQgKGZlZXNbJ21ha2VyRmVlJ10pLFxuICAgICAgICAgICAgJ3Rha2VyJzogcGFyc2VGbG9hdCAoZmVlc1sndGFrZXJGZWUnXSksXG4gICAgICAgICAgICAnd2l0aGRyYXcnOiAwLjAsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuT3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gyNGhyJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRociddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2hlc3RCaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dlc3RBc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydwZXJjZW50Q2hhbmdlJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydxdW90ZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmFzZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJldHVyblRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1ttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZSddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCghbWFya2V0KSAmJiAoJ2N1cnJlbmN5UGFpcicgaW4gdHJhZGUpKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV1bJ3N5bWJvbCddO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHNpZGUgPSB0cmFkZVsndHlwZSddO1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ3RvdGFsJyk7XG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pO1xuICAgICAgICBpZiAoJ2ZlZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGxldCByYXRlID0gcGFyc2VGbG9hdCAodHJhZGVbJ2ZlZSddKTtcbiAgICAgICAgICAgIGxldCBmZWVDb3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IG1hcmtldFsnYmFzZSddO1xuICAgICAgICAgICAgICAgIGZlZUNvc3QgPSBhbW91bnQgKiByYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvc3QgIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIGZlZUNvc3QgPSBjb3N0ICogcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAncmF0ZSc6IHJhdGUsXG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBmZWVDb3N0LFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ2lkJzogdGhpcy5zYWZlU3RyaW5nICh0cmFkZSwgJ3RyYWRlSUQnKSxcbiAgICAgICAgICAgICdvcmRlcic6IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICdvcmRlck51bWJlcicpLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3JhdGUnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2VuZCddID0gdGhpcy5zZWNvbmRzICgpOyAvLyBsYXN0IDUwMDAwIHRyYWRlcyBieSBkZWZhdWx0XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYWRlcyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiAnYWxsJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7ICdjdXJyZW5jeVBhaXInOiBwYWlyIH07XG4gICAgICAgIGlmIChzaW5jZSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHBhcnNlSW50IChzaW5jZSAvIDEwMDApO1xuICAgICAgICAgICAgcmVxdWVzdFsnZW5kJ10gPSB0aGlzLnNlY29uZHMgKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGltaXQgaXMgZGlzYWJsZWQgKGRvZXMgbm90IHJlYWxseSB3b3JrIGFzIGV4cGVjdGVkKVxuICAgICAgICAvLyBpZiAobGltaXQpXG4gICAgICAgIC8vICAgICByZXF1ZXN0WydsaW1pdCddID0gcGFyc2VJbnQgKGxpbWl0KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVyblRyYWRlSGlzdG9yeSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFkZXMgPSB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVtpZF0sIG1hcmtldCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHJhZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAodHJhZGVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuc2FmZUludGVnZXIgKG9yZGVyLCAndGltZXN0YW1wJyk7XG4gICAgICAgIGlmICghdGltZXN0YW1wKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydkYXRlJ10pO1xuICAgICAgICBsZXQgdHJhZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3Jlc3VsdGluZ1RyYWRlcycgaW4gb3JkZXIpXG4gICAgICAgICAgICB0cmFkZXMgPSB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsncmVzdWx0aW5nVHJhZGVzJ10sIG1hcmtldCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgcHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlclsncHJpY2UnXSk7XG4gICAgICAgIGxldCBjb3N0ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAndG90YWwnLCAwLjApO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnYW1vdW50Jyk7XG4gICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdzdGFydGluZ0Ftb3VudCcsIHJlbWFpbmluZyk7XG4gICAgICAgIGxldCBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ29yZGVyTnVtYmVyJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IG9yZGVyWydzdGF0dXMnXSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHJlbWFpbmluZyxcbiAgICAgICAgICAgICd0cmFkZXMnOiB0cmFkZXMsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlT3Blbk9yZGVycyAob3JkZXJzLCBtYXJrZXQsIHJlc3VsdCA9IFtdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlcnNbaV07XG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWQgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHtcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAnc2lkZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3JhdGUnXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMucGFyc2VPcmRlciAoZXh0ZW5kZWQsIG1hcmtldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBwYWlyID0gbWFya2V0ID8gbWFya2V0WydpZCddIDogJ2FsbCc7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RSZXR1cm5PcGVuT3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHBhaXIsXG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG9wZW5PcmRlcnMgPSBbXTtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgb3Blbk9yZGVycyA9IHRoaXMucGFyc2VPcGVuT3JkZXJzIChyZXNwb25zZSwgbWFya2V0LCBvcGVuT3JkZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXRJZHMgPSBPYmplY3Qua2V5cyAocmVzcG9uc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2V0SWQgPSBtYXJrZXRJZHNbaV07XG4gICAgICAgICAgICAgICAgbGV0IG9yZGVycyA9IHJlc3BvbnNlW21hcmtldElkXTtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IHRoaXMubWFya2V0c19ieV9pZFttYXJrZXRJZF07XG4gICAgICAgICAgICAgICAgb3Blbk9yZGVycyA9IHRoaXMucGFyc2VPcGVuT3JkZXJzIChvcmRlcnMsIG0sIG9wZW5PcmRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3Blbk9yZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbb3Blbk9yZGVyc1tqXVsnaWQnXV0gPSBvcGVuT3JkZXJzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQgPSB0aGlzLmluZGV4QnkgKG9wZW5PcmRlcnMsICdpZCcpO1xuICAgICAgICBsZXQgY2FjaGVkT3JkZXJJZHMgPSBPYmplY3Qua2V5cyAodGhpcy5vcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2FjaGVkT3JkZXJJZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGNhY2hlZE9yZGVySWRzW2tdO1xuICAgICAgICAgICAgaWYgKGlkIGluIG9wZW5PcmRlcnNJbmRleGVkQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIG9wZW5PcmRlcnNJbmRleGVkQnlJZFtpZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IG9yZGVyWydhbW91bnQnXSAqIG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxlZCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1haW5pbmcnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddID09IHN5bWJvbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3JkZXJzW2ldWydpZCddID09IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcmRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgT3JkZXJOb3RDYWNoZWQgKHRoaXMuaWQgKyAnIG9yZGVyIGlkICcgKyBpZC50b1N0cmluZyAoKSArICcgbm90IGZvdW5kIGluIGNhY2hlJyk7XG4gICAgfVxuXG4gICAgZmlsdGVyT3JkZXJzQnlTdGF0dXMgKG9yZGVycywgc3RhdHVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09IHN0YXR1cylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAob3JkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck9yZGVyc0J5U3RhdHVzIChvcmRlcnMsICdvcGVuJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJPcmRlcnNCeVN0YXR1cyAob3JkZXJzLCAnY2xvc2VkJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQgKHByaWNlKTtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAoYW1vdW50KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdyYXRlJzogdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMucGFyc2VPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9LCByZXNwb25zZSksIG1hcmtldCk7XG4gICAgICAgIGxldCBpZCA9IG9yZGVyWydpZCddO1xuICAgICAgICB0aGlzLm9yZGVyc1tpZF0gPSBvcmRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kICh7ICdpbmZvJzogcmVzcG9uc2UgfSwgb3JkZXIpO1xuICAgIH1cblxuICAgIGFzeW5jIGVkaXRPcmRlciAoaWQsIHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0IChwcmljZSk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ29yZGVyTnVtYmVyJzogaWQsXG4gICAgICAgICAgICAncmF0ZSc6IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSksXG4gICAgICAgICAgICAnYW1vdW50JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TW92ZU9yZGVyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpZCBpbiB0aGlzLm9yZGVycykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKHRoaXMub3JkZXJzW2lkXSwge1xuICAgICAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIHsgJ2luZm8nOiByZXNwb25zZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlck51bWJlciddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnb3JkZXJOdW1iZXInOiBpZCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMub3JkZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXVsnc3RhdHVzJ10gPSAnY2FuY2VsZWQnO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UuaW5kZXhPZiAoJ0ludmFsaWQgb3JkZXInKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIoKSBlcnJvcjogJyArIHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJTdGF0dXMgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IHRoaXMuaW5kZXhCeSAob3JkZXJzLCAnaWQnKTtcbiAgICAgICAgcmV0dXJuIChpZCBpbiBpbmRleGVkKSA/ICdvcGVuJyA6ICdjbG9zZWQnO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJUcmFkZXMgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0cmFkZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuT3JkZXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJOdW1iZXInOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZURlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGN1cnJlbmN5SWQgPSB0aGlzLmN1cnJlbmN5SWQgKGN1cnJlbmN5KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdlbmVyYXRlTmV3QWRkcmVzcyAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3lJZFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddID09IDEpXG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZSwgJ3Jlc3BvbnNlJyk7XG4gICAgICAgIGlmICghYWRkcmVzcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjcmVhdGVEZXBvc2l0QWRkcmVzcyBmYWlsZWQ6ICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybkRlcG9zaXRBZGRyZXNzZXMgKCk7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZSwgY3VycmVuY3lJZCk7XG4gICAgICAgIGxldCBzdGF0dXMgPSBhZGRyZXNzID8gJ29rJyA6ICdub25lJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeUlkLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsncmVzcG9uc2UnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7ICdjb21tYW5kJzogcGF0aCB9LCBwYXJhbXMpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgcXVlcnlbJ25vbmNlJ10gPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gdGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpO1xuICAgICAgICAgICAgbGV0IGZhaWxlZCA9IHJlc3BvbnNlWydlcnJvciddLmluZGV4T2YgKCdOb3QgZW5vdWdoJykgPj0gMDtcbiAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzIChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBPcmRlck5vdEZvdW5kLCBJbnN1ZmZpY2llbnRGdW5kcyB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgcXJ5cHRvcyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdxcnlwdG9zJyxcbiAgICAgICAgICAgICduYW1lJzogJ1FSWVBUT1MnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0NOJywgJ1RXJyBdLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwOTUzOTE1LWIxNjExZGMwLWE0MzYtMTFlNy04OTQ3LWM5NWJkNWE0MjA4Ni5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXJ5cHRvcy5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucXJ5cHRvcy5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLnF1b2luZS5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS9wcmljZV9sZXZlbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lyX2xhZGRlcnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cy9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcnlwdG9fYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbnMvbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpYXRfYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYW5fYmlkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfS9sb2FucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ19hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ19hY2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmlhdF9hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hbl9iaWRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYW5fYmlkcy97aWR9L2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2Fucy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0vY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL3tpZH0vY2xvc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9jbG9zZV9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRpbmdfYWNjb3VudHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncXVvdGVkX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1ha2VyID0gcGFyc2VGbG9hdCAobWFya2V0WydtYWtlcl9mZWUnXSk7XG4gICAgICAgICAgICBsZXQgdGFrZXIgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3Rha2VyX2ZlZSddKTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSAhbWFya2V0WydkaXNhYmxlZCddO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRzQmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHRvdGFsLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkUHJpY2VMZXZlbHMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5X3ByaWNlX2xldmVscycsICdzZWxsX3ByaWNlX2xldmVscycpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2xhc3RfdHJhZGVkX3ByaWNlJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aWNrZXJbJ2xhc3RfdHJhZGVkX3ByaWNlJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGlja2VyWydsYXN0X3RyYWRlZF9wcmljZSddLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF90cmFkZWRfcHJpY2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoX21hcmtldF9hc2snXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dfbWFya2V0X2JpZCddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21hcmtldF9iaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXJrZXRfYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogbGFzdCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV8yNGgnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aWNrZXJbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHRpY2tlclsncXVvdGVkX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydjcmVhdGVkX2F0J10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0YWtlcl9zaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3F1YW50aXR5J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhlY3V0aW9ucyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ21vZGVscyddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdvcmRlcl90eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdwcm9kdWN0X2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUHV0T3JkZXJzSWRDYW5jZWwgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyWydjcmVhdGVkX2F0J10gKiAxMDAwO1xuICAgICAgICBsZXQgbWFya2V0SWQgPSBvcmRlclsncHJvZHVjdF9pZCddO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzQnlJZFttYXJrZXRJZF07XG4gICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiBvcmRlcikge1xuICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnZmlsbGVkJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ2NhbmNlbGxlZCcpIHsgLy8gJ2xsJyBpbnRlbmRlZFxuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKG9yZGVyWydxdWFudGl0eSddKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHBhcnNlRmxvYXQgKG9yZGVyWydmaWxsZWRfcXVhbnRpdHknXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWydvcmRlcl90eXBlJ10sXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBvcmRlclsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IGFtb3VudCAtIGZpbGxlZCxcbiAgICAgICAgICAgICd0cmFkZXMnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmVlJzoge1xuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKG9yZGVyWydvcmRlcl9mZWUnXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlcnNJZCAoeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAob3JkZXIpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zPXt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncHJvZHVjdF9pZCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0dXMgPSBwYXJhbXNbJ3N0YXR1cyddO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdvcGVuJykge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhdHVzJ10gPSAnbGl2ZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGF0dXMnXSA9ICdmaWxsZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAnY2FuY2VsZWQnKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGF0dXMnXSA9ICdjYW5jZWxsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlcnMgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgb3JkZXJzID0gcmVzdWx0Wydtb2RlbHMnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0KTtcbiAgICB9XG5cbiAgICBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBzaW5jZSwgbGltaXQsIHRoaXMuZXh0ZW5kICh7ICdzdGF0dXMnOiAnb3BlbicgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBzaW5jZSwgbGltaXQsIHRoaXMuZXh0ZW5kICh7ICdzdGF0dXMnOiAnY2xvc2VkJyB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29kZSA9PSAyMDAgfHwgY29kZSA9PSA0MDQgfHwgY29kZSA9PSA0MjIpIHtcbiAgICAgICAgICAgIGlmICgoYm9keVswXSA9PSAneycpIHx8IChib2R5WzBdID09ICdbJykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJldHVybmVkIGEgbm9uLUpTT04gcmVwbHk6ICcgKyBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA9PSA0MDQpIHtcbiAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnT3JkZXIgbm90IGZvdW5kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IDQyMikge1xuICAgICAgICAgICAgaWYgKCdlcnJvcnMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9ycyA9IHJlc3BvbnNlWydlcnJvcnMnXTtcbiAgICAgICAgICAgICAgICBpZiAoJ3VzZXInIGluIGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZXMgPSBlcnJvcnNbJ3VzZXInXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmluZGV4T2YgKCdub3RfZW5vdWdoX2ZyZWVfYmFsYW5jZScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnWC1RdW9pbmUtQVBJLVZlcnNpb24nOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAncGF0aCc6IHVybCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAndG9rZW5faWQnOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnaWF0JzogTWF0aC5mbG9vciAobm9uY2UgLyAxMDAwKSwgLy8gaXNzdWVkIGF0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaGVhZGVyc1snWC1RdW9pbmUtQXV0aCddID0gdGhpcy5qd3QgKHJlcXVlc3QsIHRoaXMuc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHF1YWRyaWdhY3ggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAncXVhZHJpZ2FjeCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdRdWFkcmlnYUNYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ0EnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODI1LTk4YTZkMGRlLTVlZTctMTFlNy05ZmE0LTM4ZTExYTJjNmY1Mi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXVhZHJpZ2FjeC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucXVhZHJpZ2FjeC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cucXVhZHJpZ2FjeC5jb20vYXBpX2luZm8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V0aGVyX2RlcG9zaXRfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXRoZXJfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9va3VwX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9DQUQnOiB7ICdpZCc6ICdidGNfY2FkJywgJ3N5bWJvbCc6ICdCVEMvQ0FEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NBRCcsICdtYWtlcic6IDAuMDA1LCAndGFrZXInOiAwLjAwNSB9LFxuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjX3VzZCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwNSwgJ3Rha2VyJzogMC4wMDUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIsICd0YWtlcic6IDAuMDAyIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9DQUQnOiB7ICdpZCc6ICdldGhfY2FkJywgJ3N5bWJvbCc6ICdFVEgvQ0FEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0NBRCcsICdtYWtlcic6IDAuMDA1LCAndGFrZXInOiAwLjAwNSB9LFxuICAgICAgICAgICAgICAgICdMVEMvQ0FEJzogeyAnaWQnOiAnbHRjX2NhZCcsICdzeW1ib2wnOiAnTFRDL0NBRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdDQUQnLCAnbWFrZXInOiAwLjAwNSwgJ3Rha2VyJzogMC4wMDUgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0NBRCc6IHsgJ2lkJzogJ2J0Y19jYWQnLCAnc3ltYm9sJzogJ0JDSC9DQUQnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQ0FEJywgJ21ha2VyJzogMC4wMDUsICd0YWtlcic6IDAuMDA1IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlICsgJ19hdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2UgKyAnX3Jlc2VydmVkJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZSArICdfYmFsYW5jZSddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gWyBub25jZS50b1N0cmluZyAoKSwgdGhpcy51aWQsIHRoaXMuYXBpS2V5IF0uam9pbiAoJycpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBxcnlwdG9zID0gcmVxdWlyZSAoJy4vcXJ5cHRvcy5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHF1b2luZSBleHRlbmRzIHFyeXB0b3Mge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3F1b2luZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdRVU9JTkUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0pQJywgJ1NHJywgJ1ZOJyBdLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4NDQtOTYxNWE0ZTgtNWVlOC0xMWU3LTg4MTQtZmNkMDA0ZGI4Y2RkLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5xdW9pbmUuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnF1b2luZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLnF1b2luZS5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHNvdXRoeGNoYW5nZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdzb3V0aHhjaGFuZ2UnLFxuICAgICAgICAgICAgJ25hbWUnOiAnU291dGhYY2hhbmdlJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQVInLCAvLyBBcmdlbnRpbmFcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4Mzg5MTItNGY5NGVjOGEtNjBmNi0xMWU3LTllNWQtYmJmOWJkNTBhNTU5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5zb3V0aHhjaGFuZ2UuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5zb3V0aHhjaGFuZ2UuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnNvdXRoeGNoYW5nZS5jb20vSG9tZS9BcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbE1hcmtldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dlbmVyYXRlbmV3YWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFswXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsxXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgaWQgPSBzeW1ib2w7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RMaXN0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ0N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgZnJlZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgIGxldCB1c2VkID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnVW5jb25maXJtZWQnXSk7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSB0aGlzLnN1bSAoZnJlZSwgdXNlZCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Qm9va1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnQnV5T3JkZXJzJywgJ1NlbGxPcmRlcnMnLCAnUHJpY2UnLCAnQW1vdW50Jyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnVmFyaWF0aW9uMjRIcicpLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ1ZvbHVtZTI0SHInKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcmljZXMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gdGhpcy5pbmRleEJ5IChyZXNwb25zZSwgJ01hcmtldCcpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcmljZVN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydBdCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ1R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydBbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2xpc3RpbmdDdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICAgICAgJ3JlZmVyZW5jZUN1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydsaW1pdFByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlT3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2UudG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJDb2RlJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdIYXNoJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZm94Yml0ID0gcmVxdWlyZSAoJy4vZm94Yml0LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mgc3VyYml0Y29pbiBleHRlbmRzIGZveGJpdCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnc3VyYml0Y29pbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdTdXJCaXRjb2luJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVkUnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE1MTEtZjBhNTAxOTQtNjQ4MS0xMWU3LTk5YjUtOGYwMjkzMjQyNGNjLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9zdXJiaXRjb2luLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdGhlcm9jayBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd0aGVyb2NrJyxcbiAgICAgICAgICAgICduYW1lJzogJ1RoZVJvY2tUcmFkaW5nJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnTVQnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODY5LTc1MDU3ZmEyLTVlZTktMTFlNy05YTZmLTEzZTY0MWZhNDcwNy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkudGhlcm9ja3RyYWRpbmcuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdGhlcm9ja3RyYWRpbmcuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGkudGhlcm9ja3RyYWRpbmcuY29tL2RvYy92MS9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLnRoZXJvY2t0cmFkaW5nLmNvbS9kb2MvJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97aWR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy90aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2Z1bmRfaWR9L3Bvc2l0aW9uX2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vcG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vcG9zaXRpb25zL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2xpbWl0cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd19saW1pdHMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdG1zL3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMvcmVtb3ZlX2FsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNUaWNrZXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1sndGlja2VycyddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sndGlja2VycyddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydmdW5kX2lkJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gYmFsYW5jZVsndHJhZGluZ19iYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBiYWxhbmNlWydiYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHRvdGFsIC0gZnJlZTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnJlZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHVzZWQsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdG90YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEZ1bmRzSWRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlcmJvb2tbJ2RhdGUnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ2RhdGUnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWVfdHJhZGVkJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2VbJ3RpY2tlcnMnXSwgJ2Z1bmRfaWQnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRGdW5kc0lkVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydmdW5kX2lkJ11dO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydkYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RGdW5kc0Z1bmRJZE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdmdW5kX2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVGdW5kc0Z1bmRJZE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbm9uY2UgKyB1cmw7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdYLVRSVC1LRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnWC1UUlQtTk9OQ0UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnWC1UUlQtU0lHTic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3JzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBsaXF1aSA9IHJlcXVpcmUgKCcuL2xpcXVpLmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdGlkZXggZXh0ZW5kcyBsaXF1aSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndGlkZXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnVGlkZXgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVSycsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJzMnLFxuICAgICAgICAgICAgLy8gJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDc4MTc4MC0wMzE0OWRjNC1hMTJlLTExZTctODJiYi0zMTNiMjY5ZDI0ZDQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLnRpZGV4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS50aWRleC5jb20vdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdGlkZXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vdGlkZXguY29tL3B1YmxpYy1hcGknLFxuICAgICAgICAgICAgICAgICdmZWVzJzogJ2h0dHBzOi8vdGlkZXguY29tL3BhaXJzLXNwZWMnXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGZveGJpdCA9IHJlcXVpcmUgKCcuL2ZveGJpdC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHVyZHViaXQgZXh0ZW5kcyBmb3hiaXQge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3VyZHViaXQnLFxuICAgICAgICAgICAgJ25hbWUnOiAnVXJkdUJpdCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1BLJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkxNDUzLTE1NmJmM2FlLTY0ODAtMTFlNy04MmViLTcyOTVmZTFiNWJiNC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdXJkdWJpdC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9ibGlua3RyYWRlLmNvbS9kb2NzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdmF1bHRvcm8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndmF1bHRvcm8nLFxuICAgICAgICAgICAgJ25hbWUnOiAnVmF1bHRvcm8nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDSCcsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJzEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njg4MC1mMjA1ZTg3MC01ZWU5LTExZTctOGZlMi0wZDViMTU4ODA3NTIuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLnZhdWx0b3JvLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy52YXVsdG9yby5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9hcGkudmF1bHRvcm8uY29tJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmlkYW5kYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF0ZXN0dHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucy9kYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucy9ob3VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMvbW9udGgnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eS97c3ltYm9sfS97dHlwZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbC97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsL3tzeW1ib2x9L3t0eXBlfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1snZGF0YSddO1xuICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgbGV0IGJhc2VJZCA9IGJhc2U7XG4gICAgICAgIGxldCBxdW90ZUlkID0gcXVvdGU7XG4gICAgICAgIGxldCBpZCA9IG1hcmtldFsnTWFya2V0TmFtZSddO1xuICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAnYmFzZUlkJzogYmFzZUlkLFxuICAgICAgICAgICAgJ3F1b3RlSWQnOiBxdW90ZUlkLFxuICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3lfY29kZSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBiYWxhbmNlWydjYXNoJ107XG4gICAgICAgICAgICBsZXQgdXNlZCA9IGJhbGFuY2VbJ3Jlc2VydmVkJ107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSB0aGlzLnN1bSAoZnJlZSwgdXNlZCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHBhcmFtcyk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IHJlc3BvbnNlWydkYXRhJ11bMF1bJ2InXSxcbiAgICAgICAgICAgICdhc2tzJzogcmVzcG9uc2VbJ2RhdGEnXVsxXVsncyddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAnR29sZF9QcmljZScsICdHb2xkX0Ftb3VudCcpO1xuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHF1b3RlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCaWRhbmRhc2sgKHBhcmFtcyk7XG4gICAgICAgIGxldCBiaWRzTGVuZ3RoID0gcXVvdGVbJ2JpZHMnXS5sZW5ndGg7XG4gICAgICAgIGxldCBiaWQgPSBxdW90ZVsnYmlkcyddW2JpZHNMZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IGFzayA9IHF1b3RlWydhc2tzJ11bMF07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJzI0aEhpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWycyNGhMb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogYmlkWzBdLFxuICAgICAgICAgICAgJ2Fzayc6IGFza1swXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnTGFzdFByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnMjRoVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydUaW1lJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsnR29sZF9QcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydHb2xkX0Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYW5zYWN0aW9uc0RheSAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ1N5bWJvbFR5cGUnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydxdW90ZUlkJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnZ2xkJzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UgfHwgMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXVsnT3JkZXJfSUQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sIHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKSk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnWC1TaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlICh1cmwpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZm94Yml0ID0gcmVxdWlyZSAoJy4vZm94Yml0LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdmJ0YyBleHRlbmRzIGZveGJpdCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndmJ0YycsXG4gICAgICAgICAgICAnbmFtZSc6ICdWQlRDJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVk4nLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE0ODEtMWY1M2QxZDgtNjQ4MS0xMWU3LTg4NGUtMjFkMTdlNzkzOWRiLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly92YnRjLmV4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB2aXJ3b3ggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndmlyd294JyxcbiAgICAgICAgICAgICduYW1lJzogJ1ZpcldvWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnQVQnLCAnRVUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4OTQtNmRhOWQzNjAtNWVlYS0xMWU3LTkwYWEtNDFmMjcxMWI3NDA1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwOi8vYXBpLnZpcndveC5jb20vYXBpL2pzb24ucGhwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cudmlyd294LmNvbS9hcGkvdHJhZGluZy5waHAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy52aXJ3b3guY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnZpcndveC5jb20vZGV2ZWxvcGVycy5waHAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnbG9naW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICdwYXNzd29yZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5zdHJ1bWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJlc3RQcmljZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE1hcmtldERlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdlc3RpbWF0ZU1hcmtldE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUcmFkZWRQcmljZVZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0UmF3VHJhZGVEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUZXJtaW5hbExpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEdyaWRMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRHcmlkU3RhdGlzdGljcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEluc3RydW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRCZXN0UHJpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRNYXJrZXREZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXN0aW1hdGVNYXJrZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhZGVkUHJpY2VWb2x1bWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFJhd1RyYWRlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0U3RhdGlzdGljcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VGVybWluYWxMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRHcmlkTGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0R3JpZFN0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDb21taXNzaW9uRGlzY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDb21taXNzaW9uRGlzY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEluc3RydW1lbnRzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydyZXN1bHQnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzdWx0J11ba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2luc3RydW1lbnRJRCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnbG9uZ0N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3Nob3J0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J11bJ2FjY291bnRMaXN0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBiYWxhbmNlWydiYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHRvdGFsLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldFByaWNlIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljUG9zdEdldEJlc3RQcmljZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9scyc6IFsgc3ltYm9sIF0sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0IChyZXN1bHRbMF0sICdiZXN0QnV5UHJpY2UnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAocmVzdWx0WzBdLCAnYmVzdFNlbGxQcmljZScpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljUG9zdEdldE1hcmtldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbHMnOiBbIHN5bWJvbCBdLFxuICAgICAgICAgICAgJ2J1eURlcHRoJzogMTAwLFxuICAgICAgICAgICAgJ3NlbGxEZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J11bMF07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eScsICdzZWxsJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZW5kIC0gODY0MDAwMDA7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVkUHJpY2VWb2x1bWUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaW5zdHJ1bWVudCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdlbmREYXRlJzogdGhpcy5ZbWRITVMgKGVuZCksXG4gICAgICAgICAgICAnc3RhcnREYXRlJzogdGhpcy5ZbWRITVMgKHN0YXJ0KSxcbiAgICAgICAgICAgICdITE9DJzogMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBtYXJrZXRQcmljZSA9IGF3YWl0IHRoaXMuZmV0Y2hNYXJrZXRQcmljZSAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXVsncHJpY2VWb2x1bWVMaXN0J107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBsYXN0S2V5ID0ga2V5c1tsZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbGFzdEtleV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogbWFya2V0UHJpY2VbJ2JpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IG1hcmtldFByaWNlWydhc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydsb25nVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydzaG9ydFZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wdWJsaWNHZXRSYXdUcmFkZURhdGEgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaW5zdHJ1bWVudCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3Bhbic6IDM2MDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdpbnN0cnVtZW50JzogdGhpcy5zeW1ib2wgKG1hcmtldCksXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UGxhY2VPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJJRCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVySUQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBsZXQgYXV0aCA9IHt9O1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBhdXRoWydrZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgYXV0aFsndXNlciddID0gdGhpcy5sb2dpbjtcbiAgICAgICAgICAgIGF1dGhbJ3Bhc3MnXSA9IHRoaXMucGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgYXV0aCwgcGFyYW1zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHRoaXMuZXh0ZW5kIChhdXRoLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGxpcXVpID0gcmVxdWlyZSAoJy4vbGlxdWkuanMnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgRERvU1Byb3RlY3Rpb24gfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mgd2V4IGV4dGVuZHMgbGlxdWkge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3dleCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdXRVgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdOWicsIC8vIE5ldyBaZWFsYW5kXG4gICAgICAgICAgICAndmVyc2lvbic6ICczJyxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzA2NTI3NTEtZDc0ZWM4ZjgtOWUzMS0xMWU3LTk4YzUtNzE0NjlmY2VmMDNlLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3dleC5uei9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3dleC5uei90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93ZXgubnonLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3dleC5uei9hcGkvMy9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd2V4Lm56L3RhcGkvZG9jcycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlckluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29pbkRlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NyZWF0ZUNvdXBvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVkZWVtQ291cG9uJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvdycpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2F2ZycpLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sX2N1cicpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID09IDIwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gIT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgbm90IEpTT05cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmV0dXJuZWQgYSBub24tSlNPTiByZXBseTogJyArIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSAoYm9keSk7XG4gICAgICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IHRoaXMuc2FmZVZhbHVlIChyZXNwb25zZSwgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXR1cm5lZCBhIG1hbGZvcm1lZCBlcnJvcjogJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yID09ICdiYWQgc3RhdHVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuaW5kZXhPZiAoJ0l0IGlzIG5vdCBlbm91Z2gnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT0gJ1JlcXVlc3RzIHRvbyBvZnRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PSAnbm90IGF2YWlsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PSAnZXh0ZXJuYWwgc2VydmljZSB1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCdzIHdoYXQgZmV0Y2hPcGVuT3JkZXJzIHJldHVybiBpZiBubyBvcGVuIG9yZGVycyAoZml4IGZvciAjNDg5KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yICE9ICdubyBvcmRlcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB4YnRjZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd4YnRjZScsXG4gICAgICAgICAgICAnbmFtZSc6ICd4QlRDZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1JVJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLCAvLyByZXNwb25zZXMgYXJlIGNhY2hlZCBldmVyeSAyIHNlY29uZHNcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNQdWJsaWNBUEknOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDU5NDE0LWUyMzU5NzBjLTY2MmMtMTFlNy04YzNhLTA4ZTMxZjc4Njg0Yi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9jcnlwdG90dGxpdmV3ZWJhcGkueGJ0Y2UubmV0Ojg0NDMvYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnhidGNlLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnhidGNlLmNvbS90cmFkZWFwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3N1cHBvcnQueGJ0Y2UuaW5mby9Lbm93bGVkZ2ViYXNlL0FydGljbGUvVmlldy81Mi8yNS94YnRjZS1leGNoYW5nZS1hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3VpZCc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeS97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZXZlbDIve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbC97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGljay97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXNlcnZlcmluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5L3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZXZlbDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xldmVsMi97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2sve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fzc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhc3NldC97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24ve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2Fzay9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9iaWQvaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMi9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0vcGVyaW9kaWNpdGllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0vdGlja3MvaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L2NhY2hlL3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9hc2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9jYWNoZS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvY2FjaGUve3N5bWJvbH0vbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvY2FjaGUve3N5bWJvbH0vdGlja3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9zeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvdmVyc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0U3ltYm9sICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ1N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ01hcmdpbkN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ1Byb2ZpdEN1cnJlbmN5J107XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnSXNUcmFkZUFsbG93ZWQnXSA/IHN5bWJvbCA6IGlkO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBc3NldCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIC8vIHhidGNlIG5hbWVzIERBU0ggaW5jb3JyZWN0bHkgYXMgRFNIXG4gICAgICAgICAgICBpZiAodXBwZXJjYXNlID09ICdEU0gnKVxuICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9ICdEQVNIJztcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnRnJlZUFtb3VudCddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsnTG9ja2VkQW1vdW50J10sXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnQW1vdW50J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3VwcGVyY2FzZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRMZXZlbDJGaWx0ZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnZmlsdGVyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgb3JkZXJib29rID0gb3JkZXJib29rWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWydUaW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnQmlkcycsICdBc2tzJywgJ1ByaWNlJywgJ1ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gMDtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnTGFzdEJ1eVRpbWVzdGFtcCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA8IHRpY2tlclsnTGFzdEJ1eVRpbWVzdGFtcCddKSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gdGlja2VyWydMYXN0QnV5VGltZXN0YW1wJ107XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRpY2tlclsnTGFzdEJ1eVByaWNlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmICgnTGFzdFNlbGxUaW1lc3RhbXAnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCB0aWNrZXJbJ0xhc3RTZWxsVGltZXN0YW1wJ10pIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB0aWNrZXJbJ0xhc3RTZWxsVGltZXN0YW1wJ107XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRpY2tlclsnTGFzdFNlbGxQcmljZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVzdGFtcClcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aWNrZXJbJ0RhaWx5QmVzdEJ1eVByaWNlJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydEYWlseUJlc3RTZWxsUHJpY2UnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ0Jlc3RCaWQnXSxcbiAgICAgICAgICAgICdhc2snOiB0aWNrZXJbJ0Jlc3RBc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGlja2VyWydEYWlseVRyYWRlZFRvdGFsVm9sdW1lJ10sXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHRpY2tlcnMsICdTeW1ib2wnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT0gJ0RTSCcpXG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSAnREFTSCc7XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlID09ICdEU0gnKVxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICdEQVNIJztcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckZpbHRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdmaWx0ZXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGlja2Vycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VyIHJldHVybmVkIGVtcHR5IHJlc3BvbnNlLCB4QlRDZSBwdWJsaWMgQVBJIGVycm9yJyk7XG4gICAgICAgIHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHRpY2tlcnMsICdTeW1ib2wnKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIG5vIG1ldGhvZCBmb3IgdHJhZGVzP1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlR2V0VHJhZGUgKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlsnVGltZXN0YW1wJ10sXG4gICAgICAgICAgICBvaGxjdlsnT3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ0hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2WydMb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydDbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ1ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9ITENWIGlzIGRpc2FibGVkIGJ5IHRoZSBleGNoYW5nZScpO1xuICAgICAgICBsZXQgbWludXRlcyA9IHBhcnNlSW50ICh0aW1lZnJhbWUgLyA2MCk7IC8vIDEgbWludXRlIGJ5IGRlZmF1bHRcbiAgICAgICAgbGV0IHBlcmlvZGljaXR5ID0gbWludXRlcy50b1N0cmluZyAoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBpZiAoIXNpbmNlKVxuICAgICAgICAgICAgc2luY2UgPSB0aGlzLnNlY29uZHMgKCkgLSA4NjQwMCAqIDc7IC8vIGxhc3QgZGF5IGJ5IGRlZnVsYXRcbiAgICAgICAgaWYgKCFsaW1pdClcbiAgICAgICAgICAgIGxpbWl0ID0gMTAwMDsgLy8gZGVmYXVsdFxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRRdW90ZWhpc3RvcnlTeW1ib2xQZXJpb2RpY2l0eUJhcnNCaWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZGljaXR5JzogcGVyaW9kaWNpdHksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogc2luY2UsXG4gICAgICAgICAgICAnY291bnQnOiBsaW1pdCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsnQmFycyddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50YXBpUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlVHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnVHlwZSc6ICdDYW5jZWwnLFxuICAgICAgICAgICAgJ0lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhcGlLZXkgZm9yIGFsbCByZXF1ZXN0cywgdGhlaXIgcHVibGljIEFQSSBpcyBhbHdheXMgYnVzeScpO1xuICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIHVpZCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24gYW5kIHRyYWRpbmcsIHRoZWlyIHB1YmxpYyBBUEkgaXMgYWx3YXlzIGJ1c3knKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb247XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpXG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpO1xuICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJyB9O1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXkgKyBtZXRob2QgKyB1cmw7XG4gICAgICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgICAgICBhdXRoICs9IGJvZHk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBsZXQgY3JlZGVudGlhbHMgPSB0aGlzLnVpZCArICc6JyArIHRoaXMuYXBpS2V5ICsgJzonICsgbm9uY2UgKyAnOicgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChzaWduYXR1cmUpO1xuICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0hNQUMgJyArIGNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBsaXF1aSA9IHJlcXVpcmUgKCcuL2xpcXVpLmpzJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIEREb1NQcm90ZWN0aW9uIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHlvYml0IGV4dGVuZHMgbGlxdWkge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3lvYml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ1lvQml0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnUlUnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDMwMDAsIC8vIHJlc3BvbnNlcyBhcmUgY2FjaGVkIGV2ZXJ5IDIgc2Vjb25kc1xuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMycsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY5MTAtY2RjYmZkYWUtNWVlYS0xMWU3LTk4NTktMDNmZWE4NzMyNzJkLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3lvYml0Lm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3lvYml0Lm5ldC90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cueW9iaXQubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnlvYml0Lm5ldC9lbi9hcGkvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY3RpdmVPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW5zVG9BZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IDAuMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgbGV0IHN1YnN0aXR1dGlvbnMgPSB7XG4gICAgICAgICAgICAnQUlSJzogJ0FpckNvaW4nLFxuICAgICAgICAgICAgJ0FOSSc6ICdBTklDb2luJyxcbiAgICAgICAgICAgICdBTlQnOiAnQW50c0NvaW4nLFxuICAgICAgICAgICAgJ0FUTSc6ICdBdXR1bW5jb2luJyxcbiAgICAgICAgICAgICdCQ0MnOiAnQkNIJyxcbiAgICAgICAgICAgICdCVFMnOiAnQml0c2hhcmVzMicsXG4gICAgICAgICAgICAnRENUJzogJ0Rpc2NvdW50JyxcbiAgICAgICAgICAgICdER0QnOiAnRGFya0dvbGRDb2luJyxcbiAgICAgICAgICAgICdJQ04nOiAnaUNvaW4nLFxuICAgICAgICAgICAgJ0xJWkknOiAnTGlaaScsXG4gICAgICAgICAgICAnTFVOJzogJ0x1bmFyQ29pbicsXG4gICAgICAgICAgICAnTkFWJzogJ05hdmFqb0NvaW4nLFxuICAgICAgICAgICAgJ09NRyc6ICdPTUdhbWUnLFxuICAgICAgICAgICAgJ1BBWSc6ICdFUEFZJyxcbiAgICAgICAgICAgICdSRVAnOiAnUmVwdWJsaWNvaW4nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVuY3kgaW4gc3Vic3RpdHV0aW9ucylcbiAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb25zW2N1cnJlbmN5XTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGN1cnJlbmN5SWQgKGNvbW1vbkNvZGUpIHtcbiAgICAgICAgbGV0IHN1YnN0aXR1dGlvbnMgPSB7XG4gICAgICAgICAgICAnQWlyQ29pbic6ICdBSVInLFxuICAgICAgICAgICAgJ0FOSUNvaW4nOiAnQU5JJyxcbiAgICAgICAgICAgICdBbnRzQ29pbic6ICdBTlQnLFxuICAgICAgICAgICAgJ0F1dHVtbmNvaW4nOiAnQVRNJyxcbiAgICAgICAgICAgICdCQ0gnOiAnQkNDJyxcbiAgICAgICAgICAgICdCaXRzaGFyZXMyJzogJ0JUUycsXG4gICAgICAgICAgICAnRGlzY291bnQnOiAnRENUJyxcbiAgICAgICAgICAgICdEYXJrR29sZENvaW4nOiAnREdEJyxcbiAgICAgICAgICAgICdpQ29pbic6ICdJQ04nLFxuICAgICAgICAgICAgJ0xpWmknOiAnTElaSScsXG4gICAgICAgICAgICAnTHVuYXJDb2luJzogJ0xVTicsXG4gICAgICAgICAgICAnTmF2YWpvQ29pbic6ICdOQVYnLFxuICAgICAgICAgICAgJ09NR2FtZSc6ICdPTUcnLFxuICAgICAgICAgICAgJ0VQQVknOiAnUEFZJyxcbiAgICAgICAgICAgICdSZXB1YmxpY29pbic6ICdSRVAnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tbW9uQ29kZSBpbiBzdWJzdGl0dXRpb25zKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnNbY29tbW9uQ29kZV07XG4gICAgICAgIHJldHVybiBjb21tb25Db2RlO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgc2lkZXMgPSB7ICdmcmVlJzogJ2Z1bmRzJywgJ3RvdGFsJzogJ2Z1bmRzX2luY2xfb3JkZXJzJyB9O1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChzaWRlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBsZXQgc2lkZSA9IHNpZGVzW2tleV07XG4gICAgICAgICAgICBpZiAoc2lkZSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzW3NpZGVdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmNpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBsb3dlcmNhc2UudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWNjb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCA9IHJlc3VsdFtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRba2V5XSA9IGJhbGFuY2VzW3NpZGVdW2xvd2VyY2FzZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50Wyd0b3RhbCddICYmIGFjY291bnRbJ2ZyZWUnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ25lZWRfbmV3JzogMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogcmVzcG9uc2VbJ2FkZHJlc3MnXSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZVsnaW5mbyddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjb2luTmFtZSc6IGN1cnJlbmN5SWQsXG4gICAgICAgICAgICAnbmVlZF9uZXcnOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0RGVwb3NpdEFkZHJlc3MgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLnNhZmVTdHJpbmcgKHJlc3BvbnNlWydyZXR1cm4nXSwgJ2FkZHJlc3MnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXdDb2luc1RvQWRkcmVzcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luTmFtZSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydzdWNjZXNzJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10uaW5kZXhPZiAoJ0luc3VmZmljaWVudCBmdW5kcycpID49IDApIHsgLy8gbm90IGVub3VnVGggaXMgYSB0eXBvIGluc2lkZSBMaXF1aSdzIG93biBBUEkuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VbJ2Vycm9yJ10gPT0gJ1JlcXVlc3RzIHRvbyBvZnRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlWydlcnJvciddID09ICdub3QgYXZhaWxhYmxlJykgfHwgKHJlc3BvbnNlWydlcnJvciddID09ICdleHRlcm5hbCBzZXJ2aWNlIHVuYXZhaWxhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGFjeCA9IHJlcXVpcmUgKCcuL2FjeC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHl1bmJpIGV4dGVuZHMgYWN4IHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd5dW5iaScsXG4gICAgICAgICAgICAnbmFtZSc6ICdZVU5CSScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzEnLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1JyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzMwJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnNjAnLFxuICAgICAgICAgICAgICAgICcyaCc6ICcxMjAnLFxuICAgICAgICAgICAgICAgICc0aCc6ICcyNDAnLFxuICAgICAgICAgICAgICAgICcxMmgnOiAnNzIwJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMTQ0MCcsXG4gICAgICAgICAgICAgICAgJzNkJzogJzQzMjAnLFxuICAgICAgICAgICAgICAgICcxdyc6ICcxMDA4MCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODU3MDU0OC00ZDY0NmM0MC03MTQ3LTExZTctOWNmNi04MzliOTNlNmQ2MjIuanBnJyxcbiAgICAgICAgICAgICAgICAnZXh0ZW5zaW9uJzogJy5qc29uJywgLy8gZGVmYXVsdCBleHRlbnNpb24gYXBwZW5kZWQgdG8gZW5kcG9pbnQgVVJMc1xuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly95dW5iaS5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly95dW5iaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3l1bmJpLmNvbS9kb2N1bWVudHMvYXBpL2d1aWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8veXVuYmkuY29tL3N3YWdnZXIvJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzL3ttYXJrZXR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrX3dpdGhfcGVuZGluZ190cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzc2VzL3thZGRyZXNzfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFydG5lcnMvb3JkZXJzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZW1iZXJzL21lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9teScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvbXVsdGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9jbGVhcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHphaWYgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnemFpZicsXG4gICAgICAgICAgICAnbmFtZSc6ICdaYWlmJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSlAnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjkyNy0zOWNhMmFkYS01ZWViLTExZTctOTcyZi0xYjQxOTk1MThjYTYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLnphaWYuanAnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly96YWlmLmpwJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cDovL3RlY2hidXJlYXUtYXBpLWRvY3VtZW50LnJlYWR0aGVkb2NzLmlvL2phL2xhdGVzdC9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY29ycC56YWlmLmpwL2FwaS1kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY29ycC56YWlmLmpwL2FwaS1kb2NzL2FwaV9saW5rcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS96YWlmLmpwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS95b3UyMTk3OS9ub2RlLXphaWYnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY2llcy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmNpZXMvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeV9wYWlycy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXJzL2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZV9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdF9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfaWRfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9pbmZvMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3BlcnNvbmFsX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWNhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZUludm9pY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEludm9pY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEludm9pY2VJZHNCeU9yZGVyTnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxJbnZvaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0bGFwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb25faGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlX3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3JlYXRlX3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGFuZ2VfcG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9wb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZmFwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdncm91cHMve2dyb3VwX2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97Z3JvdXBfaWR9L3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tncm91cF9pZH0ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2dyb3VwX2lkfS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3tncm91cF9pZH0ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5UGFpcnNBbGwgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnY3VycmVuY3lfcGFpciddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlc1snZnVuZHMnXSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbJ2Z1bmRzJ11bY3VycmVuY3ldO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCdkZXBvc2l0JyBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snZGVwb3NpdCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1snZGVwb3NpdCddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCB2d2FwID0gdGlja2VyWyd2d2FwJ107XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gdGlja2VyWyd2b2x1bWUnXTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydoaWdoJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydsb3cnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ2JpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlclsnYXNrJ10sXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGlja2VyWydsYXN0J10sXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHJhZGVfdHlwZSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICdpZCcpO1xuICAgICAgICBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICd0aWQnLCBpZCk7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lfcGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnYWN0aW9uJzogKHNpZGUgPT0gJ2J1eScpID8gJ2JpZCcgOiAnYXNrJyxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3JldHVybiddWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAob3JkZXJbJ2FjdGlvbiddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnY3VycmVuY3lfcGFpciddXTtcbiAgICAgICAgbGV0IHByaWNlID0gb3JkZXJbJ3ByaWNlJ107XG4gICAgICAgIGxldCBhbW91bnQgPSBvcmRlclsnYW1vdW50J107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6ICdsaW1pdCcsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogcHJpY2UgKiBhbW91bnQsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHJhZGVzJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVycyAob3JkZXJzLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChvcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IGV4dGVuZGVkID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7ICdpZCc6IGlkIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMucGFyc2VPcmRlciAoZXh0ZW5kZWQsIG1hcmtldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAvLyAnaXNfdG9rZW4nOiBmYWxzZSxcbiAgICAgICAgICAgIC8vICdpc190b2tlbl9ib3RoJzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnY3VycmVuY3lfcGFpciddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBY3RpdmVPcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXR1cm4nXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLy8gJ2Zyb20nOiAwLFxuICAgICAgICAgICAgLy8gJ2NvdW50JzogMTAwMCxcbiAgICAgICAgICAgIC8vICdmcm9tX2lkJzogMCxcbiAgICAgICAgICAgIC8vICdlbmRfaWQnOiAxMDAwLFxuICAgICAgICAgICAgLy8gJ29yZGVyJzogJ0RFU0MnLFxuICAgICAgICAgICAgLy8gJ3NpbmNlJzogMTUwMzgyMTA1MSxcbiAgICAgICAgICAgIC8vICdlbmQnOiAxNTAzODIxMDUxLFxuICAgICAgICAgICAgLy8gJ2lzX3Rva2VuJzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnY3VycmVuY3lfcGFpciddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUhpc3RvcnkgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXR1cm4nXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdKUFknKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGRvZXMgbm90IGFsbG93ICcgKyBjdXJyZW5jeSArICcgd2l0aGRyYXdhbHMnKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgIC8vICdtZXNzYWdlJzogJ0hpIScsIC8vIFhFTSBvbmx5XG4gICAgICAgICAgICAvLyAnb3B0X2ZlZSc6IDAuMDAzLCAvLyBCVEMgYW5kIE1PTkEgb25seVxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXR1cm4nXVsndHhpZCddLFxuICAgICAgICAgICAgJ2ZlZSc6IHJlc3VsdFsncmV0dXJuJ11bJ2ZlZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLyc7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnYXBpLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXBpID09ICdmYXBpJykge1xuICAgICAgICAgICAgdXJsICs9ICdmYXBpLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGlmIChhcGkgPT0gJ2VjYXBpJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAnZWNhcGknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcGkgPT0gJ3RsYXBpJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAndGxhcGknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJ3RhcGknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAnYXBpJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHJlc3BvbnNlWydlcnJvciddKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHpiIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3piJyxcbiAgICAgICAgICAgICduYW1lJzogJ1pCJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMjg1OTE4Ny1jZDUyMTRmMC1jYTVlLTExZTctOTY3ZC05NjU2OGUyZTJiZDEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHA6Ly9hcGkuemIuY29tL2RhdGEnLCAvLyBubyBodHRwcyBmb3IgcHVibGljIEFQSVxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3RyYWRlLnpiLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3RyYWRlLnpiLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuemIuY29tL2kvZGV2ZWxvcGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrbGluZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRPcmRlcnNOZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVyc0lnbm9yZVRyYWRlVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VW5maW5pc2hlZE9yZGVyc0lnbm9yZVRyYWRlVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFVzZXJBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRXaXRoZHJhd0FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFdpdGhkcmF3UmVjb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDaGFyZ2VSZWNvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldENueVdpdGhkcmF3UmVjb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDbnlDaGFyZ2VSZWNvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0VHJhZGluZ0ZlZUZyb21CYXNlUXVvdGUgKGJhc2UsIHF1b3RlKSB7XG4gICAgICAgIC8vIGJhc2U6IHF1b3RlXG4gICAgICAgIGxldCBmZWVzID0ge1xuICAgICAgICAgICAgJ0JUQyc6IHsgJ1VTRFQnOiAwLjAgfSxcbiAgICAgICAgICAgICdCQ0gnOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ0xUQyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0VUSCc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0VUQyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0JUUyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMDAxIH0sXG4gICAgICAgICAgICAnRU9TJzogeyAnQlRDJzogMC4wMDEsICdVU0RUJzogMC4wMDEgfSxcbiAgICAgICAgICAgICdIU1InOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ1FUVU0nOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ1VTRFQnOiB7ICdCVEMnOiAwLjAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGJhc2UgaW4gZmVlcykge1xuICAgICAgICAgICAgbGV0IHF1b3RlRmVlcyA9IGZlZXNbYmFzZV07XG4gICAgICAgICAgICBpZiAocXVvdGUgaW4gcXVvdGVGZWVzKVxuICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZUZlZXNbcXVvdGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2lkXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2VJZCwgcXVvdGVJZCBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlSWQudG9VcHBlckNhc2UgKCkpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlSWQudG9VcHBlckNhc2UgKCkpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBmZWUgPSB0aGlzLmdldFRyYWRpbmdGZWVGcm9tQmFzZVF1b3RlIChiYXNlLCBxdW90ZSk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ2Ftb3VudFNjYWxlJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0WydwcmljZVNjYWxlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAgICAgJ3F1b3RlSWQnOiBxdW90ZUlkLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBmZWUsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogZmVlLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snYmFsYW5jZSddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydiYWxhbmNlJ11bY3VycmVuY3ldWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZXNbJ2Zyb3plbiddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydmcm96ZW4nXVtjdXJyZW5jeV1bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGdldE1hcmtldEZpZWxkTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiAnbWFya2V0JztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtYXJrZXRGaWVsZE5hbWUgPSB0aGlzLmdldE1hcmtldEZpZWxkTmFtZSAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdFttYXJrZXRGaWVsZE5hbWVdID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBiaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYXNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdiaWRzJyBpbiBvcmRlcmJvb2spXG4gICAgICAgICAgICBiaWRzID0gb3JkZXJib29rWydiaWRzJ107XG4gICAgICAgIGlmICgnYXNrcycgaW4gb3JkZXJib29rKVxuICAgICAgICAgICAgYXNrcyA9IG9yZGVyYm9va1snYXNrcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBiaWRzLFxuICAgICAgICAgICAgJ2Fza3MnOiBhc2tzLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdFsnYmlkcyddKVxuICAgICAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICBpZiAocmVzdWx0Wydhc2tzJ10pXG4gICAgICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWFya2V0RmllbGROYW1lID0gdGhpcy5nZXRNYXJrZXRGaWVsZE5hbWUgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3RbbWFya2V0RmllbGROYW1lXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3RyYWRlX3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1hcmtldEZpZWxkTmFtZSA9IHRoaXMuZ2V0TWFya2V0RmllbGROYW1lICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICByZXF1ZXN0W21hcmtldEZpZWxkTmFtZV0gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSAnJnByaWNlPScgKyBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZhbW91bnQ9JyArIGFtb3VudC50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHRyYWRlVHlwZSA9IChzaWRlID09ICdidXknKSA/ICcxJyA6ICcwJztcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZ0cmFkZVR5cGU9JyArIHRyYWRlVHlwZTtcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZjdXJyZW5jeT0nICsgdGhpcy5tYXJrZXRJZCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyIChwYXJhbVN0cmluZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBwYXJhbVN0cmluZyA9ICcmaWQ9JyArIGlkLnRvU3RyaW5nICgpO1xuICAgICAgICBpZiAoJ2N1cnJlbmN5JyBpbiBwYXJhbXMpXG4gICAgICAgICAgICBwYXJhbVN0cmluZyArPSAnJmN1cnJlbmN5PScgKyBwYXJhbXNbJ2N1cnJlbmN5J107XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHBhcmFtU3RyaW5nKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSAnJmlkPScgKyBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeScgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZjdXJyZW5jeT0nICsgcGFyYW1zWydjdXJyZW5jeSddO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldE9yZGVyIChwYXJhbVN0cmluZyk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgcGFyYW1zTGVuZ3RoID0gcGFyYW1zLmxlbmd0aDsgLy8gcGFyYW1zIHNob3VsZCBiZSBhIHN0cmluZyBoZXJlXG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnbWV0aG9kPScgKyBwYXRoO1xuICAgICAgICAgICAgYXV0aCArPSAnJmFjY2Vzc2tleT0nICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBhdXRoICs9IHBhcmFtc0xlbmd0aCA/IHBhcmFtcyA6ICcnO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTEnKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHNlY3JldCksICdtZDUnKTtcbiAgICAgICAgICAgIGxldCBzdWZmaXggPSAnc2lnbj0nICsgc2lnbmF0dXJlICsgJyZyZXFUaW1lPScgKyBub25jZS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyBwYXRoICsgJz8nICsgYXV0aCArICcmJyArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJylcbiAgICAgICAgICAgIGlmICgnY29kZScgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9ldnBrZGZcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVFbmNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlcn0gQSBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChrZXksIGNmZykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fREVDX1hGT1JNX01PREUsIGtleSwgY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcblx0ICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3MoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXG5cblx0ICAgICAgICBfREVDX1hGT1JNX01PREU6IDIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0oKSlcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDFcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19tb2RlID0gQy5tb2RlID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBkZWNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcblx0ICAgICAgICAgICAgdGhpcy5faXYgPSBpdjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkVuY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENCQyBkZWNyeXB0b3IuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBkYXRhIGJsb2NrIGF0IG9mZnNldC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cblx0ICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IHdoZXJlIHRoZSBibG9jayBzdGFydHMuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaXY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcblx0ICAgICAgICAgICAgQ2lwaGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gY2ZnLml2O1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLl9fY3JlYXRvciA9PSBtb2RlQ3JlYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5pbml0KHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG5cdCAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuXHQgICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG5cdCAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXG5cdCAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcblx0ICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcblx0ICAgICAgICAgICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWwgb2YgT2JqZWN0LmNyZWF0ZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fTtcblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uIChtX3cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtX3cgPSBtX3c7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXNrID0gMHhmZmZmZmZmZjtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgbV93ID0gKDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoKG1feiA8PCAweDEwKSArIG1fdykgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cblx0ICAgICAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghcmV2ZXJzZU1hcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXAgPSB0aGlzLl9yZXZlcnNlTWFwID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcFttYXAuY2hhckNvZGVBdChqKV0gPSBqO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NFN0ckxlbmd0aCA9IHBhZGRpbmdJbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XG5cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21hcDogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGExXCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcblx0ICAgICAqL1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXg7XG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcblxuXHQgICAgdmFyIEhleEZvcm1hdHRlciA9IENfZm9ybWF0LkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBITUFDIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoYXNoZXIsIGtleSkge1xuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICBoYXNoZXIgPSB0aGlzLl9oYXNoZXIgPSBuZXcgaGFzaGVyLmluaXQoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBVdGY4LnBhcnNlKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemVCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXG5cdCAgICAgICAgICAgIGlmIChrZXkuc2lnQnl0ZXMgPiBoYXNoZXJCbG9ja1NpemVCeXRlcykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gaGFzaGVyLmZpbmFsaXplKGtleSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBrZXkgZm9yIGlubmVyIGFuZCBvdXRlciBwYWRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB2YXIgaUtleSA9IHRoaXMuX2lLZXkgPSBrZXkuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIG9LZXlXb3JkcyA9IG9LZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpS2V5V29yZHMgPSBpS2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFhPUiBrZXlzIHdpdGggcGFkIGNvbnN0YW50c1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1Yztcblx0ICAgICAgICAgICAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgSE1BQyB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXRcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIGhhc2hlci51cGRhdGUodGhpcy5faUtleSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBITUFDIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBoYXNoZXIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChpbm5lckhhc2gpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaG1hYztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpLCByZXF1aXJlKFwiLi9saWItdHlwZWRhcnJheXNcIiksIHJlcXVpcmUoXCIuL2VuYy11dGYxNlwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9zaGEyNTZcIiksIHJlcXVpcmUoXCIuL3NoYTIyNFwiKSwgcmVxdWlyZShcIi4vc2hhNTEyXCIpLCByZXF1aXJlKFwiLi9zaGEzODRcIiksIHJlcXVpcmUoXCIuL3NoYTNcIiksIHJlcXVpcmUoXCIuL3JpcGVtZDE2MFwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSwgcmVxdWlyZShcIi4vcGJrZGYyXCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpLCByZXF1aXJlKFwiLi9tb2RlLWNmYlwiKSwgcmVxdWlyZShcIi4vbW9kZS1jdHJcIiksIHJlcXVpcmUoXCIuL21vZGUtY3RyLWdsYWRtYW5cIiksIHJlcXVpcmUoXCIuL21vZGUtb2ZiXCIpLCByZXF1aXJlKFwiLi9tb2RlLWVjYlwiKSwgcmVxdWlyZShcIi4vcGFkLWFuc2l4OTIzXCIpLCByZXF1aXJlKFwiLi9wYWQtaXNvMTAxMjZcIiksIHJlcXVpcmUoXCIuL3BhZC1pc285Nzk3MVwiKSwgcmVxdWlyZShcIi4vcGFkLXplcm9wYWRkaW5nXCIpLCByZXF1aXJlKFwiLi9wYWQtbm9wYWRkaW5nXCIpLCByZXF1aXJlKFwiLi9mb3JtYXQtaGV4XCIpLCByZXF1aXJlKFwiLi9hZXNcIiksIHJlcXVpcmUoXCIuL3RyaXBsZWRlc1wiKSwgcmVxdWlyZShcIi4vcmM0XCIpLCByZXF1aXJlKFwiLi9yYWJiaXRcIiksIHJlcXVpcmUoXCIuL3JhYmJpdC1sZWdhY3lcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIiwgXCIuL2xpYi10eXBlZGFycmF5c1wiLCBcIi4vZW5jLXV0ZjE2XCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL3NoYTFcIiwgXCIuL3NoYTI1NlwiLCBcIi4vc2hhMjI0XCIsIFwiLi9zaGE1MTJcIiwgXCIuL3NoYTM4NFwiLCBcIi4vc2hhM1wiLCBcIi4vcmlwZW1kMTYwXCIsIFwiLi9obWFjXCIsIFwiLi9wYmtkZjJcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIiwgXCIuL21vZGUtY2ZiXCIsIFwiLi9tb2RlLWN0clwiLCBcIi4vbW9kZS1jdHItZ2xhZG1hblwiLCBcIi4vbW9kZS1vZmJcIiwgXCIuL21vZGUtZWNiXCIsIFwiLi9wYWQtYW5zaXg5MjNcIiwgXCIuL3BhZC1pc28xMDEyNlwiLCBcIi4vcGFkLWlzbzk3OTcxXCIsIFwiLi9wYWQtemVyb3BhZGRpbmdcIiwgXCIuL3BhZC1ub3BhZGRpbmdcIiwgXCIuL2Zvcm1hdC1oZXhcIiwgXCIuL2Flc1wiLCBcIi4vdHJpcGxlZGVzXCIsIFwiLi9yYzRcIiwgXCIuL3JhYmJpdFwiLCBcIi4vcmFiYml0LWxlZ2FjeVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG5cdCAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLy8gUmVmZXJlbmNlIG9yaWdpbmFsIGluaXRcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcblxuXHQgICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0ICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBGZWVkYmFjayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DRkIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENGQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIENGQi5FbmNyeXB0b3IgPSBDRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cblx0ICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ0ZCLkRlY3J5cHRvciA9IENGQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcblxuXHQgICAgICAgICAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG5cdCAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0KHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gQ0ZCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ0ZCO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKiogQHByZXNlcnZlXG5cdCAqIENvdW50ZXIgYmxvY2sgbW9kZSBjb21wYXRpYmxlIHdpdGggIERyIEJyaWFuIEdsYWRtYW4gZmlsZWVuYy5jXG5cdCAqIGRlcml2ZWQgZnJvbSBDcnlwdG9KUy5tb2RlLkNUUlxuXHQgKiBKYW4gSHJ1YnkgamhydWJ5LndlYkBnbWFpbC5jb21cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ1RSR2xhZG1hbiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0XHRmdW5jdGlvbiBpbmNXb3JkKHdvcmQpXG5cdFx0e1xuXHRcdFx0aWYgKCgod29yZCA+PiAyNCkgJiAweGZmKSA9PT0gMHhmZikgeyAvL292ZXJmbG93XG5cdFx0XHR2YXIgYjEgPSAod29yZCA+PiAxNikmMHhmZjtcblx0XHRcdHZhciBiMiA9ICh3b3JkID4+IDgpJjB4ZmY7XG5cdFx0XHR2YXIgYjMgPSB3b3JkICYgMHhmZjtcblxuXHRcdFx0aWYgKGIxID09PSAweGZmKSAvLyBvdmVyZmxvdyBiMVxuXHRcdFx0e1xuXHRcdFx0YjEgPSAwO1xuXHRcdFx0aWYgKGIyID09PSAweGZmKVxuXHRcdFx0e1xuXHRcdFx0XHRiMiA9IDA7XG5cdFx0XHRcdGlmIChiMyA9PT0gMHhmZilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGIzID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQrK2IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdCsrYjI7XG5cdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHQrK2IxO1xuXHRcdFx0fVxuXG5cdFx0XHR3b3JkID0gMDtcblx0XHRcdHdvcmQgKz0gKGIxIDw8IDE2KTtcblx0XHRcdHdvcmQgKz0gKGIyIDw8IDgpO1xuXHRcdFx0d29yZCArPSBiMztcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdHdvcmQgKz0gKDB4MDEgPDwgMjQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHdvcmQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5jQ291bnRlcihjb3VudGVyKVxuXHRcdHtcblx0XHRcdGlmICgoY291bnRlclswXSA9IGluY1dvcmQoY291bnRlclswXSkpID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBlbmNyX2RhdGEgaW4gZmlsZWVuYy5jIGZyb20gIERyIEJyaWFuIEdsYWRtYW4ncyBjb3VudHMgb25seSB3aXRoIERXT1JEIGogPCA4XG5cdFx0XHRcdGNvdW50ZXJbMV0gPSBpbmNXb3JkKGNvdW50ZXJbMV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvdW50ZXI7XG5cdFx0fVxuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gQ1RSR2xhZG1hbi5FbmNyeXB0b3IgPSBDVFJHbGFkbWFuLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXG5cdFx0XHRcdGluY0NvdW50ZXIoY291bnRlcik7XG5cblx0XHRcdFx0dmFyIGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDVFJHbGFkbWFuLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIENUUkdsYWRtYW47XG5cdH0oKSk7XG5cblxuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSR2xhZG1hbjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENvdW50ZXIgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ1RSID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDVFIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gQ1RSLkVuY3J5cHRvciA9IENUUi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXIgPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlclxuXHQgICAgICAgICAgICBjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdID0gKGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gKyAxKSB8IDBcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDVFIuRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gQ1RSO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuQ1RSO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogRWxlY3Ryb25pYyBDb2RlYm9vayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5FQ0IgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIEVDQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIEVDQi5FbmNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIEVDQi5EZWNyeXB0b3IgPSBFQ0IuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBFQ0I7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5FQ0I7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBPdXRwdXQgRmVlZGJhY2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuT0ZCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBPRkIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICB2YXIgRW5jcnlwdG9yID0gT0ZCLkVuY3J5cHRvciA9IE9GQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgT0ZCLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIE9GQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLk9GQjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEFOU0kgWC45MjMgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5BbnNpWDkyMyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGFTaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSBsYXN0IGJ5dGUgcG9zaXRpb25cblx0ICAgICAgICB2YXIgbGFzdEJ5dGVQb3MgPSBkYXRhU2lnQnl0ZXMgKyBuUGFkZGluZ0J5dGVzIC0gMTtcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY2xhbXAoKTtcblx0ICAgICAgICBkYXRhLndvcmRzW2xhc3RCeXRlUG9zID4+PiAyXSB8PSBuUGFkZGluZ0J5dGVzIDw8ICgyNCAtIChsYXN0Qnl0ZVBvcyAlIDQpICogOCk7XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyArPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5BbnNpeDkyMztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIElTTyAxMDEyNiBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLklzbzEwMTI2ID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbShuUGFkZGluZ0J5dGVzIC0gMSkpLlxuXHQgICAgICAgICAgICAgY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtuUGFkZGluZ0J5dGVzIDw8IDI0XSwgMSkpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Jc28xMDEyNjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIElTTy9JRUMgOTc5Ny0xIFBhZGRpbmcgTWV0aG9kIDIuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuSXNvOTc5NzEgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBBZGQgMHg4MCBieXRlXG5cdCAgICAgICAgZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4ODAwMDAwMDBdLCAxKSk7XG5cblx0ICAgICAgICAvLyBaZXJvIHBhZCB0aGUgcmVzdFxuXHQgICAgICAgIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy5wYWQoZGF0YSwgYmxvY2tTaXplKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIFJlbW92ZSB6ZXJvIHBhZGRpbmdcblx0ICAgICAgICBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZGF0YSk7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgb25lIG1vcmUgYnl0ZSAtLSB0aGUgMHg4MCBieXRlXG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcy0tO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Jc285Nzk3MTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEEgbm9vcCBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLk5vUGFkZGluZyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKCkge1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogWmVybyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLlplcm9QYWRkaW5nID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jbGFtcCgpO1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcykgfHwgYmxvY2tTaXplQnl0ZXMpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgIC8vIFVucGFkXG5cdCAgICAgICAgdmFyIGkgPSBkYXRhLnNpZ0J5dGVzIC0gMTtcblx0ICAgICAgICB3aGlsZSAoISgoZGF0YVdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZikpIHtcblx0ICAgICAgICAgICAgaS0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzID0gaSArIDE7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMVwiLCBcIi4vaG1hY1wiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExO1xuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBCS0RGMiA9IENfYWxnby5QQktERjIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlLiBEZWZhdWx0OiBTSEExXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IFNIQTEsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IEhNQUNcblx0ICAgICAgICAgICAgdmFyIGhtYWMgPSBITUFDLmNyZWF0ZShjZmcuaGFzaGVyLCBwYXNzd29yZCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgIHZhciBibG9ja0luZGV4ID0gV29yZEFycmF5LmNyZWF0ZShbMHgwMDAwMDAwMV0pO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrSW5kZXhXb3JkcyA9IGJsb2NrSW5kZXgud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaG1hYy51cGRhdGUoc2FsdCkuZmluYWxpemUoYmxvY2tJbmRleCk7XG5cdCAgICAgICAgICAgICAgICBobWFjLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrV29yZHMgPSBibG9jay53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1dvcmRzTGVuZ3RoID0gYmxvY2tXb3Jkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGUgPSBibG9jaztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gaG1hYy5maW5hbGl6ZShpbnRlcm1lZGlhdGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGhtYWMucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZVdvcmRzID0gaW50ZXJtZWRpYXRlLndvcmRzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gWE9SIGludGVybWVkaWF0ZSB3aXRoIGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBibG9ja1dvcmRzTGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tXb3Jkc1tqXSBePSBpbnRlcm1lZGlhdGVXb3Jkc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIGJsb2NrSW5kZXhXb3Jkc1swXSsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuUEJLREYyID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gUEJLREYyLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5QQktERjI7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBTICA9IFtdO1xuXHQgICAgdmFyIENfID0gW107XG5cdCAgICB2YXIgRyAgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKlxuXHQgICAgICogVGhpcyBpcyBhIGxlZ2FjeSB2ZXJzaW9uIHRoYXQgbmVnbGVjdGVkIHRvIGNvbnZlcnQgdGhlIGtleSB0byBsaXR0bGUtZW5kaWFuLlxuXHQgICAgICogVGhpcyBlcnJvciBkb2Vzbid0IGFmZmVjdCB0aGUgY2lwaGVyJ3Mgc2VjdXJpdHksXG5cdCAgICAgKiBidXQgaXQgZG9lcyBhZmZlY3QgaXRzIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMuXG5cdCAgICAgKi9cblx0ICAgIHZhciBSYWJiaXRMZWdhY3kgPSBDX2FsZ28uUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBLID0gdGhpcy5fa2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLmNmZy5pdjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1ggPSBbXG5cdCAgICAgICAgICAgICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgQyA9IHRoaXMuX0MgPSBbXG5cdCAgICAgICAgICAgICAgICAoS1syXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLCAoS1swXSAmIDB4ZmZmZjAwMDApIHwgKEtbMV0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzNdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksIChLWzFdICYgMHhmZmZmMDAwMCkgfCAoS1syXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMF0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSwgKEtbMl0gJiAweGZmZmYwMDAwKSB8IChLWzNdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1sxXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLCAoS1szXSAmIDB4ZmZmZjAwMDApIHwgKEtbMF0gJiAweDAwMDBmZmZmKVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIENhcnJ5IGJpdFxuXHQgICAgICAgICAgICB0aGlzLl9iID0gMDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNvdW50ZXJzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBDW2ldIF49IFhbKGkgKyA0KSAmIDddO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSVYgc2V0dXBcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBJViA9IGl2LndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzAgPSBJVlswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8xID0gSVZbMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuXHQgICAgICAgICAgICAgICAgdmFyIGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMiA9ICgoKElWXzEgPDwgOCkgfCAoSVZfMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMSA8PCAyNCkgfCAoSVZfMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTEgPSAoaTAgPj4+IDE2KSB8IChpMiAmIDB4ZmZmZjAwMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkzID0gKGkyIDw8IDE2KSAgfCAoaTAgJiAweDAwMDBmZmZmKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICBDWzBdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1sxXSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbMl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzNdIF49IGkzO1xuXHQgICAgICAgICAgICAgICAgQ1s0XSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbNV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzZdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1s3XSBePSBpMztcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cblx0ICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcblx0ICAgICAgICAgICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzFdID0gWFsyXSBeIChYWzddID4+PiAxNikgXiAoWFs1XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMl0gPSBYWzRdIF4gKFhbMV0gPj4+IDE2KSBeIChYWzddIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgU1tpXSA9ICgoKFNbaV0gPDwgOCkgIHwgKFNbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoU1tpXSA8PCAyNCkgfCAoU1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgICAgICBNW29mZnNldCArIGldIF49IFNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gbmV4dFN0YXRlKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblx0ICAgICAgICB2YXIgQyA9IHRoaXMuX0M7XG5cblx0ICAgICAgICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIENfW2ldID0gQ1tpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcblx0ICAgICAgICBDWzFdID0gKENbMV0gKyAweGQzNGQzNGQzICsgKChDWzBdID4+PiAwKSA8IChDX1swXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzRdID0gKENbNF0gKyAweGQzNGQzNGQzICsgKChDWzNdID4+PiAwKSA8IChDX1szXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzddID0gKENbN10gKyAweGQzNGQzNGQzICsgKChDWzZdID4+PiAwKSA8IChDX1s2XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBneCA9IFhbaV0gKyBDW2ldO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnN0cnVjdCBoaWdoIGFuZCBsb3cgYXJndW1lbnQgZm9yIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnYSA9IGd4ICYgMHhmZmZmO1xuXHQgICAgICAgICAgICB2YXIgZ2IgPSBneCA+Pj4gMTY7XG5cblx0ICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcblx0ICAgICAgICAgICAgdmFyIGdsID0gKCgoZ3ggJiAweGZmZmYwMDAwKSAqIGd4KSB8IDApICsgKCgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4KSB8IDApO1xuXG5cdCAgICAgICAgICAgIC8vIEhpZ2ggWE9SIGxvd1xuXHQgICAgICAgICAgICBHW2ldID0gZ2ggXiBnbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHN0YXRlIHZhbHVlc1xuXHQgICAgICAgIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSAgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcblx0ICAgICAgICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzNdID0gKEdbM10gKyAoKEdbMl0gPDwgOCkgIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG5cdCAgICAgICAgWFs0XSA9IChHWzRdICsgKChHWzNdIDw8IDE2KSB8IChHWzNdID4+PiAxNikpICsgKChHWzJdIDw8IDE2KSB8IChHWzJdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpICB8IChHWzRdID4+PiAyNCkpICsgR1szXSkgfCAwO1xuXHQgICAgICAgIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSAgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUmFiYml0TGVnYWN5ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0TGVnYWN5KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SYWJiaXRMZWdhY3k7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBTICA9IFtdO1xuXHQgICAgdmFyIENfID0gW107XG5cdCAgICB2YXIgRyAgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSYWJiaXQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG1cblx0ICAgICAqL1xuXHQgICAgdmFyIFJhYmJpdCA9IENfYWxnby5SYWJiaXQgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEsgPSB0aGlzLl9rZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuY2ZnLml2O1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBLW2ldID0gKCgoS1tpXSA8PCA4KSAgfCAoS1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChLW2ldIDw8IDI0KSB8IChLW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1ggPSBbXG5cdCAgICAgICAgICAgICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgQyA9IHRoaXMuX0MgPSBbXG5cdCAgICAgICAgICAgICAgICAoS1syXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLCAoS1swXSAmIDB4ZmZmZjAwMDApIHwgKEtbMV0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzNdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksIChLWzFdICYgMHhmZmZmMDAwMCkgfCAoS1syXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMF0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSwgKEtbMl0gJiAweGZmZmYwMDAwKSB8IChLWzNdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1sxXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLCAoS1szXSAmIDB4ZmZmZjAwMDApIHwgKEtbMF0gJiAweDAwMDBmZmZmKVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIENhcnJ5IGJpdFxuXHQgICAgICAgICAgICB0aGlzLl9iID0gMDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNvdW50ZXJzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBDW2ldIF49IFhbKGkgKyA0KSAmIDddO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSVYgc2V0dXBcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBJViA9IGl2LndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzAgPSBJVlswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8xID0gSVZbMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuXHQgICAgICAgICAgICAgICAgdmFyIGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMiA9ICgoKElWXzEgPDwgOCkgfCAoSVZfMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMSA8PCAyNCkgfCAoSVZfMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTEgPSAoaTAgPj4+IDE2KSB8IChpMiAmIDB4ZmZmZjAwMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkzID0gKGkyIDw8IDE2KSAgfCAoaTAgJiAweDAwMDBmZmZmKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICBDWzBdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1sxXSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbMl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzNdIF49IGkzO1xuXHQgICAgICAgICAgICAgICAgQ1s0XSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbNV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzZdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1s3XSBePSBpMztcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblxuXHQgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cblx0ICAgICAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcblx0ICAgICAgICAgICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzFdID0gWFsyXSBeIChYWzddID4+PiAxNikgXiAoWFs1XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMl0gPSBYWzRdIF4gKFhbMV0gPj4+IDE2KSBeIChYWzddIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgU1tpXSA9ICgoKFNbaV0gPDwgOCkgIHwgKFNbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoU1tpXSA8PCAyNCkgfCAoU1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgICAgICBNW29mZnNldCArIGldIF49IFNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gbmV4dFN0YXRlKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBYID0gdGhpcy5fWDtcblx0ICAgICAgICB2YXIgQyA9IHRoaXMuX0M7XG5cblx0ICAgICAgICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIENfW2ldID0gQ1tpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcblx0ICAgICAgICBDWzFdID0gKENbMV0gKyAweGQzNGQzNGQzICsgKChDWzBdID4+PiAwKSA8IChDX1swXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzJdID0gKENbMl0gKyAweDM0ZDM0ZDM0ICsgKChDWzFdID4+PiAwKSA8IChDX1sxXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzRdID0gKENbNF0gKyAweGQzNGQzNGQzICsgKChDWzNdID4+PiAwKSA8IChDX1szXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzVdID0gKENbNV0gKyAweDM0ZDM0ZDM0ICsgKChDWzRdID4+PiAwKSA8IChDX1s0XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICBDWzddID0gKENbN10gKyAweGQzNGQzNGQzICsgKChDWzZdID4+PiAwKSA8IChDX1s2XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICB0aGlzLl9iID0gKENbN10gPj4+IDApIDwgKENfWzddID4+PiAwKSA/IDEgOiAwO1xuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBneCA9IFhbaV0gKyBDW2ldO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnN0cnVjdCBoaWdoIGFuZCBsb3cgYXJndW1lbnQgZm9yIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnYSA9IGd4ICYgMHhmZmZmO1xuXHQgICAgICAgICAgICB2YXIgZ2IgPSBneCA+Pj4gMTY7XG5cblx0ICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGhpZ2ggYW5kIGxvdyByZXN1bHQgb2Ygc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcblx0ICAgICAgICAgICAgdmFyIGdsID0gKCgoZ3ggJiAweGZmZmYwMDAwKSAqIGd4KSB8IDApICsgKCgoZ3ggJiAweDAwMDBmZmZmKSAqIGd4KSB8IDApO1xuXG5cdCAgICAgICAgICAgIC8vIEhpZ2ggWE9SIGxvd1xuXHQgICAgICAgICAgICBHW2ldID0gZ2ggXiBnbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IHN0YXRlIHZhbHVlc1xuXHQgICAgICAgIFhbMF0gPSAoR1swXSArICgoR1s3XSA8PCAxNikgfCAoR1s3XSA+Pj4gMTYpKSArICgoR1s2XSA8PCAxNikgfCAoR1s2XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSAgfCAoR1swXSA+Pj4gMjQpKSArIEdbN10pIHwgMDtcblx0ICAgICAgICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzNdID0gKEdbM10gKyAoKEdbMl0gPDwgOCkgIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG5cdCAgICAgICAgWFs0XSA9IChHWzRdICsgKChHWzNdIDw8IDE2KSB8IChHWzNdID4+PiAxNikpICsgKChHWzJdIDw8IDE2KSB8IChHWzJdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs1XSA9IChHWzVdICsgKChHWzRdIDw8IDgpICB8IChHWzRdID4+PiAyNCkpICsgR1szXSkgfCAwO1xuXHQgICAgICAgIFhbNl0gPSAoR1s2XSArICgoR1s1XSA8PCAxNikgfCAoR1s1XSA+Pj4gMTYpKSArICgoR1s0XSA8PCAxNikgfCAoR1s0XSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSAgfCAoR1s2XSA+Pj4gMjQpKSArIEdbNV0pIHwgMDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUmFiYml0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUmFiYml0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SYWJiaXQ7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUkM0ID0gQ19hbGdvLlJDNCA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaWdCeXRlcyA9IGtleS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBJbml0IHNib3hcblx0ICAgICAgICAgICAgdmFyIFMgPSB0aGlzLl9TID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIFNbaV0gPSBpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNldHVwXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qnl0ZUluZGV4ID0gaSAlIGtleVNpZ0J5dGVzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJ5dGUgPSAoa2V5V29yZHNba2V5Qnl0ZUluZGV4ID4+PiAyXSA+Pj4gKDI0IC0gKGtleUJ5dGVJbmRleCAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgaiA9IChqICsgU1tpXSArIGtleUJ5dGUpICUgMjU2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9IFNbaV07XG5cdCAgICAgICAgICAgICAgICBTW2ldID0gU1tqXTtcblx0ICAgICAgICAgICAgICAgIFNbal0gPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnRlcnNcblx0ICAgICAgICAgICAgdGhpcy5faSA9IHRoaXMuX2ogPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgTVtvZmZzZXRdIF49IGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbVdvcmQoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFMgPSB0aGlzLl9TO1xuXHQgICAgICAgIHZhciBpID0gdGhpcy5faTtcblx0ICAgICAgICB2YXIgaiA9IHRoaXMuX2o7XG5cblx0ICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW0gd29yZFxuXHQgICAgICAgIHZhciBrZXlzdHJlYW1Xb3JkID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7IG4rKykge1xuXHQgICAgICAgICAgICBpID0gKGkgKyAxKSAlIDI1Njtcblx0ICAgICAgICAgICAgaiA9IChqICsgU1tpXSkgJSAyNTY7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICB2YXIgdCA9IFNbaV07XG5cdCAgICAgICAgICAgIFNbaV0gPSBTW2pdO1xuXHQgICAgICAgICAgICBTW2pdID0gdDtcblxuXHQgICAgICAgICAgICBrZXlzdHJlYW1Xb3JkIHw9IFNbKFNbaV0gKyBTW2pdKSAlIDI1Nl0gPDwgKDI0IC0gbiAqIDgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFVwZGF0ZSBjb3VudGVyc1xuXHQgICAgICAgIHRoaXMuX2kgPSBpO1xuXHQgICAgICAgIHRoaXMuX2ogPSBqO1xuXG5cdCAgICAgICAgcmV0dXJuIGtleXN0cmVhbVdvcmQ7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJDNCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kaWZpZWQgUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUkM0RHJvcCA9IENfYWxnby5SQzREcm9wID0gUkM0LmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyb3AgVGhlIG51bWJlciBvZiBrZXlzdHJlYW0gd29yZHMgdG8gZHJvcC4gRGVmYXVsdCAxOTJcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFJDNC5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZHJvcDogMTkyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBSQzQuX2RvUmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBEcm9wXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNmZy5kcm9wOyBpID4gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJDNERyb3AuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzREcm9wLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJDNERyb3AgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzREcm9wKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SQzQ7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKiBAcHJlc2VydmVcblx0KGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblx0UmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG5cdCAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblx0ICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5cdFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblx0Ki9cblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBfemwgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuXHQgICAgICAgIDcsICA0LCAxMywgIDEsIDEwLCAgNiwgMTUsICAzLCAxMiwgIDAsICA5LCAgNSwgIDIsIDE0LCAxMSwgIDgsXG5cdCAgICAgICAgMywgMTAsIDE0LCAgNCwgIDksIDE1LCAgOCwgIDEsICAyLCAgNywgIDAsICA2LCAxMywgMTEsICA1LCAxMixcblx0ICAgICAgICAxLCAgOSwgMTEsIDEwLCAgMCwgIDgsIDEyLCAgNCwgMTMsICAzLCAgNywgMTUsIDE0LCAgNSwgIDYsICAyLFxuXHQgICAgICAgIDQsICAwLCAgNSwgIDksICA3LCAxMiwgIDIsIDEwLCAxNCwgIDEsICAzLCAgOCwgMTEsICA2LCAxNSwgMTNdKTtcblx0ICAgIHZhciBfenIgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICA1LCAxNCwgIDcsICAwLCAgOSwgIDIsIDExLCAgNCwgMTMsICA2LCAxNSwgIDgsICAxLCAxMCwgIDMsIDEyLFxuXHQgICAgICAgIDYsIDExLCAgMywgIDcsICAwLCAxMywgIDUsIDEwLCAxNCwgMTUsICA4LCAxMiwgIDQsICA5LCAgMSwgIDIsXG5cdCAgICAgICAgMTUsICA1LCAgMSwgIDMsICA3LCAxNCwgIDYsICA5LCAxMSwgIDgsIDEyLCAgMiwgMTAsICAwLCAgNCwgMTMsXG5cdCAgICAgICAgOCwgIDYsICA0LCAgMSwgIDMsIDExLCAxNSwgIDAsICA1LCAxMiwgIDIsIDEzLCAgOSwgIDcsIDEwLCAxNCxcblx0ICAgICAgICAxMiwgMTUsIDEwLCAgNCwgIDEsICA1LCAgOCwgIDcsICA2LCAgMiwgMTMsIDE0LCAgMCwgIDMsICA5LCAxMV0pO1xuXHQgICAgdmFyIF9zbCA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAxMSwgMTQsIDE1LCAxMiwgIDUsICA4LCAgNywgIDksIDExLCAxMywgMTQsIDE1LCAgNiwgIDcsICA5LCAgOCxcblx0ICAgICAgICA3LCA2LCAgIDgsIDEzLCAxMSwgIDksICA3LCAxNSwgIDcsIDEyLCAxNSwgIDksIDExLCAgNywgMTMsIDEyLFxuXHQgICAgICAgIDExLCAxMywgIDYsICA3LCAxNCwgIDksIDEzLCAxNSwgMTQsICA4LCAxMywgIDYsICA1LCAxMiwgIDcsICA1LFxuXHQgICAgICAgICAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgIDksICA4LCAgOSwgMTQsICA1LCAgNiwgIDgsICA2LCAgNSwgMTIsXG5cdCAgICAgICAgOSwgMTUsICA1LCAxMSwgIDYsICA4LCAxMywgMTIsICA1LCAxMiwgMTMsIDE0LCAxMSwgIDgsICA1LCAgNiBdKTtcblx0ICAgIHZhciBfc3IgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICA4LCAgOSwgIDksIDExLCAxMywgMTUsIDE1LCAgNSwgIDcsICA3LCAgOCwgMTEsIDE0LCAxNCwgMTIsICA2LFxuXHQgICAgICAgIDksIDEzLCAxNSwgIDcsIDEyLCAgOCwgIDksIDExLCAgNywgIDcsIDEyLCAgNywgIDYsIDE1LCAxMywgMTEsXG5cdCAgICAgICAgOSwgIDcsIDE1LCAxMSwgIDgsICA2LCAgNiwgMTQsIDEyLCAxMywgIDUsIDE0LCAxMywgMTMsICA3LCAgNSxcblx0ICAgICAgICAxNSwgIDUsICA4LCAxMSwgMTQsIDE0LCAgNiwgMTQsICA2LCAgOSwgMTIsICA5LCAxMiwgIDUsIDE1LCAgOCxcblx0ICAgICAgICA4LCAgNSwgMTIsICA5LCAxMiwgIDUsIDE0LCAgNiwgIDgsIDEzLCAgNiwgIDUsIDE1LCAxMywgMTEsIDExIF0pO1xuXG5cdCAgICB2YXIgX2hsID0gIFdvcmRBcnJheS5jcmVhdGUoWyAweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXSk7XG5cdCAgICB2YXIgX2hyID0gIFdvcmRBcnJheS5jcmVhdGUoWyAweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUklQRU1EMTYwIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUklQRU1EMTYwID0gQ19hbGdvLlJJUEVNRDE2MCA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggID0gV29yZEFycmF5LmNyZWF0ZShbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIICA9IHRoaXMuX2hhc2gud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBobCA9IF9obC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGhyID0gX2hyLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgemwgPSBfemwud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB6ciA9IF96ci53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNsID0gX3NsLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc3IgPSBfc3Iud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbDtcblx0ICAgICAgICAgICAgdmFyIGFyLCBiciwgY3IsIGRyLCBlcjtcblxuXHQgICAgICAgICAgICBhciA9IGFsID0gSFswXTtcblx0ICAgICAgICAgICAgYnIgPSBibCA9IEhbMV07XG5cdCAgICAgICAgICAgIGNyID0gY2wgPSBIWzJdO1xuXHQgICAgICAgICAgICBkciA9IGRsID0gSFszXTtcblx0ICAgICAgICAgICAgZXIgPSBlbCA9IEhbNF07XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIHZhciB0O1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgIHQgPSAoYWwgKyAgTVtvZmZzZXQremxbaV1dKXwwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGk8MTYpe1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYxKGJsLGNsLGRsKSArIGhsWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDMyKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjIoYmwsY2wsZGwpICsgaGxbMV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NDgpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMyhibCxjbCxkbCkgKyBobFsyXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY0KGJsLGNsLGRsKSArIGhsWzNdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY1KGJsLGNsLGRsKSArIGhsWzRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdCA9IHR8MDtcblx0ICAgICAgICAgICAgICAgIHQgPSAgcm90bCh0LHNsW2ldKTtcblx0ICAgICAgICAgICAgICAgIHQgPSAodCtlbCl8MDtcblx0ICAgICAgICAgICAgICAgIGFsID0gZWw7XG5cdCAgICAgICAgICAgICAgICBlbCA9IGRsO1xuXHQgICAgICAgICAgICAgICAgZGwgPSByb3RsKGNsLCAxMCk7XG5cdCAgICAgICAgICAgICAgICBjbCA9IGJsO1xuXHQgICAgICAgICAgICAgICAgYmwgPSB0O1xuXG5cdCAgICAgICAgICAgICAgICB0ID0gKGFyICsgTVtvZmZzZXQrenJbaV1dKXwwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGk8MTYpe1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY1KGJyLGNyLGRyKSArIGhyWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDMyKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjQoYnIsY3IsZHIpICsgaHJbMV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NDgpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMyhicixjcixkcikgKyBoclsyXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYyKGJyLGNyLGRyKSArIGhyWzNdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYxKGJyLGNyLGRyKSArIGhyWzRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdCA9IHR8MDtcblx0ICAgICAgICAgICAgICAgIHQgPSAgcm90bCh0LHNyW2ldKSA7XG5cdCAgICAgICAgICAgICAgICB0ID0gKHQrZXIpfDA7XG5cdCAgICAgICAgICAgICAgICBhciA9IGVyO1xuXHQgICAgICAgICAgICAgICAgZXIgPSBkcjtcblx0ICAgICAgICAgICAgICAgIGRyID0gcm90bChjciwgMTApO1xuXHQgICAgICAgICAgICAgICAgY3IgPSBicjtcblx0ICAgICAgICAgICAgICAgIGJyID0gdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICB0ICAgID0gKEhbMV0gKyBjbCArIGRyKXwwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKXwwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbM10gKyBlbCArIGFyKXwwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKXwwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbMF0gKyBibCArIGNyKXwwO1xuXHQgICAgICAgICAgICBIWzBdID0gIHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsIDw8IDgpICB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbCA8PCAyNCkgfCAobkJpdHNUb3RhbCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblxuXHQgICAgZnVuY3Rpb24gZjEoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKTtcblxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmMih4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpJih5KSkgfCAoKH54KSYoeikpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjMoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmNCh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkmKH4oeikpKSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGY1KHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCh4KSBeICgoeSkgfCh+KHopKSkpO1xuXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHJvdGwoeCxuKSB7XG5cdCAgICAgICAgcmV0dXJuICh4PDxuKSB8ICh4Pj4+KDMyLW4pKTtcblx0ICAgIH1cblxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5SSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihSSVBFTUQxNjApO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1JJUEVNRDE2MChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoUklQRU1EMTYwKTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUklQRU1EMTYwO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMjU2XCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTI1NlwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjI0IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjI0ID0gQ19hbGdvLlNIQTIyNCA9IFNIQTI1Ni5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSxcblx0ICAgICAgICAgICAgICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTRcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gU0hBMjU2Ll9kb0ZpbmFsaXplLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgaGFzaC5zaWdCeXRlcyAtPSA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyMjQod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyMjQgPSBTSEEyNTYuX2NyZWF0ZUhlbHBlcihTSEEyMjQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTIyNChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyMjQgPSBTSEEyNTYuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjI0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyMjQ7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBSSE9fT0ZGU0VUUyA9IFtdO1xuXHQgICAgdmFyIFBJX0lOREVYRVMgID0gW107XG5cdCAgICB2YXIgUk9VTkRfQ09OU1RBTlRTID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgQ29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgcmhvIG9mZnNldCBjb25zdGFudHNcblx0ICAgICAgICB2YXIgeCA9IDEsIHkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuXHQgICAgICAgICAgICBSSE9fT0ZGU0VUU1t4ICsgNSAqIHldID0gKCh0ICsgMSkgKiAodCArIDIpIC8gMikgJSA2NDtcblxuXHQgICAgICAgICAgICB2YXIgbmV3WCA9IHkgJSA1O1xuXHQgICAgICAgICAgICB2YXIgbmV3WSA9ICgyICogeCArIDMgKiB5KSAlIDU7XG5cdCAgICAgICAgICAgIHggPSBuZXdYO1xuXHQgICAgICAgICAgICB5ID0gbmV3WTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb21wdXRlIHBpIGluZGV4IGNvbnN0YW50c1xuXHQgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICBQSV9JTkRFWEVTW3ggKyA1ICogeV0gPSB5ICsgKCgyICogeCArIDMgKiB5KSAlIDUpICogNTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbXB1dGUgcm91bmQgY29uc3RhbnRzXG5cdCAgICAgICAgdmFyIExGU1IgPSAweDAxO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudE1zdyA9IDA7XG5cdCAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50THN3ID0gMDtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDc7IGorKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKExGU1IgJiAweDAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJpdFBvc2l0aW9uID0gKDEgPDwgaikgLSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3NpdGlvbiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQ29uc3RhbnRMc3cgXj0gMSA8PCBiaXRQb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGJpdFBvc2l0aW9uID49IDMyKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kQ29uc3RhbnRNc3cgXj0gMSA8PCAoYml0UG9zaXRpb24gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgTEZTUlxuXHQgICAgICAgICAgICAgICAgaWYgKExGU1IgJiAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIHBvbHlub21pYWwgb3ZlciBHRigyKTogeF44ICsgeF42ICsgeF41ICsgeF40ICsgMVxuXHQgICAgICAgICAgICAgICAgICAgIExGU1IgPSAoTEZTUiA8PCAxKSBeIDB4NzE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIExGU1IgPDw9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBST1VORF9DT05TVEFOVFNbaV0gPSBYNjRXb3JkLmNyZWF0ZShyb3VuZENvbnN0YW50TXN3LCByb3VuZENvbnN0YW50THN3KTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzIGZvciB0ZW1wb3JhcnkgdmFsdWVzXG5cdCAgICB2YXIgVCA9IFtdO1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IFg2NFdvcmQuY3JlYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMyBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTMgPSBDX2FsZ28uU0hBMyA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvdXRwdXRMZW5ndGhcblx0ICAgICAgICAgKiAgIFRoZSBkZXNpcmVkIG51bWJlciBvZiBiaXRzIGluIHRoZSBvdXRwdXQgaGFzaC5cblx0ICAgICAgICAgKiAgIE9ubHkgdmFsdWVzIHBlcm1pdHRlZCBhcmU6IDIyNCwgMjU2LCAzODQsIDUxMi5cblx0ICAgICAgICAgKiAgIERlZmF1bHQ6IDUxMlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogSGFzaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBvdXRwdXRMZW5ndGg6IDUxMlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGUgPSBbXVxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlW2ldID0gbmV3IFg2NFdvcmQuaW5pdCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5ibG9ja1NpemUgPSAoMTYwMCAtIDIgKiB0aGlzLmNmZy5vdXRwdXRMZW5ndGgpIC8gMzI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tTaXplTGFuZXMgPSB0aGlzLmJsb2NrU2l6ZSAvIDI7XG5cblx0ICAgICAgICAgICAgLy8gQWJzb3JiXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJsb2NrU2l6ZUxhbmVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIE0yaSAgPSBNW29mZnNldCArIDIgKiBpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBNMmkxID0gTVtvZmZzZXQgKyAyICogaSArIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgTTJpID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaSA8PCA4KSAgfCAoTTJpID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaSA8PCAyNCkgfCAoTTJpID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICBNMmkxID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaTEgPDwgOCkgIHwgKE0yaTEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpMSA8PCAyNCkgfCAoTTJpMSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBYnNvcmIgbWVzc2FnZSBpbnRvIHN0YXRlXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2ldO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IE0yaTE7XG5cdCAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gTTJpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhldGFcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWl4IGNvbHVtbiBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gMCwgdExzdyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0TXN3IF49IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdExzdyBePSBsYW5lLmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFsdWVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4ID0gVFt4XTtcblx0ICAgICAgICAgICAgICAgICAgICBUeC5oaWdoID0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICBUeC5sb3cgID0gdExzdztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4NCA9IFRbKHggKyA0KSAlIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDEgPSBUWyh4ICsgMSkgJSA1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTXN3ID0gVHgxLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MUxzdyA9IFR4MS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBNaXggc3Vycm91bmRpbmcgY29sdW1uc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gVHg0LmhpZ2ggXiAoKFR4MU1zdyA8PCAxKSB8IChUeDFMc3cgPj4+IDMxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSBUeDQubG93ICBeICgoVHgxTHN3IDw8IDEpIHwgKFR4MU1zdyA+Pj4gMzEpKTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gdExzdztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJobyBQaVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgbGFuZUluZGV4ID0gMTsgbGFuZUluZGV4IDwgMjU7IGxhbmVJbmRleCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJob09mZnNldCA9IFJIT19PRkZTRVRTW2xhbmVJbmRleF07XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGUgbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmhvT2Zmc2V0IDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAobGFuZU1zdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVMc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IChsYW5lTHN3IDw8IHJob09mZnNldCkgfCAobGFuZU1zdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChyaG9PZmZzZXQgPj0gMzIpICovIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAobGFuZUxzdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTXN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSAobGFuZU1zdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTHN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc3Bvc2UgbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVFBpTGFuZSA9IFRbUElfSU5ERVhFU1tsYW5lSW5kZXhdXTtcblx0ICAgICAgICAgICAgICAgICAgICBUUGlMYW5lLmhpZ2ggPSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgIFRQaUxhbmUubG93ICA9IHRMc3c7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJobyBwaSBhdCB4ID0geSA9IDBcblx0ICAgICAgICAgICAgICAgIHZhciBUMCA9IFRbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhdGUwID0gc3RhdGVbMF07XG5cdCAgICAgICAgICAgICAgICBUMC5oaWdoID0gc3RhdGUwLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICBUMC5sb3cgID0gc3RhdGUwLmxvdztcblxuXHQgICAgICAgICAgICAgICAgLy8gQ2hpXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZUluZGV4ID0geCArIDUgKiB5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUTGFuZSA9IFRbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFR4MUxhbmUgPSBUWygoeCArIDEpICUgNSkgKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUeDJMYW5lID0gVFsoKHggKyAyKSAlIDUpICsgNSAqIHldO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCByb3dzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUuaGlnaCA9IFRMYW5lLmhpZ2ggXiAoflR4MUxhbmUuaGlnaCAmIFR4MkxhbmUuaGlnaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUubG93ICA9IFRMYW5lLmxvdyAgXiAoflR4MUxhbmUubG93ICAmIFR4MkxhbmUubG93KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElvdGFcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudCA9IFJPVU5EX0NPTlNUQU5UU1tyb3VuZF07XG5cdCAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gcm91bmRDb25zdGFudC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IHJvdW5kQ29uc3RhbnQubG93Oztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQml0cyA9IHRoaXMuYmxvY2tTaXplICogMzI7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHgxIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cykgPj4+IDUpIC0gMV0gfD0gMHg4MDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRMZW5ndGhCeXRlcyA9IHRoaXMuY2ZnLm91dHB1dExlbmd0aCAvIDg7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRMZW5ndGhMYW5lcyA9IG91dHB1dExlbmd0aEJ5dGVzIC8gODtcblxuXHQgICAgICAgICAgICAvLyBTcXVlZXplXG5cdCAgICAgICAgICAgIHZhciBoYXNoV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGhMYW5lczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZU1zdyA9IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBsYW5lTXN3ID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVNc3cgPDwgOCkgIHwgKGxhbmVNc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZU1zdyA8PCAyNCkgfCAobGFuZU1zdyA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgbGFuZUxzdyA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTHN3IDw8IDgpICB8IChsYW5lTHN3ID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVMc3cgPDwgMjQpIHwgKGxhbmVMc3cgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3F1ZWV6ZSBzdGF0ZSB0byByZXRyaWV2ZSBoYXNoXG5cdCAgICAgICAgICAgICAgICBoYXNoV29yZHMucHVzaChsYW5lTHN3KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVNc3cpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChoYXNoV29yZHMsIG91dHB1dExlbmd0aEJ5dGVzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgdmFyIHN0YXRlID0gY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGUuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgc3RhdGVbaV0gPSBzdGF0ZVtpXS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMygnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMyh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTMgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEzKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTMgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMyk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTUxMlwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiLCBcIi4vc2hhNTEyXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEE1MTIgPSBDX2FsZ28uU0hBNTEyO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0zODQgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEzODQgPSBDX2FsZ28uU0hBMzg0ID0gU0hBNTEyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgpLCBuZXcgWDY0V29yZC5pbml0KDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDkxNTkwMTVhLCAweDMwNzBkZDE3KSwgbmV3IFg2NFdvcmQuaW5pdCgweDE1MmZlY2Q4LCAweGY3MGU1OTM5KSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg2NzMzMjY2NywgMHhmZmMwMGIzMSksIG5ldyBYNjRXb3JkLmluaXQoMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcpLCBuZXcgWDY0V29yZC5pbml0KDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQpXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IFNIQTUxMi5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIGhhc2guc2lnQnl0ZXMgLT0gMTY7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTM4NCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTM4NCA9IFNIQTUxMi5fY3JlYXRlSGVscGVyKFNIQTM4NCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMzg0KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTM4NCA9IFNIQTUxMi5fY3JlYXRlSG1hY0hlbHBlcihTSEEzODQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTM4NDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIGZ1bmN0aW9uIFg2NFdvcmRfY3JlYXRlKCkge1xuXHQgICAgICAgIHJldHVybiBYNjRXb3JkLmNyZWF0ZS5hcHBseShYNjRXb3JkLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb25zdGFudHNcblx0ICAgIHZhciBLID0gW1xuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIpLCBYNjRXb3JkX2NyZWF0ZSgweDcxMzc0NDkxLCAweDIzZWY2NWNkKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGI1YzBmYmNmLCAweGVjNGQzYjJmKSwgWDY0V29yZF9jcmVhdGUoMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksIFg2NFdvcmRfY3JlYXRlKDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIpLCBYNjRXb3JkX2NyZWF0ZSgweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGQ4MDdhYTk4LCAweGEzMDMwMjQyKSwgWDY0V29yZF9jcmVhdGUoMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksIFg2NFdvcmRfY3JlYXRlKDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYpLCBYNjRXb3JkX2NyZWF0ZSgweDgwZGViMWZlLCAweDNiMTY5NmIxKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDliZGMwNmE3LCAweDI1YzcxMjM1KSwgWDY0V29yZF9jcmVhdGUoMHhjMTliZjE3NCwgMHhjZjY5MjY5NCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksIFg2NFdvcmRfY3JlYXRlKDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUpLCBYNjRXb3JkX2NyZWF0ZSgweDI0MGNhMWNjLCAweDc3YWM5YzY1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDJkZTkyYzZmLCAweDU5MmIwMjc1KSwgWDY0V29yZF9jcmVhdGUoMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksIFg2NFdvcmRfY3JlYXRlKDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIpLCBYNjRXb3JkX2NyZWF0ZSgweGE4MzFjNjZkLCAweDJkYjQzMjEwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGIwMDMyN2M4LCAweDk4ZmIyMTNmKSwgWDY0V29yZF9jcmVhdGUoMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksIFg2NFdvcmRfY3JlYXRlKDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYpLCBYNjRXb3JkX2NyZWF0ZSgweDE0MjkyOTY3LCAweDBhMGU2ZTcwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI3YjcwYTg1LCAweDQ2ZDIyZmZjKSwgWDY0V29yZF9jcmVhdGUoMHgyZTFiMjEzOCwgMHg1YzI2YzkyNiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksIFg2NFdvcmRfY3JlYXRlKDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NjUwYTczNTQsIDB4OGJhZjYzZGUpLCBYNjRXb3JkX2NyZWF0ZSgweDc2NmEwYWJiLCAweDNjNzdiMmE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDgxYzJjOTJlLCAweDQ3ZWRhZWU2KSwgWDY0V29yZF9jcmVhdGUoMHg5MjcyMmM4NSwgMHgxNDgyMzUzYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksIFg2NFdvcmRfY3JlYXRlKDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEpLCBYNjRXb3JkX2NyZWF0ZSgweGM3NmM1MWEzLCAweDA2NTRiZTMwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGQxOTJlODE5LCAweGQ2ZWY1MjE4KSwgWDY0V29yZF9jcmVhdGUoMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksIFg2NFdvcmRfY3JlYXRlKDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgpLCBYNjRXb3JkX2NyZWF0ZSgweDFlMzc2YzA4LCAweDUxNDFhYjUzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI3NDg3NzRjLCAweGRmOGVlYjk5KSwgWDY0V29yZF9jcmVhdGUoMHgzNGIwYmNiNSwgMHhlMTliNDhhOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksIFg2NFdvcmRfY3JlYXRlKDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMpLCBYNjRXb3JkX2NyZWF0ZSgweDY4MmU2ZmYzLCAweGQ2YjJiOGEzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDc0OGY4MmVlLCAweDVkZWZiMmZjKSwgWDY0V29yZF9jcmVhdGUoMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksIFg2NFdvcmRfY3JlYXRlKDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgpLCBYNjRXb3JkX2NyZWF0ZSgweGE0NTA2Y2ViLCAweGRlODJiZGU5KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGJlZjlhM2Y3LCAweGIyYzY3OTE1KSwgWDY0V29yZF9jcmVhdGUoMHhjNjcxNzhmMiwgMHhlMzcyNTMyYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksIFg2NFdvcmRfY3JlYXRlKDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUpLCBYNjRXb3JkX2NyZWF0ZSgweGY1N2Q0ZjdmLCAweGVlNmVkMTc4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDA2ZjA2N2FhLCAweDcyMTc2ZmJhKSwgWDY0V29yZF9jcmVhdGUoMHgwYTYzN2RjNSwgMHhhMmM4OThhNiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksIFg2NFdvcmRfY3JlYXRlKDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQpLCBYNjRXb3JkX2NyZWF0ZSgweDMyY2FhYjdiLCAweDQwYzcyNDkzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDNjOWViZTBhLCAweDE1YzliZWJjKSwgWDY0V29yZF9jcmVhdGUoMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksIFg2NFdvcmRfY3JlYXRlKDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMpLCBYNjRXb3JkX2NyZWF0ZSgweDZjNDQxOThjLCAweDRhNDc1ODE3KVxuXHQgICAgXTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFcgPSBbXTtcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFdbaV0gPSBYNjRXb3JkX2NyZWF0ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTUxMiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTIgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCksIG5ldyBYNjRXb3JkLmluaXQoMHhiYjY3YWU4NSwgMHg4NGNhYTczYiksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIpLCBuZXcgWDY0V29yZC5pbml0KDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDUxMGU1MjdmLCAweGFkZTY4MmQxKSwgbmV3IFg2NFdvcmQuaW5pdCgweDliMDU2ODhjLCAweDJiM2U2YzFmKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiksIG5ldyBYNjRXb3JkLmluaXQoMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSlcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBIMCA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBIMSA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBIMiA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBIMyA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBINCA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBINSA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBINiA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBINyA9IEhbN107XG5cblx0ICAgICAgICAgICAgdmFyIEgwaCA9IEgwLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMGwgPSBIMC5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIMWggPSBIMS5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDFsID0gSDEubG93O1xuXHQgICAgICAgICAgICB2YXIgSDJoID0gSDIuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgybCA9IEgyLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgzaCA9IEgzLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIM2wgPSBIMy5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINGggPSBINC5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDRsID0gSDQubG93O1xuXHQgICAgICAgICAgICB2YXIgSDVoID0gSDUuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg1bCA9IEg1Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg2aCA9IEg2LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINmwgPSBINi5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIN2ggPSBINy5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDdsID0gSDcubG93O1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhaCA9IEgwaDtcblx0ICAgICAgICAgICAgdmFyIGFsID0gSDBsO1xuXHQgICAgICAgICAgICB2YXIgYmggPSBIMWg7XG5cdCAgICAgICAgICAgIHZhciBibCA9IEgxbDtcblx0ICAgICAgICAgICAgdmFyIGNoID0gSDJoO1xuXHQgICAgICAgICAgICB2YXIgY2wgPSBIMmw7XG5cdCAgICAgICAgICAgIHZhciBkaCA9IEgzaDtcblx0ICAgICAgICAgICAgdmFyIGRsID0gSDNsO1xuXHQgICAgICAgICAgICB2YXIgZWggPSBINGg7XG5cdCAgICAgICAgICAgIHZhciBlbCA9IEg0bDtcblx0ICAgICAgICAgICAgdmFyIGZoID0gSDVoO1xuXHQgICAgICAgICAgICB2YXIgZmwgPSBINWw7XG5cdCAgICAgICAgICAgIHZhciBnaCA9IEg2aDtcblx0ICAgICAgICAgICAgdmFyIGdsID0gSDZsO1xuXHQgICAgICAgICAgICB2YXIgaGggPSBIN2g7XG5cdCAgICAgICAgICAgIHZhciBobCA9IEg3bDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIFdpID0gV1tpXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIG1lc3NhZ2Vcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2kuaGlnaCA9IE1bb2Zmc2V0ICsgaSAqIDJdICAgICB8IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpLmxvdyAgPSBNW29mZnNldCArIGkgKiAyICsgMV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBHYW1tYTBcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCAgPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHhoID0gZ2FtbWEweC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4bCA9IGdhbW1hMHgubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTBoICA9ICgoZ2FtbWEweGggPj4+IDEpIHwgKGdhbW1hMHhsIDw8IDMxKSkgXiAoKGdhbW1hMHhoID4+PiA4KSB8IChnYW1tYTB4bCA8PCAyNCkpIF4gKGdhbW1hMHhoID4+PiA3KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwbCAgPSAoKGdhbW1hMHhsID4+PiAxKSB8IChnYW1tYTB4aCA8PCAzMSkpIF4gKChnYW1tYTB4bCA+Pj4gOCkgfCAoZ2FtbWEweGggPDwgMjQpKSBeICgoZ2FtbWEweGwgPj4+IDcpIHwgKGdhbW1hMHhoIDw8IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBHYW1tYTFcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCAgPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeGggPSBnYW1tYTF4LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXhsID0gZ2FtbWExeC5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMWggID0gKChnYW1tYTF4aCA+Pj4gMTkpIHwgKGdhbW1hMXhsIDw8IDEzKSkgXiAoKGdhbW1hMXhoIDw8IDMpIHwgKGdhbW1hMXhsID4+PiAyOSkpIF4gKGdhbW1hMXhoID4+PiA2KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExbCAgPSAoKGdhbW1hMXhsID4+PiAxOSkgfCAoZ2FtbWExeGggPDwgMTMpKSBeICgoZ2FtbWExeGwgPDwgMykgfCAoZ2FtbWExeGggPj4+IDI5KSkgXiAoKGdhbW1hMXhsID4+PiA2KSB8IChnYW1tYTF4aCA8PCAyNikpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpNyAgPSBXW2kgLSA3XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3aCA9IFdpNy5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTdsID0gV2k3LmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2ICA9IFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNmggPSBXaTE2LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTZsID0gV2kxNi5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gZ2FtbWEwbCArIFdpN2w7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IGdhbW1hMGggKyBXaTdoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaWwgKyBnYW1tYTFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaWggKyBnYW1tYTFoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaWwgKyBXaTE2bDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2loICsgV2kxNmggKyAoKFdpbCA+Pj4gMCkgPCAoV2kxNmwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV2kuaGlnaCA9IFdpaDtcblx0ICAgICAgICAgICAgICAgICAgICBXaS5sb3cgID0gV2lsO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2hoICA9IChlaCAmIGZoKSBeICh+ZWggJiBnaCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hsICA9IChlbCAmIGZsKSBeICh+ZWwgJiBnbCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqaCA9IChhaCAmIGJoKSBeIChhaCAmIGNoKSBeIChiaCAmIGNoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWpsID0gKGFsICYgYmwpIF4gKGFsICYgY2wpIF4gKGJsICYgY2wpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwaCA9ICgoYWggPj4+IDI4KSB8IChhbCA8PCA0KSkgIF4gKChhaCA8PCAzMCkgIHwgKGFsID4+PiAyKSkgXiAoKGFoIDw8IDI1KSB8IChhbCA+Pj4gNykpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMGwgPSAoKGFsID4+PiAyOCkgfCAoYWggPDwgNCkpICBeICgoYWwgPDwgMzApICB8IChhaCA+Pj4gMikpIF4gKChhbCA8PCAyNSkgfCAoYWggPj4+IDcpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTFoID0gKChlaCA+Pj4gMTQpIHwgKGVsIDw8IDE4KSkgXiAoKGVoID4+PiAxOCkgfCAoZWwgPDwgMTQpKSBeICgoZWggPDwgMjMpIHwgKGVsID4+PiA5KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExbCA9ICgoZWwgPj4+IDE0KSB8IChlaCA8PCAxOCkpIF4gKChlbCA+Pj4gMTgpIHwgKGVoIDw8IDE0KSkgXiAoKGVsIDw8IDIzKSB8IChlaCA+Pj4gOSkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldXG5cdCAgICAgICAgICAgICAgICB2YXIgS2kgID0gS1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBLaWggPSBLaS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgdmFyIEtpbCA9IEtpLmxvdztcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IGhsICsgc2lnbWExbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSBoaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIGNobDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBjaGggKyAoKHQxbCA+Pj4gMCkgPCAoY2hsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBLaWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgS2loICsgKCh0MWwgPj4+IDApIDwgKEtpbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgV2lsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIFdpaCArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuXHQgICAgICAgICAgICAgICAgdmFyIHQybCA9IHNpZ21hMGwgKyBtYWpsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyaCA9IHNpZ21hMGggKyBtYWpoICsgKCh0MmwgPj4+IDApIDwgKHNpZ21hMGwgPj4+IDApID8gMSA6IDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgICAgIGhoID0gZ2g7XG5cdCAgICAgICAgICAgICAgICBobCA9IGdsO1xuXHQgICAgICAgICAgICAgICAgZ2ggPSBmaDtcblx0ICAgICAgICAgICAgICAgIGdsID0gZmw7XG5cdCAgICAgICAgICAgICAgICBmaCA9IGVoO1xuXHQgICAgICAgICAgICAgICAgZmwgPSBlbDtcblx0ICAgICAgICAgICAgICAgIGVsID0gKGRsICsgdDFsKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBlaCA9IChkaCArIHQxaCArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZGggPSBjaDtcblx0ICAgICAgICAgICAgICAgIGRsID0gY2w7XG5cdCAgICAgICAgICAgICAgICBjaCA9IGJoO1xuXHQgICAgICAgICAgICAgICAgY2wgPSBibDtcblx0ICAgICAgICAgICAgICAgIGJoID0gYWg7XG5cdCAgICAgICAgICAgICAgICBibCA9IGFsO1xuXHQgICAgICAgICAgICAgICAgYWwgPSAodDFsICsgdDJsKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBhaCA9ICh0MWggKyB0MmggKyAoKGFsID4+PiAwKSA8ICh0MWwgPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIMGwgPSBIMC5sb3cgID0gKEgwbCArIGFsKTtcblx0ICAgICAgICAgICAgSDAuaGlnaCA9IChIMGggKyBhaCArICgoSDBsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIMWwgPSBIMS5sb3cgID0gKEgxbCArIGJsKTtcblx0ICAgICAgICAgICAgSDEuaGlnaCA9IChIMWggKyBiaCArICgoSDFsID4+PiAwKSA8IChibCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIMmwgPSBIMi5sb3cgID0gKEgybCArIGNsKTtcblx0ICAgICAgICAgICAgSDIuaGlnaCA9IChIMmggKyBjaCArICgoSDJsID4+PiAwKSA8IChjbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIM2wgPSBIMy5sb3cgID0gKEgzbCArIGRsKTtcblx0ICAgICAgICAgICAgSDMuaGlnaCA9IChIM2ggKyBkaCArICgoSDNsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINGwgPSBINC5sb3cgID0gKEg0bCArIGVsKTtcblx0ICAgICAgICAgICAgSDQuaGlnaCA9IChINGggKyBlaCArICgoSDRsID4+PiAwKSA8IChlbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINWwgPSBINS5sb3cgID0gKEg1bCArIGZsKTtcblx0ICAgICAgICAgICAgSDUuaGlnaCA9IChINWggKyBmaCArICgoSDVsID4+PiAwKSA8IChmbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBINmwgPSBINi5sb3cgID0gKEg2bCArIGdsKTtcblx0ICAgICAgICAgICAgSDYuaGlnaCA9IChINmggKyBnaCArICgoSDZsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgICAgICBIN2wgPSBINy5sb3cgID0gKEg3bCArIGhsKTtcblx0ICAgICAgICAgICAgSDcuaGlnaCA9IChIN2ggKyBoaCArICgoSDdsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyAxMjgpID4+PiAxMCkgPDwgNSkgKyAzMF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyAxMjgpID4+PiAxMCkgPDwgNSkgKyAzMV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgaGFzaCB0byAzMi1iaXQgd29yZCBhcnJheSBiZWZvcmUgcmV0dXJuaW5nXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaC50b1gzMigpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEwMjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEE1MTIpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTUxMihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEE1MTI7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUGVybXV0ZWQgQ2hvaWNlIDEgY29uc3RhbnRzXG5cdCAgICB2YXIgUEMxID0gW1xuXHQgICAgICAgIDU3LCA0OSwgNDEsIDMzLCAyNSwgMTcsIDksICAxLFxuXHQgICAgICAgIDU4LCA1MCwgNDIsIDM0LCAyNiwgMTgsIDEwLCAyLFxuXHQgICAgICAgIDU5LCA1MSwgNDMsIDM1LCAyNywgMTksIDExLCAzLFxuXHQgICAgICAgIDYwLCA1MiwgNDQsIDM2LCA2MywgNTUsIDQ3LCAzOSxcblx0ICAgICAgICAzMSwgMjMsIDE1LCA3LCAgNjIsIDU0LCA0NiwgMzgsXG5cdCAgICAgICAgMzAsIDIyLCAxNCwgNiwgIDYxLCA1MywgNDUsIDM3LFxuXHQgICAgICAgIDI5LCAyMSwgMTMsIDUsICAyOCwgMjAsIDEyLCA0XG5cdCAgICBdO1xuXG5cdCAgICAvLyBQZXJtdXRlZCBDaG9pY2UgMiBjb25zdGFudHNcblx0ICAgIHZhciBQQzIgPSBbXG5cdCAgICAgICAgMTQsIDE3LCAxMSwgMjQsIDEsICA1LFxuXHQgICAgICAgIDMsICAyOCwgMTUsIDYsICAyMSwgMTAsXG5cdCAgICAgICAgMjMsIDE5LCAxMiwgNCwgIDI2LCA4LFxuXHQgICAgICAgIDE2LCA3LCAgMjcsIDIwLCAxMywgMixcblx0ICAgICAgICA0MSwgNTIsIDMxLCAzNywgNDcsIDU1LFxuXHQgICAgICAgIDMwLCA0MCwgNTEsIDQ1LCAzMywgNDgsXG5cdCAgICAgICAgNDQsIDQ5LCAzOSwgNTYsIDM0LCA1Myxcblx0ICAgICAgICA0NiwgNDIsIDUwLCAzNiwgMjksIDMyXG5cdCAgICBdO1xuXG5cdCAgICAvLyBDdW11bGF0aXZlIGJpdCBzaGlmdCBjb25zdGFudHNcblx0ICAgIHZhciBCSVRfU0hJRlRTID0gWzEsICAyLCAgNCwgIDYsICA4LCAgMTAsIDEyLCAxNCwgMTUsIDE3LCAxOSwgMjEsIDIzLCAyNSwgMjcsIDI4XTtcblxuXHQgICAgLy8gU0JPWGVzIGFuZCByb3VuZCBwZXJtdXRhdGlvbiBjb25zdGFudHNcblx0ICAgIHZhciBTQk9YX1AgPSBbXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAwOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDA6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDMwMDAwMDAwOiAweDIsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDA6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDUwMDAwMDAwOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHg2MDAwMDAwMDogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDA6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAwOiAweDIwMixcblx0ICAgICAgICAgICAgMHg5MDAwMDAwMDogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDA6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDAwMDogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDA6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhkMDAwMDAwMDogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhmMDAwMDAwMDogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwMDogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDA6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHgzODAwMDAwMDogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDAwOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwMDogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDA6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDc4MDAwMDAwOiAweDIsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweDk4MDAwMDAwOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDA6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDAwOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHhjODAwMDAwMDogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDA6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhlODAwMDAwMDogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDA6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDE6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMTogMHgyLFxuXHQgICAgICAgICAgICAweDIwMDAwMDAxOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDAwMTogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxuXHQgICAgICAgICAgICAweDUwMDAwMDAxOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDE6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDcwMDAwMDAxOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMTogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDE6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDAxOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhiMDAwMDAwMTogMHg4MjAyLFxuXHQgICAgICAgICAgICAweGMwMDAwMDAxOiAweDIwMixcblx0ICAgICAgICAgICAgMHhkMDAwMDAwMTogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDE6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHhmMDAwMDAwMTogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAxOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHgyODAwMDAwMTogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDE6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDAxOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDE6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweDY4MDAwMDAxOiAweDIsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDE6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHg4ODAwMDAwMTogMHg4MDAyLFxuXHQgICAgICAgICAgICAweDk4MDAwMDAxOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHhhODAwMDAwMTogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDE6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweGM4MDAwMDAxOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDAwMTogMHgwLFxuXHQgICAgICAgICAgICAweGU4MDAwMDAxOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDE6IDB4ODA4MDAyXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDQwMDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDcwMDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweGQwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhlMDAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgyODAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHg4ODAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDk4MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhhODAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHhjODAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHhmODAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxMTAwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHgxMjAwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHgxNDAwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHgxNTAwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgxNjAwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgxNzAwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgxNDgwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgxNzgwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwMDAwMDogMHg0MDA4NDAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHgxYTgwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHgxYjgwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHgxYzgwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFkODAwMDAwOiAweDQwMTAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwMDA6IDB4ODQwMDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxMDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgyMDAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgzMDAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDUwMDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDYwMDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDcwMDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHhjMDAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHhkMDAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDI4MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDU4MDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHg4ODAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHg5ODAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHhjODAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDExMDAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDE2MDAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHgxNzAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweDE5MDAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHgxZjAwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDExODAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDEyODAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHgxNTgwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDE4ODAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweDFhODAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDFjODAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHgxZDgwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDFmODAwMDA6IDB4MTAxMDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDIwMDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgzMDAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDUwMDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHg3MDAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweGEwMDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweGIwMDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweGMwMDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweGQwMDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHhmMDAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHg4MDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE4MDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDI4MDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDM4MDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHg2ODAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDc4MDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDg4MDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweGU4MDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHhmODAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMDAwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDExMDAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxNjAwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxOTAwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDFiMDAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwMDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDFmMDAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDEwODAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxNDgwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDE1ODAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwOiAweDQwLFxuXHQgICAgICAgICAgICAweDE4ODAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxOTgwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHgxYTgwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDFjODAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweDFkODAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmODAwMDogMHg0MDEwNDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwLFxuXHQgICAgICAgICAgICAweDEwMDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHg1MDAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4NjAwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHg3MDAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDgwMDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweGEwMDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4YjAwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhjMDAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweGQwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhlMDAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxODAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDI4MDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MzgwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHg2ODAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDc4MDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODgwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHg5ODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhiODAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4YzgwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHhkODAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweGU4MDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHhmODAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDEwMDAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDExMDAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDEyMDAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEzMDAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDE0MDAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTUwMDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTcwMDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxOTAwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFiMDAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFjMDAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDFkMDAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweDFlMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxMDgwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxMTgwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEyODAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNjgwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxNzgwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxOTgwMDogMHgyMTA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxYTgwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFiODAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFjODAwOiAweDEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDA6IDB4MjAwMDAwODBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDEwMDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDIwMDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgzMDA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4NDAwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDUwMDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHg3MDA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4OTAwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweGEwMDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4YjAwOiAweDgsXG5cdCAgICAgICAgICAgIDB4YzAwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweGQwMDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4ZTAwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4ZjAwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDgwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDE4MDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgyODA6IDB4OCxcblx0ICAgICAgICAgICAgMHgzODA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDQ4MDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4NTgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDY4MDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHg3ODA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHg4ODA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDk4MDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweGE4MDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHhiODA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4YzgwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZDgwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweGU4MDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDEwMDA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMjAwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDEzMDA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHgxNDAwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTAwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE2MDA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTcwMDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTkwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFhMDA6IDB4OCxcblx0ICAgICAgICAgICAgMHgxYjAwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDFjMDA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweDFlMDA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTA4MDogMHg4LFxuXHQgICAgICAgICAgICAweDExODA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweDEyODA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDEzODA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTQ4MDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTY4MDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxNzgwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxYTgwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDogMHgyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MWM4MDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MWQ4MDogMHgwLFxuXHQgICAgICAgICAgICAweDFlODA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDogMHgxMDAwMjAwOFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDEwOiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MjA6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDMwOiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHg0MDogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDUwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NjA6IDB4MSxcblx0ICAgICAgICAgICAgMHg3MDogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDgwOiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4OTA6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweGEwOiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4YjA6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHhjMDogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweGQwOiAweDQwMSxcblx0ICAgICAgICAgICAgMHhlMDogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4ZjA6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4OiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgyODogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDM4OiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4NDg6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDU4OiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4Njg6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHg3ODogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4ODg6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDk4OiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4YTg6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHhiODogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4Yzg6IDB4NDAwLFxuXHQgICAgICAgICAgICAweGQ4OiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4ZTg6IDB4MSxcblx0ICAgICAgICAgICAgMHhmODogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTAwOiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwOiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMjA6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgxMzA6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxNDA6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweDE1MDogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDE2MDogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDE3MDogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTgwOiAweDQwMSxcblx0ICAgICAgICAgICAgMHgxOTA6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxYTA6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDFiMDogMHgxLFxuXHQgICAgICAgICAgICAweDFjMDogMHgwLFxuXHQgICAgICAgICAgICAweDFkMDogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweDFlMDogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDFmMDogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MTA4OiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxMTg6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgxMjg6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxMzg6IDB4MSxcblx0ICAgICAgICAgICAgMHgxNDg6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTg6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDE2ODogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4MTc4OiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTg4OiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTk4OiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4MWI4OiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWM4OiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxZDg6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDFlODogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDFmODogMHgxMDAwMDFcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4MTogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgyOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzogMHgyMCxcblx0ICAgICAgICAgICAgMHg0OiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDU6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg2OiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4NzogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDk6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHhhOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweGI6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHhjOiAweDgyMCxcblx0ICAgICAgICAgICAgMHhkOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweGY6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDA6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAxOiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDI6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMzogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA0OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDU6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDY6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDc6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDg6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOTogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGE6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGI6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYzogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBkOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGU6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZjogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHgxMTogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDEyOiAweDIwLFxuXHQgICAgICAgICAgICAweDEzOiAweDgwMCxcblx0ICAgICAgICAgICAgMHgxNDogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDE1OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4MTY6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHgxNzogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHgxODogMHgwLFxuXHQgICAgICAgICAgICAweDE5OiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDFhOiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4MWI6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHgxYzogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDFkOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDFlOiAweDgyMCxcblx0ICAgICAgICAgICAgMHgxZjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEwOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDExOiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEzOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE0OiAweDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE1OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTY6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNzogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE4OiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTk6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFiOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWM6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWQ6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFlOiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFmOiAweDgwMjA4MDBcblx0ICAgICAgICB9XG5cdCAgICBdO1xuXG5cdCAgICAvLyBNYXNrcyB0aGF0IHNlbGVjdCB0aGUgU0JPWCBpbnB1dFxuXHQgICAgdmFyIFNCT1hfTUFTSyA9IFtcblx0ICAgICAgICAweGY4MDAwMDAxLCAweDFmODAwMDAwLCAweDAxZjgwMDAwLCAweDAwMWY4MDAwLFxuXHQgICAgICAgIDB4MDAwMWY4MDAsIDB4MDAwMDFmODAsIDB4MDAwMDAxZjgsIDB4ODAwMDAwMWZcblx0ICAgIF07XG5cblx0ICAgIC8qKlxuXHQgICAgICogREVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBERVMgPSBDX2FsZ28uREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFNlbGVjdCA1NiBiaXRzIGFjY29yZGluZyB0byBQQzFcblx0ICAgICAgICAgICAgdmFyIGtleUJpdHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qml0UG9zID0gUEMxW2ldIC0gMTtcblx0ICAgICAgICAgICAgICAgIGtleUJpdHNbaV0gPSAoa2V5V29yZHNba2V5Qml0UG9zID4+PiA1XSA+Pj4gKDMxIC0ga2V5Qml0UG9zICUgMzIpKSAmIDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBc3NlbWJsZSAxNiBzdWJrZXlzXG5cdCAgICAgICAgICAgIHZhciBzdWJLZXlzID0gdGhpcy5fc3ViS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBuU3ViS2V5ID0gMDsgblN1YktleSA8IDE2OyBuU3ViS2V5KyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzdWJrZXlcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBzdWJLZXlzW25TdWJLZXldID0gW107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0U2hpZnQgPSBCSVRfU0hJRlRTW25TdWJLZXldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTZWxlY3QgNDggYml0cyBhY2NvcmRpbmcgdG8gUEMyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgbGVmdCAyOCBrZXkgYml0c1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVsoaSAvIDYpIHwgMF0gfD0ga2V5Qml0c1soKFBDMltpXSAtIDEpICsgYml0U2hpZnQpICUgMjhdIDw8ICgzMSAtIGkgJSA2KTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBmcm9tIHRoZSByaWdodCAyOCBrZXkgYml0c1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVs0ICsgKChpIC8gNikgfCAwKV0gfD0ga2V5Qml0c1syOCArICgoKFBDMltpICsgMjRdIC0gMSkgKyBiaXRTaGlmdCkgJSAyOCldIDw8ICgzMSAtIGkgJSA2KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gU2luY2UgZWFjaCBzdWJrZXkgaXMgYXBwbGllZCB0byBhbiBleHBhbmRlZCAzMi1iaXQgaW5wdXQsXG5cdCAgICAgICAgICAgICAgICAvLyB0aGUgc3Via2V5IGNhbiBiZSBicm9rZW4gaW50byA4IHZhbHVlcyBzY2FsZWQgdG8gMzItYml0cyxcblx0ICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsbG93cyB0aGUga2V5IHRvIGJlIHVzZWQgd2l0aG91dCBleHBhbnNpb25cblx0ICAgICAgICAgICAgICAgIHN1YktleVswXSA9IChzdWJLZXlbMF0gPDwgMSkgfCAoc3ViS2V5WzBdID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IDc7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YktleVtpXSA9IHN1YktleVtpXSA+Pj4gKChpIC0gMSkgKiA0ICsgMyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzdWJLZXlbN10gPSAoc3ViS2V5WzddIDw8IDUpIHwgKHN1YktleVs3XSA+Pj4gMjcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnZlcnNlIHN1YmtleXNcblx0ICAgICAgICAgICAgdmFyIGludlN1YktleXMgPSB0aGlzLl9pbnZTdWJLZXlzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaW52U3ViS2V5c1tpXSA9IHN1YktleXNbMTUgLSBpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fc3ViS2V5cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZTdWJLZXlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwgc3ViS2V5cykge1xuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXRcblx0ICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gTVtvZmZzZXRdO1xuXHQgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSBNW29mZnNldCArIDFdO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgcGVybXV0YXRpb25cblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsICAweDBmMGYwZjBmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsICAweDMzMzMzMzMzKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsICAweDAwZmYwMGZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDEsICAweDU1NTU1NTU1KTtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAwOyByb3VuZCA8IDE2OyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBzdWJLZXlzW3JvdW5kXTtcblx0ICAgICAgICAgICAgICAgIHZhciBsQmxvY2sgPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgICAgICB2YXIgckJsb2NrID0gdGhpcy5fckJsb2NrO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBGZWlzdGVsIGZ1bmN0aW9uXG5cdCAgICAgICAgICAgICAgICB2YXIgZiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGYgfD0gU0JPWF9QW2ldWygockJsb2NrIF4gc3ViS2V5W2ldKSAmIFNCT1hfTUFTS1tpXSkgPj4+IDBdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gckJsb2NrO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gbEJsb2NrIF4gZjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcblx0ICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IHRoaXMuX3JCbG9jaztcblx0ICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gdDtcblxuXHQgICAgICAgICAgICAvLyBGaW5hbCBwZXJtdXRhdGlvblxuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgIDB4NTU1NTU1NTUpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgIDB4MDBmZjAwZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgIDB4MzMzMzMzMzMpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgIDB4MGYwZjBmMGYpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdGhpcy5fckJsb2NrO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBibG9ja1NpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLy8gU3dhcCBiaXRzIGFjcm9zcyB0aGUgbGVmdCBhbmQgcmlnaHQgd29yZHNcblx0ICAgIGZ1bmN0aW9uIGV4Y2hhbmdlTFIob2Zmc2V0LCBtYXNrKSB7XG5cdCAgICAgICAgdmFyIHQgPSAoKHRoaXMuX2xCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX3JCbG9jaykgJiBtYXNrO1xuXHQgICAgICAgIHRoaXMuX3JCbG9jayBePSB0O1xuXHQgICAgICAgIHRoaXMuX2xCbG9jayBePSB0IDw8IG9mZnNldDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZXhjaGFuZ2VSTChvZmZzZXQsIG1hc2spIHtcblx0ICAgICAgICB2YXIgdCA9ICgodGhpcy5fckJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fbEJsb2NrKSAmIG1hc2s7XG5cdCAgICAgICAgdGhpcy5fbEJsb2NrIF49IHQ7XG5cdCAgICAgICAgdGhpcy5fckJsb2NrIF49IHQgPDwgb2Zmc2V0O1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkRFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkRFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5ERVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKERFUyk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVHJpcGxlLURFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgVHJpcGxlREVTID0gQ19hbGdvLlRyaXBsZURFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgREVTIGluc3RhbmNlc1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDAsIDIpKSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMiwgNCkpKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMyA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSg0LCA2KSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMS5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDE5Mi8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBibG9ja1NpemU6IDY0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5UcmlwbGVERVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5UcmlwbGVERVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlRyaXBsZURFUztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFgzMldvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiB4NjQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ194NjQgPSBDLng2NCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgNjQtYml0IHdvcmQuXG5cdCAgICAgKi9cblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZCA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgNjQtYml0IHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAzMiBiaXRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAzMiBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeDY0V29yZCA9IENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGlnaCwgbG93KSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG5cdCAgICAgICAgICAgIHRoaXMubG93ID0gbG93O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgTk9UcyB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgbmVnYXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBuZWdhdGVkID0geDY0V29yZC5ub3QoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBub3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB+dGhpcy5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gfnRoaXMubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIEFORHMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBBTkQgd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgQU5EaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYW5kZWQgPSB4NjRXb3JkLmFuZChhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gYW5kOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCAmIHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93ICYgd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgT1JzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gT1Igd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgT1JpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcmVkID0geDY0V29yZC5vcihhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gb3I6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIHwgd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgfCB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBYT1JzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gWE9SIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIFhPUmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHhvcmVkID0geDY0V29yZC54b3IoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHhvcjogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggXiB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyBeIHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgbGVmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBzaGlmdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHNoaWZ0ZWQgPSB4NjRXb3JkLnNoaWZ0TCgyNSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gc2hpZnRMOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyBpZiAobiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9ICh0aGlzLmhpZ2ggPDwgbikgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG4pKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyA8PCBuO1xuXHQgICAgICAgICAgICAvLyB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmxvdyA8PCAobiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSAwO1xuXHQgICAgICAgICAgICAvLyB9XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNoaWZ0cyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSByaWdodC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byBzaGlmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBzaGlmdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHNoaWZ0ZWQgPSB4NjRXb3JkLnNoaWZ0Uig3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBzaGlmdFI6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIGlmIChuIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSAodGhpcy5sb3cgPj4+IG4pIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBuKSk7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCA+Pj4gbjtcblx0ICAgICAgICAgICAgLy8gfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmhpZ2ggPj4+IChuIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAwO1xuXHQgICAgICAgICAgICAvLyB9XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgbGVmdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byByb3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgcm90YXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciByb3RhdGVkID0geDY0V29yZC5yb3RMKDI1KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyByb3RMOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5zaGlmdEwobikub3IodGhpcy5zaGlmdFIoNjQgLSBuKSk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJvdGF0ZXMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90Uig3KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyByb3RSOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5zaGlmdFIobikub3IodGhpcy5zaGlmdEwoNjQgLSBuKSk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBhZGQgd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgYWRkaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYWRkZWQgPSB4NjRXb3JkLmFkZChhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gYWRkOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gKHRoaXMubG93ICsgd29yZC5sb3cpIHwgMDtcblx0ICAgICAgICAgICAgLy8gdmFyIGNhcnJ5ID0gKGxvdyA+Pj4gMCkgPCAodGhpcy5sb3cgPj4+IDApID8gMSA6IDA7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCArIHdvcmQuaGlnaCArIGNhcnJ5KSB8IDA7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgNjQtYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG5cdCAgICAgICAgICogICAgIF0pO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcblx0ICAgICAgICAgKiAgICAgXSwgMTApO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyA2NC1iaXQgd29yZCBhcnJheSB0byBhIDMyLWJpdCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q3J5cHRvSlMubGliLldvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5J3MgZGF0YSBhcyBhIDMyLWJpdCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeDMyV29yZEFycmF5ID0geDY0V29yZEFycmF5LnRvWDMyKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9YMzI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB4NjRXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB4NjRXb3Jkc0xlbmd0aCA9IHg2NFdvcmRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB4MzJXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHg2NFdvcmRzTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB4NjRXb3JkID0geDY0V29yZHNbaV07XG5cdCAgICAgICAgICAgICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQuaGlnaCk7XG5cdCAgICAgICAgICAgICAgICB4MzJXb3Jkcy5wdXNoKHg2NFdvcmQubG93KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBYMzJXb3JkQXJyYXkuY3JlYXRlKHgzMldvcmRzLCB0aGlzLnNpZ0J5dGVzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHg2NFdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBcIndvcmRzXCIgYXJyYXlcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGVhY2ggWDY0V29yZCBvYmplY3Rcblx0ICAgICAgICAgICAgdmFyIHdvcmRzTGVuZ3RoID0gd29yZHMubGVuZ3RoO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2ldID0gd29yZHNbaV0uY2xvbmUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpOyIsIihmdW5jdGlvbiAoc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZmV0Y2hQb255ZmlsbChvcHRpb25zKSB7XG4gICAgdmFyIFByb21pc2UgPSBvcHRpb25zICYmIG9wdGlvbnMuUHJvbWlzZSB8fCBzZWxmLlByb21pc2U7XG4gICAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gb3B0aW9ucyAmJiBvcHRpb25zLlhNTEh0dHBSZXF1ZXN0IHx8IHNlbGYuWE1MSHR0cFJlcXVlc3Q7XG4gICAgdmFyIGdsb2JhbCA9IHNlbGY7XG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gT2JqZWN0LmNyZWF0ZShnbG9iYWwsIHtcbiAgICAgICAgZmV0Y2g6IHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdXBwb3J0ID0ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICAgICAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICAgICAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKSxcbiAgICAgICAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgICAgICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgICAgICAgXVxuXG4gICAgICAgICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgICAgICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gW11cbiAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgICAgICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgICAgICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICAgICAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICAgICAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgICAgICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gICAgICAgIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgICAgICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgICAgICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgICAgICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICAgICAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gICAgICAgIH1cblxuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgICAgICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIGZvcm1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgICAgICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIGhlYWRlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICAgICAgICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICAgICAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgICAgICAgfVxuXG4gICAgICAgIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgICAgICAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICAgICAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgICAgICAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgICAgICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgICAgICAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICAgICAgICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICAgICAgICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuICAgICAgfSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZldGNoOiBzZWxmLmZldGNoLFxuICAgICAgICBIZWFkZXJzOiBzZWxmLkhlYWRlcnMsXG4gICAgICAgIFJlcXVlc3Q6IHNlbGYuUmVxdWVzdCxcbiAgICAgICAgUmVzcG9uc2U6IHNlbGYuUmVzcG9uc2VcbiAgICAgIH07XG4gICAgfSgpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZldGNoUG9ueWZpbGw7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmZXRjaFBvbnlmaWxsO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuZmV0Y2hQb255ZmlsbCA9IGZldGNoUG9ueWZpbGw7XG4gIH1cbn0odHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gdGhpcyA6IHNlbGYpKTtcblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6ICdSRkMzOTg2JyxcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgYWxsb3dQcm90b3R5cGVzOiBmYWxzZSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgcGxhaW5PYmplY3RzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPyBudWxsIDogJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKHBvcyArIDEpLCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgcGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucykge1xuICAgIHZhciBsZWFmID0gdmFsO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScpIHtcbiAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdChsZWFmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgICAgICAgdmFyIGNsZWFuUm9vdCA9IHJvb3QuY2hhckF0KDApID09PSAnWycgJiYgcm9vdC5jaGFyQXQocm9vdC5sZW5ndGggLSAxKSA9PT0gJ10nID8gcm9vdC5zbGljZSgxLCAtMSkgOiByb290O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY2xlYW5Sb290LCAxMCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIFN0cmluZyhpbmRleCkgPT09IGNsZWFuUm9vdFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICAgICAmJiAob3B0aW9ucy5wYXJzZUFycmF5cyAmJiBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgICAgICBvYmpbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBsZWFmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZiA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKCFnaXZlbktleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuYWxsb3dEb3RzID8gZ2l2ZW5LZXkucmVwbGFjZSgvXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIGJyYWNrZXRzID0gLyhcXFtbXltcXF1dKl0pLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teW1xcXV0qXSkvZztcblxuICAgIC8vIEdldCB0aGUgcGFyZW50XG5cbiAgICB2YXIgc2VnbWVudCA9IGJyYWNrZXRzLmV4ZWMoa2V5KTtcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXNcbiAgICAgICAgLy8gdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMucHVzaChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93UHJvdG90eXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goc2VnbWVudFsxXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5hc3NpZ24oe30sIG9wdHMpIDoge307XG5cbiAgICBpZiAob3B0aW9ucy5kZWNvZGVyICE9PSBudWxsICYmIG9wdGlvbnMuZGVjb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmRlY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGVjb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA9PT0gdHJ1ZTtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIpID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXI7XG4gICAgb3B0aW9ucy5kZXB0aCA9IHR5cGVvZiBvcHRpb25zLmRlcHRoID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aDtcbiAgICBvcHRpb25zLmFycmF5TGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuYXJyYXlMaW1pdCA6IGRlZmF1bHRzLmFycmF5TGltaXQ7XG4gICAgb3B0aW9ucy5wYXJzZUFycmF5cyA9IG9wdGlvbnMucGFyc2VBcnJheXMgIT09IGZhbHNlO1xuICAgIG9wdGlvbnMuZGVjb2RlciA9IHR5cGVvZiBvcHRpb25zLmRlY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmRlY29kZXIgOiBkZWZhdWx0cy5kZWNvZGVyO1xuICAgIG9wdGlvbnMuYWxsb3dEb3RzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dEb3RzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmFsbG93RG90cyA6IGRlZmF1bHRzLmFsbG93RG90cztcbiAgICBvcHRpb25zLnBsYWluT2JqZWN0cyA9IHR5cGVvZiBvcHRpb25zLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHM7XG4gICAgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzIDogZGVmYXVsdHMuYWxsb3dQcm90b3R5cGVzO1xuICAgIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnBhcmFtZXRlckxpbWl0IDogZGVmYXVsdHMucGFyYW1ldGVyTGltaXQ7XG4gICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuXG4gICAgaWYgKHN0ciA9PT0gJycgfHwgc3RyID09PSBudWxsIHx8IHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gcGFyc2VWYWx1ZXMoc3RyLCBvcHRpb25zKSA6IHN0cjtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGtleXMgYW5kIHNldHVwIHRoZSBuZXcgb2JqZWN0XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRlbXBPYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIG5ld09iaiA9IHBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxudmFyIGFycmF5UHJlZml4R2VuZXJhdG9ycyA9IHtcbiAgICBicmFja2V0czogZnVuY3Rpb24gYnJhY2tldHMocHJlZml4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xuICAgIH0sXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgIH0sXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxufTtcblxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBlbmNvZGU6IHRydWUsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChkYXRlKTtcbiAgICB9LFxuICAgIHNraXBOdWxsczogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSggLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICBvYmplY3QsXG4gICAgcHJlZml4LFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgIHNraXBOdWxscyxcbiAgICBlbmNvZGVyLFxuICAgIGZpbHRlcixcbiAgICBzb3J0LFxuICAgIGFsbG93RG90cyxcbiAgICBzZXJpYWxpemVEYXRlLFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5XG4pIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IHNlcmlhbGl6ZURhdGUob2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyKSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gZW5jb2RlVmFsdWVzT25seSA/IHByZWZpeCA6IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybWF0dGVyKGtleVZhbHVlKSArICc9JyArIGZvcm1hdHRlcihlbmNvZGVyKG9iaiwgZGVmYXVsdHMuZW5jb2RlcikpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgocHJlZml4LCBrZXkpLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5XG4gICAgICAgICAgICApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAgICAgIHByZWZpeCArIChhbGxvd0RvdHMgPyAnLicgKyBrZXkgOiAnWycgKyBrZXkgKyAnXScpLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgICAgICBlbmNvZGVyLFxuICAgICAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5XG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLmFzc2lnbih7fSwgb3B0cykgOiB7fTtcblxuICAgIGlmIChvcHRpb25zLmVuY29kZXIgIT09IG51bGwgJiYgb3B0aW9ucy5lbmNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZW5jb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBkZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0aW9ucy5kZWxpbWl0ZXI7XG4gICAgdmFyIHN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmc7XG4gICAgdmFyIHNraXBOdWxscyA9IHR5cGVvZiBvcHRpb25zLnNraXBOdWxscyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5za2lwTnVsbHMgOiBkZWZhdWx0cy5za2lwTnVsbHM7XG4gICAgdmFyIGVuY29kZSA9IHR5cGVvZiBvcHRpb25zLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGU7XG4gICAgdmFyIGVuY29kZXIgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcjtcbiAgICB2YXIgc29ydCA9IHR5cGVvZiBvcHRpb25zLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnNvcnQgOiBudWxsO1xuICAgIHZhciBhbGxvd0RvdHMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBvcHRpb25zLmFsbG93RG90cztcbiAgICB2YXIgc2VyaWFsaXplRGF0ZSA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZURhdGUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnNlcmlhbGl6ZURhdGUgOiBkZWZhdWx0cy5zZXJpYWxpemVEYXRlO1xuICAgIHZhciBlbmNvZGVWYWx1ZXNPbmx5ID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5IDogZGVmYXVsdHMuZW5jb2RlVmFsdWVzT25seTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZm9ybWF0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbiAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRpb25zLmZvcm1hdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmb3JtYXQgb3B0aW9uIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW29wdGlvbnMuZm9ybWF0XTtcbiAgICB2YXIgb2JqS2V5cztcbiAgICB2YXIgZmlsdGVyO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqID0gZmlsdGVyKCcnLCBvYmopO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0aW9ucy5hcnJheUZvcm1hdCBpbiBhcnJheVByZWZpeEdlbmVyYXRvcnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRpb25zLmFycmF5Rm9ybWF0O1xuICAgIH0gZWxzZSBpZiAoJ2luZGljZXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRpb25zLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgb2JqS2V5cy5zb3J0KHNvcnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICBlbmNvZGUgPyBlbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICApKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0ga2V5cy5qb2luKGRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBoZXhUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICBhcnJheS5wdXNoKCclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbn0oKSk7XG5cbnZhciBjb21wYWN0UXVldWUgPSBmdW5jdGlvbiBjb21wYWN0UXVldWUocXVldWUpIHtcbiAgICB2YXIgb2JqO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmoubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0ub2JqW2l0ZW0ucHJvcF0gPSBjb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gZXhwb3J0cy5hcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFtpXSAmJiB0eXBlb2YgdGFyZ2V0W2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBleHBvcnRzLm1lcmdlKHRhcmdldFtpXSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5tZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIgOiBTdHJpbmcoc3RyKTtcblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnRzLmNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KHZhbHVlKSB7XG4gICAgdmFyIHF1ZXVlID0gW3sgb2JqOiB7IG86IHZhbHVlIH0sIHByb3A6ICdvJyB9XTtcbiAgICB2YXIgcmVmcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHJlZnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhY3RRdWV1ZShxdWV1ZSk7XG59O1xuXG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuIl19
