import * as fs from 'fs';
import ccxt from '../../js/ccxt.js';

const tsExchangeFile: string = '../ts/src/base/Exchange.ts';
const tsTypesFile: string = '../ts/src/base/types.ts';
const swiftExchangeFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchange.swift';
const swiftExchangesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchanges.swift';
const swiftTypesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTTypes.swift';
const goExchangeFile: string = '../go/v4/exchange_generated.go'
const goTypesFile: string = '../go/v4/exchange_types.go'
const gowrapperFile: string = '../swift-wrapper/ccxtwrapper.go';

const generatedHeader = `// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

`;

const customTypes = [   // Only those types that appear in swift headers
    'OrderRequest[]',
    'OrderRequest',
];

const isArray = (paramType: string): boolean => paramType.includes('[]') || paramType === 'Strings';

function splitAtProblemPhrase(methodName: string): string[] {
    if (methodName === 'signIn') {
        return ['sign', 'in: '];
    }
    const problemSwiftPhrases = [
        'By',
        'For',
        'With'
    ];
    const pattern = new RegExp(`(${problemSwiftPhrases.join('|')})(?=[A-Z])`);
    const match = pattern.exec(methodName);

    if (!match) {
        // No problem phrase found, return original string as single part array
        return [methodName, ''];
    }

    // Index where the matched phrase starts
    const index = match.index;

    // Split string into before and after the match
    return [methodName.slice(0, index), `${lowercaseFirstLetter(methodName.slice(index))}: `];
}

function capitalize (methodName: string) {
    return methodName.charAt(0).toUpperCase() + methodName.slice(1);
}
function lowercaseFirstLetter(str: string): string {
    return str[0].toLowerCase() + str.slice(1);
}
const prefix = (arr: string[], sep: string) => arr.length > 0 ? sep : '';

/*
    Gets the methods that will be created in Swift
*/
function getMethodNames(): string[] {
    const exchange = new ccxt.Exchange();
    return [
        ...Object.keys(exchange.has),
        'describe',
        'loadMarkets'
    ];
}

/**
 * Converts a single type name (as a string) to a swift type
 */
function tsTypeToSwift(tsType: string): string {
    if (!tsType) return "Void";

    /* 1) [A,B][] → [(A, B)] */
    const tupArr = tsType.match(/^\s*\[([^,\]]+),\s*([^,\]]+)]\s*\[\]\s*$/);
    if (tupArr) {
        const a = tsTypeToSwift(tupArr[1].trim());
        const b = tsTypeToSwift(tupArr[2].trim());
        return `[(${a}, ${b})]`;
    }

    /* 2) T[], T[][], T[][][] → [T], [[T]], [[[T]]] */
    const arrayDepthMatch = tsType.match(/^(\w+)((\[\])+)\s*$/);
    if (arrayDepthMatch) {
        const baseType = arrayDepthMatch[1];
        const brackets = arrayDepthMatch[2];
        const depth = (brackets.match(/\[\]/g) || []).length;

        let inner = tsTypeToSwift(baseType);
        for (let i = 0; i < depth; i++) {
            inner = `[${inner}]`;
        }
        return inner;
    }

    /* 3) fixed-length tuple [T, U, …] → (T, U, …) */
    const tupleMatch = tsType.match(/^\[\s*([^,\]]+\s*,\s*[^,\]]+.*?)\s*\]$/);
    if (tupleMatch) {
        const inner = tupleMatch[1]
            .split(",")
            .map(p => tsTypeToSwift(p.trim()))
            .join(", ");
        return `(${inner})`;
    }

    /* 4) collapse Partial<X> → X (stand-alone or inside unions) */
    tsType = tsType.replace(/Partial<\s*([^>]+?)\s*>/g, "$1");

    /* helper for a single (non-union) token */
    const mapSingle = (t: string): string =>
        t
            .replace(/\bobject\b/g, "[String: Any]")
            .replace(/\bnumber\b/g, "Double")
            .replace(/\bstring\b/g, "String")
            .replace(/\bBool\b/g, "Bool?")
            .replace(/\bboolean\b/g, "Bool")
            .replace(/\bany\b/g, "Any")
            .replace(/\bundefined\b/g, "Any")
            .replace(/\bnull\b/g, "Any")
            .replace(/\bvoid\b/g, "Void")
            .replace(/Dictionary<([^>]+)>/g, "[String: $1]")
            .replace(/\bDict\b/g, "[String: Any]")
            .replace(/\bNullableDict\b/g, "[String: Any]?")
            .replace(/\bList\b/g, "[Any]")
            .replace(/\bNullableList\b/g, "[Any]?")
            .replace(/\bNum\b/g, "Double?")
            .replace(/\bInt\b/g, "Int?")
            .replace(/\bint\b/g, "Int")
            .replace(/\bStr\b/g, "String?")
            .replace(/\bStrings\b/g, "[String]?")
            .replace(/\bIndexType\b/g, "Any")
            .replace(/\bOrderSide\b/g, "String?")
            .replace(/\bOrderType\b/g, "String")
            .replace(/\bMarketType\b/g, "String")
            .replace(/\bSubType\b/g, "String?")
            .trim();

    /* 5) handle unions */
    if (tsType.includes("|")) {
        const parts = tsType.split("|").map(p => p.trim());

        const isLit   = (p: string) => /^'[^']*'$/.test(p);
        const isStrKw = (p: string) => p === "string";
        const isStrAl = (p: string) => p === "Str";
        const isUndef = (p: string) => p === "undefined";
        const isNull  = (p: string) => p === "null";
        const isStrAr = (p: string) => p === "string[]";

        if (parts.every(p => isLit(p) || isStrKw(p) || isStrAl(p) || isUndef(p) || isNull(p))) {
            return parts.some(isUndef) || parts.some(isNull) ? "String?" : "String";
        }

        if (parts.every(p => isStrAr(p) || isUndef(p) || isNull(p))) {
            return "[String]?";
        }

        if (parts.length === 2 && (parts.some(isUndef) || parts.some(isNull))) {
            const base = parts.find(p => !isUndef(p) && !isNull(p))!;
            const mapped = mapSingle(base);
            return mapped.endsWith("?") ? mapped : `${mapped}?`;
        }

        if (parts.every(p => p === "number" || p === "string" || isUndef(p) || isNull(p))) {
            return "Any";
        }

        return "Any";
    }

    /* 6) single token */
    return mapSingle(tsType);
}

function tsTypeToGo(tsType: string): string {
    if (!tsType) return "void";

    // 1) [A,B][] → []struct{ A, B }
    const tupArr = tsType.match(/^\s*\[([^,\]]+),\s*([^,\]]+)]\s*\[\]\s*$/);
    if (tupArr) {
        const a = tsTypeToGo(tupArr[1].trim());
        const b = tsTypeToGo(tupArr[2].trim());
        return `[]struct{ A ${a}; B ${b} }`;
    }

    // 2) T[], T[][], T[][][] → []T, [][]T, [][][]T
    const arrayDepthMatch = tsType.match(/^(\w+)((\[\])+)\s*$/);
    if (arrayDepthMatch) {
        const baseType = arrayDepthMatch[1];
        const brackets = arrayDepthMatch[2];
        const depth = (brackets.match(/\[\]/g) || []).length;

        let inner = tsTypeToGo(baseType);
        for (let i = 0; i < depth; i++) {
            inner = `[]${inner}`;
        }
        return inner;
    }

    // 3) tuple [T, U, V] → struct { F0 T; F1 U; F2 V }
    const tupleMatch = tsType.match(/^\[\s*([^,\]]+\s*,\s*[^,\]]+.*?)\s*\]$/);
    if (tupleMatch) {
        const inner = tupleMatch[1]
            .split(",")
            .map((p, i) => `F${i} ${tsTypeToGo(p.trim())}`)
            .join("; ");
        return `struct { ${inner} }`;
    }

    // 4) collapse Partial<X> → X
    tsType = tsType.replace(/Partial<\s*([^>]+?)\s*>/g, "$1");

    const mapSingle = (t: string): string =>
        t
            .replace(/\bobject\b/g, "[]byte")
            .replace(/\bnumber\b/g, "float64")
            .replace(/\bstring\b/g, "string")
            .replace(/\bboolean\b/g, "bool")
            .replace(/\bany\b/g, "[]byte")
            .replace(/\bundefined\b/g, "[]byte")
            .replace(/\bnull\b/g, "[]byte")
            .replace(/\bvoid\b/g, "void")
            .replace(/\bDict\b/g, "map[string][]byte")
            .replace(/\bNullableDict\b/g, "map[string][]byte")
            .replace(/\bList\b/g, "[]byte")
            .replace(/\bNullableList\b/g, "[]byte")
            .replace(/\bNum\b/g, "float64")
            .replace(/\bInt\b/g, "int")
            .replace(/\bint\b/g, "int")
            .replace(/\bStr\b/g, "string")
            .replace(/\bStrings\b/g, "[]string")
            .replace(/\bBool\b/g, "bool")
            .replace(/\bIndexType\b/g, "[]byte")
            .replace(/\bOrderSide\b/g, "string")
            .replace(/\bOrderType\b/g, "string")
            .replace(/\bMarketType\b/g, "string")
            .replace(/\bSubType\b/g, "*string")
            .trim();

    // 5) union handling
    if (tsType.includes("|")) {
        const parts = tsType.split("|").map(p => p.trim());

        const isLit   = (p: string) => /^'[^']*'$/.test(p);
        const isStrKw = (p: string) => p === "string";
        const isStrAl = (p: string) => p === "Str";
        const isUndef = (p: string) => p === "undefined";
        const isNull  = (p: string) => p === "null";
        const isStrAr = (p: string) => p === "string[]";

        if (parts.every(p => isLit(p) || isStrKw(p) || isStrAl(p) || isUndef(p) || isNull(p))) {
            return parts.some(isUndef) || parts.some(isNull) ? "*string" : "string";
        }

        if (parts.every(p => isStrAr(p) || isUndef(p) || isNull(p))) {
            return "*[]string";
        }

        if (parts.length === 2 && (parts.some(isUndef) || parts.some(isNull))) {
            const base = parts.find(p => !isUndef(p) && !isNull(p))!;
            const mapped = mapSingle(base);
            return mapped.startsWith("*") ? mapped : `*${mapped}`;
        }

        return "[]byte";
    }

    // 6) single token
    return mapSingle(tsType);
}

/**
 * converts all types in types.ts to swift types adn prints them to CCXTTypes.swift
 */
function createSwiftTypes() {
    const tsContent = fs.readFileSync(tsTypesFile, "utf8");
    const lines     = tsContent.split("\n");

    const excluded = new Set([
        "Int", "int", "Str", "Bool", "Dictionary", "Dict", "List",
    ]);

    const out: string[] = [];
    const stack: { name: string }[] = [];
    let indent = "";
    let braceDepth = 0;
    let skipDictBody = false;   // inside  extends Dictionary<...> { ... }
    let skipTypeBody = false;   // inside  Partial<X> & { ... }

    // TODO: look at renaming this variable again
    /* helper: rename reserved 'internal' → 'isInternal' */
    const rename = (name: string) => (name === "internal" ? "isInternal" : name);
    // TODO: can't make Encodable because params is type any
    // const makeEncodable = (name: string) => customTypes.includes(name) ? `${name}: Encodable` : name;

    const push = (name: string) => {
        indent = "    ".repeat(stack.length);
        out.push(`${indent}public struct ${name} {`);
        stack.push({ name });
        indent = "    ".repeat(stack.length);
        braceDepth++;
    };
    const pop = () => {
        if (!stack.length) return;
        stack.pop();
        indent = "    ".repeat(stack.length);
        out.push(`${indent}}`);
        braceDepth--;
    };

    for (const raw of lines) {
        let line = raw.trim();
        if (!line) continue;

        /* skip bodies of dictionary-alias or partial-alias */
        if (skipDictBody) {
            if (line.startsWith("}")) skipDictBody = false;
            continue;
        }
        if (skipTypeBody) {
            if (line.startsWith("};") || line === "}") skipTypeBody = false;
            continue;
        }

        /* ── export type (one line) ─────────────────────────── */
        const oneType = line.match(/^export\s+type\s+(\w+)\s*=\s*(.+);$/);
        if (oneType) {
            const name = oneType[1];
            let body   = oneType[2].trim();
            const p = body.match(/^Partial<\s*([^>]+?)\s*>\s*&/);
            if (p) body = p[1].trim();
            body = body.replace(/\s*&\s*\{[\s\S]*$/, "").trim();
            if (!excluded.has(name))
                out.push(`public typealias ${name} = ${tsTypeToSwift(body)}`);
            continue;
        }

        /* ── export type Name = Partial<X> & {  (multi-line) ─── */
        const openPartial = line.match(
            /^export\s+type\s+(\w+)\s*=\s*Partial<\s*([^>]+?)\s*>\s*&\s*\{$/
        );
        if (openPartial) {
            const alias = openPartial[1];
            const base  = openPartial[2].trim();
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = ${tsTypeToSwift(base)}`);
            skipTypeBody = true;
            continue;
        }

        /* ── interface Name extends Dictionary<T> { … } ─────── */
        const dict = line.match(
            /^export\s+interface\s+(\w+)\s+extends\s+Dictionary\s*<\s*([^>]+?)\s*>\s*(\{)?\s*$/
        );
        if (dict) {
            const alias = dict[1];
            const inner = tsTypeToSwift(dict[2].trim());
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = [String: ${inner}]`);
            if (dict[3] === "{") skipDictBody = true;
            continue;
        }

        /* ── interface start (export optional) ───────────────── */
        const iface = line.match(/^(?:export\s+)?interface\s+(\w+)/);
        if (iface) {
            const name = iface[1];
            if (!excluded.has(name)) push(name);
            continue;
        }

        /* ── nested object  'foo': {  ───────────────────────── */
        const obj = line.match(/^['"]?(\w+)['"]?\??:\s*\{$/);
        if (obj) {
            const field = rename(obj[1]);
            const structName = field[0].toUpperCase() + field.slice(1);
            if (braceDepth === stack.length)
                out.push(`${indent}public var ${field}: ${structName}`);
            push(structName);
            continue;
        }

        /* ── closing brace ──────────────────────────────────── */
        if (line.startsWith("}")) {
            pop();
            continue;
        }

        /* ── ordinary field ( ; or , ) ─────────────────────── */
        const fld = line.match(/^['"]?(\w+)['"]?\??:\s*([^;,]+)[;,]?$/);
        if (fld && stack.length) {
            const name      = rename(fld[1]);
            const swiftType = tsTypeToSwift(fld[2]);
            const optional  = fld[0].includes("?") || swiftType.endsWith("?");
            out.push(`${indent}public var ${name}: ${swiftType}${optional ? "" : ""}`);
        }
    }

    /* write generated Swift types */
    fs.writeFileSync(swiftTypesFile, generatedHeader, "utf8");
    fs.appendFileSync(swiftTypesFile, out.join("\n"), "utf8");
}

const goMethodDeclaration = (methodName: string, params: {[key: string]: [string, string | null]}) => {
    const arrayParams: string[] = [];
    const customTypeParams: string[] = [];
    const callParams: string[] = [];
    const headerParams: string[] = [];
    const optionalParams: [string, string][] = [];
    Object.keys(params).forEach((paramName: string) => {
        const [paramType, defaultValue] = params[paramName];
        if (paramName === 'type') {
            paramName = 'typeVar';
        }
        if (defaultValue !== 'undefined') {
            let newName = paramName;
            let goType = tsTypeToGo(paramType)
            if (customTypes.includes(paramType)) {
                customTypeParams.push(paramName);
                newName = `${paramName}_object`;
                goType = 'string';
            } else if (isArray(paramType)) {
                arrayParams.push(paramName);
                newName = `${paramName}_arr`;
                goType = 'string';
            } else if (paramName === 'params') {
                newName = 'decoded';
            }
            headerParams.push(`${paramName} ${goType}`);
            callParams.push(newName);
        } else {
            optionalParams.push([paramName, paramType]);
            callParams.push(paramName);
        }
    });
    const capsMethodName = capitalize(methodName);
    const sep = "\n\t\t";
    const customTypeParamsCode = prefix(customTypeParams, sep) + customTypeParams.map(paramName => `${paramName}_object := ParseJSON(${paramName})`).join(sep);  // stringify custom types
    // const arrayParamsCode = prefix(arrayParams, sep) + arrayParams.map(paramName => `${paramName}_arr := strings.Split(${paramName}, ",")`).join(sep);  // stringify custom types  // probably unnecessary, as the array parameters are already strings
    return `
    func (e *CCXTGoExchange) ${capsMethodName}(${headerParams.join(", ")}) ([]byte, error) {${customTypeParamsCode}
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        ${optionalParams.map(([paramName, paramType]) => {
        
            return `
        var ${paramName} interface{} = nil
        if v, ok := decoded["${paramName}"]; ok && v != nil {
            if f, ok := v.(${tsTypeToGo(paramType).replace('int', 'float64')}); ok {
                ${paramName} = ${tsTypeToGo(paramType)}(f)
            }
            delete(decoded, "${paramName}")
        }`
        }).join("\n")
        }
        res := <-e.exchange.${capsMethodName}(${callParams.join(', ')})
        if err, ok := res.(error); ok {
            return nil, err
        }
        return json.Marshal(res)
    }`
}

const getSwiftReturnType = (methodName: string, tsType: string): string => {
    // TODO: This function shouldn't be needed if we can fix the encodable issue
    if (methodName === "loadMarkets") {
        return "[String: [String: Any]]";
    } else if (methodName === "describe") {
        return "[String: Any]";
    }
    const swiftTypes = {
        "int": "Int",
        "number": "Double",
        "boolean": "Bool",
        "Num": "Double?",
        "Strings": "[String]?",
        "Account[]": "[[String: Any]]",
        "any": "Any",
        "Balances": "[String: [String: Any]]",
        "BorrowInterest[]": "[[String: Any]]",
        "Conversion": "[String: Any]",
        "Conversion[]": "[[String: Any]]",
        "CrossBorrowRate": "[String: Any]",
        "CrossBorrowRates": "[String: [String: Any]]",
        "Currencies": "[String: [String: Any]]",
        "DepositAddress": "[String: Any]",
        "DepositAddress[]": "[[String: Any]]",
        "DepositWithdrawFeeNetwork": "[String: Any]",
        "Dictionary<DepositWithdrawFeeNetwork>": "[String: [String: Any]]",
        "Dictionary<Dictionary<OHLCV[]>>": "[String: [String: [[Double]]]]",
        "FundingHistory[]": "[String: [String: Any]]",
        "FundingRate": "[String: Any]",
        "FundingRateHistory[]": "[[String: Any]]",
        "FundingRates": "[String: [String: Any]]",
        "Greeks": "[String: Any]",
        "Int": "Int?",
        "IsolatedBorrowRate": "[String: Any]",
        "IsolatedBorrowRates": "[String: [String: Any]]",
        "LastPrices": "[String: [String: Any]]",
        "LedgerEntry": "[String: Any]",
        "LedgerEntry[]": "[[String: Any]]",
        "Leverage": "[String: Any]",
        "Leverages": "[String: [String: Any]]",
        "LeverageTier[]": "[[String: Any]]",
        "LeverageTiers": "[String: [[String: Any]]]",
        "Liquidation[]": "[[String: Any]]",
        "LongShortRatio": "[String: Any]",
        "LongShortRatio[]": "[[String: Any]]",
        "MarginMode": "[String: Any]",
        "MarginModes": "[String: [String: Any]]",
        "MarginModification": "[String: Any]",
        "MarginModification[]": "[[String: Any]]",
        "Market[]": "[[String: Any]]",
        "OHLCV[]": "[[Double]]",
        "OpenInterest": "[String: Any]",
        "OpenInterest[]": "[[String: Any]]",
        "OpenInterests": "[String: [String: Any]]",
        "Option": "[String: Any]",
        "OptionChain": "[String: [String: Any]]",
        "Order": "[String: Any]",
        "Order[]": "[[String: Any]]",
        "OrderBook": "[String: Any]",
        "OrderBooks": "[String: [String: Any]]",
        "Position": "[String: Any]",
        "Position[]": "[[String: Any]]",
        "string": "String",
        "Ticker": "[String: Any]",
        "Tickers": "[String: [String: Any]]",
        "Trade[]": "[[String: Any]]",
        "TradingFeeInterface": "[String: Any]",
        "TradingFees": "[String: [String: Any]]",
        "Transaction": "[String: Any]",
        "Transaction[]": "[[String: Any]]",
        "TransferEntry": "[String: Any]",
        "TransferEntry[]": "[[String: Any]]"
    }
    if (swiftTypes[tsType]) {
        return swiftTypes[tsType];
    } else if (tsType.endsWith('[]')) {
        return "Any[]";
    } else {
        return "Any";
    }
}

const swiftMethodDeclaration = (methodName: string, params: {[key: string]: [string, string | null]}, returnType: string) => {
    // TODO: add return types, right now all the return types need to be Any because the info property prevents them from extended encodeable
    // const swiftReturnType = tsTypeToSwift(returnType);
    // const guardClause = (swiftReturnType === 'Any') ? `` : `as? ${swiftReturnType}`;
    const swiftParams = Object.keys(params).map(key => {
        const [tsType, defaultValue] = params[key];
        const paramType = tsTypeToSwift(tsType);
        return defaultValue === null
            ? `${key}: ${paramType}`
            : `${key}: ${paramType} = ${defaultValue
                .replace(/undefined/g, 'nil')
                .replace(/{}/g, '[:]')}`
                .replace(/params\:\s*Any\b/g, 'params: [String: Any]')
                .replace(/'/g, '"');
    }).join(', ')
    const goCallParams: string[] = [];
    const optionalParams: string[] = [];
    const customTypeParams: string[] = [];
    const arrayParams: string[] = [];
    let index = 0;
    const [callMethodName, firstExternalName] = splitAtProblemPhrase(methodName);
    Object.keys(params).forEach(paramName => {
        const [paramType, defaultValue] = params[paramName];
        const isArray = paramType.includes('[]');
        if (defaultValue === 'undefined') {
            optionalParams.push(paramName);
        } else {
            let newName = paramName;
            if (customTypes.includes(paramType)) {
                customTypeParams.push(paramName);
                newName = `${paramName}_string`;
            } else if (isArray) {
                arrayParams.push(paramName);
                newName = `${paramName}_string`;
            } else if (paramName === 'params') {
                newName = 'paramsData';
            }
            const externalName = (index === 0) ? firstExternalName : `${paramName}: `.replace(/type/g, 'typeVar'); // type is a reserved word in Go, so we need to rename it to typeVar
            goCallParams.push(`${externalName}${newName}`);
            index += 1;
        }
    });
    const sep = "\n\t\t\t\t\t";
    let optionalsCode = '';
    let paramsCopy = false;
    if (optionalParams.length > 0){
        optionalsCode = `${sep}var paramsCopy: [String: Any] = params`;
        paramsCopy = true;
    }
    optionalsCode += prefix(optionalParams, sep) + optionalParams.map(paramName => `if (${paramName} != nil) { paramsCopy["${paramName}"] = ${paramName} }`).join(sep);
    const customTypeParamsCode = prefix(customTypeParams, sep) + customTypeParams.map(paramName => `let ${paramName}_string = stringify(${paramName})`).join(sep);  // stringify custom types
    const arrayParamsCode = prefix(arrayParams, sep) + arrayParams.map(paramName => `let ${paramName}_string = ${paramName}.joined(separator: ",")`).join(sep);  // convert array parameters to comma separated strings
    const swiftReturnType = getSwiftReturnType(methodName, returnType);
    // const guardCode = `
    //         guard let result = cleanAny(jsonObject) ${guardClause} else {
    //             throw NSError(domain: "CCXT", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid response type for ${methodName}"])
    //         }\n`;
    return`
    public func ${methodName} (${swiftParams}) async throws -> ${swiftReturnType} {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {${optionalsCode}${customTypeParamsCode}${arrayParamsCode}
                    let paramsData = try? JSONSerialization.data(withJSONObject: ${paramsCopy ? 'paramsCopy' : 'params'})
                    let data = try self.exchange.${callMethodName}(${goCallParams.join(', ')})
                    do {
                        let jsonObject = try JSONSerialization.jsonObject(with: data, options: [])
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! ${swiftReturnType})
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
`
}

const exchangeDeclaration = (exchangeName: string) => (`
public class ${capitalize(exchangeName)}: CCXTExchange {
    public init?(config: [String: Any]? = nil) {
        super.init(exchangeName: "${exchangeName}", config: config)
    }
}`);

function createExchangeClasses() {
    const exchangeDeclarations: string[] = [];
    for (const exchangeName of ccxt.exchanges) {
        exchangeDeclarations.push(exchangeDeclaration(exchangeName));
    }
    fs.writeFileSync(swiftExchangesFile, `${generatedHeader}import Foundation\nimport CCXT\n`, "utf8");
    fs.appendFileSync(swiftExchangesFile, exchangeDeclarations.join("\n"), "utf8");
}

function getTypescriptHeaders(): [string, {[key: string]: [string, string | null]}, string][] {
    // Initialize empty array for results
    const results: [string, {[key: string]: [string, string | null]}, string][] = [];
    
    // Get the allowed method names
    const allowedMethods = new Set(getMethodNames());
    
    // Read the typescript file content
    const src = fs.readFileSync(tsExchangeFile, "utf8");
    
    // Match method declarations
    const methodRegex = /async\s+(\w+)\s*\(([\s\S]*?)\)\s*(?::\s*Promise\s*<\s*([\w\[\]]+)\s*>)?/g;
    
    let match;
    while ((match = methodRegex.exec(src)) !== null) {
        const methodName = match[1];
        
        // Skip if method is not in allowedMethods
        if (!allowedMethods.has(methodName)) {
            continue;
        }
        
        const params = match[2].trim();
        const returnType = match[3]?.trim() ?? "Any";
        
        // Initialize parameter dictionary for this method
        const paramDict: {[key: string]: [string, string | null]} = {};
        
        // Split parameters and process each one
        if (params) {
            const paramList = params.split(/,(?![^{]*})(?![^\[]*\])/).map(p => p.trim());
            
            for (const param of paramList) {
                // Match: name?: type = defaultValue
                const paramMatch = param.match(/^(\w+)(\?)?(?::\s*([^=]+))?\s*(?:=\s*(.+))?$/);
                if (paramMatch) {
                    const [, name, optional, type = 'any', defaultValue] = paramMatch;
                    const finalType = (type.trim() + (optional ? '?' : '')).replace(/\s+/g, '');
                    paramDict[name] = [finalType, defaultValue?.trim() || null];
                }
            }
        }
        
        results.push([methodName, paramDict, returnType]);
    }
    
    return results;
}

function main() {

    const injectAfterString = '// METHODS BELOW THIS LINE ARE TRANSPILED';
    const injectAfterRegex = new RegExp(`(${injectAfterString})([\\s\\S]*)`, 'm');


    const swiftMethodDeclarations: string[] = [];
    const goMethodDeclarations: string[] = [];
    createSwiftTypes();
    createExchangeClasses();
    const headers = getTypescriptHeaders();
    for (const [methodName, params, returnType] of headers) {
        if ([
            // TODO: Websocket methods, once go is implemented
            'cancelAllOrdersWs',
            'cancelOrdersWs',
            'cancelOrderWs',
            'createLimitBuyOrderWs',
            'createLimitOrderWs',
            'createLimitSellOrderWs',
            'createMarketBuyOrderWs',
            'createMarketOrderWithCostWs',
            'createMarketOrderWs',
            'createMarketSellOrderWs',
            'createOrderWithTakeProfitAndStopLossWs',
            'createOrderWs',
            'createPostOnlyOrderWs',
            'createReduceOnlyOrderWs',
            'createStopLimitOrderWs',
            'createStopLossOrderWs',
            'createStopMarketOrderWs',
            'createStopOrderWs',
            'createTakeProfitOrderWs',
            'createTrailingAmountOrderWs',
            'createTrailingPercentOrderWs',
            'createTriggerOrderWs',
            'editOrderWs',
            'editOrderWs',
            'fetchBalanceWs',
            'fetchClosedOrdersWs',
            'fetchCurrenciesWs',
            'fetchDepositsWs',
            'fetchMarketsWs',
            'fetchMyTradesWs',
            'fetchOHLCVWs',
            'fetchOpenOrdersWs',
            'fetchOrderBookWs',
            'fetchOrdersWs',
            'fetchOrderWs',
            'fetchPositionsForSymbolWs',
            'fetchPositionsWs',
            'fetchPositionWs',
            'fetchTickersWs',
            'fetchTickerWs',
            'fetchTradesWs',
            'fetchTradingFeesWs',
            'fetchWithdrawalsWs',
            'watchBalance',
            'watchBidsAsks',
            'watchLiquidations',
            'watchLiquidationsForSymbols',
            'watchMyLiquidations',
            'watchMyLiquidationsForSymbols',
            'watchMyTrades',
            'watchOHLCV',
            'watchOHLCVForSymbols',
            'watchOrderBook',
            'watchOrderBookForSymbols',
            'watchOrders',
            'watchOrdersForSymbols',
            'watchPosition',
            'watchPositions',
            'watchTicker',
            'watchTickers',
            'watchTrades',
            'watchTradesForSymbols',

            // TODO: don't know how to make types encodable with params as type any
            'createOrders',
            'editOrders',
            'deleteOrders'
        ].includes(methodName)) {
            continue;
        } else {
            swiftMethodDeclarations.push(swiftMethodDeclaration(methodName, params, returnType));
            goMethodDeclarations.push(goMethodDeclaration(methodName, params));
        }
    }

    const loopItems: [string, string[]][] = [
        [swiftExchangeFile, swiftMethodDeclarations],
        [gowrapperFile, goMethodDeclarations]
    ];

    loopItems.forEach(([file, methodDeclarations]) => {
        const fileContent = fs.readFileSync(file, 'utf8');
        const newFileContent = fileContent.replace(
            injectAfterRegex,
            `$1\n${methodDeclarations.join('\n')}`
        );
        fs.writeFileSync(file, newFileContent);
    })
    fs.appendFileSync(swiftExchangeFile, '\n}');
}

main()
