import * as fs from 'fs';
import ccxt from '../../js/ccxt.js';

const tsExchangeFile: string = '../ts/src/base/Exchange.ts';
const tsTypesFile: string = '../ts/src/base/types.ts';
const swiftExchangeFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchange.swift';
const swiftExchangesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTExchanges.swift';
const swiftTypesFile: string = '../swift-wrapper/Sources/CCXTSwift/CCXTTypes.swift';
const goExchangeFile: string = '../go/v4/exchange_generated.go'
const goTypesFile: string = '../go/v4/exchange_types.go'
const gowrapperFile: string = '../swift-wrapper/ccxtwrapper.go';

const generatedHeader = `// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

`;

const customTypes = [   // Only those types that appear in swift headers
    'OrderRequest[]',
    'OrderRequest',
];

function capitalize (methodName: string) {
    return methodName.charAt(0).toUpperCase() + methodName.slice(1);
}
const prefix = (arr: string[], sep: string) => arr.length > 0 ? sep : '';

/*
    Gets the methods that will be created in Swift
*/
function getMethodNames(): string[] {
    const exchange = new ccxt.Exchange();
    return [
        ...Object.keys(exchange.has),
        'describe',
    ];
}

/**
 * Converts a single type name (as a string) to a swift type
 */
function tsTypeToSwift(tsType: string): string {
    if (!tsType) return "Void";

    /* 1) [A,B][] → [(A, B)] */
    const tupArr = tsType.match(/^\s*\[([^,\]]+),\s*([^,\]]+)]\s*\[\]\s*$/);
    if (tupArr) {
        const a = tsTypeToSwift(tupArr[1].trim());
        const b = tsTypeToSwift(tupArr[2].trim());
        return `[(${a}, ${b})]`;
    }

    /* 2) T[], T[][], T[][][] → [T], [[T]], [[[T]]] */
    const arrayDepthMatch = tsType.match(/^(\w+)((\[\])+)\s*$/);
    if (arrayDepthMatch) {
        const baseType = arrayDepthMatch[1];
        const brackets = arrayDepthMatch[2];
        const depth = (brackets.match(/\[\]/g) || []).length;

        let inner = tsTypeToSwift(baseType);
        for (let i = 0; i < depth; i++) {
            inner = `[${inner}]`;
        }
        return inner;
    }

    /* 3) fixed-length tuple [T, U, …] → (T, U, …) */
    const tupleMatch = tsType.match(/^\[\s*([^,\]]+\s*,\s*[^,\]]+.*?)\s*\]$/);
    if (tupleMatch) {
        const inner = tupleMatch[1]
            .split(",")
            .map(p => tsTypeToSwift(p.trim()))
            .join(", ");
        return `(${inner})`;
    }

    /* 4) collapse Partial<X> → X (stand-alone or inside unions) */
    tsType = tsType.replace(/Partial<\s*([^>]+?)\s*>/g, "$1");

    /* helper for a single (non-union) token */
    const mapSingle = (t: string): string =>
        t
            .replace(/\bobject\b/g, "[String: Any]")
            .replace(/\bnumber\b/g, "Double")
            .replace(/\bstring\b/g, "String")
            .replace(/\bBool\b/g, "Bool?")
            .replace(/\bboolean\b/g, "Bool")
            .replace(/\bany\b/g, "Any")
            .replace(/\bundefined\b/g, "Any")
            .replace(/\bnull\b/g, "Any")
            .replace(/\bvoid\b/g, "Void")
            .replace(/Dictionary<([^>]+)>/g, "[String: $1]")
            .replace(/\bDict\b/g, "[String: Any]")
            .replace(/\bNullableDict\b/g, "[String: Any]?")
            .replace(/\bList\b/g, "[Any]")
            .replace(/\bNullableList\b/g, "[Any]?")
            .replace(/\bNum\b/g, "Double?")
            .replace(/\bInt\b/g, "Int?")
            .replace(/\bint\b/g, "Int")
            .replace(/\bStr\b/g, "String?")
            .replace(/\bStrings\b/g, "[String]?")
            .replace(/\bIndexType\b/g, "Any")
            .replace(/\bOrderSide\b/g, "String?")
            .replace(/\bOrderType\b/g, "String")
            .replace(/\bMarketType\b/g, "String")
            .replace(/\bSubType\b/g, "String?")
            .trim();

    /* 5) handle unions */
    if (tsType.includes("|")) {
        const parts = tsType.split("|").map(p => p.trim());

        const isLit   = (p: string) => /^'[^']*'$/.test(p);
        const isStrKw = (p: string) => p === "string";
        const isStrAl = (p: string) => p === "Str";
        const isUndef = (p: string) => p === "undefined";
        const isNull  = (p: string) => p === "null";
        const isStrAr = (p: string) => p === "string[]";

        if (parts.every(p => isLit(p) || isStrKw(p) || isStrAl(p) || isUndef(p) || isNull(p))) {
            return parts.some(isUndef) || parts.some(isNull) ? "String?" : "String";
        }

        if (parts.every(p => isStrAr(p) || isUndef(p) || isNull(p))) {
            return "[String]?";
        }

        if (parts.length === 2 && (parts.some(isUndef) || parts.some(isNull))) {
            const base = parts.find(p => !isUndef(p) && !isNull(p))!;
            const mapped = mapSingle(base);
            return mapped.endsWith("?") ? mapped : `${mapped}?`;
        }

        if (parts.every(p => p === "number" || p === "string" || isUndef(p) || isNull(p))) {
            return "Any";
        }

        return "Any";
    }

    /* 6) single token */
    return mapSingle(tsType);
}

function tsTypeToGo(tsType: string): string {
    if (!tsType) return "void";

    // 1) [A,B][] → []struct{ A, B }
    const tupArr = tsType.match(/^\s*\[([^,\]]+),\s*([^,\]]+)]\s*\[\]\s*$/);
    if (tupArr) {
        const a = tsTypeToGo(tupArr[1].trim());
        const b = tsTypeToGo(tupArr[2].trim());
        return `[]struct{ A ${a}; B ${b} }`;
    }

    // 2) T[], T[][], T[][][] → []T, [][]T, [][][]T
    const arrayDepthMatch = tsType.match(/^(\w+)((\[\])+)\s*$/);
    if (arrayDepthMatch) {
        const baseType = arrayDepthMatch[1];
        const brackets = arrayDepthMatch[2];
        const depth = (brackets.match(/\[\]/g) || []).length;

        let inner = tsTypeToGo(baseType);
        for (let i = 0; i < depth; i++) {
            inner = `[]${inner}`;
        }
        return inner;
    }

    // 3) tuple [T, U, V] → struct { F0 T; F1 U; F2 V }
    const tupleMatch = tsType.match(/^\[\s*([^,\]]+\s*,\s*[^,\]]+.*?)\s*\]$/);
    if (tupleMatch) {
        const inner = tupleMatch[1]
            .split(",")
            .map((p, i) => `F${i} ${tsTypeToGo(p.trim())}`)
            .join("; ");
        return `struct { ${inner} }`;
    }

    // 4) collapse Partial<X> → X
    tsType = tsType.replace(/Partial<\s*([^>]+?)\s*>/g, "$1");

    const mapSingle = (t: string): string =>
        t
            .replace(/\bobject\b/g, "[]byte")
            .replace(/\bnumber\b/g, "float64")
            .replace(/\bstring\b/g, "string")
            .replace(/\bboolean\b/g, "bool")
            .replace(/\bany\b/g, "[]byte")
            .replace(/\bundefined\b/g, "[]byte")
            .replace(/\bnull\b/g, "[]byte")
            .replace(/\bvoid\b/g, "void")
            .replace(/\bDict\b/g, "map[string][]byte")
            .replace(/\bNullableDict\b/g, "map[string][]byte")
            .replace(/\bList\b/g, "[]byte")
            .replace(/\bNullableList\b/g, "[]byte")
            .replace(/\bNum\b/g, "float64")
            .replace(/\bInt\b/g, "int")
            .replace(/\bint\b/g, "int")
            .replace(/\bStr\b/g, "string")
            .replace(/\bStrings\b/g, "[]string")
            .replace(/\bBool\b/g, "bool")
            .replace(/\bIndexType\b/g, "[]byte")
            .replace(/\bOrderSide\b/g, "string")
            .replace(/\bOrderType\b/g, "string")
            .replace(/\bMarketType\b/g, "string")
            .replace(/\bSubType\b/g, "*string")
            .trim();

    // 5) union handling
    if (tsType.includes("|")) {
        const parts = tsType.split("|").map(p => p.trim());

        const isLit   = (p: string) => /^'[^']*'$/.test(p);
        const isStrKw = (p: string) => p === "string";
        const isStrAl = (p: string) => p === "Str";
        const isUndef = (p: string) => p === "undefined";
        const isNull  = (p: string) => p === "null";
        const isStrAr = (p: string) => p === "string[]";

        if (parts.every(p => isLit(p) || isStrKw(p) || isStrAl(p) || isUndef(p) || isNull(p))) {
            return parts.some(isUndef) || parts.some(isNull) ? "*string" : "string";
        }

        if (parts.every(p => isStrAr(p) || isUndef(p) || isNull(p))) {
            return "*[]string";
        }

        if (parts.length === 2 && (parts.some(isUndef) || parts.some(isNull))) {
            const base = parts.find(p => !isUndef(p) && !isNull(p))!;
            const mapped = mapSingle(base);
            return mapped.startsWith("*") ? mapped : `*${mapped}`;
        }

        return "[]byte";
    }

    // 6) single token
    return mapSingle(tsType);
}

/**
 * converts all types in types.ts to swift types adn prints them to CCXTTypes.swift
 */
function createSwiftTypes() {
    const tsContent = fs.readFileSync(tsTypesFile, "utf8");
    const lines     = tsContent.split("\n");

    const excluded = new Set([
        "Int", "int", "Str", "Bool", "Dictionary", "Dict", "List",
    ]);

    const out: string[] = [];
    const stack: { name: string }[] = [];
    let indent = "";
    let braceDepth = 0;
    let skipDictBody = false;   // inside  extends Dictionary<...> { ... }
    let skipTypeBody = false;   // inside  Partial<X> & { ... }

    // TODO: look at renaming this variable again
    /* helper: rename reserved 'internal' → 'isInternal' */
    const rename = (name: string) => (name === "internal" ? "isInternal" : name);
    // TODO: can't make Encodable because params is type any
    // const makeEncodable = (name: string) => customTypes.includes(name) ? `${name}: Encodable` : name;

    const push = (name: string) => {
        indent = "    ".repeat(stack.length);
        out.push(`${indent}public struct ${name} {`);
        stack.push({ name });
        indent = "    ".repeat(stack.length);
        braceDepth++;
    };
    const pop = () => {
        if (!stack.length) return;
        stack.pop();
        indent = "    ".repeat(stack.length);
        out.push(`${indent}}`);
        braceDepth--;
    };

    for (const raw of lines) {
        let line = raw.trim();
        if (!line) continue;

        /* skip bodies of dictionary-alias or partial-alias */
        if (skipDictBody) {
            if (line.startsWith("}")) skipDictBody = false;
            continue;
        }
        if (skipTypeBody) {
            if (line.startsWith("};") || line === "}") skipTypeBody = false;
            continue;
        }

        /* ── export type (one line) ─────────────────────────── */
        const oneType = line.match(/^export\s+type\s+(\w+)\s*=\s*(.+);$/);
        if (oneType) {
            const name = oneType[1];
            let body   = oneType[2].trim();
            const p = body.match(/^Partial<\s*([^>]+?)\s*>\s*&/);
            if (p) body = p[1].trim();
            body = body.replace(/\s*&\s*\{[\s\S]*$/, "").trim();
            if (!excluded.has(name))
                out.push(`public typealias ${name} = ${tsTypeToSwift(body)}`);
            continue;
        }

        /* ── export type Name = Partial<X> & {  (multi-line) ─── */
        const openPartial = line.match(
            /^export\s+type\s+(\w+)\s*=\s*Partial<\s*([^>]+?)\s*>\s*&\s*\{$/
        );
        if (openPartial) {
            const alias = openPartial[1];
            const base  = openPartial[2].trim();
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = ${tsTypeToSwift(base)}`);
            skipTypeBody = true;
            continue;
        }

        /* ── interface Name extends Dictionary<T> { … } ─────── */
        const dict = line.match(
            /^export\s+interface\s+(\w+)\s+extends\s+Dictionary\s*<\s*([^>]+?)\s*>\s*(\{)?\s*$/
        );
        if (dict) {
            const alias = dict[1];
            const inner = tsTypeToSwift(dict[2].trim());
            if (!excluded.has(alias))
                out.push(`public typealias ${alias} = [String: ${inner}]`);
            if (dict[3] === "{") skipDictBody = true;
            continue;
        }

        /* ── interface start (export optional) ───────────────── */
        const iface = line.match(/^(?:export\s+)?interface\s+(\w+)/);
        if (iface) {
            const name = iface[1];
            if (!excluded.has(name)) push(name);
            continue;
        }

        /* ── nested object  'foo': {  ───────────────────────── */
        const obj = line.match(/^['"]?(\w+)['"]?\??:\s*\{$/);
        if (obj) {
            const field = rename(obj[1]);
            const structName = field[0].toUpperCase() + field.slice(1);
            if (braceDepth === stack.length)
                out.push(`${indent}public var ${field}: ${structName}`);
            push(structName);
            continue;
        }

        /* ── closing brace ──────────────────────────────────── */
        if (line.startsWith("}")) {
            pop();
            continue;
        }

        /* ── ordinary field ( ; or , ) ─────────────────────── */
        const fld = line.match(/^['"]?(\w+)['"]?\??:\s*([^;,]+)[;,]?$/);
        if (fld && stack.length) {
            const name      = rename(fld[1]);
            const swiftType = tsTypeToSwift(fld[2]);
            const optional  = fld[0].includes("?") || swiftType.endsWith("?");
            out.push(`${indent}public var ${name}: ${swiftType}${optional ? "" : ""}`);
        }
    }

    /* write generated Swift types */
    fs.writeFileSync(swiftTypesFile, generatedHeader, "utf8");
    fs.appendFileSync(swiftTypesFile, out.join("\n"), "utf8");
}

const goMethodDeclaration = (methodName: string, params: {[key: string]: [string, string | null]}) => {
    const arrayParams: string[] = [];
    const customTypeParams: string[] = [];
    const callParams: string[] = [];
    const headerParams: string[] = [];
    Object.keys(params).forEach((paramName: string) => {
        const [paramType, defaultValue] = params[paramName];
        if (defaultValue !== 'undefined') {
            if (paramName === 'type') {
                paramName = 'typeVar';
            }
            let newName = paramName;
            let goType = tsTypeToGo(paramType)
            if (customTypes.includes(paramType)) {
                customTypeParams.push(paramName);
                newName = `${paramName}_object`;
                goType = 'string';
            } else if (paramType.includes('[]')) {
                arrayParams.push(paramName);
                newName = `${paramName}_arr`;
                goType = 'string';
            }
            headerParams.push(`${paramName} ${goType}`);
            callParams.push(newName);
        }
    });
    const capsMethodName = capitalize(methodName);
    const sep = "\n\t\t";
    const customTypeParamsCode = prefix(customTypeParams, sep) + customTypeParams.map(paramName => `${paramName}_object := ParseJSON(${paramName})`).join(sep);  // stringify custom types
    // const arrayParamsCode = prefix(arrayParams, sep) + arrayParams.map(paramName => `${paramName}_arr := strings.Split(${paramName}, ",")`).join(sep);  // stringify custom types  // probably unnecessary, as the array parameters are already strings
    return `
    func (e *CCXTGoExchange) ${capsMethodName}(${headerParams.join(", ")}) ([]byte, error) {${customTypeParamsCode}
        res := <-e.exchange.${capsMethodName}(${callParams.join(', ')})
        if err, ok := res.(error); ok {
            return nil, err
        }
        return json.Marshal(res)
    }`
}

const swiftMethodDeclaration = (methodName: string, params: {[key: string]: [string, string | null]}, returnType: string) => {
    const swiftReturnType = tsTypeToSwift(returnType);
    const guardClause = (swiftReturnType === 'Any') ? `` : `as? ${swiftReturnType}`;
    const swiftParams = Object.keys(params).map(key => {
        const [tsType, defaultValue] = params[key];
        const paramType = tsTypeToSwift(tsType);
        return defaultValue === null
            ? `${key}: ${paramType}`
            : `${key}: ${paramType} = ${defaultValue
                .replace(/undefined/g, 'nil')
                .replace(/{}/g, '[:]')}`
                .replace(/params\:\s*Any\b/g, 'params: [String: Any]')
                .replace(/'/g, '"');
    }).join(', ')
    const goCallParams: string[] = [];
    const optionalParams: string[] = [];
    const customTypeParams: string[] = [];
    const arrayParams: string[] = [];
    let index = 0;
    Object.keys(params).forEach(paramName => {
        const [paramType, defaultValue] = params[paramName];
        const isArray = paramType.includes('[]');
        if (defaultValue === 'undefined') {
            optionalParams.push(paramName);
        } else {
            let newName = paramName;
            if (customTypes.includes(paramType)) {
                customTypeParams.push(paramName);
                newName = `${paramName}_string`;
            } else if (isArray) {
                arrayParams.push(paramName);
                newName = `${paramName}_string`;
            }
            const externalName = (index === 0) ? '' : `${paramName}: `.replace(/type/g, 'typeVar'); // type is a reserved word in Go, so we need to rename it to typeVar
            const assertion = (paramName === 'params') ? ((optionalParams.length > 0) ? 'Copy as! Data' : ' as! Data') : '';
            goCallParams.push(`${externalName}${newName}${assertion}`);
            index += 1;
        }
    });
    const sep = "\n\t\t\t";
    let optionalsCode = '';
    if (optionalParams.length > 0){
        optionalsCode = `${sep}var paramsCopy: [String: Any] = params`;
    }
    optionalsCode += prefix(optionalParams, sep) + optionalParams.map(paramName => `paramsCopy["${paramName}"] = ${paramName}`).join(sep); // Adds optional parameters to params
    const customTypeParamsCode = prefix(customTypeParams, sep) + customTypeParams.map(paramName => `let ${paramName}_string = stringify(${paramName})`).join(sep);  // stringify custom types
    const arrayParamsCode = prefix(arrayParams, sep) + arrayParams.map(paramName => `let ${paramName}_string = ${paramName}.joined(separator: ",")`).join(sep);  // convert array parameters to comma separated strings
    return`
    public func ${methodName} (${swiftParams}) throws -> ${swiftReturnType} {
        do {${optionalsCode}${customTypeParamsCode}${arrayParamsCode}
            let data = try exchange.${methodName}(${goCallParams.join(', ')})
            guard let result = cleanAny(data) ${guardClause} else {
                throw NSError(domain: "CCXT", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid response type for ${methodName}"])
            }
            return result
        } catch {
            throw error
        }
    }
`
}

const exchangeDeclaration = (exchangeName: string) => (`
public class ${capitalize(exchangeName)}: CCXTExchange {
    public init?(configJson: String) {
        super.init(exchangeName: "${exchangeName}", configJson: configJson)
    }
}`);

function createExchangeClasses() {
    const exchangeDeclarations: string[] = [];
    for (const exchangeName of ccxt.exchanges) {
        exchangeDeclarations.push(exchangeDeclaration(exchangeName));
    }
    fs.writeFileSync(swiftExchangesFile, `${generatedHeader}import Foundation\nimport CCXT\n`, "utf8");
    fs.appendFileSync(swiftExchangesFile, exchangeDeclarations.join("\n"), "utf8");
}

function getTypescriptHeaders(): [string, {[key: string]: [string, string | null]}, string][] {
    // Initialize empty array for results
    const results: [string, {[key: string]: [string, string | null]}, string][] = [];
    
    // Get the allowed method names
    const allowedMethods = new Set(getMethodNames());
    
    // Read the typescript file content
    const src = fs.readFileSync(tsExchangeFile, "utf8");
    
    // Match method declarations
    const methodRegex = /async\s+(\w+)\s*\(([\s\S]*?)\)\s*(?::\s*Promise\s*<\s*([\w\[\]]+)\s*>)?/g;
    
    let match;
    while ((match = methodRegex.exec(src)) !== null) {
        const methodName = match[1];
        
        // Skip if method is not in allowedMethods
        if (!allowedMethods.has(methodName)) {
            continue;
        }
        
        const params = match[2].trim();
        const returnType = match[3]?.trim() ?? "Any";
        
        // Initialize parameter dictionary for this method
        const paramDict: {[key: string]: [string, string | null]} = {};
        
        // Split parameters and process each one
        if (params) {
            const paramList = params.split(/,(?![^{]*})(?![^\[]*\])/).map(p => p.trim());
            
            for (const param of paramList) {
                // Match: name?: type = defaultValue
                const paramMatch = param.match(/^(\w+)(\?)?(?::\s*([^=]+))?\s*(?:=\s*(.+))?$/);
                if (paramMatch) {
                    const [, name, optional, type = 'any', defaultValue] = paramMatch;
                    const finalType = (type.trim() + (optional ? '?' : '')).replace(/\s+/g, '');
                    paramDict[name] = [finalType, defaultValue?.trim() || null];
                }
            }
        }
        
        results.push([methodName, paramDict, returnType]);
    }
    
    return results;
}

function main() {

    const injectAfterString = '// METHODS BELOW THIS LINE ARE TRANSPILED';
    const injectAfterRegex = new RegExp(`(${injectAfterString})([\\s\\S]*)`, 'm');


    const swiftMethodDeclarations: string[] = [];
    const goMethodDeclarations: string[] = [];
    createSwiftTypes();
    createExchangeClasses();
    const headers = getTypescriptHeaders();
    for (const [methodName, params, returnType] of headers) {
        if ([
            // TODO: couldnt add these methods to go_interface.go, add them so that they can be used in Swift
            'cancelAllOrdersWs',
            'cancelOrdersWs',
            'cancelOrderWs',
            'createLimitBuyOrderWs',
            'createLimitOrderWs',
            'createLimitSellOrderWs',
            'createMarketBuyOrderWs',
            'createMarketOrderWithCost',
            'createMarketOrderWithCostWs',
            'createMarketOrderWs',
            'createMarketSellOrderWs',
            'createOrderWithTakeProfitAndStopLossWs',
            'createOrderWs',
            'createPostOnlyOrder',
            'createPostOnlyOrderWs',
            'createReduceOnlyOrder',
            'createReduceOnlyOrderWs',
            'createStopLossOrderWs',
            'createTakeProfitOrderWs',
            'createTrailingAmountOrderWs',
            'createTrailingPercentOrderWs',
            'createTriggerOrderWs',
            'editOrderWs',
            'editOrderWs',
            'fetchBalanceWs',
            'fetchClosedOrdersWs',
            'fetchCurrenciesWs',
            'fetchDepositsWs',
            'fetchIndexOHLCV',
            'fetchMarketsWs',
            'fetchMyTradesWs',
            'fetchOHLCVWs',
            'fetchOpenOrdersWs',
            'fetchOrderBookWs',
            'fetchOrdersWs',
            'fetchOrderWs',
            'fetchPositionsForSymbolWs',
            'fetchPositionsWs',
            'fetchPositionWs',
            'fetchTickersWs',
            'fetchTickerWs',
            'fetchTradesWs',
            'fetchTradingFeesWs',
            'fetchTransactionFee',
            'fetchWithdrawalsWs',
            'watchBalance',
            'watchBidsAsks',
            'createStopOrder',
            'createStopOrderWs',
            'createStopLimitOrder',
            'createStopLimitOrderWs',
            'createStopMarketOrder',
            'createStopMarketOrderWs',
            'fetchMarkOHLCV',
            'fetchPremiumIndexOHLCV',
            'watchLiquidations',
            'watchLiquidationsForSymbols',
            'watchMyLiquidations',
            'watchMyLiquidationsForSymbols',
            'watchMyTrades',
            'watchOHLCV',
            'watchOHLCVForSymbols',
            'watchOrderBook',
            'watchOrderBookForSymbols',
            'watchOrders',
            'watchOrdersForSymbols',
            'watchPosition',
            'watchPositions',
            'watchTicker',
            'watchTickers',
            'watchTrades',
            'watchTradesForSymbols',

            // TODO: don't know how to make types encodable with params as type any
            'createOrders',
            'editOrders'
        ].includes(methodName)) {
            continue;
        } else {
            swiftMethodDeclarations.push(swiftMethodDeclaration(methodName, params, returnType));
            goMethodDeclarations.push(goMethodDeclaration(methodName, params));
        }
    }

    const loopItems: [string, string[]][] = [
        [swiftExchangeFile, swiftMethodDeclarations],
        [gowrapperFile, goMethodDeclarations]
    ];

    loopItems.forEach(([file, methodDeclarations]) => {
        const fileContent = fs.readFileSync(file, 'utf8');
        const newFileContent = fileContent.replace(
            injectAfterRegex,
            `$1\n${methodDeclarations.join('\n')}`
        );
        fs.writeFileSync(file, newFileContent);
    })
    fs.appendFileSync(swiftExchangeFile, '\n}');
}


main()
