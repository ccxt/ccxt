(()=>{"use strict";var e={4426:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4523:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},566:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3971:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},335:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4619:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3885:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2308:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5625:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9332:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},6740:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1578:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9152:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3974:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1466:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8186:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7202:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8800:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9656:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5223:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8535:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8716:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1560:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5254:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1769:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9644:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3829:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2317:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8430:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1293:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5465:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5661:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1552:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2609:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2938:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5277:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2948:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8109:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1671:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},6658:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4935:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9360:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4295:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8093:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7227:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4012:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9420:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1352:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7418:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3434:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9722:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},706:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1180:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8617:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2394:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9023:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5893:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},359:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4558:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2459:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1359:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3548:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3942:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(1397);class r extends i.A{}const a=r},6944:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},121:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},575:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7533:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3893:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},6928:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9174:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3414:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},1426:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7774:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9886:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5531:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3800:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},9401:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7849:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},2134:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8563:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4158:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7733:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4025:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},995:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},334:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7999:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},4352:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},6405:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8139:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7698:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8646:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3965:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},7246:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5308:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3521:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},3578:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},8291:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},5517:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2961);class r extends i.k{}const a=r},6729:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4426),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"ace",name:"ACE",countries:["TW"],version:"v2",rateLimit:100,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!1,ws:!1},timeframes:{"1m":1,"5m":5,"10m":10,"30m":10,"1h":60,"2h":120,"4h":240,"8h":480,"12h":720,"1d":24,"1w":70,"1M":31},urls:{logo:"https://user-images.githubusercontent.com/1294454/216908003-fb314cf6-e66e-471c-b91d-1d86e4baaa90.jpg",api:{public:"https://ace.io/polarisex",private:"https://ace.io/polarisex/open"},www:"https://ace.io/",doc:["https://github.com/ace-exchange/ace-offical-api-docs"],fees:"https://helpcenter.ace.io/hc/zh-tw/articles/360018609132-%E8%B2%BB%E7%8E%87%E8%AA%AA%E6%98%8E"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["oapi/v2/list/tradePrice","oapi/v2/list/marketPair","open/v2/public/getOrderBook"]},private:{post:["v2/coin/customerAccount","v2/kline/getKline","v2/order/order","v2/order/cancel","v2/order/getOrderList","v2/order/showOrderStatus","v2/order/showOrderHistory","v2/order/getTradeList"]}},fees:{trading:{percentage:!0,maker:this.parseNumber("0.0005"),taker:this.parseNumber("0.001")}},options:{brokerId:"ccxt"},precisionMode:o.kb,exceptions:{exact:{2003:r.InvalidOrder,2004:r.InvalidOrder,2005:r.InvalidOrder,2021:r.InsufficientFunds,2036:r.InvalidOrder,2039:r.InvalidOrder,2053:r.InvalidOrder,2061:r.BadRequest,2063:r.InvalidOrder,9996:r.BadRequest,10012:r.AuthenticationError,20182:r.AuthenticationError,20183:r.InvalidOrder},broad:{}},commonCurrencies:{}})}async fetchMarkets(e={}){const t=await this.publicGetOapiV2ListMarketPair();return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"baseCurrencyId"),s=this.safeCurrencyCode(this.safeString(e,"base")),i=this.safeString(e,"quoteCurrencyId"),r=this.safeCurrencyCode(this.safeString(e,"quote")),a=s+"/"+r;return{id:this.safeString(e,"symbol"),uppercaseId:void 0,symbol:a,base:s,baseId:t,quote:r,quoteId:i,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:{amount:{min:this.safeNumber(e,"minLimitBaseAmount"),max:this.safeNumber(e,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}},precision:{price:this.parseNumber(this.parsePrecision(this.safeString(e,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(e,"basePrecision")))},active:void 0,created:void 0,info:e}}parseTicker(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeSymbol(s,t);return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"last_price"),last:this.safeString(e,"last_price"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"base_volume"),quoteVolume:this.safeString(e,"quote_volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.publicGetOapiV2ListTradePrice(t),r=s.id,a=this.safeDict(i,r,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetOapiV2ListTradePrice(),i=[],r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeMarket(t),o=this.safeDict(s,t,{}),n=this.parseTicker(o,a);i.push(n)}return this.filterByArrayTickers(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={quoteCurrencyId:i.quoteId,baseCurrencyId:i.baseId};void 0!==t&&(r.depth=t);const a=await this.publicGetOpenV2PublicGetOrderBook(this.extend(r,s)),o=this.safeDict(a,"attachment");return this.parseOrderBook(o,i.symbol,void 0,"bids","asks")}parseOHLCV(e,t=void 0){const s=this.safeString(e,"createTime");let i=this.parse8601(s);return void 0!==i&&(i-=288e5),[i,this.safeNumber(e,"openPrice"),this.safeNumber(e,"highPrice"),this.safeNumber(e,"lowPrice"),this.safeNumber(e,"closePrice"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={duration:this.timeframes[t],quoteCurrencyId:a.quoteId,baseCurrencyId:a.baseId};void 0!==i&&(o.limit=i),void 0!==s&&(o.startTime=s);const n=await this.privatePostV2KlineGetKline(this.extend(o,r)),d=this.safeList(n,"attachment",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",4:"canceled",5:"canceled"},e,void 0)}parseOrder(e,t=void 0){let s,i,r,a,o,n,d,h,c,l,u;if("string"==typeof e)s=e;else{if(s=this.safeString(e,"orderNo"),i=this.safeInteger(e,"orderTimeStamp"),void 0===i){const t=this.safeString(e,"orderTime");void 0!==t&&(i=this.parse8601(t),i-=288e5)}const t=this.safeString(e,"buyOrSell");void 0!==t&&(n="1"===t?"buy":"sell"),o=this.safeString(e,"num"),a=this.safeString(e,"price");const p=this.safeString(e,"quoteCurrencyName"),f=this.safeString(e,"baseCurrencyName");void 0!==p&&void 0!==f&&(r=f+"/"+p);const m=this.safeString(e,"type");void 0!==m&&(d="1"===m?"limit":"market"),c=this.safeString(e,"tradeNum"),l=this.safeString(e,"remainNum"),h=this.parseOrderStatus(this.safeString(e,"status")),u=this.safeString(e,"averagePrice")}return this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:r,type:d,timeInForce:void 0,postOnly:void 0,side:n,price:a,stopPrice:void 0,amount:o,cost:void 0,average:u,filled:c,remaining:l,status:h,fee:void 0,trades:void 0,info:e},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=t.toUpperCase(),d=s.toUpperCase(),h={baseCurrencyId:o.baseId,quoteCurrencyId:o.quoteId,type:"LIMIT"===n?1:2,buyOrSell:"BUY"===d?1:2,num:this.amountToPrecision(e,i)};"limit"===t&&(h.price=this.priceToPrecision(e,r));const c=await this.privatePostV2OrderOrder(this.extend(h,a)),l=this.safeDict(c,"attachment");return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderNo:e};return await this.privatePostV2OrderCancel(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderNo:e},r=await this.privatePostV2OrderShowOrderStatus(this.extend(i,s)),a=this.safeDict(r,"attachment");return this.parseOrder(a,void 0)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={quoteCurrencyId:a.quoteId,baseCurrencyId:a.baseId};void 0!==s&&(o.size=s);const n=await this.privatePostV2OrderGetOrderList(this.extend(o,i)),d=this.safeList(n,"attachment");return this.parseOrders(d,a,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeNo"),i=this.safeString(e,"price"),r=this.safeString(e,"num");let o=this.safeInteger(e,"tradeTimestamp");if(void 0===o){const t=this.safeString2(e,"time","tradeTime");o=this.parse8601(t),o-=288e5}let n=t.symbol;const d=this.safeString(e,"quoteCurrencyName"),h=this.safeString(e,"baseCurrencyName");let c;void 0!==d&&void 0!==h&&(n=h+"/"+d);const l=this.safeInteger(e,"buyOrSell");void 0!==l&&(c=1===l?"buy":"sell");const u=this.safeString(e,"fee");let p;if(void 0!==u){const t=this.safeString(e,"feeSave");p={cost:a.Y.stringSub(u,t),currency:d}}return this.safeTrade({info:e,id:s,order:this.safeString(e,"orderNo"),symbol:n,side:c,type:void 0,takerOrMaker:void 0,price:i,amount:r,cost:void 0,fee:p,timestamp:o,datetime:this.iso8601(o)},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.safeMarket(t),o={orderNo:e},n=await this.privatePostV2OrderShowOrderHistory(this.extend(o,r)),d=this.safeDict(n,"attachment"),h=this.safeList(d,"trades",[]);return this.parseTrades(h,a,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeMarket(e),a={};void 0!==r.id&&(a.quoteCurrencyId=r.quoteId,a.baseCurrencyId=r.baseId),void 0!==s&&(a.size=s);const o=await this.privatePostV2OrderGetTradeList(this.extend(a,i)),n=this.safeList(o,"attachment",[]);return this.parseTrades(n,r,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currencyName"),a=this.safeCurrencyCode(r),o=this.safeString(i,"amount"),n={free:this.safeString(i,"cashAmount"),total:o};t[a]=n}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV2CoinCustomerAccount(e),s=this.safeList(t,"attachment",[]);return this.parseBalance(s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if(void 0===r&&(r={}),"private"===t){this.checkRequiredCredentials();const e=this.milliseconds();let t="ACE_SIGN"+this.secret;const o=this.extend({apiKey:this.apiKey,timeStamp:this.numberToString(e)},i),d=this.keysort(o),h=Object.values(d),c=[];for(let e=0;e<h.length;e++){const t=h[e].toString();c.push(t)}t+=c.join("");const l=this.hash(this.encode(t),n.s,"hex");if(o.signKey=l,r={"Content-Type":"application/x-www-form-urlencoded"},"POST"===s){const e=this.safeString(this.options,"brokerId");void 0!==e&&(r.Referer=e)}a=this.urlencode(o)}else"public"===t&&"GET"===s&&Object.keys(d).length&&(o+="?"+this.urlencode(d));return o=this.urls.api[t]+o,{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(void 0===o)return;const h=this.id+" "+a,c=this.safeNumber(o,"status",200);if(c>200){const e=c.toString();this.throwExactlyMatchedException(this.exceptions.exact,e,h),this.throwBroadlyMatchedException(this.exceptions.broad,e,h)}}}},7930:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4523),r=s(2079),a=s(1579);class o extends i.A{describe(){return this.deepExtend(super.describe(),{id:"alpaca",name:"Alpaca",countries:["US"],rateLimit:333,hostname:"alpaca.markets",pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/187234005-b864db3d-f1e3-447a-aaf9-a9fc7b955d07.jpg",www:"https://alpaca.markets",api:{broker:"https://broker-api.{hostname}",trader:"https://api.{hostname}",market:"https://data.{hostname}"},test:{broker:"https://broker-api.sandbox.{hostname}",trader:"https://paper-api.{hostname}",market:"https://data.sandbox.{hostname}"},doc:"https://alpaca.markets/docs/",fees:"https://docs.alpaca.markets/docs/crypto-fees"},has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,fetchBalance:!1,fetchBidsAsks:!1,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRates:!1,fetchL1OrderBook:!0,fetchL2OrderBook:!1,fetchMarkets:!0,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!1},api:{broker:{},trader:{private:{get:["v2/account","v2/orders","v2/orders/{order_id}","v2/positions","v2/positions/{symbol_or_asset_id}","v2/account/portfolio/history","v2/watchlists","v2/watchlists/{watchlist_id}","v2/watchlists:by_name","v2/account/configurations","v2/account/activities","v2/account/activities/{activity_type}","v2/calendar","v2/clock","v2/assets","v2/assets/{symbol_or_asset_id}","v2/corporate_actions/announcements/{id}","v2/corporate_actions/announcements"],post:["v2/orders","v2/watchlists","v2/watchlists/{watchlist_id}","v2/watchlists:by_name"],put:["v2/watchlists/{watchlist_id}","v2/watchlists:by_name"],patch:["v2/orders/{order_id}","v2/account/configurations"],delete:["v2/orders","v2/orders/{order_id}","v2/positions","v2/positions/{symbol_or_asset_id}","v2/watchlists/{watchlist_id}","v2/watchlists:by_name","v2/watchlists/{watchlist_id}/{symbol}"]}},market:{public:{get:["v1beta3/crypto/{loc}/bars","v1beta3/crypto/{loc}/latest/bars","v1beta3/crypto/{loc}/latest/orderbooks","v1beta3/crypto/{loc}/latest/quotes","v1beta3/crypto/{loc}/latest/trades","v1beta3/crypto/{loc}/quotes","v1beta3/crypto/{loc}/snapshots","v1beta3/crypto/{loc}/trades"]},private:{get:["v1beta1/corporate-actions","v1beta1/forex/latest/rates","v1beta1/forex/rates","v1beta1/logos/{symbol}","v1beta1/news","v1beta1/screener/stocks/most-actives","v1beta1/screener/{market_type}/movers","v2/stocks/auctions","v2/stocks/bars","v2/stocks/bars/latest","v2/stocks/meta/conditions/{ticktype}","v2/stocks/meta/exchanges","v2/stocks/quotes","v2/stocks/quotes/latest","v2/stocks/snapshots","v2/stocks/trades","v2/stocks/trades/latest","v2/stocks/{symbol}/auctions","v2/stocks/{symbol}/bars","v2/stocks/{symbol}/bars/latest","v2/stocks/{symbol}/quotes","v2/stocks/{symbol}/quotes/latest","v2/stocks/{symbol}/snapshot","v2/stocks/{symbol}/trades","v2/stocks/{symbol}/trades/latest"]}}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1H","2h":"2H","4h":"4H","6h":"6H","8h":"8H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},precisionMode:a.kb,requiredCredentials:{apiKey:!0,secret:!0},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0015"),taker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0022")],[this.parseNumber("500000"),this.parseNumber("0.0020")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("10000000"),this.parseNumber("0.0015")],[this.parseNumber("25000000"),this.parseNumber("0.0013")],[this.parseNumber("50000000"),this.parseNumber("0.0012")],[this.parseNumber("100000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("500000"),this.parseNumber("0.001")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("10000000"),this.parseNumber("0.0005")],[this.parseNumber("25000000"),this.parseNumber("0.0002")],[this.parseNumber("50000000"),this.parseNumber("0.0002")],[this.parseNumber("100000000"),this.parseNumber("0.00")]]}}},headers:{"APCA-PARTNER-ID":"ccxt"},options:{defaultExchange:"CBSE",exchanges:["CBSE","FTX","GNSS","ERSX"],defaultTimeInForce:"gtc",clientOrderId:"ccxt_{id}"},exceptions:{exact:{"forbidden.":r.PermissionDenied,4041e4:r.InvalidOrder,40010001:r.BadRequest,4011e4:r.PermissionDenied,4031e4:r.InsufficientFunds,4291e4:r.RateLimitExceeded},broad:{"Invalid format for parameter":r.BadRequest,"Invalid symbol":r.BadSymbol}}})}async fetchTime(e={}){const t=await this.traderPrivateGetV2Clock(e),s=this.safeString(t,"timestamp"),i=s.slice(0,23),r=s.length-6,a=s.length-3,o=s.slice(r,a);return this.parse8601(i)-3600*this.parseToNumeric(o)*1e3}async fetchMarkets(e={}){const t=await this.traderPrivateGetV2Assets(this.extend({asset_class:"crypto",status:"active"},e));return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"symbol"),s=t.split("/"),i=this.safeString(e,"class"),r=this.safeString(s,0),a=this.safeString(s,1),o=this.safeCurrencyCode(r);let n=this.safeCurrencyCode(a);void 0===n&&"us_equity"===i&&(n="USD");const d=o+"/"+n,h="active"===this.safeString(e,"status"),c=this.safeNumber(e,"min_order_size");return{id:t,symbol:d,base:o,quote:n,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"min_trade_increment"),price:this.safeNumber(e,"price_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:c,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e),o=a.id,n=this.safeString(i,"loc","us"),d=this.safeString(i,"method","marketPublicGetV1beta3CryptoLocTrades"),h={symbols:o,loc:n};let c;if(i=this.omit(i,["loc","method"]),"marketPublicGetV1beta3CryptoLocTrades"===d){void 0!==t&&(h.start=this.iso8601(t)),void 0!==s&&(h.limit=s);const e=await this.marketPublicGetV1beta3CryptoLocTrades(this.extend(h,i)),r=this.safeDict(e,"trades",{});c=this.safeList(r,o,[])}else{if("marketPublicGetV1beta3CryptoLocLatestTrades"!==d)throw new r.NotSupported(this.id+" fetchTrades() does not support "+d+", marketPublicGetV1beta3CryptoLocTrades and marketPublicGetV1beta3CryptoLocLatestTrades are supported");{const e=await this.marketPublicGetV1beta3CryptoLocLatestTrades(this.extend(h,i)),t=this.safeDict(e,"trades",{});c=this.safeDict(t,o,{}),c=[c]}}return this.parseTrades(c,a,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=i.id,a={symbols:r,loc:this.safeString(s,"loc","us")},o=await this.marketPublicGetV1beta3CryptoLocLatestOrderbooks(this.extend(a,s)),n=this.safeDict(o,"orderbooks",{}),d=this.safeDict(n,r,{}),h=this.parse8601(this.safeString(d,"t"));return this.parseOrderBook(d,i.symbol,h,"b","a","p","s")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=o.id,d=this.safeString(a,"loc","us"),h=this.safeString(a,"method","marketPublicGetV1beta3CryptoLocBars"),c={symbols:n,loc:d};let l;if(a=this.omit(a,["loc","method"]),"marketPublicGetV1beta3CryptoLocBars"===h){void 0!==i&&(c.limit=i),void 0!==s&&(c.start=this.yyyymmdd(s)),c.timeframe=this.safeString(this.timeframes,t,t);const e=await this.marketPublicGetV1beta3CryptoLocBars(this.extend(c,a)),r=this.safeDict(e,"bars",{});l=this.safeList(r,n,[])}else{if("marketPublicGetV1beta3CryptoLocLatestBars"!==h)throw new r.NotSupported(this.id+" fetchOHLCV() does not support "+h+", marketPublicGetV1beta3CryptoLocBars and marketPublicGetV1beta3CryptoLocLatestBars are supported");{const e=await this.marketPublicGetV1beta3CryptoLocLatestBars(this.extend(c,a)),t=this.safeDict(e,"bars",{});l=this.safeDict(t,n,{}),l=[l]}}return this.parseOHLCVs(l,o,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"t");return[this.parse8601(s),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={symbol:n.id,qty:this.amountToPrecision(e,i),side:s,type:t},h=this.safeStringN(o,["triggerPrice","stop_price"]);if(void 0!==h){let s;if(!(t.indexOf("limit")>=0))throw new r.NotSupported(this.id+" createOrder() does not support stop orders for "+t+" orders, only stop_limit orders are supported");s="stop_limit",d.stop_price=this.priceToPrecision(e,h),d.type=s}t.indexOf("limit")>=0&&(d.limit_price=this.priceToPrecision(e,a));const c=this.safeString(this.options,"defaultTimeInForce");d.time_in_force=this.safeString(o,"timeInForce",c),o=this.omit(o,["timeInForce","triggerPrice"]);const l=this.safeString(this.options,"clientOrderId"),u=this.uuid().split("-").join(""),p=this.implodeParams(l,{id:u}),f=this.safeString(o,"clientOrderId",p);d.client_order_id=f,o=this.omit(o,["clientOrderId"]);const m=await this.traderPrivatePostV2Orders(this.extend(d,o));return this.parseOrder(m,n)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},r=await this.traderPrivateDeleteV2OrdersOrderId(this.extend(i,s));return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.traderPrivateDeleteV2Orders(t);return Array.isArray(s)?this.parseOrders(s,void 0):[this.safeOrder({info:s})]}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.traderPrivateGetV2OrdersOrderId(this.extend(i,s)),a=this.safeString(r,"symbol"),o=this.safeMarket(a);return this.parseOrder(r,o)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={status:"all"};let a;void 0!==e&&(a=this.market(e),r.symbols=a.id);const o=this.safeInteger(i,"until");void 0!==o&&(i=this.omit(i,"until"),r.endTime=o),void 0!==t&&(r.after=t),void 0!==s&&(r.limit=s);const n=await this.traderPrivateGetV2Orders(this.extend(r,i));return this.parseOrders(n,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"open"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"closed"},i))}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString(e,"status"),a=this.parseOrderStatus(r),o=this.safeString(e,"commission");let n;void 0!==o&&(n={cost:o,currency:"USD"});let d=this.safeString(e,"order_type");void 0!==d&&d.indexOf("limit")>=0&&(d="limit");const h=this.safeString(e,"submitted_at"),c=this.parse8601(h);return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:c,datetime:h,lastTradeTimeStamp:void 0,status:a,symbol:i,type:d,timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:void 0,side:this.safeString(e,"side"),price:this.safeNumber(e,"limit_price"),stopPrice:this.safeNumber(e,"stop_price"),triggerPrice:this.safeNumber(e,"stop_price"),cost:void 0,average:this.safeNumber(e,"filled_avg_price"),amount:this.safeNumber(e,"qty"),filled:this.safeNumber(e,"filled_qty"),remaining:void 0,trades:void 0,fee:n,info:e},t)}parseOrderStatus(e){return this.safeString({pending_new:"open",accepted:"open",new:"open",partially_filled:"open",activated:"open",filled:"closed"},e,e)}parseTimeInForce(e){return this.safeString({day:"Day"},e,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"S"),i=this.safeSymbol(s,t),r=this.safeString(e,"t"),a=this.parse8601(r),o=this.safeString(e,"tks");let n;"B"===o?n="buy":"S"===o&&(n="sell");const d=this.safeString(e,"p"),h=this.safeString(e,"s");return this.safeTrade({info:e,id:this.safeString(e,"i"),timestamp:a,datetime:this.iso8601(a),symbol:i,order:void 0,type:void 0,side:n,takerOrMaker:"taker",price:d,amount:h,cost:void 0,fee:void 0},t)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.implodeParams(e,i),n=this.implodeHostname(this.urls.api[t[0]]);r=void 0!==r?r:{},"private"===t[1]&&(this.checkRequiredCredentials(),r["APCA-API-KEY-ID"]=this.apiKey,r["APCA-API-SECRET-KEY"]=this.secret);const d=this.omit(i,this.extractParams(e));return Object.keys(d).length&&("GET"===s||"DELETE"===s?o+="?"+this.urlencode(d):(a=this.json(d),r["Content-Type"]="application/json")),n+=o,{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.id+" "+o,l=this.safeString(n,"code");void 0!==e&&this.throwExactlyMatchedException(this.exceptions.exact,l,c);const u=this.safeValue(n,"message",void 0);if(void 0!==u)throw this.throwExactlyMatchedException(this.exceptions.exact,u,c),this.throwBroadlyMatchedException(this.exceptions.broad,u,c),new r.ExchangeError(c)}}},1411:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(566),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"ascendex",name:"AscendEX",countries:["SG"],rateLimit:400,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:"emulated",fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLeverage:"emulated",fetchLeverages:!0,fetchLeverageTiers:!0,fetchMarginMode:"emulated",fetchMarginModes:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,sandbox:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1d","1w":"1w","1M":"1m"},version:"v2",urls:{logo:"https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg",api:{rest:"https://ascendex.com"},test:{rest:"https://api-test.ascendex-sandbox.com"},www:"https://ascendex.com",doc:["https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"],fees:"https://ascendex.com/en/feerate/transactionfee-traderate",referral:{url:"https://ascendex.com/en-us/register?inviteCode=EL6BXBQM",discount:.25}},api:{v1:{public:{get:{assets:1,products:1,ticker:1,"barhist/info":1,barhist:1,depth:1,trades:1,"cash/assets":1,"cash/products":1,"margin/assets":1,"margin/products":1,"futures/collateral":1,"futures/contracts":1,"futures/ref-px":1,"futures/market-data":1,"futures/funding-rates":1,"risk-limit-info":1,"exchange-info":1}},private:{get:{info:1,"wallet/transactions":1,"wallet/deposit/address":1,"data/balance/snapshot":1,"data/balance/history":1},accountCategory:{get:{balance:1,"order/open":1,"order/status":1,"order/hist/current":1,risk:1},post:{order:1,"order/batch":1},delete:{order:1,"order/all":1,"order/batch":1}},accountGroup:{get:{"cash/balance":1,"margin/balance":1,"margin/risk":1,"futures/collateral-balance":1,"futures/position":1,"futures/risk":1,"futures/funding-payments":1,"order/hist":1,"spot/fee":1},post:{transfer:1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1}}}},v2:{public:{get:{assets:1,"futures/contract":1,"futures/collateral":1,"futures/pricing-data":1,"futures/ticker":1,"risk-limit-info":1}},private:{data:{get:{"order/hist":1}},get:{"account/info":1},accountGroup:{get:{"order/hist":1,"futures/position":1,"futures/free-margin":1,"futures/order/hist/current":1,"futures/funding-payments":1,"futures/order/open":1,"futures/order/status":1},post:{"futures/isolated-position-margin":1,"futures/margin-type":1,"futures/leverage":1,"futures/transfer/deposit":1,"futures/transfer/withdraw":1,"futures/order":1,"futures/order/batch":1,"futures/order/open":1,"subuser/subuser-transfer":1,"subuser/subuser-transfer-hist":1},delete:{"futures/order":1,"futures/order/batch":1,"futures/order/all":1}}}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:o.kb,options:{"account-category":"cash","account-group":void 0,fetchClosedOrders:{method:"v2PrivateDataGetOrderHist"},defaultType:"spot",accountsByType:{spot:"cash",swap:"futures",margin:"margin"},transfer:{fillResponseFromRequest:!0},networks:{BSC:"BEP20 (BSC)",ARB:"arbitrum",SOL:"Solana",AVAX:"avalanche C chain",OMNI:"Omni",TRX:"TRC20",TRC20:"TRC20",ERC20:"ERC20",GO20:"GO20",BEP2:"BEP2",BTC:"Bitcoin",BCH:"Bitcoin ABC",LTC:"Litecoin",MATIC:"Matic Network",AKT:"Akash"}},exceptions:{exact:{1900:r.BadRequest,2100:r.AuthenticationError,5002:r.BadSymbol,6001:r.BadSymbol,6010:r.InsufficientFunds,60060:r.InvalidOrder,600503:r.InvalidOrder,100001:r.BadRequest,100002:r.BadRequest,100003:r.BadRequest,100004:r.BadRequest,100005:r.BadRequest,100006:r.BadRequest,100007:r.BadRequest,100008:r.BadSymbol,100009:r.AuthenticationError,100010:r.BadRequest,100011:r.BadRequest,100012:r.BadRequest,100013:r.BadRequest,100101:r.ExchangeError,150001:r.BadRequest,200001:r.AuthenticationError,200002:r.ExchangeError,200003:r.ExchangeError,200004:r.ExchangeError,200005:r.ExchangeError,200006:r.ExchangeError,200007:r.ExchangeError,200008:r.ExchangeError,200009:r.ExchangeError,200010:r.AuthenticationError,200011:r.ExchangeError,200012:r.ExchangeError,200013:r.ExchangeError,200014:r.PermissionDenied,200015:r.PermissionDenied,300001:r.InvalidOrder,300002:r.InvalidOrder,300003:r.InvalidOrder,300004:r.InvalidOrder,300005:r.InvalidOrder,300006:r.InvalidOrder,300007:r.InvalidOrder,300008:r.InvalidOrder,300009:r.InvalidOrder,300011:r.InsufficientFunds,300012:r.BadSymbol,300013:r.InvalidOrder,300014:r.InvalidOrder,300020:r.InvalidOrder,300021:r.AccountSuspended,300031:r.InvalidOrder,310001:r.InsufficientFunds,310002:r.InvalidOrder,310003:r.InvalidOrder,310004:r.BadSymbol,310005:r.InvalidOrder,510001:r.ExchangeError,900001:r.ExchangeError},broad:{}},commonCurrencies:{BOND:"BONDED",BTCBEAR:"BEAR",BTCBULL:"BULL",BYN:"BeyondFi",PLN:"Pollen"}})}getAccount(e={}){const t=this.safeValue(e,"account",this.options.account).toLowerCase();return this.capitalize(t)}async fetchCurrencies(e={}){const t=await this.v1PublicGetAssets(e),s=await this.v1PublicGetMarginAssets(e),i=await this.v1PublicGetCashAssets(e),r=this.safeList(t,"data",[]),a=this.safeList(s,"data",[]),o=this.safeList(i,"data",[]),n=this.indexBy(r,"assetCode"),d=this.indexBy(a,"assetCode"),h=this.indexBy(o,"assetCode"),c=this.deepExtend(n,d,h),l=Object.keys(c),u={};for(let e=0;e<l.length;e++){const t=l[e],s=c[t],i=this.safeCurrencyCode(t),r=this.safeString2(s,"precisionScale","nativeScale"),a=this.parseNumber(this.parsePrecision(r)),o=this.safeNumber2(s,"withdrawFee","withdrawalFee"),n="Normal"===this.safeString2(s,"status","statusCode"),d="borrowAssetCode"in s;u[i]={id:t,code:i,info:s,type:void 0,margin:d,name:this.safeString(s,"assetName"),active:n,deposit:void 0,withdraw:void 0,fee:o,precision:a,limits:{amount:{min:a,max:void 0},withdraw:{min:this.safeNumber(s,"minWithdrawalAmt"),max:void 0}},networks:{}}}return u}async fetchMarkets(e={}){const t=await this.v1PublicGetProducts(e),s=await this.v1PublicGetCashProducts(e),i=await this.v2PublicGetFuturesContract(e),r=this.safeList(t,"data",[]),a=this.indexBy(r,"symbol"),o=this.safeList(s,"data",[]),n=this.safeList(i,"data",[]),d=this.arrayConcat(o,n),h=this.indexBy(d,"symbol"),c=this.deepExtend(a,h),l=Object.keys(c),u=[];for(let e=0;e<l.length;e++){const t=l[e],s=c[t],i=this.safeString(s,"settlementAsset"),r=this.safeCurrencyCode(i),a=this.safeString(s,"status"),o=this.safeString(s,"domain");let n=!1;"Normal"!==a&&"InternalTrading"!==a||"LeveragedETF"===o||(n=!0);const d=void 0===r,h=!d,p=!!h||void 0;let f,m=this.safeNumber(s,"minQty"),g=this.safeNumber(s,"maxQty"),v=this.safeNumber(s,"tickSize");const y=this.safeString2(s,"underlying","symbol").split("/"),w=this.safeString(y,0),b=this.safeString(y,1),S=this.safeCurrencyCode(w),k=this.safeCurrencyCode(b);let O=S+"/"+k;if(h){const e=this.safeDict(s,"lotSizeFilter");m=this.safeNumber(e,"minQty"),g=this.safeNumber(e,"maxQty");const t=this.safeDict(s,"priceFilter");v=this.safeNumber(t,"minPrice"),f=this.safeNumber(t,"maxPrice"),O=S+"/"+k+":"+r}const T=this.safeNumber(s,"commissionReserveRate"),P=this.safeBool(s,"marginTradable",!1);u.push({id:t,symbol:O,base:S,quote:k,settle:r,baseId:w,quoteId:b,settleId:i,type:h?"swap":"spot",spot:d,margin:d?P:void 0,swap:h,future:!1,option:!1,active:n,contract:h,linear:p,inverse:h?!p:void 0,taker:T,maker:T,contractSize:h?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(s,"lotSize"),price:this.safeNumber(s,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:m,max:g},price:{min:v,max:f},cost:{min:this.safeNumber(s,"minNotional"),max:this.safeNumber(s,"maxNotional")}},created:this.safeInteger(s,"tradingStartTime"),info:s})}return u}async fetchTime(e={}){const t={requestTime:this.milliseconds()},s=await this.v1PublicGetExchangeInfo(this.extend(t,e)),i=this.safeDict(s,"data",{});return this.safeInteger(i,"requestReceiveAt")}async fetchAccounts(e={}){let t,s=this.safeString(this.options,"account-group");if(void 0===s){t=await this.v1PrivateGetInfo(e);const i=this.safeDict(t,"data",{});s=this.safeString(i,"accountGroup"),this.options["account-group"]=s}return[{id:s,type:void 0,code:void 0,info:t}]}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeList(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeCurrencyCode(this.safeString(i,"asset")),a=this.account();a.free=this.safeString(i,"availableBalance"),a.total=this.safeString(i,"totalBalance"),t[r]=a}return this.safeBalance(t)}parseMarginBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeList(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeCurrencyCode(this.safeString(i,"asset")),o=this.account();o.free=this.safeString(i,"availableBalance"),o.total=this.safeString(i,"totalBalance");const n=this.safeString(i,"borrowed"),d=this.safeString(i,"interest");o.debt=a.Y.stringAdd(n,d),t[r]=o}return this.safeBalance(t)}parseSwapBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeDict(e,"data",{}),i=this.safeList(s,"collaterals",[]);for(let e=0;e<i.length;e++){const s=i[e],r=this.safeCurrencyCode(this.safeString(s,"asset")),a=this.account();a.total=this.safeString(s,"balance"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){let t,s;await this.loadMarkets(),await this.loadAccounts(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[s,e]=this.handleMarginModeAndParams("fetchBalance",e);t=this.safeBool(e,"margin",!1)||"cross"===s?"margin":t,e=this.omit(e,"margin");const i=this.safeDict(this.options,"accountsByType",{}),a=this.safeString(i,t,"cash"),o=this.safeDict(this.accounts,0,{}),n={"account-group":this.safeString(o,"id")};if("isolated"===s&&"swap"!==t)throw new r.BadRequest(this.id+" does not supported isolated margin trading");let d;if("cash"!==a&&"margin"!==a||(n["account-category"]=a),"spot"===t||"margin"===t)d=await this.v1PrivateAccountCategoryGetBalance(this.extend(n,e));else{if("swap"!==t)throw new r.NotSupported(this.id+" fetchBalance() is not currently supported for "+t+" markets");d=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(n,e))}return"swap"===t?this.parseSwapBalance(d):"margin"===t?this.parseMarginBalance(d):this.parseBalance(d)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id},r=await this.v1PublicGetDepth(this.extend(i,s)),a=this.safeDict(r,"data",{}),o=this.safeDict(a,"data",{}),n=this.safeInteger(o,"ts"),d=this.parseOrderBook(o,e,n);return d.nonce=this.safeInteger(o,"seqnum"),d}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i="spot"===this.safeString(e,"type")?"/":void 0,r=this.safeSymbol(s,t,i),a=this.safeString(e,"close"),o=this.safeList(e,"bid",[]),n=this.safeList(e,"ask",[]),d=this.safeString(e,"open");return this.safeTicker({symbol:r,timestamp:undefined,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(o,0),bidVolume:this.safeString(o,1),ask:this.safeString(n,0),askVolume:this.safeString(n,1),vwap:void 0,open:d,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.v1PublicGetTicker(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i,r,a;if(void 0!==e){const t=this.safeString(e,0);i=this.market(t);const r=this.marketIds(e);s.symbol=r.join(",")}[r,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),a="spot"===r?await this.v1PublicGetTicker(this.extend(s,t)):await this.v2PublicGetFuturesTicker(this.extend(s,t));const o=this.safeList(a,"data",[]);return Array.isArray(o)?this.parseTickers(o,e):this.parseTickers([o],e)}parseOHLCV(e,t=void 0){const s=this.safeDict(e,"data",{});return[this.safeInteger(s,"ts"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,interval:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t),d=this.safeDict(this.options,"fetchOHLCV",{}),h=this.safeInteger(d,"limit",500);void 0!==s?(o.from=s,i=void 0===i?h:Math.min(i,h),o.to=this.sum(s,i*n*1e3,1)):void 0!==i&&(o.n=i);const c=await this.v1PublicGetBarhist(this.extend(o,r)),l=this.safeList(c,"data",[]);return this.parseOHLCVs(l,a,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString2(e,"price","p"),r=this.safeString(e,"q"),a=this.safeBool(e,"bm",!1)?"sell":"buy";return t=this.safeMarket(void 0,t),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:void 0,order:void 0,type:void 0,takerOrMaker:void 0,side:a,price:i,amount:r,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.n=s);const o=await this.v1PublicGetTrades(this.extend(a,i)),n=this.safeDict(o,"data",{}),d=this.safeList(n,"data",[]);return this.parseTrades(d,r,t,s)}parseOrderStatus(e){return this.safeString({PendingNew:"open",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",Rejected:"rejected"},e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t,"/");let a=this.safeInteger2(e,"timestamp","sendingTime");const o=this.safeInteger(e,"lastExecTime");void 0===a&&(a=o);const n=this.safeString(e,"price"),d=this.safeString(e,"orderQty"),h=this.safeString(e,"avgPx"),c=this.safeStringN(e,["cumFilledQty","cumQty","fillQty"]),l=this.safeString(e,"orderId");let u=this.safeString(e,"id");void 0!==u&&u.length<1&&(u=void 0);const p=this.safeStringLower(e,"orderType");let f=p;void 0!==p&&("stoplimit"===p&&(f="limit"),"stopmarket"===p&&(f="market"));const m=this.safeStringLower(e,"side"),g=this.safeNumber2(e,"cumFee","fee");let v;if(void 0!==g){const t=this.safeString(e,"feeAsset");v={cost:g,currency:this.safeCurrencyCode(t)}}const y=this.omitZero(this.safeString(e,"stopPrice"));let w;const b=this.safeString(e,"execInst");let S;return"reduceOnly"===b&&(w=!0),"Post"===b&&(S=!0),this.safeOrder({info:e,id:l,clientOrderId:u,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:o,symbol:r,type:f,timeInForce:void 0,postOnly:S,reduceOnly:w,side:m,price:n,stopPrice:y,triggerPrice:y,amount:d,cost:void 0,average:h,filled:c,remaining:void 0,status:s,fee:v,trades:void 0},t)}async fetchTradingFees(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.safeDict(this.accounts,0,{}),s={"account-group":this.safeString(t,"id")},i=await this.v1PrivateAccountGroupGetSpotFee(this.extend(s,e)),r=this.safeDict(i,"data",{}),a=this.safeList(r,"fees",[]),o={};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s,void 0,"/"),r=this.safeDict(t,"fee",{});o[i]={info:t,symbol:i,maker:this.safeNumber(r,"maker"),taker:this.safeNumber(r,"taker"),percentage:void 0,tierBased:void 0}}return o}createOrderRequest(e,t,s,i,r=void 0,a={}){const o=this.market(e);let n,d;[n,a]=this.handleMarginModeAndParams("createOrderRequest",a),[d,a]=this.handleMarketTypeAndParams("createOrderRequest",o,a);const h=this.safeDict(this.options,"accountsByType",{});let c=this.safeString(h,d,"cash");void 0!==n&&(c="margin");const l=this.safeDict(this.accounts,0,{}),u=this.safeString(l,"id"),p=this.safeString2(a,"clientOrderId","id"),f={"account-group":u,"account-category":c,symbol:o.id,time:this.milliseconds(),orderQty:this.amountToPrecision(e,i),orderType:t,side:s},m="market"===t||"stop_market"===t,g="limit"===t||"stop_limit"===t,v=this.safeString(a,"timeInForce"),y=this.isPostOnly(m,!1,a),w=this.safeBool(a,"reduceOnly",!1),b=this.safeString2(a,"triggerPrice","stopPrice");return g&&(f.orderPrice=this.priceToPrecision(e,r)),"IOC"===v&&(f.timeInForce="IOC"),"FOK"===v&&(f.timeInForce="FOK"),y&&(f.postOnly=!0),void 0!==b&&(f.stopPrice=this.priceToPrecision(e,b),g?f.orderType="stop_limit":m&&(f.orderType="stop_market")),void 0!==p&&(f.id=p),o.spot?void 0!==c&&(f.category=c):(f["account-category"]=c,w&&(f.execInst="ReduceOnly"),y&&(f.execInst="Post")),a=this.omit(a,["reduceOnly","triggerPrice"]),this.extend(f,a)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets(),await this.loadAccounts();const o=this.market(e),n=this.createOrderRequest(e,t,s,i,r,a);let d;d=o.swap?await this.v2PrivateAccountGroupPostFuturesOrder(n):await this.v1PrivateAccountCategoryPostOrder(n);const h=this.safeDict(d,"data",{}),c=this.safeDict2(h,"order","info",{});return this.parseOrder(c,o)}async createOrders(e,t={}){await this.loadMarkets(),await this.loadAccounts();const s=[];let i,a;for(let t=0;t<e.length;t++){const o=e[t],n=this.safeString(o,"symbol");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const d=this.safeString(o,"type"),h=this.safeString(o,"side"),c=this.safeNumber(o,"amount"),l=this.safeNumber(o,"price"),u=this.safeDict(o,"params",{}),p=this.handleMarginModeAndParams("createOrders",u)[0];if(void 0!==p)if(void 0===a)a=p;else if(a!==p)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same margin mode (isolated or cross)");const f=this.createOrderRequest(n,d,h,c,l,u);s.push(f)}const o=this.market(i),n=this.safeDict(this.options,"accountsByType",{});let d=this.safeString(n,o.type,"cash");void 0!==a&&(d="margin");const h=this.safeDict(this.accounts,0,{}),c=this.safeString(h,"id"),l={};let u;if(o.swap)throw new r.NotSupported(this.id+" createOrders() is not currently supported for swap markets on ascendex");l["account-group"]=c,l["account-category"]=d,l.orders=s,u=await this.v1PrivateAccountCategoryPostOrderBatch(l);const p=this.safeDict(u,"data",{}),f=this.safeList(p,"info",[]);return this.parseOrders(f,o)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),await this.loadAccounts(),void 0!==t&&(i=this.market(t));const[a,o]=this.handleMarketTypeAndParams("fetchOrder",i,s),n=this.safeDict(this.options,"accountsByType",{}),d=this.safeString(n,a,"cash"),h=this.safeDict(this.accounts,0,{}),c={"account-group":this.safeString(h,"id"),"account-category":d,orderId:e};let l;if("spot"===a||"margin"===a)l=await this.v1PrivateAccountCategoryGetOrderStatus(this.extend(c,o));else{if("swap"!==a)throw new r.NotSupported(this.id+" fetchOrder() is not currently supported for "+a+" markets");c["account-category"]=d,l=await this.v2PrivateAccountGroupGetFuturesOrderStatus(this.extend(c,o))}const u=this.safeDict(l,"data",{});return this.parseOrder(u,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),await this.loadAccounts(),void 0!==e&&(a=this.market(e),e=a.symbol);const o=this.safeDict(this.accounts,0,{}),n=this.safeString(o,"id"),[d,h]=this.handleMarketTypeAndParams("fetchOpenOrders",a,i),c=this.safeDict(this.options,"accountsByType",{}),l=this.safeString(c,d,"cash"),u={"account-group":n,"account-category":l};let p;if("spot"===d||"margin"===d)p=await this.v1PrivateAccountCategoryGetOrderOpen(this.extend(u,h));else{if("swap"!==d)throw new r.NotSupported(this.id+" fetchOpenOrders() is not currently supported for "+d+" markets");u["account-category"]=l,p=await this.v2PrivateAccountGroupGetFuturesOrderOpen(this.extend(u,h))}const f=this.safeList(p,"data",[]);if("futures"===l)return this.parseOrders(f,a,t,s);const m=[];for(let e=0;e<f.length;e++){const t=this.parseOrder(f[e],a);m.push(t)}return this.filterBySymbolSinceLimit(m,e,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();const a=this.safeDict(this.accounts,0,{}),o=this.safeString(a,"id"),n={};let d;void 0!==e&&(d=this.market(e),n.symbol=d.id);const[h,c]=this.handleMarketTypeAndParams("fetchClosedOrders",d,i),l=this.safeDict(this.options,"fetchClosedOrders",{}),u=this.safeString(l,"method","v2PrivateDataGetOrderHist"),p=this.getSupportedMapping(h,{spot:u,margin:u,swap:"v2PrivateAccountGroupGetFuturesOrderHistCurrent"});void 0!==t&&(n.startTime=t);const f=this.safeString(i,"until");void 0!==f&&(n.endTime=f);const m=this.safeDict(this.options,"accountsByType",{}),g=this.safeString(m,h,"cash");let v;if("v1PrivateAccountCategoryGetOrderHistCurrent"===p)n["account-group"]=o,n["account-category"]=g,void 0!==s&&(n.limit=s),v=await this.v1PrivateAccountCategoryGetOrderHistCurrent(this.extend(n,c));else if("v2PrivateDataGetOrderHist"===p)n.account=g,void 0!==s&&(n.limit=s),v=await this.v2PrivateDataGetOrderHist(this.extend(n,c));else{if("v2PrivateAccountGroupGetFuturesOrderHistCurrent"!==p)throw new r.NotSupported(this.id+" fetchClosedOrders() is not currently supported for "+h+" markets");n["account-group"]=o,n["account-category"]=g,void 0!==s&&(n.pageSize=s),v=await this.v2PrivateAccountGroupGetFuturesOrderHistCurrent(this.extend(n,c))}let y=this.safeList(v,"data",[]);return Array.isArray(y)||(y=this.safeList(y,"data",[])),this.parseOrders(y,d,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),[a,o]=this.handleMarketTypeAndParams("cancelOrder",i,s),n=this.safeDict(this.options,"accountsByType",{}),d=this.safeString(n,a,"cash"),h=this.safeDict(this.accounts,0,{}),c={"account-group":this.safeString(h,"id"),"account-category":d,symbol:i.id,time:this.milliseconds(),id:"foobar"},l=this.safeString2(s,"clientOrderId","id");let u;if(void 0===l?c.orderId=e:(c.id=l,s=this.omit(s,["clientOrderId","id"])),"spot"===a||"margin"===a)u=await this.v1PrivateAccountCategoryDeleteOrder(this.extend(c,o));else{if("swap"!==a)throw new r.NotSupported(this.id+" cancelOrder() is not currently supported for "+a+" markets");c["account-category"]=d,u=await this.v2PrivateAccountGroupDeleteFuturesOrder(this.extend(c,o))}const p=this.safeDict(u,"data",{}),f=this.safeDict2(p,"order","info",{});return this.parseOrder(f,i)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets(),await this.loadAccounts(),void 0!==e&&(s=this.market(e));const[i,a]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,i,"cash"),d=this.safeDict(this.accounts,0,{}),h={"account-group":this.safeString(d,"id"),"account-category":n,time:this.milliseconds()};let c;if(void 0!==e&&(h.symbol=s.id),"spot"===i||"margin"===i)c=await this.v1PrivateAccountCategoryDeleteOrderAll(this.extend(h,a));else{if("swap"!==i)throw new r.NotSupported(this.id+" cancelAllOrders() is not currently supported for "+i+" markets");h["account-category"]=n,c=await this.v2PrivateAccountGroupDeleteFuturesOrderAll(this.extend(h,a))}return this.safeOrder({info:c})}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tagId"),r=this.safeString(e,i);this.checkAddress(s);const a=void 0===t?void 0:t.code,o=this.safeString(e,"blockchain");return{currency:a,address:s,tag:r,network:this.networkIdToCode(o,a),info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString2(t,"network","chainName"),a=this.networkCodeToId(i);t=this.omit(t,["chainName"]);const o={asset:s.id,blockchain:a},n=await this.v1PrivateGetWalletDepositAddress(this.extend(o,t)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"address",[]);let c;if(h.length>1){const e=this.indexBy(h,"chainName");if(void 0===a){const t=Object.keys(e).join(", ");throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "+t)}c=this.safeDict(e,a,{})}else c=this.safeDict(h,0,{});const l=this.parseDepositAddress(c,s);return this.extend(l,{info:n})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({txType:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({txType:"withdrawal"},i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset=a.id),void 0!==t&&(r.startTs=t),void 0!==s&&(r.pageSize=s);const o=await this.v1PrivateGetWalletTransactions(this.extend(r,i)),n=this.safeDict(o,"data",{}),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s)}parseTransactionStatus(e){return this.safeString({reviewing:"pending",pending:"pending",confirmed:"ok",rejected:"rejected"},e,e)}parseTransaction(e,t=void 0){const s=this.safeDict(e,"destAddress",{}),i=this.safeString(s,"address"),r=this.safeString(s,"destTag"),o=this.safeInteger(e,"time"),n=this.safeString(e,"asset");let d=this.safeString(e,"amount");const h=this.safeString(e,"commission");d=a.Y.stringSub(d,h);const c=this.safeCurrencyCode(n,t);return{info:e,id:this.safeString(e,"requestId"),txid:this.safeString(e,"networkTransactionId"),type:this.safeString(e,"transactionType"),currency:c,network:void 0,amount:this.parseNumber(d),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:o,datetime:this.iso8601(o),address:i,addressFrom:void 0,addressTo:i,tag:r,tagFrom:void 0,tagTo:r,updated:void 0,comment:void 0,fee:{currency:c,cost:this.parseNumber(h),rate:void 0},internal:!1}}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeDict(this.accounts,0,{}),i={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(i,t)),a=this.safeDict(r,"data",{}),o=this.safeList(a,"contracts",[]),n=[];for(let e=0;e<o.length;e++)n.push(this.parsePosition(o[e]));return e=this.marketSymbols(e),this.filterByArrayPositions(n,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i=this.safeString(e,"buyOpenOrderNotional");a.Y.stringEq(i,"0")&&(i=this.safeString(e,"sellOpenOrderNotional"));const r="crossed"===this.safeString(e,"marginType")?"cross":"isolated";let o;return"isolated"===r&&(o=this.safeString(e,"isolatedMargin")),this.safePosition({info:e,id:void 0,symbol:t.symbol,notional:this.parseNumber(i),marginMode:r,liquidationPrice:void 0,entryPrice:this.safeNumber(e,"avgOpenPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedPnl"),percentage:void 0,contracts:this.safeNumber(e,"position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,side:this.safeStringLower(e,"side"),hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:o,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeInteger(e,"leverage"),marginRatio:void 0,stopLossPrice:this.safeNumber(e,"stopLossPrice"),takeProfitPrice:this.safeNumber(e,"takeProfitPrice")})}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeInteger(e,"time"),a=this.safeNumber(e,"fundingRate"),o=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:i,markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:r,datetime:this.iso8601(r),previousFundingRate:void 0,nextFundingRate:void 0,previousFundingTimestamp:void 0,nextFundingTimestamp:void 0,previousFundingDatetime:void 0,nextFundingDatetime:void 0,fundingRate:a,fundingTimestamp:o,fundingDatetime:this.iso8601(o)}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v2PublicGetFuturesPricingData(t),i=this.safeDict(s,"data",{}),r=this.safeList(i,"contracts",[]),a=this.parseFundingRates(r);return this.filterByArray(a,"symbol",e)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets(),await this.loadAccounts();const r=this.market(e),o=this.safeDict(this.accounts,0,{}),n=this.safeString(o,"id");t=this.amountToPrecision(e,t);const d={"account-group":n,symbol:r.id,amount:t},h=await this.v2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.extend(d,i));return"reduce"===s&&(t=a.Y.stringAbs(t)),this.extend(this.parseMarginModification(h,r),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s="0"===this.safeString(e,"code")?"ok":"failed";return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:t.quote,status:s,timestamp:void 0,datetime:void 0}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,-t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<1||e>100)throw new r.BadRequest(this.id+" leverage should be between 1 and 100");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t);if(!i.swap)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");const a=this.safeDict(this.accounts,0,{}),o={"account-group":this.safeString(a,"id"),symbol:i.id,leverage:e};return await this.v2PrivateAccountGroupPostFuturesLeverage(this.extend(o,s))}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("cross"===(e=e.toLowerCase())&&(e="crossed"),"isolated"!==e&&"crossed"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets(),await this.loadAccounts();const i=this.market(t),a=this.safeDict(this.accounts,0,{}),o={"account-group":this.safeString(a,"id"),symbol:i.id,marginType:e};if(!i.swap)throw new r.BadSymbol(this.id+" setMarginMode() supports swap contracts only");return await this.v2PrivateAccountGroupPostFuturesMarginType(this.extend(o,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PublicGetFuturesContract(t),i=this.safeList(s,"data",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeList(e,"marginRequirements",[]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=[];for(let e=0;e<s.length;e++){const i=s[e],o=this.safeString(i,"initialMarginRate");r.push({tier:this.sum(e,1),currency:t.quote,minNotional:this.safeNumber(i,"positionNotionalLowerBound"),maxNotional:this.safeNumber(i,"positionNotionalUpperBound"),maintenanceMarginRate:this.safeNumber(i,"maintenanceMarginRate"),maxLeverage:this.parseNumber(a.Y.stringDiv("1",o)),info:i})}return r}parseDepositWithdrawFee(e,t=void 0){const s=this.safeList(e,"blockChain",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};for(let e=0;e<i;e++){const a=s[e],o=this.safeString(a,"chainName"),n=this.safeString(t,"code"),d=this.networkIdToCode(o,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(a,"withdrawFee"),percentage:!1}},1===i&&(r.withdraw.fee=this.safeNumber(a,"withdrawFee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PublicGetAssets(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e,"assetCode")}async transfer(e,t,s,i,a={}){await this.loadMarkets(),await this.loadAccounts();const o=this.safeDict(this.accounts,0,{}),n=this.safeString(o,"id"),d=this.currency(e),h=this.safeDict(this.options,"accountsByType",{}),c=this.safeString(h,s,s),l=this.safeString(h,i,i);if("cash"!==c&&"cash"!==l)throw new r.ExchangeError(this.id+" transfer() only supports direct balance transfer between spot and swap, spot and margin");const u={"account-group":n,amount:this.currencyToPrecision(e,t),asset:d.id,fromAccount:c,toAccount:l},p=await this.v1PrivateAccountGroupPostTransfer(this.extend(u,a)),f=this.safeDict(this.options,"transfer",{}),m=this.safeBool(f,"fillResponseFromRequest",!0),g=this.parseTransfer(p,d);return m&&(g.fromAccount=s,g.toAccount=i,g.amount=t,g.currency=e),g}parseTransfer(e,t=void 0){const s=this.safeString(e,"code");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return"0"===e?"ok":"failed"}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingHistory","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchFundingHistory",e,t,s,i,"page",25);const a=this.safeDict(this.accounts,0,{}),o={"account-group":this.safeString(a,"id")};let n;void 0!==e&&(n=this.market(e),o.symbol=n.id),void 0!==s&&(o.pageSize=s);const d=await this.v2PrivateAccountGroupGetFuturesFundingPayments(this.extend(o,i)),h=this.safeDict(d,"data",{}),c=this.safeList(h,"data",[]);return this.parseIncomes(c,n,t,s)}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t,"-","swap"),code:"USDT",timestamp:i,datetime:this.iso8601(i),id:void 0,amount:this.safeNumber(e,"paymentInUSDT")}}async fetchMarginModes(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeDict(this.accounts,0,{}),i={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(i,t)),a=this.safeDict(r,"data",{}),o=this.safeList(a,"contracts",[]);return this.parseMarginModes(o,e,"symbol")}parseMarginMode(e,t=void 0){const s=this.safeString(e,"symbol"),i="crossed"===this.safeString(e,"marginType")?"cross":"isolated";return{info:e,symbol:this.safeSymbol(s,t),marginMode:i}}async fetchLeverages(e=void 0,t={}){await this.loadMarkets(),await this.loadAccounts();const s=this.safeDict(this.accounts,0,{}),i={"account-group":this.safeString(s,"id")},r=await this.v2PrivateAccountGroupGetFuturesPosition(this.extend(i,t)),a=this.safeDict(r,"data",{}),o=this.safeList(a,"contracts",[]);return this.parseLeverages(o,e,"symbol")}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"leverage"),r="crossed"===this.safeString(e,"marginType")?"cross":"isolated";return{info:e,symbol:this.safeSymbol(s,t),marginMode:r,longLeverage:i,shortLeverage:i}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=t[0],d=t[1],h=this.safeString(t,2);let c="";const l="accountCategory"===h;(l||"accountGroup"===h)&&(c+=this.implodeParams("/{account-group}",i),i=this.omit(i,"account-group"));let u=this.implodeParams(e,i);if(c+="/api/pro/","v2"===o?u="data"===h?"data/"+o+"/"+u:o+"/"+u:c+=o+"/",l&&(c+=this.implodeParams("{account-category}/",i)),i=this.omit(i,"account-category"),c+=u,("v1"===o&&"cash/balance"===u||"margin/balance"===u)&&(u="balance"),"v1"===o&&"spot/fee"===u&&(u="fee"),u.indexOf("subuser")>=0){const e=u.split("/");u=e[2]}if(i=this.omit(i,this.extractParams(e)),"public"===d)Object.keys(i).length&&(c+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const e=this.milliseconds().toString(),t=e+"+"+u,o=this.hmac(this.encode(t),this.encode(this.secret),n.s,"base64");r={"x-auth-key":this.apiKey,"x-auth-timestamp":e,"x-auth-signature":o},"GET"===s?Object.keys(i).length&&(c+="?"+this.urlencode(i)):(r["Content-Type"]="application/json",a=this.json(i))}return c=this.urls.api.rest+c,{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==c&&"0"!==c||void 0!==l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},2961:(e,t,s)=>{s.d(t,{k:()=>vt});var i=s(5095),r=s(7437),a=s(6238),o=s(2079),n=s(5147),d=s(7288),h=s(3206),c=s(3828),l=s(8283),u=s(8995),p=s(5897),f=s(4380),m=s(447),g=s(3187),v=s(6907),y=s(9793),w=s(9491),b=s(1878);const{isNode:S,deepExtend:k,extend:O,clone:T,flatten:P,unique:I,indexBy:x,sortBy:A,sortBy2:M,safeFloat2:C,groupBy:E,aggregate:_,uuid:B,unCamelCase:N,precisionFromString:R,Throttler:L,capitalize:V,now:D,decimalToPrecision:q,safeValue:F,safeValue2:G,safeString:H,safeString2:U,seconds:W,milliseconds:j,binaryToBase16:K,numberToBE:Y,base16ToBinary:z,iso8601:X,omit:Q,isJsonEncodedObject:Z,safeInteger:$,sum:J,omitZero:ee,implodeParams:te,extractParams:se,json:ie,merge:re,binaryConcat:ae,hash:oe,ecdsa:ne,arrayConcat:de,encode:he,urlencode:ce,hmac:le,numberToString:ue,parseTimeframe:pe,safeInteger2:fe,safeStringLower:me,parse8601:ge,yyyymmdd:ve,safeStringUpper:ye,safeTimestamp:we,binaryConcatArray:be,uuidv1:Se,numberToLE:ke,ymdhms:Oe,stringToBase64:Te,decode:Pe,uuid22:Ie,safeIntegerProduct2:xe,safeIntegerProduct:Ae,safeStringLower2:Me,yymmdd:Ce,base58ToBinary:Ee,binaryToBase58:_e,safeTimestamp2:Be,rawencode:Ne,keysort:Re,inArray:Le,isEmpty:Ve,ordered:De,filterBy:qe,uuid16:Fe,safeFloat:Ge,base64ToBinary:He,safeStringUpper2:Ue,urlencodeWithArrayRepeat:We,microseconds:je,binaryToBase64:Ke,strip:Ye,toArray:ze,safeFloatN:Xe,safeIntegerN:Qe,safeIntegerProductN:Ze,safeTimestampN:$e,safeValueN:Je,safeStringN:et,safeStringLowerN:tt,safeStringUpperN:st,urlencodeNested:it,urlencodeBase64:rt,parseDate:at,ymd:ot,base64ToString:nt,crc32:dt,packb:ht,TRUNCATE:ct,ROUND:lt,DECIMAL_PLACES:ut,NO_PADDING:pt,TICK_SIZE:ft,SIGNIFICANT_DIGITS:mt,sleep:gt}=i;class vt{constructor(e={}){this.throttleProp=void 0,this.sleep=gt,this.api=void 0,this.certified=!1,this.pro=!1,this.countries=void 0,this.userAgent=void 0,this.user_agent=void 0,this.userAgents={chrome:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36",chrome39:"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36",chrome100:"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36"},this.headers={},this.origin="*",this.agent=void 0,this.nodeHttpModuleLoaded=!1,this.httpAgent=void 0,this.httpsAgent=void 0,this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.twofa=void 0,this.balance={},this.liquidations={},this.orderbooks={},this.tickers={},this.fundingRates={},this.bidsasks={},this.orders=void 0,this.triggerOrders=void 0,this.transactions={},this.myLiquidations={},this.requiresWeb3=!1,this.requiresEddsa=!1,this.precision=void 0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0,this.last_request_headers=void 0,this.last_request_body=void 0,this.last_request_url=void 0,this.last_request_path=void 0,this.id="Exchange",this.markets=void 0,this.status=void 0,this.rateLimit=void 0,this.tokenBucket=void 0,this.throttler=void 0,this.enableRateLimit=void 0,this.httpExceptions=void 0,this.limits=void 0,this.markets_by_id=void 0,this.symbols=void 0,this.ids=void 0,this.currencies={},this.baseCurrencies=void 0,this.quoteCurrencies=void 0,this.currencies_by_id=void 0,this.codes=void 0,this.reloadingMarkets=void 0,this.marketsLoading=void 0,this.accounts=void 0,this.accountsById=void 0,this.commonCurrencies=void 0,this.hostname=void 0,this.precisionMode=void 0,this.paddingMode=void 0,this.exceptions={},this.timeframes={},this.version=void 0,this.marketsByAltname=void 0,this.name=void 0,this.targetAccount=void 0,this.stablePairs={},this.clients={},this.newUpdates=!0,this.streaming={},this.alias=!1,this.deepExtend=k,this.isNode=S,this.keys=r.HP,this.values=r.zu,this.extend=O,this.clone=T,this.flatten=P,this.unique=I,this.indexBy=x,this.sortBy=A,this.sortBy2=M,this.groupBy=E,this.aggregate=_,this.uuid=B,this.unCamelCase=N,this.precisionFromString=R,this.capitalize=V,this.now=D,this.decimalToPrecision=q,this.safeValue=F,this.safeValue2=G,this.safeString=H,this.safeString2=U,this.safeFloat=Ge,this.safeFloat2=C,this.seconds=W,this.milliseconds=j,this.binaryToBase16=K,this.numberToBE=Y,this.base16ToBinary=z,this.iso8601=X,this.omit=Q,this.isJsonEncodedObject=Z,this.safeInteger=$,this.sum=J,this.omitZero=ee,this.implodeParams=te,this.extractParams=se,this.json=ie,this.vwap=a.ru,this.merge=re,this.binaryConcat=ae,this.hash=oe,this.arrayConcat=de,this.encode=he,this.urlencode=ce,this.hmac=le,this.numberToString=ue,this.parseTimeframe=pe,this.safeInteger2=fe,this.safeStringLower=me,this.parse8601=ge,this.yyyymmdd=ve,this.safeStringUpper=ye,this.safeTimestamp=we,this.binaryConcatArray=be,this.uuidv1=Se,this.numberToLE=ke,this.ymdhms=Oe,this.yymmdd=Ce,this.stringToBase64=Te,this.decode=Pe,this.uuid22=Ie,this.safeIntegerProduct2=xe,this.safeIntegerProduct=Ae,this.binaryToBase58=_e,this.base58ToBinary=Ee,this.base64ToBinary=He,this.safeTimestamp2=Be,this.rawencode=Ne,this.keysort=Re,this.inArray=Le,this.safeStringLower2=Me,this.safeStringUpper2=Ue,this.isEmpty=Ve,this.ordered=De,this.filterBy=qe,this.uuid16=Fe,this.urlencodeWithArrayRepeat=We,this.microseconds=je,this.binaryToBase64=Ke,this.strip=Ye,this.toArray=ze,this.safeFloatN=Xe,this.safeIntegerN=Qe,this.safeIntegerProductN=Ze,this.safeTimestampN=$e,this.safeValueN=Je,this.safeStringN=et,this.safeStringLowerN=tt,this.safeStringUpperN=st,this.urlencodeNested=it,this.parseDate=at,this.ymd=ot,this.base64ToString=nt,this.crc32=dt,this.packb=ht,this.urlencodeBase64=rt,this.httpProxyAgentModule=void 0,this.httpsProxyAgentModule=void 0,this.socksProxyAgentModule=void 0,this.socksProxyAgentModuleChecked=!1,this.proxyDictionaries={},this.proxiesModulesLoading=void 0,Object.assign(this,i),this.options=this.getDefaultOptions(),this.headers={},this.origin="*",this.minFundingAddressLength=1,this.substituteCommonCurrencyCodes=!0,this.quoteJsonNumbers=!0,this.number=Number,this.handleContentTypeApplicationZip=!1,this.reduceFees=!0,this.fetchImplementation=void 0,this.validateServerSsl=!0,this.validateClientSsl=!1,this.timeout=1e4,this.verbose=!1,this.twofa=void 0,this.apiKey=void 0,this.secret=void 0,this.uid=void 0,this.login=void 0,this.password=void 0,this.privateKey=void 0,this.walletAddress=void 0,this.token=void 0,this.balance={},this.orderbooks={},this.tickers={},this.liquidations={},this.orders=void 0,this.trades={},this.transactions={},this.ohlcvs={},this.myLiquidations={},this.myTrades=void 0,this.positions=void 0,this.requiresWeb3=!1,this.requiresEddsa=!1,this.lastRestRequestTimestamp=0,this.enableLastJsonResponse=!0,this.enableLastHttpResponse=!0,this.enableLastResponseHeaders=!0,this.last_http_response=void 0,this.last_json_response=void 0,this.last_response_headers=void 0,this.last_request_headers=void 0,this.last_request_body=void 0,this.last_request_url=void 0,this.last_request_path=void 0;const t=(e=this)=>{if(null!==e){const s=Object.getOwnPropertyNames(e);for(let e=0;e<s.length;e++){const t=s[e];this[N(t)]=this[t]}t(Object.getPrototypeOf(e))}};t();const s=Object.entries(this.describe()).concat(Object.entries(e));for(let e=0;e<s.length;e++){const[t,i]=s[e];i&&Object.getPrototypeOf(i)===Object.prototype?this[t]=this.deepExtend(this[t],i):this[t]=i}const o={keepAlive:!0};this.validateServerSsl||(o.rejectUnauthorized=!1);const n=Object.keys(this.has);for(let e=0;e<n.length;e++){const t=n[e];this["has"+this.capitalize(t)]=!!this.has[t]}this.api&&this.defineRestApi(this.api,"request"),this.initRestRateLimiter(),this.markets&&this.setMarkets(this.markets),this.newUpdates=void 0===this.options.newUpdates||this.options.newUpdates,this.afterConstruct();const d=this.safeBool2(this.options,"sandbox","testnet",!1);d&&this.setSandboxMode(d)}encodeURIComponent(...e){return encodeURIComponent(...e)}checkRequiredVersion(e,t=!0){let s=!0;const[i,r,a]=e.split("."),[n,d,h]=vt.ccxtVersion.split("."),c=this.parseToInt(i),l=this.parseToInt(r),u=this.parseToInt(a),p=this.parseToInt(n),f=this.parseToInt(d),m=this.parseToInt(h);if(c>p&&(s=!1),c===p&&(l>f||l===f&&u>m)&&(s=!1),!s){if(t)throw new o.NotSupported("Your current version of CCXT is "+vt.ccxtVersion+", a newer version "+e+" is required, please, upgrade your version of CCXT");return t}return s}initRestRateLimiter(){if(void 0===this.rateLimit)throw new Error(this.id+".rateLimit property is not configured");this.tokenBucket=this.extend({delay:.001,capacity:1,cost:1,maxCapacity:1e3,refillRate:this.rateLimit>0?1/this.rateLimit:Number.MAX_VALUE},this.tokenBucket),this.throttler=new L(this.tokenBucket)}throttle(e=void 0){return this.throttler.throttle(e)}defineRestApiEndpoint(e,t,s,i,r,a,o={}){const n=r.split(/[^a-zA-Z0-9]/),d=n.map(this.capitalize).join(""),h=n.map((e=>e.trim().toLowerCase())).filter((e=>e.length>0)).join("_"),c=[a[0]].concat(a.slice(1).map(this.capitalize)).join(""),l=[a[0]].concat(a.slice(1).map((e=>e.trim())).filter((e=>e.length>0))).join("_"),u=c+i+this.capitalize(d),p=l+"_"+s+"_"+h,f=a.length>1?a:a[0],m=async(s={},i={})=>this[e](r,f,t,s,void 0,void 0,o,i);this[u]=m,this[p]=m}defineRestApi(e,t,s=[]){const i=Object.keys(e);for(let r=0;r<i.length;r++){const a=i[r],n=e[a],d=a.toUpperCase(),h=a.toLowerCase(),c=this.capitalize(h);if(Array.isArray(n))for(let e=0;e<n.length;e++){const i=n[e].trim();this.defineRestApiEndpoint(t,d,h,c,i,s)}else if(a.match(/^(?:get|post|put|delete|head|patch)$/i)){const e=Object.keys(n);for(let i=0;i<e.length;i++){const r=e[i],a=r.trim(),l=n[r];if("object"==typeof l)this.defineRestApiEndpoint(t,d,h,c,a,s,l);else{if("number"!=typeof l)throw new o.NotSupported(this.id+" defineRestApi() API format is not supported, API leafs must strings, objects or numbers");this.defineRestApiEndpoint(t,d,h,c,a,s,{cost:l})}}}else this.defineRestApi(n,t,s.concat([a]))}}log(...e){console.log(...e)}async loadProxyModules(){return void 0===this.proxiesModulesLoading&&(this.proxiesModulesLoading=(async()=>{try{this.httpProxyAgentModule=await import("../static_dependencies/proxies/http-proxy-agent/index.js"),this.httpsProxyAgentModule=await import("../static_dependencies/proxies/https-proxy-agent/index.js")}catch(e){try{this.httpProxyAgentModule=await import("http-proxy-agent"),this.httpsProxyAgentModule=await import("https-proxy-agent")}catch(e){}}if(!1===this.socksProxyAgentModuleChecked){try{this.socksProxyAgentModule=await import("socks-proxy-agent")}catch(e){}this.socksProxyAgentModuleChecked=!0}})()),await this.proxiesModulesLoading}setProxyAgents(e,t,s){let i;if(!S&&(e||t||s))throw new o.NotSupported(this.id+' - proxies in browser-side projects are not supported. You have several choices: [A] Use `exchange.proxyUrl` property to redirect requests through local/remote cors-proxy server (find sample file named "sample-local-proxy-server-with-cors" in https://github.com/ccxt/ccxt/tree/master/examples/ folder, which can be used for REST requests only) [B] override `exchange.fetch` && `exchange.watch` methods to send requests through your custom proxy');if(e){if(void 0===this.httpProxyAgentModule)throw new o.NotSupported(this.id+" you need to load JS proxy modules with `.loadProxyModules()` method at first to use proxies");e in this.proxyDictionaries||(this.proxyDictionaries[e]=new this.httpProxyAgentModule.HttpProxyAgent(e)),i=this.proxyDictionaries[e]}else if(t){if(void 0===this.httpsProxyAgentModule)throw new o.NotSupported(this.id+" you need to load JS proxy modules with `.loadProxyModules()` method at first to use proxies");t in this.proxyDictionaries||(this.proxyDictionaries[t]=new this.httpsProxyAgentModule.HttpsProxyAgent(t)),i=this.proxyDictionaries[t],i.keepAlive=!0}else if(s){if(void 0===this.socksProxyAgentModule)throw new o.NotSupported(this.id+' - to use SOCKS proxy with ccxt, at first you need install module "npm i socks-proxy-agent" and then initialize proxies with `.loadProxyModules()` method');s in this.proxyDictionaries||(this.proxyDictionaries[s]=new this.socksProxyAgentModule.SocksProxyAgent(s)),i=this.proxyDictionaries[s]}return i}async loadHttpProxyAgent(){if(!this.httpAgent){const e=await import("node:http");this.httpAgent=new e.Agent}return this.httpAgent}getHttpAgentIfNeeded(e){if(S&&"ws://"===e.substring(0,5)){if(void 0===this.httpAgent)throw new o.NotSupported(this.id+" to use proxy with non-ssl ws:// urls, at first run  `await exchange.loadHttpProxyAgent()` method");return this.httpAgent}}async fetch(e,t="GET",s=void 0,i=void 0){if(S&&!this.nodeHttpModuleLoaded){this.nodeHttpModuleLoaded=!0;const e=await import("node:https");this.httpsAgent=new e.Agent({keepAlive:!0})}s=this.extend(this.headers,s);const r=this.checkProxyUrlSettings(e,t,s,i);let a=!1;void 0!==r&&(S&&(s=this.extend({Origin:this.origin},s),"http:"===r.substring(0,5)&&(await this.loadHttpProxyAgent(),a=this.httpAgent)),e=r+e);const[n,d,h]=this.checkProxySettings(e,t,s,i);this.checkConflictingProxies(n||d||h,r),S&&await this.loadProxyModules();const c=this.setProxyAgents(n,d,h),l=void 0!==this.userAgent?this.userAgent:this.user_agent;if(l&&S&&("string"==typeof l?s=this.extend({"User-Agent":l},s):"object"==typeof l&&"User-Agent"in l&&(s=this.extend(l,s))),s=this.setHeaders(s),this.verbose&&this.log("fetch Request:\n",this.id,t,e,"\nRequestHeaders:\n",s,"\nRequestBody:\n",i,"\n"),void 0===this.fetchImplementation)if(S){void 0===this.agent&&(this.agent=this.httpsAgent);try{const e=await import("../static_dependencies/node-fetch/index.js");this.AbortError=e.AbortError,this.fetchImplementation=e.default,this.FetchError=e.FetchError}catch(e){if("function"!=typeof fetch)throw new Error('Seems, "fetch" function is not available in your node-js version, please use latest node-js version');this.fetchImplementation=fetch,this.AbortError=DOMException,this.FetchError=TypeError}}else this.fetchImplementation=self.fetch,this.AbortError=DOMException,this.FetchError=TypeError;const u=this.fetchImplementation,p={method:t,headers:s,body:i,timeout:this.timeout};this.agent&&(p.agent=this.agent),a?p.agent=a:c&&(p.agent=c);const f=new AbortController;p.signal=f.signal;const m=setTimeout((()=>{f.abort()}),this.timeout);try{const r=await u(e,p);return clearTimeout(m),this.handleRestResponse(r,e,t,s,i)}catch(s){if(s instanceof this.AbortError)throw new o.RequestTimeout(this.id+" "+t+" "+e+" request timed out ("+this.timeout+" ms)");if(s instanceof this.FetchError)throw new o.NetworkError(this.id+" "+t+" "+e+" fetch failed");throw s}}parseJson(e){try{if(this.isJsonEncodedObject(e))return JSON.parse(this.onJsonResponse(e))}catch(e){return}}getResponseHeaders(e){const t={};return e.headers.forEach(((e,s)=>{s=s.split("-").map((e=>this.capitalize(e))).join("-"),t[s]=e})),t}handleRestResponse(e,t,s="GET",i=void 0,r=void 0){const a=this.getResponseHeaders(e);if(this.handleContentTypeApplicationZip&&"application/zip"===a["Content-Type"]){const i=e.buffer();return this.enableLastResponseHeaders&&(this.last_response_headers=a),this.enableLastHttpResponse&&(this.last_http_response=i),this.verbose&&this.log("handleRestResponse:\n",this.id,s,t,e.status,e.statusText,"\nResponseHeaders:\n",a,"ZIP redacted","\n"),i}return e.text().then((o=>{const n=this.onRestResponse(e.status,e.statusText,t,s,a,o,i,r),d=this.parseJson(n);this.enableLastResponseHeaders&&(this.last_response_headers=a),this.enableLastHttpResponse&&(this.last_http_response=o),this.enableLastJsonResponse&&(this.last_json_response=d),this.verbose&&this.log("handleRestResponse:\n",this.id,s,t,e.status,e.statusText,"\nResponseHeaders:\n",a,"\nResponseBody:\n",o,"\n");return this.handleErrors(e.status,e.statusText,t,s,a,o,d,i,r)||this.handleHttpStatusCode(e.status,e.statusText,t,s,o),d||o}))}onRestResponse(e,t,s,i,r,a,o,n){return a.trim()}onJsonResponse(e){return this.quoteJsonNumbers?e.replace(/":([+.0-9eE-]+)([,}])/g,'":"$1"$2'):e}async loadMarketsHelper(e=!1,t={}){if(!e&&this.markets)return this.markets_by_id?this.markets:this.setMarkets(this.markets);let s;!0===this.has.fetchCurrencies&&(s=await this.fetchCurrencies());const i=await this.fetchMarkets(t);return this.setMarkets(i,s)}async loadMarkets(e=!1,t={}){return(e&&!this.reloadingMarkets||!this.marketsLoading)&&(this.reloadingMarkets=!0,this.marketsLoading=this.loadMarketsHelper(e,t).then((e=>(this.reloadingMarkets=!1,e)),(e=>{throw this.reloadingMarkets=!1,e}))),this.marketsLoading}async fetchCurrencies(e={}){return new Promise(((e,t)=>e(this.currencies)))}async fetchCurrenciesWs(e={}){return new Promise(((e,t)=>e(this.currencies)))}async fetchMarkets(e={}){return new Promise(((e,t)=>e(Object.values(this.markets))))}async fetchMarketsWs(e={}){return new Promise(((e,t)=>e(Object.values(this.markets))))}checkRequiredDependencies(){}parseNumber(e,t=void 0){if(void 0===e)return t;try{return this.number(e)}catch(e){return t}}checkOrderArguments(e,t,s,i,r,a){if(void 0===r&&"limit"===t)throw new o.ArgumentsRequired(this.id+" createOrder() requires a price argument for a limit order");if(i<=0)throw new o.ArgumentsRequired(this.id+" createOrder() amount should be above 0")}handleHttpStatusCode(e,t,s,i,r){const a=e.toString();if(a in this.httpExceptions){throw new(0,this.httpExceptions[a])(this.id+" "+i+" "+s+" "+a+" "+t+" "+r)}}remove0xPrefix(e){return"0x"===e.slice(0,2)?e.slice(2):e}spawn(e,...t){const s=(0,h.K)();return setTimeout((()=>{e.apply(this,t).then(s.resolve).catch(s.reject)}),0),s}delay(e,t,...s){setTimeout((()=>{this.spawn(t,...s)}),e)}orderBook(e={},t=Number.MAX_SAFE_INTEGER){return new c.Mi(e,t)}indexedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new c.nS(e,t)}countedOrderBook(e={},t=Number.MAX_SAFE_INTEGER){return new c.if(e,t)}handleMessage(e,t){}ping(e){}client(e){if(this.clients=this.clients||{},!this.clients[e]){const t=this.handleMessage.bind(this),s=this.onError.bind(this),i=this.onClose.bind(this),r=this.onConnected.bind(this),a=this.safeValue(this.options,"ws",{}),[o,n,h]=this.checkWsProxySettings(),c=this.setProxyAgents(o,n,h),l=this.getHttpAgentIfNeeded(e),u=c||(l||this.agent),p=this.deepExtend(this.streaming,{log:this.log?this.log.bind(this):this.log,ping:this.ping?this.ping.bind(this):this.ping,verbose:this.verbose,throttler:new L(this.tokenBucket),options:{agent:u}},a);this.clients[e]=new d.A(e,t,s,i,r,p)}return this.clients[e]}watchMultiple(e,t,s=void 0,i=void 0,r=void 0){const a=this.client(e),o=h.K.race(t.map((e=>a.future(e))));let n=[];if(void 0!==i)for(let e=0;e<i.length;e++){const t=i[e];a.subscriptions[t]||(n.push(t),a.subscriptions[t]=r||!0)}const d=a.connect(0);return(void 0===i||n.length)&&d.then((()=>{const e=this.safeValue(this.options,"ws"),t=this.safeValue(e,"cost",1);s&&(this.enableRateLimit&&a.throttle?a.throttle(t).then((()=>{a.send(s)})).catch((e=>{for(let e=0;e<n.length;e++){const t=n[e];delete a.subscriptions[t]}o.reject(e)})):a.send(s).catch((e=>{for(let e=0;e<n.length;e++){const t=n[e];delete a.subscriptions[t]}o.reject(e)})))})).catch((e=>{for(let e=0;e<n.length;e++){const t=n[e];delete a.subscriptions[t]}o.reject(e)})),o}watch(e,t,s=void 0,i=void 0,r=void 0){const a=this.client(e);if(void 0===i&&t in a.futures)return a.futures[t];const o=a.future(t),n=a.subscriptions[i];n||(a.subscriptions[i]=r||!0);const d=a.connect(0);return n||d.then((()=>{const e=this.safeValue(this.options,"ws"),t=this.safeValue(e,"cost",1);s&&(this.enableRateLimit&&a.throttle?a.throttle(t).then((()=>{a.send(s)})).catch((e=>{a.onError(e)})):a.send(s).catch((e=>{a.onError(e)})))})).catch((e=>{delete a.subscriptions[i],o.reject(e)})),o}onConnected(e,t=void 0){}onError(e,t){e.url in this.clients&&this.clients[e.url].error&&delete this.clients[e.url]}onClose(e,t){e.error||this.clients[e.url]&&delete this.clients[e.url]}async close(){const e=Object.values(this.clients||{}),t=[];for(let s=0;s<e.length;s++){const i=e[s];i.error=new o.ExchangeClosedByUser(this.id+" closedByUser"),t.push(i.close())}await Promise.all(t);for(let t=0;t<e.length;t++){const s=e[t];delete this.clients[s.url]}}async loadOrderBook(e,t,s,i=void 0,r={}){if(!(s in this.orderbooks))return void e.reject(new o.ExchangeError(this.id+" loadOrderBook() orderbook is not initiated"),t);const a=this.handleOption("watchOrderBook","snapshotMaxRetries",3);let n=0;try{const d=this.orderbooks[s];for(;n<a;){const a=d.cache,o=await this.fetchRestOrderBookSafe(s,i,r),h=this.getCacheIndex(o,a);if(h>=0)return d.reset(o),this.handleDeltas(d,a.slice(h)),d.cache.length=0,void e.resolve(d,t);n++}e.reject(new o.ExchangeError(this.id+" nonce is behind the cache after "+a.toString()+" tries."),t),delete this.clients[e.url]}catch(a){e.reject(a,t),await this.loadOrderBook(e,t,s,i,r)}}convertToBigInt(e){return BigInt(e)}stringToCharsArray(e){return e.split("")}valueIsDefined(e){return null!=e}arraySlice(e,t,s=void 0){return void 0===s?e.slice(t):e.slice(t,s)}getProperty(e,t,s=void 0){return t in e?e[t]:s}setProperty(e,t,s=void 0){e[t]=s}axolotl(e,t,s){return(0,l.Sw)(e,t,s)}fixStringifiedJsonMembers(e){let t=e.replaceAll("\\","");return t=t.replaceAll('"{',"{"),t=t.replaceAll('}"',"}"),t}ethAbiEncode(e,t){return this.base16ToBinary(p.Ay.encode(e,t).slice(2))}ethEncodeStructuredData(e,t,s){return this.base16ToBinary(f.z.encode(e,t,s).slice(-132))}retrieveStarkAccount(e,t,s){const i=(0,g.b)(e),r=(0,g.$u)(i),a=v.fP.compile({implementation:t,selector:y.BK("initialize"),calldata:v.fP.compile({signer:r,guardian:"0"})});return{privateKey:i,publicKey:r,address:w.r4(r,s,a,0)}}starknetEncodeStructuredData(e,t,s,i){const r=Object.keys(t);if(r.length>1)throw new o.NotSupported(this.id+"starknetEncodeStructuredData only support single type");const a={domain:e,primaryType:r[0],types:this.extend({StarkNetDomain:[{name:"name",type:"felt"},{name:"chainId",type:"felt"},{name:"version",type:"felt"}]},t),message:s};return b.E(a,i)}starknetSign(e,t){const s=(0,g._S)(e.replace("0x",""),t.slice(-64));return this.json([s.r.toString(),s.s.toString()])}intToBase16(e){return e.toString(16)}extendExchangeOptions(e){this.options=this.extend(this.options,e)}createSafeDictionary(){return{}}randomBytes(e){const t=new m.D,s=[];return s.length=e,t.nextBytes(s),Buffer.from(s).toString("hex")}describe(){return{id:void 0,name:void 0,countries:void 0,enableRateLimit:!0,rateLimit:2e3,timeout:this.timeout,certified:!1,pro:!1,alias:!1,dex:!1,has:{publicAPI:!0,privateAPI:!0,CORS:void 0,sandbox:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,addMargin:void 0,borrowCrossMargin:void 0,borrowIsolatedMargin:void 0,borrowMargin:void 0,cancelAllOrders:void 0,cancelAllOrdersWs:void 0,cancelOrder:!0,cancelOrderWs:void 0,cancelOrders:void 0,cancelOrdersWs:void 0,closeAllPositions:void 0,closePosition:void 0,createDepositAddress:void 0,createLimitBuyOrder:void 0,createLimitBuyOrderWs:void 0,createLimitOrder:!0,createLimitOrderWs:void 0,createLimitSellOrder:void 0,createLimitSellOrderWs:void 0,createMarketBuyOrder:void 0,createMarketBuyOrderWs:void 0,createMarketBuyOrderWithCost:void 0,createMarketBuyOrderWithCostWs:void 0,createMarketOrder:!0,createMarketOrderWs:!0,createMarketOrderWithCost:void 0,createMarketOrderWithCostWs:void 0,createMarketSellOrder:void 0,createMarketSellOrderWs:void 0,createMarketSellOrderWithCost:void 0,createMarketSellOrderWithCostWs:void 0,createOrder:!0,createOrderWs:void 0,createOrders:void 0,createOrderWithTakeProfitAndStopLoss:void 0,createOrderWithTakeProfitAndStopLossWs:void 0,createPostOnlyOrder:void 0,createPostOnlyOrderWs:void 0,createReduceOnlyOrder:void 0,createReduceOnlyOrderWs:void 0,createStopLimitOrder:void 0,createStopLimitOrderWs:void 0,createStopLossOrder:void 0,createStopLossOrderWs:void 0,createStopMarketOrder:void 0,createStopMarketOrderWs:void 0,createStopOrder:void 0,createStopOrderWs:void 0,createTakeProfitOrder:void 0,createTakeProfitOrderWs:void 0,createTrailingAmountOrder:void 0,createTrailingAmountOrderWs:void 0,createTrailingPercentOrder:void 0,createTrailingPercentOrderWs:void 0,createTriggerOrder:void 0,createTriggerOrderWs:void 0,deposit:void 0,editOrder:"emulated",editOrderWs:void 0,fetchAccounts:void 0,fetchBalance:!0,fetchBalanceWs:void 0,fetchBidsAsks:void 0,fetchBorrowInterest:void 0,fetchBorrowRate:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchBorrowRates:void 0,fetchBorrowRatesPerSymbol:void 0,fetchCanceledAndClosedOrders:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchClosedOrdersWs:void 0,fetchConvertCurrencies:void 0,fetchConvertQuote:void 0,fetchConvertTrade:void 0,fetchConvertTradeHistory:void 0,fetchCrossBorrowRate:void 0,fetchCrossBorrowRates:void 0,fetchCurrencies:"emulated",fetchCurrenciesWs:"emulated",fetchDeposit:void 0,fetchDepositAddress:void 0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:void 0,fetchDeposits:void 0,fetchDepositsWithdrawals:void 0,fetchDepositsWs:void 0,fetchDepositWithdrawFee:void 0,fetchDepositWithdrawFees:void 0,fetchFundingHistory:void 0,fetchFundingRate:void 0,fetchFundingRateHistory:void 0,fetchFundingRates:void 0,fetchGreeks:void 0,fetchIndexOHLCV:void 0,fetchIsolatedBorrowRate:void 0,fetchIsolatedBorrowRates:void 0,fetchMarginAdjustmentHistory:void 0,fetchIsolatedPositions:void 0,fetchL2OrderBook:!0,fetchL3OrderBook:void 0,fetchLastPrices:void 0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:void 0,fetchLeverages:void 0,fetchLeverageTiers:void 0,fetchLiquidations:void 0,fetchMarginMode:void 0,fetchMarginModes:void 0,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarketsWs:void 0,fetchMarkOHLCV:void 0,fetchMyLiquidations:void 0,fetchMySettlementHistory:void 0,fetchMyTrades:void 0,fetchMyTradesWs:void 0,fetchOHLCV:void 0,fetchOHLCVWs:void 0,fetchOpenInterest:void 0,fetchOpenInterestHistory:void 0,fetchOpenOrder:void 0,fetchOpenOrders:void 0,fetchOpenOrdersWs:void 0,fetchOption:void 0,fetchOptionChain:void 0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrderBookWs:void 0,fetchOrders:void 0,fetchOrdersByStatus:void 0,fetchOrdersWs:void 0,fetchOrderTrades:void 0,fetchOrderWs:void 0,fetchPermissions:void 0,fetchPosition:void 0,fetchPositionHistory:void 0,fetchPositionsHistory:void 0,fetchPositionWs:void 0,fetchPositionMode:void 0,fetchPositions:void 0,fetchPositionsWs:void 0,fetchPositionsForSymbol:void 0,fetchPositionsForSymbolWs:void 0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:void 0,fetchSettlementHistory:void 0,fetchStatus:void 0,fetchTicker:!0,fetchTickerWs:void 0,fetchTickers:void 0,fetchTickersWs:void 0,fetchTime:void 0,fetchTrades:!0,fetchTradesWs:void 0,fetchTradingFee:void 0,fetchTradingFees:void 0,fetchTradingFeesWs:void 0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfer:void 0,fetchTransfers:void 0,fetchUnderlyingAssets:void 0,fetchVolatilityHistory:void 0,fetchWithdrawAddresses:void 0,fetchWithdrawal:void 0,fetchWithdrawals:void 0,fetchWithdrawalsWs:void 0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayCrossMargin:void 0,repayIsolatedMargin:void 0,setLeverage:void 0,setMargin:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,watchBalance:void 0,watchMyTrades:void 0,watchOHLCV:void 0,watchOHLCVForSymbols:void 0,watchOrderBook:void 0,watchOrderBookForSymbols:void 0,watchOrders:void 0,watchOrdersForSymbols:void 0,watchPosition:void 0,watchPositions:void 0,watchStatus:void 0,watchTicker:void 0,watchTickers:void 0,watchTrades:void 0,watchTradesForSymbols:void 0,watchLiquidations:void 0,watchLiquidationsForSymbols:void 0,watchMyLiquidations:void 0,watchMyLiquidationsForSymbols:void 0,withdraw:void 0,ws:void 0},urls:{logo:void 0,api:void 0,www:void 0,doc:void 0,fees:void 0},api:void 0,requiredCredentials:{apiKey:!0,secret:!0,uid:!1,accountId:!1,login:!1,password:!1,twofa:!1,privateKey:!1,walletAddress:!1,token:!1},markets:void 0,currencies:{},timeframes:void 0,fees:{trading:{tierBased:void 0,percentage:void 0,taker:void 0,maker:void 0},funding:{tierBased:void 0,percentage:void 0,withdraw:{},deposit:{}}},status:{status:"ok",updated:void 0,eta:void 0,url:void 0},exceptions:void 0,httpExceptions:{422:o.ExchangeError,418:o.DDoSProtection,429:o.RateLimitExceeded,404:o.ExchangeNotAvailable,409:o.ExchangeNotAvailable,410:o.ExchangeNotAvailable,451:o.ExchangeNotAvailable,500:o.ExchangeNotAvailable,501:o.ExchangeNotAvailable,502:o.ExchangeNotAvailable,520:o.ExchangeNotAvailable,521:o.ExchangeNotAvailable,522:o.ExchangeNotAvailable,525:o.ExchangeNotAvailable,526:o.ExchangeNotAvailable,400:o.ExchangeNotAvailable,403:o.ExchangeNotAvailable,405:o.ExchangeNotAvailable,503:o.ExchangeNotAvailable,530:o.ExchangeNotAvailable,408:o.RequestTimeout,504:o.RequestTimeout,401:o.AuthenticationError,407:o.AuthenticationError,511:o.AuthenticationError},commonCurrencies:{XBT:"BTC",BCC:"BCH",BCHSV:"BSV"},precisionMode:ft,paddingMode:pt,limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}}}}safeBoolN(e,t,s=void 0){const i=this.safeValueN(e,t,s);return"boolean"==typeof i?i:s}safeBool2(e,t,s,i=void 0){return this.safeBoolN(e,[t,s],i)}safeBool(e,t,s=void 0){return this.safeBoolN(e,[t],s)}safeDictN(e,t,s=void 0){const i=this.safeValueN(e,t,s);return void 0===i||"object"!=typeof i||Array.isArray(i)?s:i}safeDict(e,t,s=void 0){return this.safeDictN(e,[t],s)}safeDict2(e,t,s,i=void 0){return this.safeDictN(e,[t,s],i)}safeListN(e,t,s=void 0){const i=this.safeValueN(e,t,s);return void 0===i?s:Array.isArray(i)?i:s}safeList2(e,t,s,i=void 0){return this.safeListN(e,[t,s],i)}safeList(e,t,s=void 0){return this.safeListN(e,[t],s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleDelta(e,t){throw new o.NotSupported(this.id+" handleDelta not supported yet")}handleDeltasWithKeys(e,t,s=0,i=1,r=2){for(let a=0;a<t.length;a++){const o=this.parseBidAsk(t[a],s,i,r);e.storeArray(o)}}getCacheIndex(e,t){return-1}findTimeframe(e,t=void 0){void 0===t&&(t=this.timeframes);const s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i];if(t[r]===e)return r}}checkProxyUrlSettings(e=void 0,t=void 0,s=void 0,i=void 0){const r=[];let a;void 0!==this.proxyUrl&&(r.push("proxyUrl"),a=this.proxyUrl),void 0!==this.proxy_url&&(r.push("proxy_url"),a=this.proxy_url),void 0!==this.proxyUrlCallback&&(r.push("proxyUrlCallback"),a=this.proxyUrlCallback(e,t,s,i)),void 0!==this.proxy_url_callback&&(r.push("proxy_url_callback"),a=this.proxy_url_callback(e,t,s,i)),void 0!==this.proxy&&(r.push("proxy"),a="function"==typeof this.proxy?this.proxy(e,t,s,i):this.proxy);if(r.length>1){const e=r.join(",");throw new o.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+e+"), please use only one from : proxyUrl, proxy_url, proxyUrlCallback, proxy_url_callback")}return a}checkProxySettings(e=void 0,t=void 0,s=void 0,i=void 0){const r=[];let a,n,d;const h=this.valueIsDefined(this.httpProxy),c=this.valueIsDefined(this.http_proxy);(h||c)&&(r.push("httpProxy"),a=h?this.httpProxy:this.http_proxy);const l=this.valueIsDefined(this.httpProxyCallback),u=this.valueIsDefined(this.http_proxy_callback);(l||u)&&(r.push("httpProxyCallback"),a=l?this.httpProxyCallback(e,t,s,i):this.http_proxy_callback(e,t,s,i));const p=this.valueIsDefined(this.httpsProxy),f=this.valueIsDefined(this.https_proxy);(p||f)&&(r.push("httpsProxy"),n=p?this.httpsProxy:this.https_proxy);const m=this.valueIsDefined(this.httpsProxyCallback),g=this.valueIsDefined(this.https_proxy_callback);(m||g)&&(r.push("httpsProxyCallback"),n=m?this.httpsProxyCallback(e,t,s,i):this.https_proxy_callback(e,t,s,i));const v=this.valueIsDefined(this.socksProxy),y=this.valueIsDefined(this.socks_proxy);(v||y)&&(r.push("socksProxy"),d=v?this.socksProxy:this.socks_proxy);const w=this.valueIsDefined(this.socksProxyCallback),b=this.valueIsDefined(this.socks_proxy_callback);(w||b)&&(r.push("socksProxyCallback"),d=w?this.socksProxyCallback(e,t,s,i):this.socks_proxy_callback(e,t,s,i));if(r.length>1){const e=r.join(",");throw new o.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+e+"), please use only one from: httpProxy, httpsProxy, httpProxyCallback, httpsProxyCallback, socksProxy, socksProxyCallback")}return[a,n,d]}checkWsProxySettings(){const e=[];let t,s,i;this.valueIsDefined(this.wsProxy)&&(e.push("wsProxy"),t=this.wsProxy),this.valueIsDefined(this.ws_proxy)&&(e.push("ws_proxy"),t=this.ws_proxy),this.valueIsDefined(this.wssProxy)&&(e.push("wssProxy"),s=this.wssProxy),this.valueIsDefined(this.wss_proxy)&&(e.push("wss_proxy"),s=this.wss_proxy),this.valueIsDefined(this.wsSocksProxy)&&(e.push("wsSocksProxy"),i=this.wsSocksProxy),this.valueIsDefined(this.ws_socks_proxy)&&(e.push("ws_socks_proxy"),i=this.ws_socks_proxy);if(e.length>1){const t=e.join(",");throw new o.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings ("+t+"), please use only one from: wsProxy, wssProxy, wsSocksProxy")}return[t,s,i]}checkConflictingProxies(e,t){if(e&&t)throw new o.InvalidProxySettings(this.id+" you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy")}checkAddress(e=void 0){if(void 0===e)throw new o.InvalidAddress(this.id+" address is undefined");if(1===this.unique(this.stringToCharsArray(e)).length||e.length<this.minFundingAddressLength||e.indexOf(" ")>-1)throw new o.InvalidAddress(this.id+" address is invalid or has less than "+this.minFundingAddressLength.toString()+' characters: "'+e.toString()+'"');return e}findMessageHashes(e,t){const s=[],i=Object.keys(e.futures);for(let e=0;e<i.length;e++){const r=i[e];r.indexOf(t)>=0&&s.push(r)}return s}filterByLimit(e,t=void 0,s="timestamp",i=!1){if(this.valueIsDefined(t)){const r=e.length;if(r>0){let a=!0;if(s in e[0]){const t=e[0][s],i=e[r-1][s];void 0!==t&&void 0!==i&&(a=t<=i)}i?(t>r&&(t=r),e=a?this.arraySlice(e,0,t):this.arraySlice(e,-t)):e=a?this.arraySlice(e,-t):this.arraySlice(e,0,t)}}return e}filterBySinceLimit(e,t=void 0,s=void 0,i="timestamp",r=!1){const a=this.valueIsDefined(t),o=this.toArray(e);let n=o;if(a){n=[];for(let e=0;e<o.length;e++){const s=o[e],r=this.safeValue(s,i);r&&r>=t&&n.push(s)}}if(r&&void 0!==s)return this.arraySlice(n,-s);const d=!r&&a;return this.filterByLimit(n,s,i,d)}filterByValueSinceLimit(e,t,s=void 0,i=void 0,r=void 0,a="timestamp",o=!1){const n=this.valueIsDefined(s),d=this.valueIsDefined(i),h=this.toArray(e);let c=h;if(n||d){c=[];for(let e=0;e<h.length;e++){const r=h[e],o=r[t]===s,l=!n||o,u=this.safeValue(r,a);l&&(!d||u&&i&&u>=i)&&c.push(r)}}return o&&void 0!==r?this.arraySlice(c,-r):this.filterByLimit(c,r,a,d)}setSandboxMode(e){if(e){if(!("test"in this.urls))throw new o.NotSupported(this.id+" does not have a sandbox URL");"string"==typeof this.urls.api?(this.urls.apiBackup=this.urls.api,this.urls.api=this.urls.test):(this.urls.apiBackup=this.clone(this.urls.api),this.urls.api=this.clone(this.urls.test))}else if("apiBackup"in this.urls){"string"==typeof this.urls.api?this.urls.api=this.urls.apiBackup:this.urls.api=this.clone(this.urls.apiBackup);const e=this.omit(this.urls,"apiBackup");this.urls=e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){return{}}async fetchAccounts(e={}){throw new o.NotSupported(this.id+" fetchAccounts() is not supported yet")}async fetchTrades(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchTrades() is not supported yet")}async fetchTradesWs(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchTradesWs() is not supported yet")}async watchLiquidations(e,t=void 0,s=void 0,i={}){if(this.has.watchLiquidationsForSymbols)return await this.watchLiquidationsForSymbols([e],t,s,i);throw new o.NotSupported(this.id+" watchLiquidations() is not supported yet")}async watchLiquidationsForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchLiquidationsForSymbols() is not supported yet")}async watchMyLiquidations(e,t=void 0,s=void 0,i={}){if(this.has.watchMyLiquidationsForSymbols)return this.watchMyLiquidationsForSymbols([e],t,s,i);throw new o.NotSupported(this.id+" watchMyLiquidations() is not supported yet")}async watchMyLiquidationsForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchMyLiquidationsForSymbols() is not supported yet")}async watchTrades(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchTrades() is not supported yet")}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchTradesForSymbols() is not supported yet")}async watchMyTradesForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchMyTradesForSymbols() is not supported yet")}async watchOrdersForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchOrdersForSymbols() is not supported yet")}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchOHLCVForSymbols() is not supported yet")}async watchOrderBookForSymbols(e,t=void 0,s={}){throw new o.NotSupported(this.id+" watchOrderBookForSymbols() is not supported yet")}async fetchDepositAddresses(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchDepositAddresses() is not supported yet")}async fetchOrderBook(e,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchOrderBook() is not supported yet")}async fetchMarginMode(e,t={}){if(this.has.fetchMarginModes){const s=await this.fetchMarginModes([e],t);return this.safeDict(s,e)}throw new o.NotSupported(this.id+" fetchMarginMode() is not supported yet")}async fetchMarginModes(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchMarginModes () is not supported yet")}async fetchRestOrderBookSafe(e,t=void 0,s={}){const i=this.handleOption("watchOrderBook","maxRetries",3);for(let r=0;r<i;r++)try{return await this.fetchOrderBook(e,t,s)}catch(e){if(r+1===i)throw e}}async watchOrderBook(e,t=void 0,s={}){throw new o.NotSupported(this.id+" watchOrderBook() is not supported yet")}async fetchTime(e={}){throw new o.NotSupported(this.id+" fetchTime() is not supported yet")}async fetchTradingLimits(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchTradingLimits() is not supported yet")}parseMarket(e){throw new o.NotSupported(this.id+" parseMarket() is not supported yet")}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseTicker(e,t=void 0){throw new o.NotSupported(this.id+" parseTicker() is not supported yet")}parseDepositAddress(e,t=void 0){throw new o.NotSupported(this.id+" parseDepositAddress() is not supported yet")}parseTrade(e,t=void 0){throw new o.NotSupported(this.id+" parseTrade() is not supported yet")}parseTransaction(e,t=void 0){throw new o.NotSupported(this.id+" parseTransaction() is not supported yet")}parseTransfer(e,t=void 0){throw new o.NotSupported(this.id+" parseTransfer() is not supported yet")}parseAccount(e){throw new o.NotSupported(this.id+" parseAccount() is not supported yet")}parseLedgerEntry(e,t=void 0){throw new o.NotSupported(this.id+" parseLedgerEntry() is not supported yet")}parseOrder(e,t=void 0){throw new o.NotSupported(this.id+" parseOrder() is not supported yet")}async fetchCrossBorrowRates(e={}){throw new o.NotSupported(this.id+" fetchCrossBorrowRates() is not supported yet")}async fetchIsolatedBorrowRates(e={}){throw new o.NotSupported(this.id+" fetchIsolatedBorrowRates() is not supported yet")}parseMarketLeverageTiers(e,t=void 0){throw new o.NotSupported(this.id+" parseMarketLeverageTiers() is not supported yet")}async fetchLeverageTiers(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchLeverageTiers() is not supported yet")}parsePosition(e,t=void 0){throw new o.NotSupported(this.id+" parsePosition() is not supported yet")}parseFundingRateHistory(e,t=void 0){throw new o.NotSupported(this.id+" parseFundingRateHistory() is not supported yet")}parseBorrowInterest(e,t=void 0){throw new o.NotSupported(this.id+" parseBorrowInterest() is not supported yet")}parseIsolatedBorrowRate(e,t=void 0){throw new o.NotSupported(this.id+" parseIsolatedBorrowRate() is not supported yet")}parseWsTrade(e,t=void 0){throw new o.NotSupported(this.id+" parseWsTrade() is not supported yet")}parseWsOrder(e,t=void 0){throw new o.NotSupported(this.id+" parseWsOrder() is not supported yet")}parseWsOrderTrade(e,t=void 0){throw new o.NotSupported(this.id+" parseWsOrderTrade() is not supported yet")}parseWsOHLCV(e,t=void 0){return this.parseOHLCV(e,t)}async fetchFundingRates(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchFundingRates() is not supported yet")}async watchFundingRate(e,t={}){throw new o.NotSupported(this.id+" watchFundingRate() is not supported yet")}async watchFundingRates(e,t={}){throw new o.NotSupported(this.id+" watchFundingRates() is not supported yet")}async watchFundingRatesForSymbols(e,t={}){return await this.watchFundingRates(e,t)}async transfer(e,t,s,i,r={}){throw new o.NotSupported(this.id+" transfer() is not supported yet")}async withdraw(e,t,s,i=void 0,r={}){throw new o.NotSupported(this.id+" withdraw() is not supported yet")}async createDepositAddress(e,t={}){throw new o.NotSupported(this.id+" createDepositAddress() is not supported yet")}async setLeverage(e,t=void 0,s={}){throw new o.NotSupported(this.id+" setLeverage() is not supported yet")}async fetchLeverage(e,t={}){if(this.has.fetchLeverages){const s=await this.fetchLeverages([e],t);return this.safeDict(s,e)}throw new o.NotSupported(this.id+" fetchLeverage() is not supported yet")}async fetchLeverages(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchLeverages() is not supported yet")}async setPositionMode(e,t=void 0,s={}){throw new o.NotSupported(this.id+" setPositionMode() is not supported yet")}async addMargin(e,t,s={}){throw new o.NotSupported(this.id+" addMargin() is not supported yet")}async reduceMargin(e,t,s={}){throw new o.NotSupported(this.id+" reduceMargin() is not supported yet")}async setMargin(e,t,s={}){throw new o.NotSupported(this.id+" setMargin() is not supported yet")}async fetchMarginAdjustmentHistory(e=void 0,t=void 0,s=void 0,i=void 0,r={}){throw new o.NotSupported(this.id+" fetchMarginAdjustmentHistory() is not supported yet")}async setMarginMode(e,t=void 0,s={}){throw new o.NotSupported(this.id+" setMarginMode() is not supported yet")}async fetchDepositAddressesByNetwork(e,t={}){throw new o.NotSupported(this.id+" fetchDepositAddressesByNetwork() is not supported yet")}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,r={}){throw new o.NotSupported(this.id+" fetchOpenInterestHistory() is not supported yet")}async fetchOpenInterest(e,t={}){throw new o.NotSupported(this.id+" fetchOpenInterest() is not supported yet")}async signIn(e={}){throw new o.NotSupported(this.id+" signIn() is not supported yet")}async fetchPaymentMethods(e={}){throw new o.NotSupported(this.id+" fetchPaymentMethods() is not supported yet")}parseToInt(e){const t=this.numberToString(e),s=parseFloat(t);return parseInt(s)}parseToNumeric(e){const t=this.numberToString(e);return t.indexOf(".")>=0?parseFloat(t):parseInt(t)}isRoundNumber(e){return 0===this.parseToNumeric(e%1)}safeIntegerOmitZero(e,t,s=void 0){const i=this.safeInteger(e,t,s);if(void 0!==i&&0!==i)return i}afterConstruct(){this.createNetworksByIdObject()}orderbookChecksumMessage(e){return e+' : orderbook data checksum validation failed. You can reconnect by calling watchOrderBook again or you can mute the error by setting exchange.options["watchOrderBook"]["checksum"] = false'}createNetworksByIdObject(){const e=this.invertFlatStringDictionary(this.safeValue(this.options,"networks",{}));this.options.networksById=this.extend(e,this.safeValue(this.options,"networksById",{}))}getDefaultOptions(){return{defaultNetworkCodeReplacements:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"},CRO:{CRC20:"CRONOS"}}}}safeLedgerEntry(e,t=void 0){t=this.safeCurrency(void 0,t);let s=this.safeString(e,"direction"),i=this.safeString(e,"before"),r=this.safeString(e,"after");const a=this.safeString(e,"amount");void 0!==a&&(void 0===i&&void 0!==r?i=n.Y.stringSub(r,a):void 0!==i&&void 0===r&&(r=n.Y.stringAdd(i,a))),void 0!==i&&void 0!==r&&void 0===s&&(n.Y.stringGt(i,r)&&(s="out"),n.Y.stringGt(r,i)&&(s="in"));const o=this.safeValue(e,"fee");void 0!==o&&(o.cost=this.safeNumber(o,"cost"));const d=this.safeInteger(e,"timestamp"),h=this.safeDict(e,"info",{});return{id:this.safeString(e,"id"),timestamp:d,datetime:this.iso8601(d),direction:s,account:this.safeString(e,"account"),referenceId:this.safeString(e,"referenceId"),referenceAccount:this.safeString(e,"referenceAccount"),type:this.safeString(e,"type"),currency:t.code,amount:this.parseNumber(a),before:this.parseNumber(i),after:this.parseNumber(r),status:this.safeString(e,"status"),fee:o,info:h}}safeCurrencyStructure(e){return this.extend({info:void 0,id:void 0,numericId:void 0,code:void 0,precision:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,fees:{},networks:{},limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}},e)}safeMarketStructure(e=void 0){const t={id:void 0,lowercaseId:void 0,symbol:void 0,base:void 0,quote:void 0,settle:void 0,baseId:void 0,quoteId:void 0,settleId:void 0,type:void 0,spot:void 0,margin:void 0,swap:void 0,future:void 0,option:void 0,index:void 0,active:void 0,contract:void 0,linear:void 0,inverse:void 0,subType:void 0,taker:void 0,maker:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0,cost:void 0,base:void 0,quote:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:void 0};if(void 0!==e){const s=this.extend(t,e);return s.spot&&(void 0===s.contract&&(s.contract=!1),void 0===s.swap&&(s.swap=!1),void 0===s.future&&(s.future=!1),void 0===s.option&&(s.option=!1),void 0===s.index&&(s.index=!1)),s}return t}setMarkets(e,t=void 0){const s=[];this.markets_by_id={};const i=this.sortBy(this.toArray(e),"spot",!0,!0);for(let e=0;e<i.length;e++){const t=i[e];t.id in this.markets_by_id?this.markets_by_id[t.id].push(t):this.markets_by_id[t.id]=[t];const r=this.deepExtend(this.safeMarketStructure(),{precision:this.precision,limits:this.limits},this.fees.trading,t);r.linear?r.subType="linear":r.inverse?r.subType="inverse":r.subType=void 0,s.push(r)}this.markets=this.indexBy(s,"symbol");const r=this.keysort(this.markets),a=this.keysort(this.markets_by_id);if(this.symbols=Object.keys(r),this.ids=Object.keys(a),void 0!==t)this.currencies=this.deepExtend(this.currencies,t);else{let e=[],t=[];for(let i=0;i<s.length;i++){const r=s[i],a=this.precisionMode===ut?8:this.parseNumber("1e-8"),o=this.safeDict(r,"precision",{});if("base"in r){const t=this.safeCurrencyStructure({id:this.safeString2(r,"baseId","base"),numericId:this.safeInteger(r,"baseNumericId"),code:this.safeString(r,"base"),precision:this.safeValue2(o,"base","amount",a)});e.push(t)}if("quote"in r){const e=this.safeCurrencyStructure({id:this.safeString2(r,"quoteId","quote"),numericId:this.safeInteger(r,"quoteNumericId"),code:this.safeString(r,"quote"),precision:this.safeValue2(o,"quote","price",a)});t.push(e)}}e=this.sortBy(e,"code",!1,""),t=this.sortBy(t,"code",!1,""),this.baseCurrencies=this.indexBy(e,"code"),this.quoteCurrencies=this.indexBy(t,"code");const i=this.arrayConcat(e,t),r=this.groupBy(i,"code"),a=Object.keys(r),o=[];for(let e=0;e<a.length;e++){const t=a[e],s=this.safeList(r,t,[]);let i=this.safeValue(s,0);for(let e=1;e<s.length;e++){const t=s[e];i=this.precisionMode===ft?t.precision<i.precision?t:i:t.precision>i.precision?t:i}o.push(i)}const n=this.sortBy(o,"code");this.currencies=this.deepExtend(this.currencies,this.indexBy(n,"code"))}this.currencies_by_id=this.indexBy(this.currencies,"id");const o=this.keysort(this.currencies);return this.codes=Object.keys(o),this.markets}getDescribeForExtendedWsExchange(e,t,s){const i=this.deepExtend(t.describe(),e.describe());return this.deepExtend(i,s)}safeBalance(e){const t=this.omit(e,["info","timestamp","datetime","free","used","total"]),s=Object.keys(t);e.free={},e.used={},e.total={};const i={};for(let t=0;t<s.length;t++){const r=s[t];let a=this.safeString(e[r],"total"),o=this.safeString(e[r],"free"),d=this.safeString(e[r],"used");const h=this.safeString(e[r],"debt");void 0===a&&void 0!==o&&void 0!==d&&(a=n.Y.stringAdd(o,d)),void 0===o&&void 0!==a&&void 0!==d&&(o=n.Y.stringSub(a,d)),void 0===d&&void 0!==a&&void 0!==o&&(d=n.Y.stringSub(a,o)),e[r].free=this.parseNumber(o),e[r].used=this.parseNumber(d),e[r].total=this.parseNumber(a),e.free[r]=e[r].free,e.used[r]=e[r].used,e.total[r]=e[r].total,void 0!==h&&(e[r].debt=this.parseNumber(h),i[r]=e[r].debt)}return Object.keys(i).length&&(e.debt=i),e}safeOrder(e,t=void 0){let s=this.omitZero(this.safeString(e,"amount")),i=this.safeString(e,"remaining"),r=this.safeString(e,"filled"),a=this.safeString(e,"cost"),o=this.omitZero(this.safeString(e,"average")),d=this.omitZero(this.safeString(e,"price")),h=this.safeInteger(e,"lastTradeTimestamp"),c=this.safeString(e,"symbol"),l=this.safeString(e,"side");const u=this.safeString(e,"status"),p=void 0===r,f=void 0===a,m=void 0===h,g=this.safeValue(e,"fee"),v=void 0===g,y=void 0===this.safeValue(e,"fees"),w=void 0===c,b=void 0===l,S=v||y,k=this.safeList(e,"fees",[]);let O=[];const T=void 0!==this.safeString(e,"triggerPrice")||void 0!==this.safeString(e,"stopLossPrice")||void 0!==this.safeString(e,"takeProfitPrice");if(p||f||S){const s=this.safeValue(e,"trades",O),i=this.number;this.number=String;const o=this.safeValue(s,0);O=void 0!==o&&"info"in o&&"id"in o?s:this.parseTrades(s,t),this.number=i;let d=0;const u=Array.isArray(O);if(u&&(d=O.length),u&&d>0){void 0===e.symbol&&(e.symbol=O[0].symbol),void 0===e.side&&(e.side=O[0].side),void 0===e.type&&(e.type=O[0].type),void 0===e.id&&(e.id=O[0].order),p&&(r="0"),f&&(a="0");for(let e=0;e<O.length;e++){const t=O[e],s=this.safeString(t,"amount");p&&void 0!==s&&(r=n.Y.stringAdd(r,s));const i=this.safeString(t,"cost");f&&void 0!==i&&(a=n.Y.stringAdd(a,i)),w&&(c=this.safeString(t,"symbol")),b&&(l=this.safeString(t,"side"));const o=this.safeValue(t,"timestamp");if(m&&void 0!==o&&(h=void 0===h?o:Math.max(h,o)),S){const e=this.safeValue(t,"fees");if(void 0!==e)for(let t=0;t<e.length;t++){const s=e[t];k.push(this.extend({},s))}else{const e=this.safeValue(t,"fee");void 0!==e&&k.push(this.extend({},e))}}}}}if(S){const t=this.reduceFees?this.reduceFeesByCurrency(k):k,s=t.length;for(let e=0;e<s;e++)t[e].cost=this.safeNumber(t[e],"cost"),"rate"in t[e]&&(t[e].rate=this.safeNumber(t[e],"rate"));if(!v&&0===s){const e=this.deepExtend(g);e.cost=this.safeNumber(e,"cost"),"rate"in e&&(e.rate=this.safeNumber(e,"rate")),t.push(e)}e.fees=t,v&&1===s&&(e.fee=t[0])}void 0===s&&(void 0!==r&&void 0!==i?s=n.Y.stringAdd(r,i):"closed"===u&&(s=r)),void 0===r&&(void 0!==s&&void 0!==i?r=n.Y.stringSub(s,i):"closed"===u&&void 0!==s&&(r=s)),void 0===i&&(void 0!==s&&void 0!==r?i=n.Y.stringSub(s,r):"closed"===u&&(i="0"));const P=this.safeBool(t,"inverse",!1),I=this.numberToString(this.safeValue(t,"contractSize",1));if(void 0===o&&void 0!==r&&void 0!==a&&n.Y.stringGt(r,"0")){const e=n.Y.stringMul(r,I);o=P?n.Y.stringDiv(e,a):n.Y.stringDiv(a,e)}if(f&&void 0!==r&&(void 0!==o||void 0!==d)){let e;e=void 0===o?d:o;const t=n.Y.stringMul(r,I);a=P?n.Y.stringDiv(t,e):n.Y.stringMul(t,e)}const x=this.safeValue(e,"type");(void 0===d||n.Y.stringEquals(d,"0"))&&"market"===x&&(d=o);for(let e=0;e<O.length;e++){const t=O[e];t.amount=this.safeNumber(t,"amount"),t.price=this.safeNumber(t,"price"),t.cost=this.safeNumber(t,"cost");const s=this.safeDict(t,"fee",{});s.cost=this.safeNumber(s,"cost"),"rate"in s&&(s.rate=this.safeNumber(s,"rate"));const i=this.safeList(t,"fees",[]);for(let e=0;e<i.length;e++)i[e].cost=this.safeNumber(i[e],"cost");t.fees=i,t.fee=s}let A=this.safeString(e,"timeInForce"),M=this.safeValue(e,"postOnly");void 0===A?(T||"market"!==this.safeString(e,"type")||(A="IOC"),M&&(A="PO")):void 0===M&&(M="PO"===A);const C=this.safeInteger(e,"timestamp"),E=this.safeInteger(e,"lastUpdateTimestamp");let _=this.safeString(e,"datetime");void 0===_&&(_=this.iso8601(C));const B=this.parseNumber(this.safeString2(e,"triggerPrice","stopPrice")),N=this.parseNumber(this.safeString(e,"takeProfitPrice")),R=this.parseNumber(this.safeString(e,"stopLossPrice"));return this.extend(e,{id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"clientOrderId"),timestamp:C,datetime:_,symbol:c,type:this.safeString(e,"type"),side:l,lastTradeTimestamp:h,lastUpdateTimestamp:E,price:this.parseNumber(d),amount:this.parseNumber(s),cost:this.parseNumber(a),average:this.parseNumber(o),filled:this.parseNumber(r),remaining:this.parseNumber(i),timeInForce:A,postOnly:M,trades:O,reduceOnly:this.safeValue(e,"reduceOnly"),stopPrice:B,triggerPrice:B,takeProfitPrice:N,stopLossPrice:R,status:u,fee:this.safeValue(e,"fee")})}parseOrders(e,t=void 0,s=void 0,i=void 0,r={}){let a=[];if(Array.isArray(e))for(let s=0;s<e.length;s++){const i=this.extend(this.parseOrder(e[s],t),r);a.push(i)}else{const s=Object.keys(e);for(let i=0;i<s.length;i++){const o=s[i],n=this.extend(this.parseOrder(this.extend({id:o},e[o]),t),r);a.push(n)}}a=this.sortBy(a,"timestamp");const o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(a,o,s,i)}calculateFee(e,t,s,i,r,a="taker",d={}){if("market"===t&&"maker"===a)throw new o.ArgumentsRequired(this.id+' calculateFee() - you have provided incompatible arguments - "market" type order can not be "maker". Change either the "type" or the "takerOrMaker" argument to calculate the fee.');const h=this.markets[e],c=this.safeString(h,"feeSide","quote");let l;l="get"===c?"sell"===s:"give"===c?"buy"===s:"quote"===c;let u,p=this.numberToString(i);if(l){const e=this.numberToString(r);p=n.Y.stringMul(p,e),u="quote"}else u="base";h.spot||(u="settle"),"market"===t&&(a="taker");const f=this.safeString(h,a);return p=n.Y.stringMul(p,f),{type:a,currency:h[u],rate:this.parseNumber(f),cost:this.parseNumber(p)}}safeLiquidation(e,t=void 0){const s=this.safeString(e,"contracts"),i=this.safeString(t,"contractSize"),r=this.safeString(e,"price");let a=this.safeString(e,"baseValue"),o=this.safeString(e,"quoteValue");return void 0===a&&void 0!==s&&void 0!==i&&void 0!==r&&(a=n.Y.stringMul(s,i)),void 0===o&&void 0!==a&&void 0!==r&&(o=n.Y.stringMul(a,r)),e.contracts=this.parseNumber(s),e.contractSize=this.parseNumber(i),e.price=this.parseNumber(r),e.baseValue=this.parseNumber(a),e.quoteValue=this.parseNumber(o),e}safeTrade(e,t=void 0){const s=this.safeString(e,"amount"),i=this.safeString(e,"price");let r=this.safeString(e,"cost");if(void 0===r){const e=this.safeString(t,"contractSize");let a=i;if(void 0!==e){this.safeBool(t,"inverse",!1)&&(a=n.Y.stringDiv("1",i)),a=n.Y.stringMul(a,e)}r=n.Y.stringMul(a,s)}const[a,o]=this.parsedFeeAndFees(e);return e.fee=a,e.fees=o,e.amount=this.parseNumber(s),e.price=this.parseNumber(i),e.cost=this.parseNumber(r),e}parsedFeeAndFees(e){let t=this.safeDict(e,"fee"),s=this.safeList(e,"fees");const i=void 0!==t,r=void 0!==s;if(i||r){i&&(t=this.parseFeeNumeric(t)),r||(s=[t]);const e=this.reduceFees?this.reduceFeesByCurrency(s):s,a=e.length;for(let t=0;t<a;t++)e[t]=this.parseFeeNumeric(e[t]);s=e,1===a?t=e[0]:0===a&&(t=void 0)}return void 0===t&&(t={cost:void 0,currency:void 0}),void 0===s&&(s=[]),[t,s]}parseFeeNumeric(e){return e.cost=this.safeNumber(e,"cost"),"rate"in e&&(e.rate=this.safeNumber(e,"rate")),e}findNearestCeiling(e,t){const s=e.length;for(let i=0;i<s;i++){const s=e[i];if(t<=s)return s}return e[s-1]}invertFlatStringDictionary(e){const t={},s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i],a=e[r];"string"==typeof a&&(t[a]=r)}return t}reduceFeesByCurrency(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=void 0!==r?r:s.toString();if(void 0!==a){const e=this.safeString(i,"rate"),s=this.safeString(i,"cost");if(void 0===s)continue;a in t||(t[a]={});const o=void 0===e?"":e;o in t[a]?t[a][o].cost=n.Y.stringAdd(t[a][o].cost,s):(t[a][o]={currency:r,cost:s},void 0!==e&&(t[a][o].rate=e))}}let s=[];const i=Object.values(t);for(let e=0;e<i.length;e++){const t=Object.values(i[e]);s=this.arrayConcat(s,t)}return s}safeTicker(e,t=void 0){let s=this.omitZero(this.safeString(e,"open")),i=this.omitZero(this.safeString(e,"close")),r=this.omitZero(this.safeString(e,"last")),a=this.omitZero(this.safeString(e,"change")),o=this.omitZero(this.safeString(e,"percentage")),d=this.omitZero(this.safeString(e,"average")),h=this.omitZero(this.safeString(e,"vwap"));const c=this.safeString(e,"baseVolume"),l=this.safeString(e,"quoteVolume");if(void 0===h&&(h=n.Y.stringDiv(this.omitZero(l),c)),void 0!==r&&void 0===i?i=r:void 0===r&&void 0!==i&&(r=i),void 0!==r&&void 0!==s&&(void 0===a&&(a=n.Y.stringSub(r,s)),void 0===d)){let e=18;if(void 0!==t&&this.isTickPrecision()){const s=this.safeDict(t,"precision"),i=this.safeString(s,"price");void 0!==i&&(e=this.precisionFromString(i))}d=n.Y.stringDiv(n.Y.stringAdd(r,s),"2",e)}return void 0===o&&void 0!==a&&void 0!==s&&n.Y.stringGt(s,"0")&&(o=n.Y.stringMul(n.Y.stringDiv(a,s),"100")),void 0===a&&void 0!==o&&void 0!==s&&(a=n.Y.stringDiv(n.Y.stringMul(o,s),"100")),void 0===s&&void 0!==r&&void 0!==a&&(s=n.Y.stringSub(r,a)),this.extend(e,{bid:this.parseNumber(this.omitZero(this.safeString(e,"bid"))),bidVolume:this.safeNumber(e,"bidVolume"),ask:this.parseNumber(this.omitZero(this.safeString(e,"ask"))),askVolume:this.safeNumber(e,"askVolume"),high:this.parseNumber(this.omitZero(this.safeString(e,"high"))),low:this.parseNumber(this.omitZero(this.safeString(e,"low"))),open:this.parseNumber(this.omitZero(s)),close:this.parseNumber(this.omitZero(i)),last:this.parseNumber(this.omitZero(r)),change:this.parseNumber(a),percentage:this.parseNumber(o),average:this.parseNumber(d),vwap:this.parseNumber(h),baseVolume:this.parseNumber(c),quoteVolume:this.parseNumber(l),previousClose:this.safeNumber(e,"previousClose")})}async fetchBorrowRate(e,t,s={}){throw new o.NotSupported(this.id+" fetchBorrowRate is deprecated, please use fetchCrossBorrowRate or fetchIsolatedBorrowRate instead")}async repayCrossMargin(e,t,s={}){throw new o.NotSupported(this.id+" repayCrossMargin is not support yet")}async repayIsolatedMargin(e,t,s,i={}){throw new o.NotSupported(this.id+" repayIsolatedMargin is not support yet")}async borrowCrossMargin(e,t,s={}){throw new o.NotSupported(this.id+" borrowCrossMargin is not support yet")}async borrowIsolatedMargin(e,t,s,i={}){throw new o.NotSupported(this.id+" borrowIsolatedMargin is not support yet")}async borrowMargin(e,t,s=void 0,i={}){throw new o.NotSupported(this.id+" borrowMargin is deprecated, please use borrowCrossMargin or borrowIsolatedMargin instead")}async repayMargin(e,t,s=void 0,i={}){throw new o.NotSupported(this.id+" repayMargin is deprecated, please use repayCrossMargin or repayIsolatedMargin instead")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){let a="";throw this.has.fetchTrades&&(a='. If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see "build-ohlcv-bars" file'),new o.NotSupported(this.id+" fetchOHLCV() is not supported yet"+a)}async fetchOHLCVWs(e,t="1m",s=void 0,i=void 0,r={}){let a="";throw this.has.fetchTradesWs&&(a='. If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see "build-ohlcv-bars" file'),new o.NotSupported(this.id+" fetchOHLCVWs() is not supported yet. Try using fetchOHLCV instead."+a)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){throw new o.NotSupported(this.id+" watchOHLCV() is not supported yet")}convertTradingViewToOHLCV(e,t="t",s="o",i="h",r="l",a="c",o="v",n=!1){const d=[],h=this.safeList(e,t,[]),c=this.safeList(e,s,[]),l=this.safeList(e,i,[]),u=this.safeList(e,r,[]),p=this.safeList(e,a,[]),f=this.safeList(e,o,[]);for(let e=0;e<h.length;e++)d.push([n?this.safeInteger(h,e):this.safeTimestamp(h,e),this.safeValue(c,e),this.safeValue(l,e),this.safeValue(u,e),this.safeValue(p,e),this.safeValue(f,e)]);return d}convertOHLCVToTradingView(e,t="t",s="o",i="h",r="l",a="c",o="v",n=!1){const d={};d[t]=[],d[s]=[],d[i]=[],d[r]=[],d[a]=[],d[o]=[];for(let h=0;h<e.length;h++){const c=n?e[h][0]:this.parseToInt(e[h][0]/1e3);d[t].push(c),d[s].push(e[h][1]),d[i].push(e[h][2]),d[r].push(e[h][3]),d[a].push(e[h][4]),d[o].push(e[h][5])}return d}async fetchWebEndpoint(e,t,s,i=void 0,r=void 0){let a="";const n=this.safeValue(this.options,e,{}),d=this.safeBool(n,"webApiMuteFailure",!0);try{if(!0!==this.safeBool(n,"webApiEnable",!0))return;const e=this.safeValue(n,"webApiRetries",10);let a,d=0;for(;d<e;)try{a=await this[t]({});break}catch(t){if(d+=1,d===e)throw t}let h=a;if(void 0!==i){const e=h.split(i);h=e[1]}if(void 0!==r){const e=h.split(r);h=e[0]}if(s&&"string"==typeof h){const e=this.parseJson(h.trim());if(e)return e;throw new o.BadResponse("could not parse the response into json")}return h}catch(t){a=this.id+" "+e+"() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser."}if(!d)throw new o.BadResponse(a)}marketIds(e=void 0){if(void 0===e)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.marketId(e[s]));return t}marketsForSymbols(e=void 0){if(void 0===e)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.market(e[s]));return t}marketSymbols(e=void 0,t=void 0,s=!0,i=!1,r=!1){if(void 0===e){if(!s)throw new o.ArgumentsRequired(this.id+" empty list of symbols is not supported");return e}if(0===e.length){if(!s)throw new o.ArgumentsRequired(this.id+" empty list of symbols is not supported");return e}const a=[];let n,d;for(let s=0;s<e.length;s++){const h=this.market(e[s]);if(i&&void 0!==n&&h.type!==n)throw new o.BadRequest(this.id+" symbols must be of the same type, either "+n+" or "+h.type+".");if(r&&void 0!==d&&h.linear!==d)throw new o.BadRequest(this.id+" symbols must be of the same subType, either linear or inverse.");if(void 0!==t&&h.type!==t)throw new o.BadRequest(this.id+" symbols must be of the same type "+t+". If the type is incorrect you can change it in options or the params of the request");n=h.type,h.spot||(d=h.linear);const c=this.safeString(h,"symbol",e[s]);a.push(c)}return a}marketCodes(e=void 0){if(void 0===e)return e;const t=[];for(let s=0;s<e.length;s++)t.push(this.commonCurrencyCode(e[s]));return t}parseBidsAsks(e,t=0,s=1,i=2){e=this.toArray(e);const r=[];for(let a=0;a<e.length;a++)r.push(this.parseBidAsk(e[a],t,s,i));return r}async fetchL2OrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBook(e,t,s);return this.extend(i,{asks:this.sortBy(this.aggregate(i.asks),0),bids:this.sortBy(this.aggregate(i.bids),0,!0)})}filterBySymbol(e,t=void 0){if(void 0===t)return e;const s=[];for(let i=0;i<e.length;i++){this.safeString(e[i],"symbol")===t&&s.push(e[i])}return s}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:e}networkCodeToId(e,t=void 0){if(void 0===e)return;const s=this.safeValue(this.options,"networks",{});let i=this.safeString(s,e);if(void 0===i){if(void 0===t){const t=Object.values(this.currencies);for(let s=0;s<t.length;s++){const t=[s],r=this.safeDict(t,"networks"),a=this.safeDict(r,e);if(i=this.safeString(a,"id"),void 0!==i)break}}else{const r=this.safeValue(this.options,"defaultNetworkCodeReplacements",{});if(t in r){const a=r[t],o=Object.keys(a);for(let t=0;t<o.length;t++){const r=o[t];if(a[r]===e){i=this.safeString(s,r);break}}}else{const s=this.safeDict(this.currencies,t),r=this.safeDict(s,"networks"),a=this.safeDict(r,e);i=this.safeString(a,"id")}}void 0===i&&(i=e)}return i}networkIdToCode(e=void 0,t=void 0){if(void 0===e)return;const s=this.safeDict(this.options,"networksById",{});let i=this.safeString(s,e,e);if(void 0!==t){const e=this.safeDict(this.options,"defaultNetworkCodeReplacements",{});if(t in e){const s=this.safeDict(e,t,{});i=this.safeString(s,i,i)}}return i}handleNetworkCodeAndParams(e){const t=this.safeString2(e,"networkCode","network");return void 0!==t&&(e=this.omit(e,["networkCode","network"])),[t,e]}defaultNetworkCode(e){let t;const s=this.safeDict(this.options,"defaultNetworks",{});if(e in s)t=s[e];else{const e=this.safeString(this.options,"defaultNetwork");void 0!==e&&(t=e)}return t}selectNetworkCodeFromUnifiedNetworks(e,t,s){return this.selectNetworkKeyFromNetworks(e,t,s,!0)}selectNetworkIdFromRawNetworks(e,t,s){return this.selectNetworkKeyFromNetworks(e,t,s,!1)}selectNetworkKeyFromNetworks(e,t,s,i=!1){let r;const a=Object.keys(s),n=a.length;if(void 0!==t){if(0===n)throw new o.NotSupported(this.id+" - "+t+" network did not return any result for "+e);{const n=i?t:this.networkCodeToId(t,e);if(!(n in s))throw new o.NotSupported(this.id+" - "+n+" network was not found for "+e+", use one of "+a.join(", "));r=n}}else{if(0===n)throw new o.NotSupported(this.id+" - no networks were returned for "+e);{const t=this.defaultNetworkCode(e),o=i?t:this.networkCodeToId(t,e);r=o in s?o:a[0]}}return r}safeNumber2(e,t,s,i=void 0){const r=this.safeString2(e,t,s);return this.parseNumber(r,i)}parseOrderBook(e,t,s=void 0,i="bids",r="asks",a=0,o=1,n=2){const d=this.parseBidsAsks(this.safeValue(e,i,[]),a,o,n),h=this.parseBidsAsks(this.safeValue(e,r,[]),a,o,n);return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(h,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseOHLCVs(e,t=void 0,s="1m",i=void 0,r=void 0){const a=[];for(let s=0;s<e.length;s++)a.push(this.parseOHLCV(e[s],t));const o=this.sortBy(a,0);return this.filterBySinceLimit(o,i,r,0)}parseLeverageTiers(e,t=void 0,s=void 0){const i={};let r=0;void 0!==(t=this.marketSymbols(t))&&(r=t.length);const a=void 0===t||0===r;if(Array.isArray(e))for(let r=0;r<e.length;r++){const o=e[r],n=this.safeString(o,s),d=this.safeMarket(n,void 0,void 0,"swap"),h=d.symbol;this.safeBool(d,"contract",!1)&&(a||this.inArray(h,t))&&(i[h]=this.parseMarketLeverageTiers(o,d))}else{const s=Object.keys(e);for(let r=0;r<s.length;r++){const o=s[r],n=e[o],d=this.safeMarket(o,void 0,void 0,"swap"),h=d.symbol;this.safeBool(d,"contract",!1)&&(a||this.inArray(h,t))&&(i[h]=this.parseMarketLeverageTiers(n,d))}}return i}async loadTradingLimits(e=void 0,t=!1,s={}){if(this.has.fetchTradingLimits&&(t||!("limitsLoaded"in this.options))){const t=await this.fetchTradingLimits(e);for(let s=0;s<e.length;s++){const i=e[s];this.markets[i]=this.deepExtend(this.markets[i],t[i])}this.options.limitsLoaded=this.milliseconds()}return this.markets}safePosition(e){const t=this.safeString(e,"unrealisedPnl"),s=this.safeString(e,"initialMargin");if(void 0===this.safeValue(e,"percentage")&&void 0!==t&&void 0!==s){const i=n.Y.stringMul(n.Y.stringDiv(t,s,4),"100");e.percentage=this.parseNumber(i)}let i=this.safeNumber(e,"contractSize");const r=this.safeString(e,"symbol");let a;return void 0!==r&&(a=this.safeValue(this.markets,r)),void 0===i&&void 0!==a&&(i=this.safeNumber(a,"contractSize"),e.contractSize=i),e}parsePositions(e,t=void 0,s={}){t=this.marketSymbols(t),e=this.toArray(e);const i=[];for(let t=0;t<e.length;t++){const r=this.extend(this.parsePosition(e[t],void 0),s);i.push(r)}return this.filterByArrayPositions(i,"symbol",t,!1)}parseAccounts(e,t={}){e=this.toArray(e);const s=[];for(let i=0;i<e.length;i++){const r=this.extend(this.parseAccount(e[i]),t);s.push(r)}return s}parseTrades(e,t=void 0,s=void 0,i=void 0,r={}){e=this.toArray(e);let a=[];for(let s=0;s<e.length;s++){const i=this.extend(this.parseTrade(e[s],t),r);a.push(i)}a=this.sortBy2(a,"timestamp","id");const o=void 0!==t?t.symbol:void 0;return this.filterBySymbolSinceLimit(a,o,s,i)}parseTransactions(e,t=void 0,s=void 0,i=void 0,r={}){e=this.toArray(e);let a=[];for(let s=0;s<e.length;s++){const i=this.extend(this.parseTransaction(e[s],t),r);a.push(i)}a=this.sortBy(a,"timestamp");const o=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,o,s,i)}parseTransfers(e,t=void 0,s=void 0,i=void 0,r={}){e=this.toArray(e);let a=[];for(let s=0;s<e.length;s++){const i=this.extend(this.parseTransfer(e[s],t),r);a.push(i)}a=this.sortBy(a,"timestamp");const o=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,o,s,i)}parseLedger(e,t=void 0,s=void 0,i=void 0,r={}){let a=[];const o=this.toArray(e);for(let e=0;e<o.length;e++){const s=this.parseLedgerEntry(o[e],t);if(Array.isArray(s))for(let e=0;e<s.length;e++)a.push(this.extend(s[e],r));else a.push(this.extend(s,r))}a=this.sortBy(a,"timestamp");const n=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,n,s,i)}nonce(){return this.seconds()}setHeaders(e){return e}marketId(e){const t=this.market(e);return void 0!==t?t.id:e}symbol(e){const t=this.market(e);return this.safeString(t,"symbol",e)}handleParamString(e,t,s=void 0){const i=this.safeString(e,t,s);return void 0!==i&&(e=this.omit(e,t)),[i,e]}handleParamString2(e,t,s,i=void 0){const r=this.safeString2(e,t,s,i);return void 0!==r&&(e=this.omit(e,[t,s])),[r,e]}handleParamInteger(e,t,s=void 0){const i=this.safeInteger(e,t,s);return void 0!==i&&(e=this.omit(e,t)),[i,e]}handleParamInteger2(e,t,s,i=void 0){const r=this.safeInteger2(e,t,s,i);return void 0!==r&&(e=this.omit(e,[t,s])),[r,e]}handleParamBool(e,t,s=void 0){const i=this.safeBool(e,t,s);return void 0!==i&&(e=this.omit(e,t)),[i,e]}handleParamBool2(e,t,s,i=void 0){const r=this.safeBool2(e,t,s,i);return void 0!==r&&(e=this.omit(e,[t,s])),[r,e]}resolvePath(e,t){return[this.implodeParams(e,t),this.omit(t,this.extractParams(e))]}getListFromObjectValues(e,t){let s=e;Array.isArray(e)||(s=this.toArray(e));const i=[];for(let e=0;e<s.length;e++)i.push(s[e][t]);return i}getSymbolsForMarketType(e=void 0,t=void 0,s=!0,i=!0){let r=this.markets;void 0!==e&&(r=this.filterBy(r,"type",e)),void 0!==t&&(this.checkRequiredArgument("getSymbolsForMarketType",t,"subType",["linear","inverse","quanto"]),r=this.filterBy(r,"subType",t));const a=[];return s&&a.push(!0),i&&a.push(void 0),r=this.filterByArray(r,"active",a,!1),this.getListFromObjectValues(r,"symbol")}filterByArray(e,t,s=void 0,i=!0){if(e=this.toArray(e),void 0===s||!s)return i?this.indexBy(e,t):e;const r=[];for(let i=0;i<e.length;i++)this.inArray(e[i][t],s)&&r.push(e[i]);return i?this.indexBy(r,t):r}async fetch2(e,t="public",s="GET",i={},r=void 0,a=void 0,n={}){if(this.enableRateLimit){const r=this.calculateRateLimiterCost(t,s,e,i,n);await this.throttle(r)}this.lastRestRequestTimestamp=this.milliseconds();const d=this.sign(e,t,s,i,r,a);let h,c;this.last_request_headers=d.headers,this.last_request_body=d.body,this.last_request_url=d.url,[h,i]=this.handleOptionAndParams(i,e,"maxRetriesOnFailure",0),[c,i]=this.handleOptionAndParams(i,e,"maxRetriesOnFailureDelay",0);for(let e=0;e<h+1;e++)try{return await this.fetch(d.url,d.method,d.headers,d.body)}catch(t){if(t instanceof o.NetworkError&&e<h){this.verbose&&this.log("Request failed with the error: "+t.toString()+", retrying "+(e+1).toString()+" of "+h.toString()+"..."),void 0!==c&&0!==c&&await this.sleep(c);continue}throw t}}async request(e,t="public",s="GET",i={},r=void 0,a=void 0,o={}){return await this.fetch2(e,t,s,i,r,a,o)}async loadAccounts(e=!1,t={}){if(e)this.accounts=await this.fetchAccounts(t);else{if(this.accounts)return this.accounts;this.accounts=await this.fetchAccounts(t)}return this.accountsById=this.indexBy(this.accounts,"id"),this.accounts}buildOHLCVC(e,t="1m",s=0,i=2147483647){const r=1e3*this.parseTimeframe(t),a=[],o=e.length,n=Math.min(o,i);for(let t=0;t<n;t++){const i=e[t],o=i.timestamp;if(o<s)continue;const n=Math.floor(o/r)*r;if(n<s)continue;const d=a.length-1;-1===d||n>=this.sum(a[d][0],r)?a.push([n,i.price,i.price,i.price,i.price,i.amount,1]):(a[d][2]=Math.max(a[d][2],i.price),a[d][3]=Math.min(a[d][3],i.price),a[d][4]=i.price,a[d][5]=this.sum(a[d][5],i.amount),a[d][6]=this.sum(a[d][6],1))}return a}parseTradingViewOHLCV(e,t=void 0,s="1m",i=void 0,r=void 0){const a=this.convertTradingViewToOHLCV(e);return this.parseOHLCVs(a,t,s,i,r)}async editLimitBuyOrder(e,t,s,i=void 0,r={}){return await this.editLimitOrder(e,t,"buy",s,i,r)}async editLimitSellOrder(e,t,s,i=void 0,r={}){return await this.editLimitOrder(e,t,"sell",s,i,r)}async editLimitOrder(e,t,s,i,r=void 0,a={}){return await this.editOrder(e,t,"limit",s,i,r,a)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){return await this.cancelOrder(e,t),await this.createOrder(t,s,i,r,a,o)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){return await this.cancelOrderWs(e,t),await this.createOrderWs(t,s,i,r,a,o)}async fetchPermissions(e={}){throw new o.NotSupported(this.id+" fetchPermissions() is not supported yet")}async fetchPosition(e,t={}){throw new o.NotSupported(this.id+" fetchPosition() is not supported yet")}async fetchPositionWs(e,t={}){throw new o.NotSupported(this.id+" fetchPositionWs() is not supported yet")}async watchPosition(e=void 0,t={}){throw new o.NotSupported(this.id+" watchPosition() is not supported yet")}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchPositions() is not supported yet")}async watchPositionForSymbols(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPositions(e,t,s,i)}async fetchPositionsForSymbol(e,t={}){throw new o.NotSupported(this.id+" fetchPositionsForSymbol() is not supported yet")}async fetchPositionsForSymbolWs(e,t={}){throw new o.NotSupported(this.id+" fetchPositionsForSymbol() is not supported yet")}async fetchPositions(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchPositions() is not supported yet")}async fetchPositionsWs(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchPositions() is not supported yet")}async fetchPositionsRisk(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchPositionsRisk() is not supported yet")}async fetchBidsAsks(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchBidsAsks() is not supported yet")}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){throw new o.NotSupported(this.id+" fetchBorrowInterest() is not supported yet")}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchLedger() is not supported yet")}async fetchLedgerEntry(e,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchLedgerEntry() is not supported yet")}parseBidAsk(e,t=0,s=1,i=2){const r=this.safeNumber(e,t),a=this.safeNumber(e,s),o=this.safeInteger(e,i),n=[r,a];return void 0!==o&&n.push(o),n}safeCurrency(e,t=void 0){if(void 0===e&&void 0!==t)return t;if(void 0!==this.currencies_by_id&&e in this.currencies_by_id&&void 0!==this.currencies_by_id[e])return this.currencies_by_id[e];let s=e;return void 0!==e&&(s=this.commonCurrencyCode(e.toUpperCase())),this.safeCurrencyStructure({id:e,code:s,precision:void 0})}safeMarket(e,t=void 0,s=void 0,i=void 0){const r=this.safeMarketStructure({symbol:e,marketId:e});if(void 0!==e)if(void 0!==this.markets_by_id&&e in this.markets_by_id){const s=this.markets_by_id[e];if(1===s.length)return s[0];if(void 0===i){if(void 0===t)throw new o.ArgumentsRequired(this.id+" safeMarket() requires a fourth argument for "+e+" to disambiguate between different markets with the same market id");i=t.type}for(let e=0;e<s.length;e++){const t=s[e];if(t[i])return t}}else if(void 0!==s&&""!==s){const t=e.split(s);return 2===t.length?(r.baseId=this.safeString(t,0),r.quoteId=this.safeString(t,1),r.base=this.safeCurrencyCode(r.baseId),r.quote=this.safeCurrencyCode(r.quoteId),r.symbol=r.base+"/"+r.quote,r):r}return void 0!==t?t:r}checkRequiredCredentials(e=!0){const t=Object.keys(this.requiredCredentials);for(let s=0;s<t.length;s++){const i=t[s];if(this.requiredCredentials[i]&&!this[i]){if(e)throw new o.AuthenticationError(this.id+' requires "'+i+'" credential');return!1}}return!0}oath(){if(void 0!==this.twofa)return(0,u.A)(this.twofa);throw new o.ExchangeError(this.id+" exchange.twofa has not been set for 2FA Two-Factor Authentication")}async fetchBalance(e={}){throw new o.NotSupported(this.id+" fetchBalance() is not supported yet")}async fetchBalanceWs(e={}){throw new o.NotSupported(this.id+" fetchBalanceWs() is not supported yet")}parseBalance(e){throw new o.NotSupported(this.id+" parseBalance() is not supported yet")}async watchBalance(e={}){throw new o.NotSupported(this.id+" watchBalance() is not supported yet")}async fetchPartialBalance(e,t={}){return(await this.fetchBalance(t))[e]}async fetchFreeBalance(e={}){return await this.fetchPartialBalance("free",e)}async fetchUsedBalance(e={}){return await this.fetchPartialBalance("used",e)}async fetchTotalBalance(e={}){return await this.fetchPartialBalance("total",e)}async fetchStatus(e={}){throw new o.NotSupported(this.id+" fetchStatus() is not supported yet")}async fetchTransactionFee(e,t={}){if(!this.has.fetchTransactionFees)throw new o.NotSupported(this.id+" fetchTransactionFee() is not supported yet");return await this.fetchTransactionFees([e],t)}async fetchTransactionFees(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchTransactionFees() is not supported yet")}async fetchDepositWithdrawFees(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchDepositWithdrawFees() is not supported yet")}async fetchDepositWithdrawFee(e,t={}){if(!this.has.fetchDepositWithdrawFees)throw new o.NotSupported(this.id+" fetchDepositWithdrawFee() is not supported yet");const s=await this.fetchDepositWithdrawFees([e],t);return this.safeValue(s,e)}getSupportedMapping(e,t={}){if(e in t)return t[e];throw new o.NotSupported(this.id+" "+e+" does not have a value in mapping")}async fetchCrossBorrowRate(e,t={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new o.NotSupported(this.id+" fetchCrossBorrowRate() is not supported yet");const s=await this.fetchCrossBorrowRates(t),i=this.safeValue(s,e);if(void 0===i)throw new o.ExchangeError(this.id+" fetchCrossBorrowRate() could not find the borrow rate for currency code "+e);return i}async fetchIsolatedBorrowRate(e,t={}){if(await this.loadMarkets(),!this.has.fetchBorrowRates)throw new o.NotSupported(this.id+" fetchIsolatedBorrowRate() is not supported yet");const s=await this.fetchIsolatedBorrowRates(t),i=this.safeDict(s,e);if(void 0===i)throw new o.ExchangeError(this.id+" fetchIsolatedBorrowRate() could not find the borrow rate for market symbol "+e);return i}handleOptionAndParams(e,t,s,i=void 0){const r="default"+this.capitalize(s);let a=this.safeValue2(e,s,r);if(void 0!==a)e=this.omit(e,[s,r]);else{[t,e]=this.handleParamString(e,"callerMethodName",t);const o=this.safeValue(this.options,t);void 0!==o&&(a=this.safeValue2(o,s,r)),void 0===a&&(a=this.safeValue2(this.options,s,r)),a=void 0!==a?a:i}return[a,e]}handleOptionAndParams2(e,t,s,i,r=void 0){let a,o;return[a,e]=this.handleOptionAndParams(e,t,s,r),[o,e]=this.handleOptionAndParams(e,t,i,a),[o,e]}handleOption(e,t,s=void 0){const[i,r]=this.handleOptionAndParams({},e,t,s);return i}handleMarketTypeAndParams(e,t=void 0,s={},i=void 0){const r=this.safeString2(this.options,"defaultType","type","spot");void 0===i&&(i=r);const a=this.safeDict(this.options,e);let o=i;void 0!==a&&(o="string"==typeof a?a:this.safeString2(a,"defaultType","type",o));const n=void 0===t?o:t.type;return[this.safeString2(s,"defaultType","type",n),s=this.omit(s,["defaultType","type"])]}handleSubTypeAndParams(e,t=void 0,s={},i=void 0){let r;const a=this.safeString2(s,"subType","defaultSubType");if(void 0!==a)r=a,s=this.omit(s,["subType","defaultSubType"]);else if(void 0!==t&&(t.linear?r="linear":t.inverse&&(r="inverse")),void 0===r){r=this.handleOptionAndParams({},e,"subType",i)[0]}return[r,s]}handleMarginModeAndParams(e,t={},s=void 0){return this.handleOptionAndParams(t,e,"marginMode",s)}throwExactlyMatchedException(e,t,s){if(void 0!==t&&t in e)throw new e[t](s)}throwBroadlyMatchedException(e,t,s){const i=this.findBroadlyMatchedKey(e,t);if(void 0!==i)throw new e[i](s)}findBroadlyMatchedKey(e,t){const s=Object.keys(e);for(let e=0;e<s.length;e++){const i=s[e];if(void 0!==t&&t.indexOf(i)>=0)return i}}handleErrors(e,t,s,i,r,a,o,n,d){}calculateRateLimiterCost(e,t,s,i,r={}){return this.safeValue(r,"cost",1)}async fetchTicker(e,t={}){if(this.has.fetchTickers){await this.loadMarkets();e=this.market(e).symbol;const s=await this.fetchTickers([e],t),i=this.safeDict(s,e);if(void 0===i)throw new o.NullResponse(this.id+" fetchTickers() could not find a ticker for "+e);return i}throw new o.NotSupported(this.id+" fetchTicker() is not supported yet")}async fetchTickerWs(e,t={}){if(this.has.fetchTickersWs){await this.loadMarkets();e=this.market(e).symbol;const s=await this.fetchTickersWs([e],t),i=this.safeDict(s,e);if(void 0===i)throw new o.NullResponse(this.id+" fetchTickerWs() could not find a ticker for "+e);return i}throw new o.NotSupported(this.id+" fetchTickerWs() is not supported yet")}async watchTicker(e,t={}){throw new o.NotSupported(this.id+" watchTicker() is not supported yet")}async fetchTickers(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchTickers() is not supported yet")}async fetchTickersWs(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchTickers() is not supported yet")}async fetchOrderBooks(e=void 0,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchOrderBooks() is not supported yet")}async watchBidsAsks(e=void 0,t={}){throw new o.NotSupported(this.id+" watchBidsAsks() is not supported yet")}async watchTickers(e=void 0,t={}){throw new o.NotSupported(this.id+" watchTickers() is not supported yet")}async fetchOrder(e,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchOrder() is not supported yet")}async fetchOrderWs(e,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchOrderWs() is not supported yet")}async fetchOrderStatus(e,t=void 0,s={}){return(await this.fetchOrder(e,t,s)).status}async fetchUnifiedOrder(e,t={}){return await this.fetchOrder(this.safeString(e,"id"),this.safeString(e,"symbol"),t)}async createOrder(e,t,s,i,r=void 0,a={}){throw new o.NotSupported(this.id+" createOrder() is not supported yet")}async createTrailingAmountOrder(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTrailingAmountOrder() requires a trailingAmount argument");if(d.trailingAmount=a,void 0!==n&&(d.trailingTriggerPrice=n),this.has.createTrailingAmountOrder)return await this.createOrder(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createTrailingAmountOrder() is not supported yet")}async createTrailingAmountOrderWs(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTrailingAmountOrderWs() requires a trailingAmount argument");if(d.trailingAmount=a,void 0!==n&&(d.trailingTriggerPrice=n),this.has.createTrailingAmountOrderWs)return await this.createOrderWs(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createTrailingAmountOrderWs() is not supported yet")}async createTrailingPercentOrder(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingPercent argument");if(d.trailingPercent=a,void 0!==n&&(d.trailingTriggerPrice=n),this.has.createTrailingPercentOrder)return await this.createOrder(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createTrailingPercentOrder() is not supported yet")}async createTrailingPercentOrderWs(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTrailingPercentOrderWs() requires a trailingPercent argument");if(d.trailingPercent=a,void 0!==n&&(d.trailingTriggerPrice=n),this.has.createTrailingPercentOrderWs)return await this.createOrderWs(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createTrailingPercentOrderWs() is not supported yet")}async createMarketOrderWithCost(e,t,s,i={}){if(this.has.createMarketOrderWithCost||this.has.createMarketBuyOrderWithCost&&this.has.createMarketSellOrderWithCost)return await this.createOrder(e,"market",t,s,1,i);throw new o.NotSupported(this.id+" createMarketOrderWithCost() is not supported yet")}async createMarketBuyOrderWithCost(e,t,s={}){if(this.options.createMarketBuyOrderRequiresPrice||this.has.createMarketBuyOrderWithCost)return await this.createOrder(e,"market","buy",t,1,s);throw new o.NotSupported(this.id+" createMarketBuyOrderWithCost() is not supported yet")}async createMarketSellOrderWithCost(e,t,s={}){if(this.options.createMarketSellOrderRequiresPrice||this.has.createMarketSellOrderWithCost)return await this.createOrder(e,"market","sell",t,1,s);throw new o.NotSupported(this.id+" createMarketSellOrderWithCost() is not supported yet")}async createMarketOrderWithCostWs(e,t,s,i={}){if(this.has.createMarketOrderWithCostWs||this.has.createMarketBuyOrderWithCostWs&&this.has.createMarketSellOrderWithCostWs)return await this.createOrderWs(e,"market",t,s,1,i);throw new o.NotSupported(this.id+" createMarketOrderWithCostWs() is not supported yet")}async createTriggerOrder(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTriggerOrder() requires a triggerPrice argument");if(n.triggerPrice=a,this.has.createTriggerOrder)return await this.createOrder(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createTriggerOrder() is not supported yet")}async createTriggerOrderWs(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTriggerOrderWs() requires a triggerPrice argument");if(n.triggerPrice=a,this.has.createTriggerOrderWs)return await this.createOrderWs(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createTriggerOrderWs() is not supported yet")}async createStopLossOrder(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createStopLossOrder() requires a stopLossPrice argument");if(n.stopLossPrice=a,this.has.createStopLossOrder)return await this.createOrder(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createStopLossOrder() is not supported yet")}async createStopLossOrderWs(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createStopLossOrderWs() requires a stopLossPrice argument");if(n.stopLossPrice=a,this.has.createStopLossOrderWs)return await this.createOrderWs(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createStopLossOrderWs() is not supported yet")}async createTakeProfitOrder(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTakeProfitOrder() requires a takeProfitPrice argument");if(n.takeProfitPrice=a,this.has.createTakeProfitOrder)return await this.createOrder(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createTakeProfitOrder() is not supported yet")}async createTakeProfitOrderWs(e,t,s,i,r=void 0,a=void 0,n={}){if(void 0===a)throw new o.ArgumentsRequired(this.id+" createTakeProfitOrderWs() requires a takeProfitPrice argument");if(n.takeProfitPrice=a,this.has.createTakeProfitOrderWs)return await this.createOrderWs(e,t,s,i,r,n);throw new o.NotSupported(this.id+" createTakeProfitOrderWs() is not supported yet")}async createOrderWithTakeProfitAndStopLoss(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(d=this.setTakeProfitAndStopLossParams(e,t,s,i,r,a,n,d),this.has.createOrderWithTakeProfitAndStopLoss)return await this.createOrder(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createOrderWithTakeProfitAndStopLoss() is not supported yet")}setTakeProfitAndStopLossParams(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(void 0===a&&void 0===n)throw new o.ArgumentsRequired(this.id+" createOrderWithTakeProfitAndStopLoss() requires either a takeProfit or stopLoss argument");void 0!==a&&(d.takeProfit={triggerPrice:a}),void 0!==n&&(d.stopLoss={triggerPrice:n});const h=this.safeString(d,"takeProfitType"),c=this.safeString(d,"takeProfitPriceType"),l=this.safeString(d,"takeProfitLimitPrice"),u=this.safeString(d,"takeProfitAmount"),p=this.safeString(d,"stopLossType"),f=this.safeString(d,"stopLossPriceType"),m=this.safeString(d,"stopLossLimitPrice"),g=this.safeString(d,"stopLossAmount");return void 0!==h&&(d.takeProfit.type=h),void 0!==c&&(d.takeProfit.priceType=c),void 0!==l&&(d.takeProfit.price=this.parseToNumeric(l)),void 0!==u&&(d.takeProfit.amount=this.parseToNumeric(u)),void 0!==p&&(d.stopLoss.type=p),void 0!==f&&(d.stopLoss.priceType=f),void 0!==m&&(d.stopLoss.price=this.parseToNumeric(m)),void 0!==g&&(d.stopLoss.amount=this.parseToNumeric(g)),d=this.omit(d,["takeProfitType","takeProfitPriceType","takeProfitLimitPrice","takeProfitAmount","stopLossType","stopLossPriceType","stopLossLimitPrice","stopLossAmount"])}async createOrderWithTakeProfitAndStopLossWs(e,t,s,i,r=void 0,a=void 0,n=void 0,d={}){if(d=this.setTakeProfitAndStopLossParams(e,t,s,i,r,a,n,d),this.has.createOrderWithTakeProfitAndStopLossWs)return await this.createOrderWs(e,t,s,i,r,d);throw new o.NotSupported(this.id+" createOrderWithTakeProfitAndStopLossWs() is not supported yet")}async createOrders(e,t={}){throw new o.NotSupported(this.id+" createOrders() is not supported yet")}async createOrderWs(e,t,s,i,r=void 0,a={}){throw new o.NotSupported(this.id+" createOrderWs() is not supported yet")}async cancelOrder(e,t=void 0,s={}){throw new o.NotSupported(this.id+" cancelOrder() is not supported yet")}async cancelOrderWs(e,t=void 0,s={}){throw new o.NotSupported(this.id+" cancelOrderWs() is not supported yet")}async cancelOrdersWs(e,t=void 0,s={}){throw new o.NotSupported(this.id+" cancelOrdersWs() is not supported yet")}async cancelAllOrders(e=void 0,t={}){throw new o.NotSupported(this.id+" cancelAllOrders() is not supported yet")}async cancelAllOrdersAfter(e,t={}){throw new o.NotSupported(this.id+" cancelAllOrdersAfter() is not supported yet")}async cancelOrdersForSymbols(e,t={}){throw new o.NotSupported(this.id+" cancelOrdersForSymbols() is not supported yet")}async cancelAllOrdersWs(e=void 0,t={}){throw new o.NotSupported(this.id+" cancelAllOrdersWs() is not supported yet")}async cancelUnifiedOrder(e,t={}){return this.cancelOrder(this.safeString(e,"id"),this.safeString(e,"symbol"),t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchOpenOrders&&this.has.fetchClosedOrders)throw new o.NotSupported(this.id+" fetchOrders() is not supported yet, consider using fetchOpenOrders() and fetchClosedOrders() instead");throw new o.NotSupported(this.id+" fetchOrders() is not supported yet")}async fetchOrdersWs(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchOrdersWs() is not supported yet")}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){throw new o.NotSupported(this.id+" fetchOrderTrades() is not supported yet")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchOrders() is not supported yet")}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchOrders){const r=await this.fetchOrders(e,t,s,i);return this.filterBy(r,"status","open")}throw new o.NotSupported(this.id+" fetchOpenOrders() is not supported yet")}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchOrdersWs){const r=await this.fetchOrdersWs(e,t,s,i);return this.filterBy(r,"status","open")}throw new o.NotSupported(this.id+" fetchOpenOrdersWs() is not supported yet")}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchOrders){const r=await this.fetchOrders(e,t,s,i);return this.filterBy(r,"status","closed")}throw new o.NotSupported(this.id+" fetchClosedOrders() is not supported yet")}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchCanceledAndClosedOrders() is not supported yet")}async fetchClosedOrdersWs(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchOrdersWs){const r=await this.fetchOrdersWs(e,t,s,i);return this.filterBy(r,"status","closed")}throw new o.NotSupported(this.id+" fetchClosedOrdersWs() is not supported yet")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchMyTrades() is not supported yet")}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchMyLiquidations() is not supported yet")}async fetchLiquidations(e,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchLiquidations() is not supported yet")}async fetchMyTradesWs(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchMyTradesWs() is not supported yet")}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" watchMyTrades() is not supported yet")}async fetchGreeks(e,t={}){throw new o.NotSupported(this.id+" fetchGreeks() is not supported yet")}async fetchOptionChain(e,t={}){throw new o.NotSupported(this.id+" fetchOptionChain() is not supported yet")}async fetchOption(e,t={}){throw new o.NotSupported(this.id+" fetchOption() is not supported yet")}async fetchConvertQuote(e,t,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchConvertQuote() is not supported yet")}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchDepositsWithdrawals() is not supported yet")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchDeposits() is not supported yet")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchWithdrawals() is not supported yet")}async fetchDepositsWs(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchDepositsWs() is not supported yet")}async fetchWithdrawalsWs(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchWithdrawalsWs() is not supported yet")}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchFundingRateHistory() is not supported yet")}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchFundingHistory() is not supported yet")}async closePosition(e,t=void 0,s={}){throw new o.NotSupported(this.id+" closePosition() is not supported yet")}async closeAllPositions(e={}){throw new o.NotSupported(this.id+" closeAllPositions() is not supported yet")}async fetchL3OrderBook(e,t=void 0,s={}){throw new o.BadRequest(this.id+" fetchL3OrderBook() is not supported yet")}parseLastPrice(e,t=void 0){throw new o.NotSupported(this.id+" parseLastPrice() is not supported yet")}async fetchDepositAddress(e,t={}){if(this.has.fetchDepositAddresses){const s=await this.fetchDepositAddresses([e],t),i=this.safeValue(s,e);if(void 0===i)throw new o.InvalidAddress(this.id+" fetchDepositAddress() could not find a deposit address for "+e+", make sure you have created a corresponding deposit address in your wallet on the exchange website");return i}if(this.has.fetchDepositAddressesByNetwork){const s=this.safeString(t,"network");t=this.omit(t,"network");const i=await this.fetchDepositAddressesByNetwork(e,t);if(void 0!==s)return this.safeDict(i,s);{const e=Object.keys(i),t=this.safeString(e,0);return this.safeDict(i,t)}}throw new o.NotSupported(this.id+" fetchDepositAddress() is not supported yet")}account(){return{free:void 0,used:void 0,total:void 0}}commonCurrencyCode(e){return this.substituteCommonCurrencyCodes?this.safeString(this.commonCurrencies,e,e):e}currency(e){if(void 0===this.currencies)throw new o.ExchangeError(this.id+" currencies not loaded");if("string"==typeof e){if(e in this.currencies)return this.currencies[e];if(e in this.currencies_by_id)return this.currencies_by_id[e]}throw new o.ExchangeError(this.id+" does not have currency code "+e)}market(e){if(void 0===this.markets)throw new o.ExchangeError(this.id+" markets not loaded");if(e in this.markets)return this.markets[e];if(e in this.markets_by_id){const t=this.markets_by_id[e],s=this.safeString2(this.options,"defaultType","defaultSubType","spot");for(let e=0;e<t.length;e++){const i=t[e];if(i[s])return i}return t[0]}if(e.endsWith("-C")||e.endsWith("-P")||e.startsWith("C-")||e.startsWith("P-"))return this.createExpiredOptionMarket(e);throw new o.BadSymbol(this.id+" does not have market symbol "+e)}createExpiredOptionMarket(e){throw new o.NotSupported(this.id+" createExpiredOptionMarket () is not supported yet")}handleWithdrawTagAndParams(e,t){return void 0!==e&&"object"==typeof e&&(t=this.extend(e,t),e=void 0),void 0===e&&void 0!==(e=this.safeString(t,"tag"))&&(t=this.omit(t,"tag")),[e,t]}async createLimitOrder(e,t,s,i,r={}){return await this.createOrder(e,"limit",t,s,i,r)}async createLimitOrderWs(e,t,s,i,r={}){return await this.createOrderWs(e,"limit",t,s,i,r)}async createMarketOrder(e,t,s,i=void 0,r={}){return await this.createOrder(e,"market",t,s,i,r)}async createMarketOrderWs(e,t,s,i=void 0,r={}){return await this.createOrderWs(e,"market",t,s,i,r)}async createLimitBuyOrder(e,t,s,i={}){return await this.createOrder(e,"limit","buy",t,s,i)}async createLimitBuyOrderWs(e,t,s,i={}){return await this.createOrderWs(e,"limit","buy",t,s,i)}async createLimitSellOrder(e,t,s,i={}){return await this.createOrder(e,"limit","sell",t,s,i)}async createLimitSellOrderWs(e,t,s,i={}){return await this.createOrderWs(e,"limit","sell",t,s,i)}async createMarketBuyOrder(e,t,s={}){return await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketBuyOrderWs(e,t,s={}){return await this.createOrderWs(e,"market","buy",t,void 0,s)}async createMarketSellOrder(e,t,s={}){return await this.createOrder(e,"market","sell",t,void 0,s)}async createMarketSellOrderWs(e,t,s={}){return await this.createOrderWs(e,"market","sell",t,void 0,s)}costToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,ct,s.precision.price,this.precisionMode,this.paddingMode)}priceToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,lt,s.precision.price,this.precisionMode,this.paddingMode);if("0"===i)throw new o.InvalidOrder(this.id+" price of "+s.symbol+" must be greater than minimum price precision of "+this.numberToString(s.precision.price));return i}amountToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,ct,s.precision.amount,this.precisionMode,this.paddingMode);if("0"===i)throw new o.InvalidOrder(this.id+" amount of "+s.symbol+" must be greater than minimum amount precision of "+this.numberToString(s.precision.amount));return i}feeToPrecision(e,t){const s=this.market(e);return this.decimalToPrecision(t,lt,s.precision.price,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){const i=this.currencies[e];let r=this.safeValue(i,"precision");if(void 0!==s){const e=this.safeDict(i,"networks",{}),t=this.safeDict(e,s,{});r=this.safeValue(t,"precision",r)}return void 0===r?this.forceString(t):this.decimalToPrecision(t,lt,r,this.precisionMode,this.paddingMode)}forceString(e){return"string"!=typeof e?this.numberToString(e):e}isTickPrecision(){return this.precisionMode===ft}isDecimalPrecision(){return this.precisionMode===ut}isSignificantPrecision(){return this.precisionMode===mt}safeNumber(e,t,s=void 0){const i=this.safeString(e,t);return this.parseNumber(i,s)}safeNumberN(e,t,s=void 0){const i=this.safeStringN(e,t);return this.parseNumber(i,s)}parsePrecision(e){if(void 0===e)return;const t=parseInt(e);if(0===t)return"1";let s="0.";for(let e=0;e<t-1;e++)s+="0";return s+"1"}integerPrecisionToAmount(e){if(void 0!==e){if(n.Y.stringGe(e,"0"))return this.parsePrecision(e);{const t=n.Y.stringAbs(e),s=parseInt(t);let i="1";for(let e=0;e<s-1;e++)i+="0";return i+"0"}}}async loadTimeDifference(e={}){const t=await this.fetchTime(e),s=this.milliseconds();return this.options.timeDifference=s-t,this.options.timeDifference}implodeHostname(e){return this.implodeParams(e,{hostname:this.hostname})}async fetchMarketLeverageTiers(e,t={}){if(this.has.fetchLeverageTiers){if(!this.market(e).contract)throw new o.BadSymbol(this.id+" fetchMarketLeverageTiers() supports contract markets only");const t=await this.fetchLeverageTiers([e]);return this.safeValue(t,e)}throw new o.NotSupported(this.id+" fetchMarketLeverageTiers() is not supported yet")}async createPostOnlyOrder(e,t,s,i,r=void 0,a={}){if(!this.has.createPostOnlyOrder)throw new o.NotSupported(this.id+"createPostOnlyOrder() is not supported yet");const n=this.extend(a,{postOnly:!0});return await this.createOrder(e,t,s,i,r,n)}async createPostOnlyOrderWs(e,t,s,i,r=void 0,a={}){if(!this.has.createPostOnlyOrderWs)throw new o.NotSupported(this.id+"createPostOnlyOrderWs() is not supported yet");const n=this.extend(a,{postOnly:!0});return await this.createOrderWs(e,t,s,i,r,n)}async createReduceOnlyOrder(e,t,s,i,r=void 0,a={}){if(!this.has.createReduceOnlyOrder)throw new o.NotSupported(this.id+"createReduceOnlyOrder() is not supported yet");const n=this.extend(a,{reduceOnly:!0});return await this.createOrder(e,t,s,i,r,n)}async createReduceOnlyOrderWs(e,t,s,i,r=void 0,a={}){if(!this.has.createReduceOnlyOrderWs)throw new o.NotSupported(this.id+"createReduceOnlyOrderWs() is not supported yet");const n=this.extend(a,{reduceOnly:!0});return await this.createOrderWs(e,t,s,i,r,n)}async createStopOrder(e,t,s,i,r=void 0,a=void 0,n={}){if(!this.has.createStopOrder)throw new o.NotSupported(this.id+" createStopOrder() is not supported yet");if(void 0===a)throw new o.ArgumentsRequired(this.id+" create_stop_order() requires a stopPrice argument");const d=this.extend(n,{stopPrice:a});return await this.createOrder(e,t,s,i,r,d)}async createStopOrderWs(e,t,s,i,r=void 0,a=void 0,n={}){if(!this.has.createStopOrderWs)throw new o.NotSupported(this.id+" createStopOrderWs() is not supported yet");if(void 0===a)throw new o.ArgumentsRequired(this.id+" createStopOrderWs() requires a stopPrice argument");const d=this.extend(n,{stopPrice:a});return await this.createOrderWs(e,t,s,i,r,d)}async createStopLimitOrder(e,t,s,i,r,a={}){if(!this.has.createStopLimitOrder)throw new o.NotSupported(this.id+" createStopLimitOrder() is not supported yet");const n=this.extend(a,{stopPrice:r});return await this.createOrder(e,"limit",t,s,i,n)}async createStopLimitOrderWs(e,t,s,i,r,a={}){if(!this.has.createStopLimitOrderWs)throw new o.NotSupported(this.id+" createStopLimitOrderWs() is not supported yet");const n=this.extend(a,{stopPrice:r});return await this.createOrderWs(e,"limit",t,s,i,n)}async createStopMarketOrder(e,t,s,i,r={}){if(!this.has.createStopMarketOrder)throw new o.NotSupported(this.id+" createStopMarketOrder() is not supported yet");const a=this.extend(r,{stopPrice:i});return await this.createOrder(e,"market",t,s,void 0,a)}async createStopMarketOrderWs(e,t,s,i,r={}){if(!this.has.createStopMarketOrderWs)throw new o.NotSupported(this.id+" createStopMarketOrderWs() is not supported yet");const a=this.extend(r,{stopPrice:i});return await this.createOrderWs(e,"market",t,s,void 0,a)}safeCurrencyCode(e,t=void 0){return(t=this.safeCurrency(e,t)).code}filterBySymbolSinceLimit(e,t=void 0,s=void 0,i=void 0,r=!1){return this.filterByValueSinceLimit(e,"symbol",t,s,i,"timestamp",r)}filterByCurrencySinceLimit(e,t=void 0,s=void 0,i=void 0,r=!1){return this.filterByValueSinceLimit(e,"currency",t,s,i,"timestamp",r)}filterBySymbolsSinceLimit(e,t=void 0,s=void 0,i=void 0,r=!1){const a=this.filterByArray(e,"symbol",t,!1);return this.filterBySinceLimit(a,s,i,"timestamp",r)}parseLastPrices(e,t=void 0,s={}){const i=[];if(Array.isArray(e))for(let t=0;t<e.length;t++){const r=this.extend(this.parseLastPrice(e[t]),s);i.push(r)}else{const t=Object.keys(e);for(let r=0;r<t.length;r++){const a=t[r],o=this.safeMarket(a),n=this.extend(this.parseLastPrice(e[a],o),s);i.push(n)}}return t=this.marketSymbols(t),this.filterByArray(i,"symbol",t)}parseTickers(e,t=void 0,s={}){const i=[];if(Array.isArray(e))for(let t=0;t<e.length;t++){const r=this.extend(this.parseTicker(e[t]),s);i.push(r)}else{const t=Object.keys(e);for(let r=0;r<t.length;r++){const a=t[r],o=this.safeMarket(a),n=this.extend(this.parseTicker(e[a],o),s);i.push(n)}}return t=this.marketSymbols(t),this.filterByArray(i,"symbol",t)}parseDepositAddresses(e,t=void 0,s=!0,i={}){let r=[];for(let t=0;t<e.length;t++){const s=this.extend(this.parseDepositAddress(e[t]),i);r.push(s)}return void 0!==t&&(r=this.filterByArray(r,"currency",t,!1)),s?this.indexBy(r,"currency"):r}parseBorrowInterests(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const r=e[i];s.push(this.parseBorrowInterest(r,t))}return s}parseIsolatedBorrowRates(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],r=this.parseIsolatedBorrowRate(i);t[this.safeString(r,"symbol")]=r}return t}parseFundingRateHistories(e,t=void 0,s=void 0,i=void 0){const r=[];for(let s=0;s<e.length;s++){const i=e[s];r.push(this.parseFundingRateHistory(i,t))}const a=this.sortBy(r,"timestamp"),o=void 0===t?void 0:t.symbol;return this.filterBySymbolSinceLimit(a,o,s,i)}safeSymbol(e,t=void 0,s=void 0,i=void 0){return(t=this.safeMarket(e,t,s,i)).symbol}parseFundingRate(e,t=void 0){throw new o.NotSupported(this.id+" parseFundingRate() is not supported yet")}parseFundingRates(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const r=this.parseFundingRate(e[i],t);s[r.symbol]=r}return s}handleTriggerAndParams(e){const t=this.safeBool2(e,"trigger","stop");return t&&(e=this.omit(e,["trigger","stop"])),[t,e]}isTriggerOrder(e){return this.handleTriggerAndParams(e)}isPostOnly(e,t,s={}){const i=this.safeStringUpper(s,"timeInForce");let r=this.safeBool2(s,"postOnly","post_only",!1);if(r=r||"PO"===i||t,r){if("IOC"===i||"FOK"===i)throw new o.InvalidOrder(this.id+" postOnly orders cannot have timeInForce equal to "+i);if(e)throw new o.InvalidOrder(this.id+" market orders cannot be postOnly");return!0}return!1}handlePostOnly(e,t,s={}){const i=this.safeStringUpper(s,"timeInForce");let r=this.safeBool(s,"postOnly",!1);const a="PO"===i;if(r=r||a||t,r){if("IOC"===i||"FOK"===i)throw new o.InvalidOrder(this.id+" postOnly orders cannot have timeInForce equal to "+i);if(e)throw new o.InvalidOrder(this.id+" market orders cannot be postOnly");return a&&(s=this.omit(s,"timeInForce")),[!0,s=this.omit(s,"postOnly")]}return[!1,s]}async fetchLastPrices(e=void 0,t={}){throw new o.NotSupported(this.id+" fetchLastPrices() is not supported yet")}async fetchTradingFees(e={}){throw new o.NotSupported(this.id+" fetchTradingFees() is not supported yet")}async fetchTradingFeesWs(e={}){throw new o.NotSupported(this.id+" fetchTradingFeesWs() is not supported yet")}async fetchTradingFee(e,t={}){if(!this.has.fetchTradingFees)throw new o.NotSupported(this.id+" fetchTradingFee() is not supported yet");const s=await this.fetchTradingFees(t);return this.safeDict(s,e)}async fetchConvertCurrencies(e={}){throw new o.NotSupported(this.id+" fetchConvertCurrencies() is not supported yet")}parseOpenInterest(e,t=void 0){throw new o.NotSupported(this.id+" parseOpenInterest () is not supported yet")}parseOpenInterests(e,t=void 0,s=void 0,i=void 0){const r=[];for(let s=0;s<e.length;s++){const i=e[s],a=this.parseOpenInterest(i,t);r.push(a)}const a=this.sortBy(r,"timestamp"),o=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(a,o,s,i)}async fetchFundingRate(e,t={}){if(this.has.fetchFundingRates){await this.loadMarkets();const s=this.market(e);if(e=s.symbol,!s.contract)throw new o.BadSymbol(this.id+" fetchFundingRate() supports contract markets only");const i=await this.fetchFundingRates([e],t),r=this.safeValue(i,e);if(void 0===r)throw new o.NullResponse(this.id+" fetchFundingRate () returned no data for "+e);return r}throw new o.NotSupported(this.id+" fetchFundingRate () is not supported yet")}async fetchMarkOHLCV(e,t="1m",s=void 0,i=void 0,r={}){if(this.has.fetchMarkOHLCV){const a={price:"mark"};return await this.fetchOHLCV(e,t,s,i,this.extend(a,r))}throw new o.NotSupported(this.id+" fetchMarkOHLCV () is not supported yet")}async fetchIndexOHLCV(e,t="1m",s=void 0,i=void 0,r={}){if(this.has.fetchIndexOHLCV){const a={price:"index"};return await this.fetchOHLCV(e,t,s,i,this.extend(a,r))}throw new o.NotSupported(this.id+" fetchIndexOHLCV () is not supported yet")}async fetchPremiumIndexOHLCV(e,t="1m",s=void 0,i=void 0,r={}){if(this.has.fetchPremiumIndexOHLCV){const a={price:"premiumIndex"};return await this.fetchOHLCV(e,t,s,i,this.extend(a,r))}throw new o.NotSupported(this.id+" fetchPremiumIndexOHLCV () is not supported yet")}handleTimeInForce(e={}){const t=this.safeStringUpper(e,"timeInForce");if(void 0!==t){const e=this.safeString(this.options.timeInForce,t);if(void 0===e)throw new o.ExchangeError(this.id+' does not support timeInForce "'+t+'"');return e}}convertTypeToAccount(e){const t=this.safeDict(this.options,"accountsByType",{}),s=e.toLowerCase();if(s in t)return t[s];if(e in this.markets||e in this.markets_by_id){return this.market(e).id}return e}checkRequiredArgument(e,t,s,i=[]){const r=i.length;if(void 0===t||r>0&&!this.inArray(t,i)){const t=i.join(", ");let r=this.id+" "+e+"() requires a "+s+" argument";throw""!==t&&(r+=", one of ("+t+")"),new o.ArgumentsRequired(r)}}checkRequiredMarginArgument(e,t,s){if("isolated"===s&&void 0===t)throw new o.ArgumentsRequired(this.id+" "+e+"() requires a symbol argument for isolated margin");if("cross"===s&&void 0!==t)throw new o.ArgumentsRequired(this.id+" "+e+"() cannot have a symbol argument for cross margin")}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={},r=Array.isArray(e);let a=e;r||(a=Object.keys(e));for(let o=0;o<a.length;o++){const n=a[o],d=r?n:e[n],h=r?this.safeString(d,s):n,c=this.safeCurrency(h),l=this.safeString(c,"code");(void 0===t||this.inArray(l,t))&&(i[l]=this.parseDepositWithdrawFee(d,c))}return i}parseDepositWithdrawFee(e,t=void 0){throw new o.NotSupported(this.id+" parseDepositWithdrawFee() is not supported yet")}depositWithdrawFee(e){return{info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}assignDefaultDepositWithdrawFees(e,t=void 0){const s=Object.keys(e.networks),i=s.length;if(1===i)return e.withdraw=e.networks[s[0]].withdraw,e.deposit=e.networks[s[0]].deposit,e;const r=this.safeString(t,"code");for(let t=0;t<i;t++){s[t]===r&&(e.withdraw=e.networks[s[t]].withdraw,e.deposit=e.networks[s[t]].deposit)}return e}parseIncome(e,t=void 0){throw new o.NotSupported(this.id+" parseIncome () is not supported yet")}parseIncomes(e,t=void 0,s=void 0,i=void 0){const r=[];for(let s=0;s<e.length;s++){const i=e[s],a=this.parseIncome(i,t);r.push(a)}const a=this.sortBy(r,"timestamp");return this.filterBySinceLimit(a,s,i)}getMarketFromSymbols(e=void 0){if(void 0===e)return;const t=this.safeString(e,0);return this.market(t)}parseWsOHLCVs(e,t=void 0,s="1m",i=void 0,r=void 0){const a=[];for(let s=0;s<e.length;s++)a.push(this.parseWsOHLCV(e[s],t));return a}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){if(this.has.fetchDepositsWithdrawals)return await this.fetchDepositsWithdrawals(e,t,s,i);throw new o.NotSupported(this.id+" fetchTransactions () is not supported yet")}filterByArrayPositions(e,t,s=void 0,i=!0){return this.filterByArray(e,t,s,i)}filterByArrayTickers(e,t,s=void 0,i=!0){return this.filterByArray(e,t,s,i)}createOHLCVObject(e,t,s){const i={};return i[e]={},i[e][t]=s,i}handleMaxEntriesPerRequestAndParams(e,t=void 0,s={}){let i;return[i,s]=this.handleOptionAndParams(s,e,"maxEntriesPerRequest"),void 0!==i&&i!==t&&(t=i),void 0===t&&(t=1e3),[t,s]}async fetchPaginatedCallDynamic(e,t=void 0,s=void 0,i=void 0,r={},a=void 0){let n,d,h,c;[n,r]=this.handleOptionAndParams(r,e,"paginationCalls",10),[d,r]=this.handleOptionAndParams(r,e,"maxRetries",3),[h,r]=this.handleOptionAndParams(r,e,"paginationDirection","backward");let l=0,u=[],p=0;const f=this.safeInteger2(r,"untill","till");if([a,r]=this.handleMaxEntriesPerRequestAndParams(e,a,r),"forward"===h){if(void 0===s)throw new o.ArgumentsRequired(this.id+" pagination requires a since argument when paginationDirection set to forward");c=s}for(;l<n;){l+=1;try{if("backward"===h){void 0!==c&&(r.until=c-1);const i=await this[e](t,void 0,a,r),o=i.length;if(this.verbose){let t="Dynamic pagination call "+this.numberToString(l)+" method "+e+" response length "+this.numberToString(o);void 0!==c&&(t+=" timestamp "+this.numberToString(c)),this.log(t)}if(0===o)break;p=0,u=this.arrayConcat(u,i);const n=this.safeValue(i,0);if(c=this.safeInteger2(n,"timestamp",0),void 0!==s&&c<=s)break}else{const s=await this[e](t,c,a,r),i=s.length;if(this.verbose){let t="Dynamic pagination call "+this.numberToString(l)+" method "+e+" response length "+this.numberToString(i);void 0!==c&&(t+=" timestamp "+this.numberToString(c)),this.log(t)}if(0===i)break;p=0,u=this.arrayConcat(u,s);const o=this.safeValue(s,i-1);if(c=this.safeInteger(o,"timestamp")+1,void 0!==f&&c>=f)break}}catch(e){if(p+=1,p>d)throw e}}const m=this.removeRepeatedElementsFromArray(u),g="fetchOHLCV"===e?0:"timestamp";return this.filterBySinceLimit(m,s,i,g)}async safeDeterministicCall(e,t=void 0,s=void 0,i=void 0,r=void 0,a={}){let n;[n,a]=this.handleOptionAndParams(a,e,"maxRetries",3);let d=0;for(;d<=n;)try{return r&&"fetchFundingRateHistory"!==e?await this[e](t,r,s,i,a):await this[e](t,s,i,a)}catch(e){if(e instanceof o.RateLimitExceeded)throw e;if(d+=1,d>n)throw e}return[]}async fetchPaginatedCallDeterministic(e,t=void 0,s=void 0,i=void 0,r=void 0,a={},n=void 0){let d;[d,a]=this.handleOptionAndParams(a,e,"paginationCalls",10),[n,a]=this.handleMaxEntriesPerRequestAndParams(e,n,a);const h=this.milliseconds(),c=[],l=1e3*this.parseTimeframe(r)*n;let u=h-d*l-1;u=void 0!==s?Math.max(u,s):Math.max(u,1241440531e3);const p=this.safeInteger2(a,"until","till");if(void 0!==p){const e=Math.ceil((p-s)/l);if(e>d)throw new o.BadRequest(this.id+" the number of required calls is greater than the max number of calls allowed, either increase the paginationCalls or decrease the since-until gap. Current paginationCalls limit is "+d.toString()+" required calls is "+e.toString())}for(let s=0;s<d&&!(void 0!==p&&u>=p)&&!(u>=h);s++)c.push(this.safeDeterministicCall(e,t,u,n,r,a)),u=this.sum(u,l)-1;const f=await Promise.all(c);let m=[];for(let e=0;e<f.length;e++)m=this.arrayConcat(m,f[e]);const g=this.removeRepeatedElementsFromArray(m),v="fetchOHLCV"===e?0:"timestamp";return this.filterBySinceLimit(g,s,i,v)}async fetchPaginatedCallCursor(e,t=void 0,s=void 0,i=void 0,r={},a=void 0,o=void 0,n=void 0,d=void 0){let h,c,l;[h,r]=this.handleOptionAndParams(r,e,"paginationCalls",10),[c,r]=this.handleOptionAndParams(r,e,"maxRetries",3),[d,r]=this.handleMaxEntriesPerRequestAndParams(e,d,r);let u=0,p=0,f=[];for(;u<h;){try{let i;void 0!==l&&(void 0!==n&&(l=this.parseToInt(l)+n),r[o]=l),i="fetchAccounts"===e?await this[e](r):"getLeverageTiersPaginated"===e||"fetchPositions"===e?await this[e](t,r):await this[e](t,s,d,r),p=0;const h=i.length;if(this.verbose){const t=void 0===l?"":l,s="Cursor pagination call "+(u+1).toString()+" method "+e+" response length "+h.toString()+" cursor "+t;this.log(s)}if(0===h)break;f=this.arrayConcat(f,i);const c=this.safeValue(i,h-1);if(l=this.safeValue(c.info,a),void 0===l)break;const m=this.safeInteger(c,"timestamp");if(void 0!==m&&m<s)break}catch(e){if(p+=1,p>c)throw e}u+=1}const m=this.sortCursorPaginatedResult(f),g="fetchOHLCV"===e?0:"timestamp";return this.filterBySinceLimit(m,s,i,g)}async fetchPaginatedCallIncremental(e,t=void 0,s=void 0,i=void 0,r={},a=void 0,o=void 0){let n,d;[n,r]=this.handleOptionAndParams(r,e,"paginationCalls",10),[d,r]=this.handleOptionAndParams(r,e,"maxRetries",3),[o,r]=this.handleMaxEntriesPerRequestAndParams(e,o,r);let h=0,c=0,l=[];for(;h<n;){try{r[a]=h+1;const i=await this[e](t,s,o,r);c=0;const n=i.length;if(this.verbose){const t="Incremental pagination call "+(h+1).toString()+" method "+e+" response length "+n.toString();this.log(t)}if(0===n)break;l=this.arrayConcat(l,i)}catch(e){if(c+=1,c>d)throw e}h+=1}const u=this.sortCursorPaginatedResult(l),p="fetchOHLCV"===e?0:"timestamp";return this.filterBySinceLimit(u,s,i,p)}sortCursorPaginatedResult(e){const t=this.safeValue(e,0);if(void 0!==t){if("timestamp"in t)return this.sortBy(e,"timestamp",!0);if("id"in t)return this.sortBy(e,"id",!0)}return e}removeRepeatedElementsFromArray(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"id");if(void 0!==r)void 0===this.safeString(t,r)&&(t[r]=i);else{const e=this.safeInteger2(i,"timestamp",0);void 0!==e&&void 0===this.safeString(t,e)&&(t[e]=i)}}const s=Object.values(t);return s.length>0?s:e}handleUntilOption(e,t,s,i=1){const r=this.safeInteger2(s,"until","till");return void 0!==r&&(t[e]=this.parseToInt(r*i),s=this.omit(s,["until","till"])),[t,s]}safeOpenInterest(e,t=void 0){let s=this.safeString(e,"symbol");return void 0===s&&(s=this.safeString(t,"symbol")),this.extend(e,{symbol:s,baseVolume:this.safeNumber(e,"baseVolume"),quoteVolume:this.safeNumber(e,"quoteVolume"),openInterestAmount:this.safeNumber(e,"openInterestAmount"),openInterestValue:this.safeNumber(e,"openInterestValue"),timestamp:this.safeInteger(e,"timestamp"),datetime:this.safeString(e,"datetime"),info:this.safeValue(e,"info")})}parseLiquidation(e,t=void 0){throw new o.NotSupported(this.id+" parseLiquidation () is not supported yet")}parseLiquidations(e,t=void 0,s=void 0,i=void 0){const r=[];for(let s=0;s<e.length;s++){const i=e[s],a=this.parseLiquidation(i,t);r.push(a)}const a=this.sortBy(r,"timestamp"),o=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(a,o,s,i)}parseGreeks(e,t=void 0){throw new o.NotSupported(this.id+" parseGreeks () is not supported yet")}parseOption(e,t=void 0,s=void 0){throw new o.NotSupported(this.id+" parseOption () is not supported yet")}parseOptionChain(e,t=void 0,s=void 0){const i={};for(let r=0;r<e.length;r++){const a=e[r],o=this.safeString(a,t),n=this.safeCurrency(o),d=this.safeString(a,s),h=this.safeMarket(d,void 0,void 0,"option");i[h.symbol]=this.parseOption(a,n,h)}return i}parseMarginModes(e,t=void 0,s=void 0,i=void 0){const r={};void 0===i&&(i="swap");for(let a=0;a<e.length;a++){const o=e[a],n=this.safeString(o,s),d=this.safeMarket(n,void 0,void 0,i);(void 0===t||this.inArray(d.symbol,t))&&(r[d.symbol]=this.parseMarginMode(o,d))}return r}parseMarginMode(e,t=void 0){throw new o.NotSupported(this.id+" parseMarginMode () is not supported yet")}parseLeverages(e,t=void 0,s=void 0,i=void 0){const r={};void 0===i&&(i="swap");for(let a=0;a<e.length;a++){const o=e[a],n=this.safeString(o,s),d=this.safeMarket(n,void 0,void 0,i);(void 0===t||this.inArray(d.symbol,t))&&(r[d.symbol]=this.parseLeverage(o,d))}return r}parseLeverage(e,t=void 0){throw new o.NotSupported(this.id+" parseLeverage () is not supported yet")}parseConversions(e,t=void 0,s=void 0,i=void 0,r=void 0,a=void 0,o={}){e=this.toArray(e);const n=[];let d,h;for(let t=0;t<e.length;t++){const r=e[t],a=this.safeString(r,s),c=this.safeString(r,i);void 0!==a&&(d=this.safeCurrency(a)),void 0!==c&&(h=this.safeCurrency(c));const l=this.extend(this.parseConversion(r,d,h),o);n.push(l)}const c=this.sortBy(n,"timestamp");let l;if(void 0!==t&&(l=this.safeCurrency(t),t=l.code),void 0===t)return this.filterBySinceLimit(c,r,a);const u=this.filterBy(c,"fromCurrency",t),p=this.filterBy(c,"toCurrency",t),f=this.arrayConcat(u,p);return this.filterBySinceLimit(f,r,a)}parseConversion(e,t=void 0,s=void 0){throw new o.NotSupported(this.id+" parseConversion () is not supported yet")}convertExpireDate(e){return"20"+e.slice(0,2)+"-"+e.slice(2,4)+"-"+e.slice(4,6)+"T00:00:00Z"}convertExpireDateToMarketIdDate(e){const t=e.slice(0,2),s=e.slice(2,4);let i;"01"===s?i="JAN":"02"===s?i="FEB":"03"===s?i="MAR":"04"===s?i="APR":"05"===s?i="MAY":"06"===s?i="JUN":"07"===s?i="JUL":"08"===s?i="AUG":"09"===s?i="SEP":"10"===s?i="OCT":"11"===s?i="NOV":"12"===s&&(i="DEC");return e.slice(4,6)+i+t}convertMarketIdExpireDate(e){6===e.length&&(e="0"+e);const t=e.slice(0,2),s=e.slice(2,5),i=this.safeString({JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},s);return e.slice(5,7)+i+t}async fetchPositionHistory(e,t=void 0,s=void 0,i={}){if(this.has.fetchPositionsHistory){return await this.fetchPositionsHistory([e],t,s,i)}throw new o.NotSupported(this.id+" fetchPositionHistory () is not supported yet")}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchPositionsHistory () is not supported yet")}parseMarginModification(e,t=void 0){throw new o.NotSupported(this.id+" parseMarginModification() is not supported yet")}parseMarginModifications(e,t=void 0,s=void 0,i=void 0){const r=[];for(let a=0;a<e.length;a++){const o=e[a],n=this.safeString(o,s),d=this.safeMarket(n,void 0,void 0,i);(void 0===t||this.inArray(d.symbol,t))&&r.push(this.parseMarginModification(o,d))}return r}async fetchTransfer(e,t=void 0,s={}){throw new o.NotSupported(this.id+" fetchTransfer () is not supported yet")}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){throw new o.NotSupported(this.id+" fetchTransfers () is not supported yet")}}},5147:(e,t,s)=>{s.d(t,{A:()=>n,Y:()=>o});const i=BigInt(0),r=BigInt(-1),a=BigInt(10);class o{constructor(e,t=void 0){if(this.base=void 0,void 0===t){let t=0;if((e=e.toLowerCase()).indexOf("e")>-1){let s="0";[e,s]=e.split("e"),t=parseInt(s)}const s=e.indexOf(".");this.decimals=s>-1?e.length-s-1:0;const i=e.replace(".","");this.integer=BigInt(i),this.decimals=this.decimals-t}else this.integer=e,this.decimals=t}mul(e){const t=this.integer*e.integer;return new o(t,this.decimals+e.decimals)}div(e,t=18){const s=t-this.decimals+e.decimals;let i;if(0===s)i=this.integer;else if(s<0){const e=a**BigInt(-s);i=this.integer/e}else{const e=a**BigInt(s);i=this.integer*e}const r=i/e.integer;return new o(r,t)}add(e){if(this.decimals===e.decimals){const t=this.integer+e.integer;return new o(t,this.decimals)}{const[t,s]=this.decimals>e.decimals?[e,this]:[this,e],i=s.decimals-t.decimals,r=t.integer*a**BigInt(i)+s.integer;return new o(r,s.decimals)}}mod(e){const t=Math.max(-this.decimals+e.decimals,0),s=this.integer*a**BigInt(t),i=Math.max(-e.decimals+this.decimals,0),r=e.integer*a**BigInt(i);return new o(s%r,i+e.decimals)}sub(e){const t=new o(-e.integer,e.decimals);return this.add(t)}abs(){return new o(this.integer<0?this.integer*r:this.integer,this.decimals)}neg(){return new o(-this.integer,this.decimals)}or(e){const t=this.integer|e.integer;return new o(t,this.decimals)}min(e){return this.lt(e)?this:e}max(e){return this.gt(e)?this:e}gt(e){return this.sub(e).integer>0}ge(e){return this.sub(e).integer>=0}lt(e){return e.gt(this)}le(e){return e.ge(this)}reduce(){const e=this.integer.toString(),t=e.length-1;if(0===t)return"0"===e&&(this.decimals=0),this;let s;for(s=t;s>=0&&"0"===e.charAt(s);s--);const i=t-s;if(0===i)return this;this.decimals-=i,this.integer=BigInt(e.slice(0,s+1))}equals(e){return this.reduce(),e.reduce(),this.decimals===e.decimals&&this.integer===e.integer}toString(){let e,t;this.reduce(),this.integer<0?(e="-",t=-this.integer):(e="",t=this.integer);const s=Array.from(t.toString(Number(a)).padStart(this.decimals,"0")),i=s.length-this.decimals;let r;return r=0===i?"0.":this.decimals<0?"0".repeat(-this.decimals):0===this.decimals?"":".",s.splice(i,0,r),e+s.join("")}static stringMul(e,t){if(void 0!==e&&void 0!==t)return new o(e).mul(new o(t)).toString()}static stringDiv(e,t,s=18){if(void 0===e||void 0===t)return;const r=new o(t);return r.integer!==i?new o(e).div(r,s).toString():void 0}static stringAdd(e,t){if(void 0!==e||void 0!==t)return void 0===e?t:void 0===t?e:new o(e).add(new o(t)).toString()}static stringSub(e,t){if(void 0!==e&&void 0!==t)return new o(e).sub(new o(t)).toString()}static stringAbs(e){if(void 0!==e)return new o(e).abs().toString()}static stringNeg(e){if(void 0!==e)return new o(e).neg().toString()}static stringMod(e,t){if(void 0!==e&&void 0!==t)return new o(e).mod(new o(t)).toString()}static stringOr(e,t){if(void 0!==e&&void 0!==t)return new o(e).or(new o(t)).toString()}static stringEquals(e,t){if(void 0!==e&&void 0!==t)return new o(e).equals(new o(t))}static stringEq(e,t){if(void 0!==e&&void 0!==t)return new o(e).equals(new o(t))}static stringMin(e,t){if(void 0!==e&&void 0!==t)return new o(e).min(new o(t)).toString()}static stringMax(e,t){if(void 0!==e&&void 0!==t)return new o(e).max(new o(t)).toString()}static stringGt(e,t){if(void 0!==e&&void 0!==t)return new o(e).gt(new o(t))}static stringGe(e,t){if(void 0!==e&&void 0!==t)return new o(e).ge(new o(t))}static stringLt(e,t){if(void 0!==e&&void 0!==t)return new o(e).lt(new o(t))}static stringLe(e,t){if(void 0!==e&&void 0!==t)return new o(e).le(new o(t))}}const n=o},2079:(e,t,s)=>{s.r(t),s.d(t,{AccountNotEnabled:()=>n,AccountSuspended:()=>d,AddressPending:()=>w,ArgumentsRequired:()=>h,AuthenticationError:()=>a,BadRequest:()=>c,BadResponse:()=>q,BadSymbol:()=>l,BaseError:()=>i,CancelPending:()=>G,ChecksumError:()=>V,ContractUnavailable:()=>I,DDoSProtection:()=>_,DuplicateOrderId:()=>P,ExchangeClosedByUser:()=>M,ExchangeError:()=>r,ExchangeNotAvailable:()=>N,InsufficientFunds:()=>v,InvalidAddress:()=>y,InvalidNonce:()=>L,InvalidOrder:()=>b,InvalidProxySettings:()=>A,ManualInteractionNeeded:()=>g,MarginModeAlreadySet:()=>f,MarketClosed:()=>m,NetworkError:()=>E,NoChange:()=>p,NotSupported:()=>x,NullResponse:()=>F,OnMaintenance:()=>R,OperationFailed:()=>C,OperationRejected:()=>u,OrderImmediatelyFillable:()=>O,OrderNotCached:()=>k,OrderNotFillable:()=>T,OrderNotFound:()=>S,PermissionDenied:()=>o,RateLimitExceeded:()=>B,RequestTimeout:()=>D,UnsubscribeError:()=>H,default:()=>U});class i extends Error{constructor(e){super(e),this.name="BaseError"}}class r extends i{constructor(e){super(e),this.name="ExchangeError"}}class a extends r{constructor(e){super(e),this.name="AuthenticationError"}}class o extends a{constructor(e){super(e),this.name="PermissionDenied"}}class n extends o{constructor(e){super(e),this.name="AccountNotEnabled"}}class d extends a{constructor(e){super(e),this.name="AccountSuspended"}}class h extends r{constructor(e){super(e),this.name="ArgumentsRequired"}}class c extends r{constructor(e){super(e),this.name="BadRequest"}}class l extends c{constructor(e){super(e),this.name="BadSymbol"}}class u extends r{constructor(e){super(e),this.name="OperationRejected"}}class p extends u{constructor(e){super(e),this.name="NoChange"}}class f extends p{constructor(e){super(e),this.name="MarginModeAlreadySet"}}class m extends u{constructor(e){super(e),this.name="MarketClosed"}}class g extends u{constructor(e){super(e),this.name="ManualInteractionNeeded"}}class v extends r{constructor(e){super(e),this.name="InsufficientFunds"}}class y extends r{constructor(e){super(e),this.name="InvalidAddress"}}class w extends y{constructor(e){super(e),this.name="AddressPending"}}class b extends r{constructor(e){super(e),this.name="InvalidOrder"}}class S extends b{constructor(e){super(e),this.name="OrderNotFound"}}class k extends b{constructor(e){super(e),this.name="OrderNotCached"}}class O extends b{constructor(e){super(e),this.name="OrderImmediatelyFillable"}}class T extends b{constructor(e){super(e),this.name="OrderNotFillable"}}class P extends b{constructor(e){super(e),this.name="DuplicateOrderId"}}class I extends b{constructor(e){super(e),this.name="ContractUnavailable"}}class x extends r{constructor(e){super(e),this.name="NotSupported"}}class A extends r{constructor(e){super(e),this.name="InvalidProxySettings"}}class M extends r{constructor(e){super(e),this.name="ExchangeClosedByUser"}}class C extends i{constructor(e){super(e),this.name="OperationFailed"}}class E extends C{constructor(e){super(e),this.name="NetworkError"}}class _ extends E{constructor(e){super(e),this.name="DDoSProtection"}}class B extends E{constructor(e){super(e),this.name="RateLimitExceeded"}}class N extends E{constructor(e){super(e),this.name="ExchangeNotAvailable"}}class R extends N{constructor(e){super(e),this.name="OnMaintenance"}}class L extends E{constructor(e){super(e),this.name="InvalidNonce"}}class V extends L{constructor(e){super(e),this.name="ChecksumError"}}class D extends E{constructor(e){super(e),this.name="RequestTimeout"}}class q extends C{constructor(e){super(e),this.name="BadResponse"}}class F extends q{constructor(e){super(e),this.name="NullResponse"}}class G extends C{constructor(e){super(e),this.name="CancelPending"}}class H extends i{constructor(e){super(e),this.name="UnsubscribeError"}}const U={BaseError:i,ExchangeError:r,AuthenticationError:a,PermissionDenied:o,AccountNotEnabled:n,AccountSuspended:d,ArgumentsRequired:h,BadRequest:c,BadSymbol:l,OperationRejected:u,NoChange:p,MarginModeAlreadySet:f,MarketClosed:m,ManualInteractionNeeded:g,InsufficientFunds:v,InvalidAddress:y,AddressPending:w,InvalidOrder:b,OrderNotFound:S,OrderNotCached:k,OrderImmediatelyFillable:O,OrderNotFillable:T,DuplicateOrderId:P,ContractUnavailable:I,NotSupported:x,InvalidProxySettings:A,ExchangeClosedByUser:M,OperationFailed:C,NetworkError:E,DDoSProtection:_,RateLimitExceeded:B,ExchangeNotAvailable:N,OnMaintenance:R,InvalidNonce:L,ChecksumError:V,RequestTimeout:D,BadResponse:q,NullResponse:F,CancelPending:G,UnsubscribeError:H}},5095:(e,t,s)=>{s.r(t),s.d(t,{DECIMAL_PLACES:()=>n.fv,NO_PADDING:()=>n.w1,PAD_WITH_ZERO:()=>n.ex,ROUND:()=>n.D_,ROUND_DOWN:()=>n._g,ROUND_UP:()=>n.Tz,SIGNIFICANT_DIGITS:()=>n.v,TICK_SIZE:()=>n.kb,TRUNCATE:()=>n.R3,Throttler:()=>l.x,TimedOut:()=>c.GA,aggregate:()=>u.QD,arrayConcat:()=>r.ax,asFloat:()=>o.Pf,asInteger:()=>o.JU,axolotl:()=>h.Sw,base16ToBinary:()=>d.FF,base58ToBinary:()=>d.Ry,base64ToBinary:()=>d.cg,base64ToString:()=>d.QM,binaryConcat:()=>d.qo,binaryConcatArray:()=>d.Vw,binaryToBase16:()=>d.t7,binaryToBase58:()=>d.bj,binaryToBase64:()=>d.sQ,binaryToString:()=>d.kn,capitalize:()=>a.ZH,clone:()=>r.o8,crc32:()=>h.QR,decimalToPrecision:()=>n.fq,decode:()=>d.D4,deepExtend:()=>r.zw,ecdsa:()=>h.h1,eddsa:()=>h.q4,encode:()=>d.lF,extend:()=>r.X$,extractParams:()=>u.um,filterBy:()=>r.WP,flatten:()=>r.Bq,groupBy:()=>r.$z,hasProps:()=>o.dl,hash:()=>h.tW,hmac:()=>h.w8,implodeParams:()=>u.Hp,inArray:()=>r.RV,index:()=>r.Pe,indexBy:()=>r.wQ,isArray:()=>o.cy,isBrowser:()=>i.Bd,isDeno:()=>i.N6,isDictionary:()=>o.Hf,isElectron:()=>i.b8,isEmpty:()=>r.Im,isInteger:()=>o.Fq,isJsonEncodedObject:()=>d.mC,isNode:()=>i.Ll,isNumber:()=>o.Et,isObject:()=>o.Gv,isString:()=>o.Kg,isStringCoercible:()=>o.KL,isWebWorker:()=>i.p7,isWindows:()=>i.uF,iso8601:()=>c.LC,json:()=>d.Pq,keys:()=>r.HP,keysort:()=>r.CA,mdy:()=>c.rE,merge:()=>r.h1,microseconds:()=>c.EZ,milliseconds:()=>c.Rz,now:()=>c.tB,numberToBE:()=>d.qE,numberToLE:()=>d.aN,numberToString:()=>n.um,omit:()=>r.cJ,omitZero:()=>n.Ye,ordered:()=>r.Sj,packb:()=>d.Am,parse8601:()=>c.Dj,parseDate:()=>c._U,parseTimeframe:()=>u.ce,pluck:()=>r.Ey,precisionConstants:()=>n.S2,precisionFromString:()=>n.Iu,prop:()=>o._w,rawencode:()=>d.rO,rfc2616:()=>c.D9,roundTimeframe:()=>u.jG,safeFloat:()=>o.w,safeFloat2:()=>o.Cw,safeFloatN:()=>o.Q7,safeInteger:()=>o.Y2,safeInteger2:()=>o.mU,safeIntegerN:()=>o.At,safeIntegerProduct:()=>o.lu,safeIntegerProduct2:()=>o.J0,safeIntegerProductN:()=>o.hO,safeString:()=>o.nr,safeString2:()=>o.d0,safeStringLower:()=>o.gw,safeStringLower2:()=>o.uS,safeStringLowerN:()=>o.I9,safeStringN:()=>o.Rc,safeStringUpper:()=>o.RH,safeStringUpper2:()=>o.F7,safeStringUpperN:()=>o.fu,safeTimestamp:()=>o.q0,safeTimestamp2:()=>o.ww,safeTimestampN:()=>o.Y_,safeValue:()=>o.pI,safeValue2:()=>o.Dj,safeValueN:()=>o.DR,seconds:()=>c.YA,setTimeout_safe:()=>c.k4,sleep:()=>c.yy,sortBy:()=>r.Ul,sortBy2:()=>r.sy,stringToBase64:()=>d.q3,stringToBinary:()=>d.wN,strip:()=>a.bB,sum:()=>r.cz,timeout:()=>c.wR,toArray:()=>r.$r,truncate:()=>n.xv,truncate_to_string:()=>n.NZ,unCamelCase:()=>a.Qd,unique:()=>r.Am,urlencode:()=>d.mu,urlencodeBase64:()=>d.LI,urlencodeNested:()=>d.Dy,urlencodeWithArrayRepeat:()=>d.ev,uuid:()=>a.uR,uuid16:()=>a.tg,uuid22:()=>a._n,uuidv1:()=>c.nm,values:()=>r.zu,vwap:()=>u.ru,ymd:()=>c.Th,ymdhms:()=>c.RR,yymmdd:()=>c.x_,yyyymmdd:()=>c.Rn});var i=s(7597),r=s(7437),a=s(3503),o=s(6834),n=s(1579),d=s(9560),h=s(8283),c=s(8403),l=s(7618),u=s(6238)},8283:(e,t,s)=>{s.d(t,{QR:()=>v,Sw:()=>m,h1:()=>f,q4:()=>g,tW:()=>u,w8:()=>p});var i=s(712),r=s(4710),a=s(5268),o=s(890),n=s(987),d=s(8342),h=s(191);const c={binary:e=>e,hex:r.xn.encode,base64:r.K3.encode},l={"1.3.132.0.10":n.bI,"1.2.840.10045.3.1.7":d.Qj},u=(e,t,s="hex")=>{const i=t(e);return c[s](i)},p=(e,t,s,r="hex")=>{const a=(0,i.w)(s,t,e);return c[r](a)};function f(e,t,s,i=null,r=!1){if(i&&(e=u(e,i,"hex")),"string"==typeof t&&t.length>64){if(!t.startsWith("-----BEGIN EC PRIVATE KEY-----"))throw new Error("Unsupported key format");{const e=a.o.unarmor(t);let i=o.Ge.decode(e);if(4!==i.sub.length)throw new Error("Unsupported key format");if(null!==typeof i.sub[2].sub&&i.sub[2].sub.length>0){const e=i.sub[2].sub[0].content(void 0);if(void 0===l[e])throw new Error("Unsupported curve");s=l[e]}t=i.sub[1].getHexStringValue()}}let n=s.sign(e,t,{lowS:!0});const d=(BigInt(1)<<BigInt(8)*BigInt(31))-BigInt(1),c=s.CURVE.n/BigInt(2);let p=0;for(;r&&(n.r>c||n.r<=d||n.s<=d);)n=s.sign(e,t,{lowS:!0,extraEntropy:(0,h.z)(BigInt(p),32)}),p+=1;return{r:n.r.toString(16),s:n.s.toString(16),v:n.recovery}}function m(e,t,s){const i=s.signModified(e,t);return r.tw.encode(i)}function g(e,t,s){let i;32===t.length?i=t:"string"==typeof t&&(i=new Uint8Array(a.o.unarmor(t).slice(16)));const o=s.sign(e,i);return r.K3.encode(o)}function v(e,t=!1){void 0===v.table&&(v.table="00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".split(" ").map((e=>parseInt(e,16))));let s=-1;for(let t=0;t<e.length;t++)s=s>>>8^v.table[255&(s^e.charCodeAt(t))];const i=(-1^s)>>>0;return t&&i>=2147483648?i-4294967296:i}},9560:(e,t,s)=>{s.d(t,{Am:()=>E,D4:()=>x,Dy:()=>O,FF:()=>g,LI:()=>A,Pq:()=>d,QM:()=>p,Ry:()=>y,Vw:()=>S,aN:()=>M,bj:()=>w,cg:()=>f,ev:()=>T,kn:()=>c,lF:()=>I,mC:()=>h,mu:()=>k,q3:()=>u,qE:()=>C,qo:()=>b,rO:()=>P,sQ:()=>m,t7:()=>v,wN:()=>l});var i=s(4710),r=s(191),a=s(917),o=s(4580),n=s.n(o);const d=(e,t=void 0)=>JSON.stringify(e),h=e=>"string"==typeof e&&e.length>=2&&("{"===e[0]||"["===e[0]),c=i.As.encode,l=i.As.decode,u=e=>i.K3.encode(i.As.decode(e)),p=e=>i.As.encode(i.K3.decode(e)),f=i.K3.decode,m=i.K3.encode,g=i.xn.decode,v=i.xn.encode,y=i.tw.decode,w=i.tw.encode,b=r.Id,S=e=>(0,r.Id)(...e),k=e=>n().stringify(e),O=e=>n().stringify(e),T=e=>n().stringify(e,{arrayFormat:"repeat"}),P=e=>n().stringify(e,{encode:!1}),I=i.As.decode,x=i.As.encode,A=e=>("string"==typeof e?u(e):m(e)).replace(/[=]+$/,"").replace(/\+/g,"-").replace(/\//g,"_"),M=(e,t)=>(0,r.z)(BigInt(e),t),C=(e,t)=>(0,r.lq)(BigInt(e),t);function E(e){return(0,a.l)(e)}},7437:(e,t,s)=>{s.d(t,{$r:()=>p,$z:()=>g,Am:()=>c,Bq:()=>S,CA:()=>m,Ey:()=>k,HP:()=>r,Im:()=>f,Pe:()=>o,RV:()=>u,Sj:()=>h,Ul:()=>w,WP:()=>y,X$:()=>n,ax:()=>l,cJ:()=>O,cz:()=>T,h1:()=>I,o8:()=>d,sy:()=>b,wQ:()=>v,zu:()=>a,zw:()=>P});var i=s(6834);const r=Object.keys,a=e=>(0,i.cy)(e)?e:Object.values(e),o=e=>new Set(a(e)),n=(...e)=>Object.assign({},...e),d=e=>(0,i.cy)(e)?Array.from(e):n(e),h=e=>e,c=e=>Array.from(o(e)),l=(e,t)=>e.concat(t),u=(e,t)=>t.includes(e),p=e=>Object.values(e),f=e=>!e||(Array.isArray(e)?e:Object.keys(e)).length<1,m=(e,t={})=>{for(const s of r(e).sort())t[s]=e[s];return t},g=(e,t,s={})=>{for(const i of a(e))if(t in i){const e=i[t];s[e]=s[e]||[],s[e].push(i)}return s},v=(e,t,s={})=>{for(const i of a(e))t in i&&(s[i[t]]=i);return s},y=(e,t,s=void 0,i=[])=>{for(const r of a(e))r[t]===s&&i.push(r);return i},w=(e,t,s=!1,i=0,r=(s?-1:1))=>e.sort(((e,s)=>{const a=t in e?e[t]:i,o=t in s?s[t]:i;return a<o?-r:a>o?r:0})),b=(e,t,s,i=!1,r=(i?-1:1))=>e.sort(((e,i)=>e[t]<i[t]?-r:e[t]>i[t]?r:e[s]<i[s]?-r:e[s]>i[s]?r:0)),S=function e(t,s=[]){for(const r of t)(0,i.cy)(r)?e(r,s):s.push(r);return s},k=(e,t)=>a(e).filter((e=>t in e)).map((e=>e[t])),O=(e,...t)=>{if(!Array.isArray(e)){const s=d(e);for(const e of t)if((0,i.cy)(e))for(const t of e)delete s[t];else delete s[e];return s}return e},T=(...e)=>{const t=e.filter(i.Et);return t.length>0?t.reduce(((e,t)=>e+t),0):void 0},P=function e(...t){let s;for(const r of t)if((0,i.Hf)(r)){(0,i.Hf)(s)||(s={});for(const t in r)s[t]=e(s[t],r[t])}else s=r;return s},I=(e,...t)=>{const s={},i=Object.assign({},...t),r=Object.keys(i);for(let t=0;t<r.length;t++){const a=r[t];void 0===e[a]&&(s[a]=i[a])}return Object.assign({},e,s)}},6238:(e,t,s)=>{s.d(t,{Hp:()=>h,QD:()=>l,ce:()=>o,jG:()=>n,ru:()=>c,um:()=>d});var i=s(1579),r=s(6834),a=s(2079);const o=e=>{const t=(0,r.Pf)(e.slice(0,-1)),s=e.slice(-1);let i;if("y"===s)i=31536e3;else if("M"===s)i=2592e3;else if("w"===s)i=604800;else if("d"===s)i=86400;else if("h"===s)i=3600;else if("m"===s)i=60;else{if("s"!==s)throw new a.NotSupported("timeframe unit "+s+" is not supported");i=1}return t*i},n=(e,t,s=i._g)=>{const r=1e3*o(e);return t-t%r+(s===i.Tz?r:0)},d=e=>{const t=/{([\w-]+)}/g,s=[];let i=t.exec(e);for(;i;)s.push(i[1]),i=t.exec(e);return s},h=(e,t)=>{if(!Array.isArray(t)){const s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i];Array.isArray(t[r])||(e=e.replace("{"+r+"}",t[r]))}}return e};function c(e,t){return void 0!==e&&void 0!==t&&e>0?t/e:void 0}function l(e){const t={};for(let s=0;s<e.length;s++){const[i,r]=e[s];r>0&&(t[i]=(t[i]||0)+r)}return Object.keys(t).map((e=>[parseFloat(e),parseFloat(t[e])]))}},1579:(e,t,s)=>{s.d(t,{D_:()=>r,Iu:()=>v,NZ:()=>m,R3:()=>i,S2:()=>u,Tz:()=>a,Ye:()=>b,_g:()=>o,ex:()=>l,fq:()=>y,fv:()=>n,kb:()=>h,um:()=>p,v:()=>d,w1:()=>c,xv:()=>g});const i=0,r=1,a=2,o=3,n=2,d=3,h=4,c=5,l=6,u={ROUND:r,TRUNCATE:i,ROUND_UP:a,ROUND_DOWN:o,DECIMAL_PLACES:n,SIGNIFICANT_DIGITS:d,TICK_SIZE:h,NO_PADDING:c,PAD_WITH_ZERO:l};function p(e){if(void 0===e)return;if("number"!=typeof e)return e.toString();const t=e.toString();if(Math.abs(e)<1){const s=t.split("e-"),i=s[0].replace(".",""),r=parseInt(s[1]),a="-"===t[0];if(r)return e=(a?"-":"")+"0."+new Array(r).join("0")+i.substring(a)}else{const e=t.split("e");if(e[1]){let t=parseInt(e[1]);const s=e[0].split(".");let i="";return s[1]&&(t-=s[1].length,i=s[1]),s[0]+i+new Array(t+1).join("0")}}return t}const f=[],m=(e,t=0)=>{if(e=p(e),t>0){const s=f[t]||(f[t]=new RegExp("([-]*\\d+\\.\\d{"+t+"})(\\d)")),[,i]=e.toString().match(s)||[null,e];return i.toString()}return parseInt(e).toString()},g=(e,t=0)=>parseFloat(m(e,t));function v(e){if(e.indexOf("e")>-1||e.indexOf("E")>-1){const t=e.replace(/\d\.?\d*[eE]/,"");return-1*parseInt(t)}const t=e.replace(/0+$/g,"").split(".");return t.length>1?t[1].length:0}const y=(e,t,s,i=n,r=c)=>w(e,t,s,i,r),w=(e,t,s,a=n,o=c)=>{if(a===h&&("string"==typeof s&&(s=parseFloat(s)),s<=0))throw new Error("TICK_SIZE cant be used with negative or zero numPrecisionDigits");if(s<0){const n=Math.pow(10,-s);if(t===r)return(n*w(e/n,t,0,a,o)).toString();if(t===i)return(e-e%n).toString()}if(a===h){const a=v(w(s,r,22,n,c));let d=e%s;d=Number(w(d,r,8,n,c));return 0!==v(w(d/s,r,Math.max(a,8),n,c))&&(t===r?e>0?d>=s/2?e=e-d+s:e-=d:e=d>=s/2?Number(e)-d:Number(e)-d-s:t===i&&(e-=d)),w(e,r,a,n,o)}const l=p(e),u="-"===l[0],f=u?1:0,m=l.length;for(var g=0;g<m&&"."!==l[g];g++);const y=g<l.length,b=48,S=new Uint8Array(m-f+(y?0:1));S[0]=b;let k=S.length,O=-1,T=-1;for(var P=1,I=f;I<m;I++,P++){const e=l.charCodeAt(I);if(46===e)k=P--;else{if(e<b||e>57)throw new Error(`${l}: invalid number (contains an illegal character '${l[P-1]}')`);S[P]=e,e!==b&&O<0&&(O=P)}}O<0&&(O=1);let x=a===n?k:O,A=x+s;T=-1;let M=!0,C=u;for(let e=S.length-1,i=0;e>=0;e--){let a=S[e];if(0!==e){if(a+=i,e>=x+s){a=t===r&&a>=53&&!(53===a&&i)?58:b}a>57?(a=b,i=1):i=0}else i&&(a=49);S[e]=a,a!==b&&(M=!1,O=e,T=T<0?e+1:T)}a===d&&(x=O,A=x+s),M&&(C=!1);const E=O>=k||M?k-1:O,_=T<k?k:T,B=C?1:0,N=B+(k-E),R=Math.max(_-k,0),L=_-E,V=o===c?L:A-E,D=Math.max(V-L,0),q=N+1+R,F=q+D,G=R+D===0,H=new Uint8Array(N+(G?0:1)+R+D);for(C&&(H[0]=45),P=B,I=E;P<N;P++,I++)H[P]=S[I];for(G||(H[N]=46),P=N+1,I=k;P<q;P++,I++)H[P]=S[I];for(P=q;P<F;P++)H[P]=b;return String.fromCharCode(...H)};function b(e){try{if(void 0===e||""===e)return;if(0===parseFloat(e))return;return e}catch(t){return e}}},7597:(e,t,s)=>{s.d(t,{Bd:()=>i,Ll:()=>d,N6:()=>n,b8:()=>r,p7:()=>a,uF:()=>o});const i="undefined"!=typeof window,r="undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.electron,a="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,o="undefined"!=typeof process&&"win32"===process.platform,n="undefined"!=typeof Deno,d=!(i||a||n)},5354:(e,t,s)=>{s.d(t,{a:()=>h,n:()=>d});var i=s(5944),r=s(4710),a=s(9560),o=s(8283),n=s(8342);function d(e,t,s){const a=new i.v;a.setPrivateKey(t);const o=s.create().constructor.name.toLowerCase();return a.sign(e,(e=>r.xn.encode(s(e))),o)}function h(e,t,s,i=!1,h={}){let c=(i?"RS":"HS")+8*s.outputLen;h.alg&&(c=h.alg.toUpperCase());const l=Object.assign({alg:c,typ:"JWT"},h);void 0!==l.iat&&(e.iat=l.iat,delete l.iat);const u=[(0,a.LI)(JSON.stringify(l)),(0,a.LI)(JSON.stringify(e))].join("."),p=c.slice(0,2);let f;if("HS"===p)f=(0,a.LI)((0,o.w8)(u,t,s,"binary"));else if(i||"RS"===p)f=(0,a.LI)((0,a.cg)(d(u,r.As.encode(t),s)));else if("ES"===p){const e=(0,o.h1)(u,r.As.encode(t),n.Qj,s),i=e.r.padStart(64,"0"),d=e.s.padStart(64,"0");f=(0,a.LI)((0,a.FF)(i+d))}return[u,f].join(".")}},3503:(e,t,s)=>{s.d(t,{Qd:()=>i,ZH:()=>r,_n:()=>d,bB:()=>a,tg:()=>n,uR:()=>o});const i=e=>{const t={fetchOHLCVWs:"fetch_ohlcv_ws"};return t[e]?t[e]:e.match(/[A-Z]/)?e.replace(/[a-z0-9][A-Z]/g,(e=>e[0]+"_"+e[1])).replace(/[A-Z0-9][A-Z0-9][a-z][^$]/g,(e=>e[0]+"_"+e[1]+e[2]+e[3])).replace(/[a-z][0-9]$/g,(e=>e[0]+"_"+e[1])).toLowerCase():e},r=e=>e.length?e.charAt(0).toUpperCase()+e.slice(1):e,a=e=>e.replace(/^\s+|\s+$/g,""),o=e=>e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,o),n=e=>e?(e^16*Math.random()>>e/4).toString(16):([1e5]+100+400+8e3).replace(/[018]/g,n),d=e=>e?(e^16*Math.random()>>e/4).toString(16):([1e7]+1e3+4e3+8e5).replace(/[018]/g,d)},7618:(e,t,s)=>{s.d(t,{x:()=>r});var i=s(8403);class r{constructor(e){this.config={refillRate:1,delay:.001,capacity:1,maxCapacity:2e3,tokens:0,cost:1},Object.assign(this.config,e),this.queue=[],this.running=!1}async loop(){let e=(0,i.tB)();for(;this.running;){const{resolver:t,cost:s}=this.queue[0];if(this.config.tokens>=0)this.config.tokens-=s,t(),this.queue.shift(),await Promise.resolve(),0===this.queue.length&&(this.running=!1);else{await(0,i.yy)(1e3*this.config.delay);const t=(0,i.tB)(),s=t-e;e=t;const r=this.config.tokens+this.config.refillRate*s;this.config.tokens=Math.min(r,this.config.capacity)}}}throttle(e=void 0){let t;const s=new Promise(((e,s)=>{t=e}));if(this.queue.length>this.config.maxCapacity)throw new Error("throttle queue is over maxCapacity ("+this.config.maxCapacity.toString()+"), see https://github.com/ccxt/ccxt/issues/11645#issuecomment-1195695526");return e=void 0===e?this.config.cost:e,this.queue.push({resolver:t,cost:e}),this.running||(this.running=!0,this.loop()),s}}},8403:(e,t,s)=>{s.d(t,{D9:()=>f,Dj:()=>u,EZ:()=>r,GA:()=>c,LC:()=>l,RR:()=>w,Rn:()=>y,Rz:()=>a,Th:()=>g,YA:()=>o,_U:()=>p,k4:()=>h,nm:()=>n,rE:()=>m,tB:()=>i,wR:()=>S,x_:()=>v,yy:()=>b});const i=Date.now,r=()=>1e3*i(),a=i,o=()=>Math.floor(i()/1e3),n=()=>{const e=(10*r()+122192928e9).toString(16);return e.slice(7,15)+e.slice(3,7)+"1"+e.slice(0,3)+"9696"+"ff".repeat(6)},d=setTimeout,h=(e,t,s=d,r=i()+t)=>{if(t>=2147483647)throw new Error("setTimeout() function was called with unrealistic value of "+t.toString());let a=()=>{},o=!0;const n=s((()=>{o=!0;const t=r-i();t>0?a=h(e,t,s,r):e()}),t);return function(){o&&(o=!1,clearTimeout(n)),a()}};class c extends Error{constructor(){const e="timed out";super(e),this.constructor=c,this.__proto__=c.prototype,this.message=e}}const l=e=>{let t;if(t="number"==typeof e?Math.floor(e):parseInt(e,10),!(Number.isNaN(t)||t<0))try{return new Date(t).toISOString()}catch(e){return}},u=e=>{if("string"==typeof e&&e&&!e.match(/^[0-9]+$/)&&!(e.indexOf("-")<0||e.indexOf(":")<0))try{const t=Date.parse(e.indexOf("+")>=0||"Z"===e.slice(-1)?e:(e+"Z").replace(/\s(\d\d):/,"T$1:"));if(Number.isNaN(t))return;return t}catch(e){return}},p=e=>{if("string"==typeof e&&e){if(e.indexOf("GMT")>=0)try{return Date.parse(e)}catch(e){return}return u(e)}},f=(e=void 0)=>new Date(e).toUTCString(),m=(e,t="-")=>{t=t||"";const s=new Date(e),i=s.getUTCFullYear().toString();let r=s.getUTCMonth()+1,a=s.getUTCDate();return r=r<10?"0"+r:r.toString(),a=a<10?"0"+a:a.toString(),r+t+a+t+i},g=(e,t,s=!0)=>{t=t||"";const i=new Date(e),r=i.getUTCFullYear(),a=(s?r:r-2e3).toString();let o=i.getUTCMonth()+1,n=i.getUTCDate();return o=o<10?"0"+o:o.toString(),n=n<10?"0"+n:n.toString(),a+t+o+t+n},v=(e,t="")=>g(e,t,!1),y=(e,t="-")=>g(e,t,!0),w=(e,t=" ")=>{const s=new Date(e),i=s.getUTCFullYear();let r=s.getUTCMonth()+1,a=s.getUTCDate(),o=s.getUTCHours(),n=s.getUTCMinutes(),d=s.getUTCSeconds();return r=r<10?"0"+r:r,a=a<10?"0"+a:a,o=o<10?"0"+o:o,n=n<10?"0"+n:n,d=d<10?"0"+d:d,i+"-"+r+"-"+a+t+o+":"+n+":"+d},b=e=>new Promise((t=>h(t,e))),S=async(e,t)=>{let s=()=>{};const i=new Promise((t=>s=h(t,e)));try{return await Promise.race([t,i.then((()=>{throw new c}))])}finally{s()}}},8995:(e,t,s)=>{s.d(t,{A:()=>n,O:()=>o});var i=s(4710),r=s(3466),a=s(8283);function o(e){const t=e=>parseInt(e,16);e=e.replace(" ","");const s=Math.round((new Date).getTime()/1e3),o=((e,t)=>(t+e).slice(-t.length))(((n=Math.floor(s/30))<15.5?"0":"")+Math.round(n).toString(16),"0000000000000000");var n;const d=(0,a.w8)(i.xn.decode(o),i.RG.decode(e),r.e,"hex"),h=t(d.substring(d.length-1));let c=(t(d.substr(2*h,8))&t("7fffffff"))+"";return c.substring(c.length-6,c.length)}const n=o},6834:(e,t,s)=>{s.d(t,{At:()=>B,Cw:()=>T,DR:()=>L,Dj:()=>A,Et:()=>i,F7:()=>E,Fq:()=>r,Gv:()=>d,Hf:()=>h,I9:()=>D,J0:()=>I,JU:()=>m,KL:()=>c,Kg:()=>n,Pf:()=>f,Q7:()=>_,RH:()=>O,Rc:()=>V,Y2:()=>v,Y_:()=>R,_w:()=>l,cy:()=>a,d0:()=>M,dl:()=>o,fu:()=>q,gw:()=>k,hO:()=>N,lu:()=>y,mU:()=>P,nr:()=>S,pI:()=>b,q0:()=>w,uS:()=>C,w:()=>g,ww:()=>x});const i=Number.isFinite,r=Number.isInteger,a=Array.isArray,o=e=>null!=e,n=e=>"string"==typeof e,d=e=>null!==e&&"object"==typeof e,h=e=>d(e)&&Object.getPrototypeOf(e)===Object.prototype&&!a(e)&&!(e=>e instanceof RegExp)(e),c=e=>o(e)&&e.toString||i(e),l=(e,t)=>d(e)&&""!==e[t]&&null!==e[t]?e[t]:void 0,u=(e,t,s)=>d(e)?void 0!==e[t]&&""!==e[t]&&null!==e[t]?e[t]:""!==e[s]&&null!==e[s]?e[s]:void 0:void 0,p=(e,t)=>d(e)?e[t.find((t=>void 0!==l(e,t)))]:void 0,f=e=>i(e)||n(e)&&0!==e.length?parseFloat(e):NaN,m=e=>i(e)||n(e)&&0!==e.length?Math.trunc(Number(e)):NaN,g=(e,t,s)=>{const r=f(l(e,t));return i(r)?r:s},v=(e,t,s)=>{const r=m(l(e,t));return i(r)?r:s},y=(e,t,s,r)=>{const a=f(l(e,t));return i(a)?parseInt(a*s):r},w=(e,t,s)=>{const r=f(l(e,t));return i(r)?parseInt(1e3*r):s},b=(e,t,s)=>{const i=l(e,t);return o(i)?i:s},S=(e,t,s)=>{const i=l(e,t);return c(i)?String(i):s},k=(e,t,s)=>{const i=l(e,t);return c(i)?String(i).toLowerCase():c(s)?String(s).toLowerCase():s},O=(e,t,s)=>{const i=l(e,t);return c(i)?String(i).toUpperCase():c(s)?String(s).toUpperCase():s},T=(e,t,s,r)=>{const a=f(u(e,t,s));return i(a)?a:r},P=(e,t,s,r)=>{const a=m(u(e,t,s));return i(a)?a:r},I=(e,t,s,r,a)=>{const o=f(u(e,t,s));return i(o)?parseInt(o*r):a},x=(e,t,s,r)=>{const a=f(u(e,t,s));return i(a)?parseInt(1e3*a):r},A=(e,t,s,i)=>{const r=u(e,t,s);return o(r)?r:i},M=(e,t,s,i)=>{const r=u(e,t,s);return c(r)?String(r):i},C=(e,t,s,i)=>{const r=u(e,t,s);return c(r)?String(r).toLowerCase():c(i)?String(i).toLowerCase():i},E=(e,t,s,i)=>{const r=u(e,t,s);return c(r)?String(r).toUpperCase():c(i)?String(i).toUpperCase():i},_=(e,t,s)=>{const r=f(p(e,t));return i(r)?r:s},B=(e,t,s)=>{if(void 0===e)return s;const r=m(p(e,t));return i(r)?r:s},N=(e,t,s,r)=>{const a=f(p(e,t));return i(a)?parseInt(a*s):r},R=(e,t,s)=>{const r=f(p(e,t));return i(r)?parseInt(1e3*r):s},L=(e,t,s)=>{if(void 0===e)return s;const i=p(e,t);return o(i)?i:s},V=(e,t,s)=>{if(void 0===e)return s;const i=p(e,t);return c(i)?String(i):s},D=(e,t,s)=>{const i=p(e,t);return c(i)?String(i).toLowerCase():c(s)?String(s).toLowerCase():s},q=(e,t,s)=>{const i=p(e,t);return c(i)?String(i).toUpperCase():c(s)?String(s).toUpperCase():s}},2931:(e,t,s)=>{s.d(t,{Hk:()=>n,I3:()=>r,Pt:()=>o,TG:()=>a});class i extends Array{constructor(e=void 0){super(),Object.defineProperty(this,"maxSize",{__proto__:null,value:e,writable:!0})}clear(){this.length=0}}class r extends i{constructor(e=void 0){super(e),this.hashmap={},Object.defineProperty(this,"nestedNewUpdatesBySymbol",{__proto__:null,value:!1,writable:!0}),Object.defineProperty(this,"newUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"clearUpdatesBySymbol",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"allNewUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearAllUpdates",{__proto__:null,value:!1,writable:!0}),Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0,enumerable:!1})}getLimit(e,t){let s;return void 0===e?(s=this.allNewUpdates,this.clearAllUpdates=!0):(s=this.newUpdatesBySymbol[e],void 0!==s&&this.nestedNewUpdatesBySymbol&&(s=s.size),this.clearUpdatesBySymbol[e]=!0),void 0===s?t:void 0!==t?Math.min(s,t):s}append(e){this.maxSize&&this.length===this.maxSize&&this.shift(),this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol]=0),this.newUpdatesBySymbol[e.symbol]=(this.newUpdatesBySymbol[e.symbol]||0)+1,this.allNewUpdates=(this.allNewUpdates||0)+1}}class a extends i{constructor(e=void 0){super(e),Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0}),Object.defineProperty(this,"sizeTracker",{__proto__:null,value:new Set,writable:!0}),Object.defineProperty(this,"newUpdates",{__proto__:null,value:0,writable:!0}),Object.defineProperty(this,"clearUpdates",{__proto__:null,value:!1,writable:!0})}getLimit(e,t){return this.clearUpdates=!0,void 0===t?this.newUpdates:Math.min(this.newUpdates,t)}append(e){if(e[0]in this.hashmap){const t=this.hashmap[e[0]];if(t!==e)for(const s in e)t[s]=e[s]}else{if(this.hashmap[e[0]]=e,this.maxSize&&this.length===this.maxSize){const e=this.shift();delete this.hashmap[e[0]]}this.push(e)}this.clearUpdates&&(this.clearUpdates=!1,this.sizeTracker.clear()),this.sizeTracker.add(e[0]),this.newUpdates=this.sizeTracker.size}}class o extends r{constructor(e=void 0){super(e),this.nestedNewUpdatesBySymbol=!0}append(e){const t=this.hashmap[e.symbol]=this.hashmap[e.symbol]||{};if(e.id in t){const s=t[e.id];if(s!==e)for(const t in e)s[t]=e[t];e=s;const i=this.findIndex((t=>t.id===e.id));this.splice(i,1)}else t[e.id]=e;if(this.maxSize&&this.length===this.maxSize){const e=this.shift();delete this.hashmap[e.symbol][e.id]}this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),void 0===this.newUpdatesBySymbol[e.symbol]&&(this.newUpdatesBySymbol[e.symbol]=new Set),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol].clear());const s=this.newUpdatesBySymbol[e.symbol],i=s.size;s.add(e.id);const r=s.size;this.allNewUpdates=(this.allNewUpdates||0)+(r-i)}}class n extends r{constructor(){super(),this.nestedNewUpdatesBySymbol=!0,Object.defineProperty(this,"hashmap",{__proto__:null,value:{},writable:!0})}append(e){const t=this.hashmap[e.symbol]=this.hashmap[e.symbol]||{};if(e.side in t){const s=t[e.side];if(s!==e)for(const t in e)s[t]=e[t];e=s;const i=this.findIndex((t=>t.symbol===e.symbol&&t.side===e.side));this.splice(i,1)}else t[e.side]=e;this.push(e),this.clearAllUpdates&&(this.clearAllUpdates=!1,this.clearUpdatesBySymbol={},this.allNewUpdates=0,this.newUpdatesBySymbol={}),void 0===this.newUpdatesBySymbol[e.symbol]&&(this.newUpdatesBySymbol[e.symbol]=new Set),this.clearUpdatesBySymbol[e.symbol]&&(this.clearUpdatesBySymbol[e.symbol]=!1,this.newUpdatesBySymbol[e.symbol].clear());const s=this.newUpdatesBySymbol[e.symbol],i=s.size;s.add(e.side);const r=s.size;this.allNewUpdates=(this.allNewUpdates||0)+(r-i)}}},934:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(2079),r=s(4350),a=s(3206),o=s(7437),n=s(8403),d=s(7597),h=s(9560),c=s(4710);class l{constructor(e,t,s,i,r,n={}){this.useMessageQueue=!1,this.verbose=!1;const d={url:e,onMessageCallback:t,onErrorCallback:s,onCloseCallback:i,onConnectedCallback:r,verbose:!1,protocols:void 0,options:void 0,futures:{},subscriptions:{},rejections:{},messageQueue:{},useMessageQueue:!1,connected:void 0,error:void 0,connectionStarted:void 0,connectionEstablished:void 0,isConnected:!1,connectionTimer:void 0,connectionTimeout:1e4,pingInterval:void 0,ping:void 0,keepAlive:3e4,maxPingPongMisses:2,connection:void 0,startedConnecting:!1,gunzip:!1,inflate:!1};Object.assign(this,(0,o.zw)(d,n)),this.connected=(0,a.K)()}future(e){e in this.futures||(this.futures[e]=(0,a.K)());const t=this.futures[e];if(e in this.rejections)return t.reject(this.rejections[e]),delete this.rejections[e],delete this.messageQueue[e],t;if(this.useMessageQueue){const s=this.messageQueue[e];s&&s.length&&(t.resolve(s.shift()),delete this.futures[e])}return t}resolve(e,t){if(this.verbose&&void 0===t&&this.log(new Date,"resolve received undefined messageHash"),!0===this.useMessageQueue){t in this.messageQueue||(this.messageQueue[t]=[]);const s=this.messageQueue[t];for(s.push(e);s.length>10;)s.shift();if(void 0!==t&&t in this.futures){this.futures[t].resolve(s.shift()),delete this.futures[t]}}else if(t in this.futures){this.futures[t].resolve(e),delete this.futures[t]}return e}reject(e,t=void 0){if(t)if(t in this.futures){this.futures[t].reject(e),delete this.futures[t]}else this.rejections[t]=e;else{const t=Object.keys(this.futures);for(let s=0;s<t.length;s++)this.reject(e,t[s])}return e}log(...e){console.log(...e)}connect(e=0){throw new i.NotSupported("connect() not implemented yet")}isOpen(){throw new i.NotSupported("isOpen() not implemented yet")}reset(e){this.clearConnectionTimeout(),this.clearPingInterval(),this.messageQueue={},this.reject(e)}onConnectionTimeout(){if(!this.isOpen()){const e=new i.RequestTimeout("Connection to "+this.url+" failed due to a connection timeout");this.onError(e),this.connection.close(1006)}}setConnectionTimeout(){if(this.connectionTimeout){const e=this.onConnectionTimeout.bind(this);this.connectionTimer=setTimeout(e,this.connectionTimeout)}}clearConnectionTimeout(){this.connectionTimer&&(this.connectionTimer=clearTimeout(this.connectionTimer))}setPingInterval(){if(this.keepAlive){const e=this.onPingInterval.bind(this);this.pingInterval=setInterval(e,this.keepAlive)}}clearPingInterval(){this.pingInterval&&(this.pingInterval=clearInterval(this.pingInterval))}onPingInterval(){if(this.keepAlive&&this.isOpen()){const e=(0,n.Rz)();if(this.lastPong=this.lastPong||e,this.lastPong+this.keepAlive*this.maxPingPongMisses<e)this.onError(new i.RequestTimeout("Connection to "+this.url+" timed out due to a ping-pong keepalive missing on time"));else{let t;this.ping&&(t=this.ping(this)),t?this.send(t).catch((e=>{this.onError(e)})):d.Ll?this.connection.ping():this.lastPong=e}}}onOpen(){this.verbose&&this.log(new Date,"onOpen"),this.connectionEstablished=(0,n.Rz)(),this.isConnected=!0,this.connected.resolve(this.url),this.clearConnectionTimeout(),this.setPingInterval(),this.onConnectedCallback(this)}onPing(){this.verbose&&this.log(new Date,"onPing")}onPong(){this.lastPong=(0,n.Rz)(),this.verbose&&this.log(new Date,"onPong")}onError(e){this.verbose&&this.log(new Date,"onError",e.message),e instanceof i.BaseError||(e=new i.NetworkError(e.message)),this.error=e,this.reset(this.error),this.onErrorCallback(this,this.error)}onClose(e){this.verbose&&this.log(new Date,"onClose",e),this.error||this.reset(new i.NetworkError("connection closed by remote server, closing code "+String(e.code))),this.error instanceof i.ExchangeClosedByUser&&this.reset(this.error),void 0!==this.disconnected&&this.disconnected.resolve(!0),this.onCloseCallback(this,e)}onUpgrade(e){this.verbose&&this.log(new Date,"onUpgrade")}async send(e){this.verbose&&this.log(new Date,"sending",e),e="string"==typeof e?e:JSON.stringify(e);const t=(0,a.K)();if(d.Ll){function s(e){e?t.reject(e):t.resolve(null)}this.connection.send(e,{},s)}else this.connection.send(e),t.resolve(null);return t}close(){throw new i.NotSupported("close() not implemented yet")}onMessage(e){let t,s=e.data;"string"!=typeof s&&(this.gunzip||this.inflate?(t=new Uint8Array(s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)),this.gunzip?t=(0,r.Wt)(t):this.inflate&&(t=(0,r.HM)(t)),s=c.As.encode(t)):s=s.toString());try{(0,h.mC)(s)&&(s=JSON.parse(s.replace(/:(\d{15,}),/g,':"$1",'))),this.verbose&&this.log(new Date,"onMessage",s)}catch(e){this.log(new Date,"onMessage JSON.parse",e)}try{this.onMessageCallback(this,s)}catch(e){this.reject(e)}}}},3206:(e,t,s)=>{function i(){let e,t;const s=new Promise(((s,i)=>{e=s,t=i}));return s.resolve=function(){setTimeout((()=>{e.apply(this,arguments)}))},s.reject=function(){setTimeout((()=>{t.apply(this,arguments)}))},s}s.d(t,{K:()=>i}),i.race=e=>function(e){const t=i();return e.then(t.resolve,t.reject),t}(Promise.race(e))},3828:(e,t,s)=>{s.d(t,{Mi:()=>o,if:()=>n,nS:()=>d});var i=s(8403),r=s(7437),a=s(975);class o{constructor(e={},t=void 0){this.cache=[],Object.defineProperty(this,"cache",{__proto__:null,value:[],writable:!0,enumerable:!1}),t=t||Number.MAX_SAFE_INTEGER;const s={bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0,symbol:void 0},o=Object.entries((0,r.X$)(s,e));for(let e=0;e<o.length;e++){const[t,s]=o[e];this[t]=s}"Array"===this.asks.constructor.name&&(this.asks=new a.$w(this.asks,t)),"Array"===this.bids.constructor.name&&(this.bids=new a.PB(this.bids,t)),this.timestamp&&(this.datetime=(0,i.LC)(this.timestamp))}limit(){return this.asks.limit(),this.bids.limit(),this}update(e){return void 0!==e.nonce&&void 0!==this.nonce&&e.nonce<=this.nonce?this:(this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=(0,i.LC)(this.timestamp),this.reset(e))}reset(e={}){if(this.asks.index.fill(Number.MAX_VALUE),this.asks.length=0,e.asks)for(let t=0;t<e.asks.length;t++)this.asks.storeArray(e.asks[t]);if(this.bids.index.fill(Number.MAX_VALUE),this.bids.length=0,e.bids)for(let t=0;t<e.bids.length;t++)this.bids.storeArray(e.bids[t]);return this.nonce=e.nonce,this.timestamp=e.timestamp,this.datetime=(0,i.LC)(this.timestamp),this.symbol=e.symbol,this}}class n extends o{constructor(e={},t=void 0){super((0,r.X$)(e,{asks:new a.f_(e.asks||[],t),bids:new a.jR(e.bids||[],t)}))}}class d extends o{constructor(e={},t=void 0){super((0,r.X$)(e,{asks:new a.o5(e.asks||[],t),bids:new a.eB(e.bids||[],t)}))}}},975:(e,t,s)=>{function i(e,t){let s=0,i=e.length-1;for(;s<=i;){const r=s+i>>>1;e[r]-t<0?s=r+1:i=r-1}return s}s.d(t,{$w:()=>d,PB:()=>h,eB:()=>p,f_:()=>c,jR:()=>l,o5:()=>u});const r=new Float64Array(new Array(1024).fill(Number.MAX_VALUE));class a extends Array{constructor(e=[],t=void 0){super(),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(r),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0}),this.length=0;for(let t=0;t<e.length;t++)this.storeArray(e[t].slice())}storeArray(e){const t=e[0],s=e[1],r=this.side?-t:t,a=i(this.index,r);if(s){if(this.index[a]===r)this[a][1]=s;else if(this.length++,this.index.copyWithin(a+1,a,this.index.length),this.index[a]=r,this.copyWithin(a+1,a,this.length),this[a]=e,this.length>this.index.length-1){const e=Array.from(this.index);e.length=2*this.length,e.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(e)}}else this.index[a]===r&&(this.index.copyWithin(a,a+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(a,a+1,this.length),this.length--)}store(e,t){this.storeArray([e,t])}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class o extends a{store(e,t){throw new Error("CountedOrderBookSide.store() is not supported, use storeArray([price, size, count]) instead")}storeArray(e){const t=e[0],s=e[1],r=e[2],a=this.side?-t:t,o=i(this.index,a);if(s&&r){if(this.index[o]===a){const e=this[o];e[1]=s,e[2]=r}else if(this.length++,this.index.copyWithin(o+1,o,this.index.length),this.index[o]=a,this.copyWithin(o+1,o,this.length),this[o]=e,this.length>this.index.length-1){const e=Array.from(this.index);e.length=2*this.length,e.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(e)}}else this.index[o]===a&&(this.index.copyWithin(o,o+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(o,o+1,this.length),this.length--)}}class n extends Array{constructor(e=[],t=Number.MAX_SAFE_INTEGER){super(e.length),Object.defineProperty(this,"hashmap",{__proto__:null,value:new Map,writable:!0}),Object.defineProperty(this,"index",{__proto__:null,value:new Float64Array(r),writable:!0}),Object.defineProperty(this,"depth",{__proto__:null,value:t||Number.MAX_SAFE_INTEGER,writable:!0});for(let t=0;t<e.length;t++)this.length=t,this.storeArray(e[t].slice())}store(e,t){throw new Error("IndexedOrderBook.store() is not supported, use storeArray([price, size, id]) instead")}storeArray(e){const t=e[0],s=e[1],r=e[2];let a;if(a=void 0!==t?this.side?-t:t:void 0,s){if(this.hashmap.has(r)){const t=this.hashmap.get(r);if(a=a||t,e[0]=Math.abs(a),a===t){let t=i(this.index,a);for(;this[t][2]!==r;)t++;return this.index[t]=a,void(this[t]=e)}{let e=i(this.index,t);for(;this[e][2]!==r;)e++;this.index.copyWithin(e,e+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(e,e+1,this.length),this.length--}}this.hashmap.set(r,a);let t=i(this.index,a);for(;t<this.length&&this.index[t]===a&&this[t][2]<r;)t++;if(this.length++,this.index.copyWithin(t+1,t,this.index.length),this.index[t]=a,this.copyWithin(t+1,t,this.length),this[t]=e,this.length>this.index.length-1){const e=Array.from(this.index);e.length=2*this.length,e.fill(Number.MAX_VALUE,this.index.length),this.index=new Float64Array(e)}}else if(this.hashmap.has(r)){const e=this.hashmap.get(r);let t=i(this.index,e);for(;this[t][2]!==r;)t++;this.index.copyWithin(t,t+1,this.index.length),this.index[this.length-1]=Number.MAX_VALUE,this.copyWithin(t,t+1,this.length),this.length--,this.hashmap.delete(r)}}limit(){if(this.length>this.depth){for(let e=this.depth;e<this.length;e++)this.hashmap.delete(this.index[e]),this.index[e]=Number.MAX_VALUE;this.length=this.depth}}}class d extends a{get side(){return!1}}class h extends a{get side(){return!0}}class c extends o{get side(){return!1}}class l extends o{get side(){return!0}}class u extends n{get side(){return!1}}class p extends n{get side(){return!0}}},7288:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(1591),r=s.n(i),a=s(934),o=s(7597),n=s(8403),d=s(3206);const h=o.Ll?r():self.WebSocket;class c extends a.A{constructor(){super(...arguments),this.startedConnecting=!1}createConnection(){this.verbose&&this.log(new Date,"connecting to",this.url),this.connectionStarted=(0,n.Rz)(),this.setConnectionTimeout(),o.Ll?this.connection=new h(this.url,this.protocols,this.options):this.connection=new h(this.url,this.protocols),this.connection.onopen=this.onOpen.bind(this),this.connection.onmessage=this.onMessage.bind(this),this.connection.onerror=this.onError.bind(this),this.connection.onclose=this.onClose.bind(this),o.Ll&&this.connection.on("ping",this.onPing.bind(this)).on("pong",this.onPong.bind(this)).on("upgrade",this.onUpgrade.bind(this))}connect(e=0){return this.startedConnecting||(this.startedConnecting=!0,e?(0,n.yy)(e).then(this.createConnection.bind(this)):this.createConnection()),this.connected}isOpen(){return this.connection.readyState===h.OPEN}close(){return this.connection instanceof h&&(void 0===this.disconnected&&(this.disconnected=(0,d.K)()),this.connection.close()),this.disconnected}}},9002:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(7996);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io/api/3",private:"https://api.bequant.io/api/3"},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io/referral/dd104e3bee7634ec"}})}}},8698:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(3971),r=s(2079),a=s(1579),o=s(5354),n=s(4852),d=s(5147);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bigone",name:"BigONE",countries:["CN"],version:"v3",rateLimit:20,has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:!0,cancelOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createPostOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingRate:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchWithdrawals:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"min1","5m":"min5","15m":"min15","30m":"min30","1h":"hour1","3h":"hour3","4h":"hour4","6h":"hour6","12h":"hour12","1d":"day1","1w":"week1","1M":"month1"},hostname:"big.one",urls:{logo:"https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg",api:{public:"https://{hostname}/api/v3",private:"https://{hostname}/api/v3/viewer",contractPublic:"https://{hostname}/api/contract/v2",contractPrivate:"https://{hostname}/api/contract/v2",webExchange:"https://{hostname}/api/"},www:"https://big.one",doc:"https://open.big.one/docs/api.html",fees:"https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy",referral:"https://b1.run/users/new?code=D3LLBVFT"},api:{public:{get:["ping","asset_pairs","asset_pairs/{asset_pair_name}/depth","asset_pairs/{asset_pair_name}/trades","asset_pairs/{asset_pair_name}/ticker","asset_pairs/{asset_pair_name}/candles","asset_pairs/tickers"]},private:{get:["accounts","fund/accounts","assets/{asset_symbol}/address","orders","orders/{id}","orders/multi","trades","withdrawals","deposits"],post:["orders","orders/{id}/cancel","orders/cancel","withdrawals","transfer"]},contractPublic:{get:["symbols","instruments","depth@{symbol}/snapshot","instruments/difference","instruments/prices"]},contractPrivate:{get:["accounts","orders/{id}","orders","orders/opening","orders/count","orders/opening/count","trades","trades/count"],post:["orders","orders/batch"],put:["positions/{symbol}/margin","positions/{symbol}/risk-limit"],delete:["orders/{id}","orders/batch"]},webExchange:{get:["uc/v2/assets"]}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},options:{createMarketBuyOrderRequiresPrice:!0,accountsByType:{spot:"SPOT",fund:"FUND",funding:"FUND",future:"CONTRACT",swap:"CONTRACT"},transfer:{fillResponseFromRequest:!0},exchangeMillisecondsCorrection:-100,fetchCurrencies:{webApiEnable:!0,webApiRetries:5,webApiMuteFailure:!0},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},networks:{ABBC:"ABBC",ACA:"Acala",AE:"Aeternity",ALGO:"Algorand",APT:"Aptos",AR:"Arweave",ASTR:"Astar",AVAXC:"Avax",AVAXX:"AvaxChain",BEAM:"Beam",BEP20:"BinanceSmartChain",BITCI:"BitciChain",BTC:"Bitcoin",BCH:"BitcoinCash",BSV:"BitcoinSV",CELO:"Celo",CKKB:"CKB",ATOM:"Cosmos",CRC20:"CRO",DASH:"Dash",DOGE:"Dogecoin",XEC:"ECash",EOS:"EOS",ETH:"Ethereum",ETC:"EthereumClassic",ETHW:"EthereumPow",FTM:"Fantom",FIL:"Filecoin",FSN:"Fusion",GRIN:"Grin",ONE:"Harmony",HRC20:"Hecochain",HBAR:"Hedera",HNT:"Helium",ZEN:"Horizen",IOST:"IOST",IRIS:"IRIS",KLAY:"Klaytn",KSM:"Kusama",LTC:"Litecoin",XMR:"Monero",GLMR:"Moonbeam",NEAR:"Near",NEO:"Neo",NEON3:"NeoN3",OASIS:"Oasis",OKC:"Okexchain",ONT:"Ontology",OPTIMISM:"Optimism",DOT:"Polkadot",MATIC:"Polygon",QTUM:"Qtum",REI:"REI",XRP:"Ripple",SGB:"SGB",SDN:"Shiden",SOL:"Solana",XLM:"Stellar",TERA:"Tera",XTZ:"Tezos",TRC20:"Tron",VET:"Vechain",VSYS:"VSystems",WAX:"WAX",ZEC:"Zcash"}},precisionMode:a.kb,exceptions:{exact:{10001:r.BadRequest,10005:r.ExchangeError,"Amount's scale must greater than AssetPair's base scale":r.InvalidOrder,"Price mulit with amount should larger than AssetPair's min_quote_value":r.InvalidOrder,10007:r.BadRequest,10011:r.ExchangeError,10013:r.BadSymbol,10014:r.InsufficientFunds,10403:r.PermissionDenied,10429:r.RateLimitExceeded,40004:r.AuthenticationError,40103:r.AuthenticationError,40104:r.AuthenticationError,40301:r.PermissionDenied,40302:r.ExchangeError,40601:r.ExchangeError,40602:r.ExchangeError,40603:r.InsufficientFunds,40604:r.InvalidOrder,40605:r.InvalidOrder,40120:r.InvalidOrder,40121:r.InvalidOrder,60100:r.BadSymbol},broad:{}},commonCurrencies:{CRE:"Cybereits",FXT:"FXTTOKEN",FREE:"FreeRossDAO",MBN:"Mobilian Coin",ONE:"BigONE Token"}})}async fetchCurrencies(e={}){const t=await this.fetchWebEndpoint("fetchCurrencies","webExchangeGetUcV2Assets",!0);if(void 0===t)return;const s=this.safeList(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeCurrencyCode(r),o=this.safeString(t,"name"),n=this.safeBool(t,"is_fiat")?"fiat":"crypto",h={},c=this.safeList(t,"binding_gateways",[]);let l,u,p=this.parsePrecision(this.safeString2(t,"withdrawal_scale","scale"));for(let e=0;e<c.length;e++){const t=c[e],s=this.safeString(t,"gateway_name"),i=this.networkIdToCode(s),r=this.safeBool(t,"is_deposit_enabled"),a=this.safeBool(t,"is_withdrawal_enabled"),o=r&&a,n=this.safeString(t,"min_deposit_amount"),f=this.safeString(t,"min_withdrawal_amount"),m=this.safeString(t,"withdrawal_fee"),g=this.parsePrecision(this.safeString2(t,"withdrawal_scale","scale"));h[i]={id:s,network:i,margin:void 0,deposit:r,withdraw:a,active:o,fee:this.parseNumber(m),precision:this.parseNumber(g),limits:{deposit:{min:n,max:void 0},withdraw:{min:f,max:void 0}},info:t},l=void 0===l||r?r:l,u=void 0===u||a?a:u,p=void 0===p||d.Y.stringGt(p,g)?g:p}i[a]={id:r,code:a,info:t,name:o,type:n,active:void 0,deposit:l,withdraw:u,fee:void 0,precision:this.parseNumber(p),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:h}}return i}async fetchMarkets(e={}){const t=[this.publicGetAssetPairs(e),this.contractPublicGetSymbols(e)],s=await Promise.all(t),i=s[0],r=s[1],a=this.safeList(i,"data",[]),o=[];for(let e=0;e<a.length;e++){const t=a[e],s=this.safeDict(t,"base_asset",{}),i=this.safeDict(t,"quote_asset",{}),r=this.safeString(s,"symbol"),n=this.safeString(i,"symbol"),d=this.safeCurrencyCode(r),h=this.safeCurrencyCode(n);o.push(this.safeMarketStructure({id:this.safeString(t,"name"),uuid:this.safeString(t,"id"),symbol:d+"/"+h,base:d,quote:h,settle:void 0,baseId:r,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"base_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quote_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"min_quote_value"),max:this.safeNumber(t,"max_quote_value")}},created:void 0,info:t}))}for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"baseCurrency"),i=this.safeString(t,"quoteCurrency"),a=this.safeString(t,"settleCurrency"),n=this.safeString(t,"symbol"),d=this.safeCurrencyCode(s),h=this.safeCurrencyCode(i),c=this.safeCurrencyCode(a),l=this.safeBool(t,"isInverse");o.push(this.safeMarketStructure({id:n,symbol:d+"/"+h+":"+c,base:d,quote:h,settle:c,baseId:s,quoteId:i,settleId:a,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:this.safeBool(t,"enable"),contract:!0,linear:!l,inverse:l,contractSize:this.safeNumber(t,"multiplier"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"valuePrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:this.safeNumber(t,"priceMin"),max:this.safeNumber(t,"priceMax")},cost:{min:this.safeNumber(t,"initialMargin"),max:void 0}},info:t}))}return o}parseTicker(e,t=void 0){const s="asset_pair_name"in e?"spot":"swap",i=this.safeString2(e,"asset_pair_name","symbol"),r=this.safeSymbol(i,t,"-",s),a=this.safeString2(e,"close","latestPrice"),o=this.safeDict(e,"bid",{}),n=this.safeDict(e,"ask",{});return this.safeTicker({symbol:r,timestamp:void 0,datetime:void 0,high:this.safeString2(e,"high","last24hMaxPrice"),low:this.safeString2(e,"low","last24hMinPrice"),bid:this.safeString(o,"price"),bidVolume:this.safeString(o,"quantity"),ask:this.safeString(n,"price"),askVolume:this.safeString(n,"quantity"),vwap:void 0,open:this.safeString(e,"open"),close:a,last:a,previousClose:void 0,change:this.safeString2(e,"daily_change","last24hPriceChange"),percentage:void 0,average:void 0,baseVolume:this.safeString2(e,"volume","volume24h"),quoteVolume:this.safeString(e,"volume24hInUsd"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if([i,t]=this.handleMarketTypeAndParams("fetchTicker",s,t),"spot"===i){const e={asset_pair_name:s.id},i=await this.publicGetAssetPairsAssetPairNameTicker(this.extend(e,t)),r=this.safeDict(i,"data",{});return this.parseTicker(r,s)}{const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}}async fetchTickers(e=void 0,t={}){let s;await this.loadMarkets();const i=this.safeString(e,0);let r;void 0!==i&&(s=this.market(i)),[r,t]=this.handleMarketTypeAndParams("fetchTickers",s,t);const a="spot"===r,o={};let n;if(e=this.marketSymbols(e),a){if(void 0!==e){const t=this.marketIds(e);o.pair_names=t.join(",")}const s=await this.publicGetAssetPairsTickers(this.extend(o,t));n=this.safeList(s,"data",[])}else n=await this.contractPublicGetInstruments(t);const d=this.parseTickers(n,e);return this.filterByArrayTickers(d,"symbol",e)}async fetchTime(e={}){const t=await this.publicGetPing(e),s=this.safeDict(t,"data",{}),i=this.safeInteger(s,"Timestamp");return this.parseToInt(i/1e6)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let r;if(i.contract){const e={symbol:i.id};return r=await this.contractPublicGetDepthSymbolSnapshot(this.extend(e,s)),this.parseContractOrderBook(r,i.symbol,t)}{const e={asset_pair_name:i.id};void 0!==t&&(e.limit=t),r=await this.publicGetAssetPairsAssetPairNameDepth(this.extend(e,s));const a=this.safeDict(r,"data",{});return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","quantity")}}parseContractBidsAsks(e){const t=Object.keys(e),s=[];for(let i=0;i<t.length;i++){const r=t[i],a=e[r];s.push([this.parseNumber(r),this.parseNumber(a)])}return s}parseContractOrderBook(e,t,s=void 0){const i=this.safeValue(e,"bids"),r=this.safeValue(e,"asks"),a=this.parseContractBidsAsks(i),o=this.parseContractBidsAsks(r);return{symbol:t,bids:this.filterByLimit(this.sortBy(a,0,!0),s),asks:this.filterByLimit(this.sortBy(o,0),s),timestamp:void 0,datetime:void 0,nonce:void 0}}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"created_at","inserted_at")),i=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=this.safeString(e,"asset_pair_name");t=this.safeMarket(a,t,"-");let o=this.safeString(e,"side");const n=this.safeString(e,"taker_side");let d;void 0!==n&&void 0!==o&&"SELF_TRADING"!==o&&(d=n===o?"taker":"maker"),void 0===o?o="ASK"===n?"sell":"buy":"BID"===o?o="buy":"ASK"===o&&(o="sell");const h=this.safeString(e,"maker_order_id"),c=this.safeString(e,"taker_order_id");let l;void 0!==h?l=h:void 0!==c&&(l=c);const u={id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:l,type:"limit",side:o,takerOrMaker:d,price:i,amount:r,cost:void 0,info:e};let p,f;void 0!==d?"buy"===o?"maker"===d?(p=t.base,f=t.quote):(p=t.quote,f=t.base):"maker"===d?(p=t.quote,f=t.base):(p=t.base,f=t.quote):"SELF_TRADING"===o&&("BID"===n?(p=t.quote,f=t.base):"ASK"===n&&(p=t.base,f=t.quote));const m=this.safeString(e,"maker_fee"),g=this.safeString(e,"taker_fee");return void 0!==m?void 0!==g?u.fees=[{cost:m,currency:p},{cost:g,currency:f}]:u.fee={cost:m,currency:p}:u.fee=void 0!==g?{cost:g,currency:f}:void 0,this.safeTrade(u,t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e);if(a.contract)throw new r.BadRequest(this.id+" fetchTrades () can only fetch trades for spot markets");const o={asset_pair_name:a.id},n=await this.publicGetAssetPairsAssetPairNameTrades(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e);if(o.contract)throw new r.BadRequest(this.id+" fetchOHLCV () can only fetch ohlcvs for spot markets");void 0===i&&(i=100);const n={asset_pair_name:o.id,period:this.safeString(this.timeframes,t,t),limit:i};if(void 0!==s){const e=this.parseTimeframe(t),r=this.sum(s,i*e*1e3);n.time=this.iso8601(r)}const d=await this.publicGetAssetPairsAssetPairNameCandles(this.extend(n,a)),h=this.safeList(d,"data",[]);return this.parseOHLCVs(h,o,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeList(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"asset_symbol"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.used=this.safeString(i,"locked_balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"type","");let s;return e=this.omit(e,"type"),s="funding"===t||"fund"===t?await this.privateGetFundAccounts(e):await this.privateGetAccounts(e),this.parseBalance(s)}parseType(e){return this.safeString({STOP_LIMIT:"limit",STOP_MARKET:"market",LIMIT:"limit",MARKET:"market"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"asset_pair_name"),r=this.safeSymbol(i,t,"-"),a=this.parse8601(this.safeString(e,"created_at"));let o=this.safeString(e,"side");o="BID"===o?"buy":"sell";let n=this.safeString(e,"stop_price");d.Y.stringEq(n,"0")&&(n=void 0);let h;this.safeBool(e,"immediate_or_cancel")&&(h="IOC");const c=this.parseType(this.safeString(e,"type")),l=this.safeString(e,"price");let u,p,f;return"market"===c&&"buy"===o?f=this.safeString(e,"filled_amount"):(u=this.safeString(e,"amount"),p=this.safeString(e,"filled_amount")),this.safeOrder({info:e,id:s,clientOrderId:this.safeString(e,"client_order_id"),timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:this.parse8601(this.safeString(e,"updated_at")),symbol:r,type:c,timeInForce:h,postOnly:this.safeBool(e,"post_only"),side:o,price:l,stopPrice:n,triggerPrice:n,amount:u,cost:f,average:this.safeString(e,"avg_deal_price"),filled:p,remaining:void 0,status:this.parseOrderStatus(this.safeString(e,"state")),fee:void 0,trades:void 0},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),h="buy"===s,c=h?"BID":"ASK";let l=t.toUpperCase();const u="LIMIT"===l,p=this.safeBool(o,"post_only",!1);let f;[f,o]=this.handlePostOnly("MARKET"===l,p,o);const m=this.safeStringN(o,["triggerPrice","stopPrice","stop_price"]),g={asset_pair_name:n.id,side:c,amount:this.amountToPrecision(e,i)};if(u||"STOP_LIMIT"===l){if(g.price=this.priceToPrecision(e,a),u){"IOC"===this.safeString(o,"timeInForce")&&(g.immediate_or_cancel=!0),f&&(g.post_only=!0)}g.amount=this.amountToPrecision(e,i)}else if(h){let t=!0;[t,o]=this.handleOptionAndParams(o,"createOrder","createMarketBuyOrderRequiresPrice",!0);const s=this.safeNumber(o,"cost");if(o=this.omit(o,"cost"),t){if(void 0===a&&void 0===s)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const t=this.numberToString(i),r=this.numberToString(a),o=this.parseToNumeric(d.Y.stringMul(t,r)),n=void 0!==s?s:o;g.amount=this.costToPrecision(e,n)}}else g.amount=this.costToPrecision(e,i)}else g.amount=this.amountToPrecision(e,i);void 0!==m&&(g.stop_price=this.priceToPrecision(e,m),g.operator=h?"GTE":"LTE",u?l="STOP_LIMIT":"MARKET"===l&&(l="STOP_MARKET")),g.type=l;const v=this.safeString(o,"clientOrderId");void 0!==v&&(g.client_order_id=v),o=this.omit(o,["stop_price","stopPrice","triggerPrice","timeInForce","clientOrderId"]);const y=await this.privatePostOrders(this.extend(g,o)),w=this.safeDict(y,"data");return this.parseOrder(w,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privatePostOrdersIdCancel(this.extend(i,s)),a=this.safeDict(r,"data");return this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={asset_pair_name:this.market(e).id},i=await this.privatePostOrdersCancel(this.extend(s,t)),r=this.safeDict(i,"data",{}),a=this.safeList(r,"cancelled",[]),o=this.safeList(r,"failed",[]),n=[];for(let e=0;e<a.length;e++){const t=a[e];n.push(this.safeOrder({info:t,id:t,status:"canceled"}))}for(let e=0;e<o.length;e++){const t=o[e];n.push(this.safeOrder({info:t,id:t,status:"failed"}))}return n}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrdersId(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={asset_pair_name:a.id};void 0!==s&&(o.limit=s);const n=await this.privateGetOrders(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseOrders(d,a,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={asset_pair_name:a.id};void 0!==s&&(o.limit=s);const n=await this.privateGetTrades(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}parseOrderStatus(e){return this.safeString({PENDING:"open",FILLED:"closed",CANCELLED:"canceled"},e)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({state:"PENDING"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({state:"FILLED"},i))}nonce(){const e=1e6*this.safeInteger(this.options,"exchangeMillisecondsCorrection",0);return this.sum(1e3*this.microseconds(),e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const d=this.omit(i,this.extractParams(e));let h=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);if(r={},"public"===t||"webExchange"===t||"contractPublic"===t)Object.keys(d).length&&(h+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t={type:"OpenAPIV2",sub:this.apiKey,nonce:e},i=(0,o.a)(t,this.encode(this.secret),n.s);r.Authorization="Bearer "+i,"GET"===s?Object.keys(d).length&&(h+="?"+this.urlencode(d)):"POST"===s&&(r["Content-Type"]="application/json",a=this.json(d))}return r["User-Agent"]="ccxt/"+this.id+"-"+this.version,{url:h,method:s,body:a,headers:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={asset_symbol:this.currency(e).id},[i,a]=this.handleNetworkCodeAndParams(t),o=await this.privateGetAssetsAssetSymbolAddress(this.extend(s,a)),n=this.safeList(o,"data",[]);if(n.length<1)throw new r.ExchangeError(this.id+" fetchDepositAddress() returned empty address response");const d=this.indexBy(n,"chain"),h=this.selectNetworkIdFromRawNetworks(e,i,d),c=this.safeDict(d,h,{}),l=this.safeString(c,"value"),u=this.safeString(c,"memo");return this.checkAddress(l),{currency:e,address:l,tag:u,network:this.networkIdToCode(h),info:o}}parseTransactionStatus(e){return this.safeString({WITHHOLD:"ok",UNCONFIRMED:"pending",CONFIRMED:"ok",COMPLETED:"ok",PENDING:"pending"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"asset_symbol"),i=this.safeCurrencyCode(s),r=this.safeString(e,"id"),a=this.safeNumber(e,"amount"),o=this.parseTransactionStatus(this.safeString(e,"state")),n=this.parse8601(this.safeString(e,"inserted_at")),d=this.parse8601(this.safeString2(e,"updated_at","completed_at")),h=this.safeString(e,"txid"),c=this.safeString(e,"target_address"),l=this.safeString(e,"memo"),u="customer_id"in e?"withdrawal":"deposit",p=this.safeBool(e,"is_internal");return{info:e,id:r,txid:h,timestamp:n,datetime:this.iso8601(n),network:void 0,addressFrom:void 0,address:void 0,addressTo:c,tagFrom:void 0,tag:l,tagTo:void 0,type:u,amount:a,currency:i,status:o,updated:d,fee:void 0,comment:void 0,internal:p}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset_symbol=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetDeposits(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset_symbol=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetWithdrawals(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.safeString(r,"guid",this.uuid()),c={symbol:a.id,amount:this.currencyToPrecision(e,t),from:n,to:d,guid:h},l=await this.privatePostTransfer(this.extend(c,r)),u=this.parseTransfer(l,a),p=this.safeDict(this.options,"transfer",{});return this.safeBool(p,"fillResponseFromRequest",!0)&&(u.fromAccount=s,u.toAccount=i,u.amount=t,u.id=h),u}parseTransfer(e,t=void 0){const s=this.safeString(e,"code");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:void 0,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return this.safeString({0:"ok"},e,"failed")}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={symbol:a.id,target_address:s,amount:this.currencyToPrecision(e,t)};let n;void 0!==i&&(o.memo=i),[n,r]=this.handleNetworkCodeAndParams(r),void 0!==n&&(o.gateway_name=this.networkCodeToId(n));const d=await this.privatePostWithdrawals(this.extend(o,r)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,a)}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"message");if("0"!==c&&void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},3192:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(335),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(5354),h=s(8283),c=s(6414);class l extends i.A{describe(){return this.deepExtend(super.describe(),{id:"binance",name:"Binance",countries:["JP","MT"],rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,addMargin:!0,borrowCrossMargin:!0,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createConvertTrade:!0,createDepositAddress:!1,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!0,createMarketSellOrder:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!1,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchAccounts:void 0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!0,fetchCanceledAndClosedOrders:"emulated",fetchCanceledOrders:"emulated",fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchConvertCurrencies:!0,fetchConvertQuote:!0,fetchConvertTrade:!0,fetchConvertTradeHistory:!0,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchGreeks:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:"emulated",fetchIsolatedBorrowRates:!0,fetchL3OrderBook:!1,fetchLastPrices:!0,fetchLedger:!0,fetchLedgerEntry:!0,fetchLeverage:"emulated",fetchLeverages:!0,fetchLeverageTiers:!0,fetchLiquidations:!1,fetchMarginAdjustmentHistory:!0,fetchMarginMode:"emulated",fetchMarginModes:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!0,fetchMySettlementHistory:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!1,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!0,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTradingLimits:"emulated",fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!0,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!1,fetchWithdrawAddresses:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayCrossMargin:!0,repayIsolatedMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1s":"1s","1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg",test:{dapiPublic:"https://testnet.binancefuture.com/dapi/v1",dapiPrivate:"https://testnet.binancefuture.com/dapi/v1",dapiPrivateV2:"https://testnet.binancefuture.com/dapi/v2",fapiPublic:"https://testnet.binancefuture.com/fapi/v1",fapiPublicV2:"https://testnet.binancefuture.com/fapi/v2",fapiPublicV3:"https://testnet.binancefuture.com/fapi/v3",fapiPrivate:"https://testnet.binancefuture.com/fapi/v1",fapiPrivateV2:"https://testnet.binancefuture.com/fapi/v2",fapiPrivateV3:"https://testnet.binancefuture.com/fapi/v3",public:"https://testnet.binance.vision/api/v3",private:"https://testnet.binance.vision/api/v3",v1:"https://testnet.binance.vision/api/v1"},api:{sapi:"https://api.binance.com/sapi/v1",sapiV2:"https://api.binance.com/sapi/v2",sapiV3:"https://api.binance.com/sapi/v3",sapiV4:"https://api.binance.com/sapi/v4",dapiPublic:"https://dapi.binance.com/dapi/v1",dapiPrivate:"https://dapi.binance.com/dapi/v1",eapiPublic:"https://eapi.binance.com/eapi/v1",eapiPrivate:"https://eapi.binance.com/eapi/v1",dapiPrivateV2:"https://dapi.binance.com/dapi/v2",dapiData:"https://dapi.binance.com/futures/data",fapiPublic:"https://fapi.binance.com/fapi/v1",fapiPublicV2:"https://fapi.binance.com/fapi/v2",fapiPublicV3:"https://fapi.binance.com/fapi/v3",fapiPrivate:"https://fapi.binance.com/fapi/v1",fapiPrivateV2:"https://fapi.binance.com/fapi/v2",fapiPrivateV3:"https://fapi.binance.com/fapi/v3",fapiData:"https://fapi.binance.com/futures/data",public:"https://api.binance.com/api/v3",private:"https://api.binance.com/api/v3",v1:"https://api.binance.com/api/v1",papi:"https://papi.binance.com/papi/v1"},www:"https://www.binance.com",referral:{url:"https://accounts.binance.com/en/register?ref=D7YA7CLY",discount:.1},doc:["https://developers.binance.com/en"],api_management:"https://www.binance.com/en/usercenter/settings/api-management",fees:"https://www.binance.com/en/fee/schedule"},api:{sapi:{get:{"copyTrading/futures/userStatus":2,"copyTrading/futures/leadSymbol":2,"system/status":.1,accountSnapshot:240,"account/info":.1,"margin/asset":1,"margin/pair":1,"margin/allAssets":.1,"margin/allPairs":.1,"margin/priceIndex":1,"spot/delist-schedule":10,"asset/assetDividend":1,"asset/dribblet":.1,"asset/transfer":.1,"asset/assetDetail":.1,"asset/tradeFee":.1,"asset/ledger-transfer/cloud-mining/queryByPage":4.0002,"asset/convert-transfer/queryByPage":.033335,"asset/wallet/balance":6,"asset/custody/transfer-history":6,"margin/borrow-repay":1,"margin/loan":1,"margin/repay":1,"margin/account":1,"margin/transfer":.1,"margin/interestHistory":.1,"margin/forceLiquidationRec":.1,"margin/order":1,"margin/openOrders":1,"margin/allOrders":20,"margin/myTrades":1,"margin/maxBorrowable":5,"margin/maxTransferable":5,"margin/tradeCoeff":1,"margin/isolated/transfer":.1,"margin/isolated/account":1,"margin/isolated/pair":1,"margin/isolated/allPairs":1,"margin/isolated/accountLimit":.1,"margin/interestRateHistory":.1,"margin/orderList":1,"margin/allOrderList":20,"margin/openOrderList":1,"margin/crossMarginData":{cost:.1,noCoin:.5},"margin/isolatedMarginData":{cost:.1,noCoin:1},"margin/isolatedMarginTier":.1,"margin/rateLimit/order":2,"margin/dribblet":.1,"margin/dust":20.001,"margin/crossMarginCollateralRatio":10,"margin/exchange-small-liability":.6667,"margin/exchange-small-liability-history":.6667,"margin/next-hourly-interest-rate":.6667,"margin/capital-flow":10,"margin/delist-schedule":10,"margin/available-inventory":.3334,"margin/leverageBracket":.1,"loan/vip/loanable/data":40,"loan/vip/collateral/data":40,"loan/vip/request/data":2.6668,"loan/vip/request/interestRate":2.6668,"loan/income":40.002,"loan/ongoing/orders":40,"loan/ltv/adjustment/history":40,"loan/borrow/history":40,"loan/repay/history":40,"loan/loanable/data":40,"loan/collateral/data":40,"loan/repay/collateral/rate":600,"loan/flexible/ongoing/orders":30,"loan/flexible/borrow/history":40,"loan/flexible/repay/history":40,"loan/flexible/ltv/adjustment/history":40,"loan/vip/ongoing/orders":40,"loan/vip/repay/history":40,"loan/vip/collateral/account":600,"fiat/orders":600.03,"fiat/payments":.1,"futures/transfer":1,"futures/histDataLink":.1,"rebate/taxQuery":80.004,"capital/config/getall":1,"capital/deposit/address":1,"capital/deposit/address/list":1,"capital/deposit/hisrec":.1,"capital/deposit/subAddress":.1,"capital/deposit/subHisrec":.1,"capital/withdraw/history":2,"capital/withdraw/address/list":10,"capital/contract/convertible-coins":4.0002,"convert/tradeFlow":20.001,"convert/exchangeInfo":50,"convert/assetInfo":10,"convert/orderStatus":.6667,"convert/limit/queryOpenOrders":20.001,"account/status":.1,"account/apiTradingStatus":.1,"account/apiRestrictions/ipRestriction":.1,bnbBurn:.1,"sub-account/futures/account":1,"sub-account/futures/accountSummary":.1,"sub-account/futures/positionRisk":1,"sub-account/futures/internalTransfer":.1,"sub-account/list":.1,"sub-account/margin/account":1,"sub-account/margin/accountSummary":1,"sub-account/spotSummary":.1,"sub-account/status":1,"sub-account/sub/transfer/history":.1,"sub-account/transfer/subUserHistory":.1,"sub-account/universalTransfer":.1,"sub-account/apiRestrictions/ipRestriction/thirdPartyList":1,"sub-account/transaction-statistics":.40002,"sub-account/subAccountApi/ipRestriction":20.001,"managed-subaccount/asset":.1,"managed-subaccount/accountSnapshot":240,"managed-subaccount/queryTransLogForInvestor":.1,"managed-subaccount/queryTransLogForTradeParent":.40002,"managed-subaccount/fetch-future-asset":.40002,"managed-subaccount/marginAsset":.1,"managed-subaccount/info":.40002,"managed-subaccount/deposit/address":.006667,"managed-subaccount/query-trans-log":.40002,"lending/daily/product/list":.1,"lending/daily/userLeftQuota":.1,"lending/daily/userRedemptionQuota":.1,"lending/daily/token/position":.1,"lending/union/account":.1,"lending/union/purchaseRecord":.1,"lending/union/redemptionRecord":.1,"lending/union/interestHistory":.1,"lending/project/list":.1,"lending/project/position/list":.1,"eth-staking/eth/history/stakingHistory":15,"eth-staking/eth/history/redemptionHistory":15,"eth-staking/eth/history/rewardsHistory":15,"eth-staking/eth/quota":15,"eth-staking/eth/history/rateHistory":15,"eth-staking/account":15,"eth-staking/wbeth/history/wrapHistory":15,"eth-staking/wbeth/history/unwrapHistory":15,"eth-staking/eth/history/wbethRewardsHistory":15,"mining/pub/algoList":.1,"mining/pub/coinList":.1,"mining/worker/detail":.5,"mining/worker/list":.5,"mining/payment/list":.5,"mining/statistics/user/status":.5,"mining/statistics/user/list":.5,"mining/payment/uid":.5,"bswap/pools":.1,"bswap/liquidity":{cost:.1,noPoolId:1},"bswap/liquidityOps":20.001,"bswap/quote":1.00005,"bswap/swap":20.001,"bswap/poolConfigure":1.00005,"bswap/addLiquidityPreview":1.00005,"bswap/removeLiquidityPreview":1.00005,"bswap/unclaimedRewards":6.667,"bswap/claimedHistory":6.667,"blvt/tokenInfo":.1,"blvt/subscribe/record":.1,"blvt/redeem/record":.1,"blvt/userLimit":.1,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/recentRecord":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/recentRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccountApi":1,"broker/subAccount":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/info":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/recentRecord":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/status":1,"broker/subAccount/depositHist":1,"broker/subAccount/spotSummary":1,"broker/subAccount/marginSummary":1,"broker/subAccount/futuresSummary":1,"broker/rebate/futures/recentRecord":1,"broker/subAccountApi/ipRestriction":1,"broker/universalTransfer":1,"account/apiRestrictions":.1,"c2c/orderMatch/listUserOrderHistory":.1,"nft/history/transactions":20.001,"nft/history/deposit":20.001,"nft/history/withdraw":20.001,"nft/user/getAsset":20.001,"pay/transactions":20.001,"giftcard/verify":.1,"giftcard/cryptography/rsa-public-key":.1,"giftcard/buyCode/token-limit":.1,"algo/spot/openOrders":.1,"algo/spot/historicalOrders":.1,"algo/spot/subOrders":.1,"algo/futures/openOrders":.1,"algo/futures/historicalOrders":.1,"algo/futures/subOrders":.1,"portfolio/account":.1,"portfolio/collateralRate":5,"portfolio/pmLoan":3.3335,"portfolio/interest-history":.6667,"portfolio/asset-index-price":.1,"portfolio/repay-futures-switch":3,"portfolio/margin-asset-leverage":5,"staking/productList":.1,"staking/position":.1,"staking/stakingRecord":.1,"staking/personalLeftQuota":.1,"lending/auto-invest/target-asset/list":.1,"lending/auto-invest/target-asset/roi/list":.1,"lending/auto-invest/all/asset":.1,"lending/auto-invest/source-asset/list":.1,"lending/auto-invest/plan/list":.1,"lending/auto-invest/plan/id":.1,"lending/auto-invest/history/list":.1,"lending/auto-invest/index/info":.1,"lending/auto-invest/index/user-summary":.1,"lending/auto-invest/one-off/status":.1,"lending/auto-invest/redeem/history":.1,"lending/auto-invest/rebalance/history":.1,"simple-earn/flexible/list":15,"simple-earn/locked/list":15,"simple-earn/flexible/personalLeftQuota":15,"simple-earn/locked/personalLeftQuota":15,"simple-earn/flexible/subscriptionPreview":15,"simple-earn/locked/subscriptionPreview":15,"simple-earn/flexible/history/rateHistory":15,"simple-earn/flexible/position":15,"simple-earn/locked/position":15,"simple-earn/account":15,"simple-earn/flexible/history/subscriptionRecord":15,"simple-earn/locked/history/subscriptionRecord":15,"simple-earn/flexible/history/redemptionRecord":15,"simple-earn/locked/history/redemptionRecord":15,"simple-earn/flexible/history/rewardsRecord":15,"simple-earn/locked/history/rewardsRecord":15,"simple-earn/flexible/history/collateralRecord":.1,"dci/product/list":.1,"dci/product/positions":.1,"dci/product/accounts":.1},post:{"asset/dust":.06667,"asset/dust-btc":.1,"asset/transfer":6.0003,"asset/get-funding-asset":.1,"asset/convert-transfer":.033335,"account/disableFastWithdrawSwitch":.1,"account/enableFastWithdrawSwitch":.1,"capital/withdraw/apply":4.0002,"capital/contract/convertible-coins":4.0002,"capital/deposit/credit-apply":.1,"margin/borrow-repay":20.001,"margin/transfer":4.0002,"margin/loan":20.001,"margin/repay":20.001,"margin/order":.040002,"margin/order/oco":.040002,"margin/dust":20.001,"margin/exchange-small-liability":20.001,"margin/isolated/transfer":4.0002,"margin/isolated/account":2.0001,"margin/max-leverage":300,bnbBurn:.1,"sub-account/virtualSubAccount":.1,"sub-account/margin/transfer":4.0002,"sub-account/margin/enable":.1,"sub-account/futures/enable":.1,"sub-account/futures/transfer":.1,"sub-account/futures/internalTransfer":.1,"sub-account/transfer/subToSub":.1,"sub-account/transfer/subToMaster":.1,"sub-account/universalTransfer":.1,"sub-account/options/enable":.1,"managed-subaccount/deposit":.1,"managed-subaccount/withdraw":.1,userDataStream:.1,"userDataStream/isolated":.1,"futures/transfer":.1,"lending/customizedFixed/purchase":.1,"lending/daily/purchase":.1,"lending/daily/redeem":.1,"bswap/liquidityAdd":60,"bswap/liquidityRemove":60,"bswap/swap":60,"bswap/claimRewards":6.667,"blvt/subscribe":.1,"blvt/redeem":.1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/rebate/historicalRecord":1,"apiReferral/kickback/historicalRecord":1,"broker/subAccount":1,"broker/subAccount/margin":1,"broker/subAccount/futures":1,"broker/subAccountApi":1,"broker/subAccountApi/permission":1,"broker/subAccountApi/commission":1,"broker/subAccountApi/commission/futures":1,"broker/subAccountApi/commission/coinFutures":1,"broker/transfer":1,"broker/transfer/futures":1,"broker/rebate/historicalRecord":1,"broker/subAccount/bnbBurn/spot":1,"broker/subAccount/bnbBurn/marginInterest":1,"broker/subAccount/blvt":1,"broker/subAccountApi/ipRestriction":1,"broker/subAccountApi/ipRestriction/ipList":1,"broker/universalTransfer":1,"broker/subAccountApi/permission/universalTransfer":1,"broker/subAccountApi/permission/vanillaOptions":1,"giftcard/createCode":.1,"giftcard/redeemCode":.1,"giftcard/buyCode":.1,"algo/spot/newOrderTwap":20.001,"algo/futures/newOrderVp":20.001,"algo/futures/newOrderTwap":20.001,"staking/purchase":.1,"staking/redeem":.1,"staking/setAutoStaking":.1,"eth-staking/eth/stake":15,"eth-staking/eth/redeem":15,"eth-staking/wbeth/wrap":15,"mining/hash-transfer/config":.5,"mining/hash-transfer/config/cancel":.5,"portfolio/repay":20.001,"loan/vip/renew":40.002,"loan/vip/borrow":40.002,"loan/borrow":40.002,"loan/repay":40.002,"loan/adjust/ltv":40.002,"loan/customize/margin_call":40.002,"loan/flexible/repay":40.002,"loan/flexible/adjust/ltv":40.002,"loan/vip/repay":40.002,"convert/getQuote":1.3334,"convert/acceptQuote":3.3335,"convert/limit/placeOrder":3.3335,"convert/limit/cancelOrder":1.3334,"portfolio/auto-collection":150,"portfolio/asset-collection":6,"portfolio/bnb-transfer":150,"portfolio/repay-futures-switch":150,"portfolio/repay-futures-negative-balance":150,"lending/auto-invest/plan/add":.1,"lending/auto-invest/plan/edit":.1,"lending/auto-invest/plan/edit-status":.1,"lending/auto-invest/one-off":.1,"lending/auto-invest/redeem":.1,"simple-earn/flexible/subscribe":.1,"simple-earn/locked/subscribe":.1,"simple-earn/flexible/redeem":.1,"simple-earn/locked/redeem":.1,"simple-earn/flexible/setAutoSubscribe":15,"simple-earn/locked/setAutoSubscribe":15,"dci/product/subscribe":.1,"dci/product/auto_compound/edit":.1},put:{userDataStream:.1,"userDataStream/isolated":.1},delete:{"margin/openOrders":.1,"margin/order":.006667,"margin/orderList":.006667,"margin/isolated/account":2.0001,userDataStream:.1,"userDataStream/isolated":.1,"broker/subAccountApi":1,"broker/subAccountApi/ipRestriction/ipList":1,"algo/spot/order":.1,"algo/futures/order":.1,"sub-account/subAccountApi/ipRestriction/ipList":20.001}},sapiV2:{get:{"eth-staking/account":15,"sub-account/futures/account":.1,"sub-account/futures/accountSummary":1,"sub-account/futures/positionRisk":.1,"loan/flexible/ongoing/orders":30,"loan/flexible/borrow/history":40,"loan/flexible/repay/history":40,"loan/flexible/ltv/adjustment/history":40,"loan/flexible/loanable/data":40,"loan/flexible/collateral/data":40},post:{"eth-staking/eth/stake":15,"sub-account/subAccountApi/ipRestriction":20.001,"loan/flexible/borrow":40.002,"loan/flexible/repay":40.002,"loan/flexible/adjust/ltv":40.002}},sapiV3:{get:{"sub-account/assets":.40002},post:{"asset/getUserAsset":.5}},sapiV4:{get:{"sub-account/assets":.40002}},dapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,premiumIndex:10,fundingRate:1,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},premiumIndexKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:2,noSymbol:5},constituents:2,openInterest:1}},dapiData:{get:{"delivery-price":1,openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerBuySellVol:1,basis:1}},dapiPrivate:{get:{"positionSide/dual":30,orderAmendment:1,order:1,openOrder:1,openOrders:{cost:1,noSymbol:5},allOrders:{cost:20,noSymbol:40},balance:1,account:5,"positionMargin/history":1,positionRisk:1,userTrades:{cost:20,noSymbol:40},income:20,leverageBracket:1,forceOrders:{cost:20,noSymbol:50},adlQuantile:5,commissionRate:20,"income/asyn":5,"income/asyn/id":5,pmExchangeInfo:.5,pmAccountInfo:.5},post:{"positionSide/dual":1,order:4,batchOrders:5,countdownCancelAll:10,leverage:1,marginType:1,positionMargin:1,listenKey:1},put:{listenKey:1,order:1,batchOrders:5},delete:{order:1,allOpenOrders:1,batchOrders:5,listenKey:1}},dapiPrivateV2:{get:{leverageBracket:1}},fapiPublic:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:2,byLimit:[[50,2],[100,5],[500,10],[1e3,20]]},trades:5,historicalTrades:20,aggTrades:20,klines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},continuousKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},markPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},indexPriceKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},premiumIndexKlines:{cost:1,byLimit:[[99,1],[499,2],[1e3,5],[1e4,10]]},fundingRate:1,fundingInfo:1,premiumIndex:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},openInterest:1,indexInfo:1,assetIndex:{cost:1,noSymbol:10},constituents:2,apiTradingStatus:{cost:1,noSymbol:10},lvtKlines:1}},fapiData:{get:{"delivery-price":1,openInterestHist:1,topLongShortAccountRatio:1,topLongShortPositionRatio:1,globalLongShortAccountRatio:1,takerlongshortRatio:1,basis:1}},fapiPrivate:{get:{forceOrders:{cost:20,noSymbol:50},allOrders:5,openOrder:1,openOrders:{cost:1,noSymbol:40},order:1,account:5,balance:5,leverageBracket:1,"positionMargin/history":1,positionRisk:5,"positionSide/dual":30,userTrades:5,income:30,commissionRate:20,"rateLimit/order":1,apiTradingStatus:1,multiAssetsMargin:30,"apiReferral/ifNewUser":1,"apiReferral/customization":1,"apiReferral/userCustomization":1,"apiReferral/traderNum":1,"apiReferral/overview":1,"apiReferral/tradeVol":1,"apiReferral/rebateVol":1,"apiReferral/traderSummary":1,adlQuantile:5,pmAccountInfo:5,orderAmendment:1,"income/asyn":1e3,"income/asyn/id":10,"order/asyn":1e3,"order/asyn/id":10,"trade/asyn":1e3,"trade/asyn/id":10,feeBurn:1,symbolConfig:5,accountConfig:5},post:{batchOrders:5,"positionSide/dual":1,positionMargin:1,marginType:1,order:4,leverage:1,listenKey:1,countdownCancelAll:10,multiAssetsMargin:1,"apiReferral/customization":1,"apiReferral/userCustomization":1,feeBurn:1},put:{listenKey:1,order:1,batchOrders:5},delete:{batchOrders:1,order:1,allOpenOrders:1,listenKey:1}},fapiPublicV2:{get:{"ticker/price":0}},fapiPrivateV2:{get:{account:1,balance:1,positionRisk:1}},fapiPublicV3:{get:{}},fapiPrivateV3:{get:{account:1,balance:1,positionRisk:1}},eapiPublic:{get:{ping:1,time:1,exchangeInfo:1,index:1,ticker:5,mark:5,depth:1,klines:1,trades:5,historicalTrades:20,exerciseHistory:3,openInterest:3}},eapiPrivate:{get:{account:3,position:5,openOrders:{cost:1,noSymbol:40},historyOrders:3,userTrades:5,exerciseRecord:5,bill:1,"income/asyn":5,"income/asyn/id":5,marginAccount:3,mmp:1,countdownCancelAll:1,order:1},post:{order:1,batchOrders:5,listenKey:1,mmpSet:1,mmpReset:1,countdownCancelAll:1,countdownCancelAllHeartBeat:10},put:{listenKey:1},delete:{order:1,batchOrders:1,allOpenOrders:1,allOpenOrdersByUnderlying:1,listenKey:1}},public:{get:{ping:.2,time:.2,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:2,aggTrades:.4,historicalTrades:2,klines:.4,uiKlines:.4,"ticker/24hr":{cost:.4,noSymbol:16},ticker:{cost:.4,noSymbol:16},"ticker/tradingDay":.8,"ticker/price":{cost:.4,noSymbol:.8},"ticker/bookTicker":{cost:.4,noSymbol:.8},exchangeInfo:4,avgPrice:.4},put:{userDataStream:.4},post:{userDataStream:.4},delete:{userDataStream:.4}},private:{get:{allOrderList:4,openOrderList:1.2,orderList:.8,order:.8,openOrders:{cost:1.2,noSymbol:16},allOrders:4,account:4,myTrades:4,"rateLimit/order":8,myPreventedMatches:4,myAllocations:4,"account/commission":4},post:{"order/oco":.2,"orderList/oco":.2,"orderList/oto":.2,"orderList/otoco":.2,"sor/order":.2,"sor/order/test":.2,order:.2,"order/cancelReplace":.2,"order/test":.2},delete:{openOrders:.2,orderList:.2,order:.2}},papi:{get:{ping:1,"um/order":1,"um/openOrder":1,"um/openOrders":{cost:1,noSymbol:40},"um/allOrders":5,"cm/order":1,"cm/openOrder":1,"cm/openOrders":{cost:1,noSymbol:40},"cm/allOrders":20,"um/conditional/openOrder":1,"um/conditional/openOrders":{cost:1,noSymbol:40},"um/conditional/orderHistory":1,"um/conditional/allOrders":40,"cm/conditional/openOrder":1,"cm/conditional/openOrders":{cost:1,noSymbol:40},"cm/conditional/orderHistory":1,"cm/conditional/allOrders":40,"margin/order":5,"margin/openOrders":5,"margin/allOrders":100,"margin/orderList":5,"margin/allOrderList":100,"margin/openOrderList":5,"margin/myTrades":5,balance:20,account:20,"margin/maxBorrowable":5,"margin/maxWithdraw":5,"um/positionRisk":5,"cm/positionRisk":1,"um/positionSide/dual":30,"cm/positionSide/dual":30,"um/userTrades":5,"cm/userTrades":20,"um/leverageBracket":1,"cm/leverageBracket":1,"margin/forceOrders":1,"um/forceOrders":20,"cm/forceOrders":20,"um/apiTradingStatus":1,"um/commissionRate":20,"cm/commissionRate":20,"margin/marginLoan":10,"margin/repayLoan":10,"margin/marginInterestHistory":1,"portfolio/interest-history":50,"um/income":30,"cm/income":30,"um/account":5,"cm/account":5,"repay-futures-switch":3,"um/adlQuantile":5,"cm/adlQuantile":5},post:{"um/order":1,"um/conditional/order":1,"cm/order":1,"cm/conditional/order":1,"margin/order":.0133,marginLoan:.1333,repayLoan:.1333,"margin/order/oco":.04,"um/leverage":1,"cm/leverage":1,"um/positionSide/dual":1,"cm/positionSide/dual":1,"auto-collection":.6667,"bnb-transfer":.6667,"repay-futures-switch":150,"repay-futures-negative-balance":150,listenKey:1,"asset-collection":3},put:{listenKey:1},delete:{"um/order":1,"um/conditional/order":1,"um/allOpenOrders":1,"um/conditional/allOpenOrders":1,"cm/order":1,"cm/conditional/order":1,"cm/allOpenOrders":1,"cm/conditional/allOpenOrders":1,"margin/order":1,"margin/allOpenOrders":5,"margin/orderList":2,listenKey:1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")},linear:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},inverse:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}},option:{}},commonCurrencies:{BCC:"BCC",YOYO:"YOYOW"},precisionMode:o.kb,options:{sandboxMode:!1,fetchMarkets:["spot","linear","inverse"],fetchCurrencies:!0,defaultTimeInForce:"GTC",defaultType:"spot",defaultSubType:void 0,hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,throwMarginModeAlreadySet:!1,fetchPositions:"positionRisk",recvWindow:1e4,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!0,broker:{spot:"x-R4BD3S82",margin:"x-R4BD3S82",future:"x-xcKtGhcu",delivery:"x-xcKtGhcu",swap:"x-xcKtGhcu",option:"x-xcKtGhcu"},accountsByType:{main:"MAIN",spot:"MAIN",funding:"FUNDING",margin:"MARGIN",cross:"MARGIN",future:"UMFUTURE",delivery:"CMFUTURE",linear:"UMFUTURE",swap:"UMFUTURE",inverse:"CMFUTURE",option:"OPTION"},accountsById:{MAIN:"spot",FUNDING:"funding",MARGIN:"margin",UMFUTURE:"linear",CMFUTURE:"inverse",OPTION:"option"},networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},networksById:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0},legalMoneyCurrenciesById:{BUSD:"USD"}},exceptions:{spot:{exact:{"-1004":r.OperationFailed,"-1008":r.OperationFailed,"-1099":r.AuthenticationError,"-1108":r.BadRequest,"-1131":r.BadRequest,"-1134":r.BadRequest,"-1135":r.BadRequest,"-1145":r.BadRequest,"-1151":r.BadSymbol,"-2008":r.AuthenticationError,"-2016":r.OperationRejected,"-2021":r.BadResponse,"-2022":r.BadResponse,"-2026":r.InvalidOrder,"-3000":r.OperationFailed,"-3001":r.AuthenticationError,"-3002":r.BadSymbol,"-3003":r.BadRequest,"-3004":r.OperationRejected,"-3005":r.BadRequest,"-3006":r.BadRequest,"-3007":r.OperationFailed,"-3008":r.BadRequest,"-3009":r.OperationRejected,"-3010":r.BadRequest,"-3011":r.BadRequest,"-3012":r.OperationRejected,"-3013":r.BadRequest,"-3014":r.AccountSuspended,"-3015":r.BadRequest,"-3016":r.BadRequest,"-3017":r.OperationRejected,"-3018":r.AccountSuspended,"-3019":r.AccountSuspended,"-3020":r.BadRequest,"-3021":r.BadRequest,"-3022":r.AccountSuspended,"-3023":r.OperationRejected,"-3024":r.OperationRejected,"-3025":r.BadRequest,"-3026":r.BadRequest,"-3027":r.BadSymbol,"-3028":r.BadSymbol,"-3029":r.OperationFailed,"-3036":r.AccountSuspended,"-3037":r.OperationFailed,"-3038":r.BadRequest,"-3041":r.InsufficientFunds,"-3042":r.BadRequest,"-3043":r.PermissionDenied,"-3044":r.OperationFailed,"-3045":r.OperationRejected,"-3999":r.PermissionDenied,"-4000":r.ExchangeError,"-4001":r.BadRequest,"-4002":r.BadRequest,"-4003":r.BadRequest,"-4004":r.AuthenticationError,"-4005":r.RateLimitExceeded,"-4006":r.BadRequest,"-4007":r.PermissionDenied,"-4008":r.PermissionDenied,"-4009":r.ExchangeError,"-4010":r.PermissionDenied,"-4011":r.BadRequest,"-4012":r.PermissionDenied,"-4013":r.AuthenticationError,"-4014":r.OperationRejected,"-4015":r.PermissionDenied,"-4016":r.PermissionDenied,"-4017":r.PermissionDenied,"-4018":r.BadSymbol,"-4019":r.BadRequest,"-4020":r.ExchangeError,"-4021":r.BadRequest,"-4022":r.BadRequest,"-4023":r.OperationRejected,"-4024":r.InsufficientFunds,"-4025":r.InsufficientFunds,"-4026":r.InsufficientFunds,"-4027":r.OperationFailed,"-4028":r.BadRequest,"-4029":r.BadRequest,"-4030":r.BadResponse,"-4031":r.OperationFailed,"-4032":r.OperationRejected,"-4033":r.BadRequest,"-4034":r.OperationRejected,"-4035":r.PermissionDenied,"-4036":r.PermissionDenied,"-4037":r.OperationFailed,"-4038":r.OperationFailed,"-4039":r.PermissionDenied,"-4040":r.OperationRejected,"-4041":r.OperationFailed,"-4042":r.OperationRejected,"-4043":r.OperationRejected,"-4044":r.PermissionDenied,"-4045":r.OperationFailed,"-4046":r.AuthenticationError,"-4047":r.BadRequest,"-4048":r.ExchangeError,"-4049":r.ExchangeError,"-4050":r.ExchangeError,"-4051":r.ExchangeError,"-4052":r.ExchangeError,"-4053":r.ExchangeError,"-4054":r.ExchangeError,"-4055":r.ExchangeError,"-4056":r.ExchangeError,"-4057":r.ExchangeError,"-4058":r.ExchangeError,"-4059":r.ExchangeError,"-4060":r.OperationFailed,"-4061":r.ExchangeError,"-4062":r.ExchangeError,"-4063":r.ExchangeError,"-4064":r.ExchangeError,"-4065":r.ExchangeError,"-4066":r.ExchangeError,"-4067":r.ExchangeError,"-4068":r.ExchangeError,"-4069":r.ExchangeError,"-4070":r.ExchangeError,"-4071":r.ExchangeError,"-4072":r.ExchangeError,"-4073":r.ExchangeError,"-4074":r.ExchangeError,"-4075":r.ExchangeError,"-4076":r.ExchangeError,"-4077":r.ExchangeError,"-4078":r.ExchangeError,"-4079":r.ExchangeError,"-4080":r.ExchangeError,"-4081":r.ExchangeError,"-4082":r.ExchangeError,"-4083":r.ExchangeError,"-4084":r.ExchangeError,"-4085":r.ExchangeError,"-4086":r.ExchangeError,"-4087":r.ExchangeError,"-4088":r.ExchangeError,"-4089":r.ExchangeError,"-4091":r.ExchangeError,"-4092":r.ExchangeError,"-4093":r.ExchangeError,"-4094":r.ExchangeError,"-4095":r.ExchangeError,"-4096":r.ExchangeError,"-4097":r.ExchangeError,"-4098":r.ExchangeError,"-4099":r.ExchangeError,"-4101":r.ExchangeError,"-4102":r.ExchangeError,"-4103":r.ExchangeError,"-4104":r.ExchangeError,"-4105":r.ExchangeError,"-4106":r.ExchangeError,"-4107":r.ExchangeError,"-4108":r.ExchangeError,"-4109":r.ExchangeError,"-4110":r.ExchangeError,"-4112":r.ExchangeError,"-4113":r.ExchangeError,"-4114":r.ExchangeError,"-4115":r.ExchangeError,"-4116":r.ExchangeError,"-4117":r.ExchangeError,"-4118":r.ExchangeError,"-4119":r.ExchangeError,"-4120":r.ExchangeError,"-4121":r.ExchangeError,"-4122":r.ExchangeError,"-4123":r.ExchangeError,"-4124":r.ExchangeError,"-4125":r.ExchangeError,"-4126":r.ExchangeError,"-4127":r.ExchangeError,"-4128":r.ExchangeError,"-4129":r.ExchangeError,"-4130":r.ExchangeError,"-4131":r.ExchangeError,"-4132":r.ExchangeError,"-4133":r.ExchangeError,"-4134":r.ExchangeError,"-4135":r.ExchangeError,"-4136":r.ExchangeError,"-4137":r.ExchangeError,"-4138":r.ExchangeError,"-4139":r.ExchangeError,"-4141":r.ExchangeError,"-4142":r.ExchangeError,"-4143":r.ExchangeError,"-4144":r.ExchangeError,"-4145":r.ExchangeError,"-4146":r.ExchangeError,"-4147":r.ExchangeError,"-4148":r.ExchangeError,"-4149":r.ExchangeError,"-4150":r.ExchangeError,"-5001":r.BadRequest,"-5002":r.InsufficientFunds,"-5003":r.InsufficientFunds,"-5004":r.OperationRejected,"-5005":r.OperationRejected,"-5006":r.OperationRejected,"-5007":r.BadRequest,"-5008":r.OperationRejected,"-5009":r.BadSymbol,"-5010":r.OperationFailed,"-5011":r.BadRequest,"-5012":r.OperationFailed,"-5013":r.InsufficientFunds,"-5021":r.BadRequest,"-5022":r.BadRequest,"-6001":r.BadSymbol,"-6003":r.PermissionDenied,"-6004":r.BadRequest,"-6005":r.BadRequest,"-6006":r.BadRequest,"-6007":r.OperationRejected,"-6008":r.OperationRejected,"-6009":r.RateLimitExceeded,"-6011":r.OperationRejected,"-6012":r.InsufficientFunds,"-6013":r.BadResponse,"-6014":r.OperationRejected,"-6015":r.BadRequest,"-6016":r.BadRequest,"-6017":r.PermissionDenied,"-6018":r.InsufficientFunds,"-6019":r.OperationRejected,"-6020":r.BadRequest,"-7001":r.BadRequest,"-7002":r.BadRequest,"-10001":r.OperationFailed,"-10002":r.BadRequest,"-10005":r.BadResponse,"-10007":r.BadRequest,"-10008":r.BadRequest,"-10009":r.BadRequest,"-10010":r.BadRequest,"-10011":r.InsufficientFunds,"-10012":r.BadRequest,"-10013":r.InsufficientFunds,"-10015":r.OperationFailed,"-10016":r.OperationFailed,"-10017":r.OperationRejected,"-10018":r.BadRequest,"-10019":r.BadRequest,"-10020":r.BadRequest,"-10021":r.InvalidOrder,"-10022":r.BadRequest,"-10023":r.OperationFailed,"-10024":r.BadRequest,"-10025":r.OperationFailed,"-10026":r.BadRequest,"-10028":r.BadRequest,"-10029":r.OperationRejected,"-10030":r.OperationRejected,"-10031":r.OperationRejected,"-10032":r.OperationFailed,"-10034":r.OperationRejected,"-10039":r.OperationRejected,"-10040":r.OperationRejected,"-10041":r.OperationFailed,"-10042":r.BadSymbol,"-10043":r.OperationRejected,"-10044":r.OperationRejected,"-10045":r.OperationRejected,"-10046":r.OperationRejected,"-10047":r.PermissionDenied,"-11008":r.OperationRejected,"-12014":r.RateLimitExceeded,"-13000":r.OperationRejected,"-13001":r.OperationRejected,"-13002":r.OperationRejected,"-13003":r.PermissionDenied,"-13004":r.OperationRejected,"-13005":r.OperationRejected,"-13006":r.OperationRejected,"-13007":r.PermissionDenied,"-18002":r.OperationRejected,"-18003":r.OperationRejected,"-18004":r.OperationRejected,"-18005":r.PermissionDenied,"-18006":r.OperationRejected,"-18007":r.OperationRejected,"-21001":r.BadRequest,"-21002":r.BadRequest,"-21003":r.BadResponse,"-21004":r.OperationRejected,"-21005":r.InsufficientFunds,"-21006":r.OperationFailed,"-21007":r.OperationFailed,"-32603":r.BadRequest,400002:r.BadRequest,100001003:r.AuthenticationError,200003903:r.AuthenticationError}},linear:{exact:{"-1005":r.PermissionDenied,"-1008":r.OperationFailed,"-1011":r.PermissionDenied,"-1023":r.BadRequest,"-1099":r.AuthenticationError,"-1109":r.PermissionDenied,"-1110":r.BadRequest,"-1113":r.BadRequest,"-1122":r.BadRequest,"-1126":r.BadSymbol,"-1136":r.BadRequest,"-2012":r.OperationFailed,"-2016":r.OperationRejected,"-2017":r.PermissionDenied,"-2018":r.InsufficientFunds,"-2019":r.InsufficientFunds,"-2020":r.OperationFailed,"-2021":r.OrderImmediatelyFillable,"-2022":r.InvalidOrder,"-2023":r.OperationFailed,"-2024":r.InsufficientFunds,"-2025":r.OperationRejected,"-2026":r.InvalidOrder,"-2027":r.OperationRejected,"-2028":r.OperationRejected,"-4063":r.BadRequest,"-4064":r.BadRequest,"-4065":r.BadRequest,"-4066":r.BadRequest,"-4069":r.BadRequest,"-4070":r.BadRequest,"-4071":r.BadRequest,"-4072":r.OperationRejected,"-4073":r.BadRequest,"-4074":r.OperationRejected,"-4075":r.BadRequest,"-4076":r.OperationRejected,"-4077":r.OperationRejected,"-4078":r.OperationFailed,"-4079":r.BadRequest,"-4080":r.PermissionDenied,"-4081":r.BadRequest,"-4085":r.BadRequest,"-4087":r.PermissionDenied,"-4088":r.PermissionDenied,"-4114":r.BadRequest,"-4115":r.BadRequest,"-4118":r.OperationRejected,"-4131":r.OperationRejected,"-4140":r.BadRequest,"-4141":r.OperationRejected,"-4144":r.BadSymbol,"-4164":r.InvalidOrder,"-4165":r.BadRequest,"-4167":r.BadRequest,"-4168":r.BadRequest,"-4169":r.OperationRejected,"-4170":r.OperationRejected,"-4171":r.OperationRejected,"-4172":r.OperationRejected,"-4183":r.BadRequest,"-4184":r.BadRequest,"-4192":r.PermissionDenied,"-4202":r.PermissionDenied,"-4203":r.PermissionDenied,"-4205":r.PermissionDenied,"-4206":r.PermissionDenied,"-4208":r.OperationRejected,"-4209":r.OperationRejected,"-4210":r.BadRequest,"-4211":r.BadRequest,"-4400":r.PermissionDenied,"-4401":r.PermissionDenied,"-4402":r.PermissionDenied,"-4403":r.PermissionDenied,"-5021":r.OrderNotFillable,"-5022":r.OrderNotFillable,"-5024":r.OperationRejected,"-5025":r.OperationRejected,"-5026":r.OperationRejected,"-5027":r.OperationRejected,"-5028":r.BadRequest,"-5037":r.BadRequest,"-5038":r.BadRequest,"-5039":r.BadRequest,"-5040":r.BadRequest,"-5041":r.OperationFailed}},inverse:{exact:{"-1005":r.PermissionDenied,"-1011":r.PermissionDenied,"-1023":r.BadRequest,"-1109":r.AuthenticationError,"-1110":r.BadSymbol,"-1113":r.BadRequest,"-1128":r.BadRequest,"-1136":r.BadRequest,"-2016":r.OperationRejected,"-2018":r.InsufficientFunds,"-2019":r.InsufficientFunds,"-2020":r.OperationFailed,"-2021":r.OrderImmediatelyFillable,"-2022":r.InvalidOrder,"-2023":r.OperationFailed,"-2024":r.BadRequest,"-2025":r.OperationRejected,"-2026":r.InvalidOrder,"-2027":r.OperationRejected,"-2028":r.OperationRejected,"-4086":r.BadRequest,"-4087":r.BadSymbol,"-4088":r.BadRequest,"-4089":r.PermissionDenied,"-4090":r.PermissionDenied,"-4110":r.BadRequest,"-4111":r.BadRequest,"-4112":r.OperationRejected,"-4113":r.OperationRejected,"-4150":r.OperationRejected,"-4151":r.BadRequest,"-4152":r.BadRequest,"-4154":r.BadRequest,"-4155":r.BadRequest,"-4178":r.BadRequest,"-4188":r.BadRequest,"-4192":r.PermissionDenied,"-4194":r.PermissionDenied,"-4195":r.PermissionDenied,"-4196":r.BadRequest,"-4197":r.OperationRejected,"-4198":r.OperationRejected,"-4199":r.BadRequest,"-4200":r.PermissionDenied,"-4201":r.PermissionDenied,"-4202":r.OperationRejected}},option:{exact:{"-1003":r.ExchangeError,"-1004":r.ExchangeError,"-1006":r.ExchangeError,"-1007":r.ExchangeError,"-1008":r.RateLimitExceeded,"-1010":r.ExchangeError,"-1013":r.ExchangeError,"-1108":r.ExchangeError,"-1112":r.ExchangeError,"-1114":r.ExchangeError,"-1128":r.BadSymbol,"-1129":r.BadSymbol,"-1131":r.BadRequest,"-2011":r.ExchangeError,"-2018":r.InsufficientFunds,"-2027":r.InsufficientFunds,"-3029":r.OperationFailed,"-4006":r.ExchangeError,"-4007":r.ExchangeError,"-4008":r.ExchangeError,"-4009":r.ExchangeError,"-4010":r.ExchangeError,"-4011":r.ExchangeError,"-4012":r.ExchangeError,"-4014":r.ExchangeError,"-4015":r.ExchangeError,"-4016":r.ExchangeError,"-4017":r.ExchangeError,"-4018":r.ExchangeError,"-4019":r.ExchangeError,"-4020":r.ExchangeError,"-4021":r.ExchangeError,"-4022":r.ExchangeError,"-4023":r.ExchangeError,"-4024":r.ExchangeError,"-4025":r.ExchangeError,"-4026":r.ExchangeError,"-4027":r.ExchangeError,"-4028":r.ExchangeError,"-4031":r.ExchangeError,"-4032":r.ExchangeError,"-4033":r.ExchangeError,"-4034":r.ExchangeError,"-4035":r.ExchangeError,"-4036":r.ExchangeError,"-4037":r.ExchangeError,"-4038":r.ExchangeError,"-4039":r.ExchangeError,"-4040":r.ExchangeError,"-4041":r.ExchangeError,"-4042":r.ExchangeError,"-4043":r.ExchangeError,"-4044":r.ExchangeError,"-4045":r.ExchangeError,"-4046":r.ExchangeError,"-4047":r.ExchangeError,"-4048":r.ExchangeError,"-4049":r.ExchangeError,"-4050":r.ExchangeError,"-4051":r.ExchangeError,"-4052":r.ExchangeError,"-4053":r.ExchangeError,"-4054":r.ExchangeError,"-4056":r.ExchangeError,"-4057":r.ExchangeError,"-4058":r.ExchangeError,"-4059":r.ExchangeError,"-4060":r.ExchangeError,"-4061":r.ExchangeError,"-4062":r.ExchangeError,"-4063":r.ExchangeError,"-4064":r.ExchangeError,"-4065":r.ExchangeError,"-4066":r.ExchangeError,"-4067":r.ExchangeError,"-4068":r.ExchangeError,"-4069":r.ExchangeError,"-4070":r.ExchangeError,"-4071":r.ExchangeError,"-4072":r.ExchangeError,"-4073":r.ExchangeError,"-4074":r.ExchangeError,"-4075":r.ExchangeError,"-4076":r.ExchangeError,"-4077":r.ExchangeError,"-4078":r.ExchangeError,"-4079":r.ExchangeError,"-4080":r.ExchangeError,"-4081":r.ExchangeError,"-4082":r.ExchangeError,"-4083":r.ExchangeError,"-4084":r.ExchangeError,"-4085":r.ExchangeError,"-4086":r.ExchangeError,"-4087":r.ExchangeError,"-4088":r.ExchangeError,"-4089":r.ExchangeError,"-4091":r.ExchangeError,"-4092":r.ExchangeError,"-4093":r.ExchangeError,"-4094":r.ExchangeError,"-4095":r.ExchangeError,"-4096":r.ExchangeError,"-4097":r.ExchangeError,"-4098":r.ExchangeError,"-4099":r.ExchangeError,"-4101":r.ExchangeError,"-4102":r.ExchangeError,"-4103":r.ExchangeError,"-4104":r.ExchangeError,"-4105":r.ExchangeError,"-4106":r.ExchangeError,"-4107":r.ExchangeError,"-4108":r.ExchangeError,"-4109":r.ExchangeError,"-4110":r.ExchangeError,"-4112":r.ExchangeError,"-4113":r.ExchangeError,"-4114":r.ExchangeError,"-4115":r.ExchangeError,"-4116":r.ExchangeError,"-4117":r.ExchangeError,"-4118":r.ExchangeError,"-4119":r.ExchangeError,"-4120":r.ExchangeError,"-4121":r.ExchangeError,"-4122":r.ExchangeError,"-4123":r.ExchangeError,"-4124":r.ExchangeError,"-4125":r.ExchangeError,"-4126":r.ExchangeError,"-4127":r.ExchangeError,"-4128":r.ExchangeError,"-4129":r.ExchangeError,"-4130":r.ExchangeError,"-4131":r.ExchangeError,"-4132":r.ExchangeError,"-4133":r.ExchangeError,"-4134":r.ExchangeError,"-4135":r.ExchangeError,"-4136":r.ExchangeError,"-4137":r.ExchangeError,"-4138":r.ExchangeError,"-4139":r.ExchangeError,"-4141":r.ExchangeError,"-4142":r.ExchangeError,"-4143":r.ExchangeError,"-4144":r.ExchangeError,"-4145":r.ExchangeError,"-4146":r.ExchangeError,"-4147":r.ExchangeError,"-4148":r.ExchangeError,"-4149":r.ExchangeError,"-4150":r.ExchangeError,"-20121":r.ExchangeError,"-20124":r.ExchangeError,"-20130":r.ExchangeError,"-20132":r.ExchangeError,"-20194":r.ExchangeError,"-20195":r.ExchangeError,"-20196":r.ExchangeError,"-20198":r.ExchangeError,"-20204":r.ExchangeError}},portfolioMargin:{exact:{"-1005":r.PermissionDenied,"-1011":r.PermissionDenied,"-1023":r.BadRequest,"-1109":r.BadRequest,"-1110":r.BadSymbol,"-1113":r.BadRequest,"-1128":r.BadRequest,"-1136":r.BadRequest,"-2016":r.OperationRejected,"-2018":r.InsufficientFunds,"-2019":r.InsufficientFunds,"-2020":r.OrderNotFillable,"-2021":r.OrderImmediatelyFillable,"-2022":r.InvalidOrder,"-2023":r.OperationFailed,"-2024":r.OperationRejected,"-2025":r.OperationRejected,"-2026":r.InvalidOrder,"-2027":r.OperationRejected,"-2028":r.OperationRejected,"-4063":r.BadRequest,"-4064":r.BadRequest,"-4065":r.BadRequest,"-4066":r.BadRequest,"-4069":r.BadRequest,"-4070":r.BadRequest,"-4071":r.BadRequest,"-4072":r.OperationRejected,"-4073":r.BadRequest,"-4074":r.BadRequest,"-4075":r.BadRequest,"-4076":r.OperationRejected,"-4077":r.OperationRejected,"-4078":r.OperationFailed,"-4079":r.BadRequest,"-4080":r.PermissionDenied,"-4081":r.BadRequest,"-4085":r.BadRequest,"-4086":r.BadRequest,"-4087":r.PermissionDenied,"-4088":r.PermissionDenied,"-4114":r.BadRequest,"-4115":r.BadRequest,"-4118":r.OperationRejected,"-4131":r.OperationRejected,"-4140":r.BadRequest,"-4141":r.BadRequest,"-4144":r.BadSymbol,"-4161":r.OperationRejected,"-4164":r.OperationRejected,"-4165":r.BadRequest,"-4183":r.BadRequest,"-4184":r.BadRequest,"-5021":r.OrderNotFillable,"-5022":r.OrderNotFillable,"-20121":r.ExchangeError,"-20124":r.ExchangeError,"-20130":r.ExchangeError,"-20132":r.ExchangeError,"-20194":r.ExchangeError,"-20195":r.ExchangeError,"-20196":r.ExchangeError,"-20198":r.ExchangeError,"-20204":r.ExchangeError,"-21001":r.BadRequest,"-21002":r.BadRequest,"-21003":r.BadResponse,"-21004":r.OperationRejected,"-21005":r.InsufficientFunds,"-21006":r.OperationFailed,"-21007":r.OperationFailed}},exact:{"-1000":r.OperationFailed,"-1001":r.OperationFailed,"-1002":r.AuthenticationError,"-1003":r.RateLimitExceeded,"-1004":r.OperationRejected,"-1006":r.OperationFailed,"-1007":r.RequestTimeout,"-1010":r.OperationFailed,"-1013":r.BadRequest,"-1014":r.InvalidOrder,"-1015":r.RateLimitExceeded,"-1016":r.BadRequest,"-1020":r.BadRequest,"-1021":r.InvalidNonce,"-1022":r.AuthenticationError,"-1100":r.BadRequest,"-1101":r.BadRequest,"-1102":r.BadRequest,"-1103":r.BadRequest,"-1104":r.BadRequest,"-1105":r.BadRequest,"-1106":r.BadRequest,"-1108":r.BadSymbol,"-1111":r.BadRequest,"-1112":r.OperationFailed,"-1114":r.BadRequest,"-1115":r.BadRequest,"-1116":r.BadRequest,"-1117":r.BadRequest,"-1118":r.BadRequest,"-1119":r.BadRequest,"-1120":r.BadRequest,"-1121":r.BadSymbol,"-1125":r.AuthenticationError,"-1127":r.BadRequest,"-1128":r.BadRequest,"-1130":r.BadRequest,"-2010":r.InvalidOrder,"-2011":r.OrderNotFound,"-2013":r.OrderNotFound,"-2014":r.AuthenticationError,"-2015":r.AuthenticationError,"-4000":r.InvalidOrder,"-4001":r.BadRequest,"-4002":r.BadRequest,"-4003":r.BadRequest,"-4004":r.BadRequest,"-4005":r.BadRequest,"-4006":r.BadRequest,"-4007":r.BadRequest,"-4008":r.BadRequest,"-4009":r.BadRequest,"-4010":r.BadRequest,"-4011":r.BadRequest,"-4012":r.BadRequest,"-4013":r.BadRequest,"-4014":r.BadRequest,"-4015":r.BadRequest,"-4016":r.BadRequest,"-4017":r.BadRequest,"-4018":r.BadRequest,"-4019":r.OperationRejected,"-4020":r.BadRequest,"-4021":r.BadRequest,"-4022":r.BadRequest,"-4023":r.BadRequest,"-4024":r.BadRequest,"-4025":r.BadRequest,"-4026":r.BadRequest,"-4027":r.BadRequest,"-4028":r.BadRequest,"-4029":r.BadRequest,"-4030":r.BadRequest,"-4031":r.BadRequest,"-4032":r.OperationRejected,"-4033":r.BadRequest,"-4044":r.BadRequest,"-4045":r.OperationRejected,"-4046":r.OperationRejected,"-4047":r.OperationRejected,"-4048":r.OperationRejected,"-4049":r.BadRequest,"-4050":r.InsufficientFunds,"-4051":r.InsufficientFunds,"-4052":r.OperationRejected,"-4053":r.BadRequest,"-4054":r.OperationRejected,"-4055":r.BadRequest,"-4056":r.AuthenticationError,"-4057":r.AuthenticationError,"-4058":r.BadRequest,"-4059":r.OperationRejected,"-4060":r.BadRequest,"-4061":r.OperationRejected,"-4062":r.BadRequest,"-4067":r.OperationRejected,"-4068":r.OperationRejected,"-4082":r.BadRequest,"-4083":r.OperationRejected,"-4084":r.BadRequest,"-4086":r.BadRequest,"-4104":r.BadRequest,"-4135":r.BadRequest,"-4137":r.BadRequest,"-4138":r.BadRequest,"-4139":r.BadRequest,"-4142":r.OrderImmediatelyFillable,"-20121":r.BadSymbol,"-20124":r.BadRequest,"-20130":r.BadRequest,"-20132":r.BadRequest,"-20194":r.BadRequest,"-20195":r.BadRequest,"-20196":r.BadRequest,"-20198":r.OperationRejected,"-20204":r.BadRequest,"System is under maintenance.":r.OnMaintenance,"System abnormality":r.OperationFailed,"You are not authorized to execute this request.":r.PermissionDenied,"API key does not exist":r.AuthenticationError,"Order would trigger immediately.":r.OrderImmediatelyFillable,"Stop price would trigger immediately.":r.OrderImmediatelyFillable,"Order would immediately match and take.":r.OrderImmediatelyFillable,"Account has insufficient balance for requested action.":r.InsufficientFunds,"Rest API trading is not enabled.":r.PermissionDenied,"This account may not place or cancel orders.":r.PermissionDenied,"You don't have permission.":r.PermissionDenied,"Market is closed.":r.MarketClosed,"Too many requests. Please try again later.":r.RateLimitExceeded,"This action is disabled on this account.":r.AccountSuspended,"Limit orders require GTC for this phase.":r.BadRequest,"This order type is not possible in this trading phase.":r.BadRequest,"This type of sub-account exceeds the maximum number limit":r.OperationRejected,"This symbol is restricted for this account.":r.PermissionDenied,"This symbol is not permitted for this account.":r.PermissionDenied},broad:{"has no operation privilege":r.PermissionDenied,MAX_POSITION:r.BadRequest}}})}isInverse(e,t=void 0){return void 0===t?"delivery"===e:"inverse"===t}isLinear(e,t=void 0){return void 0===t?"future"===e||"swap"===e:"linear"===t}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}createExpiredOptionMarket(e){const t="USDT",s=e.split("-"),i=e.split("/");let r;r=e.indexOf("/")>-1?this.safeString(i,0):this.safeString(s,0);const a=this.safeString(s,1),o=this.safeInteger(s,2),n=this.safeString(s,2),d=this.safeString(s,3),h=this.convertExpireDate(a);return{id:r+"-"+a+"-"+n+"-"+d,symbol:r+"/"+t+":"+t+"-"+a+"-"+n+"-"+d,base:r,quote:t,baseId:r,quoteId:t,active:void 0,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:void 0,expiry:this.parse8601(h),expiryDatetime:h,optionType:"C"===d?"call":"put",strike:o,settle:t,settleId:t,precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}market(e){if(void 0===this.markets)throw new r.ExchangeError(this.id+" markets not loaded");let t=this.safeString(this.options,"defaultType");const s=this.safeString(this.options,"defaultSubType"),i="future"===t,a="delivery"===t,o=i||a;if("string"==typeof e)if(e in this.markets){const t=this.markets[e];if(!o||!t.spot)return t;{const s=e+":"+(i?t.quote:t.base);if(s in this.markets)return this.markets[s]}}else{if(e in this.markets_by_id){const r=this.markets_by_id[e];i?t="linear":a?t="inverse":void 0===t&&(t=s);for(let e=0;e<r.length;e++){const s=r[e];if(s[t])return s}return r[0]}if(e.indexOf("/")>-1&&e.indexOf(":")<0){const[t,s]=e.split("/"),i=e+":"+("USD"===s?t:s);if(i in this.markets)return this.markets[i]}else if(e.indexOf("-C")>-1||e.indexOf("-P")>-1)return this.createExpiredOptionMarket(e)}throw new r.BadSymbol(this.id+" does not have market symbol "+e)}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.indexOf("-C")>-1||e.indexOf("-P")>-1)&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}costToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.quote,this.precisionMode,this.paddingMode)}currencyToPrecision(e,t,s=void 0){return void 0!==this.safeValue(this.currencies[e],"precision")?this.decimalToPrecision(t,o.R3,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=this.safeString2(this.options,"fetchTime","defaultType","spot"),s=this.safeString(e,"type",t),i=this.omit(e,"type");let r,a;return[r,e]=this.handleSubTypeAndParams("fetchTime",void 0,e),a=this.isLinear(s,r)?await this.fapiPublicGetTime(i):this.isInverse(s,r)?await this.dapiPublicGetTime(i):await this.publicGetTime(i),this.safeInteger(a,"serverTime")}async fetchCurrencies(e={}){if(!this.safeBool(this.options,"fetchCurrencies"))return;if(!this.checkRequiredCredentials(!1))return;if(void 0!==this.safeValue(this.urls,"apiBackup"))return;const t=await this.sapiGetCapitalConfigGetall(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"coin"),o=this.safeString(i,"name"),n=this.safeCurrencyCode(r);let d,h=!0,c=!0;const l=this.safeList(i,"networkList",[]),u={};let p;const f={};for(let e=0;e<l.length;e++){const t=l[e],s=this.safeString(t,"network"),i=this.networkIdToCode(s),r=this.safeNumber(t,"withdrawFee"),o=this.safeBool(t,"depositEnable"),n=this.safeBool(t,"withdrawEnable");c=c||o,h=h||n,u[s]=r;(this.safeBool(t,"isDefault")||void 0===p)&&(p=r);const m=this.safeString(t,"withdrawIntegerMultiple");a.Y.stringEq(m,"0")||(d=void 0===d?m:a.Y.stringMin(d,m)),f[i]={info:t,id:s,network:i,active:o&&n,deposit:o,withdraw:n,fee:r,precision:this.parseNumber(m),limits:{withdraw:{min:this.safeNumber(t,"withdrawMin"),max:this.safeNumber(t,"withdrawMax")},deposit:{min:this.safeNumber(t,"depositDust"),max:void 0}}}}const m=this.safeBool(i,"trading"),g=h&&c&&m;s[n]={id:r,name:o,code:n,precision:this.parseNumber(d),info:i,active:g,deposit:c,withdraw:h,networks:f,fee:p,fees:u,limits:this.limits}}return s}async fetchMarkets(e={}){const t=[],s=this.safeList(this.options,"fetchMarkets",["spot","linear","inverse"]),i=this.safeBool(this.options,"sandboxMode",!1),a=[];for(let e=0;e<s.length;e++){const t=s[e];"option"===t&&i||a.push(t)}for(let s=0;s<a.length;s++){const i=a[s];if("spot"===i)t.push(this.publicGetExchangeInfo(e));else if("linear"===i)t.push(this.fapiPublicGetExchangeInfo(e));else if("inverse"===i)t.push(this.dapiPublicGetExchangeInfo(e));else{if("option"!==i)throw new r.ExchangeError(this.id+' fetchMarkets() this.options fetchMarkets "'+i+'" is not a supported market type');t.push(this.eapiPublicGetExchangeInfo(e))}}const o=await Promise.all(t);let n=[];for(let e=0;e<a.length;e++){const t=this.safeDict(o,e),s=this.safeList2(t,"symbols","optionSymbols",[]);n=this.arrayConcat(n,s)}this.options.adjustForTimeDifference&&await this.loadTimeDifference();const d=[];for(let e=0;e<n.length;e++)d.push(this.parseMarket(n[e]));return d}parseMarket(e){let t=!1,s=!1,i=!1;const r=this.safeString(e,"underlying"),a=this.safeString(e,"symbol"),o=a.split("-"),n=this.safeString(o,0),d=this.safeStringLower(e,"symbol"),h=this.safeString(e,"baseAsset",n),c=this.safeString(e,"quoteAsset"),l=this.safeCurrencyCode(h),u=this.safeCurrencyCode(c),p=this.safeString(e,"contractType");let f="contractType"in e,m=this.safeInteger2(e,"deliveryDate","expiryDate"),g=this.safeString(e,"marginAsset");"PERPETUAL"===p||41334048e5===m?(m=void 0,t=!0):void 0!==r?(f=!0,i=!0,g=void 0===g?"USDT":g):void 0!==m&&(s=!0);const v=this.safeCurrencyCode(g),y=!f,w=this.safeList(e,"filters",[]),b=this.indexBy(w,"filterType"),S=this.safeString2(e,"status","contractStatus");let k,O,T,P=this.fees;const I=this.safeString(e,"strikePrice");let x=l+"/"+u;if(f){t?x=x+":"+v:s?x=x+":"+v+"-"+this.yymmdd(m):i&&(x=x+":"+v+"-"+this.yymmdd(m)+"-"+I+"-"+this.safeString(o,3)),k=this.safeNumber2(e,"contractSize","unit",this.parseNumber("1")),O=v===u,T=v===l;const r=O?"linear":"inverse";P=this.safeDict(this.fees,r,{})}let A="TRADING"===S;if(y){const t=this.safeList(e,"permissions",[]);for(let e=0;e<t.length;e++)if("TRD_GRP_003"===t[e]){A=!1;break}}const M=this.safeBool(e,"isMarginTradingAllowed",!1);let C,E;y?C="spot":t?C="swap":s?C="future":i&&(C="option",A=void 0),void 0!==I&&(E=this.parseToNumeric(I));const _={id:a,lowercaseId:d,symbol:x,base:l,quote:u,settle:v,baseId:h,quoteId:c,settleId:g,type:C,spot:y,margin:y&&M,swap:t,future:s,option:i,active:A,contract:f,linear:O,inverse:T,taker:P.trading.taker,maker:P.trading.maker,contractSize:k,expiry:m,expiryDatetime:this.iso8601(m),strike:E,optionType:this.safeStringLower(e,"side"),precision:{amount:this.parseNumber(this.parsePrecision(this.safeString2(e,"quantityPrecision","quantityScale"))),price:this.parseNumber(this.parsePrecision(this.safeString2(e,"pricePrecision","priceScale"))),base:this.parseNumber(this.parsePrecision(this.safeString(e,"baseAssetPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(e,"quotePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e,created:this.safeInteger(e,"onboardDate")};if("PRICE_FILTER"in b){const e=this.safeDict(b,"PRICE_FILTER",{});_.limits.price={min:this.safeNumber(e,"minPrice"),max:this.safeNumber(e,"maxPrice")},_.precision.price=this.safeNumber(e,"tickSize")}if("LOT_SIZE"in b){const e=this.safeDict(b,"LOT_SIZE",{});_.precision.amount=this.safeNumber(e,"stepSize"),_.limits.amount={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}if("MARKET_LOT_SIZE"in b){const e=this.safeDict(b,"MARKET_LOT_SIZE",{});_.limits.market={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}if("MIN_NOTIONAL"in b||"NOTIONAL"in b){const e=this.safeDict2(b,"MIN_NOTIONAL","NOTIONAL",{});_.limits.cost.min=this.safeNumber2(e,"minNotional","notional"),_.limits.cost.max=this.safeNumber(e,"maxNotional")}return _}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free");const s=this.safeString(e,"interest"),i=this.safeString(e,"borrowed");return t.debt=a.Y.stringAdd(i,s),t}parseBalanceCustom(e,t=void 0,s=void 0,i=!1){const r={info:e};let o;const n="isolated"===s,d="margin"===t||"cross"===s;if(i)for(let s=0;s<e.length;s++){const i=e[s],o=this.account(),n=this.safeString(i,"asset"),h=this.safeCurrencyCode(n);if("linear"===t)o.free=this.safeString(i,"umWalletBalance"),o.used=this.safeString(i,"umUnrealizedPNL");else if("inverse"===t)o.free=this.safeString(i,"cmWalletBalance"),o.used=this.safeString(i,"cmUnrealizedPNL");else if(d){const e=this.safeString(i,"crossMarginBorrowed"),t=this.safeString(i,"crossMarginInterest");o.debt=a.Y.stringAdd(e,t),o.free=this.safeString(i,"crossMarginFree"),o.used=this.safeString(i,"crossMarginLocked"),o.total=this.safeString(i,"crossMarginAsset")}else o.total=this.safeString(i,"totalWalletBalance");r[h]=o}else if(n||"spot"!==t&&!d)if(n){const t=this.safeList(e,"assets");for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString(s,"symbol"),a=this.safeSymbol(i,void 0,void 0,"spot"),o=this.safeDict(s,"baseAsset",{}),n=this.safeDict(s,"quoteAsset",{}),d=this.safeCurrencyCode(this.safeString(o,"asset")),h=this.safeCurrencyCode(this.safeString(n,"asset")),c={};c[d]=this.parseBalanceHelper(o),c[h]=this.parseBalanceHelper(n),r[a]=this.safeBalance(c)}}else if("savings"===t){const t=this.safeList(e,"positionAmountVos",[]);for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString(s,"asset"),a=this.safeCurrencyCode(i),o=this.account(),n=this.safeString(s,"amount");o.total=n,o.used=n,r[a]=o}}else if("funding"===t)for(let t=0;t<e.length;t++){const s=e[t],i=this.account(),o=this.safeString(s,"asset"),n=this.safeCurrencyCode(o);i.free=this.safeString(s,"free");const d=this.safeString(s,"freeze"),h=this.safeString(s,"withdrawing"),c=this.safeString(s,"locked");i.used=a.Y.stringAdd(d,a.Y.stringAdd(c,h)),r[n]=i}else{let t=e;Array.isArray(e)||(t=this.safeList(e,"assets",[]));for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString(s,"asset"),a=this.safeCurrencyCode(i),o=this.account();o.free=this.safeString(s,"availableBalance"),o.used=this.safeString(s,"initialMargin"),o.total=this.safeString2(s,"marginBalance","balance"),r[a]=o}}else{o=this.safeInteger(e,"updateTime");const t=this.safeList2(e,"balances","userAssets",[]);for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString(s,"asset"),o=this.safeCurrencyCode(i),n=this.account();if(n.free=this.safeString(s,"free"),n.used=this.safeString(s,"locked"),d){const e=this.safeString(s,"borrowed"),t=this.safeString(s,"interest");n.debt=a.Y.stringAdd(e,t)}r[o]=n}}return r.timestamp=o,r.datetime=this.iso8601(o),n?r:this.safeBalance(r)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot");let s,i,r,a,o,n=this.safeString(e,"type",t);[s,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e),[i,e]=this.handleOptionAndParams2(e,"fetchBalance","papi","portfolioMargin",!1),[r,a]=this.handleMarginModeAndParams("fetchBalance",e),a=this.omit(a,"type");const d={};if(i||"papi"===n)this.isLinear(n,s)?n="linear":this.isInverse(n,s)&&(n="inverse"),i=!0,o=await this.papiGetBalance(this.extend(d,a));else if(this.isLinear(n,s)){let t;n="linear",[t,e]=this.handleOptionAndParams(e,"fetchBalance","useV2",!1),e=this.extend(d,a),o=t?await this.fapiPrivateV2GetAccount(e):await this.fapiPrivateV3GetAccount(e)}else if(this.isInverse(n,s))n="inverse",o=await this.dapiPrivateGetAccount(this.extend(d,a));else if("isolated"===r){const t=this.safeList(e,"symbols");if(a=this.omit(a,"symbols"),void 0!==t){let e="";if(Array.isArray(t)){e=this.marketId(t[0]);for(let s=1;s<t.length;s++){const i=t[s];e+=","+this.marketId(i)}}else e=t;d.symbols=e}o=await this.sapiGetMarginIsolatedAccount(this.extend(d,a))}else o="margin"===n||"cross"===r?await this.sapiGetMarginAccount(this.extend(d,a)):"savings"===n?await this.sapiGetLendingUnionAccount(this.extend(d,a)):"funding"===n?await this.sapiPostAssetGetFundingAsset(this.extend(d,a)):await this.privateGetAccount(this.extend(d,a));return this.parseBalanceCustom(o,n,r,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let a;void 0!==t&&(r.limit=t),a=i.option?await this.eapiPublicGetDepth(this.extend(r,s)):i.linear?await this.fapiPublicGetDepth(this.extend(r,s)):i.inverse?await this.dapiPublicGetDepth(this.extend(r,s)):await this.publicGetDepth(this.extend(r,s));const o=this.safeInteger(a,"T"),n=this.parseOrderBook(a,e,o);return n.nonce=this.safeInteger2(a,"lastUpdateId","u"),n}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime");let i;"time"in e&&(i="contract"),void 0===i&&(i="bidQty"in e?"spot":"contract");const r=this.safeString(e,"symbol"),o=this.safeSymbol(r,t,void 0,i),n=this.safeString(e,"lastPrice"),d=this.safeString(e,"weightedAvgPrice");let h,c;return"baseVolume"in e?(h=this.safeString(e,"baseVolume"),c=a.Y.stringMul(h,d)):(h=this.safeString(e,"volume"),c=this.safeString2(e,"quoteVolume","amount")),this.safeTicker({symbol:o,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(e,"highPrice","high"),low:this.safeString2(e,"lowPrice","low"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:d,open:this.safeString2(e,"openPrice","open"),close:n,last:n,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchStatus(e={}){const t=await this.sapiGetSystemStatus(e),s=this.safeString(t,"status");return{status:this.safeString({0:"ok",1:"maintenance"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;if(s.option)r=await this.eapiPublicGetTicker(this.extend(i,t));else if(s.linear)r=await this.fapiPublicGetTicker24hr(this.extend(i,t));else if(s.inverse)r=await this.dapiPublicGetTicker24hr(this.extend(i,t));else{const e=this.safeBool(t,"rolling",!1);t=this.omit(t,"rolling"),r=e?await this.publicGetTicker(this.extend(i,t)):await this.publicGetTicker24hr(this.extend(i,t))}if(Array.isArray(r)){const e=this.safeDict(r,0,{});return this.parseTicker(e,s)}return this.parseTicker(r,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0,!0);const s=this.getMarketFromSymbols(e);let i,a,o;if([i,t]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t),[a,t]=this.handleSubTypeAndParams("fetchBidsAsks",s,t),this.isLinear(i,a))o=await this.fapiPublicGetTickerBookTicker(t);else if(this.isInverse(i,a))o=await this.dapiPublicGetTickerBookTicker(t);else{if("spot"!==i)throw new r.NotSupported(this.id+" fetchBidsAsks() does not support "+i+" markets yet");{const s={};void 0!==e&&(s.symbols=this.json(this.marketIds(e))),o=await this.publicGetTickerBookTicker(this.extend(s,t))}}return this.parseTickers(o,e)}async fetchLastPrices(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0,!0);const s=this.getMarketFromSymbols(e);let i,a,o;if([i,t]=this.handleMarketTypeAndParams("fetchLastPrices",s,t),[a,t]=this.handleSubTypeAndParams("fetchLastPrices",s,t),this.isLinear(i,a))o=await this.fapiPublicV2GetTickerPrice(t);else if(this.isInverse(i,a))o=await this.dapiPublicGetTickerPrice(t);else{if("spot"!==i)throw new r.NotSupported(this.id+" fetchLastPrices() does not support "+i+" markets yet");o=await this.publicGetTickerPrice(t)}return this.parseLastPrices(o,e)}parseLastPrice(e,t=void 0){const s=this.safeInteger(e,"time"),i=void 0===s?"spot":"swap",r=this.safeString(e,"symbol");t=this.safeMarket(r,t,void 0,i);const a=this.safeNumber(e,"price");return{symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),price:a,side:void 0,info:e}}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0,!0);const s=this.getMarketFromSymbols(e);let i,a,o;if([i,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),[a,t]=this.handleSubTypeAndParams("fetchTickers",s,t),this.isLinear(i,a))o=await this.fapiPublicGetTicker24hr(t);else if(this.isInverse(i,a))o=await this.dapiPublicGetTicker24hr(t);else if("spot"===i){const s={};void 0!==e&&(s.symbols=this.json(this.marketIds(e))),o=await this.publicGetTicker24hr(this.extend(s,t))}else{if("option"!==i)throw new r.NotSupported(this.id+" fetchTickers() does not support "+i+" markets yet");o=await this.eapiPublicGetTicker(t)}return this.parseTickers(o,e)}parseOHLCV(e,t=void 0){const s=this.safeBool(t,"inverse")?7:5;return[this.safeInteger2(e,0,"openTime"),this.safeNumber2(e,1,"open"),this.safeNumber2(e,2,"high"),this.safeNumber2(e,3,"low"),this.safeNumber2(e,4,"close"),this.safeNumber2(e,s,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e3);const o=this.market(e),n=this.safeString(r,"price"),d=this.safeInteger(r,"until");r=this.omit(r,["price","until"]),i=void 0===i?500:Math.min(i,1500);const h={interval:this.safeString(this.timeframes,t,t),limit:i},c=o.id;if("index"===n){const e=c.split("_"),t=this.safeString(e,0);h.pair=t}else h.symbol=c;if(void 0!==s&&(h.startTime=s,o.inverse&&s>0)){const e=this.parseTimeframe(t),r=this.sum(s,i*e*1e3-1),a=this.milliseconds();h.endTime=Math.min(a,r)}let l;return void 0!==d&&(h.endTime=d),l=o.option?await this.eapiPublicGetKlines(this.extend(h,r)):"mark"===n?o.inverse?await this.dapiPublicGetMarkPriceKlines(this.extend(h,r)):await this.fapiPublicGetMarkPriceKlines(this.extend(h,r)):"index"===n?o.inverse?await this.dapiPublicGetIndexPriceKlines(this.extend(h,r)):await this.fapiPublicGetIndexPriceKlines(this.extend(h,r)):"premiumIndex"===n?o.inverse?await this.dapiPublicGetPremiumIndexKlines(this.extend(h,r)):await this.fapiPublicGetPremiumIndexKlines(this.extend(h,r)):o.linear?await this.fapiPublicGetKlines(this.extend(h,r)):o.inverse?await this.dapiPublicGetKlines(this.extend(h,r)):await this.publicGetKlines(this.extend(h,r)),this.parseOHLCVs(l,o,t,s,i)}parseTrade(e,t=void 0){if("isDustTrade"in e)return this.parseDustTrade(e,t);const s=this.safeInteger2(e,"T","time");let i=this.safeString2(e,"q","qty");i=this.safeString(e,"quantity",i);const r=this.safeString(e,"symbol"),o="isIsolated"in e||"M"in e||"orderListId"in e||"isMaker"in e?"spot":"contract",n=(t=this.safeMarket(r,t,void 0,o)).symbol;let d;const h=this.safeBool2(e,"m","isBuyerMaker");let c,l;if(void 0!==h?d=h?"sell":"buy":"side"in e?d=this.safeStringLower(e,"side"):"isBuyer"in e&&(d=e.isBuyer?"buy":"sell"),"commission"in e&&(l={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(c=e.isMaker?"maker":"taker"),"maker"in e&&(c=e.maker?"maker":"taker"),"optionSide"in e||t.option){const t=this.safeCurrencyCode(this.safeString(e,"quoteAsset","USDT"));c=this.safeStringLower(e,"liquidity"),"fee"in e&&(l={cost:this.safeString(e,"fee"),currency:t}),"buy"!==d&&"sell"!==d&&(d="1"===d?"buy":"sell"),"optionSide"in e&&"buy"!==d&&(i=a.Y.stringMul("-1",i))}return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,id:this.safeStringN(e,["t","a","tradeId","id"]),order:this.safeString(e,"orderId"),type:this.safeStringLower(e,"type"),side:d,takerOrMaker:c,price:this.safeString2(e,"p","price"),amount:i,cost:this.safeString2(e,"quoteQty","baseQty"),fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);const a=this.market(e),o={symbol:a.id};if(!a.option){void 0!==t&&(o.startTime=t,o.endTime=this.sum(t,36e5));const e=this.safeInteger(i,"until");void 0!==e&&(o.endTime=e)}if(void 0!==s){const e=a.swap||a.future;o.limit=e?Math.min(s,1e3):s}let n,d=this.safeString(this.options,"fetchTradesMethod");return d=this.safeString2(i,"fetchTradesMethod","method",d),i=this.omit(i,["until","fetchTradesMethod"]),n=a.option||"eapiPublicGetTrades"===d?await this.eapiPublicGetTrades(this.extend(o,i)):a.linear||"fapiPublicGetAggTrades"===d?await this.fapiPublicGetAggTrades(this.extend(o,i)):a.inverse||"dapiPublicGetAggTrades"===d?await this.dapiPublicGetAggTrades(this.extend(o,i)):await this.publicGetAggTrades(this.extend(o,i)),this.parseTrades(n,a,t,s)}async editSpotOrder(e,t,s,i,a,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);if(!d.spot)throw new r.NotSupported(this.id+" editSpotOrder() does not support "+d.type+" orders");const h=this.editSpotOrderRequest(e,t,s,i,a,o,n),c=await this.privatePostOrderCancelReplace(h),l=this.safeDict(c,"newOrderResponse");return this.parseOrder(l,d)}editSpotOrderRequest(e,t,s,i,n,d=void 0,h={}){const c=this.market(t),l=this.safeStringN(h,["newClientOrderId","clientOrderId","origClientOrderId"]),u={symbol:c.id,side:i.toUpperCase()},p=s.toUpperCase();let f=p;this.isPostOnly("MARKET"===p,"LIMIT_MAKER"===p,h)&&(f="LIMIT_MAKER"),u.type=f;const m=this.safeNumber2(h,"stopPrice","triggerPrice");void 0!==m&&("MARKET"===f?f="STOP_LOSS":"LIMIT"===f&&(f="STOP_LOSS_LIMIT"));const g=this.safeList(c.info,"orderTypes");if(!this.inArray(f,g))throw p!==f?new r.InvalidOrder(this.id+" stopPrice parameter is not allowed for "+t+" "+s+" orders"):new r.InvalidOrder(this.id+" "+s+" is not a valid order type for the "+t+" market");if(void 0===l){const e=this.safeDict(this.options,"broker");if(void 0!==e){const t=this.safeString(e,"spot");void 0!==t&&(u.newClientOrderId=t+this.uuid22())}}else u.newClientOrderId=l;u.newOrderRespType=this.safeValue(this.options.newOrderRespType,s,"RESULT");let v=!1,y=!1,w=!1,b=!1;if("MARKET"===f){if(this.safeBool(this.options,"quoteOrderQty",!0)){const e=this.safeValue2(h,"quoteOrderQty","cost"),t=c.precision.price;if(void 0!==e)u.quoteOrderQty=this.decimalToPrecision(e,o.R3,t,this.precisionMode);else if(void 0!==d){const e=this.numberToString(n),s=this.numberToString(d),i=a.Y.stringMul(e,s);u.quoteOrderQty=this.decimalToPrecision(i,o.R3,t,this.precisionMode)}else b=!0}else b=!0}else"LIMIT"===f?(y=!0,v=!0,b=!0):"STOP_LOSS"===f||"TAKE_PROFIT"===f?(w=!0,b=!0):"STOP_LOSS_LIMIT"===f||"TAKE_PROFIT_LIMIT"===f?(b=!0,w=!0,y=!0,v=!0):"LIMIT_MAKER"===f&&(y=!0,b=!0);if(b&&(u.quantity=this.amountToPrecision(t,n)),y){if(void 0===d)throw new r.InvalidOrder(this.id+" editOrder() requires a price argument for a "+s+" order");u.price=this.priceToPrecision(t,d)}if(v&&void 0===this.safeString(h,"timeInForce")&&(u.timeInForce=this.options.defaultTimeInForce),w){if(void 0===m)throw new r.InvalidOrder(this.id+" editOrder() requires a stopPrice extra param for a "+s+" order");u.stopPrice=this.priceToPrecision(t,m)}u.cancelReplaceMode="STOP_ON_FAILURE";return void 0===this.safeString2(h,"cancelNewClientOrderId","cancelOrigClientOrderId")&&(u.cancelOrderId=e),"PO"===this.safeString(h,"timeInForce")&&(h=this.omit(h,["timeInForce"])),h=this.omit(h,["quoteOrderQty","cost","stopPrice","newClientOrderId","clientOrderId","postOnly"]),this.extend(u,h)}editContractOrderRequest(e,t,s,i,a,o=void 0,n={}){const d=this.market(t);if(!d.contract)throw new r.NotSupported(this.id+" editContractOrder() does not support "+d.type+" orders");const h={symbol:d.id,side:i.toUpperCase()},c=this.safeStringN(n,["newClientOrderId","clientOrderId","origClientOrderId"]);return h.orderId=e,h.quantity=this.amountToPrecision(t,a),void 0!==o&&(h.price=this.priceToPrecision(t,o)),void 0!==c&&(h.origClientOrderId=c),n=this.omit(n,["clientOrderId","newClientOrderId"]),h}async editContractOrder(e,t,s,i,r,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editContractOrderRequest(e,t,s,i,r,a,o);let h;return n.linear?h=await this.fapiPrivatePutOrder(this.extend(d,o)):n.inverse&&(h=await this.dapiPrivatePutOrder(this.extend(d,o))),this.parseOrder(h,n)}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);if(d.option)throw new r.NotSupported(this.id+" editOrder() does not support "+d.type+" orders");return d.spot?await this.editSpotOrder(e,t,s,i,a,o,n):await this.editContractOrder(e,t,s,i,a,o,n)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",ACCEPTED:"open",FILLED:"closed",CANCELED:"canceled",CANCELLED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired",EXPIRED_IN_MATCH:"expired"},e,e)}parseOrder(e,t=void 0){if(void 0!==this.safeString(e,"code"))return this.safeOrder({info:e,status:"rejected"},t);const s=this.parseOrderStatus(this.safeString2(e,"status","strategyStatus")),i=this.safeString(e,"symbol"),r="positionSide"in e||"cumQuote"in e?"contract":"spot",o=this.safeSymbol(i,t,void 0,r),n=this.safeString(e,"executedQty","0"),d=this.safeIntegerN(e,["time","createTime","workingTime","transactTime","updateTime"]);let h;if("transactTime"in e||"updateTime"in e){const t=this.safeInteger2(e,"updateTime","transactTime");"open"===s?a.Y.stringGt(n,"0")&&(h=t):"closed"===s&&(h=t)}const c=this.safeInteger2(e,"transactTime","updateTime"),l=this.safeString(e,"avgPrice"),u=this.safeString(e,"price"),p=this.safeString2(e,"origQty","quantity");let f=this.safeString2(e,"cummulativeQuoteQty","cumQuote");f=this.safeString(e,"cumBase",f);let m=this.safeStringLower(e,"type");const g=this.safeStringLower(e,"side"),v=this.safeList(e,"fills",[]);let y=this.safeString(e,"timeInForce");"GTX"===y&&(y="PO");const w="limit_maker"===m||"PO"===y;"limit_maker"===m&&(m="limit");const b=this.safeString(e,"stopPrice"),S=this.parseNumber(this.omitZero(b)),k=this.safeNumber(e,"fee");let O;return void 0!==k&&(O={currency:this.safeString(e,"quoteAsset"),cost:k,rate:void 0}),this.safeOrder({info:e,id:this.safeString2(e,"strategyId","orderId"),clientOrderId:this.safeString2(e,"clientOrderId","newClientStrategyId"),timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:h,lastUpdateTimestamp:c,symbol:o,type:m,timeInForce:y,postOnly:w,reduceOnly:this.safeBool(e,"reduceOnly"),side:g,price:u,triggerPrice:S,amount:p,cost:f,average:l,filled:n,remaining:void 0,status:s,fee:O,trades:v},t)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i=[];for(let t=0;t<e.length;t++){const r=e[t],a=this.safeString(r,"symbol");i.push(a);const o=this.safeString(r,"type"),n=this.safeString(r,"side"),d=this.safeValue(r,"amount"),h=this.safeValue(r,"price"),c=this.safeDict(r,"params",{}),l=this.createOrderRequest(a,o,n,d,h,c);s.push(l)}i=this.marketSymbols(i,void 0,!1,!0,!0);const a=this.market(i[0]);if(a.spot)throw new r.NotSupported(this.id+" createOrders() does not support "+a.type+" orders");let o,n={batchOrders:s};return n=this.extend(n,t),o=a.linear?await this.fapiPrivatePostBatchOrders(n):a.option?await this.eapiPrivatePostBatchOrders(n):await this.dapiPrivatePostBatchOrders(n),this.parseOrders(o)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeString(a,"type",o.type);let d,h;[d,a]=this.handleMarginModeAndParams("createOrder",a),[h,a]=this.handleOptionAndParams2(a,"createOrder","papi","portfolioMargin",!1);const c=this.safeString2(a,"triggerPrice","stopPrice"),l=this.safeString(a,"stopLossPrice"),u=this.safeString(a,"takeProfitPrice"),p=this.safeString2(a,"trailingPercent","callbackRate"),f=void 0!==c||void 0!==p||void 0!==l||void 0!==u,m=this.safeBool2(a,"sor","SOR",!1),g=this.safeBool(a,"test",!1);a=this.omit(a,["sor","SOR","test"]),h&&(a.portfolioMargin=h);const v=this.createOrderRequest(e,t,s,i,r,a);let y;return y=o.option?await this.eapiPrivatePostOrder(v):m?g?await this.privatePostSorOrderTest(v):await this.privatePostSorOrder(v):o.linear?h?f?await this.papiPostUmConditionalOrder(v):await this.papiPostUmOrder(v):await this.fapiPrivatePostOrder(v):o.inverse?h?f?await this.papiPostCmConditionalOrder(v):await this.papiPostCmOrder(v):await this.dapiPrivatePostOrder(v):"margin"===n||void 0!==d||h?h?await this.papiPostMarginOrder(v):await this.sapiPostMarginOrder(v):g?await this.privatePostOrderTest(v):await this.privatePostOrder(v),this.parseOrder(y,o)}createOrderRequest(e,t,s,i,n=void 0,d={}){const h=this.market(e),c=this.safeString(d,"type",h.type),l=this.safeString2(d,"newClientOrderId","clientOrderId"),u=t.toUpperCase(),p="MARKET"===u,f="LIMIT"===u,m={symbol:h.id,side:s.toUpperCase()};let g,v;if([g,d]=this.handleOptionAndParams2(d,"createOrder","papi","portfolioMargin",!1),[v,d]=this.handleMarginModeAndParams("createOrder",d),"margin"===c||void 0!==v||h.option){const e=this.safeBool(d,"reduceOnly",!1);d=this.omit(d,"reduceOnly"),h.option?m.reduceOnly=e:e&&(m.sideEffectType="AUTO_REPAY")}const y=this.safeString2(d,"triggerPrice","stopPrice"),w=this.safeString(d,"stopLossPrice",y),b=this.safeString(d,"takeProfitPrice"),S=this.safeString(d,"trailingDelta"),k=this.safeString2(d,"trailingTriggerPrice","activationPrice"),O=this.safeStringN(d,["trailingPercent","callbackRate","trailingDelta"]),T=void 0!==O,P=void 0!==w||void 0!==S,I=void 0!==b,x=g&&(void 0!==y||T||P||I),A=void 0!==this.safeString(d,"priceMatch");let M,C=t.toUpperCase();if(T)if(h.swap)C="TRAILING_STOP_MARKET",m.callbackRate=O,void 0!==k&&(m.activationPrice=this.priceToPrecision(e,k));else{if(p)throw new r.InvalidOrder(this.id+" trailingPercent orders are not supported for "+e+" "+t+" orders");const s=this.safeString(d,"stopLossOrTakeProfit");if(d=this.omit(d,"stopLossOrTakeProfit"),"stopLoss"!==s&&"takeProfit"!==s)throw new r.InvalidOrder(this.id+e+" trailingPercent orders require a stopLossOrTakeProfit parameter of either stopLoss or takeProfit");"stopLoss"===s?C="STOP_LOSS_LIMIT":"takeProfit"===s&&(C="TAKE_PROFIT_LIMIT"),void 0!==k&&(M=this.priceToPrecision(e,k));const i=a.Y.stringMul(O,"100");m.trailingDelta=i}else P?(M=w,p?C=h.contract?"STOP_MARKET":"STOP_LOSS":f&&(C=h.contract?"STOP":"STOP_LOSS_LIMIT")):I&&(M=b,p?C=h.contract?"TAKE_PROFIT_MARKET":"TAKE_PROFIT":f&&(C=h.contract?"TAKE_PROFIT":"TAKE_PROFIT_LIMIT"));if(h.option){if("market"===t)throw new r.InvalidOrder(this.id+" "+t+" is not a valid order type for the "+e+" market")}else{const s=this.safeList(h.info,"orderTypes");if(!this.inArray(C,s))throw u!==C?new r.InvalidOrder(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new r.InvalidOrder(this.id+" "+t+" is not a valid order type for the "+e+" market")}const E=x?"newClientStrategyId":"newClientOrderId";if(void 0===l){const e=this.safeDict(this.options,"broker",{}),t=h.contract?"x-xcKtGhcu":"x-R4BD3S82",s=this.safeString(e,c,t);m[E]=s+this.uuid22()}else m[E]=l;let _;g?(_=this.isPostOnly(p,"LIMIT_MAKER"===u,d),_&&(h.contract?m.timeInForce="GTX":C="LIMIT_MAKER")):(_=this.isPostOnly(p,"LIMIT_MAKER"===u,d),(h.spot||"margin"===c)&&(_&&(C="LIMIT_MAKER"),"isolated"===v&&(m.isIsolated=!0))),m.newOrderRespType="spot"!==c&&"margin"!==c||g?"RESULT":this.safeString(this.options.newOrderRespType,t,"FULL");m[x?"strategyType":"type"]=C;let B=!1,N=!1,R=!1,L=!1;if("MARKET"===C)if(h.spot){if(this.safeBool(this.options,"quoteOrderQty",!0)){const e=this.safeString2(d,"quoteOrderQty","cost"),t=h.precision.price;if(void 0!==e)m.quoteOrderQty=this.decimalToPrecision(e,o.R3,t,this.precisionMode);else if(void 0!==n){const e=this.numberToString(i),s=this.numberToString(n),r=a.Y.stringMul(e,s);m.quoteOrderQty=this.decimalToPrecision(r,o.R3,t,this.precisionMode)}else L=!0}else L=!0}else L=!0;else if("LIMIT"===C)N=!0,B=!0,L=!0;else if("STOP_LOSS"===C||"TAKE_PROFIT"===C)R=!0,L=!0,(h.linear||h.inverse)&&(N=!0);else if("STOP_LOSS_LIMIT"===C||"TAKE_PROFIT_LIMIT"===C)L=!0,R=!0,N=!0,B=!0;else if("LIMIT_MAKER"===C)N=!0,L=!0;else if("STOP"===C)L=!0,R=!0,N=!0;else if("STOP_MARKET"===C||"TAKE_PROFIT_MARKET"===C){void 0===this.safeBool(d,"closePosition")&&(L=!0),R=!0}else if("TRAILING_STOP_MARKET"===C&&(L=!0,void 0===O))throw new r.InvalidOrder(this.id+" createOrder() requires a trailingPercent param for a "+t+" order");if(L&&(m.quantity=g?this.parseToNumeric(i):this.amountToPrecision(e,i)),N&&!A){if(void 0===n)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument for a "+t+" order");m.price=this.priceToPrecision(e,n)}if(R){if(h.contract){if(void 0===M)throw new r.InvalidOrder(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order")}else if(void 0===S&&void 0===M&&void 0===O)throw new r.InvalidOrder(this.id+" createOrder() requires a stopPrice, trailingDelta or trailingPercent param for a "+t+" order");void 0!==M&&(m.stopPrice=this.priceToPrecision(e,M))}B&&void 0===this.safeString(d,"timeInForce")&&void 0===this.safeString(m,"timeInForce")&&(m.timeInForce=this.options.defaultTimeInForce),!g&&h.contract&&_&&(m.timeInForce="GTX"),"PO"===this.safeString(d,"timeInForce")&&(d=this.omit(d,"timeInForce"));const V=this.omit(d,["type","newClientOrderId","clientOrderId","postOnly","stopLossPrice","takeProfitPrice","stopPrice","triggerPrice","trailingTriggerPrice","trailingPercent","quoteOrderQty","cost","test"]);return this.extend(m,V)}async createMarketOrderWithCost(e,t,s,i={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketOrderWithCost() supports spot orders only");return i.cost=s,await this.createOrder(e,"market",t,s,void 0,i)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.cost=t,await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketSellOrderWithCost() supports spot orders only");return s.quoteOrderQty=t,await this.createOrder(e,"market","sell",t,void 0,s)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeString2(this.options,"fetchOrder","defaultType","spot"),o=this.safeString(s,"type",a);let n,d;[n,s]=this.handleMarginModeAndParams("fetchOrder",s),[d,s]=this.handleOptionAndParams2(s,"fetchOrder","papi","portfolioMargin",!1);const h={symbol:i.id},c=this.safeString2(s,"origClientOrderId","clientOrderId");let l;return void 0!==c?i.option?h.clientOrderId=c:h.origClientOrderId=c:h.orderId=e,s=this.omit(s,["type","clientOrderId","origClientOrderId"]),i.option?l=await this.eapiPrivateGetOrder(this.extend(h,s)):i.linear?l=d?await this.papiGetUmOrder(this.extend(h,s)):await this.fapiPrivateGetOrder(this.extend(h,s)):i.inverse?l=d?await this.papiGetCmOrder(this.extend(h,s)):await this.dapiPrivateGetOrder(this.extend(h,s)):"margin"===o||void 0!==n||d?d?l=await this.papiGetMarginOrder(this.extend(h,s)):("isolated"===n&&(h.isIsolated=!0),l=await this.sapiGetMarginOrder(this.extend(h,s))):l=await this.privateGetOrder(this.extend(h,s)),this.parseOrder(l,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchOrders",e,t,s,i);const o=this.market(e),n=this.safeString2(this.options,"fetchOrders","defaultType",o.type),d=this.safeString(i,"type",n);let h,c;[h,i]=this.handleMarginModeAndParams("fetchOrders",i),[c,i]=this.handleOptionAndParams2(i,"fetchOrders","papi","portfolioMargin",!1);const l=this.safeBool2(i,"stop","conditional");i=this.omit(i,["stop","conditional","type"]);let u,p={symbol:o.id};return[p,i]=this.handleUntilOption("endTime",p,i),void 0!==t&&(p.startTime=t),void 0!==s&&(p.limit=s),o.option?u=await this.eapiPrivateGetHistoryOrders(this.extend(p,i)):o.linear?u=c?l?await this.papiGetUmConditionalAllOrders(this.extend(p,i)):await this.papiGetUmAllOrders(this.extend(p,i)):await this.fapiPrivateGetAllOrders(this.extend(p,i)):o.inverse?u=c?l?await this.papiGetCmConditionalAllOrders(this.extend(p,i)):await this.papiGetCmAllOrders(this.extend(p,i)):await this.dapiPrivateGetAllOrders(this.extend(p,i)):c?u=await this.papiGetMarginAllOrders(this.extend(p,i)):"margin"===d||void 0!==h?("isolated"===h&&(p.isIsolated=!0),u=await this.sapiGetMarginAllOrders(this.extend(p,i))):u=await this.privateGetAllOrders(this.extend(p,i)),this.parseOrders(u,o,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o;await this.loadMarkets();const n={};let d,h;[d,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),[h,i]=this.handleOptionAndParams2(i,"fetchOpenOrders","papi","portfolioMargin",!1);const c=this.safeBoolN(i,["stop","conditional","trigger"]);if(void 0!==e){a=this.market(e),n.symbol=a.id;const t=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot"),s="type"in a?a.type:t;o=this.safeString(i,"type",s)}else{if(this.options.warnOnFetchOpenOrdersWithoutSymbol)throw new r.ExchangeError(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol has stricter rate limits (10 times more for spot, 40 times more for other markets) compared to requesting with symbol argument. To acknowledge this warning, set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.');{const e=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot");o=this.safeString(i,"type",e)}}let l,u;if([l,i]=this.handleSubTypeAndParams("fetchOpenOrders",a,i),i=this.omit(i,["type","stop","conditional","trigger"]),"option"===o)void 0!==t&&(n.startTime=t),void 0!==s&&(n.limit=s),u=await this.eapiPrivateGetOpenOrders(this.extend(n,i));else if(this.isLinear(o,l))u=h?c?await this.papiGetUmConditionalOpenOrders(this.extend(n,i)):await this.papiGetUmOpenOrders(this.extend(n,i)):await this.fapiPrivateGetOpenOrders(this.extend(n,i));else if(this.isInverse(o,l))u=h?c?await this.papiGetCmConditionalOpenOrders(this.extend(n,i)):await this.papiGetCmOpenOrders(this.extend(n,i)):await this.dapiPrivateGetOpenOrders(this.extend(n,i));else if("margin"===o||void 0!==d||h)if(h)u=await this.papiGetMarginOpenOrders(this.extend(n,i));else{if("isolated"===d&&(n.isIsolated=!0,void 0===e))throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument for isolated markets");u=await this.sapiGetMarginOpenOrders(this.extend(n,i))}else u=await this.privateGetOpenOrders(this.extend(n,i));return this.parseOrders(u,a,t,s)}async fetchOpenOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOpenOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id};let o;[o,s]=this.handleOptionAndParams2(s,"fetchOpenOrder","papi","portfolioMargin",!1);const n=this.safeBoolN(s,["stop","conditional","trigger"]);s=this.omit(s,["stop","conditional","trigger"]);let d;if(a[o&&n?"strategyId":"orderId"]=e,i.linear)d=o?n?await this.papiGetUmConditionalOpenOrder(this.extend(a,s)):await this.papiGetUmOpenOrder(this.extend(a,s)):await this.fapiPrivateGetOpenOrder(this.extend(a,s));else if(i.inverse)d=o?n?await this.papiGetCmConditionalOpenOrder(this.extend(a,s)):await this.papiGetCmOpenOrder(this.extend(a,s)):await this.dapiPrivateGetOpenOrder(this.extend(a,s));else{if(i.option)throw new r.NotSupported(this.id+" fetchOpenOrder() does not support option markets");if(i.spot)throw new r.NotSupported(this.id+" fetchOpenOrder() does not support spot markets")}return this.parseOrder(d,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");const a=await this.fetchOrders(e,t,void 0,i),o=this.filterBy(a,"status","closed");return this.filterBySinceLimit(o,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchCanceledOrders() requires a symbol argument");const a=await this.fetchOrders(e,t,void 0,i),o=this.filterBy(a,"status","canceled");return this.filterBySinceLimit(o,t,s)}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchCanceledAndClosedOrders() requires a symbol argument");const a=await this.fetchOrders(e,t,void 0,i),o=this.filterBy(a,"status","canceled"),n=this.filterBy(a,"status","closed"),d=this.arrayConcat(o,n),h=this.sortBy(d,"timestamp");return this.filterBySinceLimit(h,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeString2(this.options,"cancelOrder","defaultType","spot"),o=this.safeString(s,"type",a);let n,d;[n,s]=this.handleMarginModeAndParams("cancelOrder",s),[d,s]=this.handleOptionAndParams2(s,"cancelOrder","papi","portfolioMargin",!1);const h=this.safeBool2(s,"stop","conditional"),c={symbol:i.id},l=this.safeStringN(s,["origClientOrderId","clientOrderId","newClientStrategyId"]);let u;return void 0!==l?i.option?c.clientOrderId=l:d&&h?c.newClientStrategyId=l:c.origClientOrderId=l:d&&h?c.strategyId=e:c.orderId=e,s=this.omit(s,["type","origClientOrderId","clientOrderId","newClientStrategyId","stop","conditional"]),i.option?u=await this.eapiPrivateDeleteOrder(this.extend(c,s)):i.linear?u=d?h?await this.papiDeleteUmConditionalOrder(this.extend(c,s)):await this.papiDeleteUmOrder(this.extend(c,s)):await this.fapiPrivateDeleteOrder(this.extend(c,s)):i.inverse?u=d?h?await this.papiDeleteCmConditionalOrder(this.extend(c,s)):await this.papiDeleteCmOrder(this.extend(c,s)):await this.dapiPrivateDeleteOrder(this.extend(c,s)):"margin"===o||void 0!==n||d?d?u=await this.papiDeleteMarginOrder(this.extend(c,s)):("isolated"===n&&(c.isIsolated=!0),u=await this.sapiDeleteMarginOrder(this.extend(c,s))):u=await this.privateDeleteOrder(this.extend(c,s)),this.parseOrder(u,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let a;[a,t]=this.handleOptionAndParams2(t,"cancelAllOrders","papi","portfolioMargin",!1);const o=this.safeBool2(t,"stop","conditional"),n=this.safeString(t,"type",s.type);let d,h;return t=this.omit(t,["type","stop","conditional"]),[d,t]=this.handleMarginModeAndParams("cancelAllOrders",t),s.option?h=await this.eapiPrivateDeleteAllOpenOrders(this.extend(i,t)):s.linear?h=a?o?await this.papiDeleteUmConditionalAllOpenOrders(this.extend(i,t)):await this.papiDeleteUmAllOpenOrders(this.extend(i,t)):await this.fapiPrivateDeleteAllOpenOrders(this.extend(i,t)):s.inverse?h=a?o?await this.papiDeleteCmConditionalAllOpenOrders(this.extend(i,t)):await this.papiDeleteCmAllOpenOrders(this.extend(i,t)):await this.dapiPrivateDeleteAllOpenOrders(this.extend(i,t)):"margin"===n||void 0!==d||a?a?h=await this.papiDeleteMarginAllOpenOrders(this.extend(i,t)):("isolated"===d&&(i.isIsolated=!0),h=await this.sapiDeleteMarginOpenOrders(this.extend(i,t))):h=await this.privateDeleteOpenOrders(this.extend(i,t)),Array.isArray(h)?this.parseOrders(h,s):[this.safeOrder({info:h})]}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.contract)throw new r.BadRequest(this.id+" cancelOrders is only supported for swap markets.");const a={symbol:i.id,orderidlist:e};let o;return i.linear?o=await this.fapiPrivateDeleteBatchOrders(this.extend(a,s)):i.inverse&&(o=await this.dapiPrivateDeleteBatchOrders(this.extend(a,s))),this.parseOrders(o,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const o=this.market(t),n=this.safeString(a,"type",o.type);if(a=this.omit(a,"type"),"spot"!==n)throw new r.NotSupported(this.id+" fetchOrderTrades() supports spot markets only");const d={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(d,a))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);const o={};let n,d,h;void 0!==e&&(n=this.market(e),o.symbol=n.id),[d,i]=this.handleMarketTypeAndParams("fetchMyTrades",n,i);let c,l=this.safeInteger2(i,"until","endTime");if(void 0!==t){const e=t;o.startTime=e;const s=this.milliseconds(),i=6048e5;s-e>=i&&void 0===l&&n.linear&&(l=this.sum(e,i),l=Math.min(l,s))}if(void 0!==l&&(o.endTime=l,i=this.omit(i,["endTime","until"])),void 0!==s&&(("option"===d||n.contract)&&(s=Math.min(s,1e3)),o.limit=s),"option"===d)c=await this.eapiPrivateGetUserTrades(this.extend(o,i));else{if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");let t;[h,i]=this.handleMarginModeAndParams("fetchMyTrades",i),[t,i]=this.handleOptionAndParams2(i,"fetchMyTrades","papi","portfolioMargin",!1),"spot"===d||"margin"===d?t?c=await this.papiGetMarginMyTrades(this.extend(o,i)):"margin"===d||void 0!==h?("isolated"===h&&(o.isIsolated=!0),c=await this.sapiGetMarginMyTrades(this.extend(o,i))):c=await this.privateGetMyTrades(this.extend(o,i)):n.linear?c=t?await this.papiGetUmUserTrades(this.extend(o,i)):await this.fapiPrivateGetUserTrades(this.extend(o,i)):n.inverse&&(c=t?await this.papiGetCmUserTrades(this.extend(o,i)):await this.dapiPrivateGetUserTrades(this.extend(o,i)))}return this.parseTrades(c,n,t,s)}async fetchMyDustTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==t&&(r.startTime=t,r.endTime=this.sum(t,7776e6));const a=this.safeStringUpper(i,"type");i=this.omit(i,"type"),void 0!==a&&(r.accountType=a);const o=await this.sapiGetAssetDribblet(this.extend(r,i)),n=this.safeList(o,"userAssetDribblets",[]),d=this.safeInteger(o,"total",0),h=[];for(let e=0;e<d;e++){const t=this.safeList(n[e],"userAssetDribbletDetails",[]);for(let e=0;e<t.length;e++)t[e].isDustTrade=!0,h.push(t[e])}const c=this.parseTrades(h,void 0,t,s);return this.filterBySinceLimit(c,t,s)}parseDustTrade(e,t=void 0){const s=this.safeString(e,"transId"),i=this.safeInteger(e,"operateTime"),r=this.safeString(e,"fromAsset"),o=this.safeCurrencyCode(r),n=this.currency("BNB").code,d=n+"/"+o;let h=!1;d in this.markets&&(h=!0);const c=this.safeString(e,"serviceChargeAmount"),l={currency:n,cost:this.parseNumber(c)};let u,p,f,m,g;h?(u=d,p=this.safeString(e,"transferedAmount"),f=this.safeString(e,"amount"),m="buy"):(u=o+"/"+n,p=this.safeString(e,"amount"),f=this.safeString(e,"transferedAmount"),m="sell"),void 0!==f&&p&&(g=a.Y.stringDiv(f,p));const v=this.parseNumber(p),y=this.parseNumber(g),w=this.parseNumber(f);return{id:undefined,timestamp:i,datetime:this.iso8601(i),symbol:u,order:s,type:undefined,takerOrMaker:undefined,side:m,amount:v,price:y,cost:w,fee:l,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o=!1;if([o,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),o)return await this.fetchPaginatedCallDynamic("fetchDeposits",e,t,s,i);const n={},d=this.safeDict(this.options,"legalMoney",{}),h=this.safeBool(i,"fiat",!1);i=this.omit(i,"fiatOnly");const c=this.safeInteger(i,"until");if(i=this.omit(i,"until"),h||e in d){void 0!==e&&(r=this.currency(e)),n.transactionType=0,void 0!==t&&(n.beginTime=t),void 0!==c&&(n.endTime=c);const s=await this.sapiGetFiatOrders(this.extend(n,i));a=this.safeList(s,"data",[])}else{if(void 0!==e&&(r=this.currency(e),n.coin=r.id),void 0!==t){n.startTime=t;let e=this.sum(t,7776e6);void 0!==c&&(e=Math.min(e,c)),n.endTime=e}void 0!==s&&(n.limit=s),a=await this.sapiGetCapitalDepositHisrec(this.extend(n,i))}for(let e=0;e<a.length;e++)a[e].type="deposit";return this.parseTransactions(a,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchWithdrawals",e,t,s,i);const a=this.safeDict(this.options,"legalMoney",{}),o=this.safeBool(i,"fiat",!1);i=this.omit(i,"fiatOnly");const n={},d=this.safeInteger(i,"until");let h,c;if(void 0!==d&&(i=this.omit(i,"until"),n.endTime=d),o||e in a){void 0!==e&&(c=this.currency(e)),n.transactionType=1,void 0!==t&&(n.beginTime=t);const s=await this.sapiGetFiatOrders(this.extend(n,i));h=this.safeList(s,"data",[])}else void 0!==e&&(c=this.currency(e),n.coin=c.id),void 0!==t&&(n.startTime=t,n.endTime=this.sum(t,7776e6)),void 0!==s&&(n.limit=s),h=await this.sapiGetCapitalWithdrawHistory(this.extend(n,i));for(let e=0;e<h.length;e++)h[e].type="withdrawal";return this.parseTransactions(h,c,t,s)}parseTransactionStatusByType(e,t=void 0){if(void 0===t)return e;const s=this.safeDict({deposit:{0:"pending",1:"ok",6:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok",Processing:"pending",Failed:"failed",Successful:"ok",Refunding:"canceled",Refunded:"canceled","Refund Failed":"failed"}},t,{});return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","orderNo"),i=this.safeString(e,"address");let r=this.safeString(e,"addressTag");void 0!==r&&r.length<1&&(r=void 0);let a=this.safeString(e,"txId");void 0!==a&&a.indexOf("Internal transfer ")>=0&&(a=a.slice(18));const o=this.safeString2(e,"coin","fiatCurrency");let n,d=this.safeCurrencyCode(o,t);n=this.safeInteger2(e,"insertTime","createTime"),void 0===n&&(n=this.parse8601(this.safeString(e,"applyTime")));const h=this.safeInteger2(e,"successTime","updateTime");let c=this.safeString(e,"type");if(void 0===c){const t=this.safeString(e,"transactionType");void 0!==t&&(c="0"===t?"deposit":"withdrawal");const s=this.safeDict(this.options,"legalMoneyCurrenciesById");d=this.safeString(s,d,d)}const l=this.parseTransactionStatusByType(this.safeString(e,"status"),c),u=this.safeNumber(e,"amount"),p=this.safeNumber2(e,"transactionFee","totalFee");let f;void 0!==p&&(f={currency:d,cost:p});const m=this.safeInteger(e,"transferType");let g;void 0!==m&&(g=!!m);const v=this.safeString(e,"network");return{info:e,id:s,txid:a,timestamp:n,datetime:this.iso8601(n),network:v,address:i,addressTo:i,addressFrom:void 0,tag:r,tagTo:r,tagFrom:void 0,type:c,amount:u,currency:d,status:l,updated:h,internal:g,comment:void 0,fee:f}}parseTransferStatus(e){return this.safeString({CONFIRMED:"ok"},e,e)}parseTransfer(e,t=void 0){const s=this.safeString2(e,"tranId","transactionId"),i=this.safeString2(e,"asset","currency"),r=this.safeCurrencyCode(i,t),a=this.safeNumber(e,"amount"),o=this.safeString(e,"type");let n,d;const h=this.safeDict(this.options,"accountsById",{});if(void 0!==o){const e=o.split("_");n=this.safeValue(e,0),d=this.safeValue(e,1),n=this.safeString(h,n,n),d=this.safeString(h,d,d)}if(void 0!==this.safeInteger(e,"walletType")){const t=this.safeDict(e,"payerInfo",{}),s=this.safeDict(e,"receiverInfo",{});n=this.safeString(t,"accountId"),d=this.safeString(s,"accountId")}const c=this.safeInteger2(e,"timestamp","transactionTime"),l=this.parseTransferStatus(this.safeString(e,"status"));return{info:e,id:s,timestamp:c,datetime:this.iso8601(c),currency:r,amount:a,fromAccount:n,toAccount:d,status:l}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"asset"),r=this.safeInteger(e,"time");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),code:this.safeCurrencyCode(i),timestamp:r,datetime:this.iso8601(r),id:this.safeString(e,"tranId"),amount:this.safeNumber(e,"income")}}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n={asset:o.id,amount:this.currencyToPrecision(e,t)};if(n.type=this.safeString(a,"type"),a=this.omit(a,"type"),void 0===n.type){const e=this.safeString(a,"symbol");let t;void 0!==e&&(t=this.market(e),a=this.omit(a,"symbol"));let o,d=this.convertTypeToAccount(s).toUpperCase(),h=this.convertTypeToAccount(i).toUpperCase();if(void 0!==t&&(o=t.id),"ISOLATED"===d&&void 0===e)throw new r.ArgumentsRequired(this.id+' transfer () requires params["symbol"] when fromAccount is '+s);if("ISOLATED"===h&&void 0===e)throw new r.ArgumentsRequired(this.id+' transfer () requires params["symbol"] when toAccount is '+i);const c=this.safeDict(this.options,"accountsById",{}),l=!(d in c),u=!(h in c);if(l&&void 0===t&&(o=d),u&&void 0===t&&(o=h),l||u){const e="MAIN"===d,t="MAIN"===h;if((l||u)&&("UMFUTURE"===d||"CMFUTURE"===d||("UMFUTURE"===h||"CMFUTURE"===h)||("FUNDING"===d||"FUNDING"===h)||("OPTION"===d||"OPTION"===h)))throw new r.BadRequest(this.id+" transfer () does not allow transfers between "+s+" and "+i);t&&l?(d="ISOLATED_MARGIN",n.fromSymbol=o):e&&u?(h="ISOLATED_MARGIN",n.toSymbol=o):l&&u?(n.fromSymbol=d,n.toSymbol=h,d="ISOLATEDMARGIN",h="ISOLATEDMARGIN"):(l&&(n.fromSymbol=o,d="ISOLATEDMARGIN"),u&&(n.toSymbol=o,h="ISOLATEDMARGIN")),n.type=d+"_"+h}else n.type=d+"_"+h}const d=await this.sapiPostAssetTransfer(this.extend(n,a));return this.parseTransfer(d,o)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.safeBool(i,"internal");i=this.omit(i,"internal");let o,n=!1;if([n,i]=this.handleOptionAndParams(i,"fetchTransfers","paginate"),n&&!a)return await this.fetchPaginatedCallDynamic("fetchTransfers",e,t,s,i);void 0!==e&&(o=this.currency(e));const d={};let h="limit";if(!a){const e=this.safeString2(this.options,"fetchTransfers","defaultType","spot"),t=this.safeString(i,"fromAccount",e),s="future"===t?"spot":"future",a=this.safeString(i,"toAccount",s);let o=this.safeString(i,"type");const n=this.safeDict(this.options,"accountsByType",{}),c=this.safeString(n,t),l=this.safeString(n,a);if(void 0===o){if(void 0===c){const e=Object.keys(n);throw new r.ExchangeError(this.id+" fromAccount parameter must be one of "+e.join(", "))}if(void 0===l){const e=Object.keys(n);throw new r.ExchangeError(this.id+" toAccount parameter must be one of "+e.join(", "))}o=c+"_"+l}d.type=o,h="size"}void 0!==s&&(d[h]=s),void 0!==t&&(d.startTime=t);const c=this.safeInteger(i,"until");let l;void 0!==c&&(i=this.omit(i,"until"),d.endTime=c),l=a?await this.sapiGetPayTransactions(this.extend(d,i)):await this.sapiGetAssetTransfer(this.extend(d,i));const u=this.safeList2(l,"rows","data",[]);return this.parseTransfers(u,o,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={coin:this.currency(e).id},i=this.safeDict(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(i,r,r),void 0!==r&&(s.network=r,t=this.omit(t,"network"));const a=await this.sapiGetCapitalDepositAddress(this.extend(s,t)),o=this.safeString(a,"address"),n=this.safeString(a,"url");let d;if(void 0!==n){const t=this.safeDict(this.options,"reverseNetworks",{}),s=n.split("/");let i=this.safeString(s,2);if("blockchair.com"===i||"viewblock.io"===i){const e=this.safeString(s,3);void 0!==e&&(i=i+"/"+e)}d=this.safeString(t,i);const r=this.safeDict(this.options,"impliedNetworks",{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}});if(e in r){const t=this.safeDict(r,e,{});d=this.safeString(t,d,d)}}let h=this.safeString(a,"tag","");return 0===h.length&&(h=void 0),this.checkAddress(o),{currency:e,address:o,tag:h,network:d,info:a}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r),o=this.safeList(t,"networkList",[]);i[a]={};for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"network"),r=this.safeCurrencyCode(s),n=this.safeNumber(t,"withdrawFee");i[a][r]=n}}return{withdraw:i,deposit:{},info:s}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.sapiGetCapitalConfigGetall(t);return this.parseDepositWithdrawFees(s,e,"coin")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeList(e,"networkList",[]),i=this.depositWithdrawFee(e);for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"network"),a=this.networkIdToCode(r),o=this.safeNumber(t,"withdrawFee");!0===this.safeBool(t,"isDefault")&&(i.withdraw={fee:o,percentage:void 0}),i.networks[a]={withdraw:{fee:o,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return i}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={coin:a.id,address:s,amount:this.currencyToPrecision(e,t)};void 0!==i&&(o.addressTag=i);const n=this.safeDict(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeString(n,d,d),void 0!==d&&(o.network=d,r=this.omit(r,"network"));const h=await this.sapiPostCapitalWithdrawApply(this.extend(o,r));return this.parseTransaction(h,a)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t,void 0,"spot"),maker:this.safeNumber2(e,"makerCommission","makerCommissionRate"),taker:this.safeNumber2(e,"takerCommission","takerCommissionRate"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.type;let r,a;[r,t]=this.handleSubTypeAndParams("fetchTradingFee",s,t),[a,t]=this.handleOptionAndParams2(t,"fetchTradingFee","papi","portfolioMargin",!1);const o=this.isLinear(i,r),n=this.isInverse(i,r),d={symbol:s.id};let h;h=o?a?await this.papiGetUmCommissionRate(this.extend(d,t)):await this.fapiPrivateGetCommissionRate(this.extend(d,t)):n?a?await this.papiGetCmCommissionRate(this.extend(d,t)):await this.dapiPrivateGetCommissionRate(this.extend(d,t)):await this.sapiGetAssetTradeFee(this.extend(d,t));let c=h;return Array.isArray(c)&&(c=this.safeDict(c,0,{})),this.parseTradingFee(c,s)}async fetchTradingFees(e={}){let t,s;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e),[s,e]=this.handleSubTypeAndParams("fetchTradingFees",void 0,e,"linear");const i="spot"===t||"margin"===t,r=this.isLinear(t,s),a=this.isInverse(t,s);let o;if(i?o=await this.sapiGetAssetTradeFee(e):r?o=await this.fapiPrivateGetAccountConfig(e):a&&(o=await this.dapiPrivateGetAccount(e)),i){const e={};for(let t=0;t<o.length;t++){const s=this.parseTradingFee(o[t]);e[s.symbol]=s}return e}if(r){const e=Object.keys(this.markets),t={},s=this.safeInteger(o,"feeTier"),i=this.fees.linear.trading.tiers,r=i.maker[s][1],a=i.taker[s][1];for(let i=0;i<e.length;i++){const o=e[i];this.markets[o].linear&&(t[o]={info:{feeTier:s},symbol:o,maker:r,taker:a})}return t}if(a){const e=Object.keys(this.markets),t={},s=this.safeInteger(o,"feeTier"),i=this.fees.inverse.trading.tiers,r=i.maker[s][1],a=i.taker[s][1];for(let i=0;i<e.length;i++){const o=e[i];this.markets[o].inverse&&(t[o]={info:{feeTier:s},symbol:o,maker:r,taker:a})}return t}}async futuresTransfer(e,t,s,i={}){if(s<1||s>4)throw new r.ArgumentsRequired(this.id+" type must be between 1 and 4");await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:t,type:s},n=await this.sapiPostFuturesTransfer(this.extend(o,i));return this.parseTransfer(n,a)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let a;if(s.linear)a=await this.fapiPublicGetPremiumIndex(this.extend(i,t));else{if(!s.inverse)throw new r.NotSupported(this.id+" fetchFundingRate() supports linear and inverse contracts only");a=await this.dapiPublicGetPremiumIndex(this.extend(i,t))}return s.inverse&&(a=a[0]),this.parseFundingRate(a,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o=!1;if([o,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i);const n=this.safeString2(this.options,"fetchFundingRateHistory","defaultType","future"),d=this.safeString(i,"type",n);let h,c;void 0!==e&&(h=this.market(e),e=h.symbol,a.symbol=h.id),[c,i]=this.handleSubTypeAndParams("fetchFundingRateHistory",h,i,"linear"),i=this.omit(i,"type"),void 0!==t&&(a.startTime=t);const l=this.safeInteger(i,"until"),u=this.safeInteger(i,"endTime",l);let p;if(i=this.omit(i,["endTime","until"]),void 0!==u&&(a.endTime=u),void 0!==s&&(a.limit=s),this.isLinear(d,c))p=await this.fapiPublicGetFundingRate(this.extend(a,i));else{if(!this.isInverse(d,c))throw new r.NotSupported(this.id+" fetchFundingRateHistory() is not supported for "+d+" markets");p=await this.dapiPublicGetFundingRate(this.extend(a,i))}const f=[];for(let e=0;e<p.length;e++){const t=p[e],s=this.safeInteger(t,"fundingTime");f.push({info:t,symbol:this.safeSymbol(this.safeString(t,"symbol"),void 0,void 0,"swap"),fundingRate:this.safeNumber(t,"fundingRate"),timestamp:s,datetime:this.iso8601(s)})}const m=this.sortBy(f,"timestamp");return this.filterBySymbolSinceLimit(m,e,t,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString2(this.options,"fetchFundingRates","defaultType","future"),i=this.safeString(t,"type",s);let a;[a,t]=this.handleSubTypeAndParams("fetchFundingRates",void 0,t,"linear");const o=this.omit(t,"type");let n;if(this.isLinear(i,a))n=await this.fapiPublicGetPremiumIndex(o);else{if(!this.isInverse(i,a))throw new r.NotSupported(this.id+" fetchFundingRates() supports linear and inverse contracts only");n=await this.dapiPublicGetPremiumIndex(o)}const d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.parseFundingRate(t);d.push(s)}return this.filterByArray(d,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t,void 0,"contract"),a=this.safeNumber(e,"markPrice"),o=this.safeNumber(e,"indexPrice"),n=this.safeNumber(e,"interestRate"),d=this.safeNumber(e,"estimatedSettlePrice"),h=this.safeNumber(e,"lastFundingRate"),c=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:r,markPrice:a,indexPrice:o,interestRate:n,estimatedSettlePrice:d,timestamp:s,datetime:this.iso8601(s),fundingRate:h,fundingTimestamp:c,fundingDatetime:this.iso8601(c),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseAccountPositions(e,t=!1){const s=this.safeList(e,"positions"),i=this.safeList(e,"assets",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"asset"),o=this.safeCurrencyCode(s),n=this.safeString(t,"crossWalletBalance"),d=this.safeString(t,"crossUnPnl");r[o]={crossMargin:a.Y.stringAdd(n,d),crossWalletBalance:n}}const o=[];for(let e=0;e<s.length;e++){const i=s[e],a=this.safeString(i,"symbol"),n=this.safeMarket(a,void 0,void 0,"contract"),d=n.linear?n.quote:n.base,h=this.safeString(i,"maintMargin");if((!t||"0"!==h&&"0.00000000"!==h)&&d in r){const e=this.parseAccountPosition(this.extend(i,{crossMargin:r[d].crossMargin,crossWalletBalance:r[d].crossWalletBalance}),n);o.push(e)}}return o}parseAccountPosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeString(t,"symbol"),r=this.safeString(e,"leverage"),o=void 0!==r?parseInt(r):void 0,n=this.safeString(e,"initialMargin"),d=this.parseNumber(n);let h;if(void 0!==r){h=a.Y.stringDiv("1",r,8);this.isRoundNumber(1e3%o)||(h=a.Y.stringDiv(a.Y.stringAdd(h,"1e-8"),"1",8))}const c="notional"in e,l=this.safeString(e,"maintMargin"),u=this.parseNumber(l),p=this.safeString(e,"entryPrice");let f=this.parseNumber(p);const m=this.safeString2(e,"notional","notionalValue"),g=a.Y.stringAbs(m),v=this.parseNumber(g);let y=this.safeString(e,"positionAmt"),w=a.Y.stringAbs(y);if(void 0===y){const e=a.Y.stringMul(a.Y.stringMul(r,n),p),s=this.safeString(t,"contractSize");y=a.Y.stringDiv(e,s),w=a.Y.stringDiv(a.Y.stringAdd(y,"0.5"),"1",0)}const b=this.parseNumber(w),S=this.safeDict(this.options,"leverageBrackets",{}),k=this.safeList(S,i,[]);let O;for(let e=0;e<k.length;e++){const t=k[e];if(a.Y.stringLt(g,t[0]))break;O=t[1]}const T=this.parseNumber(O),P=this.safeString(e,"unrealizedProfit"),I=this.parseNumber(P);let x=this.safeInteger(e,"updateTime");0===x&&(x=void 0);let A,M,C,E=this.safeBool(e,"isolated");if(void 0===E){const t=this.safeString(e,"isolatedMargin");E=!a.Y.stringEq(t,"0")}E?(A="isolated",C=this.safeString(e,"isolatedWallet"),M=a.Y.stringAdd(C,P)):(A="cross",C=this.safeString(e,"crossWalletBalance"),M=this.safeString(e,"crossMargin"));const _=this.parseNumber(M);let B,N,R,L,V;const D=this.safeValue(t,"contractSize"),q=this.numberToString(D);if(a.Y.stringEquals(m,"0"))f=void 0;else{if(N=a.Y.stringLt(m,"0")?"short":"long",B=this.parseNumber(a.Y.stringDiv(a.Y.stringAdd(a.Y.stringDiv(l,M),"5e-5"),"1",4)),R=this.parseNumber(a.Y.stringMul(a.Y.stringDiv(P,n,4),"100")),c){let e,t=p;"short"===N?e=a.Y.stringAdd("1",O):(e=a.Y.stringAdd("-1",O),t=a.Y.stringMul("-1",t));const s=a.Y.stringDiv(C,a.Y.stringMul(w,e)),i=a.Y.stringDiv(t,e);L=a.Y.stringAdd(s,i)}else{let e,t=p;"short"===N?e=a.Y.stringSub("1",O):(e=a.Y.stringSub("-1",O),t=a.Y.stringMul("-1",t));const s=a.Y.stringMul(w,q),i=a.Y.stringMul(s,e),r=a.Y.stringSub(a.Y.stringMul(a.Y.stringDiv("1",t),s),C);L=a.Y.stringDiv(i,r)}const e=this.precisionFromString(this.safeString(t.precision,"price")),s=(e+1).toString(),i=new a.Y("5e-"+s).toString(),r=a.Y.stringAdd(i,L);let o=a.Y.stringDiv(r,"1",e);"-"===o[0]&&(o=void 0),V=this.parseNumber(o)}const F="BOTH"!==this.safeString(e,"positionSide");return{info:e,id:void 0,symbol:i,timestamp:x,datetime:this.iso8601(x),initialMargin:d,initialMarginPercentage:this.parseNumber(h),maintenanceMargin:u,maintenanceMarginPercentage:T,entryPrice:f,notional:v,leverage:this.parseNumber(r),unrealizedPnl:I,contracts:b,contractSize:D,marginRatio:B,liquidationPrice:V,markPrice:void 0,collateral:_,marginMode:A,side:N,hedged:F,percentage:R}}parsePositionRisk(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeString(t,"symbol"),r=this.safeString(e,"isolatedMargin"),o=this.safeDict(this.options,"leverageBrackets",{}),n=this.safeList(o,i,[]),d=this.safeString2(e,"notional","notionalValue"),h=a.Y.stringAbs(d);let c;for(let e=0;e<n.length;e++){const t=n[e];if(a.Y.stringLt(h,t[0]))break;c=t[1]}const l=this.parseNumber(h),u=a.Y.stringAbs(this.safeString(e,"positionAmt")),p=this.parseNumber(u),f=this.safeString(e,"unRealizedProfit"),m=this.parseNumber(f),g=this.omitZero(this.safeString(e,"liquidationPrice")),v=this.parseNumber(g);let y,w,b=this.safeString(e,"marginType");void 0===b&&void 0!==r&&(b=a.Y.stringEq(r,"0")?"cross":"isolated"),a.Y.stringGt(d,"0")?w="long":a.Y.stringLt(d,"0")&&(w="short");const S=this.safeString(e,"entryPrice"),k=this.parseNumber(S),O=this.safeValue(t,"contractSize"),T=this.numberToString(O),P="notional"in e;if("cross"===b){const e=this.safeDict(t,"precision",{}),s=this.safeString(e,"base"),i=this.safeString2(e,"quote","price");if(!(void 0===s&&void 0===i))if(P){let t,s=S;"short"===w?(t=a.Y.stringAdd("1",c),s=a.Y.stringMul("-1",s)):t=a.Y.stringAdd("-1",c);const i=a.Y.stringMul(g,t),r=a.Y.stringAdd(i,s),o=this.precisionFromString(this.safeString2(e,"quote","price"));void 0!==o&&(y=a.Y.stringDiv(a.Y.stringMul(r,u),"1",o))}else{let t,s=S;"short"===w?t=a.Y.stringSub("1",c):(t=a.Y.stringSub("-1",c),s=a.Y.stringMul("-1",s));const i=a.Y.stringMul(u,T),r=a.Y.stringSub(a.Y.stringDiv("1",s),a.Y.stringDiv(t,g)),o=this.precisionFromString(this.safeString(e,"base"));void 0!==o&&(y=a.Y.stringDiv(a.Y.stringMul(i,r),"1",o))}}else y=this.safeString(e,"isolatedMargin");y=void 0===y?"0":y;const I=this.parseNumber(y),x=this.parseNumber(this.omitZero(this.safeString(e,"markPrice")));let A=this.safeInteger(e,"updateTime");0===A&&(A=void 0);const M=this.parseNumber(c);let C=a.Y.stringMul(c,h);void 0===C&&(C=this.safeString(e,"maintMargin"));const E=this.parseNumber(C);let _,B;const N=this.safeString(e,"leverage");if(void 0!==N){const e=parseInt(N),t=this.isRoundNumber(1e3%e);B=a.Y.stringDiv("1",N,8),t||(B=a.Y.stringAdd(B,"1e-8"));const s=a.Y.stringMul(h,B);_=a.Y.stringDiv(s,"1",8)}else{_=this.safeString(e,"initialMargin");const t=a.Y.stringMul(_,"1");B=a.Y.stringDiv(t,h,8)}let R,L;a.Y.stringEquals(y,"0")||(R=this.parseNumber(a.Y.stringDiv(a.Y.stringAdd(a.Y.stringDiv(C,y),"5e-5"),"1",4)),L=this.parseNumber(a.Y.stringMul(a.Y.stringDiv(f,_,4),"100")));const V="BOTH"!==this.safeString(e,"positionSide");return{info:e,id:void 0,symbol:i,contracts:p,contractSize:O,unrealizedPnl:m,leverage:this.parseNumber(N),liquidationPrice:v,collateral:I,notional:l,markPrice:x,entryPrice:k,timestamp:A,initialMargin:this.parseNumber(_),initialMarginPercentage:this.parseNumber(B),maintenanceMargin:E,maintenanceMarginPercentage:M,marginRatio:R,datetime:this.iso8601(A),marginMode:b,marginType:b,side:w,hedged:V,percentage:L,stopLossPrice:void 0,takeProfitPrice:void 0}}async loadLeverageBrackets(e=!1,t={}){await this.loadMarkets();if(void 0===this.safeDict(this.options,"leverageBrackets")||e){const e=this.safeString(this.options,"defaultType","future"),s=this.safeString(t,"type",e),i=this.omit(t,"type");let a,o,n;if([a,t]=this.handleSubTypeAndParams("loadLeverageBrackets",void 0,t,"linear"),[o,t]=this.handleOptionAndParams2(t,"loadLeverageBrackets","papi","portfolioMargin",!1),this.isLinear(s,a))n=o?await this.papiGetUmLeverageBracket(i):await this.fapiPrivateGetLeverageBracket(i);else{if(!this.isInverse(s,a))throw new r.NotSupported(this.id+" loadLeverageBrackets() supports linear and inverse contracts only");n=o?await this.papiGetCmLeverageBracket(i):await this.dapiPrivateV2GetLeverageBracket(i)}this.options.leverageBrackets={};for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s,void 0,void 0,"contract"),r=this.safeList(t,"brackets",[]),a=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString2(t,"notionalFloor","qtyFloor"),i=this.safeString(t,"maintMarginRatio");a.push([s,i])}this.options.leverageBrackets[i]=a}}return this.options.leverageBrackets}async fetchLeverageTiers(e=void 0,t={}){let s,i,a,o;if(await this.loadMarkets(),[s,t]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t),[i,t]=this.handleSubTypeAndParams("fetchLeverageTiers",void 0,t,"linear"),[a,t]=this.handleOptionAndParams2(t,"fetchLeverageTiers","papi","portfolioMargin",!1),this.isLinear(s,i))o=a?await this.papiGetUmLeverageBracket(t):await this.fapiPrivateGetLeverageBracket(t);else{if(!this.isInverse(s,i))throw new r.NotSupported(this.id+" fetchLeverageTiers() supports linear and inverse contracts only");o=a?await this.papiGetCmLeverageBracket(t):await this.dapiPrivateV2GetLeverageBracket(t)}return this.parseLeverageTiers(o,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeList(e,"brackets",[]),r=[];for(let e=0;e<i.length;e++){const s=i[e];r.push({tier:this.safeNumber(s,"bracket"),currency:t.quote,minNotional:this.safeNumber2(s,"notionalFloor","qtyFloor"),maxNotional:this.safeNumber2(s,"notionalCap","qtyCap"),maintenanceMarginRate:this.safeNumber(s,"maintMarginRatio"),maxLeverage:this.safeNumber(s,"initialLeverage"),info:s})}return r}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.option)throw new r.NotSupported(this.id+" fetchPosition() supports option markets only");const i={symbol:s.id},a=await this.eapiPrivateGetPosition(this.extend(i,t));return this.parsePosition(a[0],s)}async fetchOptionPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new r.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;i=this.market(t),s.symbol=i.id}const a=await this.eapiPrivateGetPosition(this.extend(s,t)),o=[];for(let e=0;e<a.length;e++)o.push(this.parsePosition(a[e],i));return this.filterByArrayPositions(o,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeStringLower(e,"side");let o=this.safeString(e,"quantity");"long"!==r&&(o=a.Y.stringMul("-1",o));const n=this.safeInteger(e,"time");return this.safePosition({info:e,id:void 0,symbol:i,entryPrice:this.safeNumber(e,"entryPrice"),markPrice:this.safeNumber(e,"markPrice"),notional:this.safeNumber(e,"markValue"),collateral:this.safeNumber(e,"positionCost"),unrealizedPnl:this.safeNumber(e,"unrealizedPNL"),side:r,contracts:this.parseNumber(o),contractSize:void 0,timestamp:n,datetime:this.iso8601(n),hedged:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,liquidationPrice:void 0,marginRatio:void 0,marginMode:void 0,percentage:void 0})}async fetchPositions(e=void 0,t={}){let s;if([s,t]=this.handleOptionAndParams(t,"fetchPositions","method"),void 0===s){s=void 0===this.safeDict(this.options,"fetchPositions")?this.safeString(this.options,"fetchPositions","positionRisk"):"positionRisk"}if("positionRisk"===s)return await this.fetchPositionsRisk(e,t);if("account"===s)return await this.fetchAccountPositions(e,t);if("option"===s)return await this.fetchOptionPositions(e,t);throw new r.NotSupported(this.id+'.options["fetchPositions"]["method"] or params["method"] = "'+s+'" is invalid, please choose between "account", "positionRisk" and "option"')}async fetchAccountPositions(e=void 0,t={}){if(void 0!==e&&!Array.isArray(e))throw new r.ArgumentsRequired(this.id+" fetchPositions() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);const s=this.safeString(this.options,"defaultType","future"),i=this.safeString(t,"type",s);let a,o,n,d;if(t=this.omit(t,"type"),[a,t]=this.handleSubTypeAndParams("fetchAccountPositions",void 0,t,"linear"),[o,t]=this.handleOptionAndParams2(t,"fetchAccountPositions","papi","portfolioMargin",!1),this.isLinear(i,a))if(o)n=await this.papiGetUmAccount(t);else{let e;[e,t]=this.handleOptionAndParams(t,"fetchAccountPositions","useV2",!1),n=e?await this.fapiPrivateV2GetAccount(t):await this.fapiPrivateV3GetAccount(t)}else{if(!this.isInverse(i,a))throw new r.NotSupported(this.id+" fetchPositions() supports linear and inverse contracts only");n=o?await this.papiGetCmAccount(t):await this.dapiPrivateGetAccount(t)}[d,t]=this.handleOptionAndParams(t,"fetchAccountPositions","filterClosed",!1);const h=this.parseAccountPositions(n,d);return e=this.marketSymbols(e),this.filterByArrayPositions(h,"symbol",e,!1)}async fetchPositionsRisk(e=void 0,t={}){if(void 0!==e&&!Array.isArray(e))throw new r.ArgumentsRequired(this.id+" fetchPositionsRisk() requires an array argument for symbols");await this.loadMarkets(),await this.loadLeverageBrackets(!1,t);const s={};let i="future";i=this.safeString(this.options,"defaultType",i);const o=this.safeString(t,"type",i);let n,d,h;if([n,t]=this.handleSubTypeAndParams("fetchPositionsRisk",void 0,t,"linear"),[d,t]=this.handleOptionAndParams2(t,"fetchPositionsRisk","papi","portfolioMargin",!1),t=this.omit(t,"type"),this.isLinear(o,n))if(d)h=await this.papiGetUmPositionRisk(this.extend(s,t));else{let e;[e,t]=this.handleOptionAndParams(t,"fetchPositionsRisk","useV2",!1),t=this.extend(s,t),h=e?await this.fapiPrivateV2GetPositionRisk(t):await this.fapiPrivateV3GetPositionRisk(t)}else{if(!this.isInverse(o,n))throw new r.NotSupported(this.id+" fetchPositionsRisk() supports linear and inverse contracts only");h=d?await this.papiGetCmPositionRisk(this.extend(s,t)):await this.dapiPrivateGetPositionRisk(this.extend(s,t))}const c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"entryPrice");a.Y.stringGt(s,"0")&&c.push(this.parsePositionRisk(h[e]))}return e=this.marketSymbols(e),this.filterByArrayPositions(c,"symbol",e,!1)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();let o,n,d={incomeType:"FUNDING_FEE"};if(void 0!==e&&(a=this.market(e),d.symbol=a.id,!a.swap))throw new r.NotSupported(this.id+" fetchFundingHistory() supports swap contracts only");[o,i]=this.handleSubTypeAndParams("fetchFundingHistory",a,i,"linear"),[n,i]=this.handleOptionAndParams2(i,"fetchFundingHistory","papi","portfolioMargin",!1),[d,i]=this.handleUntilOption("endTime",d,i),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s);const h=this.safeString2(this.options,"fetchFundingHistory","defaultType","future"),c=this.safeString(i,"type",h);let l;if(i=this.omit(i,"type"),this.isLinear(c,o))l=n?await this.papiGetUmIncome(this.extend(d,i)):await this.fapiPrivateGetIncome(this.extend(d,i));else{if(!this.isInverse(c,o))throw new r.NotSupported(this.id+" fetchFundingHistory() supports linear and inverse contracts only");l=n?await this.papiGetCmIncome(this.extend(d,i)):await this.dapiPrivateGetIncome(this.extend(d,i))}return this.parseIncomes(l,a,t,s)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new r.BadRequest(this.id+" leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t),a={symbol:i.id,leverage:e};let o,n;if([o,s]=this.handleOptionAndParams2(s,"setLeverage","papi","portfolioMargin",!1),i.linear)n=o?await this.papiPostUmLeverage(this.extend(a,s)):await this.fapiPrivatePostLeverage(this.extend(a,s));else{if(!i.inverse)throw new r.NotSupported(this.id+" setLeverage() supports linear and inverse contracts only");n=o?await this.papiPostCmLeverage(this.extend(a,s)):await this.dapiPrivatePostLeverage(this.extend(a,s))}return n}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("CROSS"===(e=e.toUpperCase())&&(e="CROSSED"),"ISOLATED"!==e&&"CROSSED"!==e)throw new r.BadRequest(this.id+" marginMode must be either isolated or cross");await this.loadMarkets();const i=this.market(t),a={symbol:i.id,marginType:e};let o;try{if(i.linear)o=await this.fapiPrivatePostMarginType(this.extend(a,s));else{if(!i.inverse)throw new r.NotSupported(this.id+" setMarginMode() supports linear and inverse contracts only");o=await this.dapiPrivatePostMarginType(this.extend(a,s))}}catch(e){if(!(e instanceof r.MarginModeAlreadySet))throw e;if(this.safeBool(this.options,"throwMarginModeAlreadySet",!1))throw e;o={code:-4046,msg:"No need to change margin type."}}return o}async setPositionMode(e,t=void 0,s={}){const i=this.safeString(this.options,"defaultType","future"),a=this.safeString(s,"type",i);let o,n,d;s=this.omit(s,["type"]),[o,s]=this.handleSubTypeAndParams("setPositionMode",void 0,s),[n,s]=this.handleOptionAndParams2(s,"setPositionMode","papi","portfolioMargin",!1),d=e?"true":"false";const h={dualSidePosition:d};let c;if(this.isInverse(a,o))c=n?await this.papiPostCmPositionSideDual(this.extend(h,s)):await this.dapiPrivatePostPositionSideDual(this.extend(h,s));else{if(!this.isLinear(a,o))throw new r.BadRequest(this.id+" setPositionMode() supports linear and inverse contracts only");c=n?await this.papiPostUmPositionSideDual(this.extend(h,s)):await this.fapiPrivatePostPositionSideDual(this.extend(h,s))}return c}async fetchLeverages(e=void 0,t={}){let s,i,a,o;if(await this.loadMarkets(),await this.loadLeverageBrackets(!1,t),[s,t]=this.handleMarketTypeAndParams("fetchLeverages",void 0,t),[i,t]=this.handleSubTypeAndParams("fetchLeverages",void 0,t,"linear"),[a,t]=this.handleOptionAndParams2(t,"fetchLeverages","papi","portfolioMargin",!1),this.isLinear(s,i))o=a?await this.papiGetUmAccount(t):await this.fapiPrivateGetSymbolConfig(t);else{if(!this.isInverse(s,i))throw new r.NotSupported(this.id+" fetchLeverages() supports linear and inverse contracts only");o=a?await this.papiGetCmAccount(t):await this.dapiPrivateGetAccount(t)}let n=this.safeList(o,"positions",[]);return Array.isArray(o)&&(n=o),this.parseLeverages(n,e,"symbol")}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeBool(e,"isolated");let r;void 0!==i&&(r=i?"isolated":"cross");const a=this.safeStringLower(e,"marginType");void 0!==a&&(r="crossed"===a?"cross":"isolated");const o=this.safeStringLower(e,"positionSide");let n,d;const h=this.safeInteger(e,"leverage");return void 0===o||"both"===o?(n=h,d=h):"long"===o?n=h:"short"===o&&(d=h),{info:e,symbol:this.safeSymbol(s,t),marginMode:r,longLeverage:n,shortLeverage:d}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=void 0===e?void 0:this.market(e);let o;if([o,i]=this.handleMarketTypeAndParams("fetchSettlementHistory",a,i),"option"!==o)throw new r.NotSupported(this.id+" fetchSettlementHistory() supports option markets only");const n={};void 0!==e&&(e=a.symbol,n.underlying=a.baseId+a.quoteId),void 0!==t&&(n.startTime=t),void 0!==s&&(n.limit=s);const d=await this.eapiPublicGetExerciseHistory(this.extend(n,i)),h=this.parseSettlements(d,a),c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchMySettlementHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=void 0===e?void 0:this.market(e);let o;if([o,i]=this.handleMarketTypeAndParams("fetchMySettlementHistory",a,i),"option"!==o)throw new r.NotSupported(this.id+" fetchMySettlementHistory() supports option markets only");const n={};void 0!==e&&(n.symbol=a.id),void 0!==t&&(n.startTime=t),void 0!==s&&(n.limit=s);const d=await this.eapiPrivateGetExerciseRecord(this.extend(n,i)),h=this.parseSettlements(d,a),c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,a.symbol,t,s)}parseSettlement(e,t){const s=this.safeInteger2(e,"expiryDate","createDate"),i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber2(e,"realStrikePrice","exercisePrice"),timestamp:s,datetime:this.iso8601(s)}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++)s.push(this.parseSettlement(e[i],t));return s}async fetchLedgerEntry(e,t=void 0,s={}){let i;await this.loadMarkets(),[i,s]=this.handleMarketTypeAndParams("fetchLedgerEntry",void 0,s);const a={recordId:e,type:i};if("option"!==i)throw new r.BadRequest(this.id+" fetchLedgerEntry () can only be used for type option");return await this.fetchLedger(t,void 0,void 0,this.extend(a,s))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a,o,n,d=!1;if([d,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),d)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i);void 0!==e&&(n=this.currency(e));const h={};[a,i]=this.handleMarketTypeAndParams("fetchLedger",void 0,i),[o,i]=this.handleSubTypeAndParams("fetchLedger",void 0,i),void 0!==t&&(h.startTime=t),void 0!==s&&(h.limit=s);const c=this.safeInteger(i,"until");let l,u;if(void 0!==c&&(i=this.omit(i,"until"),h.endTime=c),[l,i]=this.handleOptionAndParams2(i,"fetchLedger","papi","portfolioMargin",!1),"option"===a)this.checkRequiredArgument("fetchLedger",e,"code"),h.currency=n.id,u=await this.eapiPrivateGetBill(this.extend(h,i));else if(this.isLinear(a,o))u=l?await this.papiGetUmIncome(this.extend(h,i)):await this.fapiPrivateGetIncome(this.extend(h,i));else{if(!this.isInverse(a,o))throw new r.NotSupported(this.id+" fetchLedger() supports contract wallets only");u=l?await this.papiGetCmIncome(this.extend(h,i)):await this.dapiPrivateGetIncome(this.extend(h,i))}return this.parseLedger(u,n,t,s)}parseLedgerEntry(e,t=void 0){let s,i=this.safeString2(e,"amount","income");a.Y.stringLe(i,"0")?(s="out",i=a.Y.stringMul("-1",i)):s="in";const r=this.safeString(e,"asset"),o=this.safeInteger2(e,"createDate","time"),n=this.safeString2(e,"type","incomeType");return{id:this.safeString2(e,"id","tranId"),direction:s,account:void 0,referenceAccount:void 0,referenceId:this.safeString(e,"tradeId"),type:this.parseLedgerEntryType(n),currency:this.safeCurrencyCode(r,t),amount:this.parseNumber(i),timestamp:o,datetime:this.iso8601(o),before:void 0,after:void 0,status:void 0,fee:void 0,info:e}}parseLedgerEntryType(e){return this.safeString({FEE:"fee",FUNDING_FEE:"fee",OPTIONS_PREMIUM_FEE:"fee",POSITION_LIMIT_INCREASE_FEE:"fee",CONTRACT:"trade",REALIZED_PNL:"trade",TRANSFER:"transfer",CROSS_COLLATERAL_TRANSFER:"transfer",INTERNAL_TRANSFER:"transfer",COIN_SWAP_DEPOSIT:"deposit",COIN_SWAP_WITHDRAW:"withdrawal",OPTIONS_SETTLE_PROFIT:"settlement",DELIVERED_SETTELMENT:"settlement",WELCOME_BONUS:"cashback",CONTEST_REWARD:"cashback",COMMISSION_REBATE:"rebate",API_REBATE:"rebate",REFERRAL_KICKBACK:"referral",COMMISSION:"commission"},e,e)}sign(e,t="public",s="GET",i={},a=void 0,o=void 0){if(!(t in this.urls.api))throw new r.NotSupported(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let l=this.urls.api[t];if(l+="/"+e,"historicalTrades"===e){if(!this.apiKey)throw new r.AuthenticationError(this.id+" historicalTrades endpoint requires `apiKey` credential");a={"X-MBX-APIKEY":this.apiKey}}if("userDataStream"===e||"listenKey"===e){if(!this.apiKey)throw new r.AuthenticationError(this.id+" userDataStream endpoint requires `apiKey` credential");a={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},"GET"!==s&&(o=this.urlencode(i))}else if("private"===t||"eapiPrivate"===t||"sapi"===t&&"system/status"!==e||"sapiV2"===t||"sapiV3"===t||"sapiV4"===t||"dapiPrivate"===t||"dapiPrivateV2"===t||"fapiPrivate"===t||"fapiPrivateV2"===t||"fapiPrivateV3"===t||"papi"===t&&"ping"!==e){if(this.checkRequiredCredentials(),"POST"===s&&("order"===e||"sor/order"===e)){if(void 0===this.safeString(i,"newClientOrderId")){const e=t.indexOf("sapi")>-1||"private"===t,s=e?"spot":"future",r=e?"x-R4BD3S82":"x-xcKtGhcu",a=this.safeDict(this.options,"broker",{}),o=this.safeString(a,s,r);i.newClientOrderId=o+this.uuid22()}}let r;if("batchOrders"===e&&"POST"===s){const e=this.safeValue(i,"batchOrders"),t=this.json(e);i.batchOrders=t}const u=this.safeInteger(this.options,"recvWindow");let p=this.extend({timestamp:this.nonce()},i);void 0!==u&&(p.recvWindow=u);const f=this.safeInteger(i,"recvWindow");if(void 0!==f&&(p.recvWindow=f),"sapi"===t&&"asset/dust"===e)r=this.urlencodeWithArrayRepeat(p);else if("batchOrders"===e||e.indexOf("sub-account")>=0||"capital/withdraw/apply"===e||e.indexOf("staking")>=0||e.indexOf("simple-earn")>=0)if("DELETE"===s&&"batchOrders"===e){const e=this.safeList(p,"orderidlist",[]),t=this.safeList(p,"origclientorderidlist",[]);p=this.omit(p,["orderidlist","origclientorderidlist"]),r=this.rawencode(p);const s=e.length,i=t.length;s>0&&(r=r+"&orderidlist=%5B"+e.join("%2C")+"%5D"),i>0&&(r=r+"&origclientorderidlist=%5B"+t.join("%2C")+"%5D")}else r=this.rawencode(p);else r=this.urlencode(p);let m;m=this.secret.indexOf("PRIVATE KEY")>-1?this.secret.length>120?this.encodeURIComponent((0,d.n)(r,this.secret,n.s)):this.encodeURIComponent((0,h.q4)(this.encode(r),this.secret,c.ev)):this.hmac(this.encode(r),this.encode(this.secret),n.s),r+="&signature="+m,a={"X-MBX-APIKEY":this.apiKey},"GET"===s||"DELETE"===s?l+="?"+r:(o=r,a["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(l+="?"+this.urlencode(i));return{url:l,method:s,body:o,headers:a}}getExceptionsByUrl(e,t){let s;const i=void 0!==this.hostname?this.hostname:"binance.com";if(e.startsWith("https://api."+i+"/")?s="spot":e.startsWith("https://dapi."+i+"/")?s="inverse":e.startsWith("https://fapi."+i+"/")?s="linear":e.startsWith("https://eapi."+i+"/")?s="option":e.startsWith("https://papi."+i+"/")&&(s="portfoliomargin"),void 0!==s){const e=this.safeDict(this.exceptions,s,{});return this.safeDict(e,t,{})}return{}}handleErrors(e,t,s,i,o,n,d,h,c){if(418===e||429===e)throw new r.DDoSProtection(this.id+" "+e.toString()+" "+t+" "+n);if(e>=400){if(n.indexOf("Price * QTY is zero or less")>=0)throw new r.InvalidOrder(this.id+" order cost = amount * price is zero or less "+n);if(n.indexOf("LOT_SIZE")>=0)throw new r.InvalidOrder(this.id+" order amount should be evenly divisible by lot size "+n);if(n.indexOf("PRICE_FILTER")>=0)throw new r.InvalidOrder(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+n)}if(void 0===d)return;const l=this.safeBool(d,"success",!0);if(!l){const e=this.safeString(d,"msg");let t;if(void 0!==e){try{t=JSON.parse(e)}catch(e){t=void 0}void 0!==t&&(d=t)}}const u=this.safeString(d,"msg");void 0!==u&&(this.throwExactlyMatchedException(this.getExceptionsByUrl(s,"exact"),u,this.id+" "+u),this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.getExceptionsByUrl(s,"broad"),u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const p=this.safeString(d,"code");if(void 0!==p){if("200"===p||a.Y.stringEquals(p,"0"))return;if("-2015"===p&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new r.DDoSProtection(this.id+" "+n);const e=this.id+" "+n;if("No need to change margin type."===u)throw new r.MarginModeAlreadySet(e);throw this.throwExactlyMatchedException(this.getExceptionsByUrl(s,"exact"),p,e),this.throwExactlyMatchedException(this.exceptions.exact,p,e),new r.ExchangeError(e)}if(!l)throw new r.ExchangeError(this.id+" "+n);if(Array.isArray(d)){if(1===d.length){const e=d[0],t=this.safeString(e,"code");void 0!==t&&(this.throwExactlyMatchedException(this.getExceptionsByUrl(s,"exact"),t,this.id+" "+n),this.throwExactlyMatchedException(this.exceptions.exact,t,this.id+" "+n))}}}calculateRateLimiterCost(e,t,s,i,r={}){if("noCoin"in r&&!("coin"in i))return r.noCoin;if("noSymbol"in r&&!("symbol"in i))return r.noSymbol;if("noPoolId"in r&&!("poolId"in i))return r.noPoolId;if("byLimit"in r&&"limit"in i){const e=i.limit,t=r.byLimit;for(let s=0;s<t.length;s++){const i=t[s];if(e<=i[0])return i[1]}}return this.safeValue(r,"cost",1)}async request(e,t="public",s="GET",i={},r=void 0,a=void 0,o={}){const n=await this.fetch2(e,t,s,i,r,a,o);return"private"===t&&(this.options.hasAlreadyAuthenticatedSuccessfully=!0),n}async modifyMarginHelper(e,t,s,i={}){let a=this.safeString(this.options,"defaultType","future");"spot"===a&&(a="future");const o=this.safeString(i,"type",a);if("margin"===o||"spot"===o)throw new r.NotSupported(this.id+" add / reduce margin only supported with type future or delivery");await this.loadMarkets();const n=this.market(e);t=this.amountToPrecision(e,t);const d={type:s,symbol:n.id,amount:t};let h,c;return n.linear?(c=n.quote,h=await this.fapiPrivatePostPositionMargin(this.extend(d,i))):(c=n.base,h=await this.dapiPrivatePostPositionMargin(this.extend(d,i))),this.extend(this.parseMarginModification(h,n),{code:c})}parseMarginModification(e,t=void 0){const s=this.safeInteger(e,"type"),i=this.safeString(e,"code"),r=this.safeString(e,"symbol"),a=this.safeInteger(e,"time"),o=void 0===i,n="200"===i;return{info:e,symbol:(t=this.safeMarket(r,t,void 0,"swap")).symbol,type:1===s?"add":"reduce",marginMode:"isolated",amount:this.safeNumber(e,"amount"),code:this.safeString(e,"asset"),total:void 0,status:n||o?"ok":"failed",timestamp:a,datetime:this.iso8601(a)}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,2,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,1,s)}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();const s={asset:this.currency(e).id},i=await this.sapiGetMarginInterestRateHistory(this.extend(s,t)),r=this.safeDict(i,0);return this.parseBorrowRate(r)}async fetchIsolatedBorrowRate(e,t={}){const s={symbol:e},i=await this.fetchIsolatedBorrowRates(this.extend(s,t));return this.safeDict(i,e)}async fetchIsolatedBorrowRates(e={}){await this.loadMarkets();const t={},s=this.safeString(e,"symbol");if(e=this.omit(e,"symbol"),void 0!==s){const e=this.market(s);t.symbol=e.id}const i=await this.sapiGetMarginIsolatedMarginData(this.extend(t,e));return this.parseIsolatedBorrowRates(i)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===s)s=93;else if(s>93)throw new r.BadRequest(this.id+" fetchBorrowRateHistory() limit parameter cannot exceed 92");const a={asset:this.currency(e).id,limit:s};if(void 0!==t){a.startTime=t;const e=this.sum(t,864e5*s)-1,i=this.milliseconds();a.endTime=Math.min(e,i)}const o=await this.sapiGetMarginInterestRateHistory(this.extend(a,i));return this.parseBorrowRateHistory(o,e,t,s)}parseBorrowRateHistory(e,t,s,i){const r=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.parseBorrowRate(s);r.push(i)}const a=this.sortBy(r,"timestamp");return this.filterByCurrencySinceLimit(a,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"asset");return{currency:this.safeCurrencyCode(i,t),rate:this.safeNumber(e,"dailyInterestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}parseIsolatedBorrowRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"spot");const i=this.safeList(e,"data"),r=this.safeDict(i,0),a=this.safeDict(i,1);return{info:e,symbol:this.safeString(t,"symbol"),base:this.safeString(r,"coin"),baseRate:this.safeNumber(r,"dailyInterest"),quote:this.safeString(a,"coin"),quoteRate:this.safeNumber(a,"dailyInterest"),period:864e5,timestamp:void 0,datetime:void 0}}async createGiftCode(e,t,s={}){await this.loadMarkets();const i={token:this.currency(e).id,amount:t},r=await this.sapiPostGiftcardCreateCode(this.extend(i,s)),a=this.safeDict(r,"data"),o=this.safeString(a,"code");return{info:r,id:this.safeString(a,"referenceNo"),code:o,currency:e,amount:t}}async redeemGiftCode(e,t={}){const s={code:e};return await this.sapiPostGiftcardRedeemCode(this.extend(s,t))}async verifyGiftCode(e,t={}){const s={referenceNo:e};return await this.sapiGetGiftcardVerify(this.extend(s,t))}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),[a,r]=this.handleOptionAndParams2(r,"fetchBorrowInterest","papi","portfolioMargin",!1);let o,n,d={};if(void 0!==e){const t=this.currency(e);d.asset=t.id}void 0!==s&&(d.startTime=s),void 0!==i&&(d.size=i),[d,r]=this.handleUntilOption("endTime",d,r),a?n=await this.papiGetMarginMarginInterestHistory(this.extend(d,r)):(void 0!==t&&(o=this.market(t),d.isolatedSymbol=o.id),n=await this.sapiGetMarginInterestHistory(this.extend(d,r)));const h=this.safeList(n,"rows"),c=this.parseBorrowInterests(h,o);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"isolatedSymbol"),i=this.safeInteger(e,"interestAccuredTime");return{account:void 0===s?"cross":s,symbol:s,marginMode:void 0===s?"cross":"isolated",currency:this.safeCurrencyCode(this.safeString(e,"asset")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"principal"),timestamp:i,datetime:this.iso8601(i),info:e}}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={asset:i.id,amount:this.currencyToPrecision(e,t)};let a,o;return[o,s]=this.handleOptionAndParams2(s,"repayCrossMargin","papi","portfolioMargin",!1),o?a=await this.papiPostRepayLoan(this.extend(r,s)):(r.isIsolated="FALSE",r.type="REPAY",a=await this.sapiPostMarginBorrowRepay(this.extend(r,s))),this.parseMarginLoan(a,i)}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=this.market(e),o={asset:r.id,amount:this.currencyToPrecision(t,s),symbol:a.id,isIsolated:"TRUE",type:"REPAY"},n=await this.sapiPostMarginBorrowRepay(this.extend(o,i));return this.parseMarginLoan(n,r)}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={asset:i.id,amount:this.currencyToPrecision(e,t)};let a,o;return[o,s]=this.handleOptionAndParams2(s,"borrowCrossMargin","papi","portfolioMargin",!1),o?a=await this.papiPostMarginLoan(this.extend(r,s)):(r.isIsolated="FALSE",r.type="BORROW",a=await this.sapiPostMarginBorrowRepay(this.extend(r,s))),this.parseMarginLoan(a,i)}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=this.market(e),o={asset:r.id,amount:this.currencyToPrecision(t,s),symbol:a.id,isIsolated:"TRUE",type:"BORROW"},n=await this.sapiPostMarginBorrowRepay(this.extend(o,i));return this.parseMarginLoan(n,r)}parseMarginLoan(e,t=void 0){return{id:this.safeInteger(e,"tranId"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,a={}){if("1m"===t)throw new r.BadRequest(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOpenInterestHistory","paginate",!1),o)return await this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory",e,s,i,t,a,500);const n=this.market(e),d={period:this.safeString(this.timeframes,t,t)};void 0!==i&&(d.limit=i);d[n.linear?"symbol":"pair"]=n.id,n.inverse&&(d.contractType=this.safeString(a,"contractType","CURRENT_QUARTER")),void 0!==s&&(d.startTime=s);const h=this.safeInteger(a,"until"),c=this.safeInteger(a,"endTime",h);if(a=this.omit(a,["endTime","until"]),c)d.endTime=c;else if(s){void 0===i&&(i=30);const e=this.parseTimeframe(t);d.endTime=this.sum(s,e*i*1e3)}let l;return l=n.inverse?await this.dapiDataGetOpenInterestHist(this.extend(d,a)):await this.fapiDataGetOpenInterestHist(this.extend(d,a)),this.parseOpenInterests(l,n,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e),i={};if(s.option){if(i.underlyingAsset=s.baseId,void 0===s.expiry)throw new r.NotSupported(this.id+" fetchOpenInterest does not support "+e);i.expiration=this.yymmdd(s.expiry)}else i.symbol=s.id;let a;if(a=s.option?await this.eapiPublicGetOpenInterest(this.extend(i,t)):s.inverse?await this.dapiPublicGetOpenInterest(this.extend(i,t)):await this.fapiPublicGetOpenInterest(this.extend(i,t)),!s.option)return this.parseOpenInterest(a,s);{e=s.symbol;const t=this.parseOpenInterests(a,s);for(let s=0;s<t.length;s++){const i=t[s];if(i.symbol===e)return i}}}parseOpenInterest(e,t=void 0){const s=this.safeInteger2(e,"timestamp","time"),i=this.safeString(e,"symbol"),r=this.safeNumber2(e,"sumOpenInterest","openInterest"),a=this.safeNumber2(e,"sumOpenInterestValue","sumOpenInterestUsd");return this.safeOpenInterest({symbol:this.safeSymbol(i,t,void 0,"contract"),baseVolume:t.inverse?void 0:r,quoteVolume:a,openInterestAmount:r,openInterestValue:a,timestamp:s,datetime:this.iso8601(s),info:e},t)}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a,o,n,d,h=!1;if([h,i]=this.handleOptionAndParams(i,"fetchMyLiquidations","paginate"),h)return await this.fetchPaginatedCallIncremental("fetchMyLiquidations",e,t,s,i,"current",100);void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchMyLiquidations",a,i),[n,i]=this.handleSubTypeAndParams("fetchMyLiquidations",a,i,"linear"),[d,i]=this.handleOptionAndParams2(i,"fetchMyLiquidations","papi","portfolioMargin",!1);let c,l={};if("spot"!==o&&(l.autoCloseType="LIQUIDATION"),void 0!==a){const e=a.spot?"isolatedSymbol":"symbol";d||(l[e]=a.id)}if(void 0!==t&&(l.startTime=t),void 0!==s&&("spot"===o?l.size=s:l.limit=s),[l,i]=this.handleUntilOption("endTime",l,i),"spot"===o)c=d?await this.papiGetMarginForceOrders(this.extend(l,i)):await this.sapiGetMarginForceLiquidationRec(this.extend(l,i));else if("linear"===n)c=d?await this.papiGetUmForceOrders(this.extend(l,i)):await this.fapiPrivateGetForceOrders(this.extend(l,i));else{if("inverse"!==n)throw new r.NotSupported(this.id+" fetchMyLiquidations() does not support "+a.type+" markets");c=d?await this.papiGetCmForceOrders(this.extend(l,i)):await this.dapiPrivateGetForceOrders(this.extend(l,i))}const u=this.safeList(c,"rows",c);return this.parseLiquidations(u,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger2(e,"updatedTime","updateTime");return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.safeNumber(e,"executedQty"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"avgPrice"),baseValue:this.safeNumber(e,"cumBase"),quoteValue:this.safeNumber(e,"cumQuote"),timestamp:i,datetime:this.iso8601(i)})}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.eapiPublicGetMark(this.extend(i,t));return this.parseGreeks(r[0],s)}parseGreeks(e,t=void 0){const s=this.safeString(e,"symbol");return{symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,delta:this.safeNumber(e,"delta"),gamma:this.safeNumber(e,"gamma"),theta:this.safeNumber(e,"theta"),vega:this.safeNumber(e,"vega"),rho:void 0,bidSize:void 0,askSize:void 0,bidImpliedVolatility:this.safeNumber(e,"bidIV"),askImpliedVolatility:this.safeNumber(e,"askIV"),markImpliedVolatility:this.safeNumber(e,"markIV"),bidPrice:void 0,askPrice:void 0,markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,underlyingPrice:void 0,info:e}}async fetchTradingLimits(e=void 0,t={}){const s=await this.fetchMarkets(),i={};for(let t=0;t<s.length;t++){const r=s[t],a=r.symbol;(void 0===e||this.inArray(a,e))&&(i[a]=r.limits.amount)}return i}async fetchPositionMode(e=void 0,t={}){let s,i,a;if(void 0!==e&&(s=this.market(e)),[i,t]=this.handleSubTypeAndParams("fetchPositionMode",s,t),"linear"===i)a=await this.fapiPrivateGetPositionSideDual(t);else{if("inverse"!==i)throw new r.BadRequest(this.id+' fetchPositionMode requires either a symbol argument or params["subType"]');a=await this.dapiPrivateGetPositionSideDual(t)}return{info:a,hedged:this.safeBool(a,"dualSidePosition")}}async fetchMarginModes(e=void 0,t={}){let s,i,a;if(await this.loadMarkets(),void 0!==e&&(e=this.marketSymbols(e),s=this.market(e[0])),[i,t]=this.handleSubTypeAndParams("fetchMarginMode",s,t),"linear"===i)a=await this.fapiPrivateGetSymbolConfig(t);else{if("inverse"!==i)throw new r.BadRequest(this.id+" fetchMarginModes () supports linear and inverse subTypes only");a=await this.dapiPrivateGetAccount(t)}let o=this.safeList(a,"positions",[]);return Array.isArray(a)&&(o=a),this.parseMarginModes(o,e,"symbol","swap")}parseMarginMode(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeBool(e,"isolated");let r;void 0!==i&&(r=i?"isolated":"cross");const a=this.safeStringLower(e,"marginType");return void 0!==a&&(r="crossed"===a?"cross":"isolated"),{info:e,symbol:t.symbol,marginMode:r}}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.eapiPublicGetTicker(this.extend(i,t)),a=this.safeDict(r,0,{});return this.parseOption(a,void 0,s)}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"symbol");return{info:e,currency:void 0,symbol:(s=this.safeMarket(i,s)).symbol,timestamp:void 0,datetime:void 0,impliedVolatility:void 0,openInterest:void 0,bidPrice:this.safeNumber(e,"bidPrice"),askPrice:this.safeNumber(e,"askPrice"),midPrice:void 0,markPrice:void 0,lastPrice:this.safeNumber(e,"lastPrice"),underlyingPrice:this.safeNumber(e,"exercisePrice"),change:this.safeNumber(e,"priceChange"),percentage:this.safeNumber(e,"priceChangePercent"),baseVolume:this.safeNumber(e,"volume"),quoteVolume:void 0}}async fetchMarginAdjustmentHistory(e=void 0,t=void 0,s=void 0,i=void 0,a={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory () requires a symbol argument");const o=this.market(e),n=this.safeInteger(a,"until");a=this.omit(a,"until");const d={symbol:o.id};let h;if(void 0!==t&&(d.type="add"===t?1:2),void 0!==s&&(d.startTime=s),void 0!==i&&(d.limit=i),void 0!==n&&(d.endTime=n),o.linear)h=await this.fapiPrivateGetPositionMarginHistory(this.extend(d,a));else{if(!o.inverse)throw new r.BadRequest(this.id+"fetchMarginAdjustmentHistory () is not supported for markets of type "+o.type);h=await this.dapiPrivateGetPositionMarginHistory(this.extend(d,a))}const c=this.parseMarginModifications(h);return this.filterBySymbolSinceLimit(c,e,s,i)}async fetchConvertCurrencies(e={}){await this.loadMarkets();const t=await this.sapiGetConvertAssetInfo(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r);s[a]={info:i,id:r,code:a,networks:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(i,"fraction"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},created:void 0}}return s}async fetchConvertQuote(e,t,s=void 0,i={}){if(void 0===s)throw new r.ArgumentsRequired(this.id+" fetchConvertQuote() requires an amount argument");await this.loadMarkets();const a={fromAsset:e,toAsset:t,fromAmount:s},o=await this.sapiPostConvertGetQuote(this.extend(a,i)),n=this.currency(e),d=this.currency(t);return this.parseConversion(o,n,d)}async createConvertTrade(e,t,s,i=void 0,a={}){await this.loadMarkets();const o={};let n;if("BUSD"===t||"BUSD"===s){if(void 0===i)throw new r.ArgumentsRequired(this.id+" createConvertTrade() requires an amount argument");o.clientTranId=e,o.asset=t,o.targetAsset=s,o.amount=i,n=await this.sapiPostAssetConvertTransfer(this.extend(o,a))}else o.quoteId=e,n=await this.sapiPostConvertAcceptQuote(this.extend(o,a));const d=this.currency(t),h=this.currency(s);return this.parseConversion(n,d,h)}async fetchConvertTrade(e,t=void 0,s={}){await this.loadMarkets();const i={};let r;if("BUSD"===t){const a=864e5,o=this.milliseconds();if(void 0!==t){const e=this.currency(t);i.asset=e.id}i.tranId=e,i.startTime=o-a,i.endTime=o,r=await this.sapiGetAssetConvertTransferQueryByPage(this.extend(i,s))}else i.orderId=e,r=await this.sapiGetConvertOrderStatus(this.extend(i,s));let a=r;if("BUSD"===t){const e=this.safeList(r,"rows",[]);a=this.safeDict(e,0,{})}const o=this.safeString2(a,"deductedAsset","fromAsset"),n=this.safeString2(a,"targetAsset","toAsset");let d,h;return void 0!==o&&(d=this.currency(o)),void 0!==n&&(h=this.currency(n)),this.parseConversion(a,d,h)}async fetchConvertTradeHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={},o=2592e6,n=this.milliseconds();a.startTime=void 0!==t?t:n-o;const d=this.safeInteger2(i,"endTime","until");let h,c,l,u;if(a.endTime=void 0!==d?d:n,i=this.omit(i,"until"),"BUSD"===e){const t=this.currency(e);a.asset=t.id,void 0!==s&&(a.size=s),l="deductedAsset",u="targetAsset",c="rows",h=await this.sapiGetAssetConvertTransferQueryByPage(this.extend(a,i))}else{if(a.endTime-a.startTime>o)throw new r.BadRequest(this.id+" fetchConvertTradeHistory () the max interval between startTime and endTime is 30 days.");void 0!==s&&(a.limit=s),l="fromAsset",u="toAsset",c="list",h=await this.sapiGetConvertTradeFlow(this.extend(a,i))}const p=this.safeList(h,c,[]);return this.parseConversions(p,e,l,u,t,s)}parseConversion(e,t=void 0,s=void 0){const i=this.safeIntegerN(e,["time","validTimestamp","createTime"]),r=this.safeString2(e,"deductedAsset","fromAsset"),a=this.safeCurrencyCode(r,t),o=this.safeString2(e,"targetAsset","toAsset"),n=this.safeCurrencyCode(o,s);return{info:e,timestamp:i,datetime:this.iso8601(i),id:this.safeStringN(e,["tranId","orderId","quoteId"]),fromCurrency:a,fromAmount:this.safeNumber2(e,"deductedAmount","fromAmount"),toCurrency:n,toAmount:this.safeNumber2(e,"targetAmount","toAmount"),price:void 0,fee:void 0}}}},1510:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(3192);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/delivery/en/","https://binance-docs.github.io/apidocs/spot/en","https://developers.binance.com/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{fetchMarkets:["inverse"],defaultSubType:"inverse",leverageBrackets:void 0}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,3,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,4,s)}}},8228:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(3192);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"binanceus",name:"Binance US",countries:["US"],hostname:"binance.us",rateLimit:50,certified:!1,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{web:"https://www.binance.us",public:"https://api.binance.us/api/v3",private:"https://api.binance.us/api/v3",sapi:"https://api.binance.us/sapi/v1",sapiV2:"https://api.binance.us/sapi/v2",sapiV3:"https://api.binance.us/sapi/v3"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fetchMarkets:["spot"],defaultType:"spot",quoteOrderQty:!1},has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:void 0,option:!1,addMargin:!1,closeAllPositions:!1,closePosition:!1,createReduceOnlyOrder:!1,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1},api:{public:{get:{ping:1,time:1,exchangeInfo:10,trades:1,historicalTrades:5,aggTrades:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},klines:1,"ticker/price":{cost:1,noSymbol:2},avgPrice:1,"ticker/bookTicker":{cost:1,noSymbol:2},"ticker/24hr":{cost:1,noSymbol:40},ticker:{cost:2,noSymbol:100}}},private:{get:{account:10,"rateLimit/order":20,order:2,openOrders:{cost:3,noSymbol:40},myTrades:10,myPreventedMatches:10,allOrders:10,orderList:2,allOrderList:10,openOrderList:3},post:{order:1,"order/test":1,"order/cancelReplace":1,"order/oco":1},delete:{order:1,openOrders:1,orderList:1}},sapi:{get:{"system/status":1,"asset/assetDistributionHistory":1,"asset/query/trading-fee":1,"asset/query/trading-volume":1,"sub-account/spotSummary":1,"sub-account/status":1,"otc/coinPairs":1,"otc/orders/{orderId}":1,"otc/orders":1,"ocbs/orders":1,"capital/config/getall":1,"capital/withdraw/history":1,"fiatpayment/query/withdraw/history":1,"capital/deposit/address":1,"capital/deposit/hisrec":1,"fiatpayment/query/deposit/history":1,"capital/sub-account/deposit/address":1,"capital/sub-account/deposit/history":1,"asset/query/dust-logs":1,"asset/query/dust-assets":1,"marketing/referral/reward/history":1,"staking/asset":1,"staking/stakingBalance":1,"staking/history":1,"staking/stakingRewardsHistory":1,"custodian/balance":1,"custodian/supportedAssetList":1,"custodian/walletTransferHistory":1,"custodian/custodianTransferHistory":1,"custodian/openOrders":1,"custodian/order":1,"custodian/orderHistory":1,"custodian/tradeHistory":1,"custodian/settlementSetting":1,"custodian/settlementHistory":1,"cl/transferHistory":1,"apipartner/checkEligibility":1,"apipartner/rebateHistory":1},post:{"otc/quotes":1,"otc/orders":1,"fiatpayment/withdraw/apply":1,"capital/withdraw/apply":1,"asset/dust":10,"staking/stake":1,"staking/unstake":1,"custodian/walletTransfer":1,"custodian/custodianTransfer":1,"custodian/undoTransfer":1,"custodian/order":1,"custodian/ocoOrder":1,"cl/transfer":1},delete:{"custodian/cancelOrder":1,"custodian/cancelOrdersBySymbol":1,"custodian/cancelOcoOrder":1}},sapiV2:{get:{"cl/account":10,"cl/alertHistory":1}},sapiV3:{get:{accountStatus:1,apiTradingStatus:1,"sub-account/list":1,"sub-account/transfer/history":1,"sub-account/assets":1},post:{"sub-account/transfer":1}}}})}}},2171:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(3192),r=s(2079);class a extends i.A{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USDⓈ-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:["https://binance-docs.github.io/apidocs/futures/en/","https://binance-docs.github.io/apidocs/spot/en","https://developers.binance.com/en"]},has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:void 0,createStopMarketOrder:!0},options:{fetchMarkets:["linear"],defaultSubType:"linear",leverageBrackets:void 0,marginTypes:{},marginModes:{}},exceptions:{exact:{"-5021":r.InvalidOrder,"-5022":r.InvalidOrder,"-5028":r.InvalidOrder}}})}async transferIn(e,t,s={}){return await this.futuresTransfer(e,t,1,s)}async transferOut(e,t,s={}){return await this.futuresTransfer(e,t,2,s)}}},2480:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4619),r=s(2079),a=s(5147),o=s(4852),n=s(1579);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bingx",name:"BingX",countries:["US"],rateLimit:100,version:"v1",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!0,closePosition:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createStopLossOrder:!0,createTakeProfitOrder:!0,createTrailingAmountOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchLeverage:!0,fetchLiquidations:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!0,fetchPositions:!0,fetchPositionsHistory:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0},hostname:"bingx.com",urls:{logo:"https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg",api:{spot:"https://open-api.{hostname}/openApi",swap:"https://open-api.{hostname}/openApi",contract:"https://open-api.{hostname}/openApi",wallets:"https://open-api.{hostname}/openApi",user:"https://open-api.{hostname}/openApi",subAccount:"https://open-api.{hostname}/openApi",account:"https://open-api.{hostname}/openApi",copyTrading:"https://open-api.{hostname}/openApi",cswap:"https://open-api.{hostname}/openApi"},test:{swap:"https://open-api-vst.{hostname}/openApi"},www:"https://bingx.com/",doc:"https://bingx-api.github.io/docs/",referral:"https://bingx.com/invite/OHETOM"},fees:{tierBased:!0,spot:{feeSide:"get",maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},swap:{feeSide:"quote",maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},requiredCredentials:{apiKey:!0,secret:!0},api:{spot:{v1:{public:{get:{"server/time":1,"common/symbols":1,"market/trades":1,"market/depth":1,"market/kline":1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1}},private:{get:{"trade/query":1,"trade/openOrders":1,"trade/historyOrders":1,"trade/myTrades":2,"user/commissionRate":5,"account/balance":2},post:{"trade/order":2,"trade/cancel":2,"trade/batchOrders":5,"trade/order/cancelReplace":5,"trade/cancelOrders":5,"trade/cancelOpenOrders":5,"trade/cancelAllAfter":5}}},v2:{public:{get:{"market/depth":1,"market/kline":1}}},v3:{private:{get:{"get/asset/transfer":1,"asset/transfer":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1},post:{"post/asset/transfer":5}}}},swap:{v1:{public:{get:{"ticker/price":1,"market/historicalTrades":1}},private:{get:{"positionSide/dual":5,"market/markPriceKlines":1,"trade/batchCancelReplace":5,"trade/fullOrder":2},post:{"trade/cancelReplace":2,"positionSide/dual":5,"trade/closePosition":2}}},v2:{public:{get:{"server/time":1,"quote/contracts":1,"quote/price":1,"quote/depth":1,"quote/trades":1,"quote/premiumIndex":1,"quote/fundingRate":1,"quote/klines":1,"quote/openInterest":1,"quote/ticker":1,"quote/bookTicker":1}},private:{get:{"user/balance":2,"user/positions":2,"user/income":2,"trade/openOrders":2,"trade/openOrder":2,"trade/order":2,"trade/marginType":5,"trade/leverage":2,"trade/forceOrders":1,"trade/allOrders":2,"trade/allFillOrders":2,"user/income/export":2,"user/commissionRate":2,"quote/bookTicker":1},post:{"trade/order":2,"trade/batchOrders":2,"trade/closeAllPositions":2,"trade/cancelAllAfter":5,"trade/marginType":5,"trade/leverage":5,"trade/positionMargin":5,"trade/order/test":2},delete:{"trade/order":2,"trade/batchOrders":2,"trade/allOpenOrders":2}}},v3:{public:{get:{"quote/klines":1}}}},cswap:{v1:{public:{get:{"market/contracts":1,"market/premiumIndex":1,"market/openInterest":1,"market/klines":1,"market/depth":1,"market/ticker":1}},private:{get:{"trade/leverage":2,"trade/forceOrders":2,"trade/allFillOrders":2,"trade/openOrders":2,"trade/orderDetail":2,"trade/orderHistory":2,"trade/marginType":2,"user/commissionRate":2,"user/positions":2,"user/balance":2},post:{"trade/order":2,"trade/leverage":2,"trade/closeAllPositions":2,"trade/marginType":2,"trade/positionMargin":2},delete:{"trade/allOpenOrders":2,"trade/cancelOrder":2}}}},contract:{v1:{private:{get:{allPosition:2,allOrders:2,balance:2}}}},wallets:{v1:{private:{get:{"capital/config/getall":5,"capital/deposit/address":5,"capital/innerTransfer/records":1,"capital/subAccount/deposit/address":5,"capital/deposit/subHisrec":2,"capital/subAccount/innerTransfer/records":1,"capital/deposit/riskRecords":5},post:{"capital/withdraw/apply":5,"capital/innerTransfer/apply":5,"capital/subAccountInnerTransfer/apply":2,"capital/deposit/createSubAddress":2}}}},subAccount:{v1:{private:{get:{list:10,assets:2},post:{create:10,"apiKey/create":2,"apiKey/edit":2,"apiKey/del":2,updateStatus:10}}}},account:{v1:{private:{get:{uid:1,"apiKey/query":2},post:{"innerTransfer/authorizeSubAccount":1}}}},user:{auth:{private:{post:{userDataStream:2},put:{userDataStream:2},delete:{userDataStream:2}}}},copyTrading:{v1:{private:{get:{"swap/trace/currentTrack":2},post:{"swap/trace/closeTrackOrder":2,"swap/trace/setTPSL":2,"spot/trader/sellOrder":10}}}},api:{v3:{private:{get:{"asset/transfer":1,"capital/deposit/hisrec":1,"capital/withdraw/history":1},post:{"post/asset/transfer":1}}}}},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},precisionMode:n.kb,exceptions:{exact:{400:r.BadRequest,401:r.AuthenticationError,403:r.PermissionDenied,404:r.BadRequest,429:r.DDoSProtection,418:r.PermissionDenied,500:r.ExchangeError,504:r.ExchangeError,100001:r.AuthenticationError,100412:r.AuthenticationError,100202:r.InsufficientFunds,100204:r.BadRequest,100400:r.BadRequest,100410:r.OperationFailed,100421:r.BadSymbol,100440:r.ExchangeError,100500:r.OperationFailed,100503:r.ExchangeError,80001:r.BadRequest,80012:r.InsufficientFunds,80014:r.BadRequest,80016:r.OrderNotFound,80017:r.OrderNotFound,100414:r.AccountSuspended,100419:r.PermissionDenied,100437:r.BadRequest,101204:r.InsufficientFunds},broad:{}},commonCurrencies:{SNOW:"Snowman"},options:{defaultType:"spot",accountsByType:{spot:"FUND",swap:"PFUTURES",future:"SFUTURES"},accountsById:{FUND:"spot",PFUTURES:"swap",SFUTURES:"future"},recvWindow:5e3,broker:"CCXT",defaultNetworks:{ETH:"ETH",USDT:"ERC20",USDC:"ERC20",BTC:"BTC",LTC:"LTC"}}})}async fetchTime(e={}){const t=await this.swapV2PublicGetServerTime(e),s=this.safeDict(t,"data");return this.safeInteger(s,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;if(this.safeBool(this.options,"sandboxMode",!1))return;const t=await this.walletsV1PrivateGetCapitalConfigGetall(e),s=this.safeList(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r),o=this.safeString(t,"name"),n=this.safeList(t,"networkList"),d={};let h,c,l,u,p={};for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"network"),i=this.networkIdToCode(s),r=this.safeBool(t,"isDefault");l=this.safeBool(t,"depositEnable"),u=this.safeBool(t,"withdrawEnable");const a={withdraw:{min:this.safeNumber(t,"withdrawMin"),max:this.safeNumber(t,"withdrawMax")}};r&&(h=this.safeNumber(t,"withdrawFee"),c=l||u,p=a),d[i]={info:t,id:s,network:i,fee:h,active:c,deposit:l,withdraw:u,precision:void 0,limits:a}}i[a]={info:t,code:a,id:r,precision:void 0,name:o,active:c,deposit:l,withdraw:u,networks:d,fee:h,limits:p}}return i}async fetchSpotMarkets(e){const t=await this.spotV1PublicGetCommonSymbols(e),s=this.safeDict(t,"data"),i=this.safeList(s,"symbols",[]);return this.parseMarkets(i)}async fetchSwapMarkets(e){const t=await this.swapV2PublicGetQuoteContracts(e),s=this.safeList(t,"data",[]);return this.parseMarkets(s)}async fetchInverseSwapMarkets(e){const t=await this.cswapV1PublicGetMarketContracts(e),s=this.safeList(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=t.split("-"),i=s[0],r=s[1],a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r);let n=this.safeString(e,"currency"),d=!1,h=!0;const c=this.safeNumber(e,"minTickSize");void 0!==c&&(n=i,d=!0,h=!1);const l=this.safeCurrencyCode(n);let u=this.safeNumber(e,"tickSize");void 0===u&&(u=this.parseNumber(this.parsePrecision(this.safeString(e,"pricePrecision"))));let p=this.safeNumber(e,"stepSize");void 0===p&&(p=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityPrecision"))));const f=void 0!==l?"swap":"spot",m="spot"===f,g="swap"===f;let v=a+"/"+o;void 0!==l&&(v+=":"+l);const y=this.safeDict(this.fees,f,{}),w=g?this.parseNumber("1"):void 0;let b=!1;("true"===this.safeString(e,"apiStateOpen")&&"true"===this.safeString(e,"apiStateClose")||this.safeBool(e,"apiStateSell")&&this.safeBool(e,"apiStateBuy"))&&(b=!0);const S=m?void 0:d,k=m?void 0:h;let O=this.safeInteger(e,"timeOnline");return 0===O&&(O=void 0),this.safeMarketStructure({id:t,symbol:v,base:a,quote:o,settle:l,baseId:i,quoteId:r,settleId:n,type:f,spot:m,margin:!1,swap:g,future:!1,option:!1,active:b,contract:g,linear:k,inverse:S,taker:this.safeNumber(y,"taker"),maker:this.safeNumber(y,"maker"),feeSide:this.safeString(y,"feeSide"),contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:p,price:u},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(e,"minQty","tradeMinQuantity"),max:this.safeNumber(e,"maxQty")},price:{min:c,max:void 0},cost:{min:this.safeNumberN(e,["minNotional","tradeMinUSDT","minTradeValue"]),max:this.safeNumber(e,"maxNotional")}},created:O,info:e})}async fetchMarkets(e={}){const t=[this.fetchSwapMarkets(e)];this.safeBool(this.options,"sandboxMode",!1)||(t.push(this.fetchInverseSwapMarkets(e)),t.push(this.fetchSpotMarkets(e)));const s=await Promise.all(t),i=this.safeList(s,0,[]),r=this.safeList(s,1,[]),a=this.safeList(s,2,[]),o=this.arrayConcat(i,r);return this.arrayConcat(a,o)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1440);const o=this.market(e),n={symbol:o.id};n.interval=this.safeString(this.timeframes,t,t),void 0!==s&&(n.startTime=s),void 0!==i&&(n.limit=i);const d=this.safeInteger2(r,"until","endTime");let h;if(void 0!==d&&(r=this.omit(r,["until"]),n.endTime=d),o.spot)h=await this.spotV1PublicGetMarketKline(this.extend(n,r));else if(o.inverse)h=await this.cswapV1PublicGetMarketKlines(this.extend(n,r));else{const e=this.safeString(r,"price");r=this.omit(r,"price"),h="mark"===e?await this.swapV1PrivateGetMarketMarkPriceKlines(this.extend(n,r)):await this.swapV3PublicGetQuoteKlines(this.extend(n,r))}let c=this.safeValue(h,"data",[]);return Array.isArray(c)||(c=[c]),this.parseOHLCVs(c,o,t,s,i)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeInteger2(e,"time","closeTime"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};let o,n;void 0!==s&&(a.limit=Math.min(s,100)),[n,i]=this.handleMarketTypeAndParams("fetchTrades",r,i),o="spot"===n?await this.spotV1PublicGetMarketTrades(this.extend(a,i)):await this.swapV2PublicGetQuoteTrades(this.extend(a,i));const d=this.safeList(o,"data",[]);return this.parseTrades(d,r,t,s)}parseTrade(e,t=void 0){let s=this.safeIntegerN(e,["time","filledTm","T","tradeTime"]);const i=this.safeString(e,"filledTm");void 0!==i&&(s=this.parse8601(i)),0===s&&(s=void 0);const r=this.safeString(e,"quoteQty"),o=this.safeStringN(e,["currency","N","commissionAsset"]),n=this.safeCurrencyCode(o),d=this.safeBool(e,"m"),h=this.safeString2(e,"s","symbol"),c=this.safeBoolN(e,["buyerMaker","isBuyerMaker","maker"]);let l;void 0===c&&void 0===d||(l=c||d?"maker":"taker");let u=this.safeStringLower2(e,"side","S");void 0===u&&(void 0===c&&void 0===d||(u=c||d?"sell":"buy",l="taker"));const p=this.safeBool(e,"isBuyer");void 0!==p&&(u=p?"buy":"sell");const f=this.safeBool(e,"isMaker");void 0!==f&&(l=f?"maker":"taker");let m=this.safeStringN(e,["qty","amount","q"]);if(void 0!==t&&t.swap&&"volume"in e){const s=this.safeString(t.info,"tradeMinQuantity"),i=this.safeString(e,"volume");m=a.Y.stringMul(i,s)}return this.safeTrade({id:this.safeStringN(e,["id","t"]),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(h,t,"-"),order:this.safeString2(e,"orderId","i"),type:this.safeStringLower(e,"o"),side:this.parseOrderSide(u),takerOrMaker:l,price:this.safeStringN(e,["price","p","tradePrice"]),amount:m,cost:r,fee:{cost:this.parseNumber(a.Y.stringAbs(this.safeString2(e,"commission","n"))),currency:n}},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let a,o;void 0!==t&&(r.limit=t),[o,s]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),a="spot"===o?await this.spotV1PublicGetMarketDepth(this.extend(r,s)):i.inverse?await this.cswapV1PublicGetMarketDepth(this.extend(r,s)):await this.swapV2PublicGetQuoteDepth(this.extend(r,s));const n=this.safeDict(a,"data",{}),d=this.safeInteger2(n,"T","ts");return this.parseOrderBook(n,i.symbol,d,"bids","asks",0,1)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.inverse?await this.cswapV1PublicGetMarketPremiumIndex(this.extend(i,t)):await this.swapV2PublicGetQuotePremiumIndex(this.extend(i,t));const a=this.safeList(r,"data",[]);return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,"swap",!0);const s=await this.swapV2PublicGetQuotePremiumIndex(this.extend(t)),i=this.safeList(s,"data",[]),r=[];for(let t=0;t<i.length;t++){const s=i[t],a=this.safeString(s,"symbol"),o=this.safeMarket(a,void 0,void 0,"swap");(void 0===e||this.inArray(o.symbol,e))&&r.push(this.parseFundingRate(s,o))}return r}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:this.safeSymbol(s,t,"-","swap"),markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"lastFundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:i,nextFundingDatetime:this.iso8601(i),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i);const o=this.market(e),n={symbol:o.id};void 0!==t&&(n.startTime=t),void 0!==s&&(n.limit=s);const d=this.safeInteger2(i,"until","startTime");void 0!==d&&(i=this.omit(i,["until"]),n.startTime=d);const h=await this.swapV2PublicGetQuoteFundingRate(this.extend(n,i)),c=this.safeList(h,"data",[]),l=[];for(let e=0;e<c.length;e++){const t=c[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s,o,"-","swap"),r=this.safeInteger(t,"fundingTime");l.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:r,datetime:this.iso8601(r)})}const u=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(u,o.symbol,t,s)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.inverse?await this.cswapV1PublicGetMarketOpenInterest(this.extend(i,t)):await this.swapV2PublicGetQuoteOpenInterest(this.extend(i,t));let a={};if(s.inverse){const e=this.safeList(r,"data",[]);a=this.safeDict(e,0,{})}else a=this.safeDict(r,"data",{});return this.parseOpenInterest(a,s)}parseOpenInterest(e,t=void 0){const s=this.safeInteger2(e,"time","timestamp"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t,"-","swap"),a=this.safeNumber(e,"openInterest");return this.safeOpenInterest({symbol:r,baseVolume:void 0,quoteVolume:void 0,openInterestAmount:void 0,openInterestValue:a,timestamp:s,datetime:this.iso8601(s),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.spot?await this.spotV1PublicGetTicker24hr(this.extend(i,t)):s.inverse?await this.cswapV1PublicGetMarketTicker(this.extend(i,t)):await this.swapV2PublicGetQuoteTicker(this.extend(i,t));const a=this.safeList(r,"data");if(void 0!==a){const e=this.safeDict(a,0,{});return this.parseTicker(e,s)}const o=this.safeDict(r,"data",{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){let s,i,r,a;if(await this.loadMarkets(),void 0!==e){e=this.marketSymbols(e);const t=this.safeString(e,0);void 0!==t&&(s=this.market(t))}[i,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),[r,t]=this.handleSubTypeAndParams("fetchTickers",s,t),a="spot"===i?await this.spotV1PublicGetTicker24hr(t):"inverse"===r?await this.cswapV1PublicGetMarketTicker(t):await this.swapV2PublicGetQuoteTicker(t);const o=this.safeList(a,"data");return this.parseTickers(o,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=void 0===this.safeString(e,"lastQty")?"spot":"swap",r=(t=this.safeMarket(s,t,void 0,i)).symbol,a=this.safeString(e,"openPrice"),o=this.safeString(e,"highPrice"),n=this.safeString(e,"lowPrice"),d=this.safeString(e,"lastPrice"),h=this.safeString(e,"quoteVolume"),c=this.safeString(e,"volume");let l=this.safeString(e,"priceChangePercent");void 0!==l&&(l=l.replace("%",""));const u=this.safeString(e,"priceChange");let p=this.safeInteger(e,"closeTime");0===p&&(p=void 0);const f=this.iso8601(p),m=this.safeString(e,"bidPrice"),g=this.safeString(e,"bidQty"),v=this.safeString(e,"askPrice"),y=this.safeString(e,"askQty");return this.safeTicker({symbol:r,timestamp:p,datetime:f,high:o,low:n,bid:m,bidVolume:g,ask:v,askVolume:y,vwap:void 0,open:a,close:d,last:void 0,previousClose:void 0,change:u,percentage:l,average:void 0,baseVolume:c,quoteVolume:h,info:e},t)}async fetchBalance(e={}){let t,s,i;await this.loadMarkets(),[s,e]=this.handleOptionAndParams(e,"fetchBalance","standard",!1),[i,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e);const[r,a]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);return t=s?await this.contractV1PrivateGetBalance(a):"spot"===r?await this.spotV1PrivateGetAccountBalance(a):"inverse"===i?await this.cswapV1PrivateGetUserBalance(a):await this.swapV2PrivateGetUserBalance(a),this.parseBalance(t)}parseBalance(e){const t={info:e},s=this.safeList(e,"data"),i=void 0!==this.safeDict(s,0),r=this.safeDict(e,"data",{}),a=this.safeList(r,"balances"),o=void 0!==this.safeDict(a,0);if(i)for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString2(i,"availableMargin","availableBalance"),o.used=this.safeString(i,"usedMargin"),o.total=this.safeString(i,"maxWithdrawAmount"),t[a]=o}else if(o)for(let e=0;e<a.length;e++){const s=a[e],i=this.safeString(s,"asset"),r=this.safeCurrencyCode(i),o=this.account();o.free=this.safeString(s,"free"),o.used=this.safeString(s,"locked"),t[r]=o}else{const s=this.safeDict(e,"data",{}),i=this.safeDict(s,"balance"),r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"availableMargin"),o.used=this.safeString(i,"usedMargin"),t[a]=o}return this.safeBalance(t)}async fetchPositions(e=void 0,t={}){let s,i;if(await this.loadMarkets(),e=this.marketSymbols(e),[s,t]=this.handleOptionAndParams(t,"fetchPositions","standard",!1),s)i=await this.contractV1PrivateGetAllPosition(t);else{let s,r;if(void 0!==e){e=this.marketSymbols(e);const t=this.safeString(e,0);void 0!==t&&(s=this.market(t))}[r,t]=this.handleSubTypeAndParams("fetchPositions",s,t),i="inverse"===r?await this.cswapV1PrivateGetUserPositions(t):await this.swapV2PrivateGetUserPositions(t)}const r=this.safeList(i,"data",[]);return this.parsePositions(r,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadRequest(this.id+" fetchPosition() supports swap markets only");const i={symbol:s.id};let a;a=s.inverse?await this.cswapV1PrivateGetUserPositions(this.extend(i,t)):await this.swapV2PrivateGetUserPositions(this.extend(i,t));const o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parsePosition(n,s)}parsePosition(e,t=void 0){let s=this.safeString(e,"symbol","");s=s.replace("/","-");const i=this.safeBool(e,"isolated");let r;return void 0!==i&&(r=i?"isolated":"cross"),this.safePosition({info:e,id:this.safeString(e,"positionId"),symbol:this.safeSymbol(s,t,"-","swap"),notional:this.safeNumber(e,"positionValue"),marginMode:r,liquidationPrice:void 0,entryPrice:this.safeNumber2(e,"avgPrice","entryPrice"),unrealizedPnl:this.safeNumber(e,"unrealizedProfit"),realizedPnl:this.safeNumber(e,"realisedProfit"),percentage:void 0,contracts:this.safeNumber(e,"positionAmt"),contractSize:void 0,markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,side:this.safeStringLower(e,"positionSide"),hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:this.safeInteger(e,"updateTime"),maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:this.safeNumber(e,"initialMargin"),initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async createMarketOrderWithCost(e,t,s,i={}){return i.quoteOrderQty=s,await this.createOrder(e,"market",t,s,void 0,i)}async createMarketBuyOrderWithCost(e,t,s={}){return s.quoteOrderQty=t,await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrderWithCost(e,t,s={}){return s.quoteOrderQty=t,await this.createOrder(e,"market","sell",t,void 0,s)}createOrderRequest(e,t,s,i,o=void 0,n={}){const d=this.market(e);let h,c;[c,n]=this.handleMarketTypeAndParams("createOrder",d,n),t=t.toUpperCase();const l={symbol:d.id,type:t,side:s.toUpperCase()},u="MARKET"===t,p="spot"===c,f=this.safeString(n,"stopLossPrice"),m=this.safeString(n,"takeProfitPrice"),g=this.safeString2(n,"stopPrice","triggerPrice"),v=void 0!==g,y=void 0!==f,w=void 0!==m,b=p?"newClientOrderId":"clientOrderID",S=this.safeString2(n,b,"clientOrderId");void 0!==S&&(l[b]=S);const k=this.safeStringUpper(n,"timeInForce");if([h,n]=this.handlePostOnly(u,"PostOnly"===k,n),h||"PostOnly"===k?l.timeInForce="PostOnly":"IOC"===k?l.timeInForce="IOC":"GTC"===k&&(l.timeInForce="GTC"),p){const s=this.safeString2(n,"cost","quoteOrderQty");if(n=this.omit(n,"cost"),void 0!==s)l.quoteOrderQty=this.parseToNumeric(this.costToPrecision(e,s));else if(u&&void 0!==o){const e=a.Y.stringMul(this.numberToString(i),this.numberToString(o));l.quoteOrderQty=this.parseToNumeric(e)}else l.quantity=this.parseToNumeric(this.amountToPrecision(e,i));if(u||(l.price=this.parseToNumeric(this.priceToPrecision(e,o))),void 0!==g){if(u&&void 0===this.safeString(l,"quoteOrderQty"))throw new r.ArgumentsRequired(this.id+" createOrder() requires the cost parameter (or the amount + price) for placing spot market-buy trigger orders");l.stopPrice=this.priceToPrecision(e,g),"LIMIT"===t?l.type="TRIGGER_LIMIT":"MARKET"===t&&(l.type="TRIGGER_MARKET")}else if(void 0!==f||void 0!==m){const s=void 0!==f?f:m;"LIMIT"===t?l.type="TAKE_STOP_LIMIT":"MARKET"===t&&(l.type="TAKE_STOP_MARKET"),l.stopPrice=this.parseToNumeric(this.priceToPrecision(e,s))}}else{"FOK"===k&&(l.timeInForce="FOK");const r=this.safeString(n,"trailingAmount"),h=this.safeString2(n,"trailingPercent","priceRate"),c=this.safeString(n,"trailingType","TRAILING_STOP_MARKET"),p=void 0!==r,b=void 0!==h,S=p||b,O=this.safeValue(n,"stopLoss"),T=this.safeValue(n,"takeProfit"),P=void 0!==O,I=void 0!==T;"LIMIT"!==t&&"TRIGGER_LIMIT"!==t&&"STOP"!==t&&"TAKE_PROFIT"!==t||S||(l.price=this.parseToNumeric(this.priceToPrecision(e,o)));let x,A=this.safeBool(n,"reduceOnly",!1);if(v)l.stopPrice=this.parseToNumeric(this.priceToPrecision(e,g)),u||"TRIGGER_MARKET"===t?l.type="TRIGGER_MARKET":"LIMIT"!==t&&"TRIGGER_LIMIT"!==t||(l.type="TRIGGER_LIMIT");else if(y||w)A=!0,y?(l.stopPrice=this.parseToNumeric(this.priceToPrecision(e,f)),u||"STOP_MARKET"===t?l.type="STOP_MARKET":"LIMIT"!==t&&"STOP"!==t||(l.type="STOP")):w&&(l.stopPrice=this.parseToNumeric(this.priceToPrecision(e,m)),u||"TAKE_PROFIT_MARKET"===t?l.type="TAKE_PROFIT_MARKET":"LIMIT"!==t&&"TAKE_PROFIT"!==t||(l.type="TAKE_PROFIT"));else if(S)if(l.type=c,p)l.price=this.parseToNumeric(r);else if(b){const e=a.Y.stringDiv(h,"100");l.priceRate=this.parseToNumeric(e)}if(P||I){const t=this.numberToString(i);if(P){const s=this.safeString2(O,"triggerPrice","stopPrice",O),i=this.safeString(O,"workingType","MARK_PRICE"),r=this.safeString(O,"type","STOP_MARKET"),a={stopPrice:this.parseToNumeric(this.priceToPrecision(e,s)),workingType:i,type:r},o=this.safeString(O,"price");void 0!==o&&(a.price=this.parseToNumeric(this.priceToPrecision(e,o)));const n=this.safeString(O,"quantity",t);a.quantity=this.parseToNumeric(this.amountToPrecision(e,n)),l.stopLoss=this.json(a)}if(I){const s=this.safeString2(T,"triggerPrice","stopPrice",T),i=this.safeString(T,"workingType","MARK_PRICE"),r=this.safeString(T,"type","TAKE_PROFIT_MARKET"),a={stopPrice:this.parseToNumeric(this.priceToPrecision(e,s)),workingType:i,type:r},o=this.safeString(T,"price");void 0!==o&&(a.price=this.parseToNumeric(this.priceToPrecision(e,o)));const n=this.safeString(T,"quantity",t);a.quantity=this.parseToNumeric(this.amountToPrecision(e,n)),l.takeProfit=this.json(a)}}x=this.safeBool(n,"hedged",!1)?A?"buy"===s?"SHORT":"LONG":"buy"===s?"LONG":"SHORT":"BOTH",l.positionSide=x,l.quantity=d.inverse?i:this.parseToNumeric(this.amountToPrecision(e,i))}return n=this.omit(n,["hedged","reduceOnly","triggerPrice","stopLossPrice","takeProfitPrice","trailingAmount","trailingPercent","trailingType","takeProfit","stopLoss","clientOrderId"]),this.extend(l,n)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"test",!1);a=this.omit(a,"test");const d=this.createOrderRequest(e,t,s,i,r,a);let h;h=o.swap?n?await this.swapV2PrivatePostTradeOrderTest(d):o.inverse?await this.cswapV1PrivatePostTradeOrder(d):await this.swapV2PrivatePostTradeOrder(d):await this.spotV1PrivatePostTradeOrder(d),"string"==typeof h&&(h=this.fixStringifiedJsonMembers(h),h=this.parseJson(h));const c=this.safeDict(h,"data",{});let l={};return l=o.swap?o.inverse?h:this.safeDict(c,"order",{}):c,this.parseOrder(l,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i;for(let t=0;t<e.length;t++){const a=e[t],o=this.safeString(a,"symbol");if(void 0===i)i=o;else if(i!==o)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const n=this.safeString(a,"type"),d=this.safeString(a,"side"),h=this.safeNumber(a,"amount"),c=this.safeNumber(a,"price"),l=this.safeDict(a,"params",{}),u=this.createOrderRequest(o,n,d,h,c,l);s.push(u)}const a=this.market(i),o={};let n;a.swap?(o.batchOrders=this.json(s),n=await this.swapV2PrivatePostTradeBatchOrders(o)):(o.data=this.json(s),n=await this.spotV1PrivatePostTradeBatchOrders(o));const d=this.safeDict(n,"data",{}),h=this.safeList(d,"orders",[]);return this.parseOrders(h,a)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell",SHORT:"sell",LONG:"buy",ask:"sell",bid:"buy"},e,e)}parseOrderType(e){return this.safeString({trigger_market:"market",trigger_limit:"limit",stop_limit:"limit",stop_market:"market",take_profit_market:"market",stop:"limit"},e,e)}parseOrder(e,t=void 0){const s=e,i=this.safeDict2(e,"newOrderResponse","orderOpenResponse");void 0!==i&&(e=i);const r=void 0===this.safeString2(e,"positionSide","ps")?"spot":"swap",o=this.safeString2(e,"symbol","s");void 0===t&&(t=this.safeMarket(o,void 0,void 0,r));const n=this.safeStringLower2(e,"side","S"),d=this.safeIntegerN(e,["time","transactTime","E"]),h=this.safeInteger2(e,"updateTime","T"),c=this.safeStringUpper2(e,"status","X");let l=this.safeString2(e,"feeAsset","N");const u=this.safeStringN(e,["fee","commission","n"]);void 0===l&&(l=t.spot&&"buy"===n?t.base:t.quote);let p,f=this.safeValue(e,"stopLoss");void 0!==f&&""!==f&&(p=this.omitZero(this.safeString(f,"stopLoss"))),void 0!==f&&"number"!=typeof f&&""!==f&&("string"==typeof f&&(f=this.parseJson(f)),p=this.omitZero(this.safeString(f,"stopPrice")));let m,g=this.safeValue(e,"takeProfit");void 0!==g&&""!==g&&(m=this.omitZero(this.safeString(g,"takeProfit"))),void 0!==g&&"number"!=typeof g&&""!==g&&("string"==typeof g&&(g=this.parseJson(g)),m=this.omitZero(this.safeString(g,"stopPrice")));const v=this.safeStringLower2(e,"type","o"),y=this.omitZero(this.safeString2(e,"StopPrice","stopPrice"));let w=y;return void 0!==y&&(v.indexOf("stop")>-1&&void 0===p&&(p=y,w=void 0),v.indexOf("take")>-1&&void 0===m&&(m=y,w=void 0)),this.safeOrder({info:s,id:this.safeString2(e,"orderId","i"),clientOrderId:this.safeStringN(e,["clientOrderID","clientOrderId","origClientOrderId","c"]),symbol:this.safeSymbol(o,t,"-",r),timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:h,lastUpdateTimestamp:this.safeInteger(e,"updateTime"),type:this.parseOrderType(v),timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:this.parseOrderSide(n),price:this.safeString2(e,"price","p"),stopPrice:w,triggerPrice:w,stopLossPrice:p,takeProfitPrice:m,average:this.safeString2(e,"avgPrice","ap"),cost:this.safeString(e,"cummulativeQuoteQty"),amount:this.safeStringN(e,["origQty","q","quantity"]),filled:this.safeString2(e,"executedQty","z"),remaining:void 0,status:this.parseOrderStatus(c),fee:{currency:l,cost:a.Y.stringAbs(u)},trades:void 0,reduceOnly:this.safeBool(e,"reduceOnly")},t)}parseOrderStatus(e){return this.safeString({NEW:"open",PENDING:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",CANCELLED:"canceled",FAILED:"canceled"},e,e)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id},o=this.safeString2(s,"clientOrderId","clientOrderID");let n,d,h;s=this.omit(s,["clientOrderId"]),void 0!==o?a.clientOrderID=o:a.orderId=e,[d,s]=this.handleMarketTypeAndParams("cancelOrder",i,s),[h,s]=this.handleSubTypeAndParams("cancelOrder",i,s),n="spot"===d?await this.spotV1PrivatePostTradeCancel(this.extend(a,s)):"inverse"===h?await this.cswapV1PrivateDeleteTradeCancelOrder(this.extend(a,s)):await this.swapV2PrivateDeleteTradeOrder(this.extend(a,s));const c=this.safeDict(n,"data",{}),l=this.safeDict(c,"order",c);return this.parseOrder(l,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let a;if(s.spot)a=await this.spotV1PrivatePostTradeCancelOpenOrders(this.extend(i,t));else{if(!s.swap)throw new r.BadRequest(this.id+" cancelAllOrders is only supported for spot and swap markets.");a=s.inverse?await this.cswapV1PrivateDeleteTradeAllOpenOrders(this.extend(i,t)):await this.swapV2PrivateDeleteTradeAllOpenOrders(this.extend(i,t))}const o=this.safeDict(a,"data",{}),n=this.safeList2(o,"success","orders",[]);return this.parseOrders(n)}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id},o=this.safeValue(s,"clientOrderIds");s=this.omit(s,"clientOrderIds");let n=e;const d=void 0!==o;d&&(n=o);const h=[];for(let e=0;e<n.length;e++){const t=n[e].toString();h.push(t)}let c;if(i.spot){a[d?"clientOrderIDs":"orderIds"]=h.join(","),c=await this.spotV1PrivatePostTradeCancelOrders(this.extend(a,s))}else d?a.clientOrderIDList=this.json(h):a.orderIdList=h,c=await this.swapV2PrivateDeleteTradeBatchOrders(this.extend(a,s));const l=this.safeDict(c,"data",{}),u=this.safeList2(l,"success","orders",[]);return this.parseOrders(u)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s=e>0,i={type:s?"ACTIVATE":"CLOSE",timeOut:s?this.parseToInt(e/1e3):0};let a,o;if([o,t]=this.handleMarketTypeAndParams("cancelAllOrdersAfter",void 0,t),"spot"===o)a=await this.spotV1PrivatePostTradeCancelAllAfter(this.extend(i,t));else{if("swap"!==o)throw new r.NotSupported(this.id+" cancelAllOrdersAfter() is not supported for "+o+" markets");a=await this.swapV2PrivatePostTradeCancelAllAfter(this.extend(i,t))}return a}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id,orderId:e};let o,n,d;[o,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),[n,s]=this.handleSubTypeAndParams("fetchOrder",i,s),d="spot"===o?await this.spotV1PrivateGetTradeQuery(this.extend(a,s)):"inverse"===n?await this.cswapV1PrivateGetTradeOrderDetail(this.extend(a,s)):await this.swapV2PrivateGetTradeOrder(this.extend(a,s));const h=this.safeDict(d,"data",{}),c=this.safeDict(h,"order",h);return this.parseOrder(c,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o,n;if(void 0!==e&&(o=this.market(e),a.symbol=o.id),[n,i]=this.handleMarketTypeAndParams("fetchOrders",o,i),"swap"!==n)throw new r.NotSupported(this.id+" fetchOrders() is only supported for swap markets");void 0!==s&&(a.limit=s),void 0!==t&&(a.startTime=t);const d=this.safeInteger(i,"until"),h=this.safeInteger(i,"endTime",d);i=this.omit(i,["endTime","until"]),void 0!==h&&(a.endTime=h);const c=await this.swapV1PrivateGetTradeFullOrder(this.extend(a,i)),l=this.safeDict(c,"data",{}),u=this.safeList(l,"orders",[]);return this.parseOrders(u,o,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let o,n,d;void 0!==e&&(r=this.market(e),a.symbol=r.id),[o,i]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),[n,i]=this.handleSubTypeAndParams("fetchOpenOrders",r,i),d="spot"===o?await this.spotV1PrivateGetTradeOpenOrders(this.extend(a,i)):"inverse"===n?await this.cswapV1PrivateGetTradeOpenOrders(this.extend(a,i)):await this.swapV2PrivateGetTradeOpenOrders(this.extend(a,i));const h=this.safeDict(d,"data",{}),c=this.safeList(h,"orders",[]);return this.parseOrders(c,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.fetchCanceledAndClosedOrders(e,t,s,i);return this.filterBy(r,"status","closed")}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.fetchCanceledAndClosedOrders(e,t,s,i);return this.filterBy(r,"status","canceled")}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};let n,d,h,c;[n,i]=this.handleMarketTypeAndParams("fetchClosedOrders",a,i),[d,i]=this.handleSubTypeAndParams("fetchClosedOrders",a,i),[h,i]=this.handleOptionAndParams(i,"fetchClosedOrders","standard",!1),c=h?await this.contractV1PrivateGetAllOrders(this.extend(o,i)):"spot"===n?await this.spotV1PrivateGetTradeHistoryOrders(this.extend(o,i)):"inverse"===d?await this.cswapV1PrivateGetTradeOrderHistory(this.extend(o,i)):await this.swapV2PrivateGetTradeAllOrders(this.extend(o,i));const l=this.safeDict(c,"data",{}),u=this.safeList(l,"orders",[]);return this.parseOrders(u,a,t,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={asset:a.id,amount:this.currencyToPrecision(e,t),type:n+"_"+d},c=await this.spotV3PrivateGetGetAssetTransfer(this.extend(h,r));return{info:c,id:this.safeString(c,"tranId"),timestamp:void 0,datetime:void 0,currency:e,amount:t,fromAccount:s,toAccount:i,status:void 0}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),void 0!==e&&(a=this.currency(e));const o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(i,"fromAccount"),d=this.safeString(i,"toAccount"),h=this.safeString(o,n,n),c=this.safeString(o,d,d);if(void 0===h||void 0===c)throw new r.ExchangeError(this.id+" fromAccount & toAccount parameter are required");const l={type:h+"_"+c};void 0!==t&&(l.startTime=t),void 0!==s&&(l.size=s);const u=await this.spotV3PrivateGetAssetTransfer(this.extend(l,i)),p=this.safeList(u,"rows",[]);return this.parseTransfers(p,a,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"tranId"),i=this.safeInteger(e,"timestamp"),r=this.safeCurrencyCode(void 0,t),a=this.safeString(e,"status"),o=this.safeDict(this.options,"accountsById",{}),n=this.safeString(e,"type"),d=n.split("_"),h=this.safeString(d,0),c=this.safeString(n,1),l=this.safeString(o,h,h),u=this.safeString(o,c,c);return{info:e,id:s,timestamp:i,datetime:this.iso8601(i),currency:r,amount:this.safeNumber(e,"amount"),fromAccount:l,toAccount:u,status:a}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeInteger(this.options,"recvWindow"),r=this.safeInteger(this.parseParams,"recvWindow",i),a={coin:s.id,offset:0,limit:1e3,recvWindow:r},o=await this.walletsV1PrivateGetCapitalDepositAddress(this.extend(a,t)),n=this.safeList(this.safeDict(o,"data"),"data"),d=this.parseDepositAddresses(n,[s.code],!1);return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){const s=this.safeString(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);if(void 0!==s)return this.safeDict(i,s);{const t=this.safeDict(this.options,"defaultNetworks"),s=this.safeString(t,e);if(void 0!==s)return this.safeDict(i,s);{const e=Object.keys(i),t=this.safeString(e,0);return this.safeDict(i,t)}}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag"),r=this.safeString(e,"coin"),a=(t=this.safeCurrency(r,t)).code,o=this.safeString(e,"network");return this.checkAddress(s),{currency:a,address:s,tag:i,network:o,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=await this.spotV3PrivateGetCapitalDepositHisrec(this.extend(r,i));return this.parseTransactions(o,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=await this.spotV3PrivateGetCapitalWithdrawHistory(this.extend(r,i));return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"data"),i=void 0===s?void 0:this.safeString(s,"id"),r=this.safeString(e,"id",i),a=this.safeString(e,"address"),o=this.safeString(e,"addressTag");let n=this.safeInteger(e,"insertTime"),d=this.iso8601(n);void 0===n&&(d=this.safeString(e,"applyTime"),n=this.parse8601(d));const h=this.safeString(e,"network"),c=this.safeString(e,"coin");let l=this.safeCurrencyCode(c,t);void 0!==l&&l!==h&&l.indexOf(h)>=0&&void 0!==h&&(l=l.replace(h,""));const u="0"===this.safeString(e,"transferType")?"deposit":"withdrawal";return{info:e,id:r,txid:this.safeString(e,"txId"),type:u,currency:l,network:this.networkIdToCode(h),amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:n,datetime:d,address:a,addressFrom:void 0,addressTo:a,tag:o,tagFrom:o,tagTo:void 0,updated:void 0,comment:this.safeString(e,"info"),fee:{currency:l,cost:this.safeNumber(e,"transactionFee"),rate:void 0},internal:void 0}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"ok",10:"pending",20:"rejected",30:"ok",40:"rejected",50:"ok",60:"pending",70:"rejected",2:"pending",3:"rejected",4:"pending",5:"rejected",6:"ok"},e,e)}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if("swap"!==i.type)throw new r.BadSymbol(this.id+" setMarginMode() supports swap contracts only");if("CROSS"===(e=e.toUpperCase())&&(e="CROSSED"),"ISOLATED"!==e&&"CROSSED"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");const a={symbol:i.id,marginType:e};let o;return[o,s]=this.handleSubTypeAndParams("setMarginMode",i,s),"inverse"===o?await this.cswapV1PrivatePostTradeMarginType(this.extend(a,s)):await this.swapV2PrivatePostTradeMarginType(this.extend(a,s))}async addMargin(e,t,s={}){return await this.setMargin(e,t,this.extend({type:1},s))}async reduceMargin(e,t,s={}){return await this.setMargin(e,t,this.extend({type:2},s))}async setMargin(e,t,s={}){const i=this.safeInteger(s,"type");if(void 0===i)throw new r.ArgumentsRequired(this.id+" setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)");if(!this.inArray(i,[1,2]))throw new r.ArgumentsRequired(this.id+" setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,amount:this.amountToPrecision(a.symbol,t),type:i},n=await this.swapV2PrivatePostTradePositionMargin(this.extend(o,s));return this.parseMarginModification(n,a)}parseMarginModification(e,t=void 0){const s=this.safeString(e,"type");return{info:e,symbol:this.safeString(t,"symbol"),type:"1"===s?"add":"reduce",marginMode:"isolated",amount:this.safeNumber(e,"amount"),total:this.safeNumber(e,"margin"),code:this.safeString(t,"settle"),status:void 0,timestamp:void 0,datetime:void 0}}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.inverse?await this.cswapV1PrivateGetTradeLeverage(this.extend(i,t)):await this.swapV2PrivateGetTradeLeverage(this.extend(i,t));const a=this.safeDict(r,"data",{});return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),marginMode:void 0,longLeverage:this.safeInteger(e,"longLeverage"),shortLeverage:this.safeInteger(e,"shortLeverage")}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");const i=this.safeStringUpper(s,"side");this.checkRequiredArgument("setLeverage",i,"side",["LONG","SHORT","BOTH"]),await this.loadMarkets();const a=this.market(t),o={symbol:a.id,side:i,leverage:e};return a.inverse?await this.cswapV1PrivatePostTradeLeverage(this.extend(o,s)):await this.swapV2PrivatePostTradeLeverage(this.extend(o,s))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={};let n,d,h;if([h,i]=this.handleSubTypeAndParams("fetchMyTrades",a,i),"inverse"===h){if(void 0===this.safeString(i,"orderId"))throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires an orderId argument for inverse swap trades");d=await this.cswapV1PrivateGetTradeAllFillOrders(this.extend(o,i)),n=this.safeList(d,"data",[])}else{o.symbol=a.id;const e=this.milliseconds();if(void 0!==t){o[a.spot?"startTime":"startTs"]=t}else a.swap&&(o.startTs=e-7776e6);const s=this.safeInteger(i,"until");if(i=this.omit(i,"until"),void 0!==s){o[a.spot?"endTime":"endTs"]=s}else a.swap&&(o.endTs=e);if(a.spot){d=await this.spotV1PrivateGetTradeMyTrades(this.extend(o,i));const e=this.safeDict(d,"data",{});n=this.safeList(e,"fills",[])}else{const e=this.safeStringUpper(i,"tradingUnit","CONT");i=this.omit(i,"tradingUnit"),o.tradingUnit=e,d=await this.swapV2PrivateGetTradeAllFillOrders(this.extend(o,i));const t=this.safeDict(d,"data",{});n=this.safeList(t,"fill_orders",[])}}return this.parseTrades(n,a,t,s,i)}parseDepositWithdrawFee(e,t=void 0){const s=this.safeList(e,"networkList",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(0!==i)for(let e=0;e<i;e++){const i=s[e],a=this.safeString(i,"network"),o=this.safeBool(i,"isDefault"),n=this.safeString(t,"code"),d=this.networkIdToCode(a,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(i,"withdrawFee"),percentage:!1}},o&&(r.withdraw.fee=this.safeNumber(i,"withdrawFee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.walletsV1PrivateGetCapitalConfigGetall(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e,"coin")}async withdraw(e,t,s,i=void 0,a={}){await this.loadMarkets();const o=this.currency(e);let n=this.safeInteger(a,"walletType");if(void 0===n&&(n=1),!this.inArray(n,[1,2,3]))throw new r.BadRequest(this.id+" withdraw() requires either 1 fund account, 2 standard futures account, 3 perpetual account for walletType");const d={coin:o.id,address:s,amount:this.numberToString(t),walletType:n},h=this.safeStringUpper(a,"network");void 0!==h&&(d.network=this.networkCodeToId(h)),a=this.omit(a,["walletType","network"]);const c=await this.walletsV1PrivatePostCapitalWithdrawApply(this.extend(d,a)),l=this.safeValue(c,"data");return this.parseTransaction(l)}parseParams(e){const t=this.keysort(e),s=Object.keys(t);for(let e=0;e<s.length;e++){const i=s[e],r=t[i];if(Array.isArray(r)){let e="[";for(let t=0;t<r.length;t++){t>0&&(e+=","),e+=r[t].toString()}e+="]",t[i]=e}}return t}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o,n,d={autoCloseType:"LIQUIDATION"};if([d,i]=this.handleUntilOption("endTime",d,i),void 0!==e&&(r=this.market(e),d.symbol=r.id),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s),[a,i]=this.handleSubTypeAndParams("fetchMyLiquidations",r,i),"inverse"===a)o=await this.cswapV1PrivateGetTradeForceOrders(this.extend(d,i)),n=this.safeList(o,"data",[]);else{o=await this.swapV2PrivateGetTradeForceOrders(this.extend(d,i));const e=this.safeDict(o,"data",{});n=this.safeList(e,"orders",[])}return this.parseLiquidations(n,r,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"time"),r=this.safeString(e,"executedQty"),o=this.safeString(t,"contractSize"),n=this.safeString(e,"avgPrice"),d=a.Y.stringMul(r,o),h=a.Y.stringMul(d,n);return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.parseNumber(r),contractSize:this.parseNumber(o),price:this.parseNumber(n),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(h),timestamp:i,datetime:this.iso8601(i)})}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={};let a;void 0!==this.safeString(s,"positionId")?a=await this.swapV1PrivatePostTradeClosePosition(this.extend(r,s)):(r.symbol=i.id,a=i.inverse?await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(r,s)):await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(r,s)));const o=this.safeDict(a,"data");return this.parseOrder(o,i)}async closeAllPositions(e={}){await this.loadMarkets();const t=this.safeInteger(this.options,"recvWindow"),s=this.safeInteger(this.parseParams,"recvWindow",t);let i,a;if([i,e]=this.handleMarketTypeAndParams("closeAllPositions",void 0,e),[a,e]=this.handleSubTypeAndParams("closeAllPositions",void 0,e),"margin"===i)throw new r.BadRequest(this.id+" closePositions () cannot be used for "+i+" markets");const o={recvWindow:s};let n;n="inverse"===a?await this.cswapV1PrivatePostTradeCloseAllPositions(this.extend(o,e)):await this.swapV2PrivatePostTradeCloseAllPositions(this.extend(o,e));const d=this.safeDict(n,"data",{}),h=this.safeList(d,"success",[]),c=[];for(let e=0;e<h.length;e++){const t=this.parsePosition({positionId:h[e]});c.push(t)}return c}async fetchPositionMode(e=void 0,t={}){const s=await this.swapV1PrivateGetPositionSideDual(t),i=this.safeDict(s,"data",{});return{info:s,hedged:"true"===this.safeString(i,"dualSidePosition")}}async setPositionMode(e,t=void 0,s={}){let i;i=e?"true":"false";const r={dualSidePosition:i};return await this.swapV1PrivatePostPositionSideDual(this.extend(r,s))}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.createOrderRequest(t,s,i,r,a,o);let h;d.cancelOrderId=e,d.cancelReplaceMode="STOP_ON_FAILURE",h=n.swap?await this.swapV1PrivatePostTradeCancelReplace(this.extend(d,o)):await this.spotV1PrivatePostTradeOrderCancelReplace(this.extend(d,o));const c=this.safeDict(h,"data");return this.parseOrder(c,n)}async fetchMarginMode(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a;[r,t]=this.handleSubTypeAndParams("fetchMarginMode",s,t),a="inverse"===r?await this.cswapV1PrivateGetTradeMarginType(this.extend(i,t)):await this.swapV2PrivateGetTradeMarginType(this.extend(i,t));const o=this.safeDict(a,"data",{});return this.parseMarginMode(o,s)}parseMarginMode(e,t=void 0){const s=this.safeString(e,"symbol");let i=this.safeStringLower(e,"marginType");return i="crossed"===i?"cross":i,{info:e,symbol:this.safeSymbol(s,t,"-","swap"),marginMode:i}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a={};const o=this.safeDict(r,"data",{});return s.spot?(r=await this.spotV1PrivateGetUserCommissionRate(this.extend(i,t)),a=o):s.inverse?(r=await this.cswapV1PrivateGetUserCommissionRate(t),a=o):(r=await this.swapV2PrivateGetUserCommissionRate(t),a=this.safeDict(o,"commission",{})),this.parseTradingFee(a,s)}parseTradingFee(e,t=void 0){return{info:e,symbol:void 0!==t?t.symbol:void 0,maker:this.safeNumber(e,"makerCommissionRate"),taker:this.safeNumber(e,"takerCommissionRate"),percentage:!1,tierBased:!1}}sign(e,t="public",s="GET",i={},a=void 0,n=void 0){const d=t[0],h=t[1],c=t[2];if(this.safeBool(this.options,"sandboxMode",!1)&&"swap"!==d)throw new r.NotSupported(this.id+" does not have a testnet/sandbox URL for "+d+" endpoints");let l=this.implodeHostname(this.urls.api[d]);if(l+="spot"===d&&"v3"===h?"/api":"/"+d,l+="/"+h+"/",l+=e=this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),i=this.keysort(i),"public"===c)i.timestamp=this.nonce(),Object.keys(i).length&&(l+="?"+this.urlencode(i));else if("private"===c){this.checkRequiredCredentials(),i.timestamp=this.nonce();const e=this.parseParams(i);let t=this.urlencode(e);const s=this.hmac(this.encode(this.rawencode(e)),this.encode(this.secret),o.s);Object.keys(i).length?t="?"+t+"&":t+="?",t+="signature="+s,a={"X-BX-APIKEY":this.apiKey,"X-SOURCE-KEY":this.safeString(this.options,"broker","CCXT")},l+=t}return{url:l,method:s,body:n,headers:a}}nonce(){return this.milliseconds()}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"msg");if(void 0!==c&&"0"!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},2342:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3885),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bit2c",name:"Bit2C",countries:["IL"],rateLimit:3e3,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,ws:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg",api:{rest:"https://bit2c.co.il"},www:"https://www.bit2c.co.il",referral:"https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",doc:["https://www.bit2c.co.il/home/api","https://github.com/OferE/bit2c"]},api:{public:{get:["Exchanges/{pair}/Ticker","Exchanges/{pair}/orderbook","Exchanges/{pair}/trades","Exchanges/{pair}/lasttrades"]},private:{post:["Merchant/CreateCheckout","Funds/AddCoinFundsRequest","Order/AddFund","Order/AddOrder","Order/GetById","Order/AddOrderMarketPriceBuy","Order/AddOrderMarketPriceSell","Order/CancelOrder","Order/AddCoinFundsRequest","Order/AddStopOrder","Payment/GetMyId","Payment/Send","Payment/Pay"],get:["Account/Balance","Account/Balance/v2","Order/MyOrders","Order/GetById","Order/AccountHistory","Order/OrderHistory"]}},markets:{"BTC/NIS":this.safeMarketStructure({id:"BtcNis",symbol:"BTC/NIS",base:"BTC",quote:"NIS",baseId:"Btc",quoteId:"Nis",type:"spot",spot:!0}),"ETH/NIS":this.safeMarketStructure({id:"EthNis",symbol:"ETH/NIS",base:"ETH",quote:"NIS",baseId:"Eth",quoteId:"Nis",type:"spot",spot:!0}),"LTC/NIS":this.safeMarketStructure({id:"LtcNis",symbol:"LTC/NIS",base:"LTC",quote:"NIS",baseId:"Ltc",quoteId:"Nis",type:"spot",spot:!0}),"USDC/NIS":this.safeMarketStructure({id:"UsdcNis",symbol:"USDC/NIS",base:"USDC",quote:"NIS",baseId:"Usdc",quoteId:"Nis",type:"spot",spot:!0})},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.025"),taker:this.parseNumber("0.03"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.03")],[this.parseNumber("20000"),this.parseNumber("0.0275")],[this.parseNumber("50000"),this.parseNumber("0.025")],[this.parseNumber("75000"),this.parseNumber("0.0225")],[this.parseNumber("100000"),this.parseNumber("0.02")],[this.parseNumber("250000"),this.parseNumber("0.015")],[this.parseNumber("500000"),this.parseNumber("0.0125")],[this.parseNumber("750000"),this.parseNumber("0.01")],[this.parseNumber("1000000"),this.parseNumber("0.008")],[this.parseNumber("2000000"),this.parseNumber("0.006")],[this.parseNumber("3000000"),this.parseNumber("0.004")],[this.parseNumber("4000000"),this.parseNumber("0.002")]],maker:[[this.parseNumber("0"),this.parseNumber("0.025")],[this.parseNumber("20000"),this.parseNumber("0.0225")],[this.parseNumber("50000"),this.parseNumber("0.02")],[this.parseNumber("75000"),this.parseNumber("0.0175")],[this.parseNumber("100000"),this.parseNumber("0.015")],[this.parseNumber("250000"),this.parseNumber("0.01")],[this.parseNumber("500000"),this.parseNumber("0.0075")],[this.parseNumber("750000"),this.parseNumber("0.005")],[this.parseNumber("1000000"),this.parseNumber("0.004")],[this.parseNumber("2000000"),this.parseNumber("0.003")],[this.parseNumber("3000000"),this.parseNumber("0.002")],[this.parseNumber("4000000"),this.parseNumber("0.001")]]}}},options:{fetchTradesMethod:"public_get_exchanges_pair_trades"},precisionMode:o.kb,exceptions:{exact:{"Please provide valid APIkey":r.AuthenticationError,"No order found.":r.OrderNotFound},broad:{"Please provide valid nonce":r.InvalidNonce,"please approve new terms of use on site":r.PermissionDenied}}})}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const r=s[i],a=this.account(),o=this.currency(r).id.toUpperCase();o in e&&(a.free=this.safeString(e,"AVAILABLE_"+o),a.total=this.safeString(e,o)),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalanceV2(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={pair:this.market(e).id},r=await this.publicGetExchangesPairOrderbook(this.extend(i,s));return this.parseOrderBook(r,e)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"av"),r=this.safeString(e,"a"),a=this.safeString(e,"ll");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"h"),bidVolume:void 0,ask:this.safeString(e,"l"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:i,baseVolume:r,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetExchangesPairTicker(this.extend(i,t));return this.parseTicker(r,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e),o=this.options.fetchTradesMethod,n={pair:a.id};let d;if(void 0!==t&&(n.date=this.parseToInt(t)),void 0!==s&&(n.limit=s),d="public_get_exchanges_pair_trades"===o?await this.publicGetExchangesPairTrades(this.extend(n,i)):await this.publicGetExchangesPairLasttrades(this.extend(n,i)),"string"==typeof d)throw new r.ExchangeError(d);return this.parseTrades(d,a,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalance(e),s=this.safeValue(t,"Fees",{}),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],o=this.safeSymbol(t),n=this.safeValue(s,t),d=this.safeString(n,"FeeMaker"),h=this.safeString(n,"FeeTaker"),c=this.parseNumber(a.Y.stringDiv(d,"100")),l=this.parseNumber(a.Y.stringDiv(h,"100"));r[o]={info:n,symbol:o,taker:l,maker:c,percentage:!0,tierBased:!0}}return r}async createOrder(e,t,s,i,r=void 0,o={}){await this.loadMarkets();let n="privatePostOrderAddOrder";const d=this.market(e),h={Amount:i,Pair:d.id};if("market"===t)n+="MarketPrice"+this.capitalize(s);else{h.Price=r;const e=this.numberToString(i),t=this.numberToString(r);h.Total=this.parseToNumeric(a.Y.stringMul(e,t)),h.IsBid="buy"===s}const c=await this[n](this.extend(h,o));return this.parseOrder(c,d)}async cancelOrder(e,t=void 0,s={}){const i={id:e},r=await this.privatePostOrderCancelOrder(this.extend(i,s));return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id},n=await this.privateGetOrderMyOrders(this.extend(o,i)),d=this.safeValue(n,a.id,{}),h=this.safeValue(d,"ask",[]),c=this.safeList(d,"bid",[]);return this.parseOrders(this.arrayConcat(h,c),a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),r={id:e},a=await this.privateGetOrderGetById(this.extend(r,s));return this.parseOrder(a,i)}parseOrder(e,t=void 0){let s,i=!1;"NewOrder"in e?(s=e.NewOrder,i=!0):s=e;const r=this.safeString(s,"id"),a=this.safeSymbol(void 0,t),o=this.safeIntegerProduct(s,"created",1e3);let n;if(i){const e=this.safeInteger(s,"status_type");0===e||1===e?n="open":5===e&&(n="closed")}else{const e=this.safeString(s,"status");"New"===e||"Open"===e?n="open":"Completed"===e&&(n="closed")}let d=this.safeString(s,"order_type");"0"===d?d="limit":"1"===d&&(d="market");let h=this.safeString(s,"type");"0"===h?h="buy":"1"===h&&(h="sell");const c=this.safeString(s,"price");let l,u;return i?(l=this.safeString(s,"amount"),u=this.safeString(s,"amount")):(l=this.safeString(s,"initialAmount"),u=this.safeString(s,"amount")),this.safeOrder({id:r,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:n,symbol:a,type:d,timeInForce:void 0,postOnly:void 0,side:h,price:c,stopPrice:void 0,triggerPrice:void 0,amount:l,filled:void 0,remaining:u,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==s&&(a.take=s),a.take=s,void 0!==t&&(a.toTime=this.yyyymmdd(this.milliseconds(),"."),a.fromTime=this.yyyymmdd(t,".")),void 0!==e&&(r=this.market(e),a.pair=r.id);const o=await this.privateGetOrderOrderHistory(this.extend(a,i));return this.parseTrades(o,r,t,s)}removeCommaFromValue(e){let t="";const s=e.split(",");for(let e=0;e<s.length;e++)t+=s[e];return t}parseTrade(e,t=void 0){let s,i,r,a,o,n,d,h;const c=this.safeString(e,"reference");if(void 0!==c){i=c,s=this.safeTimestamp(e,"ticks"),r=this.safeString(e,"price"),r=this.removeCommaFromValue(r),a=this.safeString(e,"firstAmount");const l=c.split("|"),u=this.safeString(e,"pair");t=this.safeMarket(u,t),t=this.safeMarket(l[0],t);const p=this.safeValue(e,"isMaker");h=p?"maker":"taker",o=p?l[2]:l[1],d=this.safeInteger(e,"action"),0===d?d="buy":1===d&&(d="sell");const f=this.safeString(e,"feeAmount");void 0!==f&&(n={cost:f,currency:"NIS"})}else s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),d=this.safeValue(e,"isBid"),void 0!==d&&(d=d?"buy":"sell");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:o,type:void 0,side:d,takerOrMaker:h,price:r,amount:a,cost:void 0,fee:n},t)}isFiat(e){return"NIS"===e}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);if(this.isFiat(e))throw new r.NotSupported(this.id+" fetchDepositAddress() does not support fiat currencies");const i={Coin:s.id},a=await this.privatePostFundsAddCoinFundsRequest(this.extend(i,t));return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");this.checkAddress(s);return{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+this.implodeParams(e,i);if("public"===t)o+=".json";else{this.checkRequiredCredentials();const e=this.nonce(),t=this.extend({nonce:e},i),d=this.urlencode(t);"GET"===s?Object.keys(t).length&&(o+="?"+d):a=d;const h=this.hmac(this.encode(d),this.encode(this.secret),n.Zf,"base64");r={"Content-Type":"application/x-www-form-urlencoded",key:this.apiKey,sign:h}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;let c=this.safeString(n,"error");if(void 0===c&&(c=this.safeString(n,"Error")),void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}}},7399:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2308),r=s(2079),a=s(1579),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitbank",name:"bitbank",countries:["JP"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week"},hostname:"bitbank.cc",urls:{logo:"https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg",api:{public:"https://public.{hostname}",private:"https://api.{hostname}",markets:"https://api.{hostname}"},www:"https://bitbank.cc/",doc:"https://docs.bitbank.cc/",fees:"https://bitbank.cc/docs/fees/"},api:{public:{get:["{pair}/ticker","tickers","tickers_jpy","{pair}/depth","{pair}/transactions","{pair}/transactions/{yyyymmdd}","{pair}/candlestick/{candletype}/{yyyymmdd}","{pair}/circuit_break_info"]},private:{get:["user/assets","user/spot/order","user/spot/active_orders","user/spot/trade_history","user/deposit_history","user/withdrawal_account","user/withdrawal_history","spot/status","spot/pairs"],post:["user/spot/order","user/spot/cancel_order","user/spot/cancel_orders","user/spot/orders_info","user/request_withdrawal"]},markets:{get:["spot/pairs"]}},precisionMode:a.kb,exceptions:{exact:{20001:r.AuthenticationError,20002:r.AuthenticationError,20003:r.AuthenticationError,20005:r.AuthenticationError,20004:r.InvalidNonce,40020:r.InvalidOrder,40021:r.InvalidOrder,40025:r.ExchangeError,40013:r.OrderNotFound,40014:r.OrderNotFound,50008:r.PermissionDenied,50009:r.OrderNotFound,50010:r.OrderNotFound,60001:r.InsufficientFunds,60005:r.InvalidOrder}}})}async fetchMarkets(e={}){const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"pairs",[]);return this.parseMarkets(i)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeString(e,"base_asset"),i=this.safeString(e,"quote_asset"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i);return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(e,"is_enabled"),contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"taker_fee_rate_quote"),maker:this.safeNumber(e,"maker_fee_rate_quote"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amount_digits"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"price_digits")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"unit_amount"),max:this.safeNumber(e,"limit_max_amount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetPairTicker(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id},a=await this.publicGetPairDepth(this.extend(r,s)),o=this.safeValue(a,"data",{}),n=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,n)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"executed_at");t=this.safeMarket(void 0,t);const i=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=this.safeString2(e,"transaction_id","trade_id"),o=this.safeString(e,"maker_taker");let n;const d=this.safeString(e,"fee_amount_quote");void 0!==d&&(n={currency:t.quote,cost:d});const h=this.safeString(e,"order_id"),c=this.safeString(e,"type"),l=this.safeString(e,"side");return this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:a,order:h,type:c,side:l,takerOrMaker:o,price:i,amount:r,cost:void 0,fee:n,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetPairTransactions(this.extend(a,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"transactions",[]);return this.parseTrades(d,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.marketsGetSpotPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"pairs",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"name"),a=this.safeMarket(s).symbol;r[a]={info:t,symbol:a,maker:this.safeNumber(t,"maker_fee_rate_quote"),taker:this.safeNumber(t,"taker_fee_rate_quote"),percentage:!0,tierBased:!1}}return r}parseOHLCV(e,t=void 0){return[this.safeInteger(e,5),this.safeNumber(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){if(void 0===s){void 0===i&&(i=1e3);const e=this.parseTimeframe(t);s=this.milliseconds()-1e3*e*i}await this.loadMarkets();const a=this.market(e),o={pair:a.id,candletype:this.safeString(this.timeframes,t,t),yyyymmdd:this.yyyymmdd(s,"")},n=await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(o,r)),d=this.safeValue(n,"data",{}),h=this.safeValue(d,"candlestick",[]),c=this.safeValue(h,0,{}),l=this.safeList(c,"ohlcv",[]);return this.parseOHLCVs(l,a,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"assets",[]);for(let e=0;e<i.length;e++){const s=i[e],r=this.safeString(s,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(s,"free_amount"),o.used=this.safeString(s,"locked_amount"),o.total=this.safeString(s,"onhand_amount"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserAssets(e);return this.parseBalance(t)}parseOrderStatus(e){return this.safeString({UNFILLED:"open",PARTIALLY_FILLED:"open",FULLY_FILLED:"closed",CANCELED_UNFILLED:"canceled",CANCELED_PARTIALLY_FILLED:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"pair");t=this.safeMarket(i,t);const r=this.safeInteger(e,"ordered_at"),a=this.safeString(e,"price"),o=this.safeString(e,"start_amount"),n=this.safeString(e,"executed_amount"),d=this.safeString(e,"remaining_amount"),h=this.safeString(e,"average_price"),c=this.parseOrderStatus(this.safeString(e,"status")),l=this.safeStringLower(e,"type"),u=this.safeStringLower(e,"side");return this.safeOrder({id:s,clientOrderId:void 0,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:c,symbol:t.symbol,type:l,timeInForce:void 0,postOnly:void 0,side:u,price:a,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:h,amount:o,filled:n,remaining:d,trades:void 0,fee:void 0,info:e},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={pair:o.id,amount:this.amountToPrecision(e,i),side:s,type:t};"limit"===t&&(n.price=this.priceToPrecision(e,r));const d=await this.privatePostUserSpotOrder(this.extend(n,a)),h=this.safeDict(d,"data");return this.parseOrder(h,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e,pair:this.market(t).id},r=await this.privatePostUserSpotCancelOrder(this.extend(i,s)),a=this.safeValue(r,"data");return this.parseOrder(a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),r={order_id:e,pair:i.id},a=await this.privateGetUserSpotOrder(this.extend(r,s)),o=this.safeDict(a,"data");return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==s&&(a.count=s),void 0!==t&&(a.since=this.parseToInt(t/1e3));const o=await this.privateGetUserSpotActiveOrders(this.extend(a,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"orders",[]);return this.parseOrders(d,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.pair=a.id),void 0!==s&&(r.count=s),void 0!==t&&(r.since=this.parseToInt(t/1e3));const o=await this.privateGetUserSpotTradeHistory(this.extend(r,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"trades",[]);return this.parseTrades(d,a,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset:s.id},r=await this.privateGetUserWithdrawalAccount(this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"accounts",[]),n=this.safeValue(o,0,{});return{currency:s,address:this.safeString(n,"address"),tag:void 0,network:void 0,info:r}}async withdraw(e,t,s,i=void 0,a={}){if([i,a]=this.handleWithdrawTagAndParams(i,a),!("uuid"in a))throw new r.ExchangeError(this.id+" uuid is required for withdrawal");await this.loadMarkets();const o=this.currency(e),n={asset:o.id,amount:t},d=await this.privatePostUserRequestWithdrawal(this.extend(n,a)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,o)}parseTransaction(e,t=void 0){const s=this.safeString(e,"txid");return{id:s,txid:s,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:(t=this.safeCurrency(void 0,t)).code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n=this.omit(i,this.extractParams(e)),d=this.implodeHostname(this.urls.api[t])+"/";if("public"===t||"markets"===t)d+=this.implodeParams(e,i),Object.keys(n).length&&(d+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const t=this.nonce().toString();let h=t;d+=this.version+"/"+this.implodeParams(e,i),"POST"===s?h+=a=this.json(n):(h+="/"+this.version+"/"+e,Object.keys(n).length&&(n=this.urlencode(n),d+="?"+n,h+="?"+n)),r={"Content-Type":"application/json","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":t,"ACCESS-SIGNATURE":this.hmac(this.encode(h),this.encode(this.secret),o.s)}}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeInteger(n,"success"),l=this.safeValue(n,"data");if(!c||!l){const e={1e4:"URL does not exist",10001:"A system error occurred. Please contact support",10002:"Invalid JSON format. Please check the contents of transmission",10003:"A system error occurred. Please contact support",10005:"A timeout error occurred. Please wait for a while and try again",20001:"API authentication failed",20002:"Illegal API key",20003:"API key does not exist",20004:"API Nonce does not exist",20005:"API signature does not exist",20011:"Two-step verification failed",20014:"SMS authentication failed",30001:"Please specify the order quantity",30006:"Please specify the order ID",30007:"Please specify the order ID array",30009:"Please specify the stock",30012:"Please specify the order price",30013:"Trade Please specify either",30015:"Please specify the order type",30016:"Please specify asset name",30019:"Please specify uuid",30039:"Please specify the amount to be withdrawn",40001:"The order quantity is invalid",40006:"Count value is invalid",40007:"End time is invalid",40008:"end_id Value is invalid",40009:"The from_id value is invalid",40013:"The order ID is invalid",40014:"The order ID array is invalid",40015:"Too many specified orders",40017:"Incorrect issue name",40020:"The order price is invalid",40021:"The trading classification is invalid",40022:"Start date is invalid",40024:"The order type is invalid",40025:"Incorrect asset name",40028:"uuid is invalid",40048:"The amount of withdrawal is illegal",50003:"Currently, this account is in a state where you can not perform the operation you specified. Please contact support",50004:"Currently, this account is temporarily registered. Please try again after registering your account",50005:"Currently, this account is locked. Please contact support",50006:"Currently, this account is locked. Please contact support",50008:"User identification has not been completed",50009:"Your order does not exist",50010:"Can not cancel specified order",50011:"API not found",60001:"The number of possessions is insufficient",60002:"It exceeds the quantity upper limit of the tender buying order",60003:"The specified quantity exceeds the limit",60004:"The specified quantity is below the threshold",60005:"The specified price is above the limit",60006:"The specified price is below the lower limit",70001:"A system error occurred. Please contact support",70002:"A system error occurred. Please contact support",70003:"A system error occurred. Please contact support",70004:"We are unable to accept orders as the transaction is currently suspended",70005:"Order can not be accepted because purchase order is currently suspended",70006:"We can not accept orders because we are currently unsubscribed ",70009:"We are currently temporarily restricting orders to be carried out. Please use the limit order.",70010:"We are temporarily raising the minimum order quantity as the system load is now rising."},t=this.safeString(l,"code"),s=this.safeString(e,t,"Error");throw this.throwExactlyMatchedException(this.exceptions.exact,t,s),new r.ExchangeError(this.id+" "+this.json(n))}}}},8085:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(6022);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitbay",name:"BitBay",alias:!0})}}},6328:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5625),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitbns",name:"Bitbns",countries:["IN"],rateLimit:1e3,certified:!1,version:"v2",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:void 0,cancelAllOrders:!1,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:"emulated",fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!1},hostname:"bitbns.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/117201933-e7a6e780-adf5-11eb-9d80-98fc2a21c3d6.jpg",api:{www:"https://{hostname}",v1:"https://api.{hostname}/api/trade/v1",v2:"https://api.{hostname}/api/trade/v2"},www:"https://bitbns.com",referral:"https://ref.bitbns.com/1090961",doc:["https://bitbns.com/trade/#/api-trading/"],fees:"https://bitbns.com/fees"},api:{www:{get:["order/fetchMarkets","order/fetchTickers","order/fetchOrderbook","order/getTickerWithVolume","exchangeData/ohlc","exchangeData/orderBook","exchangeData/tradedetails"]},v1:{get:["platform/status","tickers","orderbook/sell/{symbol}","orderbook/buy/{symbol}"],post:["currentCoinBalance/EVERYTHING","getApiUsageStatus/USAGE","getOrderSocketToken/USAGE","currentCoinBalance/{symbol}","orderStatus/{symbol}","depositHistory/{symbol}","withdrawHistory/{symbol}","withdrawHistoryAll/{symbol}","depositHistoryAll/{symbol}","listOpenOrders/{symbol}","listOpenStopOrders/{symbol}","getCoinAddress/{symbol}","placeSellOrder/{symbol}","placeBuyOrder/{symbol}","buyStopLoss/{symbol}","sellStopLoss/{symbol}","cancelOrder/{symbol}","cancelStopLossOrder/{symbol}","listExecutedOrders/{symbol}","placeMarketOrder/{symbol}","placeMarketOrderQnty/{symbol}"]},v2:{post:["orders","cancel","getordersnew","marginOrders"]}},fees:{trading:{feeSide:"quote",tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")}},precisionMode:o.kb,exceptions:{exact:{400:r.BadRequest,409:r.BadSymbol,416:r.InsufficientFunds,417:r.OrderNotFound},broad:{}}})}async fetchStatus(e={}){const t=await this.v1GetPlatformStatus(e),s=this.safeString(t,"status");return{status:this.safeString({1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.wwwGetOrderFetchMarkets(e),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"id"),a=this.safeString(i,"base"),o=this.safeString(i,"quote"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeValue(i,"precision",{}),c=this.safeValue(i,"limits",{}),l=this.safeValue(c,"amount",{}),u=this.safeValue(c,"price",{}),p=this.safeValue(c,"cost",{}),f="USDT"===o?a+"_"+o:a;s.push({id:r,uppercaseId:f,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(h,"amount"))),price:this.parseNumber(this.parsePrecision(this.safeString(h,"price")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(l,"min"),max:this.safeNumber(l,"max")},price:{min:this.safeNumber(u,"min"),max:this.safeNumber(u,"max")},cost:{min:this.safeNumber(p,"min"),max:this.safeNumber(p,"max")}},created:void 0,info:i})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit=t);const a=await this.wwwGetOrderFetchOrderbook(this.extend(r,s)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeString(e,"last");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidVolume"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askVolume"),vwap:this.safeString(e,"vwap"),open:this.safeString(e,"open"),close:a,last:a,previousClose:this.safeString(e,"previousClose"),change:this.safeString(e,"change"),percentage:this.safeString(e,"percentage"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.wwwGetOrderFetchTickers(t);return this.parseTickers(s,e)}parseBalance(e){const t=void 0,s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data",{}),r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],a=t.split("availableorder");if(a.length>1){let e=this.safeString(a,1);const r=this.account();r.free=this.safeString(i,t),r.used=this.safeString(i,"inorder"+e),"Money"===e&&(e="INR");s[this.safeCurrencyCode(e)]=r}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PostCurrentCoinBalanceEVERYTHING(e);return this.parseBalance(t)}parseStatus(e){return this.safeString({"-1":"cancelled",0:"open",1:"open",2:"done"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","entry_id"),i=this.safeString(e,"time"),r=this.safeString(e,"t_rate");let a=this.safeString(e,"type");"0"===a?a="buy":"1"===a&&(a="sell");const o=this.safeString(e,"data");let n=this.safeString(e,"status");return n="Successfully cancelled the order"===o?"cancelled":this.parseStatus(n),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:this.parse8601(i),datetime:i,lastTradeTimestamp:void 0,symbol:this.safeString(t,"symbol"),timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"rate"),stopPrice:r,triggerPrice:r,amount:this.safeString(e,"btc"),cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:n,fee:{cost:void 0,currency:void 0,rate:void 0},trades:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeStringN(a,["triggerPrice","stopPrice","t_rate"]),d=this.safeString(a,"target_rate"),h=this.safeString(a,"trail_rate");a=this.omit(a,["triggerPrice","stopPrice","trail_rate","target_rate","t_rate"]);const c={side:s.toUpperCase(),symbol:o.uppercaseId,quantity:this.amountToPrecision(e,i)};let l="v2PostOrders";"limit"===t?c.rate=this.priceToPrecision(e,r):(l="v1PostPlaceMarketOrderQntySymbol",c.market=o.quoteId),void 0!==n&&(c.t_rate=this.priceToPrecision(e,n)),void 0!==d&&(c.target_rate=this.priceToPrecision(e,d)),void 0!==h&&(c.trail_rate=this.priceToPrecision(e,h));const u=await this[l](this.extend(c,a));return this.parseOrder(u,o)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeValue2(s,"trigger","stop");s=this.omit(s,["trigger","stop"]);const o={entry_id:e,symbol:i.uppercaseId};let n;const d=a?"StopLossOrder":"Order";let h="USDT"===i.quoteId?"usdtcancel":"cancel";return h+=d,o.side=h,n=await this.v2PostCancel(this.extend(o,s)),this.parseOrder(n,i)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id,entry_id:e};if(this.safeValue2(s,"trigger","stop"))throw new r.BadRequest(this.id+" fetchOrder cannot fetch stop orders");const o=await this.v1PostOrderStatusSymbol(this.extend(a,s)),n=this.safeValue(o,"data",[]),d=this.safeDict(n,0);return this.parseOrder(d,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o=this.safeValue2(i,"trigger","stop");i=this.omit(i,["trigger","stop"]);const n="USDT"===a.quoteId?"usdtListOpen":"listOpen",d={symbol:a.uppercaseId,page:0,side:o?n+"StopOrders":n+"Orders"},h=await this.v2PostGetordersnew(this.extend(d,i)),c=this.safeList(h,"data",[]);return this.parseOrders(c,a,t,s)}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString2(e,"id","tradeId");let i=this.parse8601(this.safeString(e,"date"));i=this.safeInteger(e,"timestamp",i);const r=this.safeString2(e,"rate","price");let o=this.safeString(e,"amount"),n=this.safeStringLower(e,"type");void 0!==n&&(n.indexOf("buy")>=0?n="buy":n.indexOf("sell")>=0&&(n="sell"));const d=this.safeString(e,"factor");let h;void 0!==d?o=a.Y.stringDiv(o,d):(o=this.safeString(e,"base_volume"),h=this.safeString(e,"quote_volume"));const c=t.symbol;let l;const u=this.safeString(e,"fee");if(void 0!==u){l={cost:u,currency:t.quote}}return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:c,id:s,order:s,type:void 0,side:n,takerOrMaker:void 0,price:r,amount:o,cost:h,fee:l},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,page:0};void 0!==t&&(o.since=this.iso8601(t));const n=await this.v1PostListExecutedOrdersSymbol(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={coin:a.baseId,market:a.quoteId},n=await this.wwwGetExchangeDataTradedetails(this.extend(o,i));return this.parseTrades(n,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const a=this.currency(e),o={symbol:a.id,page:0},n=await this.v1PostDepositHistorySymbol(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const a=this.currency(e),o={symbol:a.id,page:0},n=await this.v1PostWithdrawHistorySymbol(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s)}parseTransactionStatusByType(e,t=void 0){const s=this.safeValue({deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",6:"ok"}},t,{});return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"unit"),i=this.safeCurrencyCode(s,t),r=this.parse8601(this.safeString2(e,"date","timestamp"));let a=this.safeString(e,"type");const o=this.safeString(e,"expTime","");let n;void 0!==a&&(a.indexOf("deposit")>=0?(a="deposit",n="ok"):(a.indexOf("withdraw")>=0||o.indexOf("withdraw")>=0)&&(a="withdrawal"));const d=this.safeNumber(e,"amount"),h=this.safeNumber(e,"fee");let c;return void 0!==h&&(c={currency:i,cost:h}),{info:e,id:void 0,txid:void 0,timestamp:r,datetime:this.iso8601(r),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:a,amount:d,currency:i,status:n,updated:void 0,comment:void 0,internal:void 0,fee:c}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={symbol:this.currency(e).id},i=await this.v1PostGetCoinAddressSymbol(this.extend(s,t)),r=this.safeValue(i,"data",{}),a=this.safeString(r,"token"),o=this.safeString(r,"tag");return this.checkAddress(a),{currency:e,address:a,tag:o,network:void 0,info:i}}nonce(){return this.milliseconds()}sign(e,t="www",s="GET",i={},a=void 0,o=void 0){if(!(t in this.urls.api))throw new r.ExchangeError(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");"www"!==t&&(this.checkRequiredCredentials(),a={"X-BITBNS-APIKEY":this.apiKey});let d=this.implodeHostname(this.urls.api[t])+"/"+this.implodeParams(e,i);const h=this.omit(i,this.extractParams(e)),c=this.nonce().toString();if("GET"===s)Object.keys(h).length&&(d+="?"+this.urlencode(h));else if("POST"===s){const e={timeStamp_nonce:c,body:o=Object.keys(h).length?this.json(h):"{}"},t=this.stringToBase64(this.json(e)),s=this.hmac(this.encode(t),this.encode(this.secret),n.Zf);a["X-BITBNS-PAYLOAD"]=t,a["X-BITBNS-SIGNATURE"]=s,a["Content-Type"]="application/x-www-form-urlencoded"}return{url:d,method:s,body:o,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"msg");if(void 0!==c&&"200"!==c&&"204"!==c||void 0!==l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},8959:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(3042);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitcoincom",name:"Bitcoin.com",alias:!0})}}},8657:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9332),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitfinex",name:"Bitfinex",countries:["VG"],version:"v1",rateLimit:666.666,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchDepositAddress:!0,fetchDeposits:!1,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchIndexOHLCV:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:"emulated",transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v2:"https://api-pub.bitfinex.com",public:"https://api.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",referral:"https://www.bitfinex.com/?refcode=P61eYxFL",doc:["https://docs.bitfinex.com/v1/docs","https://github.com/bitfinexcom/bitfinex-api-node"]},api:{v2:{get:{"platform/status":3,tickers:1,"ticker/{symbol}":1,"tickers/hist":1,"trades/{symbol}/hist":1,"book/{symbol}/{precision}":.375,"book/{symbol}/P0":.375,"book/{symbol}/P1":.375,"book/{symbol}/P2":.375,"book/{symbol}/P3":.375,"book/{symbol}/R0":.375,"stats1/{key}:{size}:{symbol}:{side}/{section}":1,"stats1/{key}:{size}:{symbol}/{section}":1,"stats1/{key}:{size}:{symbol}:long/last":1,"stats1/{key}:{size}:{symbol}:long/hist":1,"stats1/{key}:{size}:{symbol}:short/last":1,"stats1/{key}:{size}:{symbol}:short/hist":1,"candles/trade:{timeframe}:{symbol}/{section}":1,"candles/trade:{timeframe}:{symbol}/last":1,"candles/trade:{timeframe}:{symbol}/hist":1}},public:{get:{"book/{symbol}":1,"lendbook/{currency}":6,"lends/{currency}":3,"pubticker/{symbol}":3,"stats/{symbol}":6,symbols:18,symbols_details:18,tickers:1,"trades/{symbol}":3}},private:{post:{account_fees:18,account_infos:6,balances:9.036,basket_manage:6,credits:6,"deposit/new":18,"funding/close":6,history:6,"history/movements":6,key_info:6,margin_infos:3,mytrades:3,mytrades_funding:6,"offer/cancel":6,"offer/new":6,"offer/status":6,offers:6,"offers/hist":90.03,"order/cancel":.2,"order/cancel/all":.2,"order/cancel/multi":.2,"order/cancel/replace":.2,"order/new":.2,"order/new/multi":.2,"order/status":.2,orders:.2,"orders/hist":90.03,"position/claim":18,"position/close":18,positions:18,summary:18,taken_funds:6,total_taken_funds:6,transfer:18,unused_taken_funds:6,withdraw:18}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,deposit:{},withdraw:{}}},commonCurrencies:{ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",UST:"USDT",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"},exceptions:{exact:{temporarily_unavailable:r.ExchangeNotAvailable,"Order could not be cancelled.":r.OrderNotFound,"No such order found.":r.OrderNotFound,"Order price must be positive.":r.InvalidOrder,"Could not find a key matching the given X-BFX-APIKEY.":r.AuthenticationError,'Key price should be a decimal number, e.g. "123.456"':r.InvalidOrder,'Key amount should be a decimal number, e.g. "123.456"':r.InvalidOrder,ERR_RATE_LIMIT:r.RateLimitExceeded,Ratelimit:r.RateLimitExceeded,"Nonce is too small.":r.InvalidNonce,"No summary found.":r.ExchangeError,"Cannot evaluate your available balance, please try again":r.ExchangeNotAvailable,"Unknown symbol":r.BadSymbol,"Cannot complete transfer. Exchange balance insufficient.":r.InsufficientFunds,"Momentary balance check. Please wait few seconds and try the transfer again.":r.ExchangeError},broad:{"Invalid X-BFX-SIGNATURE":r.AuthenticationError,"This API key does not have permission":r.PermissionDenied,"not enough exchange balance for ":r.InsufficientFunds,"minimum size for ":r.InvalidOrder,"Invalid order":r.InvalidOrder,"The available balance is only":r.InsufficientFunds}},precisionMode:o.v,options:{currencyNames:{AGI:"agi",AID:"aid",AIO:"aio",ANT:"ant",AVT:"aventus",BAT:"bat",BCH:"bab",BCI:"bci",BFT:"bft",BSV:"bsv",BTC:"bitcoin",BTG:"bgold",CFI:"cfi",COMP:"comp",DAI:"dai",DADI:"dad",DASH:"dash",DATA:"datacoin",DTH:"dth",EDO:"eidoo",ELF:"elf",EOS:"eos",ETC:"ethereumc",ETH:"ethereum",ETP:"metaverse",FUN:"fun",GNT:"golem",IOST:"ios",IOTA:"iota",LEO:"let",LINK:"link",LRC:"lrc",LTC:"litecoin",LYM:"lym",MANA:"mna",MIT:"mit",MKR:"mkr",MTN:"mtn",NEO:"neo",ODE:"ode",OMG:"omisego",OMNI:"mastercoin",QASH:"qash",QTUM:"qtum",RCN:"rcn",RDN:"rdn",REP:"rep",REQ:"req",RLC:"rlc",SAN:"santiment",SNGLS:"sng",SNT:"status",SPANK:"spk",STORJ:"stj",TNB:"tnb",TRX:"trx",TUSD:"tsd",USD:"wire",USDC:"udc",UTK:"utk",USDT:"tetheruso",VEE:"vee",WAX:"wax",XLM:"xlm",XMR:"monero",XRP:"ripple",XVG:"xvg",YOYOW:"yoyow",ZEC:"zcash",ZRX:"zrx",XTZ:"xtz"},orderTypes:{limit:"exchange limit",market:"exchange market"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CNH:"CNH"},accountsByType:{spot:"exchange",margin:"trading",funding:"deposit",swap:"trading"}}})}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s={},i=await this.privatePostAccountFees(t),r=this.safeValue(i,"withdraw"),a=Object.keys(r);for(let t=0;t<a.length;t++){const i=a[t],o=this.safeCurrencyCode(i);(void 0===e||this.inArray(o,e))&&(s[o]={withdraw:this.safeNumber(r,i),deposit:{},info:this.safeNumber(r,i)})}return s}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAccountFees(t),i=this.safeList(s,"withdraw");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFee(e,t=void 0){return{withdraw:{fee:this.parseNumber(e),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{},info:e}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),r=this.safeNumber(t,"maker_fee"),a=this.safeNumber(t,"taker_fee"),o=this.safeNumber(t,"maker_fee_2fiat"),n=this.safeNumber(t,"taker_fee_2fiat"),d=this.safeNumber(t,"maker_fee_2deriv"),h=this.safeNumber(t,"taker_fee_2deriv");for(let e=0;e<this.symbols.length;e++){const c=this.symbols[e],l=this.market(c),u={info:t,symbol:c,percentage:!0,tierBased:!0};l.quote in i?(u.maker=o,u.taker=n):l.contract?(u.maker=d,u.taker=h):(u.maker=r,u.taker=a),s[c]=u}return s}async fetchMarkets(e={}){const t=await this.publicGetSymbols(),s=await this.publicGetSymbolsDetails(),i=[];for(let e=0;e<s.length;e++){const r=s[e];let a,o,n=this.safeString(r,"pair");if(!this.inArray(n,t))continue;if(n=n.toUpperCase(),n.indexOf(":")>=0){const e=n.split(":");a=e[0],o=e[1]}else a=n.slice(0,3),o=n.slice(3,6);const d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),c=d+"/"+h;let l="spot";n.indexOf("F0")>-1&&(l="swap"),i.push({id:n,symbol:c,base:d,quote:h,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:l,spot:"spot"===l,margin:this.safeValue(r,"margin"),swap:"swap"===l,future:!1,option:!1,active:!0,contract:"swap"===l,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:this.safeInteger(r,"price_precision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(r,"minimum_order_size"),max:this.safeNumber(r,"maximum_order_size")},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:r})}return i}amountToPrecision(e,t){return e=this.safeSymbol(e),this.decimalToPrecision(t,o.R3,this.markets[e].precision.amount,o.fv)}priceToPrecision(e,t){return e=this.safeSymbol(e),t=this.decimalToPrecision(t,o.D_,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,o.R3,8,o.fv)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"accountsByType",{}),s=this.safeString(e,"type","exchange"),i=this.safeString(t,s,s);if(void 0===i){const e=Object.keys(t);throw new r.ExchangeError(this.id+" fetchBalance() type parameter must be one of "+e.join(", "))}const a=this.omit(e,"type"),o=await this.privatePostBalances(a),n={info:o},d="derivatives"===s;for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"type"),r=this.safeStringLower(t,"currency",""),a=r.length-2,h="f0"===r.slice(a);if(i===s&&(!d||h)){const e=this.safeCurrencyCode(r);if(!(e in n)){const s=this.account();s.free=this.safeString(t,"available"),s.total=this.safeString(t,"amount"),n[e]=s}}}return this.safeBalance(n)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.currency(e),c=this.convertDerivativesId(h.id,s),l=this.convertDerivativesId(h.id,i),u=this.currencyToPrecision(e,t),p={amount:u,currency:c,currency_to:l,walletfrom:n,walletto:d},f=await this.privatePostTransfer(this.extend(p,a)),m=this.safeValue(f,0);if(void 0===this.safeString(m,"message"))throw new r.ExchangeError(this.id+" transfer failed");return this.extend(this.parseTransfer(m,h),{fromAccount:s,toAccount:i,amount:this.parseNumber(u)})}parseTransfer(e,t=void 0){return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(this.safeString(e,"status"))}}parseTransferStatus(e){return this.safeString({SUCCESS:"ok"},e,e)}convertDerivativesId(e,t){const s=e.length-2,i="F0"===e.slice(s);return"derivatives"!==t&&"trading"!==t&&"margin"!==t&&i?e=e.slice(0,s):"derivatives"!==t||i||(e+="F0"),e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit_bids=t,r.limit_asks=t);const a=await this.publicGetBookSymbol(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);i[t.symbol]=t}return this.filterByArrayTickers(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetPubtickerSymbol(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"pair"),r=(t=this.safeMarket(i,t)).symbol,a=this.safeString(e,"last_price");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"mid"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"tid"),i=this.safeTimestamp(e,"timestamp"),r=this.safeStringLower(e,"type"),o=this.safeString(e,"order_id"),n=this.safeString(e,"price"),d=this.safeString(e,"amount");let h;if("fee_amount"in e){const t=a.Y.stringNeg(this.safeString(e,"fee_amount")),s=this.safeString(e,"fee_currency");h={cost:t,currency:this.safeCurrencyCode(s)}}return this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:undefined,order:o,side:r,takerOrMaker:void 0,price:n,amount:d,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=50,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id,limit_trades:s};void 0!==t&&(a.timestamp=this.parseToInt(t/1e3));const o=await this.publicGetTradesSymbol(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==s&&(o.limit_trades=s),void 0!==t&&(o.timestamp=this.parseToInt(t/1e3));const n=await this.privatePostMytrades(this.extend(o,i));return this.parseTrades(n,a,t,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"postOnly",!1);t=t.toLowerCase(),a=this.omit(a,["postOnly"]),o.spot&&(t=this.safeStringLower(this.options.orderTypes,t,t));const d={symbol:o.id,side:s,amount:this.amountToPrecision(e,i),type:t,ocoorder:!1,buy_price_oco:0,sell_price_oco:0};t.indexOf("market")>-1?d.price=this.nonce().toString():d.price=this.priceToPrecision(e,r),n&&(d.is_postonly=!0);const h=await this.privatePostOrderNew(this.extend(d,a));return this.parseOrder(h,o)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n={order_id:parseInt(e)};void 0!==a&&(n.price=this.priceToPrecision(t,a)),void 0!==r&&(n.amount=this.numberToString(r)),void 0!==t&&(n.symbol=this.marketId(t)),void 0!==i&&(n.side=i),void 0!==s&&(n.type=this.safeString(this.options.orderTypes,s,s));const d=await this.privatePostOrderCancelReplace(this.extend(n,o));return this.parseOrder(d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},r=await this.privatePostOrderCancel(this.extend(i,s));return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){const s=await this.privatePostOrderCancelAll(t);return[this.safeOrder({info:s})]}parseOrder(e,t=void 0){const s=this.safeString(e,"side"),i=this.safeValue(e,"is_live"),r=this.safeValue(e,"is_cancelled");let a;a=i?"open":r?"canceled":"closed";const o=this.safeStringUpper(e,"symbol"),n=this.safeSymbol(o,t);let d=this.safeString(e,"type","");if(d.indexOf("exchange ")>=0){d=e.type.split(" ")[1]}const h=this.safeTimestamp(e,"timestamp"),c=this.safeString(e,"id");return this.safeOrder({info:e,id:c,clientOrderId:void 0,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,symbol:n,type:d,timeInForce:void 0,postOnly:void 0,side:s,price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,average:this.safeString(e,"avg_execution_price"),amount:this.safeString(e,"original_amount"),remaining:this.safeString(e,"remaining_amount"),filled:this.safeString(e,"executed_amount"),status:a,fee:void 0,cost:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0!==e&&!(e in this.markets))throw new r.ExchangeError(this.id+" has no symbol "+e);const a=await this.privatePostOrders(i);let o=this.parseOrders(a,void 0,t,s);return void 0!==e&&(o=this.filterBy(o,"symbol",e)),o}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r={};void 0!==s&&(r.limit=s);const a=await this.privatePostOrdersHist(this.extend(r,i));let o=this.parseOrders(a,void 0,t,s);return void 0!==e&&(o=this.filterBy(o,"symbol",e)),o=this.filterByArray(o,"status",["closed","canceled"],!1),o}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},r=await this.privatePostOrderStatus(this.extend(i,s));return this.parseOrder(r)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),i=void 0===i?100:Math.min(i,1e4);const a=this.market(e),o={symbol:"t"+a.id,timeframe:this.safeString(this.timeframes,t,t),sort:1,limit:i};void 0!==s&&(o.start=s);const n=await this.v2GetCandlesTradeTimeframeSymbolHist(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new r.NotSupported(this.id+" "+e+" not supported for withdrawal")}async createDepositAddress(e,t={}){await this.loadMarkets();return await this.fetchDepositAddress(e,this.extend({renew:1},t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={method:this.getCurrencyName(e),wallet_name:"exchange",renew:0},i=await this.privatePostDepositNew(this.extend(s,t));let r,a=this.safeValue(i,"address");return"address_pool"in i&&(r=a,a=i.address_pool),this.checkAddress(a),{currency:e,address:a,tag:r,network:void 0,info:i}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=this.safeString(i,"currency");const o=this.omit(i,"currency");let n;if(void 0===a){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDepositsWithdrawals() requires a currency `code` argument or a `currency` parameter");n=this.currency(e),a=n.id}o.currency=a,void 0!==t&&(o.since=this.parseToInt(t/1e3));const d=await this.privatePostHistoryMovements(this.extend(o,i));return this.parseTransactions(d,n,t,s)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp_created"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i,t);let o=this.safeString(e,"fee");return void 0!==o&&(o=a.Y.stringAbs(o)),{info:e,id:this.safeString2(e,"id","withdrawal_id"),txid:this.safeString(e,"txid"),type:this.safeStringLower(e,"type"),currency:r,network:void 0,amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"status")),timestamp:s,datetime:this.iso8601(s),address:this.safeString(e,"address"),addressFrom:void 0,addressTo:void 0,tag:this.safeString(e,"description"),tagFrom:void 0,tagTo:void 0,updated:this.safeTimestamp(e,"timestamp"),comment:void 0,internal:void 0,fee:{currency:r,cost:this.parseNumber(o),rate:void 0}}}parseTransactionStatus(e){return this.safeString({SENDING:"pending",CANCELED:"canceled",ZEROCONFIRMED:"failed",COMPLETED:"ok"},e,e)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.getCurrencyName(e),n=this.currency(e),d={withdraw_type:o,walletselected:"exchange",amount:this.numberToString(t),address:s};void 0!==i&&(d.payment_id=i);const h=await this.privatePostWithdraw(this.extend(d,a)),c=this.safeValue(h,0,{}),l=this.safeInteger(c,"withdrawal_id"),u=this.safeString(c,"message"),p=this.findBroadlyMatchedKey(this.exceptions.broad,u);if(0===l){if(void 0!==p){throw new(0,this.exceptions.broad[p])(this.id+" "+u)}throw new r.ExchangeError(this.id+" withdraw returned an id of zero: "+this.json(c))}return this.parseTransaction(c,n)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();return await this.privatePostPositions(t)}nonce(){return this.microseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.implodeParams(e,i);o="v2"===t?"/"+t+o:"/"+this.version+o;let d=this.omit(i,this.extractParams(e)),h=this.urls.api[t]+o;if(("public"===t||e.indexOf("/hist")>=0)&&Object.keys(d).length){const e="?"+this.urlencode(d);h+=e,o+=e}if("private"===t){this.checkRequiredCredentials();const e=this.nonce();d=this.extend({nonce:e.toString(),request:o},d),a=this.json(d);const t=this.stringToBase64(a),s=this.encode(this.secret),i=this.hmac(this.encode(t),s,n.qt);r={"X-BFX-APIKEY":this.apiKey,"X-BFX-PAYLOAD":t,"X-BFX-SIGNATURE":i,"Content-Type":"application/json"}}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;let c=!1;if(e>=400)"{"===o[0]&&(c=!0);else{const e=this.safeValue(n,0,{});"error"===this.safeString(e,"status","")&&(c=!0)}if(c){const e=this.id+" "+o,t=this.safeString2(n,"message","error");throw this.throwExactlyMatchedException(this.exceptions.exact,t,e),this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new r.ExchangeError(e)}}}},8703:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(2079),r=s(5147),a=s(6740),o=s(1579),n=s(7481);class d extends a.A{describe(){return this.deepExtend(super.describe(),{id:"bitfinex2",name:"Bitfinex",countries:["VG"],version:"v2",certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!1,borrowCrossMargin:!1,borrowIsolatedMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTrailingAmountOrder:!0,createTrailingPercentOrder:!1,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrder:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchLiquidations:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTickers:!0,fetchTime:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:void 0,fetchTransactions:"emulated",reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!0,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},rateLimit:250,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg",api:{v1:"https://api.bitfinex.com",public:"https://api-pub.bitfinex.com",private:"https://api.bitfinex.com"},www:"https://www.bitfinex.com",doc:["https://docs.bitfinex.com/v2/docs/","https://github.com/bitfinexcom/bitfinex-api-node"],fees:"https://www.bitfinex.com/fees"},api:{public:{get:{"conf/{config}":2.7,"conf/pub:{action}:{object}":2.7,"conf/pub:{action}:{object}:{detail}":2.7,"conf/pub:map:{object}":2.7,"conf/pub:map:{object}:{detail}":2.7,"conf/pub:map:currency:{detail}":2.7,"conf/pub:map:currency:sym":2.7,"conf/pub:map:currency:label":2.7,"conf/pub:map:currency:unit":2.7,"conf/pub:map:currency:undl":2.7,"conf/pub:map:currency:pool":2.7,"conf/pub:map:currency:explorer":2.7,"conf/pub:map:currency:tx:fee":2.7,"conf/pub:map:tx:method":2.7,"conf/pub:list:{object}":2.7,"conf/pub:list:{object}:{detail}":2.7,"conf/pub:list:currency":2.7,"conf/pub:list:pair:exchange":2.7,"conf/pub:list:pair:margin":2.7,"conf/pub:list:pair:futures":2.7,"conf/pub:list:competitions":2.7,"conf/pub:info:{object}":2.7,"conf/pub:info:{object}:{detail}":2.7,"conf/pub:info:pair":2.7,"conf/pub:info:pair:futures":2.7,"conf/pub:info:tx:status":2.7,"conf/pub:fees":2.7,"platform/status":8,tickers:2.7,"ticker/{symbol}":2.7,"tickers/hist":2.7,"trades/{symbol}/hist":2.7,"book/{symbol}/{precision}":1,"book/{symbol}/P0":1,"book/{symbol}/P1":1,"book/{symbol}/P2":1,"book/{symbol}/P3":1,"book/{symbol}/R0":1,"stats1/{key}:{size}:{symbol}:{side}/{section}":2.7,"stats1/{key}:{size}:{symbol}:{side}/last":2.7,"stats1/{key}:{size}:{symbol}:{side}/hist":2.7,"stats1/{key}:{size}:{symbol}/{section}":2.7,"stats1/{key}:{size}:{symbol}/last":2.7,"stats1/{key}:{size}:{symbol}/hist":2.7,"stats1/{key}:{size}:{symbol}:long/last":2.7,"stats1/{key}:{size}:{symbol}:long/hist":2.7,"stats1/{key}:{size}:{symbol}:short/last":2.7,"stats1/{key}:{size}:{symbol}:short/hist":2.7,"candles/trade:{timeframe}:{symbol}:{period}/{section}":2.7,"candles/trade:{timeframe}:{symbol}/{section}":2.7,"candles/trade:{timeframe}:{symbol}/last":2.7,"candles/trade:{timeframe}:{symbol}/hist":2.7,"status/{type}":2.7,"status/deriv":2.7,"status/deriv/{symbol}/hist":2.7,"liquidations/hist":80,"rankings/{key}:{timeframe}:{symbol}/{section}":2.7,"rankings/{key}:{timeframe}:{symbol}/hist":2.7,"pulse/hist":2.7,"pulse/profile/{nickname}":2.7,"funding/stats/{symbol}/hist":10},post:{"calc/trade/avg":2.7,"calc/fx":2.7}},private:{post:{"auth/r/wallets":2.7,"auth/r/wallets/hist":2.7,"auth/r/orders":2.7,"auth/r/orders/{symbol}":2.7,"auth/w/order/submit":2.7,"auth/w/order/update":2.7,"auth/w/order/cancel":2.7,"auth/w/order/multi":2.7,"auth/w/order/cancel/multi":2.7,"auth/r/orders/{symbol}/hist":2.7,"auth/r/orders/hist":2.7,"auth/r/order/{symbol}:{id}/trades":2.7,"auth/r/trades/{symbol}/hist":2.7,"auth/r/trades/hist":2.7,"auth/r/ledgers/{currency}/hist":2.7,"auth/r/ledgers/hist":2.7,"auth/r/info/margin/{key}":2.7,"auth/r/info/margin/base":2.7,"auth/r/info/margin/sym_all":2.7,"auth/r/positions":2.7,"auth/w/position/claim":2.7,"auth/w/position/increase:":2.7,"auth/r/position/increase/info":2.7,"auth/r/positions/hist":2.7,"auth/r/positions/audit":2.7,"auth/r/positions/snap":2.7,"auth/w/deriv/collateral/set":2.7,"auth/w/deriv/collateral/limits":2.7,"auth/r/funding/offers":2.7,"auth/r/funding/offers/{symbol}":2.7,"auth/w/funding/offer/submit":2.7,"auth/w/funding/offer/cancel":2.7,"auth/w/funding/offer/cancel/all":2.7,"auth/w/funding/close":2.7,"auth/w/funding/auto":2.7,"auth/w/funding/keep":2.7,"auth/r/funding/offers/{symbol}/hist":2.7,"auth/r/funding/offers/hist":2.7,"auth/r/funding/loans":2.7,"auth/r/funding/loans/hist":2.7,"auth/r/funding/loans/{symbol}":2.7,"auth/r/funding/loans/{symbol}/hist":2.7,"auth/r/funding/credits":2.7,"auth/r/funding/credits/hist":2.7,"auth/r/funding/credits/{symbol}":2.7,"auth/r/funding/credits/{symbol}/hist":2.7,"auth/r/funding/trades/{symbol}/hist":2.7,"auth/r/funding/trades/hist":2.7,"auth/r/info/funding/{key}":2.7,"auth/r/info/user":2.7,"auth/r/summary":2.7,"auth/r/logins/hist":2.7,"auth/r/permissions":2.7,"auth/w/token":2.7,"auth/r/audit/hist":2.7,"auth/w/transfer":2.7,"auth/w/deposit/address":24,"auth/w/deposit/invoice":24,"auth/w/withdraw":24,"auth/r/movements/{currency}/hist":2.7,"auth/r/movements/hist":2.7,"auth/r/alerts":5.34,"auth/w/alert/set":2.7,"auth/w/alert/price:{symbol}:{price}/del":2.7,"auth/w/alert/{type}:{symbol}:{price}/del":2.7,"auth/calc/order/avail":2.7,"auth/w/settings/set":2.7,"auth/r/settings":2.7,"auth/w/settings/del":2.7,"auth/r/pulse/hist":2.7,"auth/w/pulse/add":16,"auth/w/pulse/del":2.7}}},fees:{trading:{feeSide:"get",percentage:!0,tierBased:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.002")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.002")],[this.parseNumber("7500000"),this.parseNumber("0.002")],[this.parseNumber("10000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("20000000"),this.parseNumber("0.0014")],[this.parseNumber("25000000"),this.parseNumber("0.0012")],[this.parseNumber("30000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("7500000"),this.parseNumber("0")],[this.parseNumber("10000000"),this.parseNumber("0")],[this.parseNumber("15000000"),this.parseNumber("0")],[this.parseNumber("20000000"),this.parseNumber("0")],[this.parseNumber("25000000"),this.parseNumber("0")],[this.parseNumber("30000000"),this.parseNumber("0")]]}},funding:{withdraw:{}}},precisionMode:o.v,options:{precision:"R0",exchangeTypes:{MARKET:"market","EXCHANGE MARKET":"market",LIMIT:"limit","EXCHANGE LIMIT":"limit","EXCHANGE STOP":"market","EXCHANGE FOK":"limit","EXCHANGE STOP LIMIT":"limit","EXCHANGE IOC":"limit"},orderTypes:{market:"EXCHANGE MARKET",limit:"EXCHANGE LIMIT"},fiat:{USD:"USD",EUR:"EUR",JPY:"JPY",GBP:"GBP",CHN:"CHN"},v2AccountsByType:{spot:"exchange",exchange:"exchange",funding:"funding",margin:"margin",derivatives:"margin",future:"margin",swap:"margin"},withdraw:{includeFee:!1},networks:{BTC:"BITCOIN",LTC:"LITECOIN",ERC20:"ETHEREUM",OMNI:"TETHERUSO",LIQUID:"TETHERUSL",TRC20:"TETHERUSX",EOS:"TETHERUSS",AVAX:"TETHERUSDTAVAX",SOL:"TETHERUSDTSOL",ALGO:"TETHERUSDTALG",BCH:"TETHERUSDTBCH",KSM:"TETHERUSDTKSM",DVF:"TETHERUSDTDVF",OMG:"TETHERUSDTOMG"},networksById:{TETHERUSE:"ERC20"}},exceptions:{exact:{11010:i.RateLimitExceeded,10001:i.PermissionDenied,10020:i.BadRequest,10100:i.AuthenticationError,10114:i.InvalidNonce,20060:i.OnMaintenance,temporarily_unavailable:i.ExchangeNotAvailable},broad:{address:i.InvalidAddress,"available balance is only":i.InsufficientFunds,"not enough exchange balance":i.InsufficientFunds,"Order not found":i.OrderNotFound,"symbol: invalid":i.BadSymbol,"Invalid order":i.InvalidOrder}},commonCurrencies:{UST:"USDT",EUTF0:"EURT",USTF0:"USDT",ALG:"ALGO",AMP:"AMPL",ATO:"ATOM",BCHABC:"XEC",BCHN:"BCH",DAT:"DATA",DOG:"MDOGE",DSH:"DASH",EDO:"PNT",EUS:"EURS",EUT:"EURT",HTX:"HT",IDX:"ID",IOT:"IOTA",IQX:"IQ",LUNA:"LUNC",LUNA2:"LUNA",MNA:"MANA",ORS:"ORS Group",PAS:"PASS",QSH:"QASH",QTM:"QTUM",RBT:"RBTC",SNG:"SNGLS",STJ:"STORJ",TERRAUST:"USTC",TSD:"TUSD",YGG:"YEED",YYW:"YOYOW",UDC:"USDC",VSY:"VSYS",WAX:"WAXP",XCH:"XCHF",ZBT:"ZB"}})}isFiat(e){return e in this.options.fiat}getCurrencyId(e){return"f"+e}getCurrencyName(e){if(e in this.options.currencyNames)return this.options.currencyNames[e];throw new i.NotSupported(this.id+" "+e+" not supported for withdrawal")}amountToPrecision(e,t){return e=this.safeSymbol(e),this.decimalToPrecision(t,o.R3,this.markets[e].precision.amount,o.fv)}priceToPrecision(e,t){return e=this.safeSymbol(e),t=this.decimalToPrecision(t,o.D_,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,o.R3,8,o.fv)}async fetchStatus(e={}){const t=await this.publicGetPlatformStatus(e),s=this.safeString(t,0);return{status:this.safeString({0:"maintenance",1:"ok"},s,s),updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){let t=await this.publicGetConfPubInfoPair(e),s=await this.publicGetConfPubInfoPairFutures(e);t=this.safeValue(t,0,[]),s=this.safeValue(s,0,[]);const i=this.arrayConcat(t,s);let r=await this.publicGetConfPubListPairMargin(e);r=this.safeValue(r,0,[]);const a=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeStringUpper(t,0),o=this.safeValue(t,1,{});let n=!0;s.indexOf("F0")>=0&&(n=!1);const d=!n;let h,c;if(s.indexOf(":")>=0){const e=s.split(":");h=e[0],c=e[1]}else h=s.slice(0,3),c=s.slice(3,6);let l=this.safeCurrencyCode(h),u=this.safeCurrencyCode(c);const p=l.split("F0"),f=u.split("F0");l=this.safeString(p,0),u=this.safeString(f,0);let m,g,v=l+"/"+u;h=this.getCurrencyId(h),c=this.getCurrencyId(c),d&&(m=u,g=u,v=v+":"+m);const y=this.safeString(o,3),w=this.safeString(o,4);let b=!1;n&&this.inArray(s,r)&&(b=!0),a.push({id:"t"+s,symbol:v,base:l,quote:u,settle:m,baseId:h,quoteId:c,settleId:g,type:n?"spot":"swap",spot:n,margin:b,swap:d,future:!1,option:!1,active:!0,contract:d,linear:!!d||void 0,inverse:!d&&void 0,contractSize:d?this.parseNumber("1"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("8"),price:parseInt("5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(y),max:this.parseNumber(w)},price:{min:this.parseNumber("1e-8"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:o})}return a}async fetchCurrencies(e={}){const t={config:["pub:list:currency","pub:map:currency:sym","pub:map:currency:label","pub:map:currency:unit","pub:map:currency:undl","pub:map:currency:pool","pub:map:currency:explorer","pub:map:currency:tx:fee","pub:map:tx:method"].join(",")},s=await this.publicGetConfConfig(this.extend(t,e)),i={sym:this.indexBy(this.safeValue(s,1,[]),0),label:this.indexBy(this.safeValue(s,2,[]),0),unit:this.indexBy(this.safeValue(s,3,[]),0),undl:this.indexBy(this.safeValue(s,4,[]),0),pool:this.indexBy(this.safeValue(s,5,[]),0),explorer:this.indexBy(this.safeValue(s,6,[]),0),fees:this.indexBy(this.safeValue(s,7,[]),0)},r=this.safeValue(s,0,[]),a={};for(let e=0;e<r.length;e++){const t=r[e];if(t.indexOf("F0")>=0)continue;const o=this.safeCurrencyCode(t),n=this.safeValue(i.label,t,[]),d=this.safeString(n,1),h=this.safeValue(i.pool,t,[]),c=void 0===this.safeString(h,1)?"other":"crypto",l=this.safeValue(i.fees,t,[]),u=this.safeValue(l,1,[]),p=this.safeNumber(u,1),f=this.safeValue(i.undl,t,[]),m="8",g="f"+t;a[o]={id:g,uppercaseId:t,code:o,info:[t,n,h,l,f],type:c,name:d,active:!0,deposit:void 0,withdraw:void 0,fee:p,precision:parseInt(m),limits:{amount:{min:this.parseNumber(this.parsePrecision(m)),max:void 0},withdraw:{min:p,max:void 0}},networks:{}};const v={},y=this.safeValue(s,8,[]),w=t.replace("F0","");for(let e=0;e<y.length;e++){const t=y[e],s=this.safeString(t,0);if(this.safeString(this.safeValue(t,1,[]),0)===w){v[this.networkIdToCode(s)]={info:s,id:s.toLowerCase(),network:s,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{withdraw:{min:void 0,max:void 0}}}}}Object.keys(v).length>0&&(a[o].networks=v)}return a}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"v2AccountsByType",{}),s=this.safeString(e,"type","exchange"),r=this.safeString(t,s,s);if(void 0===r){const e=Object.keys(t);throw new i.ExchangeError(this.id+" fetchBalance() type parameter must be one of "+e.join(", "))}const a="derivatives"===s,o=this.omit(e,"type"),n=await this.privatePostAuthRWallets(o),d={info:n};for(let e=0;e<n.length;e++){const t=n[e],s=this.account(),i=this.safeString(t,3);"0"!==i&&(s.debt=i);const o=this.safeString(t,0),h=this.safeStringLower(t,1,""),c=h.length-2,l="f0"===h.slice(c);if(r===o&&(!a||l)){const e=this.safeCurrencyCode(h);s.total=this.safeString(t,2),s.free=this.safeString(t,4),d[e]=s}}return this.safeBalance(d)}async transfer(e,t,s,r,a={}){await this.loadMarkets();const o=this.safeValue(this.options,"v2AccountsByType",{}),n=this.safeString(o,s);if(void 0===n){const e=Object.keys(o);throw new i.ArgumentsRequired(this.id+" transfer() fromAccount must be one of "+e.join(", "))}const d=this.safeString(o,r);if(void 0===d){const e=Object.keys(o);throw new i.ArgumentsRequired(this.id+" transfer() toAccount must be one of "+e.join(", "))}const h=this.currency(e),c=this.convertDerivativesId(h,s),l=this.convertDerivativesId(h,r),u={amount:this.currencyToPrecision(e,t),currency:c,currency_to:l,from:n,to:d},p=await this.privatePostAuthWTransfer(this.extend(u,a));if("error"===this.safeString(p,0)){const e=this.safeString(p,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,e,this.id+" "+e),new i.ExchangeError(this.id+" "+e)}return this.parseTransfer({result:p},h)}parseTransfer(e,t=void 0){const s=this.safeList(e,"result"),i=this.safeInteger(s,0),r=this.safeValue(s,4),a=this.safeString(r,1),o=this.safeString(r,2),n=this.safeString(r,5),d=this.safeString(s,6);return{id:void 0,timestamp:i,datetime:this.iso8601(i),status:this.parseTransferStatus(d),amount:this.safeNumber(r,7),currency:this.safeCurrencyCode(n,t),fromAccount:a,toAccount:o,info:s}}parseTransferStatus(e){return this.safeString({SUCCESS:"ok",ERROR:"failed",FAILURE:"failed"},e,e)}convertDerivativesId(e,t){const s=this.safeValue(e,"info"),i=this.safeString(s,0),r=this.safeValue(s,4,[]);let a;if("derivatives"===t){a=this.safeString(r,0,i);const e=a.length-2;"F0"===a.slice(e)||(a+="F0")}else a="margin"!==t?this.safeString(r,1,i):i;return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"precision","R0"),a=this.market(e),o={symbol:a.id,precision:i};void 0!==t&&(o.len=t);const n=this.extend(o,s),d=await this.publicGetBookSymbolPrecision(n),h=this.milliseconds(),c={symbol:a.symbol,bids:[],asks:[],timestamp:h,datetime:this.iso8601(h),nonce:void 0},l="R0"===n.precision?1:0;for(let e=0;e<d.length;e++){const t=d[e],s=this.safeNumber(t,l),i=this.safeString(t,2),a=r.Y.stringAbs(i);c[r.Y.stringGt(i,"0")?"bids":"asks"].push([s,this.parseNumber(a)])}return c.bids=this.sortBy(c.bids,0,!0),c.asks=this.sortBy(c.asks,0),c}parseTicker(e,t=void 0){const s=this.safeList(e,"result"),i=this.safeSymbol(void 0,t),a=s.length,o=this.safeString(s,a-4),n=this.safeString(s,a-5);return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:this.safeString(s,a-2),low:this.safeString(s,a-1),bid:this.safeString(s,a-10),bidVolume:this.safeString(s,a-9),ask:this.safeString(s,a-8),askVolume:this.safeString(s,a-7),vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:this.safeString(s,a-6),percentage:r.Y.stringMul(n,"100"),average:void 0,baseVolume:this.safeString(s,a-3),quoteVolume:void 0,info:s},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==(e=this.marketSymbols(e))){const t=this.marketIds(e);s.symbols=t.join(",")}else s.symbols="ALL";const i=await this.publicGetTickers(this.extend(s,t)),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,0),a=this.safeMarket(s);r[a.symbol]=this.parseTicker({result:t},a)}return this.filterByArrayTickers(r,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r={result:await this.publicGetTickerSymbol(this.extend(i,t))};return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeList(e,"result",[]),i=s.length>5,a=this.safeString(s,0),o=i?4:2;let n,d=this.safeString(s,o);const h=i?5:3,c=this.safeString(s,h);let l,u,p,f;"-"===d[0]?(n="sell",d=r.Y.stringAbs(d)):n="buy";let m=this.safeSymbol(void 0,t);const g=i?2:1,v=this.safeInteger(s,g);if(i){const e=s[1];m=this.safeSymbol(e),l=this.safeString(s,3);u=1===this.safeInteger(s,8)?"maker":"taker";let t=this.safeString(s,9);t=r.Y.stringNeg(t);const i=this.safeString(s,10);f={cost:t,currency:this.safeCurrencyCode(i)};const a=s[6];p=this.safeString(this.options.exchangeTypes,a)}return this.safeTrade({id:a,timestamp:v,datetime:this.iso8601(v),symbol:m,order:l,side:n,type:p,takerOrMaker:u,price:c,amount:d,cost:void 0,fee:f,info:s},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i,1e4);const a=this.market(e);let o="-1",n={symbol:a.id};void 0!==t&&(n.start=t,o="1"),void 0!==s&&(n.limit=Math.min(s,1e4)),n.sort=o,[n,i]=this.handleUntilOption("end",n,i);const d=await this.publicGetTradesSymbolHist(this.extend(n,i)),h=this.sortBy(d,1),c=[];for(let e=0;e<h.length;e++)c.push({result:h[e]});return this.parseTrades(c,a,void 0,s)}async fetchOHLCV(e,t="1m",s=void 0,i=100,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e4);const o=this.market(e);i=void 0===i?1e4:Math.min(i,1e4);let n={symbol:o.id,timeframe:this.safeString(this.timeframes,t,t),sort:1,limit:i};void 0!==s&&(n.start=s),[n,r]=this.handleUntilOption("end",n,r);const d=await this.publicGetCandlesTradeTimeframeSymbolHist(this.extend(n,r));return this.parseOHLCVs(d,o,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}parseOrderStatus(e){if(void 0===e)return e;const t=e.split(" "),s=this.safeString(t,0);return this.safeString({ACTIVE:"open",PARTIALLY:"open",EXECUTED:"closed",CANCELED:"canceled",INSUFFICIENT:"canceled","POSTONLY CANCELED":"canceled",RSN_DUST:"rejected",RSN_PAUSE:"rejected","IOC CANCELED":"canceled","FILLORKILL CANCELED":"canceled"},s,e)}parseOrderFlags(e){return this.safeValue({1024:["reduceOnly"],4096:["postOnly"],5120:["reduceOnly","postOnly"]},e,void 0)}parseTimeInForce(e){return this.safeString({"EXCHANGE IOC":"IOC","EXCHANGE FOK":"FOK",IOC:"IOC",FOK:"FOK"},e,"GTC")}parseOrder(e,t=void 0){const s=this.safeList(e,"result"),i=this.safeString(s,0),a=this.safeString(s,3),o=this.safeSymbol(a),n=this.safeInteger(s,5),d=r.Y.stringAbs(this.safeString(s,6)),h=this.safeString(s,7),c=r.Y.stringAbs(h),l=r.Y.stringLt(h,"0")?"sell":"buy",u=this.safeString(s,8),p=this.safeString(this.safeValue(this.options,"exchangeTypes"),u),f=this.parseTimeInForce(u),m=this.safeString(s,12),g=this.parseOrderFlags(m);let v=!1;if(void 0!==g)for(let e=0;e<g.length;e++)"postOnly"===g[e]&&(v=!0);let y,w,b=this.safeString(s,16);"EXCHANGE STOP"!==u&&"EXCHANGE STOP LIMIT"!==u||(b=void 0,y=this.safeString(s,16),"EXCHANGE STOP LIMIT"===u&&(b=this.safeString(s,19)));const S=this.safeString(s,13);if(void 0!==S){const e=S.split(" @ ");w=this.parseOrderStatus(this.safeString(e,0))}const k=this.safeString(s,17),O=this.safeString(s,2);return this.safeOrder({info:s,id:i,clientOrderId:O,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:o,type:p,timeInForce:f,postOnly:v,side:l,price:b,stopPrice:y,triggerPrice:y,amount:c,cost:void 0,average:k,filled:void 0,remaining:d,status:w,fee:void 0,trades:void 0},t)}createOrderRequest(e,t,s,a,o=void 0,n={}){const d=this.market(e);let h=this.amountToPrecision(e,a);h="buy"===s?h:r.Y.stringNeg(h);const c={symbol:d.id,amount:h},l=this.safeString2(n,"stopPrice","triggerPrice"),u=this.safeString(n,"trailingAmount"),p=this.safeString(n,"timeInForce"),f=this.safeBool(n,"postOnly",!1),m=this.safeBool(n,"reduceOnly",!1),g=this.safeValue2(n,"cid","clientOrderId");let v=t.toUpperCase();void 0!==u?(v="TRAILING STOP",c.price_trailing=u):void 0!==l&&(c.price=this.priceToPrecision(e,l),"limit"===t?(v="STOP LIMIT",c.price_aux_limit=this.priceToPrecision(e,o)):v="STOP");const y="IOC"===p,w="FOK"===p,b=f||"PO"===p;if((y||w)&&void 0===o)throw new i.InvalidOrder(this.id+" createOrder() requires a price argument with IOC and FOK orders");if((y||w)&&"market"===t)throw new i.InvalidOrder(this.id+" createOrder() does not allow market IOC and FOK orders");let S;"market"!==t&&void 0===l&&(c.price=this.priceToPrecision(e,o)),y?v="IOC":w&&(v="FOK"),[S,n]=this.handleMarginModeAndParams("createOrder",n),d.spot&&void 0===S&&(v="EXCHANGE "+v),c.type=v;let k=0;return b&&(k=this.sum(k,4096)),m&&(k=this.sum(k,1024)),0!==k&&(c.flags=k),void 0!==g&&(c.cid=g),n=this.omit(n,["triggerPrice","stopPrice","timeInForce","postOnly","reduceOnly","trailingAmount","clientOrderId"]),this.extend(c,n)}async createOrder(e,t,s,r,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=this.createOrderRequest(e,t,s,r,a,o),h=await this.privatePostAuthWOrderSubmit(d);if("SUCCESS"!==this.safeString(h,6)){const e=h[5],t=h[7];throw new i.ExchangeError(this.id+" "+h[6]+": "+t+" (#"+e+")")}const c=this.safeList(h,4,[]),l=this.safeList(c,0);return this.parseOrder(this.extend({result:l}),n)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.safeString(i,"type"),o=this.safeString(i,"side"),n=this.safeNumber(i,"amount"),d=this.safeNumber(i,"price"),h=this.safeDict(i,"params",{}),c=this.createOrderRequest(r,a,o,n,d,h);s.push(["on",c])}const i={ops:s},r=await this.privatePostAuthWOrderMulti(i),a=[],o=this.safeList(r,4,[]);for(let e=0;e<o.length;e++){const t=o[e][4];a.push({result:t[0]})}return this.parseOrders(a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostAuthWOrderCancelMulti(this.extend({all:1},t)),i=this.safeList(s,4,[]),r=[];for(let e=0;e<i.length;e++)r.push({result:i[e]});return this.parseOrders(r)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const r=this.safeValue2(s,"cid","clientOrderId");let a;if(void 0!==r){const e=this.safeValue(s,"cidDate");if(void 0===e)throw new i.InvalidOrder(this.id+" canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')");a={cid:r,cid_date:e},s=this.omit(s,["cid","clientOrderId"])}else a={id:parseInt(e)};const o=await this.privatePostAuthWOrderCancel(this.extend(a,s)),n={result:this.safeValue(o,4)};return this.parseOrder(n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();for(let t=0;t<e.length;t++)e[t]=this.parseToNumeric(e[t]);const i={id:e};let r;void 0!==t&&(r=this.market(t));const a=await this.privatePostAuthWOrderCancelMulti(this.extend(i,s)),o=this.safeList(a,4,[]),n=[];for(let e=0;e<o.length;e++)n.push({result:o[e]});return this.parseOrders(n,r)}async fetchOpenOrder(e,t=void 0,s={}){const r={id:[parseInt(e)]},a=await this.fetchOpenOrders(t,void 0,void 0,this.extend(r,s)),o=this.safeValue(a,0);if(void 0===o)throw new i.OrderNotFound(this.id+" order "+e+" not found");return o}async fetchClosedOrder(e,t=void 0,s={}){const r={id:[parseInt(e)]},a=await this.fetchClosedOrders(t,void 0,void 0,this.extend(r,s)),o=this.safeValue(a,0);if(void 0===o)throw new i.OrderNotFound(this.id+" order "+e+" not found");return o}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;void 0===e?o=await this.privatePostAuthROrders(this.extend(r,i)):(a=this.market(e),r.symbol=a.id,o=await this.privatePostAuthROrdersSymbol(this.extend(r,i)));const n=[];for(let e=0;e<o.length;e++)n.push({result:o[e]});return this.parseOrders(n,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i);let a,o,n={};void 0!==t&&(n.start=t),void 0!==s&&(n.limit=s),[n,i]=this.handleUntilOption("end",n,i),void 0===e?o=await this.privatePostAuthROrdersHist(this.extend(n,i)):(a=this.market(e),n.symbol=a.id,o=await this.privatePostAuthROrdersSymbolHist(this.extend(n,i)));const d=[];for(let e=0;e<o.length;e++)d.push({result:o[e]});return this.parseOrders(d,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,r=void 0,a={}){if(void 0===t)throw new i.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={id:parseInt(e),symbol:o.id},d=await this.privatePostAuthROrderSymbolIdTrades(this.extend(n,a)),h=[];for(let e=0;e<d.length;e++)h.push({result:d[e]});return this.parseTrades(h,o,s,r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={end:this.milliseconds()};let o;void 0!==t&&(a.start=t),void 0!==s&&(a.limit=s),void 0!==e?(r=this.market(e),a.symbol=r.id,o=await this.privatePostAuthRTradesSymbolHist(this.extend(a,i))):o=await this.privatePostAuthRTradesHist(this.extend(a,i));const n=[];for(let e=0;e<o.length;e++)n.push({result:o[e]});return this.parseTrades(n,r,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();return await this.fetchDepositAddress(e,this.extend({op_renew:1},t))}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),r=this.safeString(t,"network",e),a=this.safeValue(s,"networks",{}),o=this.safeValue(a,r),n=this.safeString(o,"id");if(void 0===n)throw new i.ArgumentsRequired(this.id+" fetchDepositAddress() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const d=this.safeString(t,"wallet","exchange");t=this.omit(t,"network","wallet");const h={method:n,wallet:d,op_renew:0},c=await this.privatePostAuthWDepositAddress(this.extend(h,t)),l=this.safeValue(c,4,[]),u=this.safeString(l,5),p=void 0===u?this.safeString(l,4):u,f=void 0===u?void 0:this.safeString(l,4);return this.checkAddress(p),{currency:e,address:p,tag:f,network:void 0,info:c}}parseTransactionStatus(e){return this.safeString({SUCCESS:"ok",COMPLETED:"ok",ERROR:"failed",FAILURE:"failed",CANCELED:"canceled","PENDING APPROVAL":"pending",PENDING:"pending","PENDING REVIEW":"pending","PENDING CANCELLATION":"pending",SENDING:"pending","USER APPROVED":"pending"},e,e)}parseTransaction(e,t=void 0){const s=e.length;let i,a,o,n,d,h,c,l,u,p,f,m,g;if(8===s){const s=this.safeValue(e,4,[]);i=this.safeInteger(e,0),void 0!==t&&(o=t.code),u=this.safeString(s,8),void 0!==u&&(u=r.Y.stringAbs(u)),n=this.safeNumber(s,5),d=this.safeInteger(s,0),h="ok",0===d&&(d=void 0,h="failed"),c=this.safeString(s,3),l="withdrawal"}else if(22===s){d=this.safeString(e,0);const s=this.safeString(e,1);o=this.safeCurrencyCode(s,t);const c=this.safeString(e,2);m=this.networkIdToCode(c),i=this.safeInteger(e,5),a=this.safeInteger(e,6),h=this.parseTransactionStatus(this.safeString(e,9));const v=this.safeString(e,12);n=r.Y.stringAbs(v),void 0!==v&&(l=r.Y.stringLt(v,"0")?"withdrawal":"deposit"),u=this.safeString(e,13),void 0!==u&&(u=r.Y.stringAbs(u)),f=this.safeString(e,16),p=this.safeString(e,20),g=this.safeString(e,21)}return{info:e,id:d,txid:p,type:l,currency:o,network:m,amount:this.parseNumber(n),status:h,timestamp:i,datetime:this.iso8601(i),address:f,addressFrom:void 0,addressTo:f,tag:c,tagFrom:void 0,tagTo:c,updated:a,comment:g,internal:void 0,fee:{currency:o,cost:this.parseNumber(u),rate:void 0}}}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostAuthRSummary(e),s={},i=this.safeValue(this.options,"fiat",{}),r=this.safeValue(t,4,[]),a=this.safeValue(r,0,[]),o=this.safeValue(r,1,[]),n=this.safeNumber(a,0),d=this.safeNumber(a,2),h=this.safeNumber(a,5),c=this.safeNumber(o,0),l=this.safeNumber(o,2),u=this.safeNumber(o,5);for(let e=0;e<this.symbols.length;e++){const r=this.symbols[e],a=this.market(r),o={info:t,symbol:r,percentage:!0,tierBased:!0};a.quote in i?(o.maker=d,o.taker=l):a.contract?(o.maker=h,o.taker=u):(o.maker=n,o.taker=c),s[r]=o}return s}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let o;return void 0!==t&&(a.start=t),void 0!==s&&(a.limit=s),void 0!==e?(r=this.currency(e),a.currency=r.uppercaseId,o=await this.privatePostAuthRMovementsCurrencyHist(this.extend(a,i))):o=await this.privatePostAuthRMovementsHist(this.extend(a,i)),this.parseTransactions(o,r,t,s)}async withdraw(e,t,s,r=void 0,a={}){this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n=this.safeString(a,"network",e);a=this.omit(a,"network");const d=this.safeValue(o,"networks",{}),h=this.safeValue(d,n),c=this.safeString(h,"id");if(void 0===c)throw new i.ArgumentsRequired(this.id+" withdraw() could not find a network for '"+e+"'. You can specify it by providing the 'network' value inside params");const l=this.safeString(a,"wallet","exchange");a=this.omit(a,"network","wallet");const u={method:c,wallet:l,amount:this.numberToString(t),address:s};void 0!==r&&(u.payment_id=r);const p=this.safeValue(this.options,"withdraw",{});this.safeBool(p,"includeFee",!1)&&(u.fee_deduct=1);const f=await this.privatePostAuthWWithdraw(this.extend(u,a));if("error"===this.safeString(f,0)){const e=this.id+" "+f,t=this.safeString(f,2,"");throw this.throwExactlyMatchedException(this.exceptions.exact,t,e),this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new i.ExchangeError(e)}const m=this.safeString(f,7);"success"!==m&&this.throwBroadlyMatchedException(this.exceptions.broad,m,m);const g=this.parseTransaction(f,o);return this.extend(g,{address:s})}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.privatePostAuthRPositions(t),i=[];for(let e=0;e<s.length;e++)i.push({result:s[e]});return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeList(e,"result"),i=this.safeString(s,0),a=this.safeString(s,2),o=this.safeInteger(s,12),n=this.safeString(s,19),d=this.safeString(n,"trade_price"),h=this.safeString(n,"trade_amount");return this.safePosition({info:s,id:this.safeString(s,11),symbol:this.safeSymbol(i,t),notional:this.parseNumber(a),marginMode:"isolated",liquidationPrice:this.safeNumber(s,8),entryPrice:this.safeNumber(s,3),unrealizedPnl:this.safeNumber(s,6),percentage:this.safeNumber(s,7),contracts:void 0,contractSize:void 0,markPrice:void 0,lastPrice:void 0,side:r.Y.stringGt(a,"0")?"long":"short",hedged:void 0,timestamp:o,datetime:this.iso8601(o),lastUpdateTimestamp:this.safeInteger(s,13),maintenanceMargin:this.safeNumber(s,18),maintenanceMarginPercentage:void 0,collateral:this.safeNumber(s,17),initialMargin:this.parseNumber(r.Y.stringMul(h,d)),initialMarginPercentage:void 0,leverage:this.safeNumber(s,9),marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));o="v1"===t?t+o:this.version+o;let h=this.urls.api[t]+"/"+o;if("public"===t&&Object.keys(d).length&&(h+="?"+this.urlencode(d)),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t="/api/"+o+e+(a=this.json(d)),s=this.hmac(this.encode(t),this.encode(this.secret),n.qt);r={"bfx-nonce":e,"bfx-apikey":this.apiKey,"bfx-signature":s,"Content-Type":"application/json"}}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,r,a,o,n,d,h){if(void 0!==n){if(!Array.isArray(n)){const e=this.safeString2(n,"message","error"),t=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,t),this.throwBroadlyMatchedException(this.exceptions.broad,e,t),new i.ExchangeError(this.id+" "+o)}}else if(""===n)throw new i.ExchangeError(this.id+" returned empty response");if(429===e)throw new i.RateLimitExceeded(this.id+" "+o);if(500===e){const e=this.safeString(n,1,""),t=this.safeString(n,2,""),s=this.id+" "+t;throw this.throwBroadlyMatchedException(this.exceptions.broad,t,s),this.throwExactlyMatchedException(this.exceptions.exact,e,s),this.throwExactlyMatchedException(this.exceptions.exact,t,s),new i.ExchangeError(this.id+" "+t+" (#"+e+")")}return n}parseLedgerEntryType(e){return void 0===e?void 0:e.indexOf("fee")>=0||e.indexOf("charged")>=0?"fee":e.indexOf("rebate")>=0?"rebate":e.indexOf("deposit")>=0||e.indexOf("withdrawal")>=0?"transaction":e.indexOf("transfer")>=0?"transfer":e.indexOf("payment")>=0?"payout":e.indexOf("exchange")>=0||e.indexOf("position")>=0?"trade":e}parseLedgerEntry(e,t=void 0){const s=this.safeList(e,"result",[]);let i;const r=this.safeString(s,0),a=this.safeString(s,1),o=this.safeCurrencyCode(a,t),n=this.safeInteger(s,3),d=this.safeNumber(s,5),h=this.safeNumber(s,6),c=this.safeString(s,8);if(void 0!==c){const e=c.split(" @ "),t=this.safeStringLower(e,0);i=this.parseLedgerEntryType(t)}return{id:r,direction:void 0,account:void 0,referenceId:r,referenceAccount:void 0,type:i,currency:o,amount:d,timestamp:n,datetime:this.iso8601(n),before:void 0,after:h,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i,2500);let o,n={};void 0!==t&&(n.start=t),void 0!==s&&(n.limit=s),[n,i]=this.handleUntilOption("end",n,i),void 0!==e?(r=this.currency(e),n.currency=r.uppercaseId,o=await this.privatePostAuthRLedgersCurrencyHist(this.extend(n,i))):o=await this.privatePostAuthRLedgersHist(this.extend(n,i));const d=[];for(let e=0;e<o.length;e++){const t=o[e];d.push({result:t})}return this.parseLedger(d,r,t,s)}async fetchFundingRate(e,t={}){return await this.fetchFundingRates([e],t)}async fetchFundingRates(e=void 0,t={}){if(void 0===e)throw new i.ArgumentsRequired(this.id+" fetchFundingRates() requires a symbols argument");await this.loadMarkets();const s={keys:this.marketIds(e).join(",")},r=await this.publicGetStatusDeriv(this.extend(s,t));return this.parseFundingRates(r)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,r={}){if(void 0===e)throw new i.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",r,5e3);const o=this.market(e);let n={symbol:o.id};void 0!==t&&(n.start=t),[n,r]=this.handleUntilOption("end",n,r);const d=await this.publicGetStatusDerivSymbolHist(this.extend(n,r)),h=[];for(let e=0;e<d.length;e++){const t=d[e],s=this.parseFundingRateHistory(t,o);h.push(s)}const c=[],l=this.filterBySymbolSinceLimit(h,e,t,s),u=l.length;for(let e=0;e<u;e++){const t=l[u-e-1];c.push(t)}return c}parseFundingRate(e,t=void 0){const s=this.safeString(e,0),i=this.safeInteger(e,1),r=this.safeInteger(e,8);return{info:e,symbol:this.safeSymbol(s,t),markPrice:this.safeNumber(e,15),indexPrice:this.safeNumber(e,3),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:i,datetime:this.iso8601(i),fundingRate:this.safeNumber(e,12),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.safeNumber(e,9),nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseFundingRateHistory(e,t=void 0){const s=this.safeInteger(e,0),i=this.safeInteger(e,7);return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,14),indexPrice:this.safeNumber(e,2),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:this.iso8601(s),fundingRate:this.safeNumber(e,11),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.safeNumber(e,8),nextFundingTimestamp:i,nextFundingDatetime:this.iso8601(i),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e),i={keys:s.id},r=await this.publicGetStatusDeriv(this.extend(i,t)),a=this.safeList(r,0);return this.parseOpenInterest(a,s)}async fetchOpenInterestHistory(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOpenInterestHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory",e,s,i,"8h",r,5e3);const o=this.market(e);let n={symbol:o.id};void 0!==s&&(n.start=s),void 0!==i&&(n.limit=i),[n,r]=this.handleUntilOption("end",n,r);const d=await this.publicGetStatusDerivSymbolHist(this.extend(n,r));return this.parseOpenInterests(d,o,s,i)}parseOpenInterest(e,t=void 0){const s=23===e.length?17:18,i=this.safeInteger(e,1),r=this.safeString(e,0);return this.safeOpenInterest({symbol:this.safeSymbol(r,t,void 0,"swap"),openInterestAmount:this.safeNumber(e,s),openInterestValue:void 0,timestamp:i,datetime:this.iso8601(i),info:e},t)}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLiquidations","paginate"),r)return await this.fetchPaginatedCallDeterministic("fetchLiquidations",e,t,s,"8h",i,500);const a=this.market(e);let o={};void 0!==t&&(o.start=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("end",o,i);const n=await this.publicGetLiquidationsHist(this.extend(o,i));return this.parseLiquidations(n,a,t,s)}parseLiquidation(e,t=void 0){const s=e[0],i=this.safeInteger(s,2),a=this.safeString(s,4),o=r.Y.stringAbs(this.safeString(s,5)),n=this.safeString(t,"contractSize"),d=r.Y.stringMul(o,n),h=this.safeString(s,11);return this.safeLiquidation({info:s,symbol:this.safeSymbol(a,t,void 0,"contract"),contracts:this.parseNumber(o),contractSize:this.parseNumber(n),price:this.parseNumber(h),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(r.Y.stringMul(d,h)),timestamp:i,datetime:this.iso8601(i)})}async setMargin(e,t,s={}){await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new i.NotSupported(this.id+" setMargin() only support swap markets");const a={symbol:r.id,collateral:this.parseToNumeric(t)},o=await this.privatePostAuthWDerivCollateralSet(this.extend(a,s)),n=this.safeValue(o,0);return this.parseMarginModification(n,r)}parseMarginModification(e,t=void 0){const s=1===e[0]?"ok":"failed";return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:void 0,status:s,timestamp:void 0,datetime:void 0}}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:[this.parseToNumeric(e)]};let r,a;void 0===t?a=await this.privatePostAuthROrders(this.extend(i,s)):(r=this.market(t),i.symbol=r.id,a=await this.privatePostAuthROrdersSymbol(this.extend(i,s)));const o=this.safeList(a,0);return this.parseOrder(o,r)}async editOrder(e,t,s,a,o=void 0,n=void 0,d={}){await this.loadMarkets();const h=this.market(t),c={id:this.parseToNumeric(e)};if(void 0!==o){let e=this.amountToPrecision(t,o);e="buy"===a?e:r.Y.stringNeg(e),c.amount=e}const l=this.safeString2(d,"stopPrice","triggerPrice"),u=this.safeString(d,"trailingAmount"),p=this.safeString(d,"timeInForce"),f=this.safeBool(d,"postOnly",!1),m=this.safeBool(d,"reduceOnly",!1),g=this.safeInteger2(d,"cid","clientOrderId");void 0!==u?c.price_trailing=u:void 0!==l&&(c.price=this.priceToPrecision(t,l),"limit"===s&&(c.price_aux_limit=this.priceToPrecision(t,n)));const v=f||"PO"===p;"market"!==s&&void 0===l&&(c.price=this.priceToPrecision(t,n));let y=0;v&&(y=this.sum(y,4096)),m&&(y=this.sum(y,1024)),0!==y&&(c.flags=y),void 0!==g&&(c.cid=g);const w=this.safeInteger2(d,"leverage","lev");void 0!==w&&(c.lev=w),d=this.omit(d,["triggerPrice","stopPrice","timeInForce","postOnly","reduceOnly","trailingAmount","clientOrderId","leverage"]);const b=await this.privatePostAuthWOrderUpdate(this.extend(c,d));if("SUCCESS"!==this.safeString(b,6)){const e=b[5],t=b[7];throw new i.ExchangeError(this.id+" "+b[6]+": "+t+" (#"+e+")")}const S=this.safeList(b,4,[]);return this.parseOrder(S,h)}}},1787:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1578),r=s(2079),a=s(1579),o=s(4852),n=s(5147);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitflyer",name:"bitFlyer",countries:["JP"],version:"v1",rateLimit:1e3,hostname:"bitflyer.com",has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:!1,cancelAllOrders:void 0,cancelOrder:!0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:"emulated",fetchDeposits:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:"emulated",fetchOrder:"emulated",fetchOrderBook:!0,fetchOrders:!0,fetchPositionMode:!1,fetchPositions:!0,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg",api:{rest:"https://api.{hostname}"},www:"https://bitflyer.com",doc:"https://lightning.bitflyer.com/docs?lang=en"},api:{public:{get:["getmarkets/usa","getmarkets/eu","getmarkets","getboard","getticker","getexecutions","gethealth","getboardstate","getchats"]},private:{get:["getpermissions","getbalance","getbalancehistory","getcollateral","getcollateralhistory","getcollateralaccounts","getaddresses","getcoinins","getcoinouts","getbankaccounts","getdeposits","getwithdrawals","getchildorders","getparentorders","getparentorder","getexecutions","getpositions","gettradingcommission"],post:["sendcoin","withdraw","sendchildorder","cancelchildorder","sendparentorder","cancelparentorder","cancelallchildorders"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:a.kb,exceptions:{exact:{"-2":r.OnMaintenance}}})}parseExpiryDate(e){const t=e.slice(0,2),s=e.slice(2,5),i=e.slice(5,9),r=this.safeString({JAN:"01",FEB:"02",MAR:"03",APR:"04",MAY:"05",JUN:"06",JUL:"07",AUG:"08",SEP:"09",OCT:"10",NOV:"11",DEC:"12"},s);return this.parse8601(i+"-"+r+"-"+t+"T00:00:00Z")}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return super.safeMarket(e,t,s,"spot")}async fetchMarkets(e={}){const t=await this.publicGetGetmarkets(e),s=await this.publicGetGetmarketsUsa(e),i=await this.publicGetGetmarketsEu(e);let r=this.arrayConcat(t,s);r=this.arrayConcat(r,i);const a=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"product_code"),i=s.split("_"),o=this.safeString(t,"market_type"),n="FX"===o,d="Futures"===o,h=!n&&!d;let c,l,u,p,f="spot";if(h)l=this.safeString(i,0),u=this.safeString(i,1);else if(n)f="swap",l=this.safeString(i,1),u=this.safeString(i,2);else if(d){const e=this.safeString(t,"alias");if(void 0===e){l=s.slice(0,3),u=s.slice(3,6);const e=s.slice(-9);p=this.parseExpiryDate(e)}else{const t=e.split("_"),i=this.safeString(t,0);l=i.slice(0,-3),u=i.slice(-3);const r=s.split(i),a=this.safeString(r,1);p=this.parseExpiryDate(a)}f="future"}const m=this.safeCurrencyCode(l),g=this.safeCurrencyCode(u);let v=m+"/"+g,y=this.fees.trading.taker,w=this.fees.trading.maker;const b=n||d;b&&(w=0,y=0,c="JPY",v=v+":"+c,d&&(v=v+"-"+this.yymmdd(p))),a.push({id:s,symbol:v,base:m,quote:g,settle:c,baseId:l,quoteId:u,settleId:void 0,type:f,spot:h,margin:!1,swap:n,future:d,option:!1,active:!0,contract:b,linear:!h||void 0,inverse:!!h&&void 0,taker:y,maker:w,contractSize:void 0,expiry:p,expiryDatetime:this.iso8601(p),strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return a}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"amount"),o.free=this.safeString(i,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetGetbalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={product_code:i.id},a=await this.publicGetGetboard(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","size")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"timestamp")),r=this.safeString(e,"ltp");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:void 0,low:void 0,bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_by_product"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},r=await this.publicGetGetticker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){let s,i=this.safeStringLower(e,"side");if(void 0!==i&&i.length<1&&(i=void 0),void 0!==i){const t=i+"_child_order_acceptance_id";t in e&&(s=e[t])}void 0===s&&(s=this.safeString(e,"child_order_acceptance_id"));const r=this.parse8601(this.safeString(e,"exec_date")),a=this.safeString(e,"price"),o=this.safeString(e,"size"),n=this.safeString(e,"id");return t=this.safeMarket(void 0,t),this.safeTrade({id:n,info:e,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,order:s,type:void 0,side:i,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={product_code:r.id};void 0!==s&&(a.count=s);const o=await this.publicGetGetexecutions(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_code:s.id},r=await this.privateGetGettradingcommission(this.extend(i,t)),a=this.safeNumber(r,"commission_rate");return{info:r,symbol:s.symbol,maker:a,taker:a,percentage:void 0,tierBased:void 0}}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o={product_code:this.marketId(e),child_order_type:t.toUpperCase(),side:s.toUpperCase(),price:r,size:i},n=await this.privatePostSendchildorder(this.extend(o,a)),d=this.safeString(n,"child_order_acceptance_id");return this.safeOrder({id:d,info:n})}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={product_code:this.marketId(t),child_order_acceptance_id:e},a=await this.privatePostCancelchildorder(this.extend(i,s));return this.safeOrder({info:a})}parseOrderStatus(e){return this.safeString({ACTIVE:"open",COMPLETED:"closed",CANCELED:"canceled",EXPIRED:"canceled",REJECTED:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"child_order_date")),i=this.safeString(e,"price"),r=this.safeString(e,"size"),a=this.safeString(e,"executed_size"),o=this.safeString(e,"outstanding_size"),n=this.parseOrderStatus(this.safeString(e,"child_order_state")),d=this.safeStringLower(e,"child_order_type"),h=this.safeStringLower(e,"side"),c=this.safeString(e,"product_code"),l=this.safeSymbol(c,t);let u;const p=this.safeNumber(e,"total_commission");void 0!==p&&(u={cost:p,currency:void 0,rate:void 0});const f=this.safeString(e,"child_order_acceptance_id");return this.safeOrder({id:f,clientOrderId:void 0,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:n,symbol:l,type:d,timeInForce:void 0,postOnly:void 0,side:h,price:i,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:r,filled:a,remaining:o,fee:u,average:void 0,trades:void 0},t)}async fetchOrders(e=void 0,t=void 0,s=100,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={product_code:a.id,count:s},n=await this.privateGetGetchildorders(this.extend(o,i));let d=this.parseOrders(n,a,t,s);return void 0!==e&&(d=this.filterBy(d,"symbol",e)),d}async fetchOpenOrders(e=void 0,t=void 0,s=100,i={}){return await this.fetchOrders(e,t,s,this.extend({child_order_state:"ACTIVE"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=100,i={}){return await this.fetchOrders(e,t,s,this.extend({child_order_state:"COMPLETED"},i))}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");const i=await this.fetchOrders(t),a=this.indexBy(i,"id");if(e in a)return a[e];throw new r.OrderNotFound(this.id+" No order found with id "+e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={product_code:a.id};void 0!==s&&(o.count=s);const n=await this.privateGetGetexecutions(this.extend(o,i));return this.parseTrades(n,a,t,s)}async fetchPositions(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchPositions() requires a `symbols` argument, exactly one symbol in an array");await this.loadMarkets();const s={product_code:this.marketIds(e)};return await this.privateGetGetpositions(this.extend(s,t))}async withdraw(e,t,s,i=void 0,a={}){if(this.checkAddress(s),await this.loadMarkets(),"JPY"!==e&&"USD"!==e&&"EUR"!==e)throw new r.ExchangeError(this.id+" allows withdrawing JPY, USD, EUR only, "+e+" is not supported");const o=this.currency(e),n={currency_code:o.id,amount:t},d=await this.privatePostWithdraw(this.extend(n,a));return this.parseTransaction(d,o)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e)),void 0!==s&&(a.count=s);const o=await this.privateGetGetcoinins(this.extend(a,i));return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e)),void 0!==s&&(a.count=s);const o=await this.privateGetGetcoinouts(this.extend(a,i));return this.parseTransactions(o,r,t,s)}parseDepositStatus(e){return this.safeString({PENDING:"pending",COMPLETED:"ok"},e,e)}parseWithdrawalStatus(e){return this.safeString({PENDING:"pending",COMPLETED:"ok"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","message_id"),i=this.safeString(e,"address"),r=this.safeString(e,"currency_code"),a=this.safeCurrencyCode(r,t),o=this.parse8601(this.safeString(e,"event_date")),d=this.safeNumber(e,"amount"),h=this.safeString(e,"tx_hash"),c=this.safeString(e,"status");let l,u,p;if("fee"in e){l="withdrawal",u=this.parseWithdrawalStatus(c);const t=this.safeString(e,"fee"),s=this.safeString(e,"additional_fee");p={currency:a,cost:this.parseNumber(n.Y.stringAdd(t,s))}}else l="deposit",u=this.parseDepositStatus(c);return{info:e,id:s,txid:h,timestamp:o,datetime:this.iso8601(o),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:l,amount:d,currency:a,status:u,updated:void 0,comment:void 0,internal:void 0,fee:p}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n="/"+this.version+"/";"private"===t&&(n+="me/"),n+=e,"GET"===s&&Object.keys(i).length&&(n+="?"+this.urlencode(i));const d=this.implodeHostname(this.urls.api.rest)+n;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t=[e,s,n].join("");Object.keys(i).length&&"GET"!==s&&(t+=a=this.json(i)),r={"ACCESS-KEY":this.apiKey,"ACCESS-TIMESTAMP":e,"ACCESS-SIGN":this.hmac(this.encode(t),this.encode(this.secret),o.s),"Content-Type":"application/json"}}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(void 0===o)return;const h=this.id+" "+a,c=this.safeString(o,"error_message"),l=this.safeNumber(o,"status");void 0!==c&&(this.throwExactlyMatchedException(this.exceptions.exact,l,h),this.throwBroadlyMatchedException(this.exceptions.broad,c,h))}}},7757:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9152),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitget",name:"Bitget",countries:["SG"],version:"v2",rateLimit:50,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!0,borrowCrossMargin:!0,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!0,closePosition:!0,createConvertTrade:!0,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingAmountOrder:!1,createTrailingPercentOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledAndClosedOrders:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchConvertCurrencies:!0,fetchConvertQuote:!0,fetchConvertTrade:!1,fetchConvertTradeHistory:!0,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!0,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchLiquidations:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawAddresses:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!0,repayIsolatedMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1m"},hostname:"bitget.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/195989417-4253ddb0-afbe-4a1c-9dea-9dbcd121fa5d.jpg",api:{spot:"https://api.{hostname}",mix:"https://api.{hostname}",user:"https://api.{hostname}",p2p:"https://api.{hostname}",broker:"https://api.{hostname}",margin:"https://api.{hostname}",common:"https://api.{hostname}",tax:"https://api.{hostname}",convert:"https://api.{hostname}",copy:"https://api.{hostname}",earn:"https://api.{hostname}"},www:"https://www.bitget.com",doc:["https://www.bitget.com/api-doc/common/intro","https://www.bitget.com/api-doc/spot/intro","https://www.bitget.com/api-doc/contract/intro","https://www.bitget.com/api-doc/broker/intro","https://www.bitget.com/api-doc/margin/intro","https://www.bitget.com/api-doc/copytrading/intro","https://www.bitget.com/api-doc/earn/intro","https://bitgetlimited.github.io/apidoc/en/mix","https://bitgetlimited.github.io/apidoc/en/spot","https://bitgetlimited.github.io/apidoc/en/broker","https://bitgetlimited.github.io/apidoc/en/margin"],fees:"https://www.bitget.cc/zh-CN/rate?tab=1",referral:"https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j"},api:{public:{common:{get:{"v2/public/annoucements":1,"v2/public/time":1}},spot:{get:{"spot/v1/notice/queryAllNotices":1,"spot/v1/public/time":1,"spot/v1/public/currencies":6.6667,"spot/v1/public/products":1,"spot/v1/public/product":1,"spot/v1/market/ticker":1,"spot/v1/market/tickers":1,"spot/v1/market/fills":2,"spot/v1/market/fills-history":2,"spot/v1/market/candles":1,"spot/v1/market/depth":1,"spot/v1/market/spot-vip-level":2,"spot/v1/market/merge-depth":1,"spot/v1/market/history-candles":1,"spot/v1/public/loan/coinInfos":2,"spot/v1/public/loan/hour-interest":2,"v2/spot/public/coins":6.6667,"v2/spot/public/symbols":1,"v2/spot/market/vip-fee-rate":2,"v2/spot/market/tickers":1,"v2/spot/market/merge-depth":1,"v2/spot/market/orderbook":1,"v2/spot/market/candles":1,"v2/spot/market/history-candles":1,"v2/spot/market/fills":2,"v2/spot/market/fills-history":2}},mix:{get:{"mix/v1/market/contracts":1,"mix/v1/market/depth":1,"mix/v1/market/ticker":1,"mix/v1/market/tickers":1,"mix/v1/market/contract-vip-level":2,"mix/v1/market/fills":1,"mix/v1/market/fills-history":2,"mix/v1/market/candles":1,"mix/v1/market/index":1,"mix/v1/market/funding-time":1,"mix/v1/market/history-fundRate":1,"mix/v1/market/current-fundRate":1,"mix/v1/market/open-interest":1,"mix/v1/market/mark-price":1,"mix/v1/market/symbol-leverage":1,"mix/v1/market/queryPositionLever":1,"mix/v1/market/open-limit":1,"mix/v1/market/history-candles":1,"mix/v1/market/history-index-candles":1,"mix/v1/market/history-mark-candles":1,"mix/v1/market/merge-depth":1,"v2/mix/market/vip-fee-rate":2,"v2/mix/market/merge-depth":1,"v2/mix/market/ticker":1,"v2/mix/market/tickers":1,"v2/mix/market/fills":1,"v2/mix/market/fills-history":2,"v2/mix/market/candles":1,"v2/mix/market/history-candles":1,"v2/mix/market/history-index-candles":1,"v2/mix/market/history-mark-candles":1,"v2/mix/market/open-interest":1,"v2/mix/market/funding-time":1,"v2/mix/market/symbol-price":1,"v2/mix/market/history-fund-rate":1,"v2/mix/market/current-fund-rate":1,"v2/mix/market/contracts":1,"v2/mix/market/query-position-lever":2}},margin:{get:{"margin/v1/cross/public/interestRateAndLimit":2,"margin/v1/isolated/public/interestRateAndLimit":2,"margin/v1/cross/public/tierData":2,"margin/v1/isolated/public/tierData":2,"margin/v1/public/currencies":1,"v2/margin/currencies":2}},earn:{get:{"v2/earn/loan/public/coinInfos":2,"v2/earn/loan/public/hour-interest":2}}},private:{spot:{get:{"spot/v1/wallet/deposit-address":4,"spot/v1/wallet/withdrawal-list":1,"spot/v1/wallet/deposit-list":1,"spot/v1/account/getInfo":20,"spot/v1/account/assets":2,"spot/v1/account/assets-lite":2,"spot/v1/account/transferRecords":1,"spot/v1/convert/currencies":2,"spot/v1/convert/convert-record":2,"spot/v1/loan/ongoing-orders":2,"spot/v1/loan/repay-history":2,"spot/v1/loan/revise-history":2,"spot/v1/loan/borrow-history":2,"spot/v1/loan/debts":2,"v2/spot/trade/orderInfo":1,"v2/spot/trade/unfilled-orders":1,"v2/spot/trade/history-orders":1,"v2/spot/trade/fills":2,"v2/spot/trade/current-plan-order":1,"v2/spot/trade/history-plan-order":1,"v2/spot/account/info":20,"v2/spot/account/assets":2,"v2/spot/account/subaccount-assets":2,"v2/spot/account/bills":2,"v2/spot/account/transferRecords":1,"v2/account/funding-assets":2,"v2/account/bot-assets":2,"v2/account/all-account-balance":20,"v2/spot/wallet/deposit-address":2,"v2/spot/wallet/deposit-records":2,"v2/spot/wallet/withdrawal-records":2},post:{"spot/v1/wallet/transfer":4,"spot/v1/wallet/transfer-v2":4,"spot/v1/wallet/subTransfer":10,"spot/v1/wallet/withdrawal":4,"spot/v1/wallet/withdrawal-v2":4,"spot/v1/wallet/withdrawal-inner":4,"spot/v1/wallet/withdrawal-inner-v2":4,"spot/v1/account/sub-account-spot-assets":200,"spot/v1/account/bills":2,"spot/v1/trade/orders":2,"spot/v1/trade/batch-orders":4,"spot/v1/trade/cancel-order":2,"spot/v1/trade/cancel-order-v2":2,"spot/v1/trade/cancel-symbol-order":2,"spot/v1/trade/cancel-batch-orders":4,"spot/v1/trade/cancel-batch-orders-v2":4,"spot/v1/trade/orderInfo":1,"spot/v1/trade/open-orders":1,"spot/v1/trade/history":1,"spot/v1/trade/fills":1,"spot/v1/plan/placePlan":1,"spot/v1/plan/modifyPlan":1,"spot/v1/plan/cancelPlan":1,"spot/v1/plan/currentPlan":1,"spot/v1/plan/historyPlan":1,"spot/v1/plan/batchCancelPlan":2,"spot/v1/convert/quoted-price":4,"spot/v1/convert/trade":4,"spot/v1/loan/borrow":2,"spot/v1/loan/repay":2,"spot/v1/loan/revise-pledge":2,"spot/v1/trace/order/orderCurrentList":2,"spot/v1/trace/order/orderHistoryList":2,"spot/v1/trace/order/closeTrackingOrder":2,"spot/v1/trace/order/updateTpsl":2,"spot/v1/trace/order/followerEndOrder":2,"spot/v1/trace/order/spotInfoList":2,"spot/v1/trace/config/getTraderSettings":2,"spot/v1/trace/config/getFollowerSettings":2,"spot/v1/trace/user/myTraders":2,"spot/v1/trace/config/setFollowerConfig":2,"spot/v1/trace/user/myFollowers":2,"spot/v1/trace/config/setProductCode":2,"spot/v1/trace/user/removeTrader":2,"spot/v1/trace/getRemovableFollower":2,"spot/v1/trace/user/removeFollower":2,"spot/v1/trace/profit/totalProfitInfo":2,"spot/v1/trace/profit/totalProfitList":2,"spot/v1/trace/profit/profitHisList":2,"spot/v1/trace/profit/profitHisDetailList":2,"spot/v1/trace/profit/waitProfitDetailList":2,"spot/v1/trace/user/getTraderInfo":2,"v2/spot/trade/place-order":2,"v2/spot/trade/cancel-order":2,"v2/spot/trade/batch-orders":20,"v2/spot/trade/batch-cancel-order":2,"v2/spot/trade/cancel-symbol-order":4,"v2/spot/trade/place-plan-order":1,"v2/spot/trade/modify-plan-order":1,"v2/spot/trade/cancel-plan-order":1,"v2/spot/trade/batch-cancel-plan-order":2,"v2/spot/wallet/transfer":2,"v2/spot/wallet/subaccount-transfer":2,"v2/spot/wallet/withdrawal":2,"v2/spot/wallet/cancel-withdrawal":2,"v2/spot/wallet/modify-deposit-account":2}},mix:{get:{"mix/v1/account/account":2,"mix/v1/account/accounts":2,"mix/v1/position/singlePosition":2,"mix/v1/position/singlePosition-v2":2,"mix/v1/position/allPosition":4,"mix/v1/position/allPosition-v2":4,"mix/v1/position/history-position":1,"mix/v1/account/accountBill":2,"mix/v1/account/accountBusinessBill":4,"mix/v1/order/current":1,"mix/v1/order/marginCoinCurrent":1,"mix/v1/order/history":2,"mix/v1/order/historyProductType":4,"mix/v1/order/detail":2,"mix/v1/order/fills":2,"mix/v1/order/allFills":2,"mix/v1/plan/currentPlan":1,"mix/v1/plan/historyPlan":2,"mix/v1/trace/currentTrack":2,"mix/v1/trace/followerOrder":2,"mix/v1/trace/followerHistoryOrders":2,"mix/v1/trace/historyTrack":2,"mix/v1/trace/summary":1,"mix/v1/trace/profitSettleTokenIdGroup":1,"mix/v1/trace/profitDateGroupList":1,"mix/v1/trade/profitDateList":2,"mix/v1/trace/waitProfitDateList":1,"mix/v1/trace/traderSymbols":1,"mix/v1/trace/traderList":2,"mix/v1/trace/traderDetail":2,"mix/v1/trace/queryTraceConfig":2,"v2/mix/account/account":2,"v2/mix/account/accounts":2,"v2/mix/account/sub-account-assets":200,"v2/mix/account/open-count":2,"v2/mix/account/bill":2,"v2/mix/market/query-position-lever":2,"v2/mix/position/single-position":2,"v2/mix/position/all-position":4,"v2/mix/position/history-position":1,"v2/mix/order/detail":2,"v2/mix/order/fills":2,"v2/mix/order/fill-history":2,"v2/mix/order/orders-pending":2,"v2/mix/order/orders-history":2,"v2/mix/order/orders-plan-pending":2,"v2/mix/order/orders-plan-history":2},post:{"mix/v1/account/sub-account-contract-assets":200,"mix/v1/account/open-count":1,"mix/v1/account/setLeverage":4,"mix/v1/account/setMargin":4,"mix/v1/account/setMarginMode":4,"mix/v1/account/setPositionMode":4,"mix/v1/order/placeOrder":2,"mix/v1/order/batch-orders":2,"mix/v1/order/cancel-order":2,"mix/v1/order/cancel-batch-orders":2,"mix/v1/order/modifyOrder":2,"mix/v1/order/cancel-symbol-orders":2,"mix/v1/order/cancel-all-orders":2,"mix/v1/order/close-all-positions":20,"mix/v1/plan/placePlan":2,"mix/v1/plan/modifyPlan":2,"mix/v1/plan/modifyPlanPreset":2,"mix/v1/plan/placeTPSL":2,"mix/v1/plan/placeTrailStop":2,"mix/v1/plan/placePositionsTPSL":2,"mix/v1/plan/modifyTPSLPlan":2,"mix/v1/plan/cancelPlan":2,"mix/v1/plan/cancelSymbolPlan":2,"mix/v1/plan/cancelAllPlan":2,"mix/v1/trace/closeTrackOrder":2,"mix/v1/trace/modifyTPSL":2,"mix/v1/trace/closeTrackOrderBySymbol":2,"mix/v1/trace/setUpCopySymbols":2,"mix/v1/trace/followerSetBatchTraceConfig":2,"mix/v1/trace/followerCloseByTrackingNo":2,"mix/v1/trace/followerCloseByAll":2,"mix/v1/trace/followerSetTpsl":2,"mix/v1/trace/cancelCopyTrader":4,"mix/v1/trace/traderUpdateConfig":2,"mix/v1/trace/myTraderList":2,"mix/v1/trace/myFollowerList":2,"mix/v1/trace/removeFollower":2,"mix/v1/trace/public/getFollowerConfig":2,"mix/v1/trace/report/order/historyList":2,"mix/v1/trace/report/order/currentList":2,"mix/v1/trace/queryTraderTpslRatioConfig":2,"mix/v1/trace/traderUpdateTpslRatioConfig":2,"v2/mix/account/set-leverage":4,"v2/mix/account/set-margin":4,"v2/mix/account/set-margin-mode":4,"v2/mix/account/set-position-mode":4,"v2/mix/order/place-order":2,"v2/mix/order/click-backhand":20,"v2/mix/order/batch-place-order":20,"v2/mix/order/modify-order":2,"v2/mix/order/cancel-order":2,"v2/mix/order/batch-cancel-orders":2,"v2/mix/order/close-positions":20,"v2/mix/order/place-tpsl-order":2,"v2/mix/order/place-plan-order":2,"v2/mix/order/modify-tpsl-order":2,"v2/mix/order/modify-plan-order":2,"v2/mix/order/cancel-plan-order":2}},user:{get:{"user/v1/fee/query":2,"user/v1/sub/virtual-list":2,"user/v1/sub/virtual-api-list":2,"user/v1/tax/spot-record":1,"user/v1/tax/future-record":1,"user/v1/tax/margin-record":1,"user/v1/tax/p2p-record":1,"v2/user/virtual-subaccount-list":2,"v2/user/virtual-subaccount-apikey-list":2},post:{"user/v1/sub/virtual-create":4,"user/v1/sub/virtual-modify":4,"user/v1/sub/virtual-api-batch-create":20,"user/v1/sub/virtual-api-create":4,"user/v1/sub/virtual-api-modify":4,"v2/user/create-virtual-subaccount":4,"v2/user/modify-virtual-subaccount":4,"v2/user/batch-create-subaccount-and-apikey":20,"v2/user/create-virtual-subaccount-apikey":4,"v2/user/modify-virtual-subaccount-apikey":4}},p2p:{get:{"p2p/v1/merchant/merchantList":2,"p2p/v1/merchant/merchantInfo":2,"p2p/v1/merchant/advList":2,"p2p/v1/merchant/orderList":2,"v2/p2p/merchantList":2,"v2/p2p/merchantInfo":2,"v2/p2p/orderList":2,"v2/p2p/advList":2}},broker:{get:{"broker/v1/account/info":2,"broker/v1/account/sub-list":20,"broker/v1/account/sub-email":20,"broker/v1/account/sub-spot-assets":2,"broker/v1/account/sub-future-assets":2,"broker/v1/account/subaccount-transfer":1,"broker/v1/account/subaccount-deposit":1,"broker/v1/account/subaccount-withdrawal":1,"broker/v1/account/sub-api-list":2,"v2/broker/account/info":2,"v2/broker/account/subaccount-list":20,"v2/broker/account/subaccount-email":2,"v2/broker/account/subaccount-spot-assets":2,"v2/broker/account/subaccount-future-assets":2,"v2/broker/manage/subaccount-apikey-list":2},post:{"broker/v1/account/sub-create":20,"broker/v1/account/sub-modify":20,"broker/v1/account/sub-modify-email":20,"broker/v1/account/sub-address":2,"broker/v1/account/sub-withdrawal":2,"broker/v1/account/sub-auto-transfer":4,"broker/v1/account/sub-api-create":2,"broker/v1/account/sub-api-modify":2,"v2/broker/account/modify-subaccount-email":2,"v2/broker/account/create-subaccount":20,"v2/broker/account/modify-subaccount":20,"v2/broker/account/subaccount-address":2,"v2/broker/account/subaccount-withdrawal":2,"v2/broker/account/set-subaccount-autotransfer":2,"v2/broker/manage/create-subaccount-apikey":2,"v2/broker/manage/modify-subaccount-apikey":2}},margin:{get:{"margin/v1/cross/account/riskRate":2,"margin/v1/cross/account/maxTransferOutAmount":2,"margin/v1/isolated/account/maxTransferOutAmount":2,"margin/v1/isolated/order/openOrders":2,"margin/v1/isolated/order/history":2,"margin/v1/isolated/order/fills":2,"margin/v1/isolated/loan/list":2,"margin/v1/isolated/repay/list":2,"margin/v1/isolated/interest/list":2,"margin/v1/isolated/liquidation/list":2,"margin/v1/isolated/fin/list":2,"margin/v1/cross/order/openOrders":2,"margin/v1/cross/order/history":2,"margin/v1/cross/order/fills":2,"margin/v1/cross/loan/list":2,"margin/v1/cross/repay/list":2,"margin/v1/cross/interest/list":2,"margin/v1/cross/liquidation/list":2,"margin/v1/cross/fin/list":2,"margin/v1/cross/account/assets":2,"margin/v1/isolated/account/assets":2,"v2/margin/crossed/borrow-history":2,"v2/margin/crossed/repay-history":2,"v2/margin/crossed/interest-history":2,"v2/margin/crossed/liquidation-history":2,"v2/margin/crossed/financial-records":2,"v2/margin/crossed/account/assets":2,"v2/margin/crossed/account/risk-rate":2,"v2/margin/crossed/account/max-borrowable-amount":2,"v2/margin/crossed/account/max-transfer-out-amount":2,"v2/margin/crossed/interest-rate-and-limit":2,"v2/margin/crossed/tier-data":2,"v2/margin/crossed/open-orders":2,"v2/margin/crossed/history-orders":2,"v2/margin/crossed/fills":2,"v2/margin/isolated/borrow-history":2,"v2/margin/isolated/repay-history":2,"v2/margin/isolated/interest-history":2,"v2/margin/isolated/liquidation-history":2,"v2/margin/isolated/financial-records":2,"v2/margin/isolated/account/assets":2,"v2/margin/isolated/account/risk-rate":2,"v2/margin/isolated/account/max-borrowable-amount":2,"v2/margin/isolated/account/max-transfer-out-amount":2,"v2/margin/isolated/interest-rate-and-limit":2,"v2/margin/isolated/tier-data":2,"v2/margin/isolated/open-orders":2,"v2/margin/isolated/history-orders":2,"v2/margin/isolated/fills":2},post:{"margin/v1/cross/account/borrow":2,"margin/v1/isolated/account/borrow":2,"margin/v1/cross/account/repay":2,"margin/v1/isolated/account/repay":2,"margin/v1/isolated/account/riskRate":2,"margin/v1/cross/account/maxBorrowableAmount":2,"margin/v1/isolated/account/maxBorrowableAmount":2,"margin/v1/isolated/account/flashRepay":2,"margin/v1/isolated/account/queryFlashRepayStatus":2,"margin/v1/cross/account/flashRepay":2,"margin/v1/cross/account/queryFlashRepayStatus":2,"margin/v1/isolated/order/placeOrder":4,"margin/v1/isolated/order/batchPlaceOrder":4,"margin/v1/isolated/order/cancelOrder":2,"margin/v1/isolated/order/batchCancelOrder":2,"margin/v1/cross/order/placeOrder":2,"margin/v1/cross/order/batchPlaceOrder":2,"margin/v1/cross/order/cancelOrder":2,"margin/v1/cross/order/batchCancelOrder":2,"v2/margin/crossed/account/borrow":2,"v2/margin/crossed/account/repay":2,"v2/margin/crossed/account/flash-repay":2,"v2/margin/crossed/account/query-flash-repay-status":2,"v2/margin/crossed/place-order":2,"v2/margin/crossed/batch-place-order":2,"v2/margin/crossed/cancel-order":2,"v2/margin/crossed/batch-cancel-order":2,"v2/margin/isolated/account/borrow":2,"v2/margin/isolated/account/repay":2,"v2/margin/isolated/account/flash-repay":2,"v2/margin/isolated/account/query-flash-repay-status":2,"v2/margin/isolated/place-order":2,"v2/margin/isolated/batch-place-order":2,"v2/margin/isolated/cancel-order":2,"v2/margin/isolated/batch-cancel-order":2}},copy:{get:{"v2/copy/mix-trader/order-current-track":2,"v2/copy/mix-trader/order-history-track":2,"v2/copy/mix-trader/order-total-detail":2,"v2/copy/mix-trader/profit-history-summarys":1,"v2/copy/mix-trader/profit-history-details":1,"v2/copy/mix-trader/profit-details":1,"v2/copy/mix-trader/profits-group-coin-date":1,"v2/copy/mix-trader/config-query-symbols":1,"v2/copy/mix-trader/config-query-followers":2,"v2/copy/mix-follower/query-current-orders":2,"v2/copy/mix-follower/query-history-orders":1,"v2/copy/mix-follower/query-settings":2,"v2/copy/mix-follower/query-traders":2,"v2/copy/mix-follower/query-quantity-limit":2,"v2/copy/mix-broker/query-traders":2,"v2/copy/mix-broker/query-history-traces":2,"v2/copy/mix-broker/query-current-traces":2,"v2/copy/spot-trader/profit-summarys":2,"v2/copy/spot-trader/profit-history-details":2,"v2/copy/spot-trader/profit-details":2,"v2/copy/spot-trader/order-total-detail":2,"v2/copy/spot-trader/order-history-track":2,"v2/copy/spot-trader/order-current-track":2,"v2/copy/spot-trader/config-query-settings":2,"v2/copy/spot-trader/config-query-followers":2,"v2/copy/spot-follower/query-traders":2,"v2/copy/spot-follower/query-trader-symbols":2,"v2/copy/spot-follower/query-settings":2,"v2/copy/spot-follower/query-history-orders":2,"v2/copy/spot-follower/query-current-orders":2},post:{"v2/copy/mix-trader/order-modify-tpsl":2,"v2/copy/mix-trader/order-close-positions":2,"v2/copy/mix-trader/config-setting-symbols":2,"v2/copy/mix-trader/config-setting-base":2,"v2/copy/mix-trader/config-remove-follower":2,"v2/copy/mix-follower/setting-tpsl":1,"v2/copy/mix-follower/settings":2,"v2/copy/mix-follower/close-positions":2,"v2/copy/mix-follower/cancel-trader":4,"v2/copy/spot-trader/order-modify-tpsl":2,"v2/copy/spot-trader/order-close-tracking":2,"v2/copy/spot-trader/config-setting-symbols":2,"v2/copy/spot-trader/config-remove-follower":2,"v2/copy/spot-follower/stop-order":2,"v2/copy/spot-follower/settings":2,"v2/copy/spot-follower/setting-tpsl":2,"v2/copy/spot-follower/order-close-tracking":2,"v2/copy/spot-follower/cancel-trader":2}},tax:{get:{"v2/tax/spot-record":20,"v2/tax/future-record":20,"v2/tax/margin-record":20,"v2/tax/p2p-record":20}},convert:{get:{"v2/convert/currencies":2,"v2/convert/quoted-price":2,"v2/convert/convert-record":2,"v2/convert/bgb-convert-coin-list":2,"v2/convert/bgb-convert-records":2},post:{"v2/convert/trade":2,"v2/convert/bgb-convert":2}},earn:{get:{"v2/earn/savings/product":2,"v2/earn/savings/account":2,"v2/earn/savings/assets":2,"v2/earn/savings/records":2,"v2/earn/savings/subscribe-info":2,"v2/earn/savings/subscribe-result":2,"v2/earn/savings/redeem-result":2,"v2/earn/sharkfin/product":2,"v2/earn/sharkfin/account":2,"v2/earn/sharkfin/assets":2,"v2/earn/sharkfin/records":2,"v2/earn/sharkfin/subscribe-info":2,"v2/earn/sharkfin/subscribe-result":4,"v2/earn/loan/ongoing-orders":2,"v2/earn/loan/repay-history":2,"v2/earn/loan/revise-history":2,"v2/earn/loan/borrow-history":2,"v2/earn/loan/debts":2,"v2/earn/loan/reduces":2,"v2/earn/account/assets":2},post:{"v2/earn/savings/subscribe":2,"v2/earn/savings/redeem":2,"v2/earn/sharkfin/subscribe":2,"v2/earn/loan/borrow":2,"v2/earn/loan/repay":2,"v2/earn/loan/revise-pledge":2}},common:{get:{"v2/common/trade-rate":2}}}},fees:{spot:{taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")},swap:{taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0004")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:r.ExchangeError,"failure to get a peer from the ring-balancer":r.ExchangeNotAvailable,4010:r.PermissionDenied,4001:r.ExchangeError,4002:r.ExchangeError,30001:r.AuthenticationError,30002:r.AuthenticationError,30003:r.AuthenticationError,30004:r.AuthenticationError,30005:r.InvalidNonce,30006:r.AuthenticationError,30007:r.BadRequest,30008:r.RequestTimeout,30009:r.ExchangeError,30010:r.AuthenticationError,30011:r.PermissionDenied,30012:r.AuthenticationError,30013:r.AuthenticationError,30014:r.DDoSProtection,30015:r.AuthenticationError,30016:r.ExchangeError,30017:r.ExchangeError,30018:r.ExchangeError,30019:r.ExchangeNotAvailable,30020:r.BadRequest,30021:r.BadRequest,30022:r.PermissionDenied,30023:r.BadRequest,30024:r.BadSymbol,30025:r.BadRequest,30026:r.DDoSProtection,30027:r.AuthenticationError,30028:r.PermissionDenied,30029:r.AccountSuspended,30030:r.ExchangeError,30031:r.BadRequest,30032:r.BadSymbol,30033:r.BadRequest,30034:r.ExchangeError,30035:r.ExchangeError,30036:r.ExchangeError,30037:r.ExchangeNotAvailable,30038:r.OnMaintenance,32001:r.AccountSuspended,32002:r.PermissionDenied,32003:r.CancelPending,32004:r.ExchangeError,32005:r.InvalidOrder,32006:r.InvalidOrder,32007:r.InvalidOrder,32008:r.InvalidOrder,32009:r.InvalidOrder,32010:r.ExchangeError,32011:r.ExchangeError,32012:r.ExchangeError,32013:r.ExchangeError,32014:r.ExchangeError,32015:r.ExchangeError,32016:r.ExchangeError,32017:r.ExchangeError,32018:r.ExchangeError,32019:r.ExchangeError,32020:r.ExchangeError,32021:r.ExchangeError,32022:r.ExchangeError,32023:r.ExchangeError,32024:r.ExchangeError,32025:r.ExchangeError,32026:r.ExchangeError,32027:r.ExchangeError,32028:r.AccountSuspended,32029:r.ExchangeError,32030:r.InvalidOrder,32031:r.ArgumentsRequired,32038:r.AuthenticationError,32040:r.ExchangeError,32044:r.ExchangeError,32045:r.ExchangeError,32046:r.ExchangeError,32047:r.ExchangeError,32048:r.InvalidOrder,32049:r.ExchangeError,32050:r.InvalidOrder,32051:r.InvalidOrder,32052:r.ExchangeError,32053:r.ExchangeError,32057:r.ExchangeError,32054:r.ExchangeError,32055:r.InvalidOrder,32056:r.ExchangeError,32058:r.ExchangeError,32059:r.InvalidOrder,32060:r.InvalidOrder,32061:r.InvalidOrder,32062:r.InvalidOrder,32063:r.InvalidOrder,32064:r.ExchangeError,32065:r.ExchangeError,32066:r.ExchangeError,32067:r.ExchangeError,32068:r.ExchangeError,32069:r.ExchangeError,32070:r.ExchangeError,32071:r.ExchangeError,32072:r.ExchangeError,32073:r.ExchangeError,32074:r.ExchangeError,32075:r.ExchangeError,32076:r.ExchangeError,32077:r.ExchangeError,32078:r.ExchangeError,32079:r.ExchangeError,32080:r.ExchangeError,32083:r.ExchangeError,33001:r.PermissionDenied,33002:r.AccountSuspended,33003:r.InsufficientFunds,33004:r.ExchangeError,33005:r.ExchangeError,33006:r.ExchangeError,33007:r.ExchangeError,33008:r.InsufficientFunds,33009:r.ExchangeError,33010:r.ExchangeError,33011:r.ExchangeError,33012:r.ExchangeError,33013:r.InvalidOrder,33014:r.OrderNotFound,33015:r.InvalidOrder,33016:r.ExchangeError,33017:r.InsufficientFunds,33018:r.ExchangeError,33020:r.ExchangeError,33021:r.BadRequest,33022:r.InvalidOrder,33023:r.ExchangeError,33024:r.InvalidOrder,33025:r.InvalidOrder,33026:r.ExchangeError,33027:r.InvalidOrder,33028:r.InvalidOrder,33029:r.InvalidOrder,33034:r.ExchangeError,33035:r.ExchangeError,33036:r.ExchangeError,33037:r.ExchangeError,33038:r.ExchangeError,33039:r.ExchangeError,33040:r.ExchangeError,33041:r.ExchangeError,33042:r.ExchangeError,33043:r.ExchangeError,33044:r.ExchangeError,33045:r.ExchangeError,33046:r.ExchangeError,33047:r.ExchangeError,33048:r.ExchangeError,33049:r.ExchangeError,33050:r.ExchangeError,33051:r.ExchangeError,33059:r.BadRequest,33060:r.BadRequest,33061:r.ExchangeError,33062:r.ExchangeError,33063:r.ExchangeError,33064:r.ExchangeError,33065:r.ExchangeError,21009:r.ExchangeError,34001:r.PermissionDenied,34002:r.InvalidAddress,34003:r.ExchangeError,34004:r.ExchangeError,34005:r.ExchangeError,34006:r.ExchangeError,34007:r.ExchangeError,34008:r.InsufficientFunds,34009:r.ExchangeError,34010:r.ExchangeError,34011:r.ExchangeError,34012:r.ExchangeError,34013:r.ExchangeError,34014:r.ExchangeError,34015:r.ExchangeError,34016:r.PermissionDenied,34017:r.AccountSuspended,34018:r.AuthenticationError,34019:r.PermissionDenied,34020:r.PermissionDenied,34021:r.InvalidAddress,34022:r.ExchangeError,34023:r.PermissionDenied,34026:r.ExchangeError,34036:r.ExchangeError,34037:r.ExchangeError,34038:r.ExchangeError,34039:r.ExchangeError,35001:r.ExchangeError,35002:r.ExchangeError,35003:r.ExchangeError,35004:r.ExchangeError,35005:r.AuthenticationError,35008:r.InvalidOrder,35010:r.InvalidOrder,35012:r.InvalidOrder,35014:r.InvalidOrder,35015:r.InvalidOrder,35017:r.ExchangeError,35019:r.InvalidOrder,35020:r.InvalidOrder,35021:r.InvalidOrder,35022:r.ExchangeError,35024:r.ExchangeError,35025:r.InsufficientFunds,35026:r.ExchangeError,35029:r.OrderNotFound,35030:r.InvalidOrder,35031:r.InvalidOrder,35032:r.ExchangeError,35037:r.ExchangeError,35039:r.ExchangeError,35040:r.InvalidOrder,35044:r.ExchangeError,35046:r.InsufficientFunds,35047:r.InsufficientFunds,35048:r.ExchangeError,35049:r.InvalidOrder,35050:r.InvalidOrder,35052:r.InsufficientFunds,35053:r.ExchangeError,35055:r.InsufficientFunds,35057:r.ExchangeError,35058:r.ExchangeError,35059:r.BadRequest,35060:r.BadRequest,35061:r.BadRequest,35062:r.InvalidOrder,35063:r.InvalidOrder,35064:r.InvalidOrder,35066:r.InvalidOrder,35067:r.InvalidOrder,35068:r.InvalidOrder,35069:r.InvalidOrder,35070:r.InvalidOrder,35071:r.InvalidOrder,35072:r.InvalidOrder,35073:r.InvalidOrder,35074:r.InvalidOrder,35075:r.InvalidOrder,35076:r.InvalidOrder,35077:r.InvalidOrder,35078:r.InvalidOrder,35079:r.InvalidOrder,35080:r.InvalidOrder,35081:r.InvalidOrder,35082:r.InvalidOrder,35083:r.InvalidOrder,35084:r.InvalidOrder,35085:r.InvalidOrder,35086:r.InvalidOrder,35087:r.InvalidOrder,35088:r.InvalidOrder,35089:r.InvalidOrder,35090:r.ExchangeError,35091:r.ExchangeError,35092:r.ExchangeError,35093:r.ExchangeError,35094:r.ExchangeError,35095:r.BadRequest,35096:r.ExchangeError,35097:r.ExchangeError,35098:r.ExchangeError,35099:r.ExchangeError,36001:r.BadRequest,36002:r.BadRequest,36005:r.ExchangeError,36101:r.AuthenticationError,36102:r.PermissionDenied,36103:r.AccountSuspended,36104:r.PermissionDenied,36105:r.PermissionDenied,36106:r.AccountSuspended,36107:r.PermissionDenied,36108:r.InsufficientFunds,36109:r.PermissionDenied,36201:r.PermissionDenied,36202:r.PermissionDenied,36203:r.InvalidOrder,36204:r.ExchangeError,36205:r.BadRequest,36206:r.BadRequest,36207:r.InvalidOrder,36208:r.InvalidOrder,36209:r.InvalidOrder,36210:r.InvalidOrder,36211:r.InvalidOrder,36212:r.InvalidOrder,36213:r.InvalidOrder,36214:r.ExchangeError,36216:r.OrderNotFound,36217:r.InvalidOrder,36218:r.InvalidOrder,36219:r.InvalidOrder,36220:r.InvalidOrder,36221:r.InvalidOrder,36222:r.InvalidOrder,36223:r.InvalidOrder,36224:r.InvalidOrder,36225:r.InvalidOrder,36226:r.InvalidOrder,36227:r.InvalidOrder,36228:r.InvalidOrder,36229:r.InvalidOrder,36230:r.InvalidOrder,400:r.BadRequest,401:r.AuthenticationError,403:r.PermissionDenied,404:r.BadRequest,405:r.BadRequest,415:r.BadRequest,429:r.DDoSProtection,500:r.ExchangeNotAvailable,1001:r.RateLimitExceeded,1002:r.ExchangeError,1003:r.ExchangeError,40001:r.AuthenticationError,40002:r.AuthenticationError,40003:r.AuthenticationError,40004:r.InvalidNonce,40005:r.InvalidNonce,40006:r.AuthenticationError,40007:r.BadRequest,40008:r.InvalidNonce,40009:r.AuthenticationError,40010:r.AuthenticationError,40011:r.AuthenticationError,40012:r.AuthenticationError,40013:r.ExchangeError,40014:r.PermissionDenied,40015:r.ExchangeError,40016:r.PermissionDenied,40017:r.ExchangeError,40018:r.PermissionDenied,40019:r.BadRequest,40031:r.AccountSuspended,40037:r.AuthenticationError,40102:r.BadRequest,40103:r.BadRequest,40104:r.ExchangeError,40105:r.ExchangeError,40106:r.ExchangeError,40107:r.ExchangeError,40108:r.InvalidOrder,40109:r.OrderNotFound,40200:r.OnMaintenance,40201:r.InvalidOrder,40202:r.ExchangeError,40203:r.BadRequest,40204:r.BadRequest,40205:r.BadRequest,40206:r.BadRequest,40207:r.BadRequest,40208:r.BadRequest,40209:r.BadRequest,40300:r.ExchangeError,40301:r.PermissionDenied,40302:r.BadRequest,40303:r.BadRequest,40304:r.BadRequest,40305:r.BadRequest,40306:r.ExchangeError,40308:r.OnMaintenance,40309:r.BadSymbol,40400:r.ExchangeError,40401:r.ExchangeError,40402:r.BadRequest,40403:r.BadRequest,40404:r.BadRequest,40405:r.BadRequest,40406:r.BadRequest,40407:r.ExchangeError,40408:r.ExchangeError,40409:r.ExchangeError,40500:r.InvalidOrder,40501:r.ExchangeError,40502:r.ExchangeError,40503:r.ExchangeError,40504:r.ExchangeError,40505:r.ExchangeError,40506:r.AuthenticationError,40507:r.AuthenticationError,40508:r.ExchangeError,40509:r.ExchangeError,40600:r.ExchangeError,40601:r.ExchangeError,40602:r.ExchangeError,40603:r.ExchangeError,40604:r.ExchangeNotAvailable,40605:r.ExchangeError,40606:r.ExchangeError,40607:r.ExchangeError,40608:r.ExchangeError,40609:r.ExchangeError,40700:r.BadRequest,40701:r.ExchangeError,40702:r.ExchangeError,40703:r.ExchangeError,40704:r.ExchangeError,40705:r.BadRequest,40706:r.InvalidOrder,40707:r.BadRequest,40708:r.BadRequest,40709:r.ExchangeError,40710:r.ExchangeError,40711:r.InsufficientFunds,40712:r.InsufficientFunds,40713:r.ExchangeError,40714:r.ExchangeError,40762:r.InsufficientFunds,40768:r.OrderNotFound,41114:r.OnMaintenance,43011:r.InvalidOrder,43012:r.InsufficientFunds,43025:r.InvalidOrder,43115:r.OnMaintenance,45110:r.InvalidOrder,"invalid sign":r.AuthenticationError,"invalid currency":r.BadSymbol,"invalid symbol":r.BadSymbol,"invalid period":r.BadRequest,"invalid user":r.ExchangeError,"invalid amount":r.InvalidOrder,"invalid type":r.InvalidOrder,"invalid orderId":r.InvalidOrder,"invalid record":r.ExchangeError,"invalid accountId":r.BadRequest,"invalid address":r.BadRequest,"accesskey not null":r.AuthenticationError,"illegal accesskey":r.AuthenticationError,"sign not null":r.AuthenticationError,"req_time is too much difference from server time":r.InvalidNonce,"permissions not right":r.PermissionDenied,"illegal sign invalid":r.AuthenticationError,"user locked":r.AccountSuspended,"Request Frequency Is Too High":r.RateLimitExceeded,"more than a daily rate of cash":r.BadRequest,"more than the maximum daily withdrawal amount":r.BadRequest,"need to bind email or mobile":r.ExchangeError,"user forbid":r.PermissionDenied,"User Prohibited Cash Withdrawal":r.PermissionDenied,"Cash Withdrawal Is Less Than The Minimum Value":r.BadRequest,"Cash Withdrawal Is More Than The Maximum Value":r.BadRequest,"the account with in 24 hours ban coin":r.PermissionDenied,"order cancel fail":r.BadRequest,"base symbol error":r.BadSymbol,"base date error":r.ExchangeError,"api signature not valid":r.AuthenticationError,"gateway internal error":r.ExchangeError,"audit failed":r.ExchangeError,"order queryorder invalid":r.BadRequest,"market no need price":r.InvalidOrder,"limit need price":r.InvalidOrder,"userid not equal to account_id":r.ExchangeError,"your balance is low":r.InsufficientFunds,"address invalid cointype":r.ExchangeError,"system exception":r.ExchangeError,50003:r.ExchangeError,50004:r.BadSymbol,50006:r.PermissionDenied,50007:r.PermissionDenied,50008:r.RequestTimeout,50009:r.RateLimitExceeded,50010:r.ExchangeError,50014:r.InvalidOrder,50015:r.InvalidOrder,50016:r.InvalidOrder,50017:r.InvalidOrder,50018:r.InvalidOrder,50019:r.InvalidOrder,50020:r.InsufficientFunds,50021:r.InvalidOrder,50026:r.InvalidOrder,"invalid order query time":r.ExchangeError,"invalid start time":r.BadRequest,"invalid end time":r.BadRequest,20003:r.ExchangeError,"01001":r.ExchangeError,43111:r.PermissionDenied},broad:{"invalid size, valid range":r.ExchangeError}},precisionMode:o.kb,commonCurrencies:{JADE:"Jade Protocol",DEGEN:"DegenReborn",TONCOIN:"TON",OMNI:"omni"},options:{timeframes:{spot:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","6h":"6Hutc","12h":"12Hutc","1d":"1Dutc","3d":"3Dutc","1w":"1Wutc","1M":"1Mutc"},swap:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6Hutc","12h":"12Hutc","1d":"1Dutc","3d":"3Dutc","1w":"1Wutc","1M":"1Mutc"}},fetchMarkets:["spot","swap"],defaultType:"spot",defaultSubType:"linear",createMarketBuyOrderRequiresPrice:!0,broker:"p4sve",withdraw:{fillResponseFromRequest:!0},fetchOHLCV:{spot:{method:"publicSpotGetV2SpotMarketCandles"},swap:{method:"publicMixGetV2MixMarketCandles"},maxDaysPerTimeframe:{"1m":30,"3m":30,"5m":30,"10m":52,"15m":52,"30m":52,"1h":83,"2h":120,"4h":240,"6h":360,"12h":360,"1d":360,"3d":1e3,"1w":1e3,"1M":1e3}},fetchTrades:{spot:{method:"publicSpotGetV2SpotMarketFillsHistory"},swap:{method:"publicMixGetV2MixMarketFillsHistory"}},accountsByType:{spot:"spot",cross:"crossed_margin",isolated:"isolated_margin",swap:"usdt_futures",usdc_swap:"usdc_futures",future:"coin_futures",p2p:"p2p"},accountsById:{spot:"spot",crossed_margin:"cross",isolated_margin:"isolated",usdt_futures:"swap",usdc_futures:"usdc_swap",coin_futures:"future",p2p:"p2p"},sandboxMode:!1,networks:{TRX:"TRC20",ETH:"ERC20",BSC:"BEP20"},networksById:{TRC20:"TRX",BSC:"BEP20"},fetchPositions:{method:"privateMixGetV2MixPositionAllPosition"},defaultTimeInForce:"GTC"}})}setSandboxMode(e){this.options.sandboxMode=e}convertSymbolForSandbox(e){if(e.startsWith("S"))return e;let t;if(e.indexOf("/")>-1){if(-1===e.indexOf(":"))throw new r.NotSupported(this.id+" sandbox supports swap and future markets only");const s=e.split("/"),i=this.safeString(s,0),a=this.safeString(s,1).split(":"),o=this.safeString(a,0),n=this.safeString(a,1).split("-"),d=this.safeString(n,0),h=this.safeString(n,1);t="S"+i+"/S"+o+":S"+d,void 0!==h&&(t=t+"-"+h)}else{t="S"+e.slice(0,3)+"S"+e.slice(3)}return t}handleProductTypeAndParams(e=void 0,t={}){let s,i;if([s,t]=this.handleSubTypeAndParams("handleProductTypeAndParams",void 0,t),void 0!==s&&void 0===e){i=this.safeBool(this.options,"sandboxMode",!1)?"linear"===s?"SUSDT-FUTURES":"SCOIN-FUTURES":"linear"===s?"USDT-FUTURES":"COIN-FUTURES"}let a=this.safeString(t,"productType",i);if(void 0===a&&void 0!==e){const t=e.settle;a="USDT"===t?"USDT-FUTURES":"USDC"===t?"USDC-FUTURES":"SUSDT"===t?"SUSDT-FUTURES":"SUSDC"===t?"SUSDC-FUTURES":"SBTC"===t||"SETH"===t||"SEOS"===t?"SCOIN-FUTURES":"COIN-FUTURES"}if(void 0===a)throw new r.ArgumentsRequired(this.id+' requires a productType param, one of "USDT-FUTURES", "USDC-FUTURES", "COIN-FUTURES", "SUSDT-FUTURES", "SUSDC-FUTURES" or "SCOIN-FUTURES"');return[a,t=this.omit(t,"productType")]}async fetchTime(e={}){const t=await this.publicCommonGetV2PublicTime(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"serverTime")}async fetchMarkets(e={}){const t=this.safeBool(this.options,"sandboxMode",!1);let s=this.safeValue(this.options,"fetchMarkets",["spot","swap"]);t&&(s=["swap"]);let i=[];for(let r=0;r<s.length;r++){const a=s[r];if("swap"===a){let s;s=t?["SUSDT-FUTURES","SCOIN-FUTURES","SUSDC-FUTURES"]:["USDT-FUTURES","COIN-FUTURES","USDC-FUTURES"];for(let t=0;t<s.length;t++)i.push(this.fetchMarketsByType(a,this.extend(e,{productType:s[t]})))}else i.push(this.fetchMarketsByType(s[r],e))}i=await Promise.all(i);let r=i[0];for(let e=1;e<i.length;e++)r=this.arrayConcat(r,i[e]);return r}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quoteCoin"),i=this.safeString(e,"baseCoin"),r=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeValue(e,"supportMarginCoins",[]);let d;d=this.inArray(i,n)?i:this.inArray(s,n)?s:this.safeString(n,0);const h=this.safeCurrencyCode(d);let c,l,u,p,f,m,g,v=o+"/"+r,y=!1,w=!1,b=!1,S=!1;const k=this.safeString(e,"symbolType");if(void 0===k)c="spot",w=!0,l=this.parseNumber(this.parsePrecision(this.safeString(e,"pricePrecision"))),u=this.parseNumber(this.parsePrecision(this.safeString(e,"quantityPrecision")));else{if("perpetual"===k)c="swap",y=!0,v=v+":"+h;else if("delivery"===k){m=this.safeInteger(e,"deliveryTime"),g=this.iso8601(m);const t=g.split("-"),s=this.safeString(t,0),i=this.safeString(t,2);c="future",b=!0,v=v+":"+h+"-"+(s.slice(2,4)+this.safeString(t,1)+i.slice(0,2))}S=!0,f=o===h,p=!f;const t=this.safeInteger(e,"pricePlace"),s=this.safeInteger(e,"volumePlace"),i=this.safeString(e,"priceEndStep"),r=this.safeString(e,"minTradeNum"),n=new a.Y(i);n.decimals=Math.max(n.decimals,t),n.reduce();const d=n.toString();l=this.parseNumber(d);const w=new a.Y(r);w.decimals=Math.max(w.decimals,s),w.reduce();const O=w.toString();u=this.parseNumber(O)}const O=this.safeString2(e,"status","symbolStatus");let T,P;void 0!==O&&(T="online"===O||"normal"===O),"USDT"===r&&(P=this.safeNumber(e,"minTradeUSDT"));const I=S?1:void 0;return{id:t,symbol:v,base:o,quote:r,settle:h,baseId:i,quoteId:s,settleId:d,type:c,spot:w,margin:void 0,swap:y,future:b,option:!1,active:T,contract:S,linear:p,inverse:f,taker:this.safeNumber(e,"takerFeeRate"),maker:this.safeNumber(e,"makerFeeRate"),contractSize:I,expiry:m,expiryDatetime:g,strike:void 0,optionType:void 0,precision:{amount:u,price:l},limits:{leverage:{min:this.safeNumber(e,"minLever"),max:this.safeNumber(e,"maxLever")},amount:{min:this.safeNumber2(e,"minTradeNum","minTradeAmount"),max:this.safeNumber(e,"maxTradeAmount")},price:{min:void 0,max:void 0},cost:{min:P,max:void 0}},created:this.safeInteger(e,"launchTime"),info:e}}async fetchMarketsByType(e,t={}){let s;if("spot"===e)s=await this.publicSpotGetV2SpotPublicSymbols(t);else{if("swap"!==e&&"future"!==e)throw new r.NotSupported(this.id+" does not support "+e+" market");s=await this.publicMixGetV2MixMarketContracts(t)}const i=this.safeValue(s,"data",[]);return this.parseMarkets(i)}async fetchCurrencies(e={}){const t=await this.publicSpotGetV2SpotPublicCoins(e),s={},i=this.safeValue(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"coin"),o=this.safeCurrencyCode(r),n=this.safeValue(t,"chains",[]),d={};let h,c,l,u=!1,p=!1;for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"chain"),i=this.safeCurrencyCode(s),r="true"===this.safeString(t,"withdrawable");p=r||p;const o="true"===this.safeString(t,"rechargeable");u=o||u;const f=this.safeString(t,"withdrawFee");void 0!==f&&(l=void 0===l?f:a.Y.stringMin(f,l));const m=this.safeString(t,"minWithdrawAmount");void 0!==m&&(h=void 0===h?m:a.Y.stringMin(m,h));const g=this.safeString(t,"minDepositAmount");void 0!==g&&(c=void 0===c?g:a.Y.stringMin(g,c)),d[i]={info:t,id:s,network:i,limits:{withdraw:{min:this.parseNumber(m),max:void 0},deposit:{min:this.parseNumber(g),max:void 0}},active:r&&o,withdraw:r,deposit:o,fee:this.parseNumber(f),precision:void 0}}s[o]={info:t,id:r,code:o,networks:d,type:void 0,name:void 0,active:u&&p,deposit:u,withdraw:p,fee:this.parseNumber(l),precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(h),max:void 0},deposit:{min:this.parseNumber(c),max:void 0}},created:void 0}}return s}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();let s;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);const i={};let a,o;if([o,t]=this.handleMarginModeAndParams("fetchMarketLeverageTiers",t,"isolated"),s.swap||s.future){let e;[e,t]=this.handleProductTypeAndParams(s,t),i.productType=e,i.symbol=s.id,a=await this.publicMixGetV2MixMarketQueryPositionLever(this.extend(i,t))}else if("isolated"===o)i.symbol=s.id,a=await this.privateMarginGetV2MarginIsolatedTierData(this.extend(i,t));else{if("cross"!==o)throw new r.BadRequest(this.id+" fetchMarketLeverageTiers() symbol does not support market "+s.symbol);{const e=this.safeString(t,"code");if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMarketLeverageTiers() requires a code argument");t=this.omit(t,"code");const s=this.currency(e);i.coin=s.id,a=await this.privateMarginGetV2MarginCrossedTierData(this.extend(i,t))}}const n=this.safeValue(a,"data",[]);return this.parseMarketLeverageTiers(n,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];let i=0;for(let r=0;r<e.length;r++){const a=e[r],o=this.safeNumber(a,"startUnit");void 0!==o&&(i=o);const n=this.safeNumberN(a,["endUnit","maxBorrowableAmount","baseMaxBorrowableAmount"]),d=this.safeString2(a,"coin","baseCoin"),h=void 0!==d?d:t.base;s.push({tier:this.safeInteger2(a,"level","tier"),currency:this.safeCurrencyCode(h),minNotional:i,maxNotional:n,maintenanceMarginRate:this.safeNumber2(a,"keepMarginRate","maintainMarginRate"),maxLeverage:this.safeNumber(a,"leverage"),info:a}),i=n}return s}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),a)return await this.fetchPaginatedCallCursor("fetchDeposits",void 0,t,s,i,"idLessThan","idLessThan",void 0,100);if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires a `code` argument");const o=this.currency(e);void 0===t&&(t=this.milliseconds()-7776e6);let n={coin:o.id,startTime:t,endTime:this.milliseconds()};void 0!==s&&(n.limit=s),[n,i]=this.handleUntilOption("endTime",n,i);const d=await this.privateSpotGetV2SpotWalletDepositRecords(this.extend(n,i)),h=this.safeList(d,"data",[]);return this.parseTransactions(h,o,t,s)}async withdraw(e,t,s,i=void 0,a={}){this.checkAddress(s);const o=this.safeString2(a,"chain","network");if(a=this.omit(a,"network"),void 0===o)throw new r.ArgumentsRequired(this.id+" withdraw() requires a chain parameter or a network parameter");await this.loadMarkets();const n=this.currency(e),d=this.networkCodeToId(o),h={coin:n.id,address:s,chain:d,size:t,transferType:"on_chain"};void 0!==i&&(h.tag=i);const c=await this.privateSpotPostV2SpotWalletWithdrawal(this.extend(h,a)),l=this.safeValue(c,"data",{}),u={id:this.safeString(l,"orderId"),info:c,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:"withdrawal",currency:void 0,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,fee:void 0},p=this.safeValue(this.options,"withdraw",{});return this.safeBool(p,"fillResponseFromRequest",!0)&&(u.currency=e,u.timestamp=this.milliseconds(),u.datetime=this.iso8601(this.milliseconds()),u.amount=t,u.tag=i,u.address=s,u.addressTo=s,u.network=o),u}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),a)return await this.fetchPaginatedCallCursor("fetchWithdrawals",void 0,t,s,i,"idLessThan","idLessThan",void 0,100);if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchWithdrawals() requires a `code` argument");const o=this.currency(e);void 0===t&&(t=this.milliseconds()-7776e6);let n={coin:o.id,startTime:t,endTime:this.milliseconds()};[n,i]=this.handleUntilOption("endTime",n,i),void 0!==s&&(n.limit=s);const d=await this.privateSpotGetV2SpotWalletWithdrawalRecords(this.extend(n,i)),h=this.safeList(d,"data",[]);return this.parseTransactions(h,o,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),r=this.safeInteger(e,"cTime"),o=this.safeString(e,"chain"),n=this.safeString(e,"status"),d=this.safeString(e,"tag"),h=this.safeString(e,"fee"),c=a.Y.stringAbs(h);let l,u=this.safeString(e,"size");return void 0!==c&&(l={currency:i,cost:this.parseNumber(c)},u=a.Y.stringSub(u,c)),{id:this.safeString(e,"orderId"),info:e,txid:this.safeString(e,"tradeId"),timestamp:r,datetime:this.iso8601(r),network:this.networkIdToCode(o),addressFrom:this.safeString(e,"fromAddress"),address:this.safeString(e,"toAddress"),addressTo:this.safeString(e,"toAddress"),amount:this.parseNumber(u),type:this.safeString(e,"type"),currency:i,status:this.parseTransactionStatus(n),updated:this.safeInteger(e,"uTime"),tagFrom:void 0,tag:d,tagTo:d,comment:void 0,internal:void 0,fee:l}}parseTransactionStatus(e){return this.safeString({success:"ok",Pending:"pending",pending_review:"pending",pending_review_fail:"failed",reject:"failed"},e,e)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeString2(t,"chain","network");let i;t=this.omit(t,"network"),void 0!==s&&(i=this.networkCodeToId(s,e));const r=this.currency(e),a={coin:r.id};void 0!==i&&(a.chain=i);const o=await this.privateSpotGetV2SpotWalletDepositAddress(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseDepositAddress(n,r)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeString(e,"chain"),r=this.safeCurrencyCode(s,t);let a;return void 0!==i&&(a=this.networkIdToCode(i,r)),{currency:r,address:this.safeString(e,"address"),tag:this.safeString(e,"tag"),network:a,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();let i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);i=this.market(t)}else i=this.market(e);const r={symbol:i.id};let a;if(void 0!==t&&(r.limit=t),i.spot)a=await this.publicSpotGetV2SpotMarketOrderbook(this.extend(r,s));else{let e;[e,s]=this.handleProductTypeAndParams(i,s),r.productType=e,a=await this.publicMixGetV2MixMarketMergeDepth(this.extend(r,s))}const o=this.safeValue(a,"data",{}),n=this.safeInteger(o,"ts");return this.parseOrderBook(o,i.symbol,n)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"lastPr"),r=this.safeIntegerOmitZero(e,"ts"),o=this.safeString(e,"change24h"),n=this.safeString(e,"open24"),d=this.safeString(e,"open");let h,c;return void 0===d?(h=this.safeSymbol(s,t,void 0,"contract"),c=n):(h=this.safeSymbol(s,t,void 0,"spot"),c=d),this.safeTicker({symbol:h,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bidPr"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPr"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:c,close:i,last:i,previousClose:void 0,change:o,percentage:a.Y.stringMul(o,"100"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();let s;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);const i={symbol:s.id};let r;if(s.spot)r=await this.publicSpotGetV2SpotMarketTickers(this.extend(i,t));else{let e;[e,t]=this.handleProductTypeAndParams(s,t),i.productType=e,r=await this.publicMixGetV2MixMarketTicker(this.extend(i,t))}const a=this.safeList(r,"data",[]);return this.parseTicker(a[0],s)}async fetchTickers(e=void 0,t={}){let s,i;if(await this.loadMarkets(),void 0!==e){const t=this.safeValue(e,0);if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);s=this.market(e)}else s=this.market(t)}const r={};let a;[a,t]=this.handleMarketTypeAndParams("fetchTickers",s,t);const o=this.safeString(t,"subType");let n;[n,t]=this.handleProductTypeAndParams(s,t),"spot"===a&&void 0===o?i=await this.publicSpotGetV2SpotMarketTickers(this.extend(r,t)):(r.productType=n,i=await this.publicMixGetV2MixMarketTickers(this.extend(r,t)));const d=this.safeList(i,"data",[]);return this.parseTickers(d,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeInteger2(e,"cTime","ts");let o;const n=this.safeValue(e,"feeDetail"),d=void 0!==this.safeString(e,"posMode")?n[0]:n;if(void 0!==d){o={currency:this.safeCurrencyCode(this.safeString(d,"feeCoin"))};const e=this.safeString(d,"totalFee"),t="yes"===this.safeString(d,"deduction");o.cost=t?e:a.Y.stringNeg(e)}return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),order:this.safeString(e,"orderId"),symbol:i,side:this.safeStringLower(e,"side"),type:this.safeString(e,"orderType"),takerOrMaker:this.safeString(e,"tradeScope"),price:this.safeString2(e,"priceAvg","price"),amount:this.safeString2(e,"baseVolume","size"),cost:this.safeString2(e,"quoteVolume","amount"),timestamp:r,datetime:this.iso8601(r),fee:o},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchTrades",e,t,s,i,"idLessThan","idLessThan");let a;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);a=this.market(t)}else a=this.market(e);let o={symbol:a.id};void 0!==s&&(a.contract?o.limit=Math.min(s,1e3):o.limit=s);const n=this.safeValue(this.options,"fetchTrades",{});let d;if(a.spot){const e=this.safeValue(n,"spot",{}),s=this.safeString(e,"method","publicSpotGetV2SpotMarketFillsHistory"),r=this.safeString(i,"method",s);i=this.omit(i,"method"),"publicSpotGetV2SpotMarketFillsHistory"===r?([o,i]=this.handleUntilOption("endTime",o,i),void 0!==t&&(o.startTime=t),d=await this.publicSpotGetV2SpotMarketFillsHistory(this.extend(o,i))):"publicSpotGetV2SpotMarketFills"===r&&(d=await this.publicSpotGetV2SpotMarketFills(this.extend(o,i)))}else{const e=this.safeValue(n,"swap",{}),s=this.safeString(e,"method","publicMixGetV2MixMarketFillsHistory"),r=this.safeString(i,"method",s);let h;i=this.omit(i,"method"),[h,i]=this.handleProductTypeAndParams(a,i),o.productType=h,"publicMixGetV2MixMarketFillsHistory"===r?([o,i]=this.handleUntilOption("endTime",o,i),void 0!==t&&(o.startTime=t),d=await this.publicMixGetV2MixMarketFillsHistory(this.extend(o,i))):"publicMixGetV2MixMarketFills"===r&&(d=await this.publicMixGetV2MixMarketFills(this.extend(o,i)))}const h=this.safeList(d,"data",[]);return this.parseTrades(h,a,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;[r,t]=this.handleMarginModeAndParams("fetchTradingFee",t),s.spot?i.businessType=void 0!==r?"margin":"spot":i.businessType="contract";const a=await this.privateCommonGetV2CommonTradeRate(this.extend(i,t)),o=this.safeValue(a,"data",{});return this.parseTradingFee(o,s)}async fetchTradingFees(e={}){let t,s,i;if(await this.loadMarkets(),[s,e]=this.handleMarginModeAndParams("fetchTradingFees",e),[i,e]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e),"spot"===i){const i=this.safeBool(e,"margin",!1);e=this.omit(e,"margin"),t=void 0!==s||i?await this.publicMarginGetV2MarginCurrencies(e):await this.publicSpotGetV2SpotPublicSymbols(e)}else{if("swap"!==i&&"future"!==i)throw new r.NotSupported(this.id+" does not support "+i+" market");{let s;[s,e]=this.handleProductTypeAndParams(void 0,e),e.productType=s,t=await this.publicMixGetV2MixMarketContracts(e)}}const a=this.safeValue(t,"data",[]),o={};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"symbol"),r=this.safeSymbol(s,void 0,void 0,i),n=this.market(r),d=this.parseTradingFee(t,n);o[r]=d}return o}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate"),percentage:void 0,tierBased:void 0}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,a,200);let n;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);n=this.market(t)}else n=this.market(e);const d=n.spot?"spot":"swap",h=this.options.timeframes[d],c=864e5,l=1e3*this.parseTimeframe(t),u={symbol:n.id,granularity:this.safeString(h,t,t)},p=this.safeInteger(a,"until"),f=void 0!==i,m=void 0!==s,g=void 0!==p;let v;a=this.omit(a,["until"]);const y=this.milliseconds(),w=this.safeDict(this.options,"fetchOHLCV",{}),b=this.safeDict(w,"maxDaysPerTimeframe",{}),S=y-this.safeInteger(b,t,30)*c;f?(i=Math.min(i,1e3),u.limit=i):i=100;const k=i*l;let O,T;m&&(O=s,u.startTime=s,g||(T=this.sum(O,k),u.endTime=T)),g&&(T=p,u.endTime=T,m||(O=T-k));const P=void 0!==O&&O<=S;if(P&&f&&(u.limit=Math.min(i,200)),n.spot)v=P?await this.publicSpotGetV2SpotMarketHistoryCandles(this.extend(u,a)):await this.publicSpotGetV2SpotMarketCandles(this.extend(u,a));else{const e=90;if(m)if(g){if(T-O>e*c)throw new r.BadRequest(this.id+" fetchOHLCV() between start and end must be less than "+e.toString()+" days")}else u.endTime=Math.min(T,this.sum(s,e*c));let t,i;[t,a]=this.handleParamString(a,"price"),[i,a]=this.handleProductTypeAndParams(n,a),u.productType=i;const o=this.extend(u,a);v="mark"===t?await this.publicMixGetV2MixMarketHistoryMarkCandles(o):"index"===t?await this.publicMixGetV2MixMarketHistoryIndexCandles(o):P?await this.publicMixGetV2MixMarketHistoryCandles(o):await this.publicMixGetV2MixMarketCandles(o)}if(""===v)return[];const I=this.safeList(v,"data",v);return this.parseOHLCVs(I,n,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const t={};let s,i,a;if([s,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[i,e]=this.handleMarginModeAndParams("fetchBalance",e),"swap"===s||"future"===s){let s;[s,e]=this.handleProductTypeAndParams(void 0,e),t.productType=s,a=await this.privateMixGetV2MixAccountAccounts(this.extend(t,e))}else if("isolated"===i)a=await this.privateMarginGetMarginV1IsolatedAccountAssets(this.extend(t,e));else if("cross"===i)a=await this.privateMarginGetMarginV1CrossAccountAssets(this.extend(t,e));else{if("spot"!==s)throw new r.NotSupported(this.id+" fetchBalance() does not support "+s+" accounts");a=await this.privateSpotGetV2SpotAccountAssets(this.extend(t,e))}const o=this.safeValue(a,"data",[]);return this.parseBalance(o)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.account(),o=this.safeString2(i,"marginCoin","coin"),n=this.safeCurrencyCode(o),d=this.safeString(i,"borrow");if(void 0!==d){const e=this.safeString(i,"interest");r.free=this.safeString(i,"transferable"),r.total=this.safeString(i,"totalAmount"),r.debt=a.Y.stringAdd(d,e)}else{const e=this.safeString(i,"available"),t=this.safeString(i,"maxTransferOut");if(void 0!==t)r.free=t,r.total=this.safeString(i,"accountEquity");else{r.free=e;const t=this.safeString(i,"frozen"),s=this.safeString(i,"locked");r.used=a.Y.stringAdd(t,s)}}t[n]=r}return this.safeBalance(t)}parseOrderStatus(e){return this.safeString({new:"open",init:"open",not_trigger:"open",partial_fill:"open",partially_fill:"open",partially_filled:"open",triggered:"closed",full_fill:"closed",filled:"closed",fail_trigger:"rejected",cancel:"canceled",cancelled:"canceled",canceled:"canceled",live:"open",fail_execute:"rejected",executed:"closed"},e,e)}parseOrder(e,t=void 0){if(void 0!==this.safeString(e,"errorMsg"))return this.safeOrder({info:e,id:this.safeString(e,"orderId"),clientOrderId:this.safeString2(e,"clientOrderId","clientOid"),status:"rejected"},t);let s="posSide"in e?"contract":"spot";void 0!==t&&(s=t.type);const i=this.safeString(e,"symbol");t=this.safeMarket(i,t,void 0,s);const r=this.safeInteger2(e,"cTime","ctime"),o=this.safeInteger(e,"uTime"),n=this.safeString2(e,"status","state");let d;const h=this.safeString(e,"fee");void 0!==h&&(d={cost:this.parseNumber(a.Y.stringNeg(h)),currency:t.settle});const c=this.safeValue(e,"feeDetail");if(void 0!==c){const e=JSON.parse(c),t=Object.values(e);let s;for(let e=0;e<t.length;e++){const i=t[e];if(void 0!==this.safeValue(i,"feeCoinCode")){s=i;break}}d={cost:this.parseNumber(a.Y.stringNeg(this.safeString(s,"totalFee"))),currency:this.safeCurrencyCode(this.safeString(s,"feeCoinCode"))}}let l,u,p=this.safeStringUpper(e,"force");"POST_ONLY"===p&&(l=!0,p="PO");const f=this.safeString(e,"reduceOnly");let m,g;void 0!==f&&(u="NO"!==f);let v,y;void 0!==this.safeString(e,"basePrice")?(m=this.safeString(e,"priceAvg"),g=this.safeString(e,"basePrice")):(m=this.safeString2(e,"price","executePrice"),g=this.safeString(e,"priceAvg"));const w=this.safeString(e,"baseSize");void 0!==w?(v=w,y=this.safeString(e,"size")):(v=this.safeString(e,"size"),y=this.safeString(e,"baseVolume"));let b=this.safeString(e,"side");return"hedge_mode"===this.safeString(e,"posMode")&&u&&(b="buy"===b?"sell":"buy"),this.safeOrder({info:e,id:this.safeString2(e,"orderId","data"),clientOrderId:this.safeString2(e,"clientOrderId","clientOid"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:o,lastUpdateTimestamp:o,symbol:t.symbol,type:this.safeString(e,"orderType"),side:b,price:m,amount:v,cost:this.safeString2(e,"quoteVolume","quoteSize"),average:g,filled:y,remaining:void 0,timeInForce:p,postOnly:l,reduceOnly:u,stopPrice:this.safeNumber(e,"triggerPrice"),triggerPrice:this.safeNumber(e,"triggerPrice"),takeProfitPrice:this.safeNumber2(e,"presetStopSurplusPrice","stopSurplusTriggerPrice"),stopLossPrice:this.safeNumber2(e,"presetStopLossPrice","stopLossTriggerPrice"),status:this.parseOrderStatus(n),fee:d,trades:void 0},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.handleMarginModeAndParams("createOrder",a)[0],d=this.safeValue2(a,"stopPrice","triggerPrice"),h=this.safeValue(a,"stopLossPrice"),c=this.safeValue(a,"takeProfitPrice"),l=void 0!==this.safeString2(a,"trailingPercent","callbackRatio"),u=void 0!==d,p=void 0!==h||void 0!==c,f=this.createOrderRequest(e,t,s,i,r,a);let m;m=o.spot?u?await this.privateSpotPostV2SpotTradePlacePlanOrder(f):"isolated"===n?await this.privateMarginPostV2MarginIsolatedPlaceOrder(f):"cross"===n?await this.privateMarginPostV2MarginCrossedPlaceOrder(f):await this.privateSpotPostV2SpotTradePlaceOrder(f):u||l?await this.privateMixPostV2MixOrderPlacePlanOrder(f):p?await this.privateMixPostV2MixOrderPlaceTpslOrder(f):await this.privateMixPostV2MixOrderPlaceOrder(f);const g=this.safeDict(m,"data",{});return this.parseOrder(g,o)}createOrderRequest(e,t,s,i,o=void 0,n={}){let d,h,c;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);d=this.market(t)}else d=this.market(e);[h,n]=this.handleMarketTypeAndParams("createOrder",d,n),[c,n]=this.handleMarginModeAndParams("createOrder",n);const l={symbol:d.id,orderType:t},u="market"===t,p=this.safeValue2(n,"stopPrice","triggerPrice"),f=this.safeValue(n,"stopLossPrice"),m=this.safeValue(n,"takeProfitPrice"),g=this.safeValue(n,"stopLoss"),v=this.safeValue(n,"takeProfit"),y=void 0!==p,w=void 0!==f,b=void 0!==m,S=void 0!==g,k=void 0!==v,O=w||b,T=S||k,P=this.safeString(n,"trailingTriggerPrice",this.numberToString(o)),I=this.safeString2(n,"trailingPercent","callbackRatio"),x=void 0!==I;if(this.sum(y,w,b,x)>1)throw new r.ExchangeError(this.id+" createOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent");"limit"===t&&(l.price=this.priceToPrecision(e,o));const A=this.safeString(n,"triggerType","mark_price"),M=this.safeBool(n,"reduceOnly",!1),C=this.safeString2(n,"clientOid","clientOrderId"),E=this.safeString2(n,"force","timeInForce");let _;[_,n]=this.handlePostOnly(u,"post_only"===E,n);const B=this.safeStringUpper(this.options,"defaultTimeInForce"),N=this.safeStringUpper(n,"timeInForce",B);if(_?l.force="post_only":"GTC"===N?l.force="GTC":"FOK"===N?l.force="FOK":"IOC"===N&&(l.force="IOC"),n=this.omit(n,["stopPrice","triggerType","stopLossPrice","takeProfitPrice","stopLoss","takeProfit","postOnly","reduceOnly","clientOrderId","trailingPercent","trailingTriggerPrice"]),"swap"===h||"future"===h){let t;if(l.marginCoin=d.settleId,l.size=this.amountToPrecision(e,i),[t,n]=this.handleProductTypeAndParams(d,n),l.productType=t,void 0!==C&&(l.clientOid=C),(y||O||x)&&(l.triggerType=A),x){if(!u)throw new r.BadRequest(this.id+" createOrder() bitget trailing orders must be market orders");if(void 0===P)throw new r.ArgumentsRequired(this.id+" createOrder() bitget trailing orders must have a trailingTriggerPrice param");l.planType="track_plan",l.triggerPrice=this.priceToPrecision(e,P),l.callbackRatio=I}else if(y){if(l.planType="normal_plan",l.triggerPrice=this.priceToPrecision(e,p),void 0!==o&&(l.executePrice=this.priceToPrecision(e,o)),S){const t=this.safeNumber2(g,"triggerPrice","stopPrice");l.stopLossTriggerPrice=this.priceToPrecision(e,t);const s=this.safeNumber(g,"price");l.stopLossExecutePrice=this.priceToPrecision(e,s);const i=this.safeString(g,"type","mark_price");l.stopLossTriggerType=i}if(k){const t=this.safeNumber2(v,"triggerPrice","stopPrice");l.stopSurplusTriggerPrice=this.priceToPrecision(e,t);const s=this.safeNumber(v,"price");l.stopSurplusExecutePrice=this.priceToPrecision(e,s);const i=this.safeString(v,"type","mark_price");l.stopSurplusTriggerType=i}}else if(O){if(!u)throw new r.ExchangeError(this.id+" createOrder() bitget stopLoss or takeProfit orders must be market orders");l.holdSide="buy"===s?"long":"short",w?(l.triggerPrice=this.priceToPrecision(e,f),l.planType="pos_loss"):b&&(l.triggerPrice=this.priceToPrecision(e,m),l.planType="pos_profit")}else{if(S){const t=this.safeValue2(g,"triggerPrice","stopPrice");l.presetStopLossPrice=this.priceToPrecision(e,t)}if(k){const t=this.safeValue2(v,"triggerPrice","stopPrice");l.presetStopSurplusPrice=this.priceToPrecision(e,t)}}if(!O){void 0===c&&(c="cross");const e="cross"===c?"crossed":"isolated";let t,i;l.marginMode=e,[t,n]=this.handleParamBool(n,"hedged",!1),[i,n]=this.handleParamBool(n,"oneWayMode"),void 0!==i&&(t=!i);let r=s;M?t?(r="buy"===s?"sell":"buy",l.tradeSide="Close"):l.reduceOnly="YES":t&&(l.tradeSide="Open"),l.side=r}}else{if("spot"!==h)throw new r.NotSupported(this.id+" createOrder() does not support "+h+" orders");{if(O||T)throw new r.InvalidOrder(this.id+" createOrder() does not support stop loss/take profit orders on spot markets, only swap markets");let t,d;l.side=s;let h=!0;if([h,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0),u&&"buy"===s){d="total";const s=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==s)t=this.costToPrecision(e,s);else if(h){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i)}else d="amount",t=this.amountToPrecision(e,i);void 0!==C&&(l.clientOid=C),void 0!==c?(l.loanType="normal",u&&"buy"===s?l.quoteSize=t:l.baseSize=t):(void 0!==t&&(l.size=t),void 0!==p&&(l.planType=d,l.triggerType=A,l.triggerPrice=this.priceToPrecision(e,p),void 0!==o&&(l.executePrice=this.priceToPrecision(e,o))))}}return this.extend(l,n)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i,a;for(let t=0;t<e.length;t++){const o=e[t],n=this.safeString(o,"symbol");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const d=this.safeString(o,"type"),h=this.safeString(o,"side"),c=this.safeValue(o,"amount"),l=this.safeValue(o,"price"),u=this.safeValue(o,"params",{}),p=this.handleMarginModeAndParams("createOrders",u)[0];if(void 0!==p)if(void 0===a)a=p;else if(a!==p)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same margin mode (isolated or cross)");const f=this.createOrderRequest(n,d,h,c,l,u);s.push(f)}let o;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(i);o=this.market(e)}else o=this.market(i);const n={symbol:o.id,orderList:s};let d;if(o.swap||o.future){void 0===a&&(a="cross");const e="cross"===a?"crossed":"isolated";let s;n.marginMode=e,n.marginCoin=o.settleId,[s,t]=this.handleProductTypeAndParams(o,t),n.productType=s,d=await this.privateMixPostV2MixOrderBatchPlaceOrder(n)}else d="isolated"===a?await this.privateMarginPostV2MarginIsolatedBatchPlaceOrder(n):"cross"===a?await this.privateMarginPostV2MarginCrossedBatchPlaceOrder(n):await this.privateSpotPostV2SpotTradeBatchOrders(n);const h=this.safeValue(d,"data",{}),c=this.safeValue(h,"failureList",[]),l=this.safeValue(h,"successList",[]),u=this.arrayConcat(l,c);return this.parseOrders(u,o)}async editOrder(e,t,s,i,o=void 0,n=void 0,d={}){await this.loadMarkets();let h;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);h=this.market(e)}else h=this.market(t);const c={orderId:e},l="market"===s,u=this.safeValue2(d,"stopPrice","triggerPrice"),p=void 0!==u,f=this.safeValue(d,"stopLossPrice"),m=void 0!==f,g=this.safeValue(d,"takeProfitPrice"),v=void 0!==g,y=this.safeValue(d,"stopLoss"),w=this.safeValue(d,"takeProfit"),b=void 0!==y,S=void 0!==w,k=this.safeString(d,"trailingTriggerPrice",this.numberToString(n)),O=this.safeString2(d,"trailingPercent","newCallbackRatio"),T=void 0!==O;if(this.sum(p,m,v,T)>1)throw new r.ExchangeError(this.id+" editOrder() params can only contain one of triggerPrice, stopLossPrice, takeProfitPrice, trailingPercent");const P=this.safeString2(d,"clientOid","clientOrderId");let I;if(void 0!==P&&(c.clientOid=P),d=this.omit(d,["stopPrice","triggerType","stopLossPrice","takeProfitPrice","stopLoss","takeProfit","clientOrderId","trailingTriggerPrice","trailingPercent"]),h.spot){if(void 0===u)throw new r.NotSupported(this.id+"editOrder() only supports plan/trigger spot orders");if(this.safeBool(this.options,"editMarketBuyOrderRequiresPrice",!0)&&l&&"buy"===i){if(void 0===n)throw new r.InvalidOrder(this.id+" editOrder() requires price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the editMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const e=this.numberToString(o),s=this.numberToString(n),i=this.parseNumber(a.Y.stringMul(e,s));c.size=this.priceToPrecision(t,i)}}else c.size=this.amountToPrecision(t,o);c.orderType=s,c.triggerPrice=this.priceToPrecision(t,u),c.executePrice=this.priceToPrecision(t,n),I=await this.privateSpotPostV2SpotTradeModifyPlanOrder(this.extend(c,d))}else{if(!h.swap&&!h.future)throw new r.NotSupported(this.id+" editOrder() does not support "+h.type+" orders");let e;if(c.symbol=h.id,[e,d]=this.handleProductTypeAndParams(h,d),c.productType=e,v||m||(c.newSize=this.amountToPrecision(t,o),void 0===n||T||(c.newPrice=this.priceToPrecision(t,n))),T){if(!l)throw new r.BadRequest(this.id+" editOrder() bitget trailing orders must be market orders");void 0!==k&&(c.newTriggerPrice=this.priceToPrecision(t,k)),c.newCallbackRatio=O,I=await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(c,d))}else if(v||m)c.marginCoin=h.settleId,c.size=this.amountToPrecision(t,o),c.executePrice=this.priceToPrecision(t,n),m?c.triggerPrice=this.priceToPrecision(t,f):v&&(c.triggerPrice=this.priceToPrecision(t,g)),I=await this.privateMixPostV2MixOrderModifyTpslOrder(this.extend(c,d));else if(p){if(c.newTriggerPrice=this.priceToPrecision(t,u),b){const e=this.safeNumber2(y,"triggerPrice","stopPrice");c.newStopLossTriggerPrice=this.priceToPrecision(t,e);const s=this.safeNumber(y,"price");c.newStopLossExecutePrice=this.priceToPrecision(t,s);const i=this.safeString(y,"type","mark_price");c.newStopLossTriggerType=i}if(S){const e=this.safeNumber2(w,"triggerPrice","stopPrice");c.newSurplusTriggerPrice=this.priceToPrecision(t,e);const s=this.safeNumber(w,"price");c.newStopSurplusExecutePrice=this.priceToPrecision(t,s);const i=this.safeString(w,"type","mark_price");c.newStopSurplusTriggerType=i}I=await this.privateMixPostV2MixOrderModifyPlanOrder(this.extend(c,d))}else{const e=this.uuid(),s=this.safeString2(d,"newClientOid","newClientOrderId",e);if(d=this.omit(d,"newClientOrderId"),c.newClientOid=s,b){const e=this.safeValue2(y,"triggerPrice","stopPrice");c.newPresetStopLossPrice=this.priceToPrecision(t,e)}if(S){const e=this.safeValue2(w,"triggerPrice","stopPrice");c.newPresetStopSurplusPrice=this.priceToPrecision(t,e)}I=await this.privateMixPostV2MixOrderModifyOrder(this.extend(c,d))}}const x=this.safeDict(I,"data",{});return this.parseOrder(x,h)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();let i,a,o;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);i=this.market(e)}else i=this.market(t);[a,s]=this.handleMarginModeAndParams("cancelOrder",s);const n={},d=this.safeValue(s,"trailing"),h=this.safeValue2(s,"stop","trigger");if(s=this.omit(s,["stop","trigger","trailing"]),i.spot&&h||(n.symbol=i.id),(i.swap||i.future)&&h||(n.orderId=e),i.swap||i.future){let t;if([t,s]=this.handleProductTypeAndParams(i,s),n.productType=t,h||d){const t=[],s={orderId:e};t.push(s),n.orderIdList=t}if(d){const e=this.safeString(s,"planType","track_plan");n.planType=e,o=await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(n,s))}else o=h?await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(n,s)):await this.privateMixPostV2MixOrderCancelOrder(this.extend(n,s))}else{if(!i.spot)throw new r.NotSupported(this.id+" cancelOrder() does not support "+i.type+" orders");void 0!==a?"isolated"===a?o=await this.privateMarginPostV2MarginIsolatedCancelOrder(this.extend(n,s)):"cross"===a&&(o=await this.privateMarginPostV2MarginCrossedCancelOrder(this.extend(n,s))):o=h?await this.privateSpotPostV2SpotTradeCancelPlanOrder(this.extend(n,s)):await this.privateSpotPostV2SpotTradeCancelOrder(this.extend(n,s))}const c=this.safeValue(o,"data",{});let l;if((i.swap||i.future)&&h){l=this.safeValue(c,"successList",[])[0]}else l=c;return this.parseOrder(l,i)}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();let i,a;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);i=this.market(e)}else i=this.market(t);[a,s]=this.handleMarginModeAndParams("cancelOrders",s);const o=this.safeValue2(s,"stop","trigger");s=this.omit(s,["stop","trigger"]);const n=[];for(let t=0;t<e.length;t++){const s={orderId:e[t]};n.push(s)}const d={symbol:i.id};let h;if(i.spot&&void 0===a?d.orderList=n:d.orderIdList=n,i.spot)h=void 0!==a?"cross"===a?await this.privateMarginPostV2MarginCrossedBatchCancelOrder(this.extend(d,s)):await this.privateMarginPostV2MarginIsolatedBatchCancelOrder(this.extend(d,s)):await this.privateSpotPostV2SpotTradeBatchCancelOrder(this.extend(d,s));else{let e;[e,s]=this.handleProductTypeAndParams(i,s),d.productType=e,h=o?await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(d,s)):await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(d,s))}const c=this.safeValue(h,"data",{}),l=this.safeList(c,"successList",[]);return this.parseOrders(l,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);[i,t]=this.handleMarginModeAndParams("cancelAllOrders",t);const a={symbol:s.id},o=this.safeBool2(t,"stop","trigger");let n;if(t=this.omit(t,["stop","trigger"]),s.spot){if(void 0===i){if(o){const e={symbolList:[s.id]};n=await this.privateSpotPostV2SpotTradeBatchCancelPlanOrder(this.extend(e,t))}else n=await this.privateSpotPostV2SpotTradeCancelSymbolOrder(this.extend(a,t));const e=this.safeInteger(n,"requestTime"),i=this.safeDict(n,"data"),r=this.safeString(i,"symbol");return[this.safeOrder({info:n,symbol:this.safeSymbol(r,void 0,void 0,"spot"),timestamp:e,datetime:this.iso8601(e)})]}n="cross"===i?await this.privateMarginPostMarginV1CrossOrderBatchCancelOrder(this.extend(a,t)):await this.privateMarginPostMarginV1IsolatedOrderBatchCancelOrder(this.extend(a,t))}else{let e;[e,t]=this.handleProductTypeAndParams(s,t),a.productType=e,n=o?await this.privateMixPostV2MixOrderCancelPlanOrder(this.extend(a,t)):await this.privateMixPostV2MixOrderBatchCancelOrders(this.extend(a,t))}const d=this.safeDict(n,"data"),h=this.safeList2(d,"resultList","successList"),c=this.safeList2(d,"failure","failureList"),l=this.arrayConcat(h,c);return this.parseOrders(l)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();let i;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);i=this.market(e)}else i=this.market(t);const a={orderId:e};let o;if(i.spot)o=await this.privateSpotGetV2SpotTradeOrderInfo(this.extend(a,s));else{if(!i.swap&&!i.future)throw new r.NotSupported(this.id+" fetchOrder() does not support "+i.type+" orders");{let e;a.symbol=i.id,[e,s]=this.handleProductTypeAndParams(i,s),a.productType=e,o=await this.privateMixGetV2MixOrderDetail(this.extend(a,s))}}"string"==typeof o&&(o=JSON.parse(o));const n=this.safeDict(o,"data");if(void 0!==n&&!Array.isArray(n))return this.parseOrder(n,i);const d=this.safeList(o,"data",[]),h=this.safeDict(d,0,{});return this.parseOrder(h,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool(this.options,"sandboxMode",!1);let a,o,n,d={};if([n,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),void 0!==e){if(r){const t=this.convertSymbolForSandbox(e);a=this.market(t)}else a=this.market(e);d.symbol=a.id;const t=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot"),s="type"in a?a.type:t;o=this.safeString(i,"type",s)}else{const e=this.safeString2(this.options,"fetchOpenOrders","defaultType","spot");o=this.safeString(i,"type",e)}let h,c=!1;if([c,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),c){let r;return"spot"===o?void 0!==n&&(r="minId"):r="endId",await this.fetchPaginatedCallCursor("fetchOpenOrders",e,t,s,i,r,"idLessThan")}const l=this.safeBool(i,"trailing"),u=this.safeBool2(i,"stop","trigger"),p=void 0!==this.safeString(i,"planType"),f=u||p;if(i=this.omit(i,["stop","trigger","trailing"]),[d,i]=this.handleUntilOption("endTime",d,i),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s),"swap"===o||"future"===o||void 0!==n){const e=this.safeString2(i,"clientOid","clientOrderId");i=this.omit(i,"clientOrderId"),void 0!==e&&(d.clientOid=e)}let m;if(m=this.omit(i,["type"]),"spot"===o)void 0!==n?(void 0===t&&(t=this.milliseconds()-7776e6,d.startTime=t),"isolated"===n?h=await this.privateMarginGetV2MarginIsolatedOpenOrders(this.extend(d,m)):"cross"===n&&(h=await this.privateMarginGetV2MarginCrossedOpenOrders(this.extend(d,m)))):h=u?await this.privateSpotGetV2SpotTradeCurrentPlanOrder(this.extend(d,m)):await this.privateSpotGetV2SpotTradeUnfilledOrders(this.extend(d,m));else{let e;if([e,m]=this.handleProductTypeAndParams(a,m),d.productType=e,l){const e=this.safeString(i,"planType","track_plan");d.planType=e,h=await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(d,m))}else if(f){const e=this.safeString(m,"planType","normal_plan");d.planType=e,h=await this.privateMixGetV2MixOrderOrdersPlanPending(this.extend(d,m))}else h=await this.privateMixGetV2MixOrderOrdersPending(this.extend(d,m))}const g=this.safeValue(h,"data");if("spot"!==o){const e=this.safeList(g,"entrustedList",[]);return this.parseOrders(e,a,t,s)}if(void 0!==n||u){const e=this.safeList(g,"orderList",[]);return this.parseOrders(e,a,t,s)}return this.parseOrders(g,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.fetchCanceledAndClosedOrders(e,t,s,i);return this.filterBy(r,"status","closed")}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.fetchCanceledAndClosedOrders(e,t,s,i);return this.filterBy(r,"status","canceled")}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a;if(this.safeBool(this.options,"sandboxMode",!1)&&void 0!==e){e=this.convertSymbolForSandbox(e)}let o,n,d={};void 0!==e&&(a=this.market(e),d.symbol=a.id),[o,i]=this.handleMarketTypeAndParams("fetchCanceledAndClosedOrders",a,i),[n,i]=this.handleMarginModeAndParams("fetchCanceledAndClosedOrders",i);let h,c=!1;if([c,i]=this.handleOptionAndParams(i,"fetchCanceledAndClosedOrders","paginate"),c){let r;return"spot"===o?void 0!==n&&(r="minId"):r="endId",await this.fetchPaginatedCallCursor("fetchCanceledAndClosedOrders",e,t,s,i,r,"idLessThan")}const l=this.safeValue(i,"trailing"),u=this.safeBool2(i,"stop","trigger");if(i=this.omit(i,["stop","trigger","trailing"]),[d,i]=this.handleUntilOption("endTime",d,i),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s),"swap"===o||"future"===o||void 0!==n){const e=this.safeString2(i,"clientOid","clientOrderId");i=this.omit(i,"clientOrderId"),void 0!==e&&(d.clientOid=e)}const p=this.milliseconds();if("spot"===o)if(void 0!==n)void 0===t&&(t=p-7776e6,d.startTime=t),"isolated"===n?h=await this.privateMarginGetV2MarginIsolatedHistoryOrders(this.extend(d,i)):"cross"===n&&(h=await this.privateMarginGetV2MarginCrossedHistoryOrders(this.extend(d,i)));else if(u){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchCanceledAndClosedOrders() requires a symbol argument");const s=this.safeIntegerN(i,["endTime","until"]);i=this.omit(i,["until"]),void 0===t&&(t=p-7776e6,d.startTime=t),void 0===s&&(d.endTime=p),h=await this.privateSpotGetV2SpotTradeHistoryPlanOrder(this.extend(d,i))}else h=await this.privateSpotGetV2SpotTradeHistoryOrders(this.extend(d,i));else{let e;if([e,i]=this.handleProductTypeAndParams(a,i),d.productType=e,l){const e=this.safeString(i,"planType","track_plan");d.planType=e,h=await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(d,i))}else if(u){const e=this.safeString(i,"planType","normal_plan");d.planType=e,h=await this.privateMixGetV2MixOrderOrdersPlanHistory(this.extend(d,i))}else h=await this.privateMixGetV2MixOrderOrdersHistory(this.extend(d,i))}const f=this.safeValue(h,"data",{});if("spot"!==o)return this.parseOrders(this.safeValue(f,"entrustedList",[]),a,t,s);if(void 0!==n||u)return this.parseOrders(this.safeValue(f,"orderList",[]),a,t,s);"string"==typeof h&&(h=JSON.parse(h));const m=this.safeList(h,"data",[]);return this.parseOrders(m,a,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeString(i,"symbol");let a,o;if(i=this.omit(i,"symbol"),void 0!==r){if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(r);a=this.market(e)}else a=this.market(r)}[o,i]=this.handleMarketTypeAndParams("fetchLedger",a,i);let n,d=!1;if([d,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),d){let e;return"spot"!==o&&(e="endId"),await this.fetchPaginatedCallCursor("fetchLedger",r,t,s,i,e,"idLessThan")}let h,c={};if(void 0!==e&&(n=this.currency(e),c.coin=n.id),[c,i]=this.handleUntilOption("endTime",c,i),void 0!==t&&(c.startTime=t),void 0!==s&&(c.limit=s),"spot"===o)h=await this.privateSpotGetV2SpotAccountBills(this.extend(c,i));else{let e;void 0!==r&&(c.symbol=a.id),[e,i]=this.handleProductTypeAndParams(a,i),c.productType=e,h=await this.privateMixGetV2MixAccountBill(this.extend(c,i))}const l=this.safeValue(h,"data");if("swap"===o||"future"===o){const e=this.safeValue(l,"bills",[]);return this.parseLedger(e,n,t,s)}return this.parseLedger(l,n,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),r=this.safeInteger(e,"cTime"),o=this.safeNumber(e,"balance"),n=this.safeNumber2(e,"fees","fee"),d=this.safeString2(e,"size","amount"),h=this.parseNumber(a.Y.stringAbs(d));let c="in";return d.indexOf("-")>=0&&(c="out"),{info:e,id:this.safeString(e,"billId"),timestamp:r,datetime:this.iso8601(r),direction:c,account:void 0,referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerType(this.safeString(e,"businessType")),currency:i,amount:h,before:void 0,after:o,status:void 0,fee:n}}parseLedgerType(e){return this.safeString({trans_to_cross:"transfer",trans_from_cross:"transfer",trans_to_exchange:"transfer",trans_from_exchange:"transfer",trans_to_isolated:"transfer",trans_from_isolated:"transfer",trans_to_contract:"transfer",trans_from_contract:"transfer",trans_to_otc:"transfer",trans_from_otc:"transfer",open_long:"trade",close_long:"trade",open_short:"trade",close_short:"trade",force_close_long:"trade",force_close_short:"trade",burst_long_loss_query:"trade",burst_short_loss_query:"trade",force_buy:"trade",force_sell:"trade",burst_buy:"trade",burst_sell:"trade",delivery_long:"settlement",delivery_short:"settlement",contract_settle_fee:"fee",append_margin:"transaction",adjust_down_lever_append_margin:"transaction",reduce_margin:"transaction",auto_append_margin:"transaction",cash_gift_issue:"cashback",cash_gift_recycle:"cashback",bonus_issue:"rebate",bonus_recycle:"rebate",bonus_expired:"rebate",transfer_in:"transfer",transfer_out:"transfer",deposit:"deposit",withdraw:"withdrawal",buy:"trade",sell:"trade"},e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let a,o;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);a=this.market(t)}else a=this.market(e);[o,i]=this.handleMarginModeAndParams("fetchMyTrades",i);let n,d=!1;if([d,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),d){let r;return a.spot?void 0!==o&&(r="minId"):r="endId",await this.fetchPaginatedCallCursor("fetchMyTrades",e,t,s,i,r,"idLessThan")}let h={symbol:a.id};if([h,i]=this.handleUntilOption("endTime",h,i),void 0!==t&&(h.startTime=t),void 0!==s&&(h.limit=s),a.spot)void 0!==o?(void 0===t&&(h.startTime=this.milliseconds()-7776e6),"isolated"===o?n=await this.privateMarginGetV2MarginIsolatedFills(this.extend(h,i)):"cross"===o&&(n=await this.privateMarginGetV2MarginCrossedFills(this.extend(h,i)))):n=await this.privateSpotGetV2SpotTradeFills(this.extend(h,i));else{let e;[e,i]=this.handleProductTypeAndParams(a,i),h.productType=e,n=await this.privateMixGetV2MixOrderFills(this.extend(h,i))}const c=this.safeValue(n,"data");if(a.swap||a.future){const e=this.safeList(c,"fillList",[]);return this.parseTrades(e,a,t,s)}if(void 0!==o){const e=this.safeList(c,"fills",[]);return this.parseTrades(e,a,t,s)}return this.parseTrades(c,a,t,s)}async fetchPosition(e,t={}){await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);[i,t]=this.handleProductTypeAndParams(s,t);const r={symbol:s.id,marginCoin:s.settleId,productType:i},a=await this.privateMixGetV2MixPositionSinglePosition(this.extend(r,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parsePosition(n,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s,i=!1;if([i,t]=this.handleOptionAndParams(t,"fetchPositions","paginate"),i)return await this.fetchPaginatedCallCursor("fetchPositions",void 0,void 0,void 0,t,"endId","idLessThan");let a,o;if(this.safeBool(t,"useHistoryEndpoint",!1)?s="privateMixGetV2MixPositionHistoryPosition":[s,t]=this.handleOptionAndParams(t,"fetchPositions","method","privateMixGetV2MixPositionAllPosition"),void 0!==e){const t=this.safeString(e,0);if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);a=this.market(e)}else a=this.market(t)}[o,t]=this.handleProductTypeAndParams(a,t);const n={productType:o};let d,h=!1;if("privateMixGetV2MixPositionAllPosition"===s){let s=this.safeString(t,"marginCoin","USDT");if(void 0!==e)s=a.settleId;else if("USDT-FUTURES"===o)s="USDT";else if("USDC-FUTURES"===o)s="USDC";else if("SUSDT-FUTURES"===o)s="SUSDT";else if("SUSDC-FUTURES"===o)s="SUSDC";else if(("SCOIN-FUTURES"===o||"COIN-FUTURES"===o)&&void 0===s)throw new r.ArgumentsRequired(this.id+" fetchPositions() requires a marginCoin parameter that matches the productType");n.marginCoin=s,d=await this.privateMixGetV2MixPositionAllPosition(this.extend(n,t))}else h=!0,void 0!==a&&(n.symbol=a.id),d=await this.privateMixGetV2MixPositionHistoryPosition(this.extend(n,t));let c=[];if(h){const e=this.safeDict(d,"data",{});c=this.safeList(e,"list",[])}else c=this.safeList(d,"data",[]);const l=[];for(let e=0;e<c.length;e++)l.push(this.parsePosition(c[e],a));return e=this.marketSymbols(e),this.filterByArrayPositions(l,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t,void 0,"contract")).symbol,r=this.safeInteger2(e,"cTime","ctime");let o,n,d=this.safeString(e,"marginMode");const h=this.safeString(e,"unrealizedPL"),c=this.safeString(e,"marginSize");"isolated"===d?o=a.Y.stringAdd(c,h):"crossed"===d&&(d="cross",n=c);const l=this.safeString(e,"posMode");let u;"hedge_mode"===l?u=!0:"one_way_mode"===l&&(u=!1);const p=this.safeString(e,"holdSide"),f=this.safeString(e,"leverage"),m=this.safeValue(t,"contractSize"),g=this.numberToString(m),v=this.safeString(e,"total"),y=this.safeString2(e,"openPriceAvg","openAvgPrice"),w=this.safeString(e,"keepMarginRate"),b=a.Y.stringMul(y,v);void 0===n&&(n=a.Y.stringDiv(b,f));let S=this.parseNumber(a.Y.stringDiv(v,g));void 0===S&&(S=this.safeNumber(e,"closeTotalPos"));const k=this.safeString(e,"markPrice"),O=a.Y.stringMul(v,k),T=a.Y.stringDiv(n,O);let P=this.parseNumber(this.omitZero(this.safeString(e,"liquidationPrice")));const I="0.9994";if(void 0===P&&"isolated"===d&&a.Y.stringGt(v,"0")){let e=a.Y.stringDiv(c,v),t=w;"short"===p&&(e=a.Y.stringNeg(e),t=a.Y.stringNeg(t));let s=a.Y.stringSub("1",t),i=a.Y.stringSub(y,e);"long"===p?s=a.Y.stringMul(s,I):i=a.Y.stringMul(i,I),P=this.parseNumber(a.Y.stringDiv(i,s))}const x=a.Y.stringMul(O,"0.0006"),A=a.Y.stringAdd(a.Y.stringMul(w,O),x),M=a.Y.stringMul(a.Y.stringDiv(h,n,4),"100");return this.safePosition({info:e,id:this.safeString(e,"orderId"),symbol:i,notional:this.parseNumber(O),marginMode:d,liquidationPrice:P,entryPrice:this.parseNumber(y),unrealizedPnl:this.parseNumber(h),realizedPnl:this.safeNumber(e,"pnl"),percentage:this.parseNumber(M),contracts:S,contractSize:m,markPrice:this.parseNumber(k),lastPrice:this.safeNumber(e,"closeAvgPrice"),side:p,hedged:u,timestamp:r,datetime:this.iso8601(r),lastUpdateTimestamp:this.safeInteger(e,"utime"),maintenanceMargin:this.parseNumber(A),maintenanceMarginPercentage:this.parseNumber(w),collateral:this.parseNumber(o),initialMargin:this.parseNumber(n),initialMarginPercentage:this.parseNumber(T),leverage:this.parseNumber(f),marginRatio:this.safeNumber(e,"marginRatio"),stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory",e,t,s,i,"pageNo",100);let o,n;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);o=this.market(t)}else o=this.market(e);[n,i]=this.handleProductTypeAndParams(o,i);const d={symbol:o.id,productType:n};void 0!==s&&(d.pageSize=s);const h=await this.publicMixGetV2MixMarketHistoryFundRate(this.extend(d,i)),c=this.safeValue(h,"data",[]),l=[];for(let e=0;e<c.length;e++){const t=c[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s,o),r=this.safeInteger(t,"fundingTime");l.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:r,datetime:this.iso8601(r)})}const u=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(u,o.symbol,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");[i,t]=this.handleProductTypeAndParams(s,t);const a={symbol:s.id,productType:i},o=await this.publicMixGetV2MixMarketCurrentFundRate(this.extend(a,t)),n=this.safeValue(o,"data",[]);return this.parseFundingRate(n[0],s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingHistory","paginate"),a)return await this.fetchPaginatedCallCursor("fetchFundingHistory",e,t,s,i,"endId","idLessThan");let o,n;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);o=this.market(t)}else o=this.market(e);if(!o.swap)throw new r.BadSymbol(this.id+" fetchFundingHistory() supports swap contracts only");[n,i]=this.handleProductTypeAndParams(o,i);let d={symbol:o.id,marginCoin:o.settleId,businessType:"contract_settle_fee",productType:n};[d,i]=this.handleUntilOption("endTime",d,i),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s);const h=await this.privateMixGetV2MixAccountBill(this.extend(d,i)),c=this.safeValue(h,"data",{}),l=this.safeValue(c,"bills",[]);return this.parseFundingHistories(l,o,t,s)}parseFundingHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"coin"),r=this.safeInteger(e,"cTime");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),timestamp:r,datetime:this.iso8601(r),code:this.safeCurrencyCode(i),amount:this.safeNumber(e,"amount"),id:this.safeString(e,"billId")}}parseFundingHistories(e,t=void 0,s=void 0,i=void 0){const r=[];for(let s=0;s<e.length;s++){const i=e[s];"contract_settle_fee"===this.safeString(i,"businessType")&&r.push(this.parseFundingHistory(i,t))}const a=this.sortBy(r,"timestamp");return this.filterBySinceLimit(a,s,i)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.safeString(i,"holdSide");let a,o;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);a=this.market(t)}else a=this.market(e);[o,i]=this.handleProductTypeAndParams(a,i);const n={symbol:a.id,marginCoin:a.settleId,amount:this.amountToPrecision(e,t),holdSide:r,productType:o};i=this.omit(i,"holdSide");const d=await this.privateMixPostV2MixAccountSetMargin(this.extend(n,i));return this.extend(this.parseMarginModification(d,a),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s="00000"===this.safeString(e,"code")?"ok":"failed";return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:t.settle,status:s,timestamp:void 0,datetime:void 0}}async reduceMargin(e,t,s={}){if(t>0)throw new r.BadRequest(this.id+" reduceMargin() amount parameter must be a negative value");if(void 0===this.safeString(s,"holdSide"))throw new r.ArgumentsRequired(this.id+" reduceMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){if(void 0===this.safeString(s,"holdSide"))throw new r.ArgumentsRequired(this.id+" addMargin() requires a holdSide parameter, either long or short");return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);[i,t]=this.handleProductTypeAndParams(s,t);const r={symbol:s.id,marginCoin:s.settleId,productType:i},a=await this.privateMixGetV2MixAccountAccount(this.extend(r,t)),o=this.safeDict(a,"data",{});return this.parseLeverage(o,s)}parseLeverage(e,t=void 0){return{info:e,symbol:t.symbol,marginMode:"isolated",longLeverage:this.safeInteger(e,"isolatedLongLever"),shortLeverage:this.safeInteger(e,"isolatedShortLever")}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();let i,a;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);i=this.market(e)}else i=this.market(t);[a,s]=this.handleProductTypeAndParams(i,s);const o={symbol:i.id,marginCoin:i.settleId,leverage:this.numberToString(e),productType:a};return await this.privateMixPostV2MixAccountSetLeverage(this.extend(o,s))}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("cross"===(e=e.toLowerCase())&&(e="crossed"),"isolated"!==e&&"crossed"!==e)throw new r.ArgumentsRequired(this.id+" setMarginMode() marginMode must be either isolated or crossed (cross)");await this.loadMarkets();let i,a;if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);i=this.market(e)}else i=this.market(t);[a,s]=this.handleProductTypeAndParams(i,s);const o={symbol:i.id,marginCoin:i.settleId,marginMode:e,productType:a};return await this.privateMixPostV2MixAccountSetMarginMode(this.extend(o,s))}async setPositionMode(e,t=void 0,s={}){await this.loadMarkets();const i=e?"hedge_mode":"one_way_mode";let r,a;if(void 0!==t){if(this.safeBool(this.options,"sandboxMode",!1)){const e=this.convertSymbolForSandbox(t);r=this.market(e)}else r=this.market(t)}[a,s]=this.handleProductTypeAndParams(r,s);const o={posMode:i,productType:a};return await this.privateMixPostV2MixAccountSetPositionMode(this.extend(o,s))}async fetchOpenInterest(e,t={}){await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");[i,t]=this.handleProductTypeAndParams(s,t);const a={symbol:s.id,productType:i},o=await this.publicMixGetV2MixMarketOpenInterest(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseOpenInterest(n,s)}parseOpenInterest(e,t=void 0){const s=this.safeValue(e,"openInterestList",[]),i=this.safeInteger(e,"ts"),r=this.safeString(s[0],"symbol");return this.safeOpenInterest({symbol:this.safeSymbol(r,t,void 0,"contract"),openInterestAmount:this.safeNumber(s[0],"size"),openInterestValue:void 0,timestamp:i,datetime:this.iso8601(i),info:e},t)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTransfers() requires a code argument");let a;await this.loadMarkets(),[a,i]=this.handleMarketTypeAndParams("fetchTransfers",void 0,i);const o=this.safeString(i,"fromAccount",a);i=this.omit(i,"fromAccount");const n=this.safeValue(this.options,"accountsByType",{});a=this.safeString(n,o);const d=this.currency(e);let h={coin:d.id,fromType:a};void 0!==t&&(h.startTime=t),void 0!==s&&(h.limit=s),[h,i]=this.handleUntilOption("endTime",h,i);const c=await this.privateSpotGetV2SpotAccountTransferRecords(this.extend(h,i)),l=this.safeList(c,"data",[]);return this.parseTransfers(l,d,t,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n={fromType:this.safeString(o,s),toType:this.safeString(o,i),amount:t,coin:a.id},d=this.safeString(r,"symbol");let h;r=this.omit(r,"symbol"),void 0!==d&&(h=this.market(d),n.symbol=h.id);const c=await this.privateSpotPostV2SpotWalletTransfer(this.extend(n,r)),l=this.safeValue(c,"data",{});return l.ts=this.safeInteger(c,"requestTime"),this.parseTransfer(l,a)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeStringLower(e,"status"),r=this.safeString(e,"coin"),a=this.safeString(e,"fromType"),o=this.safeValue(this.options,"accountsById",{}),n=this.safeString(o,a,a),d=this.safeString(e,"toType"),h=this.safeString(o,d,d);return{info:e,id:this.safeString(e,"transferId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(r,t),amount:this.safeNumber(e,"size"),fromAccount:n,toAccount:h,status:this.parseTransferStatus(i)}}parseTransferStatus(e){return this.safeString({successful:"ok"},e,e)}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"chains",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};for(let e=0;e<i;e++){const a=s[e],o=this.safeString(a,"chain"),n=this.safeString(t,"code"),d=this.networkIdToCode(o,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(a,"withdrawFee"),percentage:!1}},1===i&&(r.withdraw.fee=this.safeNumber(a,"withdrawFee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSpotGetV2SpotPublicCoins(t),i=this.safeList(s,"data",[]);return this.parseDepositWithdrawFees(i,e,"coin")}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={coin:i.id,borrowAmount:this.currencyToPrecision(e,t)},a=await this.privateMarginPostV2MarginCrossedAccountBorrow(this.extend(r,s)),o=this.safeValue(a,"data",{});return this.parseMarginLoan(o,i)}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=this.market(e),o={coin:r.id,borrowAmount:this.currencyToPrecision(t,s),symbol:a.id},n=await this.privateMarginPostV2MarginIsolatedAccountBorrow(this.extend(o,i)),d=this.safeValue(n,"data",{});return this.parseMarginLoan(d,r,a)}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=this.market(e),o={coin:r.id,repayAmount:this.currencyToPrecision(t,s),symbol:a.id},n=await this.privateMarginPostV2MarginIsolatedAccountRepay(this.extend(o,i)),d=this.safeValue(n,"data",{});return this.parseMarginLoan(d,r,a)}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={coin:i.id,repayAmount:this.currencyToPrecision(e,t)},a=await this.privateMarginPostV2MarginCrossedAccountRepay(this.extend(r,s)),o=this.safeValue(a,"data",{});return this.parseMarginLoan(o,i)}parseMarginLoan(e,t=void 0,s=void 0){const i=this.safeString(e,"coin"),r=this.safeString(e,"symbol");let a;return void 0!==r&&(a=this.safeSymbol(r,s,void 0,"spot")),{id:this.safeString2(e,"loanId","repayId"),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber2(e,"borrowAmount","repayAmount"),symbol:a,timestamp:void 0,datetime:void 0,info:e}}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a,o,n=!1;if([n,i]=this.handleOptionAndParams(i,"fetchMyLiquidations","paginate"),n)return await this.fetchPaginatedCallCursor("fetchMyLiquidations",e,t,s,i,"minId","idLessThan");if(void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchMyLiquidations",a,i),"spot"!==o)throw new r.NotSupported(this.id+" fetchMyLiquidations() supports spot margin markets only");let d,h,c={};if([c,i]=this.handleUntilOption("endTime",c,i),c.startTime=void 0!==t?t:this.milliseconds()-7776e6,void 0!==s&&(c.limit=s),[h,i]=this.handleMarginModeAndParams("fetchMyLiquidations",i,"cross"),"isolated"===h){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyLiquidations() requires a symbol argument");c.symbol=a.id,d=await this.privateMarginGetV2MarginIsolatedLiquidationHistory(this.extend(c,i))}else"cross"===h&&(d=await this.privateMarginGetV2MarginCrossedLiquidationHistory(this.extend(c,i)));const l=this.safeValue(d,"data",{}),u=this.safeList(l,"resultList",[]);return this.parseLiquidations(u,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"liqEndTime"),r=this.safeString2(e,"LiqFee","liqFee"),o=this.safeString(e,"totalDebt"),n=a.Y.stringAdd(r,o);return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:void 0,contractSize:void 0,price:void 0,baseValue:void 0,quoteValue:this.parseNumber(n),timestamp:i,datetime:this.iso8601(i)})}async fetchIsolatedBorrowRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateMarginGetV2MarginIsolatedInterestRateAndLimit(this.extend(i,t)),a=this.safeInteger(r,"requestTime"),o=this.safeValue(r,"data",[]),n=this.safeValue(o,0,{});return n.timestamp=a,this.parseIsolatedBorrowRate(n,s)}parseIsolatedBorrowRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,void 0,"spot"),r=this.safeString(e,"baseCoin"),a=this.safeString(e,"quoteCoin"),o=this.safeInteger(e,"timestamp");return{symbol:i,base:this.safeCurrencyCode(r),baseRate:this.safeNumber(e,"baseDailyInterestRate"),quote:this.safeCurrencyCode(a),quoteRate:this.safeNumber(e,"quoteDailyInterestRate"),period:864e5,timestamp:o,datetime:this.iso8601(o),info:e}}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},r=await this.privateMarginGetV2MarginCrossedInterestRateAndLimit(this.extend(i,t)),a=this.safeInteger(r,"requestTime"),o=this.safeValue(r,"data",[]),n=this.safeValue(o,0,{});return n.timestamp=a,this.parseBorrowRate(n,s)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeInteger(e,"timestamp");return{currency:this.safeCurrencyCode(s,t),rate:this.safeNumber(e,"dailyInterestRate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();let o,n=!1;if([n,a]=this.handleOptionAndParams(a,"fetchBorrowInterest","paginate"),n)return await this.fetchPaginatedCallCursor("fetchBorrowInterest",t,s,i,a,"minId","idLessThan");void 0!==t&&(o=this.market(t));const d={};let h,c,l;if(void 0!==e&&(h=this.currency(e),d.coin=h.id),d.startTime=void 0!==s?s:this.milliseconds()-7776e6,void 0!==i&&(d.limit=i),[l,a]=this.handleMarginModeAndParams("fetchBorrowInterest",a,"cross"),"isolated"===l){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchBorrowInterest() requires a symbol argument");d.symbol=o.id,c=await this.privateMarginGetV2MarginIsolatedInterestHistory(this.extend(d,a))}else"cross"===l&&(c=await this.privateMarginGetV2MarginCrossedInterestHistory(this.extend(d,a)));const u=this.safeValue(c,"data",{}),p=this.safeValue(u,"resultList",[]),f=this.parseBorrowInterests(p,o);return this.filterByCurrencySinceLimit(f,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=void 0!==s?"isolated":"cross",r=this.safeInteger(e,"cTime");return{symbol:this.safeString(t,"symbol"),marginMode:i,currency:this.safeCurrencyCode(this.safeString(e,"interestCoin")),interest:this.safeNumber(e,"interestAmount"),interestRate:this.safeNumber(e,"dailyInterestRate"),amountBorrowed:void 0,timestamp:r,datetime:this.iso8601(r),info:e}}async closePosition(e,t=void 0,s={}){await this.loadMarkets();let i,r;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);i=this.market(t)}else i=this.market(e);[r,s]=this.handleProductTypeAndParams(i,s);const a={symbol:i.id,productType:r};void 0!==t&&(a.holdSide=t);const o=await this.privateMixPostV2MixOrderClosePositions(this.extend(a,s)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"successList",[]);return this.parseOrder(d[0],i)}async closeAllPositions(e={}){let t;await this.loadMarkets(),[t,e]=this.handleProductTypeAndParams(void 0,e);const s={productType:t},i=await this.privateMixPostV2MixOrderClosePositions(this.extend(s,e)),r=this.safeValue(i,"data",{}),a=this.safeList(r,"successList",[]);return this.parsePositions(a,void 0,e)}async fetchMarginMode(e,t={}){await this.loadMarkets();let s,i;if(this.safeBool(this.options,"sandboxMode",!1)){const t=this.convertSymbolForSandbox(e);s=this.market(t)}else s=this.market(e);[i,t]=this.handleProductTypeAndParams(s,t);const r={symbol:s.id,marginCoin:s.settleId,productType:i},a=await this.privateMixGetV2MixAccountAccount(this.extend(r,t)),o=this.safeDict(a,"data",{});return this.parseMarginMode(o,s)}parseMarginMode(e,t=void 0){let s=this.safeString(e,"marginMode");return s="crossed"===s?"cross":s,{info:e,symbol:t.symbol,marginMode:s}}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeInteger(i,"until");i=this.omit(i,"until");const a={};if(void 0!==e){if(e.length>0){const t=this.market(e[0]);a.symbol=t.id}}void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s),void 0!==r&&(a.endTime=r);const o=await this.privateMixGetV2MixPositionHistoryPosition(this.extend(a,i)),n=this.safeDict(o,"data"),d=this.safeList(n,"list"),h=this.parsePositions(d,e,i);return this.filterBySinceLimit(h,t,s)}async fetchConvertQuote(e,t,s=void 0,i={}){await this.loadMarkets();const r={fromCoin:e,toCoin:t,fromCoinSize:this.numberToString(s)},a=await this.privateConvertGetV2ConvertQuotedPrice(this.extend(r,i)),o=this.safeDict(a,"data",{}),n=this.safeString(o,"fromCoin",e),d=this.currency(n),h=this.safeString(o,"toCoin",t),c=this.currency(h);return this.parseConversion(o,d,c)}async createConvertTrade(e,t,s,i=void 0,a={}){await this.loadMarkets();const o=this.safeString2(a,"price","cnvtPrice");if(void 0===o)throw new r.ArgumentsRequired(this.id+" createConvertTrade() requires a price parameter");const n=this.safeString2(a,"toAmount","toCoinSize");if(void 0===n)throw new r.ArgumentsRequired(this.id+" createConvertTrade() requires a toAmount parameter");a=this.omit(a,["price","toAmount"]);const d={traceId:e,fromCoin:t,toCoin:s,fromCoinSize:this.numberToString(i),toCoinSize:n,cnvtPrice:o},h=await this.privateConvertPostV2ConvertTrade(this.extend(d,a)),c=this.safeDict(h,"data",{}),l=this.safeString(c,"toCoin",s),u=this.currency(l);return this.parseConversion(c,void 0,u)}async fetchConvertTradeHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={},a=this.milliseconds();r.startTime=void 0!==t?t:a-864e5;const o=this.safeString2(i,"endTime","until");r.endTime=void 0!==o?o:a,void 0!==s&&(r.limit=s),i=this.omit(i,"until");const n=await this.privateConvertGetV2ConvertConvertRecord(this.extend(r,i)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"dataList",[]);return this.parseConversions(h,e,"fromCoin","toCoin",t,s)}parseConversion(e,t=void 0,s=void 0){const i=this.safeInteger(e,"ts"),r=this.safeString(e,"fromCoin"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"toCoin"),n=this.safeCurrencyCode(o,s);return{info:e,timestamp:i,datetime:this.iso8601(i),id:this.safeString2(e,"id","traceId"),fromCurrency:a,fromAmount:this.safeNumber(e,"fromCoinSize"),toCurrency:n,toAmount:this.safeNumber(e,"toCoinSize"),price:this.safeNumber(e,"cnvtPrice"),fee:this.safeNumber(e,"fee")}}async fetchConvertCurrencies(e={}){await this.loadMarkets();const t=await this.privateConvertGetV2ConvertCurrencies(e),s={},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r);s[a]={info:t,id:r,code:a,networks:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:this.safeNumber(t,"available"),fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(t,"minAmount"),max:this.safeNumber(t,"maxAmount")},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},created:void 0}}return s}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeString2(n,"err_msg","msg"),l=this.id+" "+o,u=void 0!==c&&""!==c&&"success"!==c;u&&(this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwBroadlyMatchedException(this.exceptions.broad,c,l));const p=this.safeString2(n,"code","err_code"),f=void 0!==p&&"00000"!==p;if(f&&this.throwExactlyMatchedException(this.exceptions.exact,p,l),f||u)throw new r.ExchangeError(l)}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){const o="private"===t[0],d=t[1],h="/api"+("/"+this.implodeParams(e,i));let c=this.implodeHostname(this.urls.api[d])+h;const l=this.omit(i,this.extractParams(e));if(!o&&"GET"===s){Object.keys(l).length>0&&(c=c+"?"+this.urlencode(l))}if(o){this.checkRequiredCredentials();const e=this.milliseconds().toString();let t=e+s+h;if("POST"===s)t+=a=this.json(i);else if(Object.keys(i).length){let e="?"+this.urlencode(this.keysort(i));e.indexOf("%24")>-1&&(e=e.replace("%24","$")),c+=e,t+=e}const o=this.hmac(this.encode(t),this.encode(this.secret),n.s,"base64"),d=this.safeString(this.options,"broker");r={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":o,"ACCESS-TIMESTAMP":e,"ACCESS-PASSPHRASE":this.password,"X-CHANNEL-API-CODE":d},"POST"===s&&(r["Content-Type"]="application/json")}return{url:c,method:s,body:a,headers:r}}}},357:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3974),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bithumb",name:"Bithumb",countries:["KR"],rateLimit:500,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},hostname:"bithumb.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg",api:{public:"https://api.{hostname}/public",private:"https://api.{hostname}"},www:"https://www.bithumb.com",doc:"https://apidocs.bithumb.com",fees:"https://en.bithumb.com/customer_support/info_fee"},api:{public:{get:["ticker/ALL_{quoteId}","ticker/{baseId}_{quoteId}","orderbook/ALL_{quoteId}","orderbook/{baseId}_{quoteId}","transaction_history/{baseId}_{quoteId}","network-info","assetsstatus/multichain/ALL","assetsstatus/multichain/{currency}","withdraw/minimum/ALL","withdraw/minimum/{currency}","assetsstatus/ALL","assetsstatus/{baseId}","candlestick/{baseId}_{quoteId}/{interval}"]},private:{post:["info/account","info/balance","info/wallet_address","info/ticker","info/orders","info/user_transactions","info/order_detail","trade/place","trade/cancel","trade/btc_withdrawal","trade/krw_deposit","trade/krw_withdrawal","trade/market_buy","trade/market_sell","trade/stop_limit"]}},fees:{trading:{maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")}},precisionMode:o.v,exceptions:{"Bad Request(SSL)":r.BadRequest,"Bad Request(Bad Method)":r.BadRequest,"Bad Request.(Auth Data)":r.AuthenticationError,"Not Member":r.AuthenticationError,"Invalid Apikey":r.AuthenticationError,"Method Not Allowed.(Access IP)":r.PermissionDenied,"Method Not Allowed.(BTC Adress)":r.InvalidAddress,"Method Not Allowed.(Access)":r.PermissionDenied,"Database Fail":r.ExchangeNotAvailable,"Invalid Parameter":r.BadRequest,5600:r.ExchangeError,"Unknown Error":r.ExchangeError,"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions":r.ExchangeError},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","30m":"30m","1h":"1h","6h":"6h","12h":"12h","1d":"24h"},options:{quoteCurrencies:{BTC:{limits:{cost:{min:2e-4,max:100}}},KRW:{limits:{cost:{min:500,max:5e9}}}}},commonCurrencies:{ALT:"ArchLoot",FTC:"FTC2",SOC:"Soda Coin"}})}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return super.safeMarket(e,t,s,"spot")}amountToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.amount,o.fv)}async fetchMarkets(e={}){const t=[],s=this.safeDict(this.options,"quoteCurrencies",{}),i=Object.keys(s),r=[];for(let t=0;t<i.length;t++){const s={quoteId:i[t]};r.push(this.publicGetTickerALLQuoteId(this.extend(s,e)))}const a=await Promise.all(r);for(let e=0;e<i.length;e++){const r=i[e],o=r,n=a[e],d=this.safeDict(n,"data"),h=this.safeDict(s,r,{}),c=Object.keys(d);for(let e=0;e<c.length;e++){const s=c[e];if("date"===s)continue;const i=d[s],a=this.safeCurrencyCode(s);let n=!0;if(Array.isArray(i)){0===i.length&&(n=!1)}const l=this.deepExtend({id:s,symbol:a+"/"+r,base:a,quote:r,settle:void 0,baseId:s,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:n,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDateTime:void 0,strike:void 0,optionType:void 0,precision:{amount:parseInt("4"),price:parseInt("4")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{}},created:void 0,info:i},h);t.push(l)}}return t}parseBalance(e){const t={info:e},s=this.safeDict(e,"data"),i=Object.keys(this.currencies);for(let e=0;e<i.length;e++){const r=i[e],a=this.account(),o=this.currency(r),n=this.safeStringLower(o,"id");a.total=this.safeString(s,"total_"+n),a.used=this.safeString(s,"in_use_"+n),a.free=this.safeString(s,"available_"+n),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostInfoBalance(this.extend({currency:"ALL"},e));return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={baseId:i.baseId,quoteId:i.quoteId};void 0!==t&&(r.count=t);const a=await this.publicGetOrderbookBaseIdQuoteId(this.extend(r,s)),o=this.safeDict(a,"data",{}),n=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,e,n,"bids","asks","price","quantity")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"date"),i=this.safeSymbol(void 0,t),r=this.safeString(e,"opening_price"),a=this.safeString(e,"closing_price"),o=this.safeString(e,"units_traded_24H"),n=this.safeString(e,"acc_trade_value_24H");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"max_price"),low:this.safeString(e,"min_price"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:r,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={},i=this.safeDict(this.options,"quoteCurrencies",{}),r=Object.keys(i),a=[];for(let e=0;e<r.length;e++){const s={quoteId:r[e]};a.push(this.publicGetTickerALLQuoteId(this.extend(s,t)))}const o=await Promise.all(a);for(let e=0;e<r.length;e++){const t=r[e],i=o[e],a=this.safeDict(i,"data",{}),n=this.safeInteger(a,"date"),d=this.omit(a,"date"),h=Object.keys(d);for(let e=0;e<h.length;e++){const i=h[e],r=a[i],o=this.safeCurrencyCode(i)+"/"+t,d=this.safeMarket(o);r.date=n,s[o]=this.parseTicker(r,d)}}return this.filterByArrayTickers(s,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={baseId:s.baseId,quoteId:s.quoteId},r=await this.publicGetTickerBaseIdQuoteId(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={baseId:a.baseId,quoteId:a.quoteId,interval:this.safeString(this.timeframes,t,t)},n=await this.publicGetCandlestickBaseIdQuoteIdInterval(this.extend(o,r)),d=this.safeList(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}parseTrade(e,t=void 0){let s;const i=this.safeString(e,"transaction_date");if(void 0!==i){const t=i.split(" ");if(t.length>1){const e=t[0];let i=t[1];i.length<8&&(i="0"+i),s=this.parse8601(e+" "+i)}else s=this.safeIntegerProduct(e,"transaction_date",.001)}void 0!==s&&(s-=324e5);let r=this.safeString(e,"type");r="ask"===r?"sell":"buy";const a=this.safeString(e,"cont_no");t=this.safeMarket(void 0,t);const o=this.safeString(e,"price"),n=this.fixCommaNumber(this.safeString2(e,"units_traded","units")),d=this.safeString(e,"total");let h;const c=this.safeString(e,"fee");if(void 0!==c){const t=this.safeString(e,"fee_currency");h={cost:c,currency:this.commonCurrencyCode(t)}}return this.safeTrade({id:a,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:undefined,side:r,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={baseId:r.baseId,quoteId:r.quoteId};void 0!==s&&(a.count=s);const o=await this.publicGetTransactionHistoryBaseIdQuoteId(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={order_currency:n.id,payment_currency:n.quote,units:i};let h="privatePostTradePlace";"limit"===t?(d.price=a,d.type="buy"===s?"bid":"ask"):h="privatePostTradeMarket"+this.capitalize(s);const c=await this[h](this.extend(d,o)),l=this.safeString(c,"order_id");if(void 0===l)throw new r.InvalidOrder(this.id+" createOrder() did not return an order id");return this.safeOrder({info:c,symbol:e,type:t,side:s,id:l},n)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={order_id:e,count:1,order_currency:i.base,payment_currency:i.quote},o=await this.privatePostInfoOrderDetail(this.extend(a,s)),n=this.safeDict(o,"data");return this.parseOrder(this.extend(n,{order_id:e}),i)}parseOrderStatus(e){return this.safeString({Pending:"open",Completed:"closed",Cancel:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeIntegerProduct(e,"order_date",.001),i="bid"===this.safeString2(e,"type","side")?"buy":"sell",r=this.parseOrderStatus(this.safeString(e,"order_status")),o=this.safeString2(e,"order_price","price");let n="limit";a.Y.stringEquals(o,"0")&&(n="market");const d=this.fixCommaNumber(this.safeString2(e,"order_qty","units"));let h,c=this.fixCommaNumber(this.safeString(e,"units_remaining"));void 0===c&&("closed"===r?c="0":"canceled"!==r&&(c=d));const l=this.safeString(e,"order_currency"),u=this.safeString(e,"payment_currency"),p=this.safeCurrencyCode(l),f=this.safeCurrencyCode(u);void 0!==p&&void 0!==f&&(h=p+"/"+f),void 0===h&&(h=(t=this.safeMarket(void 0,t)).symbol);const m=this.safeString(e,"order_id"),g=this.safeList(e,"contract",[]);return this.safeOrder({info:e,id:m,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:h,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:o,stopPrice:void 0,triggerPrice:void 0,amount:d,cost:void 0,average:void 0,filled:void 0,remaining:c,status:r,fee:void 0,trades:g},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);void 0===s&&(s=100);const o={count:s,order_currency:a.base,payment_currency:a.quote};void 0!==t&&(o.after=t);const n=await this.privatePostInfoOrders(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseOrders(d,a,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");if(!("side"in s))throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a `side` parameter (sell or buy)");const i=this.market(t),a="buy"===s.side?"bid":"ask";s=this.omit(s,["side","currency"]);const o={order_id:e,type:a,order_currency:i.base,payment_currency:i.quote},n=await this.privatePostTradeCancel(this.extend(o,s));return this.safeOrder({info:n})}async cancelUnifiedOrder(e,t={}){const s={side:e.side};return await this.cancelOrder(e.id,e.symbol,this.extend(s,t))}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={units:t,address:s,currency:o.id};if("XRP"===e||"XMR"===e||"EOS"===e||"STEEM"===e){const t=this.safeString(a,"destination");if(void 0===i&&void 0===t)throw new r.ArgumentsRequired(this.id+" "+e+" withdraw() requires a tag argument or an extra destination param");void 0!==i&&(n.destination=i)}const d=await this.privatePostTradeBtcWithdrawal(this.extend(n,a));return this.parseTransaction(d,o)}parseTransaction(e,t=void 0){return{id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:(t=this.safeCurrency(void 0,t)).code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:void 0,info:e}}fixCommaNumber(e){if(void 0===e)return;let t=e;for(;t.indexOf(",")>-1;)t=t.replace(",","");return t}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o="/"+this.implodeParams(e,i);let d=this.implodeHostname(this.urls.api[t])+o;const h=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(h).length&&(d+="?"+this.urlencode(h));else{this.checkRequiredCredentials(),a=this.urlencode(this.extend({endpoint:o},h));const e=this.nonce().toString(),t=o+"\0"+a+"\0"+e,s=this.hmac(this.encode(t),this.encode(this.secret),n.Zf),i=this.stringToBase64(s);r={Accept:"application/json","Content-Type":"application/x-www-form-urlencoded","Api-Key":this.apiKey,"Api-Sign":i,"Api-Nonce":e}}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&"status"in n){const e=this.safeString(n,"status"),t=this.safeString(n,"message");if(void 0!==e){if("0000"===e)return;if("거래 진행중인 내역이 존재하지 않습니다."===t)return;const s=this.id+" "+t;throw this.throwExactlyMatchedException(this.exceptions,e,s),this.throwExactlyMatchedException(this.exceptions,t,s),new r.ExchangeError(s)}}}}},1837:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1466),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitmart",name:"BitMart",countries:["US","CN","HK","KR"],rateLimit:33.34,version:"v2",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,borrowCrossMargin:!1,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,createTrailingPercentOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIsolatedBorrowRate:!0,fetchIsolatedBorrowRates:!0,fetchLiquidations:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyLiquidations:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawAddressesByNetwork:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!1,transfer:!0,withdraw:!0},hostname:"bitmart.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg",api:{spot:"https://api-cloud.{hostname}",swap:"https://api-cloud-v2.{hostname}"},www:"https://www.bitmart.com/",doc:"https://developer-pro.bitmart.com/",referral:{url:"http://www.bitmart.com/?r=rQCFLh",discount:.3},fees:"https://www.bitmart.com/fee/en"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:{"system/time":3,"system/service":3,"spot/v1/currencies":7.5,"spot/v1/symbols":7.5,"spot/v1/symbols/details":5,"spot/quotation/v3/tickers":6,"spot/quotation/v3/ticker":4,"spot/quotation/v3/lite-klines":5,"spot/quotation/v3/klines":7,"spot/quotation/v3/books":4,"spot/quotation/v3/trades":4,"spot/v1/ticker":5,"spot/v2/ticker":30,"spot/v1/ticker_detail":5,"spot/v1/steps":30,"spot/v1/symbols/kline":6,"spot/v1/symbols/book":5,"spot/v1/symbols/trades":5,"contract/v1/tickers":15,"contract/public/details":5,"contract/public/depth":5,"contract/public/open-interest":30,"contract/public/funding-rate":30,"contract/public/kline":6,"account/v1/currencies":30}},private:{get:{"account/sub-account/v1/transfer-list":7.5,"account/sub-account/v1/transfer-history":7.5,"account/sub-account/main/v1/wallet":5,"account/sub-account/main/v1/subaccount-list":7.5,"account/contract/sub-account/main/v1/wallet":5,"account/contract/sub-account/main/v1/transfer-list":7.5,"account/contract/sub-account/v1/transfer-history":7.5,"account/v1/wallet":5,"account/v1/currencies":30,"spot/v1/wallet":5,"account/v1/deposit/address":30,"account/v1/withdraw/charge":32,"account/v2/deposit-withdraw/history":7.5,"account/v1/deposit-withdraw/detail":7.5,"spot/v1/order_detail":1,"spot/v2/orders":5,"spot/v1/trades":5,"spot/v2/trades":4,"spot/v3/orders":5,"spot/v2/order_detail":1,"spot/v1/margin/isolated/borrow_record":1,"spot/v1/margin/isolated/repay_record":1,"spot/v1/margin/isolated/pairs":30,"spot/v1/margin/isolated/account":5,"spot/v1/trade_fee":30,"spot/v1/user_fee":30,"spot/v1/broker/rebate":1,"contract/private/assets-detail":5,"contract/private/order":1.2,"contract/private/order-history":10,"contract/private/position":10,"contract/private/get-open-orders":1.2,"contract/private/current-plan-order":1.2,"contract/private/trades":10,"contract/private/position-risk":10,"contract/private/affilate/rebate-list":10,"contract/private/affilate/trade-list":10},post:{"account/sub-account/main/v1/sub-to-main":30,"account/sub-account/sub/v1/sub-to-main":30,"account/sub-account/main/v1/main-to-sub":30,"account/sub-account/sub/v1/sub-to-sub":30,"account/sub-account/main/v1/sub-to-sub":30,"account/contract/sub-account/main/v1/sub-to-main":7.5,"account/contract/sub-account/main/v1/main-to-sub":7.5,"account/contract/sub-account/sub/v1/sub-to-main":7.5,"account/v1/withdraw/apply":7.5,"spot/v1/submit_order":1,"spot/v1/batch_orders":1,"spot/v2/cancel_order":1,"spot/v1/cancel_orders":15,"spot/v4/query/order":1,"spot/v4/query/client-order":1,"spot/v4/query/open-orders":5,"spot/v4/query/history-orders":5,"spot/v4/query/trades":5,"spot/v4/query/order-trades":5,"spot/v4/cancel_orders":3,"spot/v4/batch_orders":3,"spot/v3/cancel_order":1,"spot/v2/batch_orders":1,"spot/v2/submit_order":1,"spot/v1/margin/submit_order":1,"spot/v1/margin/isolated/borrow":30,"spot/v1/margin/isolated/repay":30,"spot/v1/margin/isolated/transfer":30,"account/v1/transfer-contract-list":60,"account/v1/transfer-contract":60,"contract/private/submit-order":2.5,"contract/private/cancel-order":1.5,"contract/private/cancel-orders":30,"contract/private/submit-plan-order":2.5,"contract/private/cancel-plan-order":1.5,"contract/private/submit-leverage":2.5}}},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"45m":45,"1h":60,"2h":120,"3h":180,"4h":240,"1d":1440,"1w":10080,"1M":43200},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0040"),maker:this.parseNumber("0.0035"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0020")],[this.parseNumber("10"),this.parseNumber("0.18")],[this.parseNumber("50"),this.parseNumber("0.0016")],[this.parseNumber("250"),this.parseNumber("0.0014")],[this.parseNumber("1000"),this.parseNumber("0.0012")],[this.parseNumber("5000"),this.parseNumber("0.0010")],[this.parseNumber("25000"),this.parseNumber("0.0008")],[this.parseNumber("50000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("10"),this.parseNumber("0.0009")],[this.parseNumber("50"),this.parseNumber("0.0008")],[this.parseNumber("250"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0005")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")]]}}},precisionMode:o.kb,exceptions:{exact:{3e4:r.ExchangeError,30001:r.AuthenticationError,30002:r.AuthenticationError,30003:r.AccountSuspended,30004:r.AuthenticationError,30005:r.AuthenticationError,30006:r.AuthenticationError,30007:r.AuthenticationError,30008:r.AuthenticationError,30010:r.PermissionDenied,30011:r.AuthenticationError,30012:r.AuthenticationError,30013:r.RateLimitExceeded,30014:r.ExchangeNotAvailable,30016:r.OnMaintenance,30017:r.RateLimitExceeded,30018:r.BadRequest,30019:r.PermissionDenied,6e4:r.BadRequest,60001:r.BadRequest,60002:r.BadRequest,60003:r.ExchangeError,60004:r.ExchangeError,60005:r.ExchangeError,60006:r.ExchangeError,60007:r.InvalidAddress,60008:r.InsufficientFunds,60009:r.ExchangeError,60010:r.ExchangeError,60011:r.InvalidAddress,60012:r.ExchangeError,60020:r.PermissionDenied,60021:r.PermissionDenied,60022:r.PermissionDenied,60026:r.PermissionDenied,60027:r.PermissionDenied,60028:r.AccountSuspended,60029:r.AccountSuspended,60030:r.BadRequest,60031:r.BadRequest,60050:r.ExchangeError,60051:r.ExchangeError,61001:r.InsufficientFunds,61003:r.BadRequest,61004:r.BadRequest,61005:r.BadRequest,61006:r.NotSupported,61007:r.ExchangeError,61008:r.ExchangeError,7e4:r.ExchangeError,70001:r.BadRequest,70002:r.BadSymbol,70003:r.NetworkError,71001:r.BadRequest,71002:r.BadRequest,71003:r.BadRequest,71004:r.BadRequest,71005:r.BadRequest,5e4:r.BadRequest,50001:r.BadSymbol,50002:r.BadRequest,50003:r.BadRequest,50004:r.BadRequest,50005:r.OrderNotFound,50006:r.InvalidOrder,50007:r.InvalidOrder,50008:r.InvalidOrder,50009:r.InvalidOrder,50010:r.InvalidOrder,50011:r.InvalidOrder,50012:r.InvalidOrder,50013:r.InvalidOrder,50014:r.BadRequest,50015:r.BadRequest,50016:r.BadRequest,50017:r.BadRequest,50018:r.BadRequest,50019:r.ExchangeError,50020:r.InsufficientFunds,50021:r.BadRequest,50022:r.ExchangeNotAvailable,50023:r.BadSymbol,50024:r.BadRequest,50025:r.BadRequest,50026:r.BadRequest,50027:r.BadRequest,50028:r.BadRequest,50029:r.InvalidOrder,50030:r.OrderNotFound,50031:r.OrderNotFound,50032:r.OrderNotFound,50033:r.InvalidOrder,50034:r.InvalidOrder,50035:r.InvalidOrder,50036:r.ExchangeError,50037:r.BadRequest,50038:r.BadRequest,50039:r.BadRequest,50040:r.BadSymbol,50041:r.ExchangeError,50042:r.BadRequest,51e3:r.BadSymbol,51001:r.ExchangeError,51002:r.ExchangeError,51003:r.ExchangeError,51004:r.InsufficientFunds,51005:r.InvalidOrder,51006:r.InvalidOrder,51007:r.BadRequest,51008:r.ExchangeError,51009:r.InvalidOrder,51010:r.InvalidOrder,51011:r.InvalidOrder,51012:r.InvalidOrder,51013:r.InvalidOrder,51014:r.InvalidOrder,51015:r.InvalidOrder,52e3:r.BadRequest,52001:r.BadRequest,52002:r.BadRequest,52003:r.BadRequest,52004:r.BadRequest,53e3:r.AccountSuspended,53001:r.AccountSuspended,53002:r.PermissionDenied,53003:r.PermissionDenied,53005:r.PermissionDenied,53006:r.PermissionDenied,53007:r.PermissionDenied,53008:r.PermissionDenied,53009:r.PermissionDenied,53010:r.PermissionDenied,57001:r.BadRequest,58001:r.BadRequest,59001:r.ExchangeError,59002:r.ExchangeError,59003:r.ExchangeError,59004:r.ExchangeError,59005:r.PermissionDenied,59006:r.ExchangeError,59007:r.ExchangeError,59008:r.ExchangeError,59009:r.ExchangeError,59010:r.InsufficientFunds,59011:r.ExchangeError,40001:r.ExchangeError,40002:r.ExchangeError,40003:r.ExchangeError,40004:r.ExchangeError,40005:r.ExchangeError,40006:r.PermissionDenied,40007:r.BadRequest,40008:r.InvalidNonce,40009:r.BadRequest,40010:r.BadRequest,40011:r.BadRequest,40012:r.ExchangeError,40013:r.ExchangeError,40014:r.BadSymbol,40015:r.BadSymbol,40016:r.InvalidOrder,40017:r.InvalidOrder,40018:r.InvalidOrder,40019:r.ExchangeError,40020:r.InvalidOrder,40021:r.ExchangeError,40022:r.ExchangeError,40023:r.ExchangeError,40024:r.ExchangeError,40025:r.ExchangeError,40026:r.ExchangeError,40027:r.InsufficientFunds,40028:r.PermissionDenied,40029:r.InvalidOrder,40030:r.InvalidOrder,40031:r.InvalidOrder,40032:r.InvalidOrder,40033:r.InvalidOrder,40034:r.BadSymbol,40035:r.OrderNotFound,40036:r.InvalidOrder,40037:r.OrderNotFound,40038:r.BadRequest,40039:r.BadRequest,40040:r.InvalidOrder,40041:r.InvalidOrder,40042:r.InvalidOrder,40043:r.InvalidOrder,40044:r.InvalidOrder,40045:r.InvalidOrder,40046:r.PermissionDenied,40047:r.PermissionDenied,40048:r.InvalidOrder,40049:r.InvalidOrder,40050:r.InvalidOrder},broad:{}},commonCurrencies:{$GM:"GOLDMINER",$HERO:"Step Hero",$PAC:"PAC",BP:"BEYOND",GDT:"Gorilla Diamond",GLD:"Goldario",MVP:"MVP Coin",TRU:"Truebit"},options:{defaultNetwork:"ERC20",defaultNetworks:{USDT:"ERC20"},networks:{ERC20:"ERC20",SOL:"SOL",BTC:"BTC",TRC20:"TRC20",OMNI:"OMNI",XLM:"XLM",EOS:"EOS",NEO:"NEO",BTM:"BTM",BCH:"BCH",LTC:"LTC",BSV:"BSV",XRP:"XRP",PLEX:"PLEX",XCH:"XCH",NEAR:"NEAR",FIO:"FIO",SCRT:"SCRT",IOTX:"IOTX",ALGO:"ALGO",ATOM:"ATOM",DOT:"DOT",ADA:"ADA",DOGE:"DOGE",XYM:"XYM",GLMR:"GLMR",MOVR:"MOVR",ZIL:"ZIL",INJ:"INJ",KSM:"KSM",ZEC:"ZEC",NAS:"NAS",HRC20:"HECO",XDC:"XDC",ONE:"ONE",LAT:"LAT",CSPR:"Casper",ICP:"Computer",XTZ:"XTZ",MINA:"MINA",THETA:"THETA",AKT:"AKT",AR:"AR",CELO:"CELO",FIL:"FIL",NULS:"NULS",ETC:"ETC",DASH:"DASH",DGB:"DGB",BEP2:"BEP2",GRIN:"GRIN",WAVES:"WAVES",ABBC:"ABBC",ACA:"ACA",QTUM:"QTUM",PAC:"PAC",TLOS:"TLOS",KARDIA:"KardiaChain",FUSE:"FUSE",TRC10:"TRC10",FIRO:"FIRO",FTM:"Fantom",EVER:"EVER",KAVA:"KAVA",HYDRA:"HYDRA",PLCU:"PLCU",BRISE:"BRISE",OPTIMISM:"OPTIMISM",REEF:"REEF",SYS:"SYS",VITE:"VITE",STX:"STX",SXP:"SXP",BITCI:"BITCI",XRD:"XRD",ASTR:"ASTAR",ZEN:"HORIZEN",LTO:"LTO",ETHW:"ETHW",ETHF:"ETHF",IOST:"IOST",APT:"APT",ONT:"ONT",EVMOS:"EVMOS",XMR:"XMR",OASYS:"OAS",OSMO:"OSMO",OMAX:"OMAX Chain",DESO:"DESO",BFIC:"BFIC",OHO:"OHO",CS:"CS",CHEQ:"CHEQ",NODL:"NODL",NEM:"XEM",FRA:"FRA",ERGO:"ERG"},defaultType:"spot",fetchBalance:{type:"spot"},accountsByType:{spot:"spot",swap:"swap"},createMarketBuyOrderRequiresPrice:!0,brokerId:"CCXTxBitmart000"}})}async fetchTime(e={}){const t=await this.publicGetSystemTime(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"server_time")}async fetchStatus(e={}){const t=this.safeValue(this.options,"fetchStatus",{}),s=this.safeString(this.options,"defaultType");let i=this.safeString(t,"type",s);i=this.safeString(e,"type",i),e=this.omit(e,"type");const r=await this.publicGetSystemService(e),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"service",[]),n=this.indexBy(o,"service_type");"swap"===i&&(i="contract");const d=this.safeValue(n,i);let h,c;if(void 0!==d){2===this.safeInteger(d,"status")?h="ok":(h="maintenance",c=this.safeInteger(d,"end_time"))}return{status:h,updated:void 0,eta:c,url:void 0,info:r}}async fetchSpotMarkets(e={}){const t=await this.publicGetSpotV1SymbolsDetails(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"symbol"),o=this.safeInteger(t,"symbol_id"),n=this.safeString(t,"base_currency"),d=this.safeString(t,"quote_currency"),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=h+"/"+c,u=this.safeString(t,"min_buy_amount"),p=this.safeString(t,"min_sell_amount"),f=a.Y.stringMax(u,p),m=this.safeNumber(t,"base_min_size");r.push({id:s,numericId:o,symbol:l,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:m,price:this.parseNumber(this.parsePrecision(this.safeString(t,"price_max_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:m,max:this.safeNumber(t,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.parseNumber(f),max:void 0}},created:void 0,info:t})}return r}async fetchContractMarkets(e={}){const t=await this.publicGetContractPublicDetails(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"symbol"),a=this.safeString(t,"base_currency"),o=this.safeString(t,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h="USDT",c=this.safeCurrencyCode(h),l=n+"/"+d+":"+c,u=this.safeInteger(t,"product_type"),p=1===u,f=2===u;let m=this.safeInteger(t,"expire_timestamp");f||0!==m||(m=void 0),r.push({id:s,numericId:void 0,symbol:l,base:n,quote:d,settle:c,baseId:a,quoteId:o,settleId:h,type:p?"swap":"future",spot:!1,margin:!1,swap:p,future:f,option:!1,active:!0,contract:!0,linear:!0,inverse:!1,contractSize:this.safeNumber(t,"contract_size"),expiry:m,expiryDatetime:this.iso8601(m),strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"vol_precision"),price:this.safeNumber(t,"price_precision")},limits:{leverage:{min:this.safeNumber(t,"min_leverage"),max:this.safeNumber(t,"max_leverage")},amount:{min:this.safeNumber(t,"min_volume"),max:this.safeNumber(t,"max_volume")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:this.safeInteger(t,"open_timestamp"),info:t})}return r}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchContractMarkets(e);return this.arrayConcat(t,s)}async fetchCurrencies(e={}){const t=await this.publicGetSpotV1Currencies(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"id"),a=this.safeCurrencyCode(s),o=this.safeString(t,"name"),n=this.safeValue(t,"withdraw_enabled"),d=this.safeValue(t,"deposit_enabled"),h=n&&d;r[a]={id:s,code:a,name:o,info:t,active:h,deposit:d,withdraw:n,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return r}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privateGetAccountV1WithdrawCharge(this.extend(s,t)),r=i.data,a={};return a[e]=this.safeNumber(r,"withdraw_fee"),{info:i,withdraw:a,deposit:{}}}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=(await this.privateGetAccountV1WithdrawCharge(this.extend(s,t))).data;return this.parseDepositWithdrawFee(i)}parseTicker(e,t=void 0){const s=this.safeList(e,"result",[]),i=this.safeString2(e,"avg_price","index_price");let r=this.safeString2(e,"symbol","contract_symbol"),o=this.safeInteger2(e,"timestamp","ts"),n=this.safeString2(e,"last_price","last"),d=this.safeString2(e,"price_change_percent_24h","change_24h"),h=this.safeString(e,"fluctuation"),c=this.safeString2(e,"high_24h","high_price"),l=this.safeString2(e,"low_24h","low_price"),u=this.safeString2(e,"best_bid","bid_px"),p=this.safeString2(e,"best_bid_size","bid_sz"),f=this.safeString2(e,"best_ask","ask_px"),m=this.safeString2(e,"best_ask_size","ask_sz"),g=this.safeString(e,"open_24h"),v=this.safeStringN(e,["base_volume_24h","v_24h","volume_24h"]),y=this.safeStringLowerN(e,["quote_volume_24h","qv_24h","turnover_24h"]);const w=this.safeString(s,0);void 0!==w&&(r=w,o=this.safeInteger(s,12),c=this.safeString(s,5),l=this.safeString(s,6),u=this.safeString(s,8),p=this.safeString(s,9),f=this.safeString(s,10),m=this.safeString(s,11),g=this.safeString(s,4),n=this.safeString(s,1),h=this.safeString(s,7),v=this.safeString(s,2),y=this.safeStringLower(s,3));const b=(t=this.safeMarket(r,t)).symbol;return void 0===o&&(o=this.safeIntegerProduct(e,"s_t",1e3)),void 0===d&&(d=a.Y.stringMul(h,"100")),void 0===y&&(void 0===v?y=this.safeString(e,"volume_24h",y):(y=v,v=void 0)),this.safeTicker({symbol:b,timestamp:o,datetime:this.iso8601(o),high:c,low:l,bid:u,bidVolume:p,ask:f,askVolume:m,vwap:void 0,open:g,close:n,last:n,previousClose:void 0,change:h,percentage:d,average:i,baseVolume:v,quoteVolume:y,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let a;if(s.swap)i.symbol=s.id,a=await this.publicGetContractPublicDetails(this.extend(i,t));else{if(!s.spot)throw new r.NotSupported(this.id+" fetchTicker() does not support "+s.type+" markets, only spot and swap markets are accepted");i.symbol=s.id,a=await this.publicGetSpotQuotationV3Ticker(this.extend(i,t))}let o=[],n={};if(s.spot)n=this.safeDict(a,"data",{});else{const e=this.safeDict(a,"data",{});o=this.safeList(e,"symbols",[]),n=this.safeValue(o,0,{})}return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){let s,i,a;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))){const t=this.safeValue(e,0);i=this.market(t)}if([s,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),"spot"===s)a=await this.publicGetSpotQuotationV3Tickers(t);else{if("swap"!==s)throw new r.NotSupported(this.id+" fetchTickers() does not support "+s+" markets, only spot and swap markets are accepted");a=await this.publicGetContractPublicDetails(t)}let o=[];if("spot"===s)o=this.safeList(a,"data",[]);else{const e=this.safeDict(a,"data",{});o=this.safeList(e,"symbols",[])}const n={};for(let e=0;e<o.length;e++){let t={};t="spot"===s?this.parseTicker({result:o[e]}):this.parseTicker(o[e]);n[t.symbol]=t}return this.filterByArrayTickers(n,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),a={symbol:i.id};let o;if(i.spot)void 0!==t&&(a.limit=t),o=await this.publicGetSpotQuotationV3Books(this.extend(a,s));else{if(!i.swap)throw new r.NotSupported(this.id+" fetchOrderBook() does not support "+i.type+" markets, only spot and swap markets are accepted");o=await this.publicGetContractPublicDepth(this.extend(a,s))}const n=this.safeValue(o,"data",{}),d=this.safeInteger2(n,"ts","timestamp");return this.parseOrderBook(n,i.symbol,d)}parseTrade(e,t=void 0){const s=this.safeIntegerN(e,["createTime","create_time",1]);let i,r,a,o;void 0!==this.safeString(e,0)?(i=this.safeString2(e,"count",3),r=this.safeString(e,"amount"),o=this.safeString2(e,"type",4)):(i=this.safeStringN(e,["size","vol","fillQty"]),r=this.safeString(e,"notional"),a=this.safeString(e,"type"),o=this.parseOrderSide(this.safeString(e,"side")));const n=this.safeString2(e,"symbol",0);t=this.safeMarket(n,t);const d=this.safeString2(e,"fee","paid_fees");let h;if(void 0!==d){const s=this.safeString(e,"feeCoinName");let i=this.safeCurrencyCode(s);void 0===i&&(i="buy"===o?t.base:t.quote),h={cost:d,currency:i}}return this.safeTrade({info:e,id:this.safeStringN(e,["tradeId","trade_id","lastTradeID"]),order:this.safeString2(e,"orderId","order_id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:a,side:o,price:this.safeStringN(e,["price","fillPrice",2]),amount:i,cost:r,takerOrMaker:this.safeStringLower2(e,"tradeRole","exec_type"),fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e);if(!a.spot)throw new r.NotSupported(this.id+" fetchTrades() does not support "+a.type+" orders, only spot orders are accepted");const o={symbol:a.id};void 0!==s&&(o.limit=s);const n=await this.publicGetSpotQuotationV3Trades(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp2(e,"timestamp","ts"),this.safeNumber2(e,"open_price","o"),this.safeNumber2(e,"high_price","h"),this.safeNumber2(e,"low_price","l"),this.safeNumber2(e,"close_price","c"),this.safeNumber2(e,"volume","v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,200);const o=this.market(e),n=this.parseTimeframe(t),d=this.safeInteger(this.timeframes,t);let h,c={symbol:o.id};if(c.step=void 0!==d?d:t,o.spot)[c,r]=this.handleUntilOption("before",c,r,.001),void 0!==i&&(c.limit=i),void 0!==s&&(c.after=this.parseToInt(s/1e3)-1);else{const e=1200;void 0===i&&(i=e),i=Math.min(e,i);const t=this.parseToInt(this.milliseconds()/1e3);if(void 0===s){const e=t-i*n;c.start_time=e,c.end_time=t}else{const e=this.parseToInt(s/1e3)-1,r=this.sum(e,i*n);c.start_time=e,c.end_time=Math.min(r,t)}[c,r]=this.handleUntilOption("end_time",c,r,.001)}h=o.swap?await this.publicGetContractPublicKline(this.extend(c,r)):await this.publicGetSpotQuotationV3Klines(this.extend(c,r));const l=this.safeList(h,"data",[]);return this.parseOHLCVs(l,o,t,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();const o={};let n,d;void 0!==e&&(a=this.market(e),o.symbol=a.id),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",a,i);const h=this.safeIntegerN(i,["until","endTime","end_time"]);if(i=this.omit(i,["until"]),"spot"===n){let e;[e,i]=this.handleMarginModeAndParams("fetchMyTrades",i),"isolated"===e&&(o.orderMode="iso_margin");const r=this.safeValue(this.options,"fetchMyTrades",{}),a=this.safeInteger(r,"limit",200);void 0===s&&(s=a),o.limit=s,void 0!==t&&(o.startTime=t),void 0!==h&&(o.endTime=h),d=await this.privatePostSpotV4QueryTrades(this.extend(o,i))}else{if("swap"!==n)throw new r.NotSupported(this.id+" fetchMyTrades() does not support "+n+" orders, only spot and swap orders are accepted");if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");void 0!==t&&(o.start_time=t),void 0!==h&&(o.end_time=h),d=await this.privateGetContractPrivateTrades(this.extend(o,i))}const c=this.safeList(d,"data",[]);return this.parseTrades(c,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={orderId:e},o=await this.privatePostSpotV4QueryOrderTrades(this.extend(a,r)),n=this.safeList(o,"data",[]);return this.parseTrades(n,void 0,s,i)}customParseBalance(e,t){const s=this.safeValue(e,"data",{});let i;i="swap"===t?this.safeValue(e,"data",[]):"margin"===t?this.safeValue(s,"symbols",[]):this.safeValue(s,"wallet",[]);const r={info:e};if("margin"===t){for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"symbol"),a=this.safeSymbol(s,void 0,"_"),o=this.safeValue(t,"base",{}),n=this.safeValue(t,"quote",{}),d=this.safeCurrencyCode(this.safeString(o,"currency")),h=this.safeCurrencyCode(this.safeString(n,"currency")),c={};c[d]=this.parseBalanceHelper(o),c[h]=this.parseBalanceHelper(n),r[a]=this.safeBalance(c)}return r}for(let e=0;e<i.length;e++){const t=i[e];let s=this.safeString2(t,"id","currency");s=this.safeString(t,"coin_code",s);const a=this.safeCurrencyCode(s),o=this.account();o.free=this.safeString2(t,"available","available_balance"),o.used=this.safeString2(t,"frozen","frozen_balance"),r[a]=o}return this.safeBalance(r)}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"frozen"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total_asset");const s=this.safeString(e,"borrow_unpaid"),i=this.safeString(e,"interest_unpaid");return t.debt=a.Y.stringAdd(s,i),t}async fetchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeString(e,"marginMode"),i=this.safeBool(e,"margin",!1);let a;if(e=this.omit(e,["margin","marginMode"]),(void 0!==s||i)&&(t="margin"),"spot"===t)a=await this.privateGetSpotV1Wallet(e);else if("swap"===t)a=await this.privateGetContractPrivateAssetsDetail(e);else if("account"===t)a=await this.privateGetAccountV1Wallet(e);else{if("margin"!==t)throw new r.NotSupported(this.id+" fetchBalance() does not support "+t+" markets, only spot, swap and account and margin markets are accepted");a=await this.privateGetSpotV1MarginIsolatedAccount(e)}return this.customParseBalance(a,t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.spot)throw new r.NotSupported(this.id+" fetchTradingFee() does not support "+s.type+" orders, only spot orders are accepted");const i={symbol:s.id},a=await this.privateGetSpotV1TradeFee(this.extend(i,t)),o=this.safeValue(a,"data");return this.parseTradingFee(o)}parseOrder(e,t=void 0){let s;"string"==typeof e&&(s=e,e={}),s=this.safeString2(e,"order_id","orderId",s);const i=this.safeInteger2(e,"create_time","createTime"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t);t=this.safeMarket(a,t);const o=this.safeString(t,"type","spot");let n,d,h=this.safeString(e,"type");"limit_maker"===h&&(h="limit",d=!0,n="PO"),"ioc"===h&&(h="limit",n="IOC");let c=this.safeString(e,"price");"market price"===c&&(c=void 0);const l=this.safeNumber(e,"activation_price");return this.safeOrder({id:s,clientOrderId:this.safeString2(e,"client_order_id","clientOrderId"),info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"update_time"),symbol:a,type:h,timeInForce:n,postOnly:d,side:this.parseOrderSide(this.safeString(e,"side")),price:this.omitZero(c),stopPrice:l,triggerPrice:l,amount:this.omitZero(this.safeString(e,"size")),cost:this.safeString2(e,"filled_notional","filledNotional"),average:this.safeStringN(e,["price_avg","priceAvg","deal_avg_price"]),filled:this.safeStringN(e,["filled_size","filledSize","deal_size"]),remaining:void 0,status:this.parseOrderStatusByType(o,this.safeString2(e,"status","state")),fee:void 0,trades:void 0},t)}parseOrderSide(e){return this.safeString({1:"buy",2:"buy",3:"sell",4:"sell"},e,e)}parseOrderStatusByType(e,t){const s=this.safeValue({spot:{1:"rejected",2:"open",3:"rejected",4:"open",5:"open",6:"closed",7:"canceled",8:"canceled",new:"open",partially_filled:"open",filled:"closed",partially_canceled:"canceled"},swap:{1:"open",2:"open",4:"closed"}},e,{});return this.safeString(s,t,t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.handleMarginModeAndParams("createOrder",a),d=this.safeString(n,0),h=void 0!==this.safeStringN(a,["triggerPrice","stopPrice","trigger_price"]);let c;if(o.spot){const o=this.createSpotOrderRequest(e,t,s,i,r,a);c="isolated"===d?await this.privatePostSpotV1MarginSubmitOrder(o):await this.privatePostSpotV2SubmitOrder(o)}else{const o=this.createSwapOrderRequest(e,t,s,i,r,a);c=h?await this.privatePostContractPrivateSubmitPlanOrder(o):await this.privatePostContractPrivateSubmitOrder(o)}const l=this.safeValue(c,"data",{}),u=this.parseOrder(l,o);return u.type=t,u.side=s,u.amount=i,u.price=r,u}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i,a;for(let t=0;t<e.length;t++){const o=e[t],n=this.safeString(o,"symbol");if(a=this.market(n),!a.spot)throw new r.NotSupported(this.id+" createOrders() supports spot orders only");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const d=this.safeString(o,"type"),h=this.safeString(o,"side"),c=this.safeValue(o,"amount"),l=this.safeValue(o,"price"),u=this.safeDict(o,"params",{});let p=this.createSpotOrderRequest(n,d,h,c,l,u);p=this.omit(p,["symbol"]),s.push(p)}const o={symbol:a.id,orderParams:s},n=await this.privatePostSpotV4BatchOrders(o),d=this.safeDict(n,"data",{}),h=this.safeDict(d,"data",{}),c=this.safeList(h,"orderIds",[]),l=[];for(let e=0;e<c.length;e++){const t=c[e],s=this.safeOrder({id:t},a);l.push(s)}return l}createSwapOrderRequest(e,t,s,i,r=void 0,a={}){const o={symbol:this.market(e).id,type:t,size:parseInt(this.amountToPrecision(e,i))},n=this.safeString(a,"timeInForce"),d=this.safeInteger(a,"mode"),h="market"===t;let c;const l=this.safeValue(a,"reduceOnly"),u=4===d;[c,a]=this.handlePostOnly(h,u,a);const p="limit"===t||c||("IOC"===n||3===d);"GTC"===n?o.mode=1:"FOK"===n?o.mode=2:"IOC"===n&&(o.mode=3),c&&(o.mode=4);const f=this.safeStringN(a,["triggerPrice","stopPrice","trigger_price"]),m=void 0!==f,g=this.safeString2(a,"trailingTriggerPrice","activation_price",this.numberToString(r)),v=this.safeString2(a,"trailingPercent","callback_rate"),y=void 0!==v;let w;p?o.price=this.priceToPrecision(e,r):("trailing"===t||y)&&(o.callback_rate=v,o.activation_price=this.priceToPrecision(e,g),o.activation_price_type=this.safeInteger(a,"activation_price_type",1)),m&&((p||void 0!==r)&&(o.executive_price=this.priceToPrecision(e,r)),o.trigger_price=this.priceToPrecision(e,f),o.price_type=this.safeInteger(a,"price_type",1),"buy"===s?o.price_way=l?2:1:"sell"===s&&(o.price_way=l?1:2)),"buy"===s?o.side=l?2:1:"sell"===s&&(o.side=l?3:4),[w,a]=this.handleMarginModeAndParams("createOrder",a,"cross"),o.open_type=w;const b=this.safeString(a,"clientOrderId");void 0!==b&&(a=this.omit(a,"clientOrderId"),o.client_order_id=b);const S=this.safeInteger(a,"leverage");return a=this.omit(a,["timeInForce","postOnly","reduceOnly","leverage","trailingTriggerPrice","trailingPercent","triggerPrice","stopPrice"]),void 0!==S?o.leverage=this.numberToString(S):m&&(o.leverage="1"),this.extend(o,a)}createSpotOrderRequest(e,t,s,i,n=void 0,d={}){const h=this.market(e),c={symbol:h.id,side:s,type:t},l=this.safeString(d,"timeInForce");if("FOK"===l)throw new r.InvalidOrder(this.id+" createOrder() only accepts timeInForce parameter values of IOC or PO");const u=this.safeInteger(d,"mode"),p="market"===t;let f;const m="limit_maker"===t||4===u;[f,d]=this.handlePostOnly(p,m,d),d=this.omit(d,["timeInForce","postOnly"]);const g="IOC"===l||"ioc"===t;if("limit"===t||f||g)c.size=this.amountToPrecision(e,i),c.price=this.priceToPrecision(e,n);else if(p)if("buy"===s){let e=this.safeString2(d,"cost","notional");d=this.omit(d,"cost");let t=!0;if([t,d]=this.handleOptionAndParams(d,"createOrder","createMarketBuyOrderRequiresPrice",!0),t){if(void 0===n&&void 0===e)throw new r.InvalidOrder(this.id+' createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument or in the "notional" extra parameter (the exchange-specific behaviour)');{const t=this.numberToString(i),s=this.numberToString(n);e=a.Y.stringMul(t,s)}}else e=void 0===e?this.numberToString(i):e;c.notional=this.decimalToPrecision(e,o.R3,h.precision.price,this.precisionMode)}else"sell"===s&&(c.size=this.amountToPrecision(e,i));f&&(c.type="limit_maker"),g&&(c.type="ioc");const v=this.safeString(d,"clientOrderId");return void 0!==v&&(d=this.omit(d,"clientOrderId"),c.client_order_id=v),this.extend(c,d)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id},o=this.safeString2(s,"clientOrderId","client_order_id");let n;if(void 0!==o?a.client_order_id=o:a.order_id=e.toString(),s=this.omit(s,["clientOrderId"]),i.spot)n=await this.privatePostSpotV3CancelOrder(this.extend(a,s));else{const e=this.safeValue2(s,"stop","trigger");s=this.omit(s,["stop","trigger"]),n=e?await this.privatePostContractPrivateCancelPlanOrder(this.extend(a,s)):await this.privatePostContractPrivateCancelOrder(this.extend(a,s))}if(i.swap)return n;const d=this.safeValue(n,"data");if(!0===d)return this.safeOrder({id:e},i);const h=this.safeValue(d,"succeed");if(void 0!==h){if(void 0===(e=this.safeString(h,0)))throw new r.InvalidOrder(this.id+" cancelOrder() failed to cancel "+t+" order id "+e)}else{if(!this.safeValue(d,"result"))throw new r.InvalidOrder(this.id+" cancelOrder() "+t+" order id "+e+" is filled or canceled")}return this.safeOrder({id:e,symbol:i.symbol,info:{}},i)}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.spot)throw new r.NotSupported(this.id+" cancelOrders() does not support "+i.type+" orders, only spot orders are accepted");const a=this.safeList(s,"clientOrderIds");s=this.omit(s,["clientOrderIds"]);const o={symbol:i.id};void 0!==a?o.clientOrderIds=a:o.orderIds=e;const n=await this.privatePostSpotV4CancelOrders(this.extend(o,s)),d=this.safeDict(n,"data",{}),h=[],c=this.safeList(d,"successIds",[]);for(let e=0;e<c.length;e++){const t=c[e];h.push(this.safeOrder({id:t,status:"canceled"},i))}const l=this.safeList(d,"failIds",[]);for(let e=0;e<l.length;e++){const t=l[e];h.push(this.safeOrder({id:t,status:"failed"},i))}return h}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i,a,o;if(void 0!==e&&(i=this.market(e),s.symbol=i.id),[o,t]=this.handleMarketTypeAndParams("cancelAllOrders",i,t),"spot"===o)a=await this.privatePostSpotV1CancelOrders(this.extend(s,t));else if("swap"===o){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");a=await this.privatePostContractPrivateCancelOrders(this.extend(s,t))}return a}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrdersByStatus() requires a symbol argument");await this.loadMarkets();const o=this.market(t);if(!o.spot)throw new r.NotSupported(this.id+" fetchOrdersByStatus() does not support "+o.type+" orders, only spot orders are accepted");const n={symbol:o.id,offset:1,N:100};n.status="open"===e?9:"closed"===e?6:"canceled"===e?8:e;const d=await this.privateGetSpotV3Orders(this.extend(n,a)),h=this.safeValue(d,"data",{}),c=this.safeList(h,"orders",[]);return this.parseOrders(c,o,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();const o={};let n,d;if(void 0!==e&&(a=this.market(e),o.symbol=a.id),void 0!==s&&(o.limit=s),[n,i]=this.handleMarketTypeAndParams("fetchOpenOrders",a,i),"spot"===n){let e;[e,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),"isolated"===e&&(o.orderMode="iso_margin"),void 0!==t&&(o.startTime=t);const s=this.safeInteger2(i,"until","endTime");void 0!==s&&(i=this.omit(i,["endTime"]),o.endTime=s),d=await this.privatePostSpotV4QueryOpenOrders(this.extend(o,i))}else{if("swap"!==n)throw new r.NotSupported(this.id+" fetchOpenOrders() does not support "+n+" orders, only spot and swap orders are accepted");{const e=this.safeValue2(i,"stop","trigger");if(i=this.omit(i,["stop","trigger"]),e)d=await this.privateGetContractPrivateCurrentPlanOrder(this.extend(o,i));else{const e=this.safeBool(i,"trailing",!1);let t=this.safeString(i,"orderType");i=this.omit(i,["orderType","trailing"]),e&&(t="trailing"),void 0!==t&&(o.type=t),d=await this.privateGetContractPrivateGetOpenOrders(this.extend(o,i))}}}const h=this.safeList(d,"data",[]);return this.parseOrders(h,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();const o={};let n,d;if(void 0!==e&&(a=this.market(e),o.symbol=a.id),[n,i]=this.handleMarketTypeAndParams("fetchClosedOrders",a,i),"spot"!==n&&void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");[d,i]=this.handleMarginModeAndParams("fetchClosedOrders",i),"isolated"===d&&(o.orderMode="iso_margin");void 0!==t&&(o["spot"===n?"startTime":"start_time"]=t);const h="spot"===n?"endTime":"end_time",c=this.safeInteger2(i,"until",h);let l;void 0!==c&&(i=this.omit(i,["until"]),o[h]=c),l="spot"===n?await this.privatePostSpotV4QueryHistoryOrders(this.extend(o,i)):await this.privateGetContractPrivateOrderHistory(this.extend(o,i));const u=this.safeList(l,"data",[]);return this.parseOrders(u,a,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("canceled",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={};let a,o,n;if(void 0!==t&&(o=this.market(t)),[a,s]=this.handleMarketTypeAndParams("fetchOrder",o,s),"spot"===a){const t=this.safeString(s,"clientOrderId");t||(i.orderId=e),n=void 0!==t?await this.privatePostSpotV4QueryClientOrder(this.extend(i,s)):await this.privatePostSpotV4QueryOrder(this.extend(i,s))}else if("swap"===a){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");const a=this.safeBool(s,"trailing",!1);let d=this.safeString(s,"orderType");s=this.omit(s,["orderType","trailing"]),a&&(d="trailing"),void 0!==d&&(i.type=d),i.symbol=o.id,i.order_id=e,n=await this.privateGetContractPrivateOrder(this.extend(i,s))}const d=this.safeDict(n,"data",{});return this.parseOrder(d,o)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};if("USDT"===e){const s=this.safeValue(this.options,"defaultNetworks"),r=this.safeStringUpper(s,e),a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network",r);o=this.safeString(a,o,o),void 0!==o&&(i.currency=i.currency+"-"+o,t=this.omit(t,"network"))}const r=await this.privateGetAccountV1DepositAddress(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"address"),r=this.safeString(e,"chain");let a;if(t=this.safeCurrency(s,t),void 0!==r){const e=r.split("-"),s=e.length,i=this.safeString(e,s-1);a=i===this.safeString(t,"name")?this.safeString(t,"code"):this.networkIdToCode(i)}return this.checkAddress(i),{info:e,currency:this.safeString(t,"code"),address:i,tag:this.safeString(e,"address_memo"),network:a}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={currency:a.id,amount:t,destination:"To Digital Address",address:s};if(void 0!==i&&(o.address_memo=i),"USDT"===e){const t=this.safeValue(this.options,"defaultNetworks"),s=this.safeStringUpper(t,e),i=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper(r,"network",s);a=this.safeString(i,a,a),void 0!==a&&(o.currency=o.currency+"-"+a,r=this.omit(r,"network"))}const n=await this.privatePostAccountV1WithdrawApply(this.extend(o,r)),d=this.safeValue(n,"data"),h=this.parseTransaction(d,a);return this.extend(h,{code:e,address:s,tag:i})}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets(),void 0===i&&(i=50);const a={operation_type:e,offset:1,N:i};let o;if(void 0!==t&&(o=this.currency(t),a.currency=o.id),"USDT"===t){const e=this.safeValue(this.options,"defaultNetworks"),s=this.safeStringUpper(e,t),i=this.safeValue(this.options,"networks",{});let n=this.safeStringUpper(r,"network",s);n=this.safeString(i,n,n),void 0!==n&&(a.currency+="-"+n,o.code=a.currency,r=this.omit(r,"network"))}const n=await this.privateGetAccountV2DepositWithdrawHistory(this.extend(a,r)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"records",[]);return this.parseTransactions(h,o,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetAccountV1DepositWithdrawDetail(this.extend(i,s)),a=this.safeValue(r,"data",{}),o=this.safeDict(a,"record",{});return this.parseTransaction(o)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetAccountV1DepositWithdrawDetail(this.extend(i,s)),a=this.safeValue(r,"data",{}),o=this.safeDict(a,"record",{});return this.parseTransaction(o)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdraw",e,t,s,i)}parseTransactionStatus(e){return this.safeString({0:"pending",1:"pending",2:"pending",3:"ok",4:"canceled",5:"failed"},e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"withdraw_id"),r=this.safeString(e,"deposit_id");let a;void 0!==i&&""!==i?(a="withdraw",s=i):void 0!==r&&""!==r&&(a="deposit",s=r);const o=this.safeNumber(e,"arrival_amount"),n=this.safeInteger(e,"apply_time"),d=this.safeString(e,"currency"),h=this.safeCurrencyCode(d,t),c=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"fee");let u;void 0!==l&&(u={cost:l,currency:h});const p=this.safeString(e,"tx_id");return{info:e,id:s,currency:h,amount:o,network:void 0,address:this.safeString(e,"address"),addressFrom:void 0,addressTo:void 0,tag:this.safeString(e,"address_memo"),tagFrom:void 0,tagTo:void 0,status:c,type:a,updated:void 0,txid:p,internal:void 0,comment:void 0,timestamp:0!==n?n:void 0,datetime:0!==n?this.iso8601(n):void 0,fee:u}}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(t,s)},n=await this.privatePostSpotV1MarginIsolatedRepay(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.parseMarginLoan(d,a);return this.extend(h,{amount:s,symbol:e})}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o={symbol:r.id,currency:a.id,amount:this.currencyToPrecision(t,s)},n=await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.parseMarginLoan(d,a);return this.extend(h,{amount:s,symbol:e})}parseMarginLoan(e,t=void 0){return{id:this.safeString2(e,"borrow_id","repay_id"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateGetSpotV1MarginIsolatedPairs(this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"symbols",[]),n=this.safeValue(o,0);return this.parseIsolatedBorrowRate(n,s)}parseIsolatedBorrowRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeValue(e,"base",{}),a=this.safeValue(e,"quote",{}),o=this.safeString(r,"currency"),n=this.safeString(a,"currency");return{symbol:i,base:this.safeCurrencyCode(o),baseRate:this.safeNumber(r,"hourly_interest"),quote:this.safeCurrencyCode(n),quoteRate:this.safeNumber(a,"hourly_interest"),period:36e5,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetSpotV1MarginIsolatedPairs(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]);return this.parseIsolatedBorrowRates(i)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n={amount:this.currencyToPrecision(e,t),currency:o.id},d=this.convertTypeToAccount(s),h=this.convertTypeToAccount(i);if("spot"===s)"margin"===i?(n.side="in",n.symbol=h):"swap"===i&&(n.type="spot_to_contract");else{if("spot"!==i)throw new r.ArgumentsRequired(this.id+" transfer() requires either fromAccount or toAccount to be spot");"margin"===s?(n.side="out",n.symbol=d):"swap"===s&&(n.type="contract_to_spot")}let c;"margin"===s||"margin"===i?c=await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(n,a)):"swap"!==s&&"swap"!==i||(c=await this.privatePostAccountV1TransferContract(this.extend(n,a)));const l=this.safeValue(c,"data",{});return this.extend(this.parseTransfer(l,o),{status:this.parseTransferStatus(this.safeString2(c,"code","message"))})}parseTransferStatus(e){return this.safeString({1e3:"ok",OK:"ok",FINISHED:"ok"},e,e)}parseTransferToAccount(e){return this.safeString({contract_to_spot:"spot",spot_to_contract:"swap"},e,e)}parseTransferFromAccount(e){return this.safeString({contract_to_spot:"swap",spot_to_contract:"spot"},e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"transfer_id"),timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseTransferFromAccount(this.safeString(e,"type")),toAccount:this.parseTransferToAccount(this.safeString(e,"type")),status:this.parseTransferStatus(this.safeString(e,"state"))}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),void 0===s&&(s=10);const r={page:this.safeInteger(i,"page",1),limit:s};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==t&&(r.time_start=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until"),n=this.safeInteger(i,"time_end",o);i=this.omit(i,["until"]),void 0!==n&&(r.time_end=n);const d=await this.privatePostAccountV1TransferContractList(this.extend(r,i)),h=this.safeValue(d,"data",{}),c=this.safeList(h,"records",[]);return this.parseTransfers(c,a,t,s)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchBorrowInterest() requires a symbol argument");await this.loadMarkets();const o=this.market(t),n={symbol:o.id};void 0!==i&&(n.N=i),void 0!==s&&(n.start_time=s);const d=await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(n,a)),h=this.safeValue(d,"data",{}),c=this.safeValue(h,"records",[]),l=this.parseBorrowInterests(c,o);return this.filterByCurrencySinceLimit(l,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"create_time");return{symbol:this.safeString(t,"symbol"),marginMode:"isolated",currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest_amount"),interestRate:this.safeNumber(e,"hourly_interest"),amountBorrowed:this.safeNumber(e,"borrow_amount"),timestamp:i,datetime:this.iso8601(i),info:e}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},a=await this.publicGetContractPublicOpenInterest(this.extend(i,t)),o=this.safeDict(a,"data",{});return this.parseOpenInterest(o,s)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol");return this.safeOpenInterest({symbol:this.safeSymbol(i,t),openInterestAmount:this.safeNumber(e,"open_interest"),openInterestValue:this.safeNumber(e,"open_interest_value"),timestamp:s,datetime:this.iso8601(s),info:e},t)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");let i;[i,s]=this.handleMarginModeAndParams("setLeverage",s),this.checkRequiredArgument("setLeverage",i,"marginMode",["isolated","cross"]),await this.loadMarkets();const a=this.market(t);if(!a.swap)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");const o={symbol:a.id,leverage:e.toString(),open_type:i};return await this.privatePostContractPrivateSubmitLeverage(this.extend(o,s))}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},a=await this.publicGetContractPublicFundingRate(this.extend(i,t)),o=this.safeValue(a,"data",{});return this.parseFundingRate(o,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:i,datetime:this.iso8601(i),fundingRate:this.safeNumber(e,"expected_rate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"rate_value"),previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateGetContractPrivatePosition(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeDict(a,0,{});return this.parsePosition(o,s)}async fetchPositions(e=void 0,t={}){let s,i;if(await this.loadMarkets(),void 0!==e){i=e.length;const t=this.safeString(e,0);s=this.market(t)}const r={};1===i&&(r.symbol=s.id);const a=await this.privateGetContractPrivatePosition(this.extend(r,t)),o=this.safeValue(a,"data",[]),n=[];for(let e=0;e<o.length;e++)n.push(this.parsePosition(o[e]));return e=this.marketSymbols(e),this.filterByArrayPositions(n,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeInteger(e,"timestamp"),o=this.safeInteger(e,"position_type"),n=this.safeString(e,"maintenance_margin"),d=this.safeString(e,"current_value"),h=this.safeString(e,"position_cross"),c=a.Y.stringDiv(n,d),l=a.Y.stringDiv(n,h);return this.safePosition({info:e,id:void 0,symbol:i,timestamp:r,datetime:this.iso8601(r),lastUpdateTimestamp:void 0,hedged:void 0,side:1===o?"long":"short",contracts:this.safeNumber(e,"current_amount"),contractSize:this.safeNumber(t,"contractSize"),entryPrice:this.safeNumber(e,"entry_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,notional:this.parseNumber(d),leverage:this.safeNumber(e,"leverage"),collateral:this.parseNumber(h),initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(n),maintenanceMarginPercentage:this.parseNumber(c),unrealizedPnl:this.safeNumber(e,"unrealized_value"),realizedPnl:this.safeNumber(e,"realized_value"),liquidationPrice:void 0,marginMode:void 0,percentage:void 0,marginRatio:this.parseNumber(l),stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyLiquidations() requires a symbol argument");await this.loadMarkets();const a=this.market(e);if(!a.swap)throw new r.NotSupported(this.id+" fetchMyLiquidations() supports swap markets only");let o={symbol:a.id};void 0!==t&&(o.start_time=t),[o,i]=this.handleUntilOption("end_time",o,i);const n=await this.privateGetContractPrivateOrderHistory(this.extend(o,i)),d=this.safeValue(n,"data",[]),h=[];for(let e=0;e<d.length;e++){const t=d[e];"liquidate"===this.safeString(t,"type")&&h.push(t)}return this.parseLiquidations(h,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"update_time"),r=this.safeString(e,"deal_size"),o=this.safeString(t,"contractSize"),n=this.safeString(e,"deal_avg_price"),d=a.Y.stringMul(r,o),h=a.Y.stringMul(d,n);return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.parseNumber(r),contractSize:this.parseNumber(o),price:this.parseNumber(n),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(h),timestamp:i,datetime:this.iso8601(i)})}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=e.split("/"),d=this.safeString(o,0,"spot"),h="spot"===d||"account"===d?"spot":"swap";let c=this.implodeHostname(this.urls.api[h])+"/"+this.implodeParams(e,i);const l=this.omit(i,this.extractParams(e));let u="";const p="GET"===s||"DELETE"===s;if(p&&Object.keys(l).length&&(u=this.urlencode(l),c+="?"+u),"private"===t){this.checkRequiredCredentials();const e=this.milliseconds().toString(),t=this.safeString(this.options,"brokerId","CCXTxBitmart000");r={"X-BM-KEY":this.apiKey,"X-BM-TIMESTAMP":e,"X-BM-BROKER-ID":t,"Content-Type":"application/json"},p||(u=a=this.json(l));const s=e+"#"+this.uid+"#"+u,i=this.hmac(this.encode(s),this.encode(this.secret),n.s);r["X-BM-SIGN"]=i}return{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeStringLower(n,"message"),l=void 0!==c&&"ok"!==c&&"success"!==c,u=this.safeString(n,"code");if(void 0!==u&&"1000"!==u||l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,u,e),this.throwBroadlyMatchedException(this.exceptions.broad,u,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}}},9523:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(8186),r=s(1579),a=s(2079),o=s(5147),n=s(4852),d=s(8995);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitmex",name:"BitMEX",countries:["SC"],version:"v1",userAgent:void 0,rateLimit:100,certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!0,option:!1,addMargin:void 0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!0,createOrder:!0,createReduceOnlyOrder:!0,createTrailingAmountOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDepositsWithdrawals:"emulated",fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:"emulated",fetchLeverages:!0,fetchLeverageTiers:!1,fetchLiquidations:!0,fetchMarginAdjustmentHistory:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,reduceMargin:void 0,sandbox:!0,setLeverage:!0,setMargin:void 0,setMarginMode:!0,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","1h":"1h","1d":"1d"},urls:{test:{public:"https://testnet.bitmex.com",private:"https://testnet.bitmex.com"},logo:"https://github.com/ccxt/ccxt/assets/43336371/cea9cfe5-c57e-4b84-b2ac-77b960b04445",api:{public:"https://www.bitmex.com",private:"https://www.bitmex.com"},www:"https://www.bitmex.com",doc:["https://www.bitmex.com/app/apiOverview","https://github.com/BitMEX/api-connectors/tree/master/official-http"],fees:"https://www.bitmex.com/app/fees",referral:{url:"https://www.bitmex.com/app/register/NZTR1q",discount:.1}},api:{public:{get:{announcement:5,"announcement/urgent":5,chat:5,"chat/channels":5,"chat/connected":5,"chat/pinned":5,funding:5,guild:5,instrument:5,"instrument/active":5,"instrument/activeAndIndices":5,"instrument/activeIntervals":5,"instrument/compositeIndex":5,"instrument/indices":5,"instrument/usdVolume":5,insurance:5,leaderboard:5,liquidation:5,"orderBook/L2":5,"porl/nonce":5,quote:5,"quote/bucketed":5,schema:5,"schema/websocketHelp":5,settlement:5,stats:5,"stats/history":5,"stats/historyUSD":5,trade:5,"trade/bucketed":5,"wallet/assets":5,"wallet/networks":5}},private:{get:{address:5,apiKey:5,execution:5,"execution/tradeHistory":5,globalNotification:5,"leaderboard/name":5,order:5,"porl/snapshots":5,position:5,user:5,"user/affiliateStatus":5,"user/checkReferralCode":5,"user/commission":5,"user/csa":5,"user/depositAddress":5,"user/executionHistory":5,"user/getWalletTransferAccounts":5,"user/margin":5,"user/quoteFillRatio":5,"user/quoteValueRatio":5,"user/staking":5,"user/staking/instruments":5,"user/staking/tiers":5,"user/tradingVolume":5,"user/unstakingRequests":5,"user/wallet":5,"user/walletHistory":5,"user/walletSummary":5,userAffiliates:5,userEvent:5},post:{address:5,chat:5,guild:5,"guild/archive":5,"guild/join":5,"guild/kick":5,"guild/leave":5,"guild/sharesTrades":5,order:1,"order/cancelAllAfter":5,"order/closePosition":5,"position/isolate":1,"position/leverage":1,"position/riskLimit":5,"position/transferMargin":1,"user/addSubaccount":5,"user/cancelWithdrawal":5,"user/communicationToken":5,"user/confirmEmail":5,"user/confirmWithdrawal":5,"user/logout":5,"user/preferences":5,"user/requestWithdrawal":5,"user/unstakingRequests":5,"user/updateSubaccount":5,"user/walletTransfer":5},put:{guild:5,order:1},delete:{order:1,"order/all":1,"user/unstakingRequests":5}}},exceptions:{exact:{"Invalid API Key.":a.AuthenticationError,"This key is disabled.":a.PermissionDenied,"Access Denied":a.PermissionDenied,"Duplicate clOrdID":a.InvalidOrder,"orderQty is invalid":a.InvalidOrder,"Invalid price":a.InvalidOrder,"Invalid stopPx for ordType":a.InvalidOrder,"Account is restricted":a.PermissionDenied},broad:{"Signature not valid":a.AuthenticationError,overloaded:a.ExchangeNotAvailable,"Account has insufficient Available Balance":a.InsufficientFunds,"Service unavailable":a.ExchangeNotAvailable,"Server Error":a.ExchangeError,"Unable to cancel order due to existing state":a.InvalidOrder,"We require all new traders to verify":a.PermissionDenied}},precisionMode:r.kb,options:{"api-expires":5,fetchOHLCVOpenTimestamp:!0,oldPrecision:!1,networks:{BTC:"btc",ERC20:"eth",BEP20:"bsc",TRC20:"tron",AVAXC:"avax",NEAR:"near",XTZ:"xtz",DOT:"dot",SOL:"sol",ADA:"ada"}},commonCurrencies:{USDt:"USDT",XBt:"BTC",XBT:"BTC",Gwei:"ETH",GWEI:"ETH",LAMP:"SOL",LAMp:"SOL"}})}async fetchCurrencies(e={}){const t=await this.publicGetWalletAssets(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),n=this.safeString(i,"currency"),d=this.safeString(i,"name"),h=this.safeValue(i,"networks",[]);let c=!1,l=!1;const u={},p=this.safeString(i,"scale"),f=this.parsePrecision(p),m=this.parseNumber(f);for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"asset"),i=this.networkIdToCode(s),r=this.safeString(t,"withdrawalFee"),a=this.parseNumber(o.Y.stringMul(r,f)),n=this.safeBool(t,"depositEnabled",!1),d=this.safeBool(t,"withdrawalEnabled",!1),p=n&&d;n&&(c=!0),d&&(l=!0),u[i]={info:t,id:s,network:i,active:p,deposit:n,withdraw:d,fee:a,precision:void 0,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}}}}const g=this.safeValue(i,"enabled")||c||l,v=this.safeString(i,"minWithdrawalAmount"),y=this.parseNumber(o.Y.stringMul(v,f)),w=this.safeString(i,"maxWithdrawalAmount"),b=this.parseNumber(o.Y.stringMul(w,f)),S=this.safeString(i,"minDepositAmount"),k=this.parseNumber(o.Y.stringMul(S,f));s[a]={id:n,code:a,info:i,name:d,active:g,deposit:c,withdraw:l,fee:void 0,precision:m,limits:{amount:{min:void 0,max:void 0},withdraw:{min:y,max:b},deposit:{min:k,max:void 0}},networks:u}}return s}convertFromRealAmount(e,t){const s=this.currency(e),i=this.safeString(s,"precision"),r=this.numberToString(t),a=o.Y.stringDiv(r,i);return this.parseNumber(a)}convertToRealAmount(e,t){if(void 0===e)return t;if(void 0===t)return;const s=this.currency(e),i=this.safeString(s,"precision");return o.Y.stringMul(t,i)}amountToPrecision(e,t){e=this.safeSymbol(e);const s=this.market(e),i=this.safeValue(this.options,"oldPrecision");return s.spot&&!i&&(t=this.convertFromRealAmount(s.base,t)),super.amountToPrecision(e,t)}convertFromRawQuantity(e,t,s="base"){if(this.safeValue(this.options,"oldPrecision"))return this.parseNumber(t);e=this.safeSymbol(e);if(!this.inArray(e,this.symbols))return this.parseNumber(t);const i=this.market(e);return i.spot?this.parseNumber(this.convertToRealAmount(i[s],t)):this.parseNumber(t)}convertFromRawCost(e,t){return this.convertFromRawQuantity(e,t,"quote")}async fetchMarkets(e={}){const t=await this.publicGetInstrumentActive(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"symbol");let s=this.safeString(e,"underlying"),i=this.safeString(e,"quoteCurrency");const r=this.safeString(e,"settlCurrency"),a=this.safeCurrencyCode(r),n=this.safeString(e,"typ");let d,h=!1,c=!1,l=!1;"FFWCSX"===n?(d="swap",h=!0):"IFXXXP"===n?(d="spot",c=!0):"FFCCSX"===n?(d="future",l=!0):"FFICSX"===n&&(i=s,s=this.safeString(e,"rootSymbol"),d="future",l=!0);const u=this.safeCurrencyCode(s),p=this.safeCurrencyCode(i),f=h||l;let m;const g=this.safeValue(e,"isInverse"),v=this.safeValue(e,"isQuanto"),y=f?!g&&!v:void 0,w="Unlisted"!==this.safeString(e,"state");let b,S,k;if(c)k=u+"/"+p;else if(f){if(k=u+"/"+p+":"+a,y){const t=this.safeString2(e,"underlyingToPositionMultiplier","underlyingToSettleMultiplier");m=this.parseNumber(o.Y.stringDiv("1",t))}else{const t=o.Y.stringAbs(this.safeString(e,"multiplier"));m=this.parseNumber(t)}l&&(S=this.safeString(e,"expiry"),b=this.parse8601(S),k=k+"-"+this.yymmdd(b))}else k=t;const O=this.safeString2(e,"positionCurrency","underlying"),T=this.safeCurrencyCode(O)===p,P=this.safeNumber(e,"maxOrderQty"),I=this.safeString(e,"initMargin","1"),x=this.parseNumber(o.Y.stringDiv("1",I));return{id:t,symbol:k,base:u,quote:p,settle:a,baseId:s,quoteId:i,settleId:r,type:d,spot:c,margin:!1,swap:h,future:l,option:!1,active:w,contract:f,linear:y,inverse:g,quanto:v,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:m,expiry:b,expiryDatetime:S,strike:this.safeNumber(e,"optionStrikePrice"),optionType:void 0,precision:{amount:this.safeNumber(e,"lotSize"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:f?this.parseNumber("1"):void 0,max:f?x:void 0},amount:{min:void 0,max:T?void 0:P},price:{min:void 0,max:this.safeNumber(e,"maxPrice")},cost:{min:void 0,max:T?P:void 0}},created:this.parse8601(this.safeString(e,"listing")),info:e}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account(),n=this.safeString(i,"availableMargin"),d=this.safeString(i,"marginBalance");o.free=this.convertToRealAmount(a,n),o.total=this.convertToRealAmount(a,d),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserMargin(this.extend({currency:"all"},e));return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.depth=t);const r=await this.publicGetOrderBookL2(this.extend(i,s)),a={symbol:e,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let t=0;t<r.length;t++){const s=r[t],i="Sell"===s.side?"asks":"bids",o=this.convertFromRawQuantity(e,this.safeString(s,"size")),n=this.safeNumber(s,"price");void 0!==n&&a[i].push([n,o])}return a.bids=this.sortBy(a.bids,0,!0),a.asks=this.sortBy(a.asks,0),a}async fetchOrder(e,t=void 0,s={}){const i={filter:{orderID:e}},r=await this.fetchOrders(t,void 0,void 0,this.deepExtend(i,s));if(1===r.length)return r[0];throw new a.OrderNotFound(this.id+": The order "+e+" not found.")}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchOrders",e,t,s,i,100);let o={};void 0!==e&&(r=this.market(e),o.symbol=r.id),void 0!==t&&(o.startTime=this.iso8601(t)),void 0!==s&&(o.count=s);const n=this.safeInteger2(i,"until","endTime");void 0!==n&&(i=this.omit(i,["until"]),o.endTime=this.iso8601(n)),o=this.deepExtend(o,i),"filter"in o&&(o.filter=this.json(o.filter));const d=await this.privateGetOrder(o);return this.parseOrders(d,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.deepExtend({filter:{open:!0}},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchOrders(e,t,s,i);return this.filterByArray(r,"status",["closed","canceled"],!1)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i,100);let o={};void 0!==e&&(r=this.market(e),o.symbol=r.id),void 0!==t&&(o.startTime=this.iso8601(t)),void 0!==s&&(o.count=s);const n=this.safeInteger2(i,"until","endTime");void 0!==n&&(i=this.omit(i,["until"]),o.endTime=this.iso8601(n)),o=this.deepExtend(o,i),"filter"in o&&(o.filter=this.json(o.filter));const d=await this.privateGetExecutionTradeHistory(o);return this.parseTrades(d,r,t,s)}parseLedgerEntryType(e){return this.safeString({Withdrawal:"transaction",RealisedPNL:"margin",UnrealisedPNL:"margin",Deposit:"transaction",Transfer:"transfer",AffiliatePayout:"referral",SpotTrade:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactID"),i=this.safeString(e,"account"),r=this.safeString(e,"tx"),a=this.parseLedgerEntryType(this.safeString(e,"transactType")),n=this.safeString(e,"currency"),d=this.safeCurrencyCode(n,t),h=this.safeString(e,"amount");let c=this.convertToRealAmount(d,h),l=this.parse8601(this.safeString(e,"transactTime"));void 0===l&&(l=0);let u=this.safeString(e,"fee");void 0!==u&&(u=this.convertToRealAmount(d,u));const p={cost:this.parseNumber(u),currency:d};let f=this.safeString(e,"walletBalance");void 0!==f&&(f=this.convertToRealAmount(d,f));const m=this.parseNumber(o.Y.stringSub(this.numberToString(f),this.numberToString(c)));let g;o.Y.stringLt(h,"0")?(g="out",c=this.convertToRealAmount(d,o.Y.stringAbs(h))):g="in";const v=this.parseTransactionStatus(this.safeString(e,"transactStatus"));return{id:s,info:e,timestamp:l,datetime:this.iso8601(l),direction:g,account:i,referenceId:r,referenceAccount:undefined,type:a,currency:d,amount:c,before:m,after:this.parseNumber(f),status:v,fee:p}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==s&&(r.count=s),void 0!==e&&(a=this.currency(e),r.currency=a.id);const o=await this.privateGetUserWalletHistory(this.extend(r,i));return this.parseLedger(o,a,t,s)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={currency:"all"};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.count=s);const o=await this.privateGetUserWalletHistory(this.extend(r,i)),n=this.filterByArray(o,"transactType",["Withdrawal","Deposit"],!1);return this.parseTransactions(n,a,t,s)}parseTransactionStatus(e){return this.safeString({Confirmed:"pending",Canceled:"canceled",Completed:"ok",Pending:"pending"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency");t=this.safeCurrency(s,t);const i=this.parse8601(this.safeString(e,"transactTime")),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeStringLower(e,"transactType");let n,d,h;"withdrawal"===a?(n=this.safeString(e,"address"),d=this.safeString(e,"tx"),h=n):"deposit"===a&&(h=this.safeString(e,"address"),d=this.safeString(e,"tx"));const c=this.safeString(e,"amount"),l=o.Y.stringAbs(c),u=this.convertToRealAmount(t.code,l),p=this.safeString(e,"fee"),f=this.convertToRealAmount(t.code,p);let m=this.safeString(e,"transactStatus");return void 0!==m&&(m=this.parseTransactionStatus(m)),{info:e,id:this.safeString(e,"transactID"),txid:this.safeString(e,"tx"),type:a,currency:t.code,network:this.networkIdToCode(this.safeString(e,"network"),t.code),amount:this.parseNumber(u),status:m,timestamp:i,datetime:this.iso8601(i),address:n,addressFrom:d,addressTo:h,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:r,internal:void 0,comment:void 0,fee:{currency:t.code,cost:this.parseNumber(f),rate:void 0}}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetInstrument(this.extend(i,t)),o=this.safeValue(r,0);if(void 0===o)throw new a.BadSymbol(this.id+" fetchTicker() symbol "+e+" not found");return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetInstrumentActiveAndIndices(t),i={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]),r=this.safeString(t,"symbol");void 0!==r&&(i[r]=t)}return this.filterByArrayTickers(i,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString(e,"prevPrice24h"),o=this.safeString(e,"lastPrice");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:void 0,ask:this.safeString(e,"askPrice"),askVolume:void 0,vwap:this.safeString(e,"vwap"),open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"homeNotional24h"),quoteVolume:this.safeString(e,"foreignNotional24h"),info:e},t)}parseOHLCV(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.convertFromRawQuantity(t.symbol,this.safeString(e,"volume"));return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),i]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r);const o=this.market(e),n={symbol:o.id,binSize:this.safeString(this.timeframes,t,t),partial:!0};void 0!==i&&(n.count=i);const d=this.safeInteger2(r,"until","endTime");void 0!==d&&(r=this.omit(r,["until"]),n.endTime=this.iso8601(d));const h=1e3*this.parseTimeframe(t),c=this.safeBool(this.options,"fetchOHLCVOpenTimestamp",!0);if(void 0!==s){let e=s;c&&(e=this.sum(e,h));const t=this.iso8601(e);n.startTime=t}else n.reverse=!0;const l=await this.publicGetTradeBucketed(this.extend(n,r)),u=this.parseOHLCVs(l,o,t,s,i);if(c)for(let e=0;e<u.length;e++)u[e][0]=u[e][0]-h;return u}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString2(e,"avgPx","price"),n=this.convertFromRawQuantity(i,this.safeString2(e,"size","lastQty")),d=this.numberToString(this.convertFromRawCost(i,this.safeString(e,"execCost"))),h=this.safeString(e,"trdMatchID"),c=this.safeString(e,"orderID"),l=this.safeStringLower(e,"side");let u;const p=this.numberToString(this.convertFromRawCost(i,this.safeString(e,"execComm")));if(void 0!==p){const t=this.safeString2(e,"settlCurrency","currency");u={cost:p,currency:this.safeCurrencyCode(t),rate:this.safeString(e,"commission")}}const f=this.safeString(e,"execType");let m;void 0!==p&&"Trade"===f&&(m=o.Y.stringLt(p,"0")?"maker":"taker");const g=this.safeStringLower(e,"ordType");return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:i,id:h,order:c,type:g,takerOrMaker:m,side:l,price:a,cost:o.Y.stringAbs(d),amount:n,fee:u},t)}parseOrderStatus(e){return this.safeString({New:"open",PartiallyFilled:"open",Filled:"closed",DoneForDay:"open",Canceled:"canceled",PendingCancel:"open",PendingNew:"open",Rejected:"rejected",Expired:"expired",Stopped:"open",Untriggered:"open",Triggered:"open"},e,e)}parseTimeInForce(e){return this.safeString({Day:"Day",GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString(e,"orderQty");let a,n,d=!1;if(void 0===s){d="inverse"===this.safeString(this.options,"defaultSubType","linear")}else d=this.safeBool(t,"inverse",!1);d?a=this.convertFromRawQuantity(i,r):n=this.convertFromRawQuantity(i,r);const h=this.safeString(e,"avgPx");let c;const l=this.numberToString(this.convertFromRawQuantity(i,this.safeString(e,"cumQty")));c=d?o.Y.stringDiv(l,h):l;const u=this.safeString(e,"execInst");let p;void 0!==u&&(p="ParticipateDoNotInitiate"===u);const f=this.parse8601(this.safeString(e,"timestamp")),m=this.safeNumber(e,"stopPx"),g=this.safeString(e,"leavesQty");return this.safeOrder({info:e,id:this.safeString(e,"orderID"),clientOrderId:this.safeString(e,"clOrdID"),timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:this.parse8601(this.safeString(e,"transactTime")),symbol:i,type:this.safeStringLower(e,"ordType"),timeInForce:this.parseTimeInForce(this.safeString(e,"timeInForce")),postOnly:p,side:this.safeStringLower(e,"side"),price:this.safeString(e,"price"),stopPrice:m,triggerPrice:m,amount:n,cost:a,average:h,filled:c,remaining:this.convertFromRawQuantity(i,g),status:this.parseOrderStatus(this.safeString(e,"ordStatus")),fee:void 0,trades:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);const a=this.market(e),o={symbol:a.id};void 0!==t?o.startTime=this.iso8601(t):o.reverse=!0,void 0!==s&&(o.count=Math.min(s,1e3));const n=this.safeInteger2(i,"until","endTime");void 0!==n&&(i=this.omit(i,["until"]),o.endTime=this.iso8601(n));const d=await this.publicGetTrade(this.extend(o,i));return this.parseTrades(d,a,t,s)}async createOrder(e,t,s,i,r=void 0,o={}){await this.loadMarkets();const n=this.market(e);let d=this.capitalize(t);if(void 0!==this.safeValue(o,"reduceOnly")&&!n.swap&&!n.future)throw new a.InvalidOrder(this.id+" createOrder() does not support reduceOnly for "+n.type+" orders, reduceOnly orders are supported for swap and future markets only");const h=this.safeString(this.options,"brokerId","CCXT"),c=this.parseToInt(this.amountToPrecision(e,i)),l={symbol:n.id,side:this.capitalize(s),orderQty:c,ordType:d,text:h},u=this.safeNumberN(o,["triggerPrice","stopPx","stopPrice"]);let p=this.safeString2(o,"trailingAmount","pegOffsetValue");const f=void 0!==p;if(void 0!==u||f){const i=this.safeString(o,"triggerDirection"),r="above"===i;if("limit"!==t&&"market"!==t||this.checkRequiredArgument("createOrder",i,"triggerDirection",["above","below"]),"limit"===t?d="buy"===s?r?"StopLimit":"LimitIfTouched":r?"LimitIfTouched":"StopLimit":"market"===t&&(d="buy"===s?r?"Stop":"MarketIfTouched":r?"MarketIfTouched":"Stop"),f){("sell"===s&&("Stop"===d||"StopLimit"===d)||"buy"===s&&("MarketIfTouched"===d||"LimitIfTouched"===d))&&(p="-"+p),l.pegOffsetValue=this.parseToNumeric(p),l.pegPriceType="TrailingStopPeg"}else{if(void 0===u)throw new a.ArgumentsRequired(this.id+" createOrder() requires a triggerPrice (stopPx|stopPrice) parameter for the "+d+" order type");l.stopPx=this.parseToNumeric(this.priceToPrecision(e,u))}l.ordType=d,o=this.omit(o,["triggerPrice","stopPrice","stopPx","triggerDirection","trailingAmount"])}"Limit"!==d&&"StopLimit"!==d&&"LimitIfTouched"!==d||(l.price=this.parseToNumeric(this.priceToPrecision(e,r)));const m=this.safeString2(o,"clOrdID","clientOrderId");void 0!==m&&(l.clOrdID=m,o=this.omit(o,["clOrdID","clientOrderId"]));const g=await this.privatePostOrder(this.extend(l,o));return this.parseOrder(g,n)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n={};let d=this.safeString2(o,"trailingAmount","pegOffsetValue");if(void 0!==d){const e=this.safeString(o,"triggerDirection"),t="above"===e;let r;"limit"!==s&&"market"!==s||this.checkRequiredArgument("createOrder",e,"triggerDirection",["above","below"]),"limit"===s?r="buy"===i?t?"StopLimit":"LimitIfTouched":t?"LimitIfTouched":"StopLimit":"market"===s&&(r="buy"===i?t?"Stop":"MarketIfTouched":t?"MarketIfTouched":"Stop");("sell"===i&&("Stop"===r||"StopLimit"===r)||"buy"===i&&("MarketIfTouched"===r||"LimitIfTouched"===r))&&(d="-"+d),n.pegOffsetValue=this.parseToNumeric(d),o=this.omit(o,["triggerDirection","trailingAmount"])}const h=this.safeString2(o,"origClOrdID","clientOrderId");if(void 0!==h){n.origClOrdID=h;const e=this.safeString(o,"clOrdID","clientOrderId");void 0!==e&&(n.clOrdID=e),o=this.omit(o,["origClOrdID","clOrdID","clientOrderId"])}else n.orderID=e;if(void 0!==r){const e=this.parseToInt(this.amountToPrecision(t,r));n.orderQty=e}void 0!==a&&(n.price=a);const c=this.safeString(this.options,"brokerId","CCXT");n.text=c;const l=await this.privatePutOrder(this.extend(n,o));return this.parseOrder(l)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),r={};void 0===i?r.orderID=e:(r.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const o=await this.privateDeleteOrder(this.extend(r,s)),n=this.safeValue(o,0,{}),d=this.safeString(n,"error");if(void 0!==d&&d.indexOf("Unable to cancel order due to existing state")>=0)throw new a.OrderNotFound(this.id+" cancelOrder() failed: "+d);return this.parseOrder(n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clOrdID","clientOrderId"),r={};void 0===i?r.orderID=e:(r.clOrdID=i,s=this.omit(s,["clOrdID","clientOrderId"]));const a=await this.privateDeleteOrder(this.extend(r,s));return this.parseOrders(a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;void 0!==e&&(i=this.market(e),s.symbol=i.id);const r=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(r,i)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={timeout:e>0?this.parseToInt(e/1e3):0};return await this.privatePostOrderCancelAllAfter(this.extend(s,t))}async fetchLeverages(e=void 0,t={}){await this.loadMarkets();const s=await this.fetchPositions(e,t);return this.parseLeverages(s,e,"symbol")}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"marginMode"),longLeverage:this.safeInteger(e,"leverage"),shortLeverage:this.safeInteger(e,"leverage")}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPosition(t),i=this.parsePositions(s,e);return this.filterByArrayPositions(i,"symbol",e,!1)}parsePosition(e,t=void 0){const s=(t=this.safeMarket(this.safeString(e,"symbol"),t)).symbol,i=this.safeString(e,"timestamp"),r=!0===this.safeValue(e,"crossMargin")?"cross":"isolated",a=o.Y.stringAbs(this.safeString2(e,"foreignNotional","homeNotional")),n=this.safeString(t,"settle"),d=this.convertToRealAmount(n,this.safeString(e,"maintMargin")),h=this.convertToRealAmount(n,this.safeString(e,"unrealisedPnl")),c=this.parseNumber(o.Y.stringAbs(this.safeString(e,"currentQty"))),l=this.safeNumber(t,"contractSize");let u;const p=this.safeString(e,"homeNotional");return void 0!==p&&(u="-"===p[0]?"short":"long"),this.safePosition({info:e,id:this.safeString(e,"account"),symbol:s,timestamp:this.parse8601(i),datetime:i,lastUpdateTimestamp:void 0,hedged:void 0,side:u,contracts:c,contractSize:l,entryPrice:this.safeNumber(e,"avgEntryPrice"),markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,notional:this.parseNumber(a),leverage:this.safeNumber(e,"leverage"),collateral:void 0,initialMargin:this.safeNumber(e,"initMargin"),initialMarginPercentage:this.safeNumber(e,"initMarginReq"),maintenanceMargin:d,maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),unrealizedPnl:h,liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:r,marginRatio:void 0,percentage:this.safeNumber(e,"unrealisedPnlPcnt"),stopLossPrice:void 0,takeProfitPrice:void 0})}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o=this.convertFromRealAmount(e,t);let n;[n,r]=this.handleNetworkCodeAndParams(r);const h={currency:a.id,amount:o,address:s,network:this.networkCodeToId(n,a.code)};void 0!==this.twofa&&(h.otpToken=(0,d.O)(this.twofa));const c=await this.privatePostUserRequestWithdrawal(this.extend(h,r));return this.parseTransaction(c,a)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetInstrumentActiveAndIndices(t),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeMarket(r);this.safeBool(a,"swap",!1)&&i.push(t)}e=this.marketSymbols(e);const r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"symbol"),r=this.safeString(e,"fundingTimestamp");return{info:e,symbol:this.safeSymbol(i,t),markPrice:this.safeNumber(e,"markPrice"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:this.safeNumber(e,"indicativeSettlePrice"),timestamp:this.parse8601(s),datetime:s,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:this.iso8601(r),fundingDatetime:r,nextFundingRate:this.safeNumber(e,"indicativeFundingRate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;if(e in this.currencies){const t=this.currency(e);r.symbol=t.id}else if(void 0!==e){const t=e.split(":"),s=["nearest","daily","weekly","monthly","quarterly","biquarterly","perpetual"];if(t.length>1&&this.inArray(t[1],s)){e=this.currency(t[0]).id+":"+t[1],r.symbol=e}else a=this.market(e),r.symbol=a.id}void 0!==t&&(r.startTime=this.iso8601(t)),void 0!==s&&(r.count=s);const o=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==o&&(r.endTime=this.iso8601(o)),void 0===t&&void 0===o&&(r.reverse=!0);const n=await this.publicGetFunding(this.extend(r,i));return this.parseFundingRateHistories(n,a,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t),fundingRate:this.safeNumber(e,"fundingRate"),timestamp:this.parse8601(i),datetime:i}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<.01||e>100)throw new a.BadRequest(this.id+" leverage should be between 0.01 and 100");await this.loadMarkets();const i=this.market(t);if("swap"!==i.type&&"future"!==i.type)throw new a.BadSymbol(this.id+" setLeverage() supports future and swap contracts only");const r={symbol:i.id,leverage:e};return await this.privatePostPositionLeverage(this.extend(r,s))}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("isolated"!==(e=e.toLowerCase())&&"cross"!==e)throw new a.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if("swap"!==i.type&&"future"!==i.type)throw new a.BadSymbol(this.id+" setMarginMode() supports swap and future contracts only");const r="cross"!==e,o={symbol:i.id,enabled:r};return await this.privatePostPositionIsolate(this.extend(o,s))}async fetchDepositAddress(e,t={}){let s;if(await this.loadMarkets(),[s,t]=this.handleNetworkCodeAndParams(t),void 0===s)throw new a.ArgumentsRequired(this.id+' fetchDepositAddress requires params["network"]');const i=this.currency(e);t=this.omit(t,"network");const r={currency:i.id,network:this.networkCodeToId(s,i.code)},o=await this.privateGetUserDepositAddress(this.extend(r,t));return{currency:e,address:o.replace('"',"").replace('"',""),tag:void 0,network:s,info:o}}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networks",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(0!==i){const a=this.safeString(e,"scale"),n=this.parsePrecision(a);for(let e=0;e<i;e++){const a=s[e],d=this.safeString(a,"asset"),h=this.safeString(t,"code"),c=this.networkIdToCode(d,h),l=this.safeString(a,"withdrawalFee"),u=this.parseNumber(o.Y.stringMul(l,n));r.networks[c]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:u,percentage:!1}},1===i&&(r.withdraw.fee=u,r.withdraw.percentage=!1)}}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetWalletAssets(t);return this.parseDepositWithdrawFees(s,e,"asset")}calculateRateLimiterCost(e,t,s,i,r={}){const a=this.checkRequiredCredentials(!1),o=this.safeValue(r,"cost",1);return 1!==o?a?o:20:o}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLiquidations","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchLiquidations",e,t,s,i);const a=this.market(e);let o={symbol:a.id};void 0!==t&&(o.startTime=t),void 0!==s&&(o.count=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.publicGetLiquidation(this.extend(o,i));return this.parseLiquidations(n,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol");return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"price"),baseValue:void 0,quoteValue:void 0,timestamp:void 0,datetime:void 0})}handleErrors(e,t,s,i,r,o,n,d,h){if(void 0!==n){if(429===e)throw new a.DDoSProtection(this.id+" "+o);if(e>=400){const t=this.safeValue(n,"error",{}),s=this.safeString(t,"message"),i=this.id+" "+o;if(this.throwExactlyMatchedException(this.exceptions.exact,s,i),this.throwBroadlyMatchedException(this.exceptions.broad,s,i),400===e)throw new a.BadRequest(i);throw new a.ExchangeError(i)}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/api/"+this.version+"/"+e;if("GET"===s)Object.keys(i).length&&(o+="?"+this.urlencode(i));else{const e=this.safeString(i,"_format");void 0!==e&&(o+="?"+this.urlencode({_format:e}),i=this.omit(i,"_format"))}const d=this.urls.api[t]+o,h=this.checkRequiredCredentials(!1);if("private"===t||"public"===t&&h){this.checkRequiredCredentials();let e=s+o,t=this.safeInteger(this.options,"api-expires");r={"Content-Type":"application/json","api-key":this.apiKey},t=this.sum(this.seconds(),t);const d=t.toString();e+=d,r["api-expires"]=d,"POST"!==s&&"PUT"!==s&&"DELETE"!==s||Object.keys(i).length&&(e+=a=this.json(i)),r["api-signature"]=this.hmac(this.encode(e),this.encode(this.secret),n.s)}return{url:d,method:s,body:a,headers:r}}}},2753:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7202),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitopro",name:"BitoPro",countries:["TW"],version:"v3",rateLimit:100,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","3h":"3h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/158227251-3a92a220-9222-453c-9277-977c6677fe71.jpg",api:{rest:"https://api.bitopro.com/v3"},www:"https://www.bitopro.com",doc:["https://github.com/bitoex/bitopro-offical-api-docs/blob/master/v3-1/rest-1/rest.md"],fees:"https://www.bitopro.com/fees"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{"order-book/{pair}":1,tickers:1,"tickers/{pair}":1,"trades/{pair}":1,"provisioning/currencies":1,"provisioning/trading-pairs":1,"provisioning/limitations-and-fees":1,"trading-history/{pair}":1,"price/otc/{currency}":1}},private:{get:{"accounts/balance":1,"orders/history":1,"orders/all/{pair}":1,"orders/trades/{pair}":1,"orders/{pair}/{orderId}":1,"wallet/withdraw/{currency}/{serial}":1,"wallet/withdraw/{currency}/id/{id}":1,"wallet/depositHistory/{currency}":1,"wallet/withdrawHistory/{currency}":1},post:{"orders/{pair}":.5,"orders/batch":20/3,"wallet/withdraw/{currency}":10},put:{orders:5},delete:{"orders/{pair}/{id}":2/3,"orders/all":5,"orders/{pair}":5}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("3000000"),this.parseNumber("0.00194")],[this.parseNumber("5000000"),this.parseNumber("0.0015")],[this.parseNumber("30000000"),this.parseNumber("0.0014")],[this.parseNumber("300000000"),this.parseNumber("0.0013")],[this.parseNumber("550000000"),this.parseNumber("0.0012")],[this.parseNumber("1300000000"),this.parseNumber("0.0011")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("3000000"),this.parseNumber("0.00097")],[this.parseNumber("5000000"),this.parseNumber("0.0007")],[this.parseNumber("30000000"),this.parseNumber("0.0006")],[this.parseNumber("300000000"),this.parseNumber("0.0005")],[this.parseNumber("550000000"),this.parseNumber("0.0004")],[this.parseNumber("1300000000"),this.parseNumber("0.0003")]]}}},options:{networks:{ERC20:"ERC20",ETH:"ERC20",TRX:"TRX",TRC20:"TRX",BEP20:"BSC",BSC:"BSC"}},precisionMode:o.kb,exceptions:{exact:{"Unsupported currency.":r.BadRequest,"Unsupported order type":r.BadRequest,"Invalid body":r.BadRequest,"Invalid Signature":r.AuthenticationError,"Address not in whitelist.":r.BadRequest},broad:{"Invalid amount":r.InvalidOrder,"Balance for ":r.InsufficientFunds,"Invalid ":r.BadRequest,"Wrong parameter":r.BadRequest}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetProvisioningCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.safeValue(t,"deposit"),n=this.safeValue(t,"withdraw"),d=this.safeNumber(t,"withdrawFee"),h={withdraw:{min:this.safeNumber(t,"minWithdraw"),max:this.safeNumber(t,"maxWithdraw")},amount:{min:void 0,max:void 0}};i[a]={id:r,code:a,info:t,type:void 0,name:void 0,active:o&&n,deposit:o,withdraw:n,fee:d,precision:void 0,limits:h}}return i}async fetchMarkets(e={}){const t=await this.publicGetProvisioningTradingPairs(),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=!this.safeValue(e,"maintain"),s=this.safeString(e,"pair"),i=s.toUpperCase(),r=this.safeString(e,"base"),a=this.safeString(e,"quote"),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a);return{id:s,uppercaseId:i,symbol:o+"/"+n,base:o,quote:n,baseId:o,quoteId:n,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:{amount:{min:this.safeNumber(e,"minLimitBaseAmount"),max:this.safeNumber(e,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}},precision:{price:this.parseNumber(this.parsePrecision(this.safeString(e,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(e,"basePrecision")))},active:t,created:void 0,info:e}}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=this.safeString(t,"symbol");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high24hr"),low:this.safeString(e,"low24hr"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"lastPrice"),last:this.safeString(e,"lastPrice"),previousClose:void 0,change:void 0,percentage:this.safeString(e,"priceChange24hr"),average:void 0,baseVolume:this.safeString(e,"volume24hr"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTickersPair(this.extend(i,t)),a=this.safeValue(r,"data",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(),i=this.safeValue(s,"data",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id};void 0!==t&&(r.limit=t);const a=await this.publicGetOrderBookPair(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","amount")}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"orderId");let r;r=void 0===s?this.safeTimestamp(e,"timestamp"):this.safeInteger(e,"timestamp");const a=this.safeString(e,"pair");t=this.safeMarket(a,t);const o=this.safeString(t,"symbol"),n=this.safeString(e,"price"),d=this.safeStringLower(e,"type");let h=this.safeStringLower(e,"action");if(void 0===h){h=this.safeValue(e,"isBuyer")?"buy":"sell"}let c,l=this.safeString(e,"amount");void 0===l&&(l=this.safeString(e,"baseAmount"));const u=this.safeString(e,"fee"),p=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));void 0!==u&&(c={cost:u,currency:p,rate:void 0});const f=this.safeValue(e,"isTaker");let m;return void 0!==f&&(m=f?"taker":"maker"),this.safeTrade({id:s,info:e,order:i,timestamp:r,datetime:this.iso8601(r),symbol:o,takerOrMaker:m,type:d,side:h,price:n,amount:l,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTradesPair(this.extend(a,i)),n=this.safeValue(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetProvisioningLimitationsAndFees(e),s=this.safeValue(t,"tradingFeeRate",{}),i=this.safeValue(s,0),r={},a=this.safeNumber(i,"makerFee"),o=this.safeNumber(i,"takerFee");for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e];r[t]={info:i,symbol:t,maker:a,taker:o,percentage:!0,tierBased:!0}}return r}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t,t),n={pair:a.id,resolution:o};i=void 0===i?500:Math.min(i,75e3);const d=this.parseTimeframe(t);let h;if(void 0===s)n.to=this.seconds(),n.from=n.to-i*d;else{const e=1e3*d;h=Math.floor(s/e)*e,n.from=Math.floor(s/1e3),n.to=this.sum(n.from,i*d)}const c=await this.publicGetTradingHistoryPair(this.extend(n,r)),l=this.safeValue(c,"data",[]),u=this.parseOHLCVs(l,a,t,s,i);return this.insertMissingCandles(u,d,h,i)}insertMissingCandles(e,t,s,i){if(0===e.length)return e;const r=[];let a,o=e[0];a=void 0===s?o[0]:s;let n=0;const d=e.length;let h=0;for(;h<i&&n<d;){const s=e[n];if(s[0]===a)r.push(s),n=this.sum(n,1);else{const e=this.arrayConcat([],o);e[0]=a,e[1]=e[4],e[2]=e[4],e[3]=e[4],e[5]=this.parseNumber("0"),r.push(e)}a=this.sum(a,1e3*t),h=r.length,o=r[h-1]}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(i,"amount"),n={free:this.safeString(i,"available"),total:o};t[a]=n}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e),s=this.safeValue(t,"data",[]);return this.parseBalance(s)}parseOrderStatus(e){return this.safeString({"-1":"open",0:"open",1:"open",2:"closed",3:"closed",4:"canceled",6:"canceled"},e,void 0)}parseOrder(e,t=void 0){const s=this.safeString2(e,"id","orderId"),i=this.safeInteger2(e,"timestamp","createdTimestamp");let r=this.safeString(e,"action");r=r.toLowerCase();const o=this.safeString2(e,"amount","originalAmount"),n=this.safeString(e,"price"),d=this.safeString(e,"pair");t=this.safeMarket(d,t,"_");const h=this.safeString(t,"symbol"),c=this.safeString(e,"status"),l=this.parseOrderStatus(c),u=this.safeStringLower(e,"type"),p=this.safeString(e,"avgExecutionPrice"),f=this.safeString(e,"executedAmount"),m=this.safeString(e,"remainingAmount"),g=this.safeString(e,"timeInForce");let v,y;"POST_ONLY"===g&&(v=!0);const w=this.safeString(e,"fee"),b=this.safeCurrencyCode(this.safeString(e,"feeSymbol"));return a.Y.stringGt(w,"0")&&(y={currency:b,cost:w}),this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"updatedTimestamp"),symbol:h,type:u,timeInForce:g,postOnly:v,side:r,price:n,stopPrice:void 0,triggerPrice:void 0,amount:o,cost:void 0,average:p,filled:f,remaining:m,status:l,fee:y,trades:void 0,info:e},t)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={type:t,pair:n.id,action:s,amount:this.amountToPrecision(e,i),timestamp:this.milliseconds()},h=t.toUpperCase();if("LIMIT"===h&&(d.price=this.priceToPrecision(e,a)),"STOP_LIMIT"===h){d.price=this.priceToPrecision(e,a);const t=this.safeValue2(o,"triggerPrice","stopPrice");if(o=this.omit(o,["triggerPrice","stopPrice"]),void 0===t)throw new r.InvalidOrder(this.id+" createOrder() requires a stopPrice parameter for "+h+" orders");d.stopPrice=this.priceToPrecision(e,t);const s=this.safeString(o,"condition");if(void 0===s)throw new r.InvalidOrder(this.id+" createOrder() requires a condition parameter for "+h+" orders");d.condition=s}this.isPostOnly("MARKET"===h,void 0,o)&&(d.timeInForce="POST_ONLY");const c=await this.privatePostOrdersPair(this.extend(d,o));return this.parseOrder(c,n)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={id:e,pair:i.id},o=await this.privateDeleteOrdersPairId(this.extend(a,s));return this.parseOrder(o,i)}parseCancelOrders(e){const t=Object.keys(e),s=[];for(let i=0;i<t.length;i++){const r=t[i],a=e[r];for(let e=0;e<a.length;e++)s.push(this.safeOrder({info:a[e],id:a[e],symbol:this.safeSymbol(r)}))}return s}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i={};i[this.market(t).uppercaseId]=e;const a=await this.privatePutOrders(this.extend(i,s)),o=this.safeDict(a,"data");return this.parseCancelOrders(o)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(void 0!==e){const r=this.market(e);s.pair=r.id,i=await this.privateDeleteOrdersPair(this.extend(s,t))}else i=await this.privateDeleteOrdersAll(this.extend(s,t));const r=this.safeValue(i,"data",{});return this.parseCancelOrders(r)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={orderId:e,pair:i.id},o=await this.privateGetOrdersPairOrderId(this.extend(a,s));return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id};void 0!==t&&(o.startTimestamp=t),void 0!==s&&(o.limit=s);const n=await this.privateGetOrdersAllPair(this.extend(o,i));let d=this.safeValue(n,"data");return void 0===d&&(d=[]),this.parseOrders(d,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({statusKind:"OPEN"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return this.fetchOrders(e,t,s,this.extend({statusKind:"DONE"},i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id},n=await this.privateGetOrdersTradesPair(this.extend(o,i)),d=this.safeValue(n,"data",[]);return this.parseTrades(d,a,t,s)}parseTransactionStatus(e){return this.safeString({COMPLETE:"ok",INVALID:"failed",PROCESSING:"pending",WAIT_PROCESS:"pending",FAILED:"failed",EXPIRED:"failed",CANCELLED:"failed",EMAIL_VERIFICATION:"pending",WAIT_CONFIRMATION:"pending"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"address"),o=this.safeString(e,"message"),n=this.safeString(e,"status");let d=this.safeString(e,"protocol");return"MAIN"===d&&(d=i),{info:e,id:this.safeString(e,"serial"),txid:this.safeString(e,"txid"),type:void 0,currency:i,network:this.networkIdToCode(d),amount:this.safeNumber(e,"total"),status:this.parseTransactionStatus(n),timestamp:r,datetime:this.iso8601(r),address:a,addressFrom:void 0,addressTo:a,tag:o,tagFrom:void 0,tagTo:o,updated:void 0,comment:void 0,internal:void 0,fee:{currency:i,cost:this.safeNumber(e,"fee"),rate:void 0}}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires the code argument");await this.loadMarkets();const a=this.safeCurrency(e),o={currency:a.id};void 0!==t&&(o.startTimestamp=t),void 0!==s&&(o.limit=s);const n=await this.privateGetWalletDepositHistoryCurrency(this.extend(o,i)),d=this.safeValue(n,"data",[]);return this.parseTransactions(d,a,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchWithdrawals() requires the code argument");await this.loadMarkets();const a=this.safeCurrency(e),o={currency:a.id};void 0!==t&&(o.startTimestamp=t),void 0!==s&&(o.limit=s);const n=await this.privateGetWalletWithdrawHistoryCurrency(this.extend(o,i)),d=this.safeValue(n,"data",[]);return this.parseTransactions(d,a,t,s,{type:"withdrawal"})}async fetchWithdrawal(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchWithdrawal() requires the code argument");await this.loadMarkets();const i=this.safeCurrency(t),a={serial:e,currency:i.id},o=await this.privateGetWalletWithdrawCurrencySerial(this.extend(a,s)),n=this.safeValue(o,"data",{});return this.parseTransaction(n,i)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),await this.loadMarkets(),this.checkAddress(s);const o=this.currency(e),n={currency:o.id,amount:this.numberToString(t),address:s};if("network"in a){const e=this.safeValue(this.options,"networks",{}),t=this.safeStringUpper(a,"network");a=this.omit(a,["network"]);const s=this.safeString(e,t);if(void 0===s)throw new r.ExchangeError(this.id+" invalid network "+t);n.protocol=s}void 0!==i&&(n.message=i);const d=await this.privatePostWalletWithdrawCurrency(this.extend(n,a)),h=this.safeValue(d,"data",{});return this.parseTransaction(h,o)}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdrawFee"),percentage:!1},deposit:{fee:void 0,percentage:void 0},networks:{}}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetProvisioningCurrencies(t),i=this.safeList(s,"data",[]);return this.parseDepositWithdrawFees(i,e,"currency")}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if(void 0===r&&(r={}),r["X-BITOPRO-API"]="ccxt","private"===t){if(this.checkRequiredCredentials(),"POST"===s||"PUT"===s){a=this.json(i);const e=this.stringToBase64(a),t=this.hmac(this.encode(e),this.encode(this.secret),n.qt);r["X-BITOPRO-APIKEY"]=this.apiKey,r["X-BITOPRO-PAYLOAD"]=e,r["X-BITOPRO-SIGNATURE"]=t}else if("GET"===s||"DELETE"===s){Object.keys(d).length&&(o+="?"+this.urlencode(d));const e={nonce:this.milliseconds()},t=this.json(e),s=this.stringToBase64(t),i=this.hmac(this.encode(s),this.encode(this.secret),n.qt);r["X-BITOPRO-APIKEY"]=this.apiKey,r["X-BITOPRO-PAYLOAD"]=s,r["X-BITOPRO-SIGNATURE"]=i}}else"public"===t&&"GET"===s&&Object.keys(d).length&&(o+="?"+this.urlencode(d));return o=this.urls.api.rest+o,{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(e>=200&&e<300)return;const c=this.id+" "+o,l=this.safeString(n,"error");throw this.throwExactlyMatchedException(this.exceptions.exact,l,c),this.throwBroadlyMatchedException(this.exceptions.broad,l,c),new r.ExchangeError(c)}}},9110:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(3573);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitpanda",alias:!0})}}},9061:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8800),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitrue",name:"Bitrue",countries:["SG"],rateLimit:1e3,certified:!1,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingRate:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPositionMode:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawals:!0,setLeverage:!0,setMargin:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/1294454/139516488-243a830d-05dd-446b-91c6-c1f18fe30c63.jpg",api:{spot:"https://www.bitrue.com/api",fapi:"https://fapi.bitrue.com/fapi",dapi:"https://fapi.bitrue.com/dapi",kline:"https://www.bitrue.com/kline-api"},www:"https://www.bitrue.com",referral:"https://www.bitrue.com/affiliate/landing?cn=600000&inviteCode=EZWETQE",doc:["https://github.com/Bitrue-exchange/bitrue-official-api-docs","https://www.bitrue.com/api-docs"],fees:"https://bitrue.zendesk.com/hc/en-001/articles/4405479952537"},api:{spot:{kline:{public:{get:{"public.json":1,"public{currency}.json":1}}},v1:{public:{get:{ping:1,time:1,exchangeInfo:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10]]},trades:1,historicalTrades:5,aggTrades:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},"market/kline":1}},private:{get:{order:1,openOrders:1,allOrders:5,account:5,myTrades:{cost:5,noSymbol:40},"etf/net-value/{symbol}":1,"withdraw/history":1,"deposit/history":1},post:{order:4,"withdraw/commit":1},delete:{order:1}}},v2:{private:{get:{myTrades:5}}}},fapi:{v1:{public:{get:{ping:1,time:1,contracts:1,depth:1,ticker:1,klines:1}}},v2:{private:{get:{myTrades:1,openOrders:1,order:1,account:1,leverageBracket:1,commissionRate:1,futures_transfer_history:1,forceOrdersHistory:1},post:{positionMargin:1,level_edit:1,cancel:1,order:1,allOpenOrders:1,futures_transfer:1}}}},dapi:{v1:{public:{get:{ping:1,time:1,contracts:1,depth:1,ticker:1,klines:1}}},v2:{private:{get:{myTrades:1,openOrders:1,order:1,account:1,leverageBracket:1,commissionRate:1,futures_transfer_history:1,forceOrdersHistory:1},post:{positionMargin:1,level_edit:1,cancel:1,order:1,allOpenOrders:1,futures_transfer:1}}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.00098"),maker:this.parseNumber("0.00098")},future:{trading:{feeSide:"quote",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000400"),maker:this.parseNumber("0.000200"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000400")],[this.parseNumber("250"),this.parseNumber("0.000400")],[this.parseNumber("2500"),this.parseNumber("0.000350")],[this.parseNumber("7500"),this.parseNumber("0.000320")],[this.parseNumber("22500"),this.parseNumber("0.000300")],[this.parseNumber("50000"),this.parseNumber("0.000270")],[this.parseNumber("100000"),this.parseNumber("0.000250")],[this.parseNumber("200000"),this.parseNumber("0.000220")],[this.parseNumber("400000"),this.parseNumber("0.000200")],[this.parseNumber("750000"),this.parseNumber("0.000170")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000200")],[this.parseNumber("250"),this.parseNumber("0.000160")],[this.parseNumber("2500"),this.parseNumber("0.000140")],[this.parseNumber("7500"),this.parseNumber("0.000120")],[this.parseNumber("22500"),this.parseNumber("0.000100")],[this.parseNumber("50000"),this.parseNumber("0.000080")],[this.parseNumber("100000"),this.parseNumber("0.000060")],[this.parseNumber("200000"),this.parseNumber("0.000040")],[this.parseNumber("400000"),this.parseNumber("0.000020")],[this.parseNumber("750000"),this.parseNumber("0")]]}}},delivery:{trading:{feeSide:"base",tierBased:!0,percentage:!0,taker:this.parseNumber("0.000500"),maker:this.parseNumber("0.000100"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.000500")],[this.parseNumber("250"),this.parseNumber("0.000450")],[this.parseNumber("2500"),this.parseNumber("0.000400")],[this.parseNumber("7500"),this.parseNumber("0.000300")],[this.parseNumber("22500"),this.parseNumber("0.000250")],[this.parseNumber("50000"),this.parseNumber("0.000240")],[this.parseNumber("100000"),this.parseNumber("0.000240")],[this.parseNumber("200000"),this.parseNumber("0.000240")],[this.parseNumber("400000"),this.parseNumber("0.000240")],[this.parseNumber("750000"),this.parseNumber("0.000240")]],maker:[[this.parseNumber("0"),this.parseNumber("0.000100")],[this.parseNumber("250"),this.parseNumber("0.000080")],[this.parseNumber("2500"),this.parseNumber("0.000050")],[this.parseNumber("7500"),this.parseNumber("0.0000030")],[this.parseNumber("22500"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.000050")],[this.parseNumber("100000"),this.parseNumber("-0.000060")],[this.parseNumber("200000"),this.parseNumber("-0.000070")],[this.parseNumber("400000"),this.parseNumber("-0.000080")],[this.parseNumber("750000"),this.parseNumber("-0.000090")]]}}}},options:{createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot","linear","inverse"],fetchMyTradesMethod:"v2PrivateGetMyTrades",hasAlreadyAuthenticatedSuccessfully:!1,recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"FULL"},networks:{ERC20:"ETH",TRC20:"TRX",AETERNITY:"Aeternity",AION:"AION",ALGO:"Algorand",ASK:"ASK",ATOM:"ATOM",AVAXC:"AVAX C-Chain",BCH:"BCH",BEP2:"BEP2",BEP20:"BEP20",Bitcoin:"Bitcoin",BRP20:"BRP20",ADA:"Cardano",CASINOCOIN:"CasinoCoin","CASINOCOIN-XRPL":"CasinoCoin XRPL",CONTENTOS:"Contentos",DASH:"Dash",DECOIN:"Decoin",DFI:"DeFiChain",DGB:"DGB",DIVI:"Divi",DOGE:"dogecoin",EOS:"EOS",ETC:"ETC",FILECOIN:"Filecoin",FREETON:"FREETON",HBAR:"HBAR",HEDERA:"Hedera Hashgraph",HRC20:"HRC20",ICON:"ICON",ICP:"ICP",IGNIS:"Ignis",INTERNETCOMPUTER:"Internet Computer",IOTA:"IOTA",KAVA:"KAVA",KSM:"KSM",LTC:"LiteCoin",LUNA:"Luna",MATIC:"MATIC",MOBILECOIN:"Mobile Coin",MONACOIN:"MonaCoin",XMR:"Monero",NEM:"NEM",NEP5:"NEP5",OMNI:"OMNI",PAC:"PAC",DOT:"Polkadot",RAVEN:"Ravencoin",SAFEX:"Safex",SOL:"SOLANA",SGB:"Songbird",XML:"Stellar Lumens",XYM:"Symbol",XTZ:"Tezos",theta:"theta",THETA:"THETA",VECHAIN:"VeChain",WANCHAIN:"Wanchain",XINFIN:"XinFin Network",XRP:"XRP",XRPL:"XRPL",ZIL:"ZIL"},defaultType:"spot",timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","12h":"12H","1d":"1D","1w":"1W"},future:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1h","1d":"1day","1w":"1week","1M":"1month"}},accountsByType:{spot:"wallet",future:"contract",swap:"contract",funding:"wallet",fund:"wallet",contract:"contract"}},commonCurrencies:{MIM:"MIM Swarm"},precisionMode:o.kb,exceptions:{exact:{"System is under maintenance.":r.OnMaintenance,"System abnormality":r.ExchangeError,"You are not authorized to execute this request.":r.PermissionDenied,"API key does not exist":r.AuthenticationError,"Order would trigger immediately.":r.OrderImmediatelyFillable,"Stop price would trigger immediately.":r.OrderImmediatelyFillable,"Order would immediately match and take.":r.OrderImmediatelyFillable,"Account has insufficient balance for requested action.":r.InsufficientFunds,"Rest API trading is not enabled.":r.ExchangeNotAvailable,"You don't have permission.":r.PermissionDenied,"Market is closed.":r.ExchangeNotAvailable,"Too many requests. Please try again later.":r.DDoSProtection,"-1000":r.ExchangeNotAvailable,"-1001":r.ExchangeNotAvailable,"-1002":r.AuthenticationError,"-1003":r.RateLimitExceeded,"-1013":r.InvalidOrder,"-1015":r.RateLimitExceeded,"-1016":r.ExchangeNotAvailable,"-1020":r.BadRequest,"-1021":r.InvalidNonce,"-1022":r.AuthenticationError,"-1100":r.BadRequest,"-1101":r.BadRequest,"-1102":r.BadRequest,"-1103":r.BadRequest,"-1104":r.BadRequest,"-1105":r.BadRequest,"-1106":r.BadRequest,"-1111":r.BadRequest,"-1112":r.InvalidOrder,"-1114":r.BadRequest,"-1115":r.BadRequest,"-1116":r.BadRequest,"-1117":r.BadRequest,"-1166":r.InvalidOrder,"-1118":r.BadRequest,"-1119":r.BadRequest,"-1120":r.BadRequest,"-1121":r.BadSymbol,"-1125":r.AuthenticationError,"-1127":r.BadRequest,"-1128":r.BadRequest,"-1130":r.BadRequest,"-1131":r.BadRequest,"-1160":r.InvalidOrder,"-1156":r.InvalidOrder,"-2008":r.AuthenticationError,"-2010":r.ExchangeError,"-2011":r.OrderNotFound,"-2013":r.OrderNotFound,"-2014":r.AuthenticationError,"-2015":r.AuthenticationError,"-2017":r.InsufficientFunds,"-2019":r.InsufficientFunds,"-3005":r.InsufficientFunds,"-3006":r.InsufficientFunds,"-3008":r.InsufficientFunds,"-3010":r.ExchangeError,"-3015":r.ExchangeError,"-3022":r.AccountSuspended,"-4028":r.BadRequest,"-3020":r.InsufficientFunds,"-3041":r.InsufficientFunds,"-5013":r.InsufficientFunds,"-11008":r.InsufficientFunds,"-4051":r.InsufficientFunds},broad:{"has no operation privilege":r.PermissionDenied,MAX_POSITION:r.InvalidOrder}}})}currencyToPrecision(e,t,s=void 0){return void 0!==this.safeValue(this.currencies[e],"precision")?this.decimalToPrecision(t,o.R3,this.currencies[e].precision,this.precisionMode,this.paddingMode):this.numberToString(t)}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchStatus(e={}){const t=await this.spotV1PublicGetPing(e);return{status:Object.keys(t).length?"maintenance":"ok",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.spotV1PublicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchCurrencies(e={}){const t=await this.spotV1PublicGetExchangeInfo(e),s={},i=this.safeValue(t,"coins",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"coin"),o=this.safeString(t,"coinFulName"),n=this.safeCurrencyCode(r);let d,h,c,l,u;const p=this.safeValue(t,"chainDetail",[]),f={};for(let e=0;e<p.length;e++){const t=p[e],s=this.safeString(t,"chain"),i=this.networkIdToCode(s,n),r=this.safeValue(t,"enableDeposit");d=r||d;const o=this.safeValue(t,"enableWithdraw");h=o||h;const m=this.safeString(t,"withdrawFee");void 0!==m&&(u=void 0===u?m:a.Y.stringMin(m,u));const g=this.safeString(t,"minWithdraw");void 0!==g&&(c=void 0===c?g:a.Y.stringMin(g,c));const v=this.safeString(t,"maxWithdraw");void 0!==v&&(l=void 0===l?v:a.Y.stringMax(v,l)),f[i]={info:t,id:s,network:i,deposit:r,withdraw:o,active:r&&o,fee:this.parseNumber(m),precision:void 0,limits:{withdraw:{min:this.parseNumber(g),max:this.parseNumber(v)}}}}s[n]={id:r,name:o,code:n,precision:void 0,info:t,active:d&&h,deposit:d,withdraw:h,networks:f,fee:this.parseNumber(u),limits:{withdraw:{min:this.parseNumber(c),max:this.parseNumber(l)}}}}return s}async fetchMarkets(e={}){const t=[],s=this.safeValue(this.options,"fetchMarkets",["spot","linear","inverse"]);for(let i=0;i<s.length;i++){const a=s[i];if("spot"===a)t.push(this.spotV1PublicGetExchangeInfo(e));else if("linear"===a)t.push(this.fapiV1PublicGetContracts(e));else{if("inverse"!==a)throw new r.ExchangeError(this.id+' fetchMarkets() this.options fetchMarkets "'+a+'" is not a supported market type');t.push(this.dapiV1PublicGetContracts(e))}}const i=await Promise.all(t),a=this.safeValue(this.safeValue(i,0),"symbols",[]),o=this.safeValue(i,1),n=this.safeValue(i,2);let d=a;return d=this.arrayConcat(d,o),d=this.arrayConcat(d,n),this.options.adjustForTimeDifference&&await this.loadTimeDifference(),this.parseMarkets(d)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeStringLower(e,"symbol"),i=this.safeInteger(e,"side");let r,o,n;void 0===i?r="spot":(r="swap",o=1===i,n=0===i);const d="spot"!==r;let h,c,l=this.safeString(e,"baseAsset"),u=this.safeString(e,"quoteAsset");if(d){const e=t.split("-");l=this.safeString(e,1),u=this.safeString(e,2),h=o?u:l,c=this.safeCurrencyCode(h)}const p=this.safeCurrencyCode(l),f=this.safeCurrencyCode(u);let m=p+"/"+f;void 0!==c&&(m+=":"+c);const g=this.safeValue(e,"filters",[]),v=this.indexBy(g,"filterType"),y=this.safeString(e,"status"),w=this.safeValue(v,"PRICE_FILTER",{}),b=this.safeValue(v,"LOT_SIZE",{}),S=this.safeString(e,"pricePrecision"),k=this.safeString(e,"quantityPrecision"),O=this.safeString(w,"priceScale",S),T=this.safeString(b,"volumeScale",k),P=this.safeString(e,"multiplier");let I=this.safeNumber(b,"maxQty");void 0===I&&(I=this.safeNumber(e,"maxValidOrder"));let x=this.safeNumber(b,"minVal");return void 0===x&&(x=this.safeNumber(e,"minOrderMoney")),{id:t,lowercaseId:s,symbol:m,base:p,quote:f,settle:c,baseId:l,quoteId:u,settleId:h,type:r,spot:"spot"===r,margin:!1,swap:d,future:!1,option:!1,active:"TRADING"===y,contract:d,linear:o,inverse:n,contractSize:this.parseNumber(a.Y.stringAbs(P)),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(T)),price:this.parseNumber(this.parsePrecision(O))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(b,"minQty"),max:I},price:{min:this.safeNumber(w,"minPrice"),max:this.safeNumber(w,"maxPrice")},cost:{min:x,max:void 0}},created:void 0,info:e}}parseBalance(e){const t={info:e},s=this.safeInteger(e,"updateTime"),i=this.safeValue2(e,"balances","account",[]);for(let e=0;e<i.length;e++){const s=i[e],r=this.safeString2(s,"asset","marginCoin"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString2(s,"free","accountNormal"),o.used=this.safeString2(s,"locked","accountLock"),t[a]=o}return t.timestamp=s,t.datetime=this.iso8601(s),this.safeBalance(t)}async fetchBalance(e={}){let t,s,i,r;return await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e),"swap"===t?void 0!==s&&"inverse"===s?(i=await this.dapiV2PrivateGetAccount(e),r=this.safeValue(i,"data",{})):(i=await this.fapiV2PrivateGetAccount(e),r=this.safeValue(i,"data",{})):(i=await this.spotV1PrivateGetAccount(e),r=i),this.parseBalance(r)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let a;if(i.swap){const e={contractName:i.id};void 0!==t&&(t>100&&(t=100),e.limit=t),i.linear?a=await this.fapiV1PublicGetDepth(this.extend(e,s)):i.inverse&&(a=await this.dapiV1PublicGetDepth(this.extend(e,s)))}else{if(!i.spot)throw new r.NotSupported(this.id+" fetchOrderBook only support spot & swap markets");{const e={symbol:i.id};void 0!==t&&(t>1e3&&(t=1e3),e.limit=t),a=await this.spotV1PublicGetDepth(this.extend(e,s))}}const o=this.safeInteger(a,"time"),n=this.parseOrderBook(a,e,o);return n.nonce=this.safeInteger(a,"lastUpdateId"),n}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString2(e,"lastPrice","last"),r=this.safeInteger(e,"time");let o;return o=t.swap?a.Y.stringMul(this.safeString(e,"rose"),"100"):this.safeString(e,"priceChangePercent"),this.safeTicker({symbol:s,timestamp:r,datetime:this.iso8601(r),high:this.safeString2(e,"highPrice","high"),low:this.safeString2(e,"lowPrice","low"),bid:this.safeString2(e,"bidPrice","buy"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString2(e,"askPrice","sell"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:i,last:i,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:o,average:void 0,baseVolume:this.safeString2(e,"volume","vol"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i,a;if(s.swap){const e={contractName:s.id};s.linear?i=await this.fapiV1PublicGetTicker(this.extend(e,t)):s.inverse&&(i=await this.dapiV1PublicGetTicker(this.extend(e,t))),a=i}else{if(!s.spot)throw new r.NotSupported(this.id+" fetchTicker only support spot & swap markets");{const e={symbol:s.id};i=await this.spotV1PublicGetTicker24hr(this.extend(e,t)),a=this.safeValue(i,0,{})}}return this.parseTicker(a,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeValue(this.options,"timeframes",{});let d,h;if(o.swap){const e=this.safeValue(n,"future",{}),s={contractName:o.id,interval:this.safeString(e,t,"1min")};void 0!==i&&(s.limit=i),o.linear?d=await this.fapiV1PublicGetKlines(this.extend(s,a)):o.inverse&&(d=await this.dapiV1PublicGetKlines(this.extend(s,a))),h=d}else{if(!o.spot)throw new r.NotSupported(this.id+" fetchOHLCV only support spot & swap markets");{const e=this.safeValue(n,"spot",{}),r={symbol:o.id,scale:this.safeString(e,t,"1m")};void 0!==i&&(r.limit=i),void 0!==s&&(r.fromIdx=s),d=await this.spotV1PublicGetMarketKline(this.extend(r,a)),h=this.safeValue(d,"data",[])}}return this.parseOHLCVs(h,o,t,s,i)}parseOHLCV(e,t=void 0){let s=this.safeTimestamp(e,"i");return void 0===s&&(s=this.safeInteger(e,"idx")),[s,this.safeNumber2(e,"o","open"),this.safeNumber2(e,"h","high"),this.safeNumber2(e,"l","low"),this.safeNumber2(e,"c","close"),this.safeNumber2(e,"v","vol")]}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=this.safeString(e,0),i=this.market(s);let a;if(i.swap){const e={contractName:i.id};i.linear?a=await this.fapiV1PublicGetTicker(this.extend(e,t)):i.inverse&&(a=await this.dapiV1PublicGetTicker(this.extend(e,t)))}else{if(!i.spot)throw new r.NotSupported(this.id+" fetchBidsAsks only support spot & swap markets");{const e={symbol:i.id};a=await this.spotV1PublicGetTickerBookTicker(this.extend(e,t))}}const o={};return o[i.id]=a,this.parseTickers(o,e)}async fetchTickers(e=void 0,t={}){let s,i;await this.loadMarkets();const a={};let o;if(void 0!==(e=this.marketSymbols(e))){const o=this.safeString(e,0),n=this.market(o);if(n.swap)throw new r.NotSupported(this.id+" fetchTickers does not support swap markets, please use fetchTicker instead");if(!n.spot)throw new r.NotSupported(this.id+" fetchTickers only support spot & swap markets");s=await this.spotV1PublicGetTicker24hr(this.extend(a,t)),i=s}else{if([o,t]=this.handleMarketTypeAndParams("fetchTickers",void 0,t),"spot"!==o)throw new r.NotSupported(this.id+" fetchTickers only support spot when symbols are not proved");s=await this.spotV1PublicGetTicker24hr(this.extend(a,t)),i=s}const n={};for(let e=0;e<i.length;e++){const t=this.safeValue(i,e,{});n[this.market(this.safeValue(t,"symbol")).id]=t}return this.parseTickers(n,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"ctime","time"),i=this.safeString(e,"price"),r=this.safeString(e,"qty"),a=this.safeString2(e,"symbol","contractName"),o=this.safeSymbol(a,t),n=this.safeString(e,"orderId"),d=this.safeString2(e,"id","tradeId");let h;const c=this.safeValue(e,"isBuyerMaker"),l=this.safeValue(e,"isBuyer");let u,p;void 0!==c&&(h=c?"sell":"buy"),void 0!==l&&(h=l?"buy":"sell"),"commission"in e&&(u={cost:this.safeString2(e,"commission","fee"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAssert"))});const f=this.safeValue(e,"isMaker");return void 0!==f&&(p=f?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:d,order:n,type:void 0,side:h,takerOrMaker:p,price:i,amount:r,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e);let o;if(!a.spot)throw new r.NotSupported(this.id+" fetchTrades only support spot markets");{const e={symbol:a.id};void 0!==s&&(e.limit=s),o=await this.spotV1PublicGetTrades(this.extend(e,i))}return this.parseTrades(o,a,t,s)}parseOrderStatus(e){return this.safeString({INIT:"open",PENDING_CREATE:"open",NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"},e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString2(e,"status","orderStatus")),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),o=this.safeString(e,"executedQty");let n,d;"time"in e?n=this.safeInteger(e,"time"):"transactTime"in e?n=this.safeInteger(e,"transactTime"):"updateTime"in e&&"open"===s&&(a.Y.stringGt(o,"0")?d=this.safeInteger(e,"updateTime"):n=this.safeInteger(e,"updateTime"));const h=this.safeString(e,"avgPrice"),c=this.safeString(e,"price"),l=this.safeString(e,"origQty"),u=this.safeString2(e,"cummulativeQuoteQty","cumQuote"),p=this.safeString(e,"orderId");let f=this.safeStringLower(e,"type");const m=this.safeStringLower(e,"side"),g=this.safeValue(e,"fills",[]),v=this.safeString(e,"clientOrderId"),y=this.safeString(e,"timeInForce"),w="limit_maker"===f||"GTX"===y||"post_only"===f;"limit_maker"===f&&(f="limit");const b=this.safeString(e,"stopPrice"),S=this.parseNumber(this.omitZero(b));return this.safeOrder({info:e,id:p,clientOrderId:v,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:d,symbol:r,type:f,timeInForce:y,postOnly:w,side:m,price:c,stopPrice:S,triggerPrice:S,amount:l,cost:u,average:h,filled:o,remaining:void 0,status:s,fee:void 0,trades:g},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).swap)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports swap orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e);let h,c;const l=t.toUpperCase(),u={side:s.toUpperCase(),type:l};if("LIMIT"===l){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument");u.price=this.priceToPrecision(e,o)}if(d.swap){const t="MARKET"===l,p=this.safeStringLower(n,"timeInForce");this.isPostOnly(t,void 0,n)?u.type="POST_ONLY":"fok"===p?u.type="FOK":"ioc"===p&&(u.type="IOC"),u.contractName=d.id;let f=!0;if([f,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0),t&&"buy"===s&&f){const t=this.safeString(n,"cost");if(n=this.omit(n,"cost"),void 0===o&&void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires the price argument with swap market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options["createMarketBuyOrderRequiresPrice"] = false to supply the cost in the amount argument (the exchange-specific behaviour)');{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r),d=void 0!==t?t:n;u.amount=this.costToPrecision(e,d),u.volume=this.costToPrecision(e,d)}}else u.amount=this.parseToNumeric(i),u.volume=this.parseToNumeric(i);u.positionType=1;const m=this.safeValue2(n,"reduceOnly","reduce_only");u.open=m?"CLOSE":"OPEN";const g=this.safeString(n,"leverage","1");u.leverage=this.parseToNumeric(g),n=this.omit(n,["leverage","reduceOnly","reduce_only","timeInForce"]),d.linear?h=await this.fapiV2PrivatePostOrder(this.extend(u,n)):d.inverse&&(h=await this.dapiV2PrivatePostOrder(this.extend(u,n))),c=this.safeValue(h,"data",{})}else{if(!d.spot)throw new r.NotSupported(this.id+" createOrder only support spot & swap markets");{u.symbol=d.id,u.quantity=this.amountToPrecision(e,i);const s=this.safeValue(d.info,"orderTypes");if(!this.inArray(l,s))throw new r.InvalidOrder(this.id+" "+t+" is not a valid order type in market "+e);const a=this.safeString2(n,"newClientOrderId","clientOrderId");void 0!==a&&(n=this.omit(n,["newClientOrderId","clientOrderId"]),u.newClientOrderId=a);const o=this.safeValue2(n,"triggerPrice","stopPrice");void 0!==o&&(n=this.omit(n,["triggerPrice","stopPrice"]),u.stopPrice=this.priceToPrecision(e,o)),h=await this.spotV1PrivatePostOrder(this.extend(u,n)),c=h}}return this.parseOrder(c,d)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeValue2(s,"origClientOrderId","clientOrderId");let o,n;s=this.omit(s,["origClientOrderId","clientOrderId"]);const d={};if(void 0===a?d.orderId=e:i.swap?d.clientOrderId=a:d.origClientOrderId=a,i.swap)d.contractName=i.id,i.linear?o=await this.fapiV2PrivateGetOrder(this.extend(d,s)):i.inverse&&(o=await this.dapiV2PrivateGetOrder(this.extend(d,s))),n=this.safeValue(o,"data",{});else{if(!i.spot)throw new r.NotSupported(this.id+" fetchOrder only support spot & swap markets");d.orderId=e,d.symbol=i.id,o=await this.spotV1PrivateGetOrder(this.extend(d,s)),n=o}return this.parseOrder(n,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);if(!a.spot)throw new r.NotSupported(this.id+" fetchClosedOrders only support spot markets");const o={symbol:a.id};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s);const n=await this.spotV1PrivateGetAllOrders(this.extend(o,i));return this.parseOrders(n,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);let o,n;const d={};if(a.swap)d.contractName=a.id,a.linear?o=await this.fapiV2PrivateGetOpenOrders(this.extend(d,i)):a.inverse&&(o=await this.dapiV2PrivateGetOpenOrders(this.extend(d,i))),n=this.safeValue(o,"data",[]);else{if(!a.spot)throw new r.NotSupported(this.id+" fetchOpenOrders only support spot & swap markets");d.symbol=a.id,o=await this.spotV1PrivateGetOpenOrders(this.extend(d,i)),n=o}return this.parseOrders(n,a,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeValue2(s,"origClientOrderId","clientOrderId");let o,n;s=this.omit(s,["origClientOrderId","clientOrderId"]);const d={};if(void 0===a?d.orderId=e:i.swap?d.clientOrderId=a:d.origClientOrderId=a,i.swap)d.contractName=i.id,i.linear?o=await this.fapiV2PrivatePostCancel(this.extend(d,s)):i.inverse&&(o=await this.dapiV2PrivatePostCancel(this.extend(d,s))),n=this.safeValue(o,"data",{});else{if(!i.spot)throw new r.NotSupported(this.id+" cancelOrder only support spot & swap markets");d.symbol=i.id,o=await this.spotV1PrivateDeleteOrder(this.extend(d,s)),n=o}return this.parseOrder(n,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.market(e);let i,a;if(!s.swap)throw new r.NotSupported(this.id+" cancelAllOrders only support future markets");{const e={contractName:s.id};s.linear?i=await this.fapiV2PrivatePostAllOpenOrders(this.extend(e,t)):s.inverse&&(i=await this.dapiV2PrivatePostAllOpenOrders(this.extend(e,t))),a=this.safeValue(i,"data",[])}return this.parseOrders(a,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");const a=this.market(e);let o,n;const d={};if(void 0!==t&&(d.startTime=t),void 0!==s&&(s>1e3&&(s=1e3),d.limit=s),a.swap)d.contractName=a.id,a.linear?o=await this.fapiV2PrivateGetMyTrades(this.extend(d,i)):a.inverse&&(o=await this.dapiV2PrivateGetMyTrades(this.extend(d,i))),n=this.safeValue(o,"data",[]);else{if(!a.spot)throw new r.NotSupported(this.id+" fetchMyTrades only support spot & swap markets");d.symbol=a.id,o=await this.spotV2PrivateGetMyTrades(this.extend(d,i)),n=o}return this.parseTrades(n,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires a code argument");await this.loadMarkets();const a=this.currency(e),o={coin:a.id,status:1};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s);const n=await this.spotV1PrivateGetDepositHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchWithdrawals() requires a code argument");await this.loadMarkets();const a=this.currency(e),o={coin:a.id,status:5};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s);const n=await this.spotV1PrivateGetWithdrawHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a)}parseTransactionStatusByType(e,t=void 0){const s=this.safeValue({deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",5:"ok",6:"canceled"}},t,{});return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdrawId"),i=this.safeString(e,"tagType");let r,a,o=this.safeString(e,"addressTo"),n=this.safeString(e,"addressFrom");if(void 0!==i){if(void 0!==o){const e=o.split("_");o=this.safeString(e,0),r=this.safeString(e,1)}if(void 0!==n){const e=n.split("_");n=this.safeString(e,0),a=this.safeString(e,1)}}const d=this.safeString(e,"txid"),h=this.safeInteger(e,"createdAt"),c=this.safeInteger(e,"updatedAt"),l="payAmount"in e||"ctime"in e?"withdrawal":"deposit",u=this.parseTransactionStatusByType(this.safeString(e,"status"),l),p=this.safeNumber(e,"amount");let f,m=this.safeString2(e,"symbol","coin");if(void 0!==m){const e=m.split("_");m=this.safeString(e,0);const t=this.safeString(e,1);void 0!==t&&(f=t.toUpperCase())}const g=this.safeCurrencyCode(m,t),v=this.safeNumber(e,"fee");let y;return void 0!==v&&(y={currency:g,cost:v}),{info:e,id:s,txid:d,timestamp:h,datetime:this.iso8601(h),network:f,address:o,addressTo:o,addressFrom:n,tag:r,tagTo:r,tagFrom:a,type:l,amount:p,currency:g,status:u,updated:c,internal:!1,comment:void 0,fee:y}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={coin:a.id,amount:t,addressTo:s};let n;[n,r]=this.handleNetworkCodeAndParams(r),void 0!==n&&(o.chainName=this.networkCodeToId(n)),void 0!==i&&(o.tag=i);const d=await this.spotV1PrivatePostWithdrawCommit(this.extend(o,r)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,a)}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"chainDetail",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(0!==i)for(let e=0;e<i;e++){const a=s[e],o=this.safeString(a,"chain"),n=this.safeString(t,"code"),d=this.networkIdToCode(o,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(a,"withdrawFee"),percentage:!1}},1===i&&(r.withdraw.fee=this.safeNumber(a,"withdrawFee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotV1PublicGetExchangeInfo(t),i=this.safeList(s,"coins");return this.parseDepositWithdrawFees(i,e,"coin")}parseTransfer(e,t=void 0){const s=this.safeString(e,"transferType");let i,r;if(void 0!==s){const e=s.split("_to_");i=this.safeString(e,0),r=this.safeString(e,1)}const a=this.safeInteger(e,"ctime");return{info:e,id:void 0,timestamp:a,datetime:this.iso8601(a),currency:this.safeString(t,"code"),amount:this.safeNumber(e,"amount"),fromAccount:i,toAccount:r,status:"ok"}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={transferType:this.safeString2(i,"type","transferType")};let a;void 0!==e&&(a=this.currency(e),r.coinSymbol=a.id),void 0!==t&&(r.beginTime=t),void 0!==s&&(s>200&&(s=200),r.limit=s);const o=this.safeInteger(i,"until");void 0!==o&&(i=this.omit(i,"until"),r.endTime=o);const n=await this.fapiV2PrivateGetFuturesTransferHistory(this.extend(r,i)),d=this.safeList(n,"data",[]);return this.parseTransfers(d,a,t,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={coinSymbol:a.id,amount:this.currencyToPrecision(e,t),transferType:n+"_to_"+d},c=await this.fapiV2PrivatePostFuturesTransfer(this.extend(h,r)),l=this.safeDict(c,"data",{});return this.parseTransfer(l,a)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new r.BadRequest(this.id+" leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let a;const o={contractName:i.id,leverage:e};if(!i.swap)throw new r.NotSupported(this.id+" setLeverage only support swap markets");return i.linear?a=await this.fapiV2PrivatePostLevelEdit(this.extend(o,s)):i.inverse&&(a=await this.dapiV2PrivatePostLevelEdit(this.extend(o,s))),a}parseMarginModification(e,t=void 0){return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:void 0,status:void 0,timestamp:void 0,datetime:void 0}}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e);if(!i.swap)throw new r.NotSupported(this.id+" setMargin only support swap markets");let a;const o={contractName:i.id,amount:this.parseToNumeric(t)};return i.linear?a=await this.fapiV2PrivatePostPositionMargin(this.extend(o,s)):i.inverse&&(a=await this.dapiV2PrivatePostPositionMargin(this.extend(o,s))),this.parseMarginModification(a,i)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeString(t,0),d=this.safeString(t,1),h=this.safeString(t,2);let c;if(c="api"===o&&"kline"===d?this.urls.api[o]:this.urls.api[o]+"/"+d,c=c+"/"+this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),"private"===h){this.checkRequiredCredentials();const t=this.safeInteger(this.options,"recvWindow",5e3);if("spot"===o){let e=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:t},i));e+="&signature="+this.hmac(this.encode(e),this.encode(this.secret),n.s),r={"X-MBX-APIKEY":this.apiKey},"GET"===s||"DELETE"===s?c+="?"+e:(a=e,r["Content-Type"]="application/x-www-form-urlencoded")}else{const h=this.nonce().toString();let l;"fapi"===o?l="/fapi":"dapi"===o&&(l="/dapi"),l=l+"/"+d+"/"+e;let u=h+s+l;if("GET"===s){Object.keys(i).length>0&&(u+="?"+this.urlencode(i));const e=this.hmac(this.encode(u),this.encode(this.secret),n.s);r={"X-CH-APIKEY":this.apiKey,"X-CH-SIGN":e,"X-CH-TS":h},c+="?"+this.urlencode(i)}else{const e=this.extend({recvWindow:t},i);u+=a=this.json(e);const s=this.hmac(this.encode(u),this.encode(this.secret),n.s);r={"Content-Type":"application/json","X-CH-APIKEY":this.apiKey,"X-CH-SIGN":s,"X-CH-TS":h}}}}else Object.keys(i).length&&(c+="?"+this.urlencode(i));return{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,o,n,d,h,c){if(418===e||429===e)throw new r.DDoSProtection(this.id+" "+e.toString()+" "+t+" "+n);if(e>=400){if(n.indexOf("Price * QTY is zero or less")>=0)throw new r.InvalidOrder(this.id+" order cost = amount * price is zero or less "+n);if(n.indexOf("LOT_SIZE")>=0)throw new r.InvalidOrder(this.id+" order amount should be evenly divisible by lot size "+n);if(n.indexOf("PRICE_FILTER")>=0)throw new r.InvalidOrder(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+n)}if(void 0===d)return;const l=this.safeBool(d,"success",!0);if(!l){const e=this.safeString(d,"msg");let t;if(void 0!==e){try{t=JSON.parse(e)}catch(e){t=void 0}void 0!==t&&(d=t)}}const u=this.safeString(d,"msg");void 0!==u&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const p=this.safeString(d,"code");if(void 0!==p){if("200"===p||a.Y.stringEquals(p,"0"))return;if("-2015"===p&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new r.DDoSProtection(this.id+" temporary banned: "+n);const e=this.id+" "+n;throw this.throwExactlyMatchedException(this.exceptions.exact,p,e),new r.ExchangeError(e)}if(!l)throw new r.ExchangeError(this.id+" "+n)}calculateRateLimiterCost(e,t,s,i,r={}){if("noSymbol"in r&&!("symbol"in i))return r.noSymbol;if("byLimit"in r&&"limit"in i){const e=i.limit,t=r.byLimit;for(let s=0;s<t.length;s++){const i=t[s];if(e<=i[0])return i[1]}}return this.safeValue(r,"cost",1)}}},3019:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9656),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitso",name:"Bitso",countries:["MX"],rateLimit:2e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg",api:{rest:"https://bitso.com/api"},test:{rest:"https://stage.bitso.com/api"},www:"https://bitso.com",doc:"https://bitso.com/api_info",fees:"https://bitso.com/fees",referral:"https://bitso.com/?ref=itej"},precisionMode:o.kb,options:{precision:{XRP:1e-6,MXN:.01,TUSD:.01},defaultPrecision:1e-8},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","12h":"43200","1d":"86400","1w":"604800"},api:{public:{get:["available_books","ticker","order_book","trades","ohlc"]},private:{get:["account_status","balance","fees","fundings","fundings/{fid}","funding_destination","kyc_documents","ledger","ledger/trades","ledger/fees","ledger/fundings","ledger/withdrawals","mx_bank_codes","open_orders","order_trades/{oid}","orders/{oid}","user_trades","user_trades/{tid}","withdrawals/","withdrawals/{wid}"],post:["bitcoin_withdrawal","debit_card_withdrawal","ether_withdrawal","orders","phone_number","phone_verification","phone_withdrawal","spei_withdrawal","ripple_withdrawal","bcash_withdrawal","litecoin_withdrawal"],delete:["orders","orders/{oid}","orders/all"]}},exceptions:{"0201":r.AuthenticationError,104:r.InvalidNonce,"0304":r.BadRequest}})}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const r={};void 0!==s&&(r.limit=s);const a=await this.privateGetLedger(this.extend(r,i)),o=this.safeValue(a,"payload",[]),n=this.safeCurrency(e);return this.parseLedger(o,n,t,s)}parseLedgerEntryType(e){return this.safeString({funding:"transaction",withdrawal:"transaction",trade:"trade",fee:"fee"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"operation"),i=this.parseLedgerEntryType(s),r=this.safeValue(e,"balance_updates",[]),o=this.safeValue(r,0,{});let n,d;const h=this.safeString(o,"amount"),c=this.safeString(o,"currency"),l=this.safeCurrencyCode(c,t),u=this.safeValue(e,"details",{});let p=this.safeString2(u,"fid","wid");if(void 0===p&&(p=this.safeString(u,"tid")),"funding"===s)n="in";else if("withdrawal"===s)n="out";else if("trade"===s)n=void 0;else if("fee"===s){n="out";d={cost:a.Y.stringAbs(h),currency:t}}const f=this.parse8601(this.safeString(e,"created_at"));return this.safeLedgerEntry({id:this.safeString(e,"eid"),direction:n,account:void 0,referenceId:p,referenceAccount:void 0,type:i,currency:l,amount:h,timestamp:f,datetime:this.iso8601(f),before:void 0,after:void 0,status:"ok",fee:d,info:e},t)}async fetchMarkets(e={}){const t=await this.publicGetAvailableBooks(e),s=this.safeValue(t,"payload",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"book"),[o,n]=r.split("_");let d=o.toUpperCase(),h=n.toUpperCase();d=this.safeCurrencyCode(d),h=this.safeCurrencyCode(h);const c=this.safeValue(t,"fees",{}),l=this.safeValue(c,"flat_rate",{}),u=this.safeString(l,"taker"),p=this.safeString(l,"maker"),f=this.parseNumber(a.Y.stringDiv(u,"100")),m=this.parseNumber(a.Y.stringDiv(p,"100")),g=this.safeValue(c,"structure",[]),v={taker:f,maker:m,percentage:!0,tierBased:!0},y=[],w=[];for(let e=0;e<g.length;e++){const t=g[e],s=this.safeNumber(t,"volume"),i=this.safeNumber(t,"taker"),r=this.safeNumber(t,"maker");y.push([s,i]),w.push([s,r]),0===e&&(v.taker=i,v.maker=r)}const b={taker:y,maker:w};v.tiers=b;const S=this.safeNumber(this.options.precision,h,this.options.defaultPrecision);i.push(this.extend({id:r,symbol:d+"/"+h,base:d,quote:h,settle:void 0,baseId:o,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:f,maker:m,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(this.options.precision,d,this.options.defaultPrecision),price:this.safeNumber(t,"tick_size",S)},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minimum_amount"),max:this.safeNumber(t,"maximum_amount")},price:{min:this.safeNumber(t,"minimum_price"),max:this.safeNumber(t,"maximum_price")},cost:{min:this.safeNumber(t,"minimum_value"),max:this.safeNumber(t,"maximum_value")}},created:void 0,info:t},v))}return i}parseBalance(e){const t=this.safeValue(e,"payload",{}),s=this.safeValue(t,"balances",[]),i={info:e,timestamp:void 0,datetime:void 0};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"locked"),o.total=this.safeString(t,"total"),i[a]=o}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={book:i.id},a=await this.publicGetOrderBook(this.extend(r,s)),o=this.safeValue(a,"payload"),n=this.parse8601(this.safeString(o,"updated_at"));return this.parseOrderBook(o,i.symbol,n,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"vwap"),o=this.safeString(e,"volume"),n=a.Y.stringMul(o,r),d=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:r,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={book:s.id},r=await this.publicGetTicker(this.extend(i,t)),a=this.safeValue(r,"payload");return this.parseTicker(a,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={book:a.id,time_bucket:this.safeString(this.timeframes,t,t)};if(void 0!==s){if(o.start=s,void 0!==i){const e=this.parseTimeframe(t);o.end=this.sum(s,e*i*1e3)}}else if(void 0!==i){const e=this.milliseconds();o.end=e,o.start=e-1e3*this.parseTimeframe(t)*i}const n=await this.publicGetOhlc(this.extend(o,r)),d=this.safeList(n,"payload",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"bucket_start_time"),this.safeNumber(e,"first_rate"),this.safeNumber(e,"max_rate"),this.safeNumber(e,"min_rate"),this.safeNumber(e,"last_rate"),this.safeNumber(e,"volume")]}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"book"),r=this.safeSymbol(i,t,"_");let o=this.safeString(e,"side");const n=this.safeString(e,"maker_side");let d;void 0!==o?d=o===n?"maker":"taker":o="buy"===n?"sell":"buy";let h,c=this.safeString2(e,"amount","major");void 0!==c&&(c=a.Y.stringAbs(c));const l=this.safeString(e,"fees_amount");if(void 0!==l){const t=this.safeString(e,"fees_currency");h={cost:l,currency:this.safeCurrencyCode(t)}}let u=this.safeString(e,"minor");void 0!==u&&(u=a.Y.stringAbs(u));const p=this.safeString(e,"price"),f=this.safeString(e,"oid"),m=this.safeString(e,"tid");return this.safeTrade({id:m,info:e,timestamp:s,datetime:this.iso8601(s),symbol:r,order:f,type:void 0,side:o,takerOrMaker:d,price:p,amount:c,cost:u,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={book:r.id},o=await this.publicGetTrades(this.extend(a,i));return this.parseTrades(o.payload,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"fees",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"book"),a=this.safeSymbol(s,void 0,"_");r[a]={info:t,symbol:a,maker:this.safeNumber(t,"maker_fee_decimal"),taker:this.safeNumber(t,"taker_fee_decimal"),percentage:!0,tierBased:!0}}return r}async fetchMyTrades(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const a=this.market(e),o="marker"in i;if(void 0!==t&&!o)throw new r.ExchangeError(this.id+" fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(i=this.extend(i,{marker:parseInt(i.marker)}));const n={book:a.id,limit:s},d=await this.privateGetUserTrades(this.extend(n,i));return this.parseTrades(d.payload,a,t,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={book:o.id,side:s,type:t,major:this.amountToPrecision(o.symbol,i)};"limit"===t&&(n.price=this.priceToPrecision(o.symbol,r));const d=await this.privatePostOrders(this.extend(n,a)),h=this.safeString(d.payload,"oid");return this.safeOrder({info:d,id:h},o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={oid:e},r=await this.privateDeleteOrdersOid(this.extend(i,s)),a=this.safeList(r,"payload",[]),o=this.safeString(a,0);return this.safeOrder({info:r,id:o})}async cancelOrders(e,t=void 0,s={}){if(!Array.isArray(e))throw new r.ArgumentsRequired(this.id+" cancelOrders() ids argument should be an array");let i;void 0!==t&&(i=this.market(t));const a={oids:e.join(",")},o=await this.privateDeleteOrders(this.extend(a,s)),n=this.safeValue(o,"payload",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e];d.push(this.parseOrder(t,i))}return d}async cancelAllOrders(e=void 0,t={}){if(void 0!==e)throw new r.NotSupported(this.id+" cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.");const s=await this.privateDeleteOrdersAll(t),i=this.safeValue(s,"payload",[]),a=[];for(let e=0;e<i.length;e++){const t=this.parseOrder(i[e]);a.push(t)}return a}parseOrderStatus(e){return this.safeString({"partial-fill":"open","partially filled":"open",queued:"open",completed:"closed"},e,e)}parseOrder(e,t=void 0){let s;s="string"==typeof e?e:this.safeString(e,"oid");const i=this.safeString(e,"side"),r=this.parseOrderStatus(this.safeString(e,"status")),a=this.safeString(e,"book"),o=this.safeSymbol(a,t,"_"),n=this.safeString(e,"type"),d=this.parse8601(this.safeString(e,"created_at")),h=this.safeString(e,"price"),c=this.safeString(e,"original_amount"),l=this.safeString(e,"unfilled_amount"),u=this.safeString(e,"client_id");return this.safeOrder({info:e,id:s,clientOrderId:u,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:o,type:n,timeInForce:void 0,postOnly:void 0,side:i,price:h,stopPrice:void 0,triggerPrice:void 0,amount:c,cost:void 0,remaining:l,filled:void 0,status:r,fee:void 0,average:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=25,i={}){await this.loadMarkets();const a=this.market(e),o="marker"in i;if(void 0!==t&&!o)throw new r.ExchangeError(this.id+" fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id");o&&(i=this.extend(i,{marker:parseInt(i.marker)}));const n={book:a.id,limit:s},d=await this.privateGetOpenOrders(this.extend(n,i));return this.parseOrders(d.payload,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privateGetOrdersOid({oid:e}),a=this.safeValue(i,"payload");if(Array.isArray(a)){if(1===i.payload.length)return this.parseOrder(a[0])}throw new r.OrderNotFound(this.id+": The order "+e+" not found.")}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(t),o={oid:e},n=await this.privateGetOrderTradesOid(this.extend(o,r));return this.parseTrades(n.payload,a)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={fid:e},r=await this.privateGetFundingsFid(this.extend(i,s)),a=this.safeValue(r,"payload",[]),o=this.safeDict(a,0,{});return this.parseTransaction(o)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a=await this.privateGetFundings(i),o=this.safeList(a,"payload",[]);return this.parseTransactions(o,r,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={fund_currency:this.currency(e).id},i=await this.privateGetFundingDestination(this.extend(s,t));let r,a=this.safeString(i.payload,"account_identifier");if(a.indexOf("?dt=")>=0){const e=a.split("?dt=");a=this.safeString(e,0),r=this.safeString(e,1)}return this.checkAddress(a),{currency:e,address:a,tag:r,network:void 0,info:i}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i={},r=this.safeValue(s,"payload",{}),a=this.safeValue(r,"deposit_fees",[]);for(let t=0;t<a.length;t++){const s=a[t],r=this.safeString(s,"currency"),o=this.safeCurrencyCode(r);(void 0===e||this.inArray(o,e))&&(i[o]={deposit:this.safeNumber(s,"fee"),withdraw:void 0,info:{deposit:s,withdraw:void 0}})}const o=this.safeValue(r,"withdrawal_fees",[]),n=Object.keys(o);for(let t=0;t<n.length;t++){const s=n[t],r=this.safeCurrencyCode(s);(void 0===e||this.inArray(r,e))&&(i[r]={deposit:this.safeValue(i[r],"deposit"),withdraw:this.safeNumber(o,s),info:{deposit:this.safeValue(i[r].info,"deposit"),withdraw:this.safeNumber(o,s)}})}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetFees(t),i=this.safeList(s,"payload",[]);return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={},r=this.safeValue(e,"deposit_fees",[]),a=this.safeValue(e,"withdrawal_fees",[]);for(let e=0;e<r.length;e++){const s=r[e],a=this.safeString(s,"currency"),o=this.safeCurrencyCode(a);(void 0===t||o in t)&&(i[o]={deposit:{fee:this.safeNumber(s,"fee"),percentage:!this.safeValue(s,"is_fixed")},withdraw:{fee:void 0,percentage:void 0},networks:{},info:s})}const o=Object.keys(a);for(let e=0;e<o.length;e++){const s=o[e],r=this.safeCurrencyCode(s);if(void 0===t||r in t){const e=this.parseNumber(a[s]);void 0===this.safeValue(i,r)&&(i[r]=this.depositWithdrawFee({})),i[r].withdraw.fee=e,i[r].info[r]=e}}return i}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o={BTC:"Bitcoin",ETH:"Ether",XRP:"Ripple",BCH:"Bcash",LTC:"Litecoin"},n=this.currency(e),d=e in o?o[e]:void 0;if(void 0===d)throw new r.ExchangeError(this.id+" not valid withdraw coin: "+e);const h={amount:t,address:s,destination_tag:i},c="privatePost"+d+"Withdrawal",l=await this[c](this.extend(h,a)),u=this.safeValue(l,"payload",[]),p=this.safeDict(u,0);return this.parseTransaction(p,n)}safeNetwork(e){if(void 0===e)return;e=e.toUpperCase();return this.safeString({trx:"TRC20",erc20:"ERC20",bsc:"BEP20",bep2:"BEP2"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"currency","asset");t=this.safeCurrency(s,t);const i=this.safeValue(e,"details",{}),r=this.safeString(e,"created_at"),a=this.safeString(i,"withdrawal_address"),o=this.safeString(i,"receiving_address"),n=this.safeString2(e,"network","method"),d=this.safeString(e,"status"),h=this.safeString(e,"wid");return{id:this.safeString2(e,"wid","fid"),txid:this.safeString(i,"tx_hash"),timestamp:this.parse8601(r),datetime:r,network:this.safeNetwork(n),addressFrom:o,address:void 0!==a?a:o,addressTo:a,amount:this.safeNumber(e,"amount"),type:void 0===h?"deposit":"withdrawal",currency:this.safeCurrencyCode(s,t),status:this.parseTransactionStatus(d),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:void 0,info:e}}parseTransactionStatus(e){return this.safeString({pending:"pending",in_progress:"pending",complete:"ok",failed:"failed"},e,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.version+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));"GET"!==s&&"DELETE"!==s||Object.keys(d).length&&(o+="?"+this.urlencode(d));const h=this.urls.api.rest+o;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t=[e,s,o].join("");"GET"!==s&&"DELETE"!==s&&Object.keys(d).length&&(t+=a=this.json(d));const i=this.hmac(this.encode(t),this.encode(this.secret),n.s);r={Authorization:"Bitso "+(this.apiKey+":"+e+":"+i),"Content-Type":"application/json"}}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&"success"in n){let e=this.safeBool(n,"success",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.id+" "+this.json(n),t=this.safeValue(n,"error");if(void 0===t)throw new r.ExchangeError(e);const s=this.safeString(t,"code");throw this.throwExactlyMatchedException(this.exceptions,s,e),new r.ExchangeError(e)}}}}},382:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5223),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitstamp",name:"Bitstamp",countries:["GB"],rateLimit:75,version:"v2",userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:"emulated",fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg",api:{public:"https://www.bitstamp.net/api",private:"https://www.bitstamp.net/api"},www:"https://www.bitstamp.net",doc:"https://www.bitstamp.net/api"},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"259200"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{"ohlc/{pair}/":1,"order_book/{pair}/":1,"ticker/":1,"ticker_hour/{pair}/":1,"ticker/{pair}/":1,"transactions/{pair}/":1,"trading-pairs-info/":1,"currencies/":1,"eur_usd/":1,"travel_rule/vasps/":1}},private:{get:{"travel_rule/contacts/":1,"contacts/{contact_uuid}/":1,"earn/subscriptions/":1,"earn/transactions/":1},post:{"account_balances/":1,"account_balances/{currency}/":1,"balance/":1,"balance/{pair}/":1,"bch_withdrawal/":1,"bch_address/":1,"user_transactions/":1,"user_transactions/{pair}/":1,"crypto-transactions/":1,"open_orders/all/":1,"open_orders/{pair}/":1,"order_status/":1,"cancel_order/":1,"cancel_all_orders/":1,"cancel_all_orders/{pair}/":1,"buy/{pair}/":1,"buy/market/{pair}/":1,"buy/instant/{pair}/":1,"sell/{pair}/":1,"sell/market/{pair}/":1,"sell/instant/{pair}/":1,"transfer-to-main/":1,"transfer-from-main/":1,"my_trading_pairs/":1,"fees/trading/":1,"fees/trading/{market_symbol}":1,"fees/withdrawal/":1,"fees/withdrawal/{currency}/":1,"withdrawal-requests/":1,"withdrawal/open/":1,"withdrawal/status/":1,"withdrawal/cancel/":1,"liquidation_address/new/":1,"liquidation_address/info/":1,"btc_unconfirmed/":1,"websockets_token/":1,"btc_withdrawal/":1,"btc_address/":1,"ripple_withdrawal/":1,"ripple_address/":1,"ltc_withdrawal/":1,"ltc_address/":1,"eth_withdrawal/":1,"eth_address/":1,"xrp_withdrawal/":1,"xrp_address/":1,"xlm_withdrawal/":1,"xlm_address/":1,"pax_withdrawal/":1,"pax_address/":1,"link_withdrawal/":1,"link_address/":1,"usdc_withdrawal/":1,"usdc_address/":1,"omg_withdrawal/":1,"omg_address/":1,"dai_withdrawal/":1,"dai_address/":1,"knc_withdrawal/":1,"knc_address/":1,"mkr_withdrawal/":1,"mkr_address/":1,"zrx_withdrawal/":1,"zrx_address/":1,"gusd_withdrawal/":1,"gusd_address/":1,"aave_withdrawal/":1,"aave_address/":1,"bat_withdrawal/":1,"bat_address/":1,"uma_withdrawal/":1,"uma_address/":1,"snx_withdrawal/":1,"snx_address/":1,"uni_withdrawal/":1,"uni_address/":1,"yfi_withdrawal/":1,"yfi_address/":1,"audio_withdrawal/":1,"audio_address/":1,"crv_withdrawal/":1,"crv_address/":1,"algo_withdrawal/":1,"algo_address/":1,"comp_withdrawal/":1,"comp_address/":1,"grt_withdrawal/":1,"grt_address/":1,"usdt_withdrawal/":1,"usdt_address/":1,"eurt_withdrawal/":1,"eurt_address/":1,"matic_withdrawal/":1,"matic_address/":1,"sushi_withdrawal/":1,"sushi_address/":1,"chz_withdrawal/":1,"chz_address/":1,"enj_withdrawal/":1,"enj_address/":1,"alpha_withdrawal/":1,"alpha_address/":1,"ftt_withdrawal/":1,"ftt_address/":1,"storj_withdrawal/":1,"storj_address/":1,"axs_withdrawal/":1,"axs_address/":1,"sand_withdrawal/":1,"sand_address/":1,"hbar_withdrawal/":1,"hbar_address/":1,"rgt_withdrawal/":1,"rgt_address/":1,"fet_withdrawal/":1,"fet_address/":1,"skl_withdrawal/":1,"skl_address/":1,"cel_withdrawal/":1,"cel_address/":1,"sxp_withdrawal/":1,"sxp_address/":1,"ada_withdrawal/":1,"ada_address/":1,"slp_withdrawal/":1,"slp_address/":1,"ftm_withdrawal/":1,"ftm_address/":1,"perp_withdrawal/":1,"perp_address/":1,"dydx_withdrawal/":1,"dydx_address/":1,"gala_withdrawal/":1,"gala_address/":1,"shib_withdrawal/":1,"shib_address/":1,"amp_withdrawal/":1,"amp_address/":1,"sgb_withdrawal/":1,"sgb_address/":1,"avax_withdrawal/":1,"avax_address/":1,"wbtc_withdrawal/":1,"wbtc_address/":1,"ctsi_withdrawal/":1,"ctsi_address/":1,"cvx_withdrawal/":1,"cvx_address/":1,"imx_withdrawal/":1,"imx_address/":1,"nexo_withdrawal/":1,"nexo_address/":1,"ust_withdrawal/":1,"ust_address/":1,"ant_withdrawal/":1,"ant_address/":1,"gods_withdrawal/":1,"gods_address/":1,"rad_withdrawal/":1,"rad_address/":1,"band_withdrawal/":1,"band_address/":1,"inj_withdrawal/":1,"inj_address/":1,"rly_withdrawal/":1,"rly_address/":1,"rndr_withdrawal/":1,"rndr_address/":1,"vega_withdrawal/":1,"vega_address/":1,"1inch_withdrawal/":1,"1inch_address/":1,"ens_withdrawal/":1,"ens_address/":1,"mana_withdrawal/":1,"mana_address/":1,"lrc_withdrawal/":1,"lrc_address/":1,"ape_withdrawal/":1,"ape_address/":1,"mpl_withdrawal/":1,"mpl_address/":1,"euroc_withdrawal/":1,"euroc_address/":1,"sol_withdrawal/":1,"sol_address/":1,"dot_withdrawal/":1,"dot_address/":1,"near_withdrawal/":1,"near_address/":1,"doge_withdrawal/":1,"doge_address/":1,"flr_withdrawal/":1,"flr_address/":1,"dgld_withdrawal/":1,"dgld_address/":1,"ldo_withdrawal/":1,"ldo_address/":1,"travel_rule/contacts/":1,"earn/subscribe/":1,"earn/subscriptions/setting/":1,"earn/unsubscribe":1,"wecan_withdrawal/":1,"wecan_address/":1,"trac_withdrawal/":1,"trac_address/":1,"eurcv_withdrawal/":1,"eurcv_address/":1,"pyusd_withdrawal/":1,"pyusd_address/":1,"lmwr_withdrawal/":1,"lmwr_address/":1,"pepe_withdrawal/":1,"pepe_address/":1,"blur_withdrawal/":1,"blur_address/":1,"vext_withdrawal/":1,"vext_address/":1,"cspr_withdrawal/":1,"cspr_address/":1,"vchf_withdrawal/":1,"vchf_address/":1,"veur_withdrawal/":1,"veur_address/":1,"truf_withdrawal/":1,"truf_address/":1,"wif_withdrawal/":1,"wif_address/":1,"smt_withdrawal/":1,"smt_address/":1,"sui_withdrawal/":1,"sui_address/":1,"jup_withdrawal/":1,"jup_address/":1,"ondo_withdrawal/":1,"ondo_address/":1,"boba_withdrawal/":1,"boba_address/":1,"pyth_withdrawal/":1,"pyth_address/":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]],maker:[[this.parseNumber("0"),this.parseNumber("0.005")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0024")],[this.parseNumber("200000"),this.parseNumber("0.0022")],[this.parseNumber("400000"),this.parseNumber("0.0020")],[this.parseNumber("600000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.0014")],[this.parseNumber("2000000"),this.parseNumber("0.0013")],[this.parseNumber("4000000"),this.parseNumber("0.0012")],[this.parseNumber("20000000"),this.parseNumber("0.0011")],[this.parseNumber("50000000"),this.parseNumber("0.0010")],[this.parseNumber("100000000"),this.parseNumber("0.0007")],[this.parseNumber("500000000"),this.parseNumber("0.0005")],[this.parseNumber("2000000000"),this.parseNumber("0.0003")],[this.parseNumber("6000000000"),this.parseNumber("0.0001")],[this.parseNumber("20000000000"),this.parseNumber("0.00005")],[this.parseNumber("20000000001"),this.parseNumber("0")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{BTC:0,BCH:0,LTC:0,ETH:0,XRP:0,XLM:0,PAX:0,USD:7.5,EUR:0}}},precisionMode:o.kb,commonCurrencies:{UST:"USTC"},options:{networksById:{"bitcoin-cash":"BCH",bitcoin:"BTC",ethereum:"ERC20",litecoin:"LTC",stellar:"XLM",xrpl:"XRP",tron:"TRC20",algorand:"ALGO",flare:"FLR",hedera:"HBAR",cardana:"ADA",songbird:"FLR","avalanche-c-chain":"AVAX",solana:"SOL",polkadot:"DOT",near:"NEAR",doge:"DOGE",sui:"SUI",casper:"CSRP"}},exceptions:{exact:{"No permission found":r.PermissionDenied,"API key not found":r.AuthenticationError,"IP address not allowed":r.PermissionDenied,"Invalid nonce":r.InvalidNonce,"Invalid signature":r.AuthenticationError,"Authentication failed":r.AuthenticationError,"Missing key, signature and nonce parameters":r.AuthenticationError,"Wrong API key format":r.AuthenticationError,"Your account is frozen":r.PermissionDenied,"Please update your profile with your FATCA information, before using API.":r.PermissionDenied,"Order not found.":r.OrderNotFound,"Price is more than 20% below market price.":r.InvalidOrder,"Bitstamp.net is under scheduled maintenance. We'll be back soon.":r.OnMaintenance,"Order could not be placed.":r.ExchangeNotAvailable,"Invalid offset.":r.BadRequest},broad:{"Minimum order size is":r.InvalidOrder,"Check your account balance for details.":r.InsufficientFunds,"Ensure this value has at least":r.InvalidAddress,"Ensure that there are no more than":r.InvalidOrder}}})}async fetchMarkets(e={}){const t=await this.fetchMarketsFromCache(e),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"name");let[a,o]=r.split("/");const n=a.toLowerCase(),d=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const h=this.safeString(i,"minimum_order").split(" "),c=this.safeString(i,"trading");s.push({id:this.safeString(i,"url_symbol"),marketId:n+"_"+d,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,future:!1,swap:!1,option:!1,active:"Enabled"===c,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(i,"base_decimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(i,"counter_decimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(h,0),max:void 0}},created:void 0,info:i})}return s}constructCurrencyObject(e,t,s,i,r,a){let o="crypto";const n=this.describe();this.isFiat(t)&&(o="fiat");const d=this.parseNumber(this.parsePrecision(this.numberToString(i)));return{id:e,code:t,info:a,type:o,name:s,active:!0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(n.fees.funding.withdraw,t),precision:d,limits:{amount:{min:d,max:void 0},price:{min:d,max:void 0},cost:{min:r,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}async fetchMarketsFromCache(e={}){const t=this.safeValue(this.options,"fetchMarkets",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===s||r-s>i){const s=await this.publicGetTradingPairsInfo(e);this.options.fetchMarkets=this.extend(t,{response:s,timestamp:r})}return this.safeValue(this.options.fetchMarkets,"response")}async fetchCurrencies(e={}){const t=await this.fetchMarketsFromCache(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"name");let[a,o]=r.split("/");const n=a.toLowerCase(),d=o.toLowerCase();a=this.safeCurrencyCode(a),o=this.safeCurrencyCode(o);const h=this.safeString(i,"description"),[c,l]=h.split(" / "),u=this.safeString(i,"minimum_order").split(" ")[0];if(!(a in s)){const e=this.safeInteger(i,"base_decimals");s[a]=this.constructCurrencyObject(n,a,c,e,void 0,i)}if(!(o in s)){const e=this.safeInteger(i,"counter_decimals");s[o]=this.constructCurrencyObject(d,o,l,e,this.parseNumber(u),i)}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id},a=await this.publicGetOrderBookPair(this.extend(r,s)),o=this.safeInteger(a,"microtimestamp"),n=this.parseToInt(o/1e3),d=this.parseOrderBook(a,i.symbol,n);return d.nonce=o,d}parseTicker(e,t=void 0){const s=this.safeString(e,"pair"),i=this.safeSymbol(s,t,void 0),r=this.safeTimestamp(e,"timestamp"),o=this.safeString(e,"vwap"),n=this.safeString(e,"volume"),d=a.Y.stringMul(n,o),h=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:o,open:this.safeString(e,"open"),close:h,last:h,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}getCurrencyIdFromTransaction(e){const t=this.safeStringLower(e,"currency");if(void 0!==t)return t;e=this.omit(e,["fee","price","datetime","type","status","id"]);const s=Object.keys(e);for(let t=0;t<s.length;t++){const i=s[t];if(i.indexOf("_")<0){const t=this.safeInteger(e,i);if(void 0!==t&&0!==t)return i}}}getMarketFromTrade(e){e=this.omit(e,["fee","price","datetime","tid","type","order_id","side"]);const t=Object.keys(e),s=t.length;if(s>2)throw new r.ExchangeError(this.id+" getMarketFromTrade() too many keys: "+this.json(t)+" in the trade: "+this.json(e));if(2===s){let e=t[0]+t[1];if(e in this.markets_by_id)return this.safeMarket(e);if(e=t[1]+t[0],e in this.markets_by_id)return this.safeMarket(e)}}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tid");let i,r,o=this.safeString(e,"price"),n=this.safeString(e,"amount");const d=this.safeString(e,"order_id");let h,c=this.safeString(e,"cost");if(void 0===t){const s=Object.keys(e);for(let e=0;e<s.length;e++){const i=s[e];"order_id"!==i&&i.indexOf("_")>=0&&(h=i,t=this.safeMarket(h,t,"_"))}}void 0===t&&(t=this.getMarketFromTrade(e));const l=this.safeString(e,"fee"),u=t.quote,p=void 0!==h?h:t.marketId;o=this.safeString(e,p,o),n=this.safeString(e,t.baseId,n),c=this.safeString(e,t.quoteId,c),i=t.symbol;const f=this.safeString2(e,"date","datetime");let m,g;if(void 0!==f&&(f.indexOf(" ")>=0?m=this.parse8601(f):(m=parseInt(f),m*=1e3)),"id"in e){if(void 0!==n){a.Y.stringLt(n,"0")?(r="sell",n=a.Y.stringNeg(n)):r="buy"}}else r=this.safeString(e,"type"),r="1"===r?"sell":"0"===r?"buy":void 0;return void 0!==c&&(c=a.Y.stringAbs(c)),void 0!==l&&(g={cost:l,currency:u}),this.safeTrade({id:s,info:e,timestamp:m,datetime:this.iso8601(m),symbol:i,order:d,type:undefined,side:r,takerOrMaker:void 0,price:o,amount:n,cost:c,fee:g},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id,time:"hour"},o=await this.publicGetTransactionsPair(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,step:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t);if(void 0===i)if(void 0===s)o.limit=1e3;else{i=1e3;const e=this.parseToInt(s/1e3);o.start=e,o.end=this.sum(e,n*(i-1)),o.limit=i}else{if(void 0!==s){const e=this.parseToInt(s/1e3);o.start=e,o.end=this.sum(e,n*(i-1))}o.limit=Math.min(i,1e3)}const d=await this.publicGetOhlcPair(this.extend(o,r)),h=this.safeValue(d,"data",{}),c=this.safeList(h,"ohlc",[]);return this.parseOHLCVs(c,a,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};void 0===e&&(e=[]);for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.used=this.safeString(i,"reserved"),o.total=this.safeString(i,"total"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalances(e);return this.parseBalance(t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_symbol:s.id},r=await this.privatePostFeesTrading(this.extend(i,t)),a=this.indexBy(r,"currency_pair"),o=this.safeDict(a,s.id);return this.parseTradingFee(o,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeDict(e,"fees",{});return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(i,"maker"),taker:this.safeNumber(i,"taker"),percentage:void 0,tierBased:void 0}}parseTradingFees(e){const t={info:e},s=this.symbols;for(let i=0;i<s.length;i++){const r=s[i],a=this.parseTradingFee(e[i]);t[r]=a}return t}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostFeesTrading(e);return this.parseTradingFees(t)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostFeesWithdrawal(t);return this.parseTransactionFees(s)}parseTransactionFees(e,t=void 0){const s={},i=this.indexBy(e,"currency"),r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a],n=this.safeValue(e,a,{}),d=this.safeCurrencyCode(o);(void 0===t||this.inArray(d,t))&&(s[d]={withdraw_fee:this.safeNumber(n,"fee"),deposit:{},info:this.safeDict(i,o)})}return s}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostFeesWithdrawal(t),i=this.groupBy(s,"currency");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e);for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"network"),a=this.networkIdToCode(r),o=this.safeNumber(i,"fee");s.withdraw={fee:o,percentage:void 0},s.networks[a]={withdraw:{fee:o,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return s}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={pair:o.id,amount:this.amountToPrecision(e,i)},d=this.safeString2(a,"client_order_id","clientOrderId");let h;void 0!==d&&(n.client_order_id=d,a=this.omit(a,["clientOrderId"]));const c=this.capitalize(s);"market"===t?h="Buy"===c?await this.privatePostBuyMarketPair(this.extend(n,a)):await this.privatePostSellMarketPair(this.extend(n,a)):"instant"===t?h="Buy"===c?await this.privatePostBuyInstantPair(this.extend(n,a)):await this.privatePostSellInstantPair(this.extend(n,a)):(n.price=this.priceToPrecision(e,r),h="Buy"===c?await this.privatePostBuyPair(this.extend(n,a)):await this.privatePostSellPair(this.extend(n,a)));const l=this.parseOrder(h,o);return l.type=t,l}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privatePostCancelOrder(this.extend(i,s));return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};let r;void 0!==e?(s=this.market(e),i.pair=s.id,r=await this.privatePostCancelAllOrdersPair(this.extend(i,t))):r=await this.privatePostCancelAllOrders(this.extend(i,t));const a=this.safeList(r,"canceled");return this.parseOrders(a)}parseOrderStatus(e){return this.safeString({"In Queue":"open",Open:"open",Finished:"closed",Canceled:"canceled"},e,e)}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"client_order_id","clientOrderId"),r={};void 0!==i?(r.client_order_id=i,s=this.omit(s,["client_order_id","clientOrderId"])):r.id=e;const a=await this.privatePostOrderStatus(this.extend(r,s));return this.parseOrderStatus(this.safeString(a,"status"))}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r=this.safeValue2(s,"client_order_id","clientOrderId"),a={};void 0!==r?(a.client_order_id=r,s=this.omit(s,["client_order_id","clientOrderId"])):a.id=e;const o=await this.privatePostOrderStatus(this.extend(a,s));return this.parseOrder(o,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o="privatePostUserTransactions";void 0!==e&&(a=this.market(e),r.pair=a.id,o+="Pair"),void 0!==s&&(r.limit=s);const n=await this[o](this.extend(r,i)),d=this.filterBy(n,"type","2");return this.parseTrades(d,a,t,s)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==s&&(r.limit=s);const a=await this.privatePostUserTransactions(this.extend(r,i));let o;void 0!==e&&(o=this.currency(e));const n=this.filterByArray(a,"type",["0","1"],!1);return this.parseTransactions(n,o,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};r.timedelta=void 0!==t?this.milliseconds()-t:5e7;const a=await this.privatePostWithdrawalRequests(this.extend(r,i));return this.parseTransactions(a,void 0,t,s)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"datetime")),i=this.getCurrencyIdFromTransaction(e),r=this.safeCurrencyCode(i,t),o=this.safeString(e,"fee");let n,d;"amount"in e?d=this.safeString(e,"amount"):void 0!==t?(d=this.safeString(e,t.id,d),n=t.code):void 0!==r&&void 0!==i&&(d=this.safeString(e,i,d),n=r),void 0!==d&&(d=a.Y.stringAbs(d));let h,c,l="ok";if("status"in e&&(l=this.parseTransactionStatus(this.safeString(e,"status"))),"type"in e){const t=this.safeString(e,"type");"0"===t?h="deposit":"1"===t&&(h="withdrawal")}else h="withdrawal";let u=this.safeString(e,"address");if(void 0!==u){const e=u.split("?dt=");e.length>1&&(u=e[0],c=e[1])}let p={currency:void 0,cost:void 0,rate:void 0};return void 0!==o&&(p={currency:n,cost:o,rate:void 0}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),type:h,currency:r,network:void 0,amount:this.parseNumber(d),status:l,timestamp:s,datetime:this.iso8601(s),address:u,addressFrom:void 0,addressTo:u,tag:c,tagFrom:void 0,tagTo:c,updated:void 0,comment:void 0,internal:void 0,fee:p}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"pending",2:"ok",3:"canceled",4:"failed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id");let r=this.safeString(e,"type");void 0!==r&&(r="1"===r?"sell":"buy");const a=this.parse8601(this.safeString(e,"datetime")),o=this.safeStringLower(e,"currency_pair"),n=this.safeSymbol(o,t,"/"),d=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeString(e,"amount"),c=this.safeValue(e,"transactions",[]),l=this.safeString(e,"price");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(a),timestamp:a,lastTradeTimestamp:void 0,status:d,symbol:n,type:void 0,timeInForce:void 0,postOnly:void 0,side:r,price:l,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:h,filled:void 0,remaining:void 0,trades:c,fee:void 0,info:e,average:void 0},t)}parseLedgerEntryType(e){return this.safeString({0:"transaction",1:"transaction",2:"trade",14:"transfer"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString(e,"type"));if("trade"===s){const t=this.parseTrade(e);let i;const r=Object.keys(e);for(let e=0;e<r.length;e++)if(r[e].indexOf("_")>=0){const t=r[e].replace("_","");i=this.safeMarket(t,i)}void 0===i&&(i=this.getMarketFromTrade(e));const a="buy"===t.side?"in":"out";return{id:t.id,info:e,timestamp:t.timestamp,datetime:t.datetime,direction:a,account:void 0,referenceId:t.order,referenceAccount:void 0,type:s,currency:i.base,amount:t.amount,before:void 0,after:void 0,status:"ok",fee:t.fee}}{const i=this.parseTransaction(e,t);let r;if("amount"in e){const t=this.safeString(e,"amount");r=a.Y.stringGt(t,"0")?"in":"out"}else if("currency"in i&&void 0!==i.currency){const s=this.safeString(i,"currency");t=this.currency(s);const o=this.safeString(e,t.id);r=a.Y.stringGt(o,"0")?"in":"out"}return{id:i.id,info:e,timestamp:i.timestamp,datetime:i.datetime,direction:r,account:void 0,referenceId:i.txid,referenceAccount:void 0,type:s,currency:i.currency,amount:i.amount,before:void 0,after:void 0,status:i.status,fee:i.fee}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==s&&(r.limit=s);const a=await this.privatePostUserTransactions(this.extend(r,i));let o;return void 0!==e&&(o=this.currency(e)),this.parseLedger(a,o,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privatePostOpenOrdersAll(i);return this.parseOrders(a,r,t,s,{status:"open",type:"limit"})}getCurrencyName(e){return e.toLowerCase()}isFiat(e){return"USD"===e||"EUR"===e||"GBP"===e}async fetchDepositAddress(e,t={}){if(this.isFiat(e))throw new r.NotSupported(this.id+" fiat fetchDepositAddress() for "+e+" is not supported!");const s=this.getCurrencyName(e),i="privatePost"+this.capitalize(s)+"Address",a=await this[i](t),o=this.safeString(a,"address"),n=this.safeString2(a,"memo_id","destination_tag");return this.checkAddress(o),{currency:e,address:o,tag:n,network:void 0,info:a}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets(),this.checkAddress(s);const a={amount:t};let o,n;if(this.isFiat(e))n="privatePostWithdrawalOpen",o=this.currency(e),a.iban=s,a.account_currency=o.id;else{const t=this.getCurrencyName(e);n="privatePost"+this.capitalize(t)+"Withdrawal","XRP"===e?void 0!==i&&(a.destination_tag=i):"XLM"!==e&&"HBAR"!==e||void 0!==i&&(a.memo_id=i),a.address=s}const d=await this[n](this.extend(a,r));return this.parseTransaction(d,o)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n={amount:this.parseToNumeric(this.currencyToPrecision(e,t)),currency:o.id.toUpperCase()};let d;if("main"===s)n.subAccount=i,d=await this.privatePostTransferFromMain(this.extend(n,a));else{if("main"!==i)throw new r.BadRequest(this.id+" transfer() only supports from or to main");n.subAccount=s,d=await this.privatePostTransferToMain(this.extend(n,a))}const h=this.parseTransfer(d,o);return h.amount=t,h.fromAccount=s,h.toAccount=i,h}parseTransfer(e,t=void 0){const s=this.safeString(e,"status");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:t.code,amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return this.safeString({ok:"ok",error:"failed"},e,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/";o+=this.version+"/",o+=this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e="BITSTAMP "+this.apiKey,t=this.uuid(),i=this.milliseconds().toString(),h="v2";let c="";r={"X-Auth":e,"X-Auth-Nonce":t,"X-Auth-Timestamp":i,"X-Auth-Version":h},"POST"===s&&(Object.keys(d).length?(a=this.urlencode(d),c="application/x-www-form-urlencoded",r["Content-Type"]=c):(a=this.urlencode({foo:"bar"}),c="application/x-www-form-urlencoded",r["Content-Type"]=c));const l=a||"",u=e+s+o.replace("https://","")+c+t+i+h+l,p=this.hmac(this.encode(u),this.encode(this.secret),n.s);r["X-Auth-Signature"]=p}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"status"),l=this.safeValue(n,"error");if("error"===c||void 0!==l){let e=[];if("string"==typeof l)e.push(l);else if(void 0!==l){const t=Object.keys(l);for(let s=0;s<t.length;s++){const i=t[s],r=this.safeValue(l,i);Array.isArray(r)?e=this.arrayConcat(e,r):e.push(r)}}const t=this.safeValue(n,"reason",{});if("string"==typeof t)e.push(t);else{const s=this.safeValue(t,"__all__",[]);for(let t=0;t<s.length;t++)e.push(s[t])}if("API0005"===this.safeString(n,"code"))throw new r.AuthenticationError(this.id+" invalid signature, use the uid for the main account if you have subaccounts");const s=this.id+" "+o;for(let t=0;t<e.length;t++){const i=e[t];this.throwExactlyMatchedException(this.exceptions.exact,i,s),this.throwBroadlyMatchedException(this.exceptions.broad,i,s)}throw new r.ExchangeError(s)}}}},112:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(8535),r=s(2079),a=s(1579),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitteam",name:"BIT.TEAM",countries:["UK"],version:"v2.0.6",rateLimit:1,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,deposit:!1,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrder:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1,ws:!1},timeframes:{"1m":"1","5m":"5","15m":"15","1h":"60","1d":"1D"},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/cf71fe3d-b8b4-40f2-a906-907661b28793",api:{history:"https://history.bit.team",public:"https://bit.team",private:"https://bit.team"},www:"https://bit.team/",referral:"https://bit.team/auth/sign-up?ref=bitboy2023",doc:["https://bit.team/trade/api/documentation"]},api:{history:{get:{"api/tw/history/{pairName}/{resolution}":1}},public:{get:{"trade/api/asset":1,"trade/api/currencies":1,"trade/api/orderbooks/{symbol}":1,"trade/api/orders":1,"trade/api/pair/{name}":1,"trade/api/pairs":1,"trade/api/pairs/precisions":1,"trade/api/rates":1,"trade/api/trade/{id}":1,"trade/api/trades":1,"trade/api/ccxt/pairs":1,"trade/api/cmc/assets":1,"trade/api/cmc/orderbook/{pair}":1,"trade/api/cmc/summary":1,"trade/api/cmc/ticker":1,"trade/api/cmc/trades/{pair}":1}},private:{get:{"trade/api/ccxt/balance":1,"trade/api/ccxt/order/{id}":1,"trade/api/ccxt/ordersOfUser":1,"trade/api/ccxt/tradesOfUser":1,"trade/api/transactionsOfUser":1},post:{"trade/api/ccxt/cancel-all-order":1,"trade/api/ccxt/cancelorder":1,"trade/api/ccxt/ordercreate":1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:a.kb,options:{networksById:{Ethereum:"ERC20",ethereum:"ERC20",Tron:"TRC20",tron:"TRC20",Binance:"BSC",binance:"BSC","Binance Smart Chain":"BSC",bscscan:"BSC",Bitcoin:"BTC",bitcoin:"BTC",Litecoin:"LTC",litecoin:"LTC",Polygon:"POLYGON",polygon:"POLYGON",PRIZM:"PRIZM",Decimal:"Decimal",ufobject:"ufobject",tonchain:"tonchain"},currenciesValuedInUsd:{USDT:!0,BUSD:!0}},exceptions:{exact:{400002:r.BadSymbol,401e3:r.AuthenticationError,403002:r.BadRequest,404200:r.BadSymbol},broad:{"is not allowed":r.BadRequest,"Insufficient funds":r.InsufficientFunds,"Invalid request params input":r.BadRequest,"must be a number":r.BadRequest,"must be a string":r.BadRequest,"must be of type":r.BadRequest,"must be one of":r.BadRequest,"Order not found":r.OrderNotFound,"Pair with pair name":r.BadSymbol,pairName:r.BadSymbol,"Service Unavailable":r.ExchangeNotAvailable,"Symbol ":r.BadSymbol}}})}async fetchMarkets(e={}){const t=await this.publicGetTradeApiCcxtPairs(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"pairs",[]);return this.parseMarkets(i)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeInteger(e,"id"),i=t.split("_"),r=this.safeString(i,0),a=this.safeString(i,1),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a),d=this.safeValue(e,"active"),h=this.safeString(e,"timeStart"),c=this.parse8601(h);let l;const u=this.safeValue(this.options,"currenciesValuedInUsd",{});if(this.safeBool(u,n,!1)){const t=this.safeValue(e,"settings",{});l=this.safeNumber(t,"limit_usd")}return this.safeMarketStructure({id:t,numericId:s,symbol:o+"/"+n,base:o,quote:n,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:d,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"baseStep"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"quoteStep")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:l,max:void 0}},created:c,info:e})}async fetchCurrencies(e={}){const t=await this.publicGetTradeApiCurrencies(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"currencies",[]);let r=await this.publicGetTradeApiCmcAssets();r=this.indexBy(r,"unified_cryptoasset_id");const a={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"symbol"),o=this.safeInteger(t,"id"),n=this.safeCurrencyCode(s),d=this.safeBool(t,"active",!1),h=this.parseNumber(this.parsePrecision(this.safeString(t,"precision"))),c=this.safeValue(t,"txLimits",{}),l=this.safeString(c,"minWithdraw"),u=this.safeString(c,"maxWithdraw"),p=this.safeString(c,"minDeposit");let f;const m=this.safeValue(c,"withdrawCommissionFixed",{});let g={};const v=this.safeString(t,"blockChain");void 0!==v&&""!==v?(f=this.parseNumber(m),g[v]=f):g=m;const y=this.safeValue(r,o,{}),w=this.safeValue(y,"depositStatus"),b=this.safeValue(y,"withdrawStatus"),S=Object.keys(g),k={},O=this.parseNumber(this.parsePrecision(this.safeString(t,"decimals")));for(let e=0;e<S.length;e++){const s=S[e],i=this.networkIdToCode(s,n),r=this.safeNumber(g,s);k[i]={id:s,network:i,deposit:w,withdraw:b,active:d,fee:r,precision:O,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(l),max:this.parseNumber(u)},deposit:{min:this.parseNumber(p),max:void 0}},info:t}}a[n]={id:s,numericId:o,code:n,name:n,info:t,active:d,deposit:w,withdraw:b,fee:f,precision:h,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(l),max:this.parseNumber(u)},deposit:{min:this.parseNumber(p),max:void 0}},networks:k}}return a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t,t),n={pairName:a.id,resolution:o},d=await this.historyGetApiTwHistoryPairNameResolution(this.extend(n,r)),h=this.safeValue(d,"result",{}),c=this.safeList(h,"data",[]);return this.parseOHLCVs(c,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={pair:this.market(e).id},r=await this.publicGetTradeApiCmcOrderbookPair(this.extend(i,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={type:this.safeString(i,"type","all")};let a;void 0!==e&&(a=this.market(e),r.pair=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetTradeApiCcxtOrdersOfUser(this.extend(r,i)),n=this.safeValue(o,"result",{}),d=this.safeList(n,"orders",[]);return this.parseOrders(d,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e};let r;void 0!==t&&(r=this.market(t));const a=await this.privateGetTradeApiCcxtOrderId(this.extend(i,s)),o=this.safeDict(a,"result");return this.parseOrder(o,r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return await this.fetchOrders(e,t,s,this.extend({type:"active"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return await this.fetchOrders(e,t,s,this.extend({type:"closed"},i))}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return await this.fetchOrders(e,t,s,this.extend({type:"cancelled"},i))}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={pairId:n.numericId.toString(),type:t,side:s,amount:this.amountToPrecision(e,i)};if("limit"===t){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for a "+t+" order");d.price=this.priceToPrecision(e,a)}const h=await this.privatePostTradeApiCcxtOrdercreate(this.extend(d,o)),c=this.safeDict(h,"result",{});return this.parseOrder(c,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privatePostTradeApiCcxtCancelorder(this.extend(i,s)),a=this.safeDict(r,"result",{});return this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};void 0!==e?(s=this.market(e),i.pairId=s.numericId.toString()):i.pairId="0";const r=await this.privatePostTradeApiCcxtCancelAllOrder(this.extend(i,t)),a=[this.safeValue(r,"result",{})];return this.parseOrders(a,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"pair");t=this.safeMarket(i,t);const r=this.safeString(e,"orderCid");let a;const o=this.safeString(e,"createdAt");a=void 0!==o?this.parse8601(o):this.safeTimestamp(e,"timestamp");const n=this.safeString(e,"updatedAt"),d=this.parse8601(n),h=this.parseOrderStatus(this.safeString(e,"status")),c=this.parseOrderType(this.safeString(e,"type")),l=this.safeString(e,"side"),u=this.safeValue(e,"fee"),p=this.safeString(e,"price"),f=this.safeString(e,"stopPrice"),m=this.safeString(e,"quantity"),g=this.safeString(e,"executed");let v;if(void 0!==u){const e=this.safeString(u,"amount"),t=this.safeString(u,"symbol");v={currency:this.safeCurrencyCode(t),cost:e,rate:void 0}}return this.safeOrder({id:s,clientOrderId:r,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,lastUpdateTimestamp:d,status:h,symbol:t.symbol,type:c,timeInForce:"GTC",side:l,price:p,stopPrice:f,triggerPrice:f,average:void 0,amount:m,cost:void 0,filled:g,remaining:void 0,fee:v,trades:void 0,info:e,postOnly:!1},t)}parseOrderStatus(e){return this.safeString({accepted:"open",executed:"closed",cancelled:"canceled",partiallyCancelled:"canceled",delete:"rejected",inactive:"rejected",executing:"open",created:"open"},e,e)}parseOrderType(e){return this.safeString({market:"market",limit:"limit"},e,e)}parseValueToPricision(e,t,s,i){const r=this.safeString(e,t),a=this.safeString(s,i);if(void 0===r||void 0===a)return;const n=this.parsePrecision(a);return o.Y.stringMul(r,n)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();let s=await this.publicGetTradeApiCmcSummary();const i=[];Array.isArray(s)||(s=[]);for(let e=0;e<s.length;e++){const t=s[e],r=this.parseTicker(t);i.push(r)}return this.filterByArrayTickers(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={name:s.id},r=await this.publicGetTradeApiPairName(this.extend(i,t)),a=this.safeValue(r,"result",{}),o=this.safeDict(a,"pair",{});return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeStringLower(e,"trading_pairs");let i,r,a,o;t=this.safeMarket(s,t);const n=this.safeValue(e,"bids"),d=this.safeValue(e,"asks");if(void 0!==n&&Array.isArray(n)&&void 0!==d&&Array.isArray(d)){const e=this.safeValue(n,0,{});i=this.safeString(e,"price"),a=this.safeString(e,"quantity");const t=this.safeValue(d,0,{});r=this.safeString(t,"price"),o=this.safeString(t,"quantity")}else i=this.safeString(e,"highest_bid"),r=this.safeString(e,"lowest_ask");const h=this.safeString2(e,"volume24","base_volume"),c=this.safeString2(e,"quoteVolume24","quote_volume"),l=this.safeString2(e,"highPrice24","highest_price_24h"),u=this.safeString2(e,"lowPrice24","lowest_price_24h"),p=this.safeString2(e,"lastPrice","last_price"),f=this.safeString2(e,"change24","price_change_percent_24h");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,open:void 0,high:l,low:u,close:p,bid:i,bidVolume:a,ask:r,askVolume:o,vwap:void 0,previousClose:void 0,change:void 0,percentage:f,average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTradeApiCmcTradesPair(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.pairId=a.numericId),void 0!==s&&(r.limit=s);const o=await this.privateGetTradeApiCcxtTradesOfUser(this.extend(r,i)),n=this.safeValue(o,"result",{}),d=this.safeList(n,"trades",[]);return this.parseTrades(d,a,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"pair"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"id","trade_id"),a=this.safeString(e,"price"),n=this.safeString2(e,"quantity","base_volume"),d=this.safeString(e,"quote_volume"),h=this.safeString(e,"isCurrentSide");let c=this.safeString(e,"timestamp");void 0!==h&&(c=o.Y.stringMul(c,"1000"));let l,u,p=this.safeString2(e,"side","type");"maker"===h?("sell"===p?p="buy":"buy"===p&&(p="sell"),u=this.safeString(e,"makerOrderId"),l=this.safeValue(e,"feeMaker",{})):"taker"===h&&(u=this.safeString(e,"takerOrderId"),l=this.safeValue(e,"feeTaker",{}));const f=this.safeString(l,"symbol"),m=this.safeString(l,"amount"),g={currency:this.safeCurrencyCode(f),cost:m},v=this.parseToInt(c);return this.safeTrade({id:r,order:u,timestamp:v,datetime:this.iso8601(v),symbol:i,type:void 0,side:p,takerOrMaker:h,price:a,amount:n,cost:d,fee:g,info:e},t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetTradeApiCcxtBalance(e);return this.parseBalance(t)}parseBalance(e){const t=this.milliseconds(),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"result",{}),r=this.omit(i,["free","used","total"]),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],r=this.safeValue(i,t),o=this.safeString(r,"free"),n=this.safeString(r,"used"),d=this.safeString(r,"total");s[this.safeCurrencyCode(t.toLowerCase())]={free:o,used:n,total:d}}return this.safeBalance(s)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.currency=r.numericId),void 0!==s&&(a.limit=s);const o=await this.privateGetTradeApiTransactionsOfUser(this.extend(a,i)),n=this.safeValue(o,"result",{}),d=this.safeList(n,"transactions",[]);return this.parseTransactions(d,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeValue(e,"currency"),i=this.safeString(s,"symbol"),r=this.safeCurrencyCode(i,t),a=this.safeString(e,"id"),o=this.safeValue(e,"params"),n=this.safeString(o,"tx_id"),d=this.safeInteger(e,"timestamp");let h=this.safeString(e,"blockChain");if(void 0===h){const e=this.safeValue(s,"links",[]),t=this.safeValue(e,0,{});h=this.safeString(t,"blockChain")}const c=this.safeString(e,"sender"),l=this.safeString(e,"recipient"),u=this.safeString(e,"message"),p=this.parseTransactionType(this.safeString(e,"type")),f=this.parseValueToPricision(e,"amount",s,"decimals"),m=this.parseTransactionStatus(this.safeValue(e,"status"));return{info:e,id:a,txid:n,timestamp:d,datetime:this.iso8601(d),network:this.networkIdToCode(h),addressFrom:c,address:void 0,addressTo:l,tagFrom:void 0,tag:u,tagTo:void 0,type:p,amount:this.parseNumber(f),currency:r,status:m,updated:void 0,fee:void 0,comment:this.safeString(e,"description"),internal:!1}}parseTransactionType(e){return this.safeString({deposit:"deposit",withdraw:"withdrawal"},e,e)}parseTransactionStatus(e){return this.safeString({approving:"pending",success:"ok"},e,e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),n="/"+this.implodeParams(e,i);let d=this.urls.api[t]+n;const h=this.urlencode(o);if("private"===t){this.checkRequiredCredentials(),"POST"===s?a=this.json(o):0!==h.length&&(d+="?"+h);const e=this.apiKey+":"+this.secret;r={Authorization:"Basic "+this.stringToBase64(e),"Content-Type":"application/json"}}else 0!==h.length&&(d+="?"+h);return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&200!==e){if(404===e){if(s.indexOf("/ccxt/order/")>=0&&"GET"===i){const e=s.split("/order/"),t=this.safeString(e,1);throw new r.OrderNotFound(this.id+" order "+t+" not found")}if(s.indexOf("/cmc/orderbook/")>=0){const e=s.split("/cmc/orderbook/"),t=this.safeString(e,1);throw new r.BadSymbol(this.id+" symbolId "+t+" not found")}}const t=this.id+" "+o,a=this.safeString(n,"message"),d=this.safeString(n,"code");throw this.throwBroadlyMatchedException(this.exceptions.broad,a,t),this.throwExactlyMatchedException(this.exceptions.exact,d,t),new r.ExchangeError(t)}}}},3727:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8716),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bitvavo",name:"Bitvavo",countries:["NL"],rateLimit:60,version:"v2",certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/169202626-bd130fc5-fcf9-41bb-8d97-6093225c73cd.jpg",api:{public:"https://api.bitvavo.com",private:"https://api.bitvavo.com"},www:"https://bitvavo.com/",doc:"https://docs.bitvavo.com/",fees:"https://bitvavo.com/en/fees",referral:"https://bitvavo.com/?a=24F34952F7"},api:{public:{get:{time:1,markets:1,assets:1,"{market}/book":1,"{market}/trades":5,"{market}/candles":1,"ticker/price":1,"ticker/book":1,"ticker/24h":{cost:1,noMarket:25}}},private:{get:{account:1,order:1,orders:5,ordersOpen:{cost:1,noMarket:25},trades:5,balance:5,deposit:1,depositHistory:5,withdrawalHistory:5},post:{order:1,withdrawal:1},put:{order:1},delete:{order:1,orders:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0020")],[this.parseNumber("250000"),this.parseNumber("0.0016")],[this.parseNumber("500000"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.0010")],[this.parseNumber("2500000"),this.parseNumber("0.0008")],[this.parseNumber("5000000"),this.parseNumber("0.0006")],[this.parseNumber("10000000"),this.parseNumber("0.0005")],[this.parseNumber("25000000"),this.parseNumber("0.0004")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0010")],[this.parseNumber("250000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0006")],[this.parseNumber("1000000"),this.parseNumber("0.0005")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("10000000"),this.parseNumber("0.0003")],[this.parseNumber("25000000"),this.parseNumber("0.0003")]]}}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{101:r.ExchangeError,102:r.BadRequest,103:r.RateLimitExceeded,104:r.RateLimitExceeded,105:r.PermissionDenied,107:r.ExchangeNotAvailable,108:r.ExchangeNotAvailable,109:r.ExchangeNotAvailable,110:r.BadRequest,200:r.BadRequest,201:r.BadRequest,202:r.BadRequest,203:r.BadSymbol,204:r.BadRequest,205:r.BadRequest,206:r.BadRequest,210:r.InvalidOrder,211:r.InvalidOrder,212:r.InvalidOrder,213:r.InvalidOrder,214:r.InvalidOrder,215:r.InvalidOrder,216:r.InsufficientFunds,217:r.InvalidOrder,230:r.ExchangeError,231:r.ExchangeError,232:r.BadRequest,233:r.InvalidOrder,234:r.InvalidOrder,235:r.ExchangeError,236:r.BadRequest,240:r.OrderNotFound,300:r.AuthenticationError,301:r.AuthenticationError,302:r.AuthenticationError,303:r.AuthenticationError,304:r.AuthenticationError,305:r.AuthenticationError,306:r.AuthenticationError,307:r.PermissionDenied,308:r.AuthenticationError,309:r.AuthenticationError,310:r.PermissionDenied,311:r.PermissionDenied,312:r.PermissionDenied,315:r.BadRequest,317:r.AccountSuspended,400:r.ExchangeError,401:r.ExchangeError,402:r.PermissionDenied,403:r.PermissionDenied,404:r.OnMaintenance,405:r.ExchangeError,406:r.BadRequest,407:r.ExchangeError,408:r.InsufficientFunds,409:r.InvalidAddress,410:r.ExchangeError,411:r.BadRequest,412:r.InvalidAddress,413:r.InvalidAddress,414:r.ExchangeError},broad:{"start parameter is invalid":r.BadRequest,"symbol parameter is invalid":r.BadSymbol,"amount parameter is invalid":r.InvalidOrder,"orderId parameter is invalid":r.InvalidOrder}},options:{"BITVAVO-ACCESS-WINDOW":1e4,networks:{ERC20:"ETH",TRC20:"TRX"}},precisionMode:a.v,commonCurrencies:{MIOTA:"IOTA"}})}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,a.fv)}amountToPrecision(e,t){return this.decimalToPrecision(t,a.R3,this.markets[e].precision.amount,a.fv)}priceToPrecision(e,t){return t=this.decimalToPrecision(t,a.D_,this.markets[e].precision.price,this.precisionMode),this.decimalToPrecision(t,a.R3,8,a.fv)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"time")}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e);return this.parseMarkets(t)}parseMarkets(e){const t=this.currencies,s=this.indexBy(t,"id"),i=[],r=this.fees;for(let t=0;t<e.length;t++){const a=e[t],o=this.safeString(a,"market"),n=this.safeString(a,"base"),d=this.safeString(a,"quote"),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=this.safeString(a,"status"),u=this.safeValue(s,n),p=this.safeInteger(u,"precision");i.push(this.safeMarketStructure({id:o,symbol:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"trading"===l,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,taker:r.trading.taker,maker:r.trading.maker,precision:{amount:this.safeInteger(u,"decimals",p),price:this.safeInteger(a,"pricePrecision")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(a,"minOrderInBaseAsset"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(a,"minOrderInQuoteAsset"),max:void 0}},created:void 0,info:a}))}return i}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e);return this.parseCurrencies(t)}parseCurrencies(e){const t={};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"symbol"),a=this.safeCurrencyCode(r),o={},n=this.safeValue(i,"networks",[]),d=1===n.length,h="OK"===this.safeValue(i,"depositStatus"),c="OK"===this.safeValue(i,"withdrawalStatus"),l=h&&c,u=this.safeNumber(i,"withdrawalFee"),p=this.safeInteger(i,"decimals",8),f=this.safeNumber(i,"withdrawalMinAmount");if(d){const e=n[0],t=this.networkIdToCode(e);o[t]={info:i,id:e,network:t,active:l,deposit:h,withdraw:c,fee:u,precision:p,limits:{withdraw:{min:f,max:void 0}}}}t[a]={info:i,id:r,code:a,name:this.safeString(i,"name"),active:l,deposit:h,withdraw:c,networks:o,fee:u,precision:p,limits:{amount:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},withdraw:{min:f,max:void 0}}}}return this.currencies=this.deepExtend(this.currencies,t),t}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.publicGetTicker24h(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"last"),o=this.safeString(e,"volume"),n=this.safeString(e,"volumeQuote"),d=this.safeString(e,"open");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:d,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker24h(t);return this.parseTickers(s,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);let o={market:r.id};void 0!==s&&(o.limit=Math.min(s,1e3)),void 0!==t&&(o.start=t),[o,i]=this.handleUntilOption("end",o,i);const n=await this.publicGetMarketTrades(this.extend(o,i));return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"price"),i=this.safeString(e,"amount"),r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"side"),o=this.safeString2(e,"id","fillId"),n=this.safeString(e,"market"),d=this.safeSymbol(n,t,"-"),h=this.safeValue(e,"taker");let c;void 0!==h&&(c=h?"taker":"maker");const l=this.safeString(e,"fee");let u;if(void 0!==l){const t=this.safeString(e,"feeCurrency");u={cost:l,currency:this.safeCurrencyCode(t)}}const p=this.safeString(e,"orderId");return this.safeTrade({info:e,id:o,symbol:d,timestamp:r,datetime:this.iso8601(r),order:p,type:void 0,side:a,takerOrMaker:c,price:s,amount:i,cost:void 0,fee:u},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccount(e);return this.parseTradingFees(t)}parseTradingFees(e,t=void 0){const s=this.safeValue(e,"fees"),i=this.safeNumber(s,"maker"),r=this.safeNumber(s,"taker"),a={};for(let t=0;t<this.symbols.length;t++){const s=this.symbols[t];a[s]={info:e,symbol:s,maker:i,taker:r,percentage:!0,tierBased:!0}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={market:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetMarketBook(this.extend(r,s)),o=this.parseOrderBook(a,i.symbol);return o.nonce=this.safeInteger(a,"nonce"),o}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}fetchOHLCVRequest(e,t="1m",s=void 0,i=void 0,r={}){let a={market:this.market(e).id,interval:this.safeString(this.timeframes,t,t)};if(void 0!==s){const e=this.parseTimeframe(t);a.start=s,i=void 0===i?1440:Math.min(i,1440),a.end=this.sum(s,i*e*1e3)}return[a,r]=this.handleUntilOption("end",a,r),void 0!==i&&(a.limit=i),this.extend(a,r)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1440);const n=this.fetchOHLCVRequest(e,t,s,i,r),d=await this.publicGetMarketCandles(n);return this.parseOHLCVs(d,a,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"symbol"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.used=this.safeString(i,"inOrder"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={symbol:this.currency(e).id},i=await this.privateGetDeposit(this.extend(s,t)),r=this.safeString(i,"address"),a=this.safeString(i,"paymentId");return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:i}}createOrderRequest(e,t,s,i,r=void 0,n={}){const d=this.market(e),h={market:d.id,side:s,orderType:t},c="market"===t||"stopLoss"===t||"takeProfit"===t,l="limit"===t||"stopLossLimit"===t||"takeProfitLimit"===t,u=this.safeString(n,"timeInForce");let p=this.safeStringN(n,["triggerPrice","stopPrice","triggerAmount"]);const f=this.isPostOnly(c,!1,n),m=this.safeValue(n,"stopLossPrice"),g=this.safeValue(n,"takeProfitPrice");if(n=this.omit(n,["timeInForce","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),c){let t;if(void 0!==r){const e=this.numberToString(r),s=this.numberToString(i),a=o.Y.stringMul(s,e);t=this.parseNumber(a)}else t=this.safeNumber(n,"cost");if(void 0!==t){const e=this.currency(d.quote).precision;h.amountQuote=this.decimalToPrecision(t,a.R3,e,this.precisionMode)}else h.amount=this.amountToPrecision(e,i);n=this.omit(n,["cost"])}else l&&(h.price=this.priceToPrecision(e,r),h.amount=this.amountToPrecision(e,i));const v=void 0!==g||"takeProfit"===t||"takeProfitLimit"===t;return void 0!==m||void 0!==p&&!v||"stopLoss"===t||"stopLossLimit"===t?(void 0!==m&&(p=m),h.orderType=c?"stopLoss":"stopLossLimit"):v&&(void 0!==g&&(p=g),h.orderType=c?"takeProfit":"takeProfitLimit"),void 0!==p&&(h.triggerAmount=this.priceToPrecision(e,p),h.triggerType="price",h.triggerReference="lastTrade"),void 0!==u&&"PO"!==u&&(h.timeInForce=u),f&&(h.postOnly=!0),this.extend(h,n)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.createOrderRequest(e,t,s,i,r,a),d=await this.privatePostOrder(n);return this.parseOrder(d,o)}editOrderRequest(e,t,s,i,a=void 0,o=void 0,n={}){let d={};const h=this.market(t),c=this.safeNumber(n,"amountRemaining"),l=this.safeStringN(n,["triggerPrice","stopPrice","triggerAmount"]);if(n=this.omit(n,["amountRemaining","triggerPrice","stopPrice","triggerAmount"]),void 0!==o&&(d.price=this.priceToPrecision(t,o)),void 0!==a&&(d.amount=this.amountToPrecision(t,a)),void 0!==c&&(d.amountRemaining=this.amountToPrecision(t,c)),void 0!==l&&(d.triggerAmount=this.priceToPrecision(t,l)),d=this.extend(d,n),this.isEmpty(d))throw new r.ArgumentsRequired(this.id+" editOrder() requires an amount argument, or a price argument, or non-empty params");return void 0===this.safeString(n,"clientOrderId")&&(d.orderId=e),d.market=h.id,d}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editOrderRequest(e,t,s,i,r,a,o),h=await this.privatePutOrder(d);return this.parseOrder(h,n)}cancelOrderRequest(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const i={market:this.market(t).id};return void 0===this.safeString(s,"clientOrderId")&&(i.orderId=e),this.extend(i,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),r=this.cancelOrderRequest(e,t,s),a=await this.privateDeleteOrder(r);return this.parseOrder(a,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;void 0!==e&&(i=this.market(e),s.market=i.id);const r=await this.privateDeleteOrders(this.extend(s,t));return this.parseOrders(r,i)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={market:i.id};void 0===this.safeString(s,"clientOrderId")&&(a.orderId=e);const o=await this.privateGetOrder(this.extend(a,s));return this.parseOrder(o,i)}fetchOrdersRequest(e=void 0,t=void 0,s=void 0,i={}){let r={market:this.market(e).id};return void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s),[r,i]=this.handleUntilOption("end",r,i),this.extend(r,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchOrders",e,t,s,i);const o=this.market(e),n=this.fetchOrdersRequest(e,t,s,i),d=await this.privateGetOrders(n);return this.parseOrders(d,o,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.privateGetOrdersOpen(this.extend(r,i));return this.parseOrders(o,a,t,s)}parseOrderStatus(e){return this.safeString({new:"open",canceled:"canceled",canceledAuction:"canceled",canceledSelfTradePrevention:"canceled",canceledIOC:"canceled",canceledFOK:"canceled",canceledMarketProtection:"canceled",canceledPostOnly:"canceled",filled:"closed",partiallyFilled:"open",expired:"canceled",rejected:"canceled",awaitingTrigger:"open"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeInteger(e,"created"),r=this.safeString(e,"market"),a=(t=this.safeMarket(r,t,"-")).symbol,n=this.parseOrderStatus(this.safeString(e,"status")),d=this.safeString(e,"side"),h=this.safeString(e,"orderType"),c=this.safeString(e,"price"),l=this.safeString(e,"amount"),u=this.safeString(e,"amountRemaining"),p=this.safeString(e,"filledAmount");let f,m=this.safeString(e,"filledAmountQuote");if(void 0===m){const t=this.safeString(e,"amountQuote"),s=this.safeString(e,"amountQuoteRemaining");m=o.Y.stringSub(t,s)}const g=this.safeNumber(e,"feePaid");if(void 0!==g){const t=this.safeString(e,"feeCurrency");f={cost:g,currency:this.safeCurrencyCode(t)}}const v=this.safeValue(e,"fills",[]),y=this.safeString(e,"timeInForce"),w=this.safeValue(e,"postOnly"),b=this.safeNumber(e,"triggerPrice");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:a,type:h,timeInForce:y,postOnly:w,side:d,price:c,stopPrice:b,triggerPrice:b,amount:l,cost:m,average:void 0,filled:p,remaining:u,status:n,fee:f,trades:v},t)}fetchMyTradesRequest(e=void 0,t=void 0,s=void 0,i={}){let r={market:this.market(e).id};return void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s),[r,i]=this.handleUntilOption("end",r,i),this.extend(r,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);const o=this.market(e),n=this.fetchMyTradesRequest(e,t,s,i),d=await this.privateGetTrades(n);return this.parseTrades(d,o,t,s)}withdrawRequest(e,t,s,i=void 0,r={}){const a={symbol:this.currency(e).id,amount:this.currencyToPrecision(e,t),address:s};return void 0!==i&&(a.paymentId=i),this.extend(a,r)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o=this.withdrawRequest(e,t,s,i,r),n=await this.privatePostWithdrawal(o);return this.parseTransaction(n,a)}fetchWithdrawalsRequest(e=void 0,t=void 0,s=void 0,i={}){const r={};let a;return void 0!==e&&(a=this.currency(e),r.symbol=a.id),void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s),this.extend(r,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.fetchWithdrawalsRequest(e,t,s,i);let a;void 0!==e&&(a=this.currency(e));const o=await this.privateGetWithdrawalHistory(r);return this.parseTransactions(o,a,t,s,{type:"withdrawal"})}fetchDepositsRequest(e=void 0,t=void 0,s=void 0,i={}){const r={};let a;return void 0!==e&&(a=this.currency(e),r.symbol=a.id),void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s),this.extend(r,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.fetchDepositsRequest(e,t,s,i);let a;void 0!==e&&(a=this.currency(e));const o=await this.privateGetDepositHistory(r);return this.parseTransactions(o,a,t,s,{type:"deposit"})}parseTransactionStatus(e){return this.safeString({awaiting_processing:"pending",awaiting_email_confirmation:"pending",awaiting_bitvavo_inspection:"pending",approved:"pending",sending:"pending",in_mempool:"pending",processed:"pending",completed:"ok",canceled:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),r=this.safeCurrencyCode(i,t),a=this.parseTransactionStatus(this.safeString(e,"status")),o=this.safeNumber(e,"amount"),n=this.safeString(e,"address"),d=this.safeString(e,"txId");let h;const c=this.safeNumber(e,"fee");let l;void 0!==c&&(h={cost:c,currency:r}),l="success"in e||"address"in e?"withdrawal":"deposit";const u=this.safeString(e,"paymentId");return{info:e,id:undefined,txid:d,timestamp:s,datetime:this.iso8601(s),addressFrom:void 0,address:n,addressTo:n,tagFrom:void 0,tag:u,tagTo:u,type:l,amount:o,currency:r,status:a,updated:void 0,fee:h,network:void 0,comment:void 0,internal:void 0}}parseDepositWithdrawFee(e,t=void 0){const s={info:e,withdraw:{fee:this.safeNumber(e,"withdrawalFee"),percentage:!1},deposit:{fee:this.safeNumber(e,"depositFee"),percentage:!1},networks:{}},i=this.safeValue(e,"networks");let r=this.safeValue(i,0);const a=this.safeString(t,"code");"Mainnet"===r&&(r=a);const o=this.networkIdToCode(r,a);return s.networks[o]={deposit:s.deposit,withdraw:s.withdraw},s}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetAssets(t);return this.parseDepositWithdrawFees(s,e,"symbol")}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e));let d="/"+this.version+"/"+this.implodeParams(e,i);const h="GET"===s||"DELETE"===s;if(h&&Object.keys(o).length&&(d+="?"+this.urlencode(o)),"private"===t){this.checkRequiredCredentials();let e="";h||Object.keys(o).length&&(e=a=this.json(o));const t=this.milliseconds().toString(),i=t+s+d+e,c=this.hmac(this.encode(i),this.encode(this.secret),n.s),l=this.safeString(this.options,"BITVAVO-ACCESS-WINDOW","10000");r={"BITVAVO-ACCESS-KEY":this.apiKey,"BITVAVO-ACCESS-SIGNATURE":c,"BITVAVO-ACCESS-TIMESTAMP":t,"BITVAVO-ACCESS-WINDOW":l},h||(r["Content-Type"]="application/json")}return d=this.urls.api[t]+d,{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"errorCode"),l=this.safeString(n,"error");if(void 0!==c){const e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,l,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}calculateRateLimiterCost(e,t,s,i,r={}){return"noMarket"in r&&!("market"in i)?r.noMarket:this.safeValue(r,"cost",1)}}},5257:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(1560),r=s(5147),a=s(1579),o=s(7481);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bl3p",name:"BL3P",countries:["NL"],rateLimit:1e3,version:"1",comment:"An exchange market by BitonicNL",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,ws:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg",api:{rest:"https://api.bl3p.eu"},www:"https://bl3p.eu",doc:["https://github.com/BitonicNL/bl3p-api/tree/master/docs","https://bl3p.eu/api","https://bitonic.nl/en/api"]},api:{public:{get:["{market}/ticker","{market}/orderbook","{market}/trades"]},private:{post:["{market}/money/depth/full","{market}/money/order/add","{market}/money/order/cancel","{market}/money/order/result","{market}/money/orders","{market}/money/orders/history","{market}/money/trades/fetch","GENMKT/money/info","GENMKT/money/deposit_address","GENMKT/money/new_deposit_address","GENMKT/money/wallet/history","GENMKT/money/withdraw"]}},markets:{"BTC/EUR":this.safeMarketStructure({id:"BTCEUR",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"BTC",quoteId:"EUR",maker:.0025,taker:.0025,type:"spot",spot:!0})},precisionMode:a.kb})}parseBalance(e){const t=this.safeValue(e,"data",{}),s=this.safeValue(t,"wallets",{}),i={info:t},r=Object.keys(this.currencies);for(let e=0;e<r.length;e++){const t=r[e],a=this.currency(t).id,o=this.safeValue(s,a,{}),n=this.safeValue(o,"available",{}),d=this.safeValue(o,"balance",{}),h=this.account();h.free=this.safeString(n,"value"),h.total=this.safeString(d,"value"),i[t]=h}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e);return this.parseBalance(t)}parseBidAsk(e,t=0,s=1,i=2){const a=this.safeString(e,t),o=this.safeString(e,s);return[this.parseNumber(r.Y.stringDiv(a,"100000.0")),this.parseNumber(r.Y.stringDiv(o,"100000000.0"))]}async fetchOrderBook(e,t=void 0,s={}){const i=this.market(e),r={market:i.id},a=await this.publicGetMarketOrderbook(this.extend(r,s)),o=this.safeDict(a,"data");return this.parseOrderBook(o,i.symbol,void 0,"bids","asks","price_int","amount_int")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),r=this.safeString(e,"last"),a=this.safeValue(e,"volume",{});return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(a,"24h"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){const s=this.market(e),i={market:s.id},r=await this.publicGetMarketTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeInteger(e,"date"),a=this.safeString(e,"price_int"),o=this.safeString(e,"amount_int");return t=this.safeMarket(void 0,t),this.safeTrade({id:s,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,type:void 0,side:void 0,order:void 0,takerOrMaker:void 0,price:r.Y.stringDiv(a,"100000"),amount:r.Y.stringDiv(o,"100000000"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const r=this.market(e),a=await this.publicGetMarketTrades(this.extend({market:r.id},i));return this.parseTrades(a.data.trades,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGENMKTMoneyInfo(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"trade_fee"),a=this.parseNumber(r.Y.stringDiv(i,"100")),o={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e];o[t]={info:s,symbol:t,maker:a,taker:a,percentage:!0,tierBased:!1}}return o}async createOrder(e,t,s,i,a=void 0,o={}){const n=this.market(e),d=this.numberToString(i),h=this.numberToString(a),c={market:n.id,amount_int:parseInt(r.Y.stringMul(d,"100000000")),fee_currency:n.quote,type:"buy"===s?"bid":"ask"};"limit"===t&&(c.price_int=parseInt(r.Y.stringMul(h,"100000.0")));const l=await this.privatePostMarketMoneyOrderAdd(this.extend(c,o)),u=this.safeString(l.data,"order_id");return this.safeOrder({info:l,id:u},n)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},r=await this.privatePostMarketMoneyOrderCancel(this.extend(i,s));return this.safeOrder({info:r})}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.privatePostGENMKTMoneyNewDepositAddress(this.extend(i,t)),a=this.safeDict(r,"data");return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{info:e,currency:this.safeString(t,"code"),address:s,tag:void 0,network:void 0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const n=this.implodeParams(e,i);let d=this.urls.api.rest+"/"+this.version+"/"+n;const h=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(h).length&&(d+="?"+this.urlencode(h));else{this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},h));const t=this.base64ToBinary(this.secret),s=n+"\0"+a,i=this.hmac(this.encode(s),t,o.Zf,"base64");r={"Content-Type":"application/x-www-form-urlencoded","Rest-Key":this.apiKey,"Rest-Sign":i}}return{url:d,method:s,body:a,headers:r}}}},3205:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(5254),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"blockchaincom",secret:void 0,name:"Blockchain.com",countries:["LX"],rateLimit:500,version:"v3",pro:!0,has:{CORS:!1,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL2OrderBook:!0,fetchL3OrderBook:!0,fetchLedger:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!0,transfer:!1,withdraw:!0},timeframes:void 0,urls:{logo:"https://user-images.githubusercontent.com/1294454/147515585-1296e91b-7398-45e5-9d32-f6121538533f.jpeg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.blockchain.com/v3/exchange",private:"https://api.blockchain.com/v3/exchange"},www:"https://blockchain.com",doc:["https://api.blockchain.com/v3"],fees:"https://exchange.blockchain.com/fees"},api:{public:{get:{tickers:1,"tickers/{symbol}":1,symbols:1,"symbols/{symbol}":1,"l2/{symbol}":1,"l3/{symbol}":1}},private:{get:{fees:1,orders:1,"orders/{orderId}":1,trades:1,fills:1,deposits:1,"deposits/{depositId}":1,accounts:1,"accounts/{account}/{currency}":1,whitelist:1,"whitelist/{currency}":1,withdrawals:1,"withdrawals/{withdrawalId}":1},post:{orders:1,"deposits/{currency}":1,withdrawals:1},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0045")],[this.parseNumber("10000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0018")],[this.parseNumber("100000"),this.parseNumber("0.0018")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("2500000"),this.parseNumber("0.0018")],[this.parseNumber("5000000"),this.parseNumber("0.0016")],[this.parseNumber("25000000"),this.parseNumber("0.0014")],[this.parseNumber("100000000"),this.parseNumber("0.0011")],[this.parseNumber("500000000"),this.parseNumber("0.0008")],[this.parseNumber("1000000000"),this.parseNumber("0.0006")]],maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0017")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.0008")],[this.parseNumber("500000"),this.parseNumber("0.0007")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("5000000"),this.parseNumber("0.0004")],[this.parseNumber("25000000"),this.parseNumber("0.0003")],[this.parseNumber("100000000"),this.parseNumber("0.0002")],[this.parseNumber("500000000"),this.parseNumber("0.0001")],[this.parseNumber("1000000000"),this.parseNumber("0")]]}}},requiredCredentials:{apiKey:!1,secret:!0},options:{networks:{ERC20:"ETH",TRC20:"TRX",ALGO:"ALGO",ADA:"ADA",AR:"AR",ATOM:"ATOM",AVAXC:"AVAX",BCH:"BCH",BSV:"BSV",BTC:"BTC",DCR:"DCR",DESO:"DESO",DASH:"DASH",CELO:"CELO",CHZ:"CHZ",MATIC:"MATIC",SOL:"SOL",DOGE:"DOGE",DOT:"DOT",EOS:"EOS",ETC:"ETC",FIL:"FIL",KAVA:"KAVA",LTC:"LTC",IOTA:"MIOTA",NEAR:"NEAR",STX:"STX",XLM:"XLM",XMR:"XMR",XRP:"XRP",XTZ:"XTZ",ZEC:"ZEC",ZIL:"ZIL"}},precisionMode:o.kb,exceptions:{exact:{401:r.AuthenticationError,404:r.OrderNotFound},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetSymbols(e),s=Object.keys(t),i=[];for(let e=0;e<s.length;e++){const r=s[e],o=this.safeValue(t,r),n=this.safeString(o,"base_currency"),d=this.safeString(o,"counter_currency"),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=this.safeNumber(o,"id");let u;u="open"===this.safeString(o,"status");const p=this.safeString(o,"min_price_increment"),f=this.safeString(o,"min_price_increment_scale"),m=this.parsePrecision(f),g=a.Y.stringMul(p,m),v=this.safeString(o,"lot_size"),y=this.safeString(o,"lot_size_scale"),w=this.parsePrecision(y),b=a.Y.stringMul(v,w),S=this.safeString(o,"min_order_size"),k=this.safeString(o,"min_order_size_scale"),O=this.parsePrecision(k),T=a.Y.stringMul(S,O),P=this.parseNumber(T);let I;if(I=this.safeString(o,"max_order_size"),"0"!==I){const e=this.safeString(o,"max_order_size_scale"),t=this.parsePrecision(e),s=a.Y.stringMul(I,t);I=this.parseNumber(s)}else I=void 0;i.push({info:o,id:r,numericId:l,symbol:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:u,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(b),price:this.parseNumber(g)},limits:{leverage:{min:void 0,max:void 0},amount:{min:P,max:I},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0})}return i}async fetchOrderBook(e,t=void 0,s={}){return await this.fetchL3OrderBook(e,t,s)}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetL3Symbol(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","px","qty")}async fetchL2OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetL2Symbol(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","px","qty")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),r=this.safeString(e,"last_trade_price"),a=this.safeString(e,"volume_24h"),o=this.safeString(e,"price_24h");return this.safeTicker({symbol:i,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:o,close:void 0,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:a,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTickersSymbol(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseOrderState(e){return this.safeString({OPEN:"open",REJECTED:"rejected",FILLED:"closed",CANCELED:"canceled",PART_FILLED:"open",EXPIRED:"expired"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"clOrdId"),i=this.safeStringLower(e,"ordType"),r=this.safeString(e,"ordStatus"),a=this.parseOrderState(r),o=this.safeStringLower(e,"side"),n=this.safeString(e,"symbol"),d=this.safeSymbol(n,t,"-"),h=this.safeString(e,"exOrdId"),c="market"!==i?this.safeString(e,"price"):void 0,l=this.safeNumber(e,"avgPx"),u=this.safeInteger(e,"timestamp"),p=this.iso8601(u),f=this.safeString(e,"cumQty"),m=this.safeString(e,"leavesQty");return this.safeOrder({id:h,clientOrderId:s,datetime:p,timestamp:u,lastTradeTimestamp:void 0,status:a,symbol:d,type:i,timeInForce:void 0,side:o,price:c,average:l,amount:void 0,filled:f,remaining:m,cost:void 0,trades:[],fees:[],info:e})}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=this.safeString(o,"ordType",t).toUpperCase(),h=this.safeString2(o,"clientOrderId","clOrdId",this.uuid16());o=this.omit(o,["ordType","clientOrderId","clOrdId"]);const c={ordType:d,symbol:n.id,side:s.toUpperCase(),orderQty:this.amountToPrecision(e,i),clOrdId:h},l=this.safeValue2(o,"stopPx","stopPrice");if(o=this.omit(o,["stopPx","stopPrice"]),("STOP"===d||"STOPLIMIT"===d)&&void 0===l)throw new r.ArgumentsRequired(this.id+" createOrder() requires a stopPx or stopPrice param for a "+d+" order");void 0!==l&&("MARKET"===d?c.ordType="STOP":"LIMIT"===d&&(c.ordType="STOPLIMIT"));let u=!1,p=!1;"LIMIT"!==c.ordType&&"STOPLIMIT"!==c.ordType||(u=!0),"STOP"!==c.ordType&&"STOPLIMIT"!==c.ordType||(p=!0),u&&(c.price=this.priceToPrecision(e,a)),p&&(c.stopPx=this.priceToPrecision(e,l));const f=await this.privatePostOrders(this.extend(c,o));return this.parseOrder(f,n)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},r=await this.privateDeleteOrdersOrderId(this.extend(i,s));return this.safeOrder({id:e,info:r})}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=this.marketId(e);s.symbol=t}const i=await this.privateDeleteOrders(this.extend(s,t));return[this.safeOrder({info:i})]}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"makerRate"),i=this.safeNumber(t,"takerRate"),r={};for(let e=0;e<this.symbols.length;e++){const a=this.symbols[e];r[a]={info:t,symbol:a,maker:s,taker:i}}return r}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("CANCELED",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("FILLED",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("OPEN",e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={status:e,limit:100};let o;void 0!==t&&(o=this.market(t),a.symbol=o.id);const n=await this.privateGetOrders(this.extend(a,r));return this.parseOrders(n,o,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"exOrdId"),i=this.safeString(e,"tradeId"),r=this.safeString(e,"side").toLowerCase(),a=this.safeString(e,"symbol"),o=this.safeString(e,"price"),n=this.safeString(e,"qty"),d=this.safeInteger(e,"timestamp"),h=this.iso8601(d),c=(t=this.safeMarket(a,t,"-")).symbol;let l;const u=this.safeString(e,"fee");if(void 0!==u){l={cost:u,currency:t.quote}}return this.safeTrade({id:i,timestamp:d,datetime:h,symbol:c,order:s,type:void 0,side:r,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:l,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==s&&(r.limit=s),void 0!==e&&(r.symbol=this.marketId(e),a=this.market(e));const o=await this.privateGetFills(this.extend(r,i));return this.parseTrades(o,a,t,s,i)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.privatePostDepositsCurrency(this.extend(i,t)),a=this.safeString(r,"address");let o,n;if(void 0!==a){const e=a.split(";");o=this.safeString(e,0),n=this.safeString(e,1)}const d={info:r};return d.currency=s.code,d.address=n,void 0!==o&&(d.tag=o),d}parseTransactionState(e){return this.safeString({COMPLETED:"ok",REJECTED:"failed",PENDING:"pending",FAILED:"failed",REFUNDED:"refunded"},e,e)}parseTransaction(e,t=void 0){let s,i;const r=this.safeNumber(e,"amount"),a=this.safeInteger(e,"timestamp"),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.safeString(e,"state");"depositId"in e?(s="deposit",i=this.safeString(e,"depositId")):"withdrawalId"in e&&(s="withdrawal",i=this.safeString(e,"withdrawalId"));const h="withdrawal"===s?this.safeNumber(e,"fee"):void 0;let c;void 0!==h&&(c={currency:n,cost:h});const l=this.safeString(e,"address");return{info:e,id:i,txid:this.safeString(e,"txhash"),timestamp:a,datetime:this.iso8601(a),network:void 0,addressFrom:void 0,address:l,addressTo:l,tagFrom:void 0,tag:void 0,tagTo:void 0,type:s,amount:r,currency:n,status:this.parseTransactionState(d),updated:void 0,comment:void 0,internal:void 0,fee:c}}async withdraw(e,t,s,i=void 0,r={}){await this.loadMarkets();const a=this.currency(e),o={amount:t,currency:a.id,beneficiary:s,sendMax:!1},n=await this.privatePostWithdrawals(this.extend(o,r));return this.parseTransaction(n,a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==t&&(r.from=t),void 0!==e&&(a=this.currency(e));const o=await this.privateGetWithdrawals(this.extend(r,i));return this.parseTransactions(o,a,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdrawalId:e},r=await this.privateGetWithdrawalsWithdrawalId(this.extend(i,s));return this.parseTransaction(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==t&&(r.from=t),void 0!==e&&(a=this.currency(e));const o=await this.privateGetDeposits(this.extend(r,i));return this.parseTransactions(o,a,t,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={depositId:this.safeString(s,"depositId",e)},r=await this.privateGetDepositsDepositId(this.extend(i,s));return this.parseTransaction(r)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"account","primary");e=this.omit(e,"account");const s={account:t},i=await this.privateGetAccounts(this.extend(s,e)),a=this.safeValue(i,t);if(void 0===a)throw new r.ExchangeError(this.id+' fetchBalance() could not find the "'+t+'" account');const o={info:i};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"currency"),i=this.safeCurrencyCode(s),r=this.account();r.free=this.safeString(t,"available"),r.total=this.safeString(t,"balance"),o[i]=r}return this.safeBalance(o)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.privateGetOrdersOrderId(this.extend(i,s));return this.parseOrder(r)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o="/"+this.implodeParams(e,i);let n=this.urls.api[t]+o;const d=this.omit(i,this.extractParams(e));return"public"===t?Object.keys(d).length&&(n+="?"+this.urlencode(d)):"private"===t&&(this.checkRequiredCredentials(),r={"X-API-Token":this.secret},"GET"===s?Object.keys(d).length&&(n+="?"+this.urlencode(d)):(a=this.json(d),r["Content-Type"]="application/json")),{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"text");if(void 0!==c&&"Insufficient Balance"===c)throw new r.InsufficientFunds(this.id+" "+o);const l=this.safeString(n,"status"),u=this.safeString(n,"error");if(void 0!==e){const e=this.id+" "+this.json(n);this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,u,e)}}}},2520:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1769),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"blofin",name:"BloFin",countries:["US"],version:"v1",rateLimit:100,pro:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,borrowMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!0,createDepositAddress:!1,createMarketBuyOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopLossOrder:!0,createStopMarketOrder:!1,createStopOrder:!1,createTakeProfitOrder:!0,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchGreeks:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverages:!0,fetchLeverageTiers:!1,fetchMarginMode:!0,fetchMarginModes:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMySettlementHistory:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:void 0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPermissions:void 0,fetchPosition:!0,fetchPositions:!0,fetchPositionsForSymbol:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","8h":"8H","12h":"12H","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},hostname:"www.blofin.com",urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/255a7b29-341f-4d20-8342-fbfae4932807",api:{rest:"https://openapi.blofin.com"},referral:{url:"https://blofin.com/register?referral_code=jBd8U1",discount:.05},www:"https://www.blofin.com",doc:"https://blofin.com/docs"},api:{public:{get:{"market/instruments":1,"market/tickers":1,"market/books":1,"market/trades":1,"market/candles":1,"market/mark-price":1,"market/funding-rate":1,"market/funding-rate-history":1}},private:{get:{"asset/balances":1,"trade/orders-pending":1,"trade/fills-history":1,"asset/deposit-history":1,"asset/withdrawal-history":1,"asset/bills":1,"account/balance":1,"account/positions":1,"account/leverage-info":1,"account/margin-mode":1,"account/batch-leverage-info":1,"trade/orders-tpsl-pending":1,"trade/orders-history":1,"trade/orders-tpsl-history":1,"user/query-apikey":1,"affiliate/basic":1},post:{"trade/order":1,"trade/cancel-order":1,"account/set-leverage":1,"trade/batch-orders":1,"trade/order-tpsl":1,"trade/cancel-batch-orders":1,"trade/cancel-tpsl":1,"trade/close-position":1,"asset/transfer":1}}},fees:{swap:{taker:this.parseNumber("0.00060"),maker:this.parseNumber("0.00020")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{400:r.BadRequest,401:r.AuthenticationError,500:r.ExchangeError,404:r.BadRequest,405:r.BadRequest,406:r.BadRequest,429:r.RateLimitExceeded,152001:r.BadRequest,152002:r.BadRequest,152003:r.BadRequest,152004:r.BadRequest,152005:r.BadRequest,152006:r.InvalidOrder,152007:r.InvalidOrder,152008:r.InvalidOrder,152009:r.InvalidOrder,150003:r.InvalidOrder,150004:r.InvalidOrder,542:r.InvalidOrder,102002:r.InvalidOrder,102005:r.InvalidOrder,102014:r.InvalidOrder,102015:r.InvalidOrder,102022:r.InvalidOrder,102037:r.InvalidOrder,102038:r.InvalidOrder,102039:r.InvalidOrder,102040:r.InvalidOrder,102047:r.InvalidOrder,102048:r.InvalidOrder,102049:r.InvalidOrder,102050:r.InvalidOrder,102051:r.InvalidOrder,102052:r.InvalidOrder,102053:r.InvalidOrder,102054:r.InvalidOrder,102055:r.InvalidOrder,102064:r.BadRequest,102065:r.BadRequest,102068:r.BadRequest,103013:r.ExchangeError,"Order failed. Insufficient USDT margin in account":r.InsufficientFunds},broad:{"Internal Server Error":r.ExchangeNotAvailable,"server error":r.ExchangeNotAvailable}},httpExceptions:{429:r.ExchangeNotAvailable},precisionMode:o.kb,options:{brokerId:"ec6dd3a7dd982d0b",accountsByType:{swap:"futures",future:"futures"},accountsById:{futures:"swap"},sandboxMode:!1,defaultNetwork:"ERC20",defaultNetworks:{ETH:"ERC20",BTC:"BTC",USDT:"TRC20"},networks:{BTC:"Bitcoin",BEP20:"BSC",ERC20:"ERC20",TRC20:"TRC20"},fetchOpenInterestHistory:{timeframes:{"5m":"5m","1h":"1H","8h":"8H","1d":"1D","5M":"5m","1H":"1H","8H":"8H","1D":"1D"}},fetchOHLCV:{timezone:"UTC"},fetchPositions:{method:"privateGetAccountPositions"},createOrder:"privatePostTradeOrder",createMarketBuyOrderRequiresPrice:!1,fetchMarkets:["swap"],defaultType:"swap",fetchLedger:{method:"privateGetAssetBills"},fetchOpenOrders:{method:"privateGetTradeOrdersPending"},cancelOrders:{method:"privatePostTradeCancelBatchOrders"},fetchCanceledOrders:{method:"privateGetTradeOrdersHistory"},fetchClosedOrders:{method:"privateGetTradeOrdersHistory"},withdraw:{password:void 0,pwd:void 0},exchangeType:{spot:"SPOT",swap:"SWAP",SPOT:"SPOT",SWAP:"SWAP"}}})}async fetchMarkets(e={}){const t=await this.publicGetMarketInstruments(e),s=this.safeList(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"instId"),s=this.safeStringLower(e,"instType"),i="spot"===s,r="future"===s,o="swap"===s,n="option"===s,d=o||r,h=this.safeString(e,"baseCurrency"),c=this.safeString(e,"quoteCurrency"),l=this.safeString(e,"quoteCurrency"),u=this.safeCurrencyCode(l),p=this.safeCurrencyCode(h),f=this.safeCurrencyCode(c);let m=p+"/"+f;o&&(m=m+":"+u);const g=void 0,v=this.safeString(e,"tickSize"),y=this.safeDict2(this.fees,s,"trading",{}),w=this.safeNumber(y,"taker"),b=this.safeNumber(y,"maker");let S=this.safeString(e,"maxLeverage","100");S=a.Y.stringMax(S,"1");const k="live"===this.safeString(e,"state");return this.safeMarketStructure({id:t,symbol:m,base:p,quote:f,baseId:h,quoteId:c,settle:u,settleId:l,type:s,spot:i,option:n,margin:i&&a.Y.stringGt(S,"1"),swap:o,future:r,active:k,taker:w,maker:b,contract:d,linear:d?c===l:void 0,inverse:d?h===l:void 0,contractSize:d?this.safeNumber(e,"contractValue"):void 0,expiry:g,expiryDatetime:g,strike:undefined,optionType:undefined,created:this.safeInteger(e,"listTime"),precision:{amount:this.safeNumber(e,"lotSize"),price:this.parseNumber(v)},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(S)},amount:{min:this.safeNumber(e,"minSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:e})}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={instId:this.market(e).id};void 0!==(t=void 0===t?50:t)&&(i.size=t);const r=await this.publicGetMarketBooks(this.extend(i,s)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{}),n=this.safeInteger(o,"ts");return this.parseOrderBook(o,e,n)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,a=this.safeString(e,"last"),o=this.safeString(e,"open24h"),n=this.safeBool(t,"spot",!1)?this.safeString(e,"volCurrency24h"):void 0,d=this.safeString(e,"vol24h"),h=this.safeString(e,"high24h"),c=this.safeString(e,"low24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:h,low:c,bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:o,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},r=await this.publicGetMarketTickers(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeList(s,"data",[]);return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,a=this.safeInteger(e,"ts"),o=this.safeString2(e,"price","fillPrice"),n=this.safeString2(e,"size","fillSize"),d=this.safeString(e,"side"),h=this.safeString(e,"orderId"),c=this.safeString(e,"fee");let l;return void 0!==c&&(l={cost:c,currency:t.settle}),this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:r,id:s,order:h,type:void 0,takerOrMaker:void 0,side:d,price:o,amount:n,cost:void 0,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchTrades",e,t,s,i,"tradeId","after",void 0,100);const a=this.market(e),o={instId:a.id};let n,d;void 0!==s&&(o.limit=s),[d,i]=this.handleOptionAndParams(i,"fetchTrades","method","publicGetMarketTrades"),"publicGetMarketTrades"===d&&(n=await this.publicGetMarketTrades(this.extend(o,i)));const h=this.safeList(n,"data",[]);return this.parseTrades(h,a,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,100);void 0===i&&(i=100);const n={instId:a.id,bar:this.safeString(this.timeframes,t,t),limit:i},d=this.safeInteger(r,"until");let h;void 0!==d&&(n.after=d,r=this.omit(r,"until")),h=await this.publicGetMarketCandles(this.extend(n,r));const c=this.safeList(h,"data",[]);return this.parseOHLCVs(c,a,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i);const o=this.market(e),n={instId:o.id};void 0!==t&&(n.before=Math.max(t-1,0)),void 0!==s&&(n.limit=s);const d=await this.publicGetMarketFundingRateHistory(this.extend(n,i)),h=[],c=this.safeList(d,"data",[]);for(let e=0;e<c.length;e++){const t=c[e],s=this.safeInteger(t,"fundingTime");h.push({info:t,symbol:o.symbol,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:s,datetime:this.iso8601(s)})}const l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,o.symbol,t,s)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"nextFundingTime"),i=this.safeString(e,"instId"),r=this.safeSymbol(i,t),a=this.safeNumber(e,"nextFundingRate"),o=this.safeInteger(e,"fundingTime");return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:o,fundingDatetime:this.iso8601(o),nextFundingRate:a,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.ExchangeError(this.id+" fetchFundingRate() is only valid for swap markets");const i={instId:s.id},a=await this.publicGetMarketFundingRate(this.extend(i,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseFundingRate(n,s)}parseBalanceByType(e,t){return e?this.parseFundingBalance(t):this.parseBalance(t)}parseBalance(e){const t={info:e},s=this.safeDict(e,"data",{}),i=this.safeInteger(s,"ts"),r=this.safeList(s,"details",[]);for(let e=0;e<r.length;e++){const s=r[e],i=this.safeString(s,"currency"),a=this.safeCurrencyCode(i),o=this.account(),n=this.safeString(s,"equity"),d=this.safeString(s,"available");void 0===n||void 0===d?(o.free=this.safeString(s,"availableEquity"),o.used=this.safeString(s,"frozen")):(o.total=n,o.free=d),t[a]=o}return t.timestamp=i,t.datetime=this.iso8601(i),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeList(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.free=this.safeString(i,"available"),o.used=this.safeString(i,"frozen"),t[a]=o}return this.safeBalance(t)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.parseNumber(a.Y.stringNeg(this.safeString2(e,"maker","makerU"))),taker:this.parseNumber(a.Y.stringNeg(this.safeString2(e,"taker","takerU"))),percentage:void 0,tierBased:void 0}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(e,"accountType","type");e=this.omit(e,["accountType","type"]);const s={};let i;if(void 0!==t){const r=this.safeDict(this.options,"accountsByType",{}),a=this.safeString(r,t,t);s.accountType=a,i=await this.privateGetAssetBalances(this.extend(s,e))}else i=await this.privateGetAccountBalance(this.extend(s,e));return this.parseBalanceByType(t,i)}createOrderRequest(e,t,s,i,r=void 0,a={}){const o={instId:this.market(e).id,side:s,orderType:t,size:this.amountToPrecision(e,i),brokerId:this.safeString(this.options,"brokerId","ec6dd3a7dd982d0b")};let n;[n,a]=this.handleMarginModeAndParams("createOrder",a,"cross"),o.marginMode=n;const d=this.safeString(a,"timeInForce","GTC"),h="market"===t;a=this.omit(a,["timeInForce"]);h||h&&("IOC"===d||"ioc"===t)?o.orderType="market":o.price=this.priceToPrecision(e,r);let c=!1;[c,a]=this.handlePostOnly(h,"post_only"===t,a),c&&(o.type="post_only");const l=this.safeDict(a,"stopLoss"),u=this.safeDict(a,"takeProfit");a=this.omit(a,["stopLoss","takeProfit"]);const p=void 0!==l,f=void 0!==u;if(p||f){if(p){const t=this.safeString2(l,"triggerPrice","stopPrice");o.slTriggerPrice=this.priceToPrecision(e,t);const s=this.safeString(l,"price","-1");o.slOrderPrice=this.priceToPrecision(e,s)}if(f){const t=this.safeString2(u,"triggerPrice","stopPrice");o.tpTriggerPrice=this.priceToPrecision(e,t);const s=this.safeString(u,"price","-1");o.tpOrderPrice=this.priceToPrecision(e,s)}}return this.extend(o,a)}parseOrderStatus(e){return this.safeString({canceled:"canceled",order_failed:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"tpslId","orderId"),i=this.safeInteger(e,"createTime"),r=this.safeInteger(e,"updateTime"),o=this.safeInteger(e,"fillTime"),n=this.safeString(e,"side");let d,h,c=this.safeString(e,"orderType");"post_only"===c?(d=!0,c="limit"):"fok"===c?(h="FOK",c="limit"):"ioc"===c&&(h="IOC",c="limit");const l=this.safeString(e,"instId");t=this.safeMarket(l,t);const u=this.safeSymbol(l,t,"-"),p=this.safeString(e,"filledSize"),f=this.safeString2(e,"px","price"),m=this.safeString(e,"averagePrice"),g=this.parseOrderStatus(this.safeString(e,"state")),v=this.safeString(e,"fee"),y=this.safeString(e,"size"),w=this.safeString(e,"leverage","1"),b=this.safeString(t,"contractSize"),S=a.Y.stringMul(b,p);let k,O;if(void 0!==m&&(k=a.Y.stringMul(m,S),k=a.Y.stringDiv(k,w)),void 0!==v){const t=a.Y.stringAbs(v),s=this.safeString(e,"feeCcy","USDT"),i=this.safeCurrencyCode(s);O={cost:this.parseNumber(t),currency:i}}let T=this.safeString(e,"clientOrderId");void 0!==T&&T.length<1&&(T=void 0);const P=this.safeNumber(e,"slTriggerPrice"),I=this.safeNumber(e,"slOrderPrice"),x=this.safeNumber(e,"tpTriggerPrice"),A=this.safeNumber(e,"tpOrderPrice"),M="true"===this.safeString(e,"reduceOnly");return this.safeOrder({info:e,id:s,clientOrderId:T,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:o,lastUpdateTimestamp:r,symbol:u,type:c,timeInForce:h,postOnly:d,side:n,price:f,stopLossTriggerPrice:P,takeProfitTriggerPrice:x,stopLossPrice:I,takeProfitPrice:A,average:m,cost:k,amount:y,filled:p,remaining:void 0,status:g,fee:O,trades:void 0,reduceOnly:M},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"tpsl",!1);let d;a=this.omit(a,"tpsl"),[d,a]=this.handleOptionAndParams(a,"createOrder","method","privatePostTradeOrder");const h=void 0!==this.safeString(a,"stopLossPrice"),c=void 0!==this.safeString(a,"takeProfitPrice");let l;if(n||"privatePostTradeOrderTpsl"===d||(h||c)){const o=this.createTpslOrderRequest(e,t,s,i,r,a);l=await this.privatePostTradeOrderTpsl(o)}else{const o=this.createOrderRequest(e,t,s,i,r,a);l=await this.privatePostTradeOrder(o)}const u=this.safeList(l,"data",[]),p=this.safeDict(u,0),f=this.parseOrder(p,o);return f.type=t,f.side=s,f}createTpslOrderRequest(e,t,s,i=void 0,a=void 0,o={}){const n=this.market(e),d=this.safeString(o,"positionSide","net"),h={instId:n.id,side:s,positionSide:d,brokerId:this.safeString(this.options,"brokerId","ec6dd3a7dd982d0b")};void 0!==i&&(h.size=this.amountToPrecision(e,i));const c=this.safeString(o,"marginMode","cross");if("cross"!==c&&"isolated"!==c)throw new r.BadRequest(this.id+" createTpslOrder() requires a marginMode parameter that must be either cross or isolated");const l=this.safeString(o,"stopLossPrice"),u=this.safeString(o,"takeProfitPrice");return void 0!==l?(h.slTriggerPrice=this.priceToPrecision(e,l),h.slOrderPrice="market"===t?"-1":this.priceToPrecision(e,a)):void 0!==u&&(h.tpTriggerPrice=this.priceToPrecision(e,u),h.tpOrderPrice="market"===t?"-1":this.priceToPrecision(e,a)),h.marginMode=c,o=this.omit(o,["stopLossPrice","takeProfitPrice"]),this.extend(h,o)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={instId:i.id},o=this.safeBoolN(s,["stop","trigger","tpsl"],!1),n=this.safeString(s,"clientOrderId");void 0!==n?a.clientOrderId=n:o?a.tpslId=e.toString():a.orderId=e.toString();const d=this.omit(s,["orderId","clientOrderId","stop","trigger","tpsl"]);if(o){const i=await this.cancelOrders([e],t,s);return this.safeDict(i,0)}const h=await this.privatePostTradeCancelOrder(this.extend(a,d)),c=this.safeList(h,"data",[]),l=this.safeDict(c,0);return this.parseOrder(l,i)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"symbol"),o=this.safeString(r,"type"),n=this.safeString(r,"side"),d=this.safeValue(r,"amount"),h=this.safeValue(r,"price"),c=this.safeDict(r,"params",{}),l=this.extend(c,t),u=this.createOrderRequest(a,o,n,d,h,l);s.push(u)}const i=await this.privatePostTradeBatchOrders(s),r=this.safeList(i,"data",[]);return this.parseOrders(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchOpenOrders",e,t,s,i);const a={};let o;void 0!==e&&(o=this.market(e),a.instId=o.id),void 0!==s&&(a.limit=s);const n=this.safeBoolN(i,["stop","trigger","tpsl","TPSL"],!1);let d;[d,i]=this.handleOptionAndParams(i,"fetchOpenOrders","method","privateGetTradeOrdersPending");const h=this.omit(i,["method","stop","trigger","tpsl","TPSL"]);let c;c=n||"privateGetTradeOrdersTpslPending"===d?await this.privateGetTradeOrdersTpslPending(this.extend(a,h)):await this.privateGetTradeOrdersPending(this.extend(a,h));const l=this.safeList(c,"data",[]);return this.parseOrders(l,o,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);let a,o={};void 0!==e&&(a=this.market(e),o.instId=a.id),[o,i]=this.handleUntilOption("end",o,i),void 0!==s&&(o.limit=s);const n=await this.privateGetTradeFillsHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchDeposits",e,t,s,i);let a,o={};void 0!==e&&(a=this.currency(e),o.currency=a.id),void 0!==t&&(o.before=Math.max(t-1,0)),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("after",o,i);const n=await this.privateGetAssetDepositHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchWithdrawals",e,t,s,i);let a,o={};void 0!==e&&(a=this.currency(e),o.currency=a.id),void 0!==t&&(o.before=Math.max(t-1,0)),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("after",o,i);const n=await this.privateGetAssetWithdrawalHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s,i)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i);let a,o,n={};void 0!==s&&(n.limit=s),void 0!==e&&(a=this.currency(e),n.currency=a.id),[n,i]=this.handleUntilOption("end",n,i),o=await this.privateGetAssetBills(this.extend(n,i));const d=this.safeList(o,"data",[]);return this.parseLedger(d,a,t,s)}parseTransaction(e,t=void 0){let s,i;const r=this.safeString(e,"withdrawId"),a=this.safeString(e,"depositId"),o=this.safeString(e,"address"),n=o,d=this.safeString(e,"tag");void 0!==r?(s="withdrawal",i=r):(i=a,s="deposit");const h=this.safeString(e,"currency"),c=this.safeCurrencyCode(h),l=this.safeNumber(e,"amount"),u=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"txId"),f=this.safeInteger(e,"ts"),m=this.safeString(e,"feeCurrency"),g=this.safeCurrencyCode(m),v=this.safeNumber(e,"fee");return{info:e,id:i,currency:c,amount:l,network:void 0,addressFrom:void 0,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:u,type:s,updated:void 0,txid:p,timestamp:f,datetime:this.iso8601(f),internal:void 0,comment:void 0,fee:{currency:g,cost:v}}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"ok",2:"failed",3:"pending"},e,e)}parseLedgerEntryType(e){return this.safeString({1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transferId"),i=this.safeString(e,"clientId"),r=this.safeString(e,"fromAccount"),a=this.safeString(e,"toAccount"),o=this.parseLedgerEntryType(this.safeString(e,"type")),n=this.safeCurrencyCode(this.safeString(e,"currency"),t),d=this.safeString(e,"amount"),h=this.parseNumber(d),c=this.safeInteger(e,"ts");return{id:s,info:e,timestamp:c,datetime:this.iso8601(c),fromAccount:r,toAccount:a,type:o,currency:n,amount:h,clientId:i,status:"ok"}}parseIds(e){return"string"==typeof e?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=[],o=this.safeDict(this.options,"cancelOrders",{}),n=this.safeString(o,"method","privatePostTradeCancelBatchOrders");let d=this.safeString(s,"method",n);const h=this.parseIds(this.safeValue(s,"clientOrderId")),c=this.parseIds(this.safeValue(s,"tpslId")),l=this.safeBoolN(s,["stop","trigger","tpsl"]);if(l&&(d="privatePostTradeCancelTpsl"),void 0===h){if(e=this.parseIds(e),void 0!==c)for(let e=0;e<c.length;e++)a.push({tpslId:c[e],instId:i.id});for(let t=0;t<e.length;t++)l?a.push({tpslId:e[t],instId:i.id}):a.push({orderId:e[t],instId:i.id})}else for(let e=0;e<h.length;e++)a.push({instId:i.id,clientOrderId:h[e]});let u;u="privatePostTradeCancelTpsl"===d?await this.privatePostTradeCancelTpsl(a):await this.privatePostTradeCancelBatchOrders(a);const p=this.safeList(u,"data",[]);return this.parseOrders(p,i,void 0,void 0,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={currency:a.id,amount:this.currencyToPrecision(e,t),fromAccount:n,toAccount:d},c=await this.privatePostAssetTransfer(this.extend(h,r)),l=this.safeDict(c,"data",{});return this.parseTransfer(l,a)}parseTransfer(e,t=void 0){return{info:e,id:this.safeString(e,"transferId"),timestamp:void 0,datetime:void 0,currency:void 0,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},r=await this.privateGetAccountPositions(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0);if(void 0!==o)return this.parsePosition(o,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.privateGetAccountPositions(t),i=this.safeList(s,"data",[]),r=this.parsePositions(i);return this.filterByArrayPositions(r,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"instId"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString(e,"positions"),o=a.Y.stringAbs(r);let n=this.safeString(e,"positionSide");const d="net"!==n,h=this.parseNumber(o);void 0!==r&&"net"===n&&(n=a.Y.stringGt(r,"0")?"long":a.Y.stringLt(r,"0")?"short":void 0);const c=this.safeNumber(t,"contractSize"),l=this.numberToString(c),u=this.safeString(e,"markPrice");let p=this.safeString(e,"notionalUsd");t.inverse&&(p=a.Y.stringDiv(a.Y.stringMul(o,l),u));const f=this.parseNumber(p),m=this.safeString(e,"marginMode");let g;const v=this.safeString(e,"averagePrice"),y=this.safeString(e,"unrealizedPnl"),w=this.safeString(e,"leverage");let b,S;"cross"===m?(g=this.safeString(e,"initialMargin"),S=a.Y.stringAdd(g,y)):"isolated"===m&&(b=a.Y.stringDiv("1",w),S=this.safeString(e,"margin"));const k=this.safeString(e,"maintenanceMargin"),O=this.parseNumber(k),T=a.Y.stringDiv(k,p);void 0===b?b=this.parseNumber(a.Y.stringDiv(g,p,4)):void 0===g&&(g=a.Y.stringMul(b,p));const P=this.parseNumber(a.Y.stringDiv(a.Y.stringAdd(T,"0.00005"),"1",4)),I=this.safeNumber(e,"liquidationPrice"),x=this.safeString(e,"unrealizedPnlRatio"),A=this.parseNumber(a.Y.stringMul(x,"100")),M=this.safeInteger(e,"updateTime"),C=this.parseNumber(a.Y.stringDiv(k,S,4));return this.safePosition({info:e,id:void 0,symbol:i,notional:f,marginMode:m,liquidationPrice:I,entryPrice:this.parseNumber(v),unrealizedPnl:this.parseNumber(y),percentage:A,contracts:h,contractSize:c,markPrice:this.parseNumber(u),lastPrice:void 0,side:n,hedged:d,timestamp:M,datetime:this.iso8601(M),lastUpdateTimestamp:void 0,maintenanceMargin:O,maintenanceMarginPercentage:P,collateral:this.parseNumber(S),initialMargin:this.parseNumber(g),initialMarginPercentage:this.parseNumber(b),leverage:this.parseNumber(w),marginRatio:C,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchLeverages(e=void 0,t={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchLeverages() requires a symbols argument");let s;if([s,t]=this.handleMarginModeAndParams("fetchLeverages",t),void 0===s&&(s=this.safeString(t,"marginMode","cross")),"cross"!==s&&"isolated"!==s)throw new r.BadRequest(this.id+" fetchLeverages() requires a marginMode parameter that must be either cross or isolated");e=this.marketSymbols(e);let i="";for(let t=0;t<e.length;t++){const s=e[t],r=this.market(s);t>0?i=i+","+r.id:i+=r.id}const a={instId:i,marginMode:s},o=await this.privateGetAccountBatchLeverageInfo(this.extend(a,t)),n=this.safeList(o,"data",[]);return this.parseLeverages(n,e,"instId")}async fetchLeverage(e,t={}){let s;if(await this.loadMarkets(),[s,t]=this.handleMarginModeAndParams("fetchLeverage",t),void 0===s&&(s=this.safeString(t,"marginMode","cross")),"cross"!==s&&"isolated"!==s)throw new r.BadRequest(this.id+" fetchLeverage() requires a marginMode parameter that must be either cross or isolated");const i=this.market(e),a={instId:i.id,marginMode:s},o=await this.privateGetAccountLeverageInfo(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseLeverage(n,i)}parseLeverage(e,t=void 0){const s=this.safeString(e,"instId"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"marginMode"),longLeverage:i,shortLeverage:i}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new r.BadRequest(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let a;if([a,s]=this.handleMarginModeAndParams("setLeverage",s,"cross"),"cross"!==a&&"isolated"!==a)throw new r.BadRequest(this.id+" setLeverage() requires a marginMode parameter that must be either cross or isolated");const o={leverage:e,marginMode:a,instId:i.id};return await this.privatePostAccountSetLeverage(this.extend(o,s))}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.safeString(s,"clientOrderId");let a;[a,s]=this.handleMarginModeAndParams("closePosition",s,"cross");const o={instId:i.id,marginMode:a};void 0!==r&&(o.clientOrderId=r);const n=await this.privatePostTradeClosePosition(this.extend(o,s));return this.safeDict(n,"data")}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i);const a={};let o;void 0!==e&&(o=this.market(e),a.instId=o.id),void 0!==s&&(a.limit=s),void 0!==t&&(a.begin=t);const n=this.safeBoolN(i,["stop","trigger","tpsl","TPSL"],!1);let d;[d,i]=this.handleOptionAndParams(i,"fetchOpenOrders","method","privateGetTradeOrdersHistory");const h=this.omit(i,["method","stop","trigger","tpsl","TPSL"]);let c;c=n||"privateGetTradeOrdersTpslHistory"===d?await this.privateGetTradeOrdersTpslHistory(this.extend(a,h)):await this.privateGetTradeOrdersHistory(this.extend(a,h));const l=this.safeList(c,"data",[]);return this.parseOrders(l,o,t,s)}async fetchMarginMode(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.privateGetAccountMarginMode(t),r=this.safeDict(i,"data",{});return this.parseMarginMode(r,s)}parseMarginMode(e,t=void 0){return{info:e,symbol:t.symbol,marginMode:this.safeString(e,"marginMode")}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"msg"),u=this.id+" "+o;if(void 0!==c&&"0"!==c)throw this.throwExactlyMatchedException(this.exceptions.exact,l,u),this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,l,u),new r.ExchangeError(u);const p=this.safeList(n,"data"),f=this.safeDict(p,0),m=this.safeString(f,"msg"),g=this.safeString(f,"code");void 0!==g&&"0"!==g&&(this.throwExactlyMatchedException(this.exceptions.exact,g,u),this.throwExactlyMatchedException(this.exceptions.exact,m,u),this.throwBroadlyMatchedException(this.exceptions.broad,m,u))}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/api/"+this.version+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));let h=this.implodeHostname(this.urls.api.rest)+o;if("public"===t)this.isEmpty(d)||(h+="?"+this.urlencode(d));else if("private"===t){this.checkRequiredCredentials();const e=this.milliseconds().toString();r={"ACCESS-KEY":this.apiKey,"ACCESS-PASSPHRASE":this.password,"ACCESS-TIMESTAMP":e,"ACCESS-NONCE":e};let t="";if("GET"===s){if(!this.isEmpty(d)){const e="?"+this.urlencode(d);h+=e,o+=e}}else this.isEmpty(d)||(t=a=this.json(d)),r["Content-Type"]="application/json";const i=o+s+e+e+t,c=this.stringToBase64(this.hmac(this.encode(i),this.encode(this.secret),n.s));r["ACCESS-SIGN"]=c}return{url:h,method:s,body:a,headers:r}}}},3413:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9644),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"btcalpha",name:"BTC-Alpha",countries:["US"],version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL2OrderBook:!0,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","1d":"D"},urls:{logo:"https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg",api:{rest:"https://btc-alpha.com/api"},www:"https://btc-alpha.com",doc:"https://btc-alpha.github.io/api-docs",fees:"https://btc-alpha.com/fees/",referral:"https://btc-alpha.com/?r=123788"},api:{public:{get:["currencies/","pairs/","orderbook/{pair_name}","exchanges/","charts/{pair}/{type}/chart/","ticker/"]},private:{get:["wallets/","orders/own/","order/{id}/","exchanges/own/","deposits/","withdraws/"],post:["order/","order-cancel/"]}},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")},funding:{withdraw:{}}},commonCurrencies:{CBC:"Cashbery"},precisionMode:o.kb,exceptions:{exact:{},broad:{"Out of balance":r.InsufficientFunds}}})}async fetchMarkets(e={}){const t=await this.publicGetPairs(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeString(e,"currency1"),i=this.safeString(e,"currency2"),r=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeString(e,"price_precision"),d=this.parsePrecision(n),h=this.safeString(e,"minimum_order_size");return{id:t,symbol:r+"/"+o,base:r,quote:o,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amount_precision"))),price:this.parseNumber(this.parsePrecision(n))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(h),max:this.safeNumber(e,"maximum_order_size")},price:{min:this.parseNumber(d),max:void 0},cost:{min:this.parseNumber(a.Y.stringMul(d,h)),max:void 0}},created:void 0,info:e}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"timestamp"),i=parseInt(a.Y.stringMul(s,"1000000")),r=this.safeString(e,"pair");t=this.safeMarket(r,t,"_");const o=this.safeString(e,"last");return this.safeTicker({info:e,symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:this.safeString(e,"diff"),percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"vol")},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair_name:i.id};t&&(r.limit_sell=t,r.limit_buy=t);const a=await this.publicGetOrderbookPairName(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"buy","sell","price","amount")}parseBidsAsks(e,t=0,s=1,i=2){const r=[];for(let i=0;i<e.length;i++){const a=e[i];a&&r.push(this.parseBidAsk(a,t,s))}return r}parseTrade(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"timestamp"),r=this.parseToInt(a.Y.stringMul(i,"1000000")),o=this.safeString(e,"price"),n=this.safeString(e,"amount"),d=this.safeString(e,"id"),h=this.safeString2(e,"my_side","type");return this.safeTrade({id:d,info:e,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,order:d,type:"limit",side:h,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.pair=r.id),void 0!==s&&(a.limit=s);const o=await this.publicGetExchanges(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a=await this.privateGetDeposits(i);return this.parseTransactions(a,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.currency_id=r.id);const o=await this.privateGetWithdraws(this.extend(a,i));return this.parseTransactions(o,r,t,s,{type:"withdrawal"})}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),r=this.safeString(e,"status");return{id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),txid:void 0,type:void 0,status:this.parseTransactionStatus(r),comment:void 0,internal:void 0,fee:void 0,updated:void 0}}parseTransactionStatus(e){return this.safeString({10:"pending",20:"pending",30:"ok",40:"failed",50:"canceled"},e,e)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="5m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,type:this.safeString(this.timeframes,t,t)};void 0!==i&&(o.limit=i),void 0!==s&&(o.since=this.parseToInt(s/1e3));const n=await this.publicGetChartsPairTypeChart(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(i,"reserve"),o.total=this.safeString(i,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWallets(e);return this.parseBalance(t)}parseOrderStatus(e){return this.safeString({1:"open",2:"canceled",3:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"pair"),i=(t=this.safeMarket(s,t,"_")).symbol;let r;r=this.safeBool(e,"success",!1)?this.safeTimestamp(e,"date"):this.safeInteger(e,"date");const a=this.safeString(e,"price"),o=this.safeString(e,"amount"),n=this.safeString(e,"amount_filled"),d=this.safeString(e,"amount_original"),h=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeStringN(e,["oid","id","order"]),l=this.safeValue(e,"trades"),u=this.safeString2(e,"my_side","type");return this.safeOrder({id:c,clientOrderId:void 0,datetime:this.iso8601(r),timestamp:r,status:h,symbol:i,type:"limit",timeInForce:void 0,postOnly:void 0,side:u,price:a,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:d,filled:n,remaining:o,trades:l,fee:void 0,info:e,lastTradeTimestamp:void 0,average:void 0},t)}async createOrder(e,t,s,i,o=void 0,n={}){if("market"===t)throw new r.InvalidOrder(this.id+" only limits orders are supported");await this.loadMarkets();const d=this.market(e),h={pair:d.id,type:s,amount:i,price:this.priceToPrecision(e,o)},c=await this.privatePostOrder(this.extend(h,n));if(!c.success)throw new r.InvalidOrder(this.id+" "+this.json(c));const l=this.parseOrder(c,d),u=l.amount.toString();return i=a.Y.stringGt(u,"0")?l.amount:i,l.amount=this.parseNumber(i),l}async cancelOrder(e,t=void 0,s={}){const i={order:e},r=await this.privatePostOrderCancel(this.extend(i,s));return this.parseOrder(r)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrderId(this.extend(i,s));return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.pair=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetOrdersOwn(this.extend(r,i));return this.parseOrders(o,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"1"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"3"},i))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};if(void 0!==e){const t=this.market(e);r.pair=t.id}void 0!==s&&(r.limit=s);const a=await this.privateGetExchangesOwn(this.extend(r,i));return this.parseTrades(a,void 0,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.urlencode(this.keysort(this.omit(i,this.extractParams(e))));let d=this.urls.api.rest+"/";if("charts/{pair}/{type}/chart/"!==e&&(d+="v1/"),d+=this.implodeParams(e,i),r={Accept:"application/json"},"public"===t)o.length&&(d+="?"+o);else{this.checkRequiredCredentials();let e=this.apiKey;"POST"===s?(r["Content-Type"]="application/x-www-form-urlencoded",e+=a=o):o.length&&(d+="?"+o),r["X-KEY"]=this.apiKey,r["X-SIGN"]=this.hmac(this.encode(e),this.encode(this.secret),n.s),r["X-NONCE"]=this.nonce().toString()}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"error");if(void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}}},5376:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(3829),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(4035);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"btcbox",name:"BtcBox",countries:["JP"],rateLimit:1e3,version:"v1",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1,ws:!1},urls:{logo:"https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg",api:{rest:"https://www.btcbox.co.jp/api"},www:"https://www.btcbox.co.jp/",doc:"https://blog.btcbox.jp/en/archives/8762",fees:"https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction"},api:{public:{get:["depth","orders","ticker","tickers"]},private:{post:["balance","trade_add","trade_cancel","trade_list","trade_view","wallet"]}},precisionMode:o.kb,exceptions:{104:r.AuthenticationError,105:r.PermissionDenied,106:r.InvalidNonce,107:r.InvalidOrder,200:r.InsufficientFunds,201:r.InvalidOrder,202:r.InvalidOrder,203:r.OrderNotFound,401:r.OrderNotFound,402:r.DDoSProtection}})}async fetchMarkets(e={}){const t=await this.publicGetTickers(),s=Object.keys(t),i=[];for(let e=0;e<s.length;e++){const r=s[e],a=r.split("_"),o=this.safeString(a,0),n=this.safeString(a,1),d=n.toLowerCase(),h=o.toLowerCase(),c=t[r],l=o+"/"+n,u="BTC"===h?this.parseNumber("0.0005"):this.parseNumber("0.0010");i.push(this.safeMarketStructure({id:h,uppercaseId:void 0,symbol:l,base:o,baseId:h,quote:n,quoteId:d,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,taker:u,maker:u,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}},precision:{price:void 0,amount:void 0},active:void 0,created:void 0,info:c}))}return i}parseMarket(e){const t=this.safeString(e,"base"),s=this.safeCurrencyCode(t),i=this.safeString(e,"quote"),r=this.safeCurrencyCode(i),a=s+"/"+r;return{id:this.safeString(e,"symbol"),uppercaseId:void 0,symbol:a,base:s,baseId:t,quote:r,quoteId:i,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,limits:{amount:{min:this.safeNumber(e,"minLimitBaseAmount"),max:this.safeNumber(e,"maxLimitBaseAmount")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0},leverage:{min:void 0,max:void 0}},precision:{price:this.parseNumber(this.parsePrecision(this.safeString(e,"quotePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(e,"basePrecision")))},active:void 0,created:void 0,info:e}}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const r=s[i],a=this.currency(r).id,o=a+"_balance";if(o in e){const s=this.account(),i=a+"_lock";s.free=this.safeString(e,o),s.used=this.safeString(e,i),t[r]=s}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={};this.symbols.length>1&&(r.coin=i.baseId);const a=await this.publicGetDepth(this.extend(r,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};this.symbols.length>1&&(i.coin=s.baseId);const r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");t=this.safeMarket(void 0,t);const i=this.safeString(e,"tid"),r=this.safeString(e,"price"),a=this.safeString(e,"amount"),o=this.safeString(e,"type");return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:undefined,side:o,takerOrMaker:void 0,price:r,amount:a,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={};this.symbols.length>1&&(a.coin=r.baseId);const o=await this.publicGetOrders(this.extend(a,i));return this.parseTrades(o,r,t,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={amount:i,price:r,type:s,coin:o.baseId},d=await this.privatePostTradeAdd(this.extend(n,a));return this.parseOrder(d,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const i=this.market(t),r={id:e,coin:i.baseId},a=await this.privatePostTradeCancel(this.extend(r,s));return this.parseOrder(a,i)}parseOrderStatus(e){return this.safeString({part:"open",all:"closed",cancelled:"canceled",closed:"closed",no:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id");let i;void 0!==this.safeString(e,"datetime")&&(i=this.parse8601(e.datetime+"+09:00"));const r=this.safeString(e,"amount_original"),o=this.safeString(e,"amount_outstanding"),n=this.safeString(e,"price");let d=this.parseOrderStatus(this.safeString(e,"status"));void 0===d&&a.Y.stringEquals(o,"0")&&(d="closed");t=this.safeMarket(void 0,t);const h=this.safeString(e,"type");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,amount:r,remaining:o,filled:void 0,side:h,type:void 0,timeInForce:void 0,postOnly:void 0,status:d,symbol:t.symbol,price:n,stopPrice:void 0,triggerPrice:void 0,cost:void 0,trades:undefined,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const i=this.market(t),r=this.extend({id:e,coin:i.baseId},s),a=await this.privatePostTradeView(this.extend(r,s));return this.parseOrder(a,i)}async fetchOrdersByType(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets(),void 0===t&&(t="BTC/JPY");const a=this.market(t),o={type:e,coin:a.baseId},n=await this.privatePostTradeList(this.extend(o,r)),d=this.parseOrders(n,a,s,i);if("open"===e)for(let e=0;e<d.length;e++)d[e].status="open";return d}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("all",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByType("open",e,t,s,i)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+this.version+"/"+e;if("public"===t)Object.keys(i).length&&(o+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.extend({key:this.apiKey,nonce:e},i),s=this.urlencode(t),o=this.hash(this.encode(this.secret),d.F);t.signature=this.hmac(this.encode(s),this.encode(o),n.s),a=this.urlencode(t),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(e>=400)return;const c=this.safeValue(n,"result");if(void 0===c||!0===c)return;const l=this.safeValue(n,"code"),u=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions,l,u),new r.ExchangeError(u)}async request(e,t="public",s="GET",i={},a=void 0,o=void 0,n={}){let d=await this.fetch2(e,t,s,i,a,o,n);if("string"==typeof d){if(d=this.strip(d),!this.isJsonEncodedObject(d))throw new r.ExchangeError(this.id+" "+d);d=JSON.parse(d)}return d}}},4936:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(2317),r=s(2079),a=s(1579),o=s(5147),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"btcmarkets",name:"BTC Markets",countries:["AU"],rateLimit:1e3,version:"v3",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:"emulated",fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:"emulated",fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg",api:{public:"https://api.btcmarkets.net",private:"https://api.btcmarkets.net"},www:"https://btcmarkets.net",doc:["https://api.btcmarkets.net/doc/v3","https://github.com/BTCMarkets/API"]},api:{public:{get:["markets","markets/{marketId}/ticker","markets/{marketId}/trades","markets/{marketId}/orderbook","markets/{marketId}/candles","markets/tickers","markets/orderbooks","time"]},private:{get:["orders","orders/{id}","batchorders/{ids}","trades","trades/{id}","withdrawals","withdrawals/{id}","deposits","deposits/{id}","transfers","transfers/{id}","addresses","withdrawal-fees","assets","accounts/me/trading-fees","accounts/me/withdrawal-limits","accounts/me/balances","accounts/me/transactions","reports/{id}"],post:["orders","batchorders","withdrawals","reports"],delete:["orders","orders/{id}","batchorders/{ids}"],put:["orders/{id}"]}},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},precisionMode:a.kb,exceptions:{exact:{InsufficientFund:r.InsufficientFunds,InvalidPrice:r.InvalidOrder,InvalidAmount:r.InvalidOrder,MissingArgument:r.BadRequest,OrderAlreadyCancelled:r.InvalidOrder,OrderNotFound:r.OrderNotFound,OrderStatusIsFinal:r.InvalidOrder,InvalidPaginationParameter:r.BadRequest},broad:{}},fees:{percentage:!0,tierBased:!0,maker:this.parseNumber("-0.0005"),taker:this.parseNumber("0.0020")},options:{fees:{AUD:{maker:this.parseNumber("0.0085"),taker:this.parseNumber("0.0085")}}}})}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==i&&(a.limit=i),void 0!==s&&(a.after=s),void 0!==t&&(o=this.currency(t));const n=await this[e](this.extend(a,r));return this.parseTransactions(n,o,s,i)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetTransfers",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetDeposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("privateGetWithdrawals",e,t,s,i)}parseTransactionStatus(e){return this.safeString({Accepted:"pending","Pending Authorization":"pending",Complete:"ok",Cancelled:"cancelled",Failed:"failed"},e,e)}parseTransactionType(e){return this.safeString({Withdraw:"withdrawal",Deposit:"deposit"},e,e)}parseTransaction(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.parse8601(this.safeString(e,"lastUpdate"));let r=this.parseTransactionType(this.safeStringLower(e,"type"));"withdraw"===r&&(r="withdrawal");const a=this.safeValue(e,"paymentDetail",{}),n=this.safeString(a,"txId");let d,h=this.safeString(a,"address");if(void 0!==h){const e=h.split("?dt=");e.length>1&&(h=e[0],d=e[1])}const c=h,l=d,u=this.safeString(e,"fee"),p=this.parseTransactionStatus(this.safeString(e,"status")),f=this.safeString(e,"assetName"),m=this.safeCurrencyCode(f);let g=this.safeString(e,"amount");return u&&(g=o.Y.stringSub(g,u)),{id:this.safeString(e,"id"),txid:n,timestamp:s,datetime:this.iso8601(s),network:void 0,address:h,addressTo:c,addressFrom:undefined,tag:d,tagTo:l,tagFrom:undefined,type:r,amount:this.parseNumber(g),currency:m,status:p,updated:i,comment:this.safeString(e,"description"),internal:void 0,fee:{currency:m,cost:this.parseNumber(u),rate:void 0},info:e}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"baseAssetName"),s=this.safeString(e,"quoteAssetName"),i=this.safeString(e,"marketId"),r=this.safeCurrencyCode(t),a=this.safeCurrencyCode(s),o=r+"/"+a,n=this.safeValue(this.safeValue(this.options,"fees",{}),a,this.fees),d=this.parseNumber(this.parsePrecision(this.safeString(e,"priceDecimals"))),h=this.safeNumber(e,"minOrderAmount"),c=this.safeNumber(e,"maxOrderAmount");let l;return"AUD"===a&&(l=d),{id:i,symbol:o,base:r,quote:a,settle:void 0,baseId:t,quoteId:s,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"Online"===this.safeString(e,"status"),contract:!1,linear:void 0,inverse:void 0,taker:n.taker,maker:n.maker,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amountDecimals"))),price:d},limits:{leverage:{min:void 0,max:void 0},amount:{min:h,max:c},price:{min:l,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"timestamp"))}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"assetName"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(i,"locked"),o.total=this.safeString(i,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsMeBalances(e);return this.parseBalance(t)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,0)),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={marketId:a.id,timeWindow:this.safeString(this.timeframes,t,t)};void 0!==s&&(o.from=this.iso8601(s)),void 0!==i&&(o.limit=Math.min(i,200));const n=await this.publicGetMarketsMarketIdCandles(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={marketId:this.market(e).id},r=await this.publicGetMarketsMarketIdOrderbook(this.extend(i,s)),a=this.safeIntegerProduct(r,"snapshotId",.001),o=this.parseOrderBook(r,e,a);return o.nonce=this.safeInteger(r,"snapshotId"),o}parseTicker(e,t=void 0){const s=this.safeString(e,"marketId"),i=(t=this.safeMarket(s,t,"-")).symbol,r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString(e,"lastPrice"),o=this.safeString(e,"volume24h"),n=this.safeString(e,"volumeQte24h"),d=this.safeString(e,"price24h"),h=this.safeString(e,"pricePct24h");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high24h"),low:this.safeString(e,"low"),bid:this.safeString(e,"bestBid"),bidVolume:void 0,ask:this.safeString(e,"bestAsk"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:d,percentage:h,average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketId:s.id},r=await this.publicGetMarketsMarketIdTicker(this.extend(i,t));return this.parseTicker(r,s)}async fetchTicker2(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},r=await this.publicGetMarketsMarketIdTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"timestamp")),i=this.safeString(e,"marketId"),r="AUD"===(t=this.safeMarket(i,t,"-")).quote?t.quote:t.base;let a=this.safeString(e,"side");"Bid"===a?a="buy":"Ask"===a&&(a="sell");const o=this.safeString(e,"id"),n=this.safeString(e,"price"),d=this.safeString(e,"amount"),h=this.safeString(e,"orderId");let c;const l=this.safeString(e,"fee");void 0!==l&&(c={cost:l,currency:r});const u=this.safeStringLower(e,"liquidityType");return this.safeTrade({info:e,id:o,timestamp:s,datetime:this.iso8601(s),order:h,symbol:t.symbol,type:void 0,side:a,price:n,amount:d,cost:void 0,takerOrMaker:u,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={marketId:r.id},o=await this.publicGetMarketsMarketIdTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={marketId:n.id,amount:this.amountToPrecision(e,i),side:"buy"===s?"Bid":"Ask"},h=t.toLowerCase(),c=this.safeValue(this.options,"orderTypes",{limit:"Limit",market:"Market",stop:"Stop","stop limit":"Stop Limit","take profit":"Take Profit"});d.type=this.safeString(c,h,t);let l=!1,u=!1;if("limit"===h?l=!0:"stop limit"===h?(u=!0,l=!0):("take profit"===h||"stop"===h)&&(u=!0),l){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for a "+t+"order");d.price=this.priceToPrecision(e,a)}if(u){const s=this.safeNumber(o,"triggerPrice");if(o=this.omit(o,"triggerPrice"),void 0===s)throw new r.ArgumentsRequired(this.id+" createOrder() requires a triggerPrice parameter for a "+t+"order");d.triggerPrice=this.priceToPrecision(e,s)}const p=this.safeString(o,"clientOrderId");void 0!==p&&(d.clientOrderId=p),o=this.omit(o,"clientOrderId");const f=await this.privatePostOrders(this.extend(d,o));return this.parseOrder(f,n)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();for(let t=0;t<e.length;t++)e[t]=parseInt(e[t]);const i={ids:e},r=await this.privateDeleteBatchordersIds(this.extend(i,s)),a=this.safeList(r,"cancelOrders",[]),o=this.safeList(r,"unprocessedRequests",[]),n=this.arrayConcat(a,o);return this.parseOrders(n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateDeleteOrdersId(this.extend(i,s));return this.parseOrder(r)}calculateFee(e,t,s,i,r,a="taker",n={}){const d=this.markets[e];let h,c;if("AUD"===d.quote){h=d.quote;const t=this.numberToString(i),s=this.numberToString(r),a=o.Y.stringMul(t,s);c=this.costToPrecision(e,a)}else h=d.base,c=this.amountToPrecision(e,i);const l=d[a],u=o.Y.stringMul(this.numberToString(l),c);return{type:a,currency:h,rate:l,cost:parseFloat(this.feeToPrecision(e,u))}}parseOrderStatus(e){return this.safeString({Accepted:"open",Placed:"open","Partially Matched":"open","Fully Matched":"closed",Cancelled:"canceled","Partially Cancelled":"canceled",Failed:"rejected"},e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"creationTime")),i=this.safeString(e,"marketId");t=this.safeMarket(i,t,"-");let r=this.safeString(e,"side");"Bid"===r?r="buy":"Ask"===r&&(r="sell");const a=this.safeStringLower(e,"type"),o=this.safeString(e,"price"),n=this.safeString(e,"amount"),d=this.safeString(e,"openAmount"),h=this.parseOrderStatus(this.safeString(e,"status")),c=this.safeString(e,"orderId"),l=this.safeString(e,"clientOrderId"),u=this.safeString(e,"timeInForce"),p=this.safeNumber(e,"triggerPrice"),f=this.safeValue(e,"postOnly");return this.safeOrder({info:e,id:c,clientOrderId:l,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:a,timeInForce:u,postOnly:f,side:r,price:o,stopPrice:p,triggerPrice:p,cost:void 0,amount:n,filled:void 0,remaining:d,average:void 0,status:h,trades:void 0,fee:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(r)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={status:"all"};let a;void 0!==e&&(a=this.market(e),r.marketId=a.id),void 0!==t&&(r.after=t),void 0!==s&&(r.limit=s);const o=await this.privateGetOrders(this.extend(r,i));return this.parseOrders(o,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"open"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchOrders(e,t,s,i);return this.filterBy(r,"status","closed")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.marketId=a.id),void 0!==t&&(r.after=t),void 0!==s&&(r.limit=s);const o=await this.privateGetTrades(this.extend(r,i));return this.parseTrades(o,a,t,s)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={currency_id:a.id,amount:this.currencyToPrecision(e,t)};"AUD"!==e&&(this.checkAddress(s),o.toAddress=s),void 0!==i&&(o.toAddress=s+"?dt="+i);const n=await this.privatePostWithdrawals(this.extend(o,r));return this.parseTransaction(n,a)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.version+"/"+this.implodeParams(e,i);const d=this.keysort(this.omit(i,this.extractParams(e)));if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.base64ToBinary(this.secret);let i=s+o+e;"GET"===s||"DELETE"===s?Object.keys(d).length&&(o+="?"+this.urlencode(d)):i+=a=this.json(d);const h=this.hmac(this.encode(i),t,n.Zf,"base64");r={Accept:"application/json","Accept-Charset":"UTF-8","Content-Type":"application/json","BM-AUTH-APIKEY":this.apiKey,"BM-AUTH-TIMESTAMP":e,"BM-AUTH-SIGNATURE":h}}else"public"===t&&Object.keys(d).length&&(o+="?"+this.urlencode(d));return{url:this.urls.api[t]+o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},9265:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8430),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"btcturk",name:"BTCTurk",countries:["TR"],rateLimit:100,pro:!1,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,ws:!1},timeframes:{"1m":1,"15m":15,"30m":30,"1h":60,"4h":240,"1d":"1 d","1w":"1 w","1y":"1 y"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153926-efbef500-c2c0-11ea-9842-05b63612c4b9.jpg",api:{public:"https://api.btcturk.com/api/v2",private:"https://api.btcturk.com/api/v1",graph:"https://graph-api.btcturk.com/v1"},www:"https://www.btcturk.com",doc:"https://github.com/BTCTrader/broker-api-docs"},api:{public:{get:{orderbook:1,ticker:.1,trades:1,ohlc:1,"server/exchangeinfo":1}},private:{get:{"users/balances":1,openOrders:1,allOrders:1,"users/transactions/trade":1},post:{"users/transactions/crypto":1,"users/transactions/fiat":1,order:1,cancelOrder:1},delete:{order:1}},graph:{get:{ohlcs:1,"klines/history":1}}},fees:{trading:{maker:this.parseNumber("0.0005"),taker:this.parseNumber("0.0009")}},exceptions:{exact:{FAILED_ORDER_WITH_OPEN_ORDERS:r.InsufficientFunds,FAILED_LIMIT_ORDER:r.InvalidOrder,FAILED_MARKET_ORDER:r.InvalidOrder}},precisionMode:o.kb})}async fetchMarkets(e={}){const t=await this.publicGetServerExchangeinfo(e),s=this.safeValue(t,"data"),i=this.safeValue(s,"symbols",[]);return this.parseMarkets(i)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeString(e,"numerator"),i=this.safeString(e,"denominator"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeValue(e,"filters",[]);let n,d,h,c,l;for(let e=0;e<o.length;e++){const t=o[e];"PRICE_FILTER"===this.safeString(t,"filterType")&&(n=this.safeNumber(t,"minPrice"),d=this.safeNumber(t,"maxPrice"),h=this.safeNumber(t,"minAmount"),c=this.safeNumber(t,"maxAmount"),l=this.safeNumber(t,"minExchangeValue"))}return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"TRADING"===this.safeString(e,"status"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"numeratorScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"denominatorScale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:h,max:c},price:{min:n,max:d},cost:{min:l,max:void 0}},created:void 0,info:e}}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.free=this.safeString(i,"free"),o.used=this.safeString(i,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUsersBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pairSymbol:i.id},a=await this.publicGetOrderbook(this.extend(r,s)),o=this.safeValue(a,"data"),n=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,n,"bids","asks",0,1)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeInteger(e,"timestamp"),a=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:a,last:a,previousClose:void 0,change:this.safeString(e,"daily"),percentage:this.safeString(e,"dailyPercent"),average:this.safeString(e,"average"),baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.safeList(s,"data");return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"date","timestamp"),i=this.safeString2(e,"tid","id"),r=this.safeString(e,"orderId"),o=this.safeString(e,"price"),n=a.Y.stringAbs(this.safeString(e,"amount")),d=this.safeString(e,"pair"),h=this.safeSymbol(d,t),c=this.safeString2(e,"side","orderType");let l;const u=this.safeString(e,"fee");if(void 0!==u){const t=this.safeString(e,"denominatorSymbol");l={cost:a.Y.stringAbs(u),currency:this.safeCurrencyCode(t)}}return this.safeTrade({info:e,id:i,order:r,timestamp:s,datetime:this.iso8601(s),symbol:h,type:void 0,side:c,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pairSymbol:r.id};void 0!==s&&(a.last=s);const o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,"data");return this.parseTrades(n,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1h",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={symbol:o.id,resolution:this.safeValue(this.timeframes,t,t)},d=this.safeInteger(a,"until",this.milliseconds());if(n.to=this.parseToInt(d/1e3),void 0!==s?n.from=this.parseToInt(s/1e3):void 0===i&&(i=100),void 0!==i){if(i=Math.min(i,11e3),"1y"===t)throw new r.BadRequest(this.id+' fetchOHLCV () does not accept a limit parameter when timeframe == "1y"');const e=this.parseTimeframe(t)*(i-1);if(void 0!==s){const t=this.parseToInt(s/1e3)+e;n.to=Math.min(n.to,t)}else n.from=this.parseToInt(0)-e}const h=await this.graphGetKlinesHistory(this.extend(n,a));return this.parseOHLCVs(h,o,t,s,i)}parseOHLCVs(e,t=void 0,s="1m",i=void 0,r=void 0){const a=[],o=this.safeValue(e,"t"),n=this.safeValue(e,"h"),d=this.safeValue(e,"o"),h=this.safeValue(e,"l"),c=this.safeValue(e,"c"),l=this.safeValue(e,"v");for(let e=0;e<o.length;e++){const s={timestamp:this.safeValue(o,e),high:this.safeValue(n,e),open:this.safeValue(d,e),low:this.safeValue(h,e),close:this.safeValue(c,e),volume:this.safeValue(l,e)};a.push(this.parseOHLCV(s,t))}const u=this.sortBy(a,0);return this.filterBySinceLimit(u,i,r,0)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={orderType:s,orderMethod:t,pairSymbol:o.id,quantity:this.amountToPrecision(e,i)};"market"!==t&&(n.price=this.priceToPrecision(e,r)),"clientOrderId"in a?n.newClientOrderId=a.clientOrderId:"newClientOrderId"in a||(n.newClientOrderId=this.uuid());const d=await this.privatePostOrder(this.extend(n,a)),h=this.safeDict(d,"data");return this.parseOrder(h,o)}async cancelOrder(e,t=void 0,s={}){const i={id:e},r=await this.privateDeleteOrder(this.extend(i,s));return this.safeOrder({info:r})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.pairSymbol=a.id);const o=await this.privateGetOpenOrders(this.extend(r,i)),n=this.safeValue(o,"data"),d=this.safeValue(n,"bids",[]),h=this.safeList(n,"asks",[]);return this.parseOrders(this.arrayConcat(d,h),a,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pairSymbol:r.id};void 0!==s&&(a.last=s),void 0!==t&&(a.startTime=Math.floor(t/1e3));const o=await this.privateGetAllOrders(this.extend(a,i)),n=this.safeList(o,"data");return this.parseOrders(n,r,t,s)}parseOrderStatus(e){return this.safeString({Untouched:"open",Partial:"open",Canceled:"canceled",Closed:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"price"),r=this.safeString2(e,"amount","quantity"),o=a.Y.stringAbs(r),n=this.safeString(e,"leftAmount"),d=this.safeString(e,"pairSymbol"),h=this.safeSymbol(d,t),c=this.safeString(e,"type"),l=this.safeString(e,"method"),u=this.safeString(e,"orderClientId"),p=this.safeInteger2(e,"updateTime","datetime"),f=this.safeString(e,"status"),m=this.parseOrderStatus(f);return this.safeOrder({info:e,id:s,price:i,amount:o,remaining:n,filled:void 0,cost:void 0,average:void 0,status:m,side:c,type:l,clientOrderId:u,timestamp:p,datetime:this.iso8601(p),symbol:h,fee:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privateGetUsersTransactionsTrade(),o=this.safeList(a,"data");return this.parseTrades(o,r,t,s)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},a=void 0,o=void 0){if("btctrader"===this.id)throw new r.ExchangeError(this.id+" is an abstract base API for BTCExchange, BTCTurk");let d=this.urls.api[t]+"/"+e;if("GET"===s||"DELETE"===s?Object.keys(i).length&&(d+="?"+this.urlencode(i)):o=this.json(i),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.base64ToBinary(this.secret),s=this.apiKey+e;a={"X-PCK":this.apiKey,"X-Stamp":e,"X-Signature":this.hmac(this.encode(s),t,n.s,"base64"),"Content-Type":"application/json"}}return{url:d,method:s,body:o,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){const c=this.safeString(n,"code","0"),l=this.safeString(n,"message"),u=void 0===l?o:l;if(this.throwExactlyMatchedException(this.exceptions.exact,l,this.id+" "+u),"0"!==c&&"SUCCESS"!==c)throw new r.ExchangeError(this.id+" "+u)}}},5462:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(1293),r=s(1579),a=s(2079),o=s(5147),n=s(4852),d=s(5354);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"bybit",name:"Bybit",countries:["VG"],version:"v5",userAgent:void 0,rateLimit:20,hostname:"bybit.com",pro:!0,certified:!0,has:{CORS:!0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,borrowCrossMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!0,closeAllPositions:!1,closePosition:!1,createMarketBuyOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingAmountOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledAndClosedOrders:!0,fetchCanceledOrders:!0,fetchClosedOrder:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchGreeks:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!0,fetchMySettlementHistory:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositions:!0,fetchPositionsHistory:!0,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfers:!0,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!0,fetchWithdrawals:!0,repayCrossMargin:!0,sandbox:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M"},urls:{test:{spot:"https://api-testnet.{hostname}",futures:"https://api-testnet.{hostname}",v2:"https://api-testnet.{hostname}",public:"https://api-testnet.{hostname}",private:"https://api-testnet.{hostname}"},logo:"https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg",api:{spot:"https://api.{hostname}",futures:"https://api.{hostname}",v2:"https://api.{hostname}",public:"https://api.{hostname}",private:"https://api.{hostname}"},demotrading:{spot:"https://api-demo.{hostname}",futures:"https://api-demo.{hostname}",v2:"https://api-demo.{hostname}",public:"https://api-demo.{hostname}",private:"https://api-demo.{hostname}"},www:"https://www.bybit.com",doc:["https://bybit-exchange.github.io/docs/inverse/","https://bybit-exchange.github.io/docs/linear/","https://github.com/bybit-exchange"],fees:"https://help.bybit.com/hc/en-us/articles/360039261154",referral:"https://www.bybit.com/register?affiliate_id=35953"},api:{public:{get:{"spot/v3/public/symbols":1,"spot/v3/public/quote/depth":1,"spot/v3/public/quote/depth/merged":1,"spot/v3/public/quote/trades":1,"spot/v3/public/quote/kline":1,"spot/v3/public/quote/ticker/24hr":1,"spot/v3/public/quote/ticker/price":1,"spot/v3/public/quote/ticker/bookTicker":1,"spot/v3/public/server-time":1,"spot/v3/public/infos":1,"spot/v3/public/margin-product-infos":1,"spot/v3/public/margin-ensure-tokens":1,"v3/public/time":1,"contract/v3/public/copytrading/symbol/list":1,"derivatives/v3/public/order-book/L2":1,"derivatives/v3/public/kline":1,"derivatives/v3/public/tickers":1,"derivatives/v3/public/instruments-info":1,"derivatives/v3/public/mark-price-kline":1,"derivatives/v3/public/index-price-kline":1,"derivatives/v3/public/funding/history-funding-rate":1,"derivatives/v3/public/risk-limit/list":1,"derivatives/v3/public/delivery-price":1,"derivatives/v3/public/recent-trade":1,"derivatives/v3/public/open-interest":1,"derivatives/v3/public/insurance":1,"v5/announcements/index":5,"v5/market/time":5,"v5/market/kline":5,"v5/market/mark-price-kline":5,"v5/market/index-price-kline":5,"v5/market/premium-index-price-kline":5,"v5/market/instruments-info":5,"v5/market/orderbook":5,"v5/market/tickers":5,"v5/market/funding/history":5,"v5/market/recent-trade":5,"v5/market/open-interest":5,"v5/market/historical-volatility":5,"v5/market/insurance":5,"v5/market/risk-limit":5,"v5/market/delivery-price":5,"v5/market/account-ratio":5,"v5/spot-lever-token/info":5,"v5/spot-lever-token/reference":5,"v5/spot-margin-trade/data":5,"v5/spot-cross-margin-trade/data":5,"v5/spot-cross-margin-trade/pledge-token":5,"v5/spot-cross-margin-trade/borrow-token":5,"v5/ins-loan/product-infos":5,"v5/ins-loan/ensure-tokens-convert":5}},private:{get:{"v5/market/instruments-info":5,"v2/private/wallet/fund/records":25,"spot/v3/private/order":2.5,"spot/v3/private/open-orders":2.5,"spot/v3/private/history-orders":2.5,"spot/v3/private/my-trades":2.5,"spot/v3/private/account":2.5,"spot/v3/private/reference":2.5,"spot/v3/private/record":2.5,"spot/v3/private/cross-margin-orders":10,"spot/v3/private/cross-margin-account":10,"spot/v3/private/cross-margin-loan-info":10,"spot/v3/private/cross-margin-repay-history":10,"spot/v3/private/margin-loan-infos":10,"spot/v3/private/margin-repaid-infos":10,"spot/v3/private/margin-ltv":10,"asset/v3/private/transfer/inter-transfer/list/query":50,"asset/v3/private/transfer/sub-member/list/query":50,"asset/v3/private/transfer/sub-member-transfer/list/query":50,"asset/v3/private/transfer/universal-transfer/list/query":25,"asset/v3/private/coin-info/query":25,"asset/v3/private/deposit/address/query":10,"contract/v3/private/copytrading/order/list":30,"contract/v3/private/copytrading/position/list":40,"contract/v3/private/copytrading/wallet/balance":25,"contract/v3/private/position/limit-info":25,"contract/v3/private/order/unfilled-orders":1,"contract/v3/private/order/list":1,"contract/v3/private/position/list":1,"contract/v3/private/execution/list":1,"contract/v3/private/position/closed-pnl":1,"contract/v3/private/account/wallet/balance":1,"contract/v3/private/account/fee-rate":1,"contract/v3/private/account/wallet/fund-records":1,"unified/v3/private/order/unfilled-orders":1,"unified/v3/private/order/list":1,"unified/v3/private/position/list":1,"unified/v3/private/execution/list":1,"unified/v3/private/delivery-record":1,"unified/v3/private/settlement-record":1,"unified/v3/private/account/wallet/balance":1,"unified/v3/private/account/transaction-log":1,"unified/v3/private/account/borrow-history":1,"unified/v3/private/account/borrow-rate":1,"unified/v3/private/account/info":1,"user/v3/private/frozen-sub-member":10,"user/v3/private/query-sub-members":5,"user/v3/private/query-api":5,"user/v3/private/get-member-type":1,"asset/v3/private/transfer/transfer-coin/list/query":50,"asset/v3/private/transfer/account-coin/balance/query":50,"asset/v3/private/transfer/account-coins/balance/query":25,"asset/v3/private/transfer/asset-info/query":50,"asset/v3/public/deposit/allowed-deposit-list/query":.17,"asset/v3/private/deposit/record/query":10,"asset/v3/private/withdraw/record/query":10,"v5/order/realtime":5,"v5/order/history":5,"v5/order/spot-borrow-check":1,"v5/position/list":5,"v5/execution/list":5,"v5/position/closed-pnl":5,"v5/position/move-history":5,"v5/pre-upgrade/order/history":5,"v5/pre-upgrade/execution/list":5,"v5/pre-upgrade/position/closed-pnl":5,"v5/pre-upgrade/account/transaction-log":5,"v5/pre-upgrade/asset/delivery-record":5,"v5/pre-upgrade/asset/settlement-record":5,"v5/account/wallet-balance":1,"v5/account/borrow-history":1,"v5/account/collateral-info":1,"v5/asset/coin-greeks":1,"v5/account/fee-rate":10,"v5/account/info":5,"v5/account/transaction-log":1,"v5/account/contract-transaction-log":1,"v5/account/smp-group":1,"v5/account/mmp-state":5,"v5/asset/exchange/order-record":5,"v5/asset/delivery-record":5,"v5/asset/settlement-record":5,"v5/asset/transfer/query-asset-info":50,"v5/asset/transfer/query-account-coins-balance":25,"v5/asset/transfer/query-account-coin-balance":50,"v5/asset/transfer/query-transfer-coin-list":50,"v5/asset/transfer/query-inter-transfer-list":50,"v5/asset/transfer/query-sub-member-list":50,"v5/asset/transfer/query-universal-transfer-list":25,"v5/asset/deposit/query-allowed-list":5,"v5/asset/deposit/query-record":10,"v5/asset/deposit/query-sub-member-record":10,"v5/asset/deposit/query-internal-record":5,"v5/asset/deposit/query-address":10,"v5/asset/deposit/query-sub-member-address":10,"v5/asset/coin/query-info":28,"v5/asset/withdraw/query-record":10,"v5/asset/withdraw/withdrawable-amount":5,"v5/asset/withdraw/vasp/list":5,"v5/user/query-sub-members":5,"v5/user/query-api":5,"v5/user/sub-apikeys":5,"v5/user/get-member-type":5,"v5/user/aff-customer-info":5,"v5/user/del-submember":5,"v5/user/submembers":5,"v5/spot-lever-token/order-record":1,"v5/spot-margin-trade/state":5,"v5/spot-cross-margin-trade/loan-info":1,"v5/spot-cross-margin-trade/account":1,"v5/spot-cross-margin-trade/orders":1,"v5/spot-cross-margin-trade/repay-history":1,"v5/ins-loan/product-infos":5,"v5/ins-loan/ensure-tokens-convert":5,"v5/ins-loan/loan-order":5,"v5/ins-loan/repaid-history":5,"v5/ins-loan/ltv-convert":5,"v5/lending/info":5,"v5/lending/history-order":5,"v5/lending/account":5,"v5/broker/earning-record":5,"v5/broker/earnings-info":5,"v5/broker/account-info":5,"v5/broker/asset/query-sub-member-deposit-record":10},post:{"option/usdc/openapi/private/v1/place-order":2.5,"option/usdc/openapi/private/v1/replace-order":2.5,"option/usdc/openapi/private/v1/cancel-order":2.5,"option/usdc/openapi/private/v1/cancel-all":2.5,"option/usdc/openapi/private/v1/query-active-orders":2.5,"option/usdc/openapi/private/v1/query-order-history":2.5,"option/usdc/openapi/private/v1/execution-list":2.5,"option/usdc/openapi/private/v1/query-position":2.5,"perpetual/usdc/openapi/private/v1/place-order":2.5,"perpetual/usdc/openapi/private/v1/replace-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-order":2.5,"perpetual/usdc/openapi/private/v1/cancel-all":2.5,"perpetual/usdc/openapi/private/v1/position/leverage/save":2.5,"spot/v3/private/order":2.5,"spot/v3/private/cancel-order":2.5,"spot/v3/private/cancel-orders":2.5,"spot/v3/private/cancel-orders-by-ids":2.5,"spot/v3/private/purchase":2.5,"spot/v3/private/redeem":2.5,"spot/v3/private/cross-margin-loan":10,"spot/v3/private/cross-margin-repay":10,"asset/v3/private/transfer/inter-transfer":150,"asset/v3/private/withdraw/create":300,"asset/v3/private/withdraw/cancel":50,"asset/v3/private/transfer/sub-member-transfer":150,"asset/v3/private/transfer/transfer-sub-member-save":150,"asset/v3/private/transfer/universal-transfer":10,"user/v3/private/create-sub-member":10,"user/v3/private/create-sub-api":10,"user/v3/private/update-api":10,"user/v3/private/delete-api":10,"user/v3/private/update-sub-api":10,"user/v3/private/delete-sub-api":10,"contract/v3/private/copytrading/order/create":30,"contract/v3/private/copytrading/order/cancel":30,"contract/v3/private/copytrading/order/close":30,"contract/v3/private/copytrading/position/close":40,"contract/v3/private/copytrading/position/set-leverage":40,"contract/v3/private/copytrading/wallet/transfer":25,"contract/v3/private/copytrading/order/trading-stop":2.5,"contract/v3/private/order/create":1,"contract/v3/private/order/cancel":1,"contract/v3/private/order/cancel-all":1,"contract/v3/private/order/replace":1,"contract/v3/private/position/set-auto-add-margin":1,"contract/v3/private/position/switch-isolated":1,"contract/v3/private/position/switch-mode":1,"contract/v3/private/position/switch-tpsl-mode":1,"contract/v3/private/position/set-leverage":1,"contract/v3/private/position/trading-stop":1,"contract/v3/private/position/set-risk-limit":1,"contract/v3/private/account/setMarginMode":1,"unified/v3/private/order/create":30,"unified/v3/private/order/replace":30,"unified/v3/private/order/cancel":30,"unified/v3/private/order/create-batch":30,"unified/v3/private/order/replace-batch":30,"unified/v3/private/order/cancel-batch":30,"unified/v3/private/order/cancel-all":30,"unified/v3/private/position/set-leverage":2.5,"unified/v3/private/position/tpsl/switch-mode":2.5,"unified/v3/private/position/set-risk-limit":2.5,"unified/v3/private/position/trading-stop":2.5,"unified/v3/private/account/upgrade-unified-account":2.5,"unified/v3/private/account/setMarginMode":2.5,"fht/compliance/tax/v3/private/registertime":50,"fht/compliance/tax/v3/private/create":50,"fht/compliance/tax/v3/private/status":50,"fht/compliance/tax/v3/private/url":50,"v5/order/create":2.5,"v5/order/amend":5,"v5/order/cancel":2.5,"v5/order/cancel-all":50,"v5/order/create-batch":5,"v5/order/amend-batch":5,"v5/order/cancel-batch":5,"v5/order/disconnected-cancel-all":5,"v5/position/set-leverage":5,"v5/position/switch-isolated":5,"v5/position/set-tpsl-mode":5,"v5/position/switch-mode":5,"v5/position/set-risk-limit":5,"v5/position/trading-stop":5,"v5/position/set-auto-add-margin":5,"v5/position/add-margin":5,"v5/position/move-positions":5,"v5/position/confirm-pending-mmr":5,"v5/account/upgrade-to-uta":5,"v5/account/quick-repayment":5,"v5/account/set-margin-mode":5,"v5/account/set-hedging-mode":5,"v5/account/mmp-modify":5,"v5/account/mmp-reset":5,"v5/asset/transfer/inter-transfer":50,"v5/asset/transfer/save-transfer-sub-member":150,"v5/asset/transfer/universal-transfer":10,"v5/asset/deposit/deposit-to-account":5,"v5/asset/withdraw/create":50,"v5/asset/withdraw/cancel":50,"v5/user/create-sub-member":10,"v5/user/create-sub-api":10,"v5/user/frozen-sub-member":10,"v5/user/update-api":10,"v5/user/update-sub-api":10,"v5/user/delete-api":10,"v5/user/delete-sub-api":10,"v5/spot-lever-token/purchase":2.5,"v5/spot-lever-token/redeem":2.5,"v5/spot-margin-trade/switch-mode":5,"v5/spot-margin-trade/set-leverage":5,"v5/spot-cross-margin-trade/loan":2.5,"v5/spot-cross-margin-trade/repay":2.5,"v5/spot-cross-margin-trade/switch":2.5,"v5/ins-loan/association-uid":5,"v5/lending/purchase":5,"v5/lending/redeem":5,"v5/lending/redeem-cancel":5,"v5/account/set-collateral-switch":5,"v5/account/set-collateral-switch-batch":5,"v5/account/demo-apply-money":5}}},httpExceptions:{403:a.RateLimitExceeded},exceptions:{exact:{"-10009":a.BadRequest,"-1004":a.BadRequest,"-1021":a.BadRequest,"-1103":a.BadRequest,"-1140":a.InvalidOrder,"-1197":a.InvalidOrder,"-2013":a.InvalidOrder,"-2015":a.AuthenticationError,"-6017":a.BadRequest,"-6025":a.BadRequest,"-6029":a.BadRequest,5004:a.ExchangeError,7001:a.BadRequest,10001:a.BadRequest,10002:a.InvalidNonce,10003:a.AuthenticationError,10004:a.AuthenticationError,10005:a.PermissionDenied,10006:a.RateLimitExceeded,10007:a.AuthenticationError,10008:a.AuthenticationError,10009:a.AuthenticationError,10010:a.PermissionDenied,10014:a.BadRequest,10016:a.ExchangeError,10017:a.BadRequest,10018:a.RateLimitExceeded,10020:a.PermissionDenied,10024:a.PermissionDenied,10027:a.PermissionDenied,10028:a.PermissionDenied,10029:a.PermissionDenied,12137:a.InvalidOrder,12201:a.BadRequest,12141:a.BadRequest,100028:a.PermissionDenied,110001:a.OrderNotFound,110003:a.InvalidOrder,110004:a.InsufficientFunds,110005:a.InvalidOrder,110006:a.InsufficientFunds,110007:a.InsufficientFunds,110008:a.InvalidOrder,110009:a.InvalidOrder,110010:a.InvalidOrder,110011:a.InvalidOrder,110012:a.InsufficientFunds,110013:a.BadRequest,110014:a.InsufficientFunds,110015:a.BadRequest,110016:a.InvalidOrder,110017:a.InvalidOrder,110018:a.BadRequest,110019:a.InvalidOrder,110020:a.InvalidOrder,110021:a.InvalidOrder,110022:a.InvalidOrder,110023:a.InvalidOrder,110024:a.BadRequest,110025:a.NoChange,110026:a.MarginModeAlreadySet,110027:a.NoChange,110028:a.BadRequest,110029:a.BadRequest,110030:a.InvalidOrder,110031:a.InvalidOrder,110032:a.InvalidOrder,110033:a.InvalidOrder,110034:a.InvalidOrder,110035:a.InvalidOrder,110036:a.InvalidOrder,110037:a.InvalidOrder,110038:a.InvalidOrder,110039:a.InvalidOrder,110040:a.InvalidOrder,110041:a.InvalidOrder,110042:a.InvalidOrder,110043:a.BadRequest,110044:a.InsufficientFunds,110045:a.InsufficientFunds,110046:a.BadRequest,110047:a.BadRequest,110048:a.BadRequest,110049:a.BadRequest,110050:a.BadRequest,110051:a.InsufficientFunds,110052:a.InsufficientFunds,110053:a.InsufficientFunds,110054:a.InvalidOrder,110055:a.InvalidOrder,110056:a.InvalidOrder,110057:a.InvalidOrder,110058:a.InvalidOrder,110059:a.InvalidOrder,110060:a.BadRequest,110061:a.BadRequest,110062:a.BadRequest,110063:a.ExchangeError,110064:a.InvalidOrder,110065:a.PermissionDenied,110066:a.ExchangeError,110067:a.PermissionDenied,110068:a.PermissionDenied,110069:a.PermissionDenied,110070:a.InvalidOrder,110071:a.ExchangeError,110072:a.InvalidOrder,110073:a.ExchangeError,130006:a.InvalidOrder,130021:a.InsufficientFunds,130074:a.InvalidOrder,131001:a.InsufficientFunds,131084:a.ExchangeError,131200:a.ExchangeError,131201:a.ExchangeError,131202:a.BadRequest,131203:a.BadRequest,131204:a.BadRequest,131205:a.BadRequest,131206:a.ExchangeError,131207:a.BadRequest,131208:a.ExchangeError,131209:a.BadRequest,131210:a.BadRequest,131211:a.BadRequest,131212:a.InsufficientFunds,131213:a.BadRequest,131214:a.BadRequest,131215:a.BadRequest,131216:a.ExchangeError,131217:a.ExchangeError,131231:a.NotSupported,131232:a.NotSupported,131002:a.BadRequest,131003:a.ExchangeError,131004:a.AuthenticationError,131085:a.InsufficientFunds,131086:a.BadRequest,131088:a.BadRequest,131089:a.BadRequest,131090:a.ExchangeError,131091:a.ExchangeError,131092:a.ExchangeError,131093:a.ExchangeError,131094:a.BadRequest,131095:a.BadRequest,131096:a.BadRequest,131097:a.ExchangeError,131098:a.ExchangeError,131099:a.ExchangeError,140001:a.OrderNotFound,140003:a.InvalidOrder,140004:a.InsufficientFunds,140005:a.InvalidOrder,140006:a.InsufficientFunds,140007:a.InsufficientFunds,140008:a.InvalidOrder,140009:a.InvalidOrder,140010:a.InvalidOrder,140011:a.InvalidOrder,140012:a.InsufficientFunds,140013:a.BadRequest,140014:a.InsufficientFunds,140015:a.InvalidOrder,140016:a.InvalidOrder,140017:a.InvalidOrder,140018:a.BadRequest,140019:a.InvalidOrder,140020:a.InvalidOrder,140021:a.InvalidOrder,140022:a.InvalidOrder,140023:a.InvalidOrder,140024:a.BadRequest,140025:a.BadRequest,140026:a.BadRequest,140027:a.BadRequest,140028:a.InvalidOrder,140029:a.BadRequest,140030:a.InvalidOrder,140031:a.BadRequest,140032:a.InvalidOrder,140033:a.InvalidOrder,140034:a.InvalidOrder,140035:a.InvalidOrder,140036:a.BadRequest,140037:a.InvalidOrder,140038:a.BadRequest,140039:a.BadRequest,140040:a.InvalidOrder,140041:a.InvalidOrder,140042:a.InvalidOrder,140043:a.BadRequest,140044:a.InsufficientFunds,140045:a.InsufficientFunds,140046:a.BadRequest,140047:a.BadRequest,140048:a.BadRequest,140049:a.BadRequest,140050:a.InvalidOrder,140051:a.InsufficientFunds,140052:a.InsufficientFunds,140053:a.InsufficientFunds,140054:a.InvalidOrder,140055:a.InvalidOrder,140056:a.InvalidOrder,140057:a.InvalidOrder,140058:a.InvalidOrder,140059:a.InvalidOrder,140060:a.BadRequest,140061:a.BadRequest,140062:a.BadRequest,140063:a.ExchangeError,140064:a.InvalidOrder,140065:a.PermissionDenied,140066:a.ExchangeError,140067:a.PermissionDenied,140068:a.PermissionDenied,140069:a.PermissionDenied,140070:a.InvalidOrder,170001:a.ExchangeError,170005:a.InvalidOrder,170007:a.RequestTimeout,170010:a.InvalidOrder,170011:a.InvalidOrder,170019:a.InvalidOrder,170031:a.ExchangeError,170032:a.ExchangeError,170033:a.InsufficientFunds,170034:a.InsufficientFunds,170035:a.BadRequest,170036:a.BadRequest,170037:a.BadRequest,170105:a.BadRequest,170115:a.InvalidOrder,170116:a.InvalidOrder,170117:a.InvalidOrder,170121:a.InvalidOrder,170124:a.InvalidOrder,170130:a.BadRequest,170131:a.InsufficientFunds,170132:a.InvalidOrder,170133:a.InvalidOrder,170134:a.InvalidOrder,170135:a.InvalidOrder,170136:a.InvalidOrder,170137:a.InvalidOrder,170139:a.InvalidOrder,170140:a.InvalidOrder,170141:a.InvalidOrder,170142:a.InvalidOrder,170143:a.InvalidOrder,170144:a.InvalidOrder,170145:a.InvalidOrder,170146:a.InvalidOrder,170147:a.InvalidOrder,170148:a.InvalidOrder,170149:a.ExchangeError,170150:a.ExchangeError,170151:a.InvalidOrder,170157:a.InvalidOrder,170159:a.InvalidOrder,170190:a.InvalidOrder,170191:a.InvalidOrder,170192:a.InvalidOrder,170193:a.InvalidOrder,170194:a.InvalidOrder,170195:a.InvalidOrder,170196:a.InvalidOrder,170197:a.InvalidOrder,170198:a.InvalidOrder,170199:a.InvalidOrder,170200:a.InvalidOrder,170201:a.PermissionDenied,170202:a.InvalidOrder,170203:a.InvalidOrder,170204:a.InvalidOrder,170206:a.InvalidOrder,170210:a.InvalidOrder,170213:a.OrderNotFound,170217:a.InvalidOrder,170218:a.InvalidOrder,170221:a.BadRequest,170222:a.RateLimitExceeded,170223:a.InsufficientFunds,170224:a.PermissionDenied,170226:a.InsufficientFunds,170227:a.ExchangeError,170228:a.InvalidOrder,170229:a.InvalidOrder,170234:a.ExchangeError,170241:a.ManualInteractionNeeded,175e3:a.InvalidOrder,175001:a.InvalidOrder,175002:a.InvalidOrder,175003:a.InsufficientFunds,175004:a.InvalidOrder,175005:a.InvalidOrder,175006:a.InsufficientFunds,175007:a.InvalidOrder,175008:a.InvalidOrder,175009:a.InvalidOrder,175010:a.PermissionDenied,175012:a.InvalidOrder,175013:a.InvalidOrder,175014:a.InvalidOrder,175015:a.InvalidOrder,175016:a.InvalidOrder,175017:a.InvalidOrder,175027:a.ExchangeError,176002:a.BadRequest,176004:a.BadRequest,176003:a.BadRequest,176006:a.BadRequest,176005:a.BadRequest,176008:a.BadRequest,176007:a.BadRequest,176010:a.BadRequest,176009:a.BadRequest,176012:a.BadRequest,176011:a.BadRequest,176014:a.BadRequest,176013:a.BadRequest,176015:a.InsufficientFunds,176016:a.BadRequest,176017:a.BadRequest,176018:a.BadRequest,176019:a.BadRequest,176020:a.BadRequest,176021:a.BadRequest,176022:a.BadRequest,176023:a.BadRequest,176024:a.BadRequest,176025:a.BadRequest,176026:a.BadRequest,176027:a.BadRequest,176028:a.BadRequest,176029:a.BadRequest,176030:a.BadRequest,176031:a.BadRequest,176034:a.BadRequest,176035:a.PermissionDenied,176036:a.PermissionDenied,176037:a.PermissionDenied,176038:a.BadRequest,176039:a.BadRequest,176040:a.BadRequest,181e3:a.BadRequest,181001:a.BadRequest,181002:a.InvalidOrder,181003:a.InvalidOrder,181004:a.InvalidOrder,182e3:a.InvalidOrder,181017:a.BadRequest,20001:a.OrderNotFound,20003:a.InvalidOrder,20004:a.InvalidOrder,20005:a.InvalidOrder,20006:a.InvalidOrder,20007:a.InvalidOrder,20008:a.InvalidOrder,20009:a.InvalidOrder,20010:a.InvalidOrder,20011:a.InvalidOrder,20012:a.InvalidOrder,20013:a.InvalidOrder,20014:a.InvalidOrder,20015:a.InvalidOrder,20016:a.InvalidOrder,20017:a.InvalidOrder,20018:a.InvalidOrder,20019:a.InvalidOrder,20020:a.InvalidOrder,20021:a.InvalidOrder,20022:a.BadRequest,20023:a.BadRequest,20031:a.BadRequest,20070:a.BadRequest,20071:a.BadRequest,20084:a.BadRequest,30001:a.BadRequest,30003:a.InvalidOrder,30004:a.InvalidOrder,30005:a.InvalidOrder,30007:a.InvalidOrder,30008:a.InvalidOrder,30009:a.ExchangeError,30010:a.InsufficientFunds,30011:a.PermissionDenied,30012:a.PermissionDenied,30013:a.PermissionDenied,30014:a.InvalidOrder,30015:a.InvalidOrder,30016:a.ExchangeError,30017:a.InvalidOrder,30018:a.InvalidOrder,30019:a.InvalidOrder,30020:a.InvalidOrder,30021:a.InvalidOrder,30022:a.InvalidOrder,30023:a.InvalidOrder,30024:a.InvalidOrder,30025:a.InvalidOrder,30026:a.InvalidOrder,30027:a.InvalidOrder,30028:a.InvalidOrder,30029:a.InvalidOrder,30030:a.InvalidOrder,30031:a.InsufficientFunds,30032:a.InvalidOrder,30033:a.RateLimitExceeded,30034:a.OrderNotFound,30035:a.RateLimitExceeded,30036:a.ExchangeError,30037:a.InvalidOrder,30041:a.ExchangeError,30042:a.InsufficientFunds,30043:a.InvalidOrder,30044:a.InvalidOrder,30045:a.InvalidOrder,30049:a.InsufficientFunds,30050:a.ExchangeError,30051:a.ExchangeError,30052:a.ExchangeError,30054:a.ExchangeError,30057:a.ExchangeError,30063:a.ExchangeError,30067:a.InsufficientFunds,30068:a.ExchangeError,30074:a.InvalidOrder,30075:a.InvalidOrder,30078:a.ExchangeError,33004:a.AuthenticationError,34026:a.ExchangeError,34036:a.BadRequest,35015:a.BadRequest,340099:a.ExchangeError,3400045:a.ExchangeError,3100116:a.BadRequest,3100198:a.BadRequest,3200300:a.InsufficientFunds},broad:{"Request timeout":a.RequestTimeout,"unknown orderInfo":a.OrderNotFound,"invalid api_key":a.AuthenticationError,oc_diff:a.InsufficientFunds,new_oc:a.InsufficientFunds,"openapi sign params error!":a.AuthenticationError}},precisionMode:r.kb,options:{usePrivateInstrumentsInfo:!1,sandboxMode:!1,enableDemoTrading:!1,fetchMarkets:["spot","linear","inverse","option"],createOrder:{method:"privatePostV5OrderCreate"},enableUnifiedMargin:void 0,enableUnifiedAccount:void 0,createMarketBuyOrderRequiresPrice:!0,createUnifiedMarginAccount:!1,defaultType:"swap",defaultSubType:"linear",defaultSettle:"USDT",code:"BTC",recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,loadAllOptions:!1,loadExpiredOptions:!1,brokerId:"CCXT",accountsByType:{spot:"SPOT",margin:"SPOT",future:"CONTRACT",swap:"CONTRACT",option:"OPTION",investment:"INVESTMENT",unified:"UNIFIED",funding:"FUND",fund:"FUND",contract:"CONTRACT"},accountsById:{SPOT:"spot",MARGIN:"spot",CONTRACT:"contract",OPTION:"option",INVESTMENT:"investment",UNIFIED:"unified",FUND:"fund"},networks:{ERC20:"ETH",TRC20:"TRX",BEP20:"BSC",OMNI:"OMNI",SPL:"SOL"},networksById:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20",OMNI:"OMNI",SPL:"SOL"},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},intervals:{"5m":"5min","15m":"15min","30m":"30min","1h":"1h","4h":"4h","1d":"1d"}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:75e-5,maker:1e-4},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}}})}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}enableDemoTrading(e){if(this.options.sandboxMode)throw new a.NotSupported(this.id+" demo trading does not support in sandbox environment");if(e)this.urls.apiBackupDemoTrading=this.urls.api,this.urls.api=this.urls.demotrading;else if("apiBackupDemoTrading"in this.urls){this.urls.api=this.urls.apiBackupDemoTrading;const e=this.omit(this.urls,"apiBackupDemoTrading");this.urls=e}this.options.enableDemoTrading=e}nonce(){return this.milliseconds()-this.options.timeDifference}addPaginationCursorToResult(e){const t=this.safeDict(e,"result",{}),s=this.safeValueN(t,["list","rows","data","dataList"],[]),i=this.safeString2(t,"nextPageCursor","cursor"),r=s.length;if(void 0!==i&&r>0){const e=s[0];e.nextPageCursor=i,s[0]=e}return s}async isUnifiedEnabled(e={}){const t=this.safeBool(this.options,"enableUnifiedMargin"),s=this.safeBool(this.options,"enableUnifiedAccount");if(void 0===t||void 0===s){if(this.options.enableDemoTrading)return this.options.enableUnifiedMargin=!1,this.options.enableUnifiedAccount=!0,[this.options.enableUnifiedMargin,this.options.enableUnifiedAccount];const t=await this.privateGetV5UserQueryApi(e),s=this.safeDict(t,"result",{});this.options.enableUnifiedMargin=1===this.safeInteger(s,"unified"),this.options.enableUnifiedAccount=1===this.safeInteger(s,"uta")}return[this.options.enableUnifiedMargin,this.options.enableUnifiedAccount]}async upgradeUnifiedTradeAccount(e={}){return await this.privatePostV5AccountUpgradeToUta(e)}createExpiredOptionMarket(e){const t="USD",s="USDC",i=e.split("-"),r=e.split("/");let a,o;e.indexOf("/")>-1?(a=this.safeString(r,0),o=this.safeString(i,1)):(a=this.safeString(i,0),o=this.convertMarketIdExpireDate(this.safeString(i,1)));const n=this.safeString(i,2),d=this.safeString(i,3),h=this.convertExpireDate(o),c=this.parse8601(h);let l,u;return"BTC"===a?(l=this.parseNumber("0.01"),u=this.parseNumber("5")):"ETH"===a?(l=this.parseNumber("0.1"),u=this.parseNumber("0.1")):"SOL"===a&&(l=this.parseNumber("1"),u=this.parseNumber("0.01")),{id:a+"-"+this.convertExpireDateToMarketIdDate(o)+"-"+n+"-"+d,symbol:a+"/"+t+":"+s+"-"+o+"-"+n+"-"+d,base:a,quote:t,settle:s,baseId:a,quoteId:t,settleId:s,active:!1,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:this.parseNumber("1"),expiry:c,expiryDatetime:h,optionType:"C"===d?"call":"put",strike:this.parseNumber(n),precision:{amount:l,price:u},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.indexOf("-C")>-1||e.indexOf("-P")>-1)&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}getBybitType(e,t,s={}){let i,r;return[i,s]=this.handleMarketTypeAndParams(e,t,s),[r,s]=this.handleSubTypeAndParams(e,t,s),"option"===i||"spot"===i?[i,s]:[r,s]}getAmount(e,t){const s=void 0===this.market(e).precision.amount,i=this.numberToString(t);return s||"0"===i?i:this.amountToPrecision(e,t)}getPrice(e,t){return void 0===this.market(e).precision.price?t:this.priceToPrecision(e,t)}getCost(e,t){return void 0===this.market(e).precision.price?t:this.costToPrecision(e,t)}async fetchTime(e={}){const t=await this.publicGetV5MarketTime(e);return this.safeInteger(t,"time")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;if(this.options.enableDemoTrading)return;const t=await this.privateGetV5AssetCoinQueryInfo(e),s=this.safeDict(t,"result",{}),i=this.safeList(s,"rows",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"coin"),a=this.safeCurrencyCode(s),n=this.safeString(t,"name"),d=this.safeList(t,"chains",[]),h={};let c,l,u,p,f=!1,m=!1;for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"chain"),i=this.networkIdToCode(s),r=this.parseNumber(this.parsePrecision(this.safeString(t,"minAccuracy")));c=void 0===c?r:Math.min(c,r);const a=1===this.safeInteger(t,"chainDeposit");f=a||f;const n=1===this.safeInteger(t,"chainWithdraw");m=n||m;const g=this.safeString(t,"withdrawFee");void 0!==g&&(l=void 0===l?g:o.Y.stringMin(g,l));const v=this.safeString(t,"withdrawMin");void 0!==v&&(u=void 0===u?v:o.Y.stringMin(v,u));const y=this.safeString(t,"depositMin");void 0!==y&&(p=void 0===p?y:o.Y.stringMin(y,p)),h[i]={info:t,id:s,network:i,active:a&&n,deposit:a,withdraw:n,fee:this.parseNumber(g),precision:r,limits:{withdraw:{min:this.parseNumber(v),max:void 0},deposit:{min:this.parseNumber(y),max:void 0}}}}r[a]={info:t,code:a,id:s,name:n,active:f&&m,deposit:f,withdraw:m,fee:this.parseNumber(l),precision:c,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(u),max:void 0},deposit:{min:this.parseNumber(p),max:void 0}},networks:h}}return r}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();const t=[],s=this.safeList(this.options,"fetchMarkets",["spot","linear","inverse"]);for(let i=0;i<s.length;i++){const r=s[i];if("spot"===r)t.push(this.fetchSpotMarkets(e));else if("linear"===r)t.push(this.fetchFutureMarkets({category:"linear"}));else if("inverse"===r)t.push(this.fetchFutureMarkets({category:"inverse"}));else{if("option"!==r)throw new a.ExchangeError(this.id+' fetchMarkets() this.options fetchMarkets "'+r+'" is not a supported market type');t.push(this.fetchOptionMarkets({baseCoin:"BTC"})),t.push(this.fetchOptionMarkets({baseCoin:"ETH"})),t.push(this.fetchOptionMarkets({baseCoin:"SOL"}))}}const i=await Promise.all(t),r=this.safeList(i,0,[]),o=this.safeList(i,1,[]),n=this.safeList(i,2,[]),d=this.safeList(i,3,[]),h=this.safeList(i,4,[]),c=this.safeList(i,5,[]),l=this.arrayConcat(o,n);let u=this.arrayConcat(d,h);u=this.arrayConcat(u,c);const p=this.arrayConcat(l,u);return this.arrayConcat(r,p)}async fetchSpotMarkets(e){const t={category:"spot"};let s;s=this.safeBool(this.options,"usePrivateInstrumentsInfo",!1)?await this.privateGetV5MarketInstrumentsInfo(this.extend(t,e)):await this.publicGetV5MarketInstrumentsInfo(this.extend(t,e));const i=this.safeDict(s,"result",{}),r=this.safeList(i,"list",[]),a=[],o=this.parseNumber("0.001"),n=this.parseNumber("0.001");for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"symbol"),i=this.safeString(t,"baseCoin"),d=this.safeString(t,"quoteCoin"),h=this.safeCurrencyCode(i),c=this.safeCurrencyCode(d),l=h+"/"+c,u="Trading"===this.safeString(t,"status"),p=this.safeDict(t,"lotSizeFilter"),f=this.safeDict(t,"priceFilter"),m=this.safeNumber(p,"quotePrecision"),g="none"!==this.safeString(t,"marginTrading","none");a.push(this.safeMarketStructure({id:s,symbol:l,base:h,quote:c,settle:void 0,baseId:i,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:g,swap:!1,future:!1,option:!1,active:u,contract:!1,linear:void 0,inverse:void 0,taker:o,maker:n,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(p,"basePrecision"),price:this.safeNumber(f,"tickSize",m)},limits:{leverage:{min:this.parseNumber("1"),max:void 0},amount:{min:this.safeNumber(p,"minOrderQty"),max:this.safeNumber(p,"maxOrderQty")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(p,"minOrderAmt"),max:this.safeNumber(p,"maxOrderAmt")}},created:void 0,info:t}))}return a}async fetchFutureMarkets(e){(e=this.extend(e)).limit=1e3;const t=this.safeBool(this.options,"usePrivateInstrumentsInfo",!1);let s;s=t?await this.privateGetV5MarketInstrumentsInfo(e):await this.publicGetV5MarketInstrumentsInfo(e);const i=this.safeDict(s,"result",{});let r=this.safeList(i,"list",[]),a=this.safeString(i,"nextPageCursor");if(void 0!==a)for(;void 0!==a;){let s;e.cursor=a,s=t?await this.privateGetV5MarketInstrumentsInfo(e):await this.publicGetV5MarketInstrumentsInfo(e);const i=this.safeDict(s,"result",{}),o=this.safeList(i,"list",[]);if(0===o.length)break;r=this.arrayConcat(o,r),a=this.safeString(i,"nextPageCursor")}const o=[];let n=this.safeString(i,"category");for(let e=0;e<r.length;e++){const t=r[e];void 0===n&&(n=this.safeString(t,"category"));const s="linear"===n,i="inverse"===n,a=this.safeString(t,"contractType"),d="InverseFutures"===a,h="LinearFutures"===a,c="LinearPerpetual"===a,l="InversePerpetual"===a,u=this.safeString(t,"symbol"),p=this.safeString(t,"baseCoin"),f=this.safeString(t,"quoteCoin"),m=s?f:p,g=this.safeString(t,"settleCoin",m),v=this.safeCurrencyCode(p),y=this.safeCurrencyCode(f);let w;w=c&&"USD"===g?"USDC":this.safeCurrencyCode(g);let b=v+"/"+y;const S=this.safeDict(t,"lotSizeFilter",{}),k=this.safeDict(t,"priceFilter",{}),O=this.safeDict(t,"leverageFilter",{}),T=this.safeString(t,"status"),P=c||l,I=d||h;let x,A;P?x="swap":I&&(x="future"),P||(A=this.omitZero(this.safeString(t,"deliveryTime")),void 0!==A&&(A=parseInt(A)));const M=this.iso8601(A);b=b+":"+w,void 0!==A&&(b=b+"-"+this.yymmdd(A));const C=i?this.safeNumber2(S,"minTradingQty","minOrderQty"):this.parseNumber("1");o.push(this.safeMarketStructure({id:u,symbol:b,base:v,quote:y,settle:w,baseId:p,quoteId:f,settleId:g,type:x,spot:!1,margin:void 0,swap:P,future:I,option:!1,active:"Trading"===T,contract:!0,linear:s,inverse:i,taker:this.safeNumber(t,"takerFee",this.parseNumber("0.0006")),maker:this.safeNumber(t,"makerFee",this.parseNumber("0.0001")),contractSize:C,expiry:A,expiryDatetime:M,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(S,"qtyStep"),price:this.safeNumber(k,"tickSize")},limits:{leverage:{min:this.safeNumber(O,"minLeverage"),max:this.safeNumber(O,"maxLeverage")},amount:{min:this.safeNumber2(S,"minTradingQty","minOrderQty"),max:this.safeNumber2(S,"maxTradingQty","maxOrderQty")},price:{min:this.safeNumber(k,"minPrice"),max:this.safeNumber(k,"maxPrice")},cost:{min:void 0,max:void 0}},created:this.safeInteger(t,"launchTime"),info:t}))}return o}async fetchOptionMarkets(e){const t={category:"option"},s=this.safeBool(this.options,"usePrivateInstrumentsInfo",!1);let i;i=s?await this.privateGetV5MarketInstrumentsInfo(this.extend(t,e)):await this.publicGetV5MarketInstrumentsInfo(this.extend(t,e));const r=this.safeDict(i,"result",{});let a=this.safeList(r,"list",[]);if(this.options.loadAllOptions){t.limit=1e3;let i=this.safeString(r,"nextPageCursor");if(void 0!==i)for(;void 0!==i;){let r;t.cursor=i,r=s?await this.privateGetV5MarketInstrumentsInfo(this.extend(t,e)):await this.publicGetV5MarketInstrumentsInfo(this.extend(t,e));const o=this.safeDict(r,"result",{}),n=this.safeList(o,"list",[]);if(0===n.length)break;a=this.arrayConcat(n,a),i=this.safeString(o,"nextPageCursor")}}const o=[];for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"symbol"),i=this.safeString(t,"baseCoin"),r=this.safeString(t,"quoteCoin"),n=this.safeString(t,"settleCoin"),d=this.safeCurrencyCode(i),h=this.safeCurrencyCode(r),c=this.safeCurrencyCode(n),l=this.safeDict(t,"lotSizeFilter",{}),u=this.safeDict(t,"priceFilter",{}),p=this.safeString(t,"status"),f=this.safeInteger(t,"deliveryTime"),m=s.split("-"),g=this.safeString(m,2),v=this.safeString(m,3),y="Trading"===p;(y||this.options.loadAllOptions||this.options.loadExpiredOptions)&&o.push(this.safeMarketStructure({id:s,symbol:d+"/"+h+":"+c+"-"+this.yymmdd(f)+"-"+g+"-"+v,base:d,quote:h,settle:c,baseId:i,quoteId:r,settleId:n,type:"option",spot:!1,margin:!1,swap:!1,future:!1,option:!0,active:y,contract:!0,linear:void 0,inverse:void 0,taker:this.safeNumber(t,"takerFee",this.parseNumber("0.0006")),maker:this.safeNumber(t,"makerFee",this.parseNumber("0.0001")),contractSize:this.parseNumber("1"),expiry:f,expiryDatetime:this.iso8601(f),strike:this.parseNumber(g),optionType:this.safeStringLower(t,"optionsType"),precision:{amount:this.safeNumber(l,"qtyStep"),price:this.safeNumber(u,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(l,"minOrderQty"),max:this.safeNumber(l,"maxOrderQty")},price:{min:this.safeNumber(u,"minPrice"),max:this.safeNumber(u,"maxPrice")},cost:{min:void 0,max:void 0}},created:this.safeInteger(t,"launchTime"),info:t}))}return o}parseTicker(e,t=void 0){const s=void 0===this.safeString(e,"openInterestValue"),i=this.safeInteger(e,"time"),r=this.safeString(e,"symbol"),a=s?"spot":"contract";t=this.safeMarket(r,t,void 0,a);const n=this.safeSymbol(r,t,void 0,a),d=this.safeString(e,"lastPrice"),h=this.safeString(e,"prevPrice24h");let c=this.safeString(e,"price24hPcnt");c=o.Y.stringMul(c,"100");const l=this.safeString(e,"turnover24h"),u=this.safeString(e,"volume24h"),p=this.safeString(e,"bid1Price"),f=this.safeString(e,"ask1Price"),m=this.safeString(e,"highPrice24h"),g=this.safeString(e,"lowPrice24h");return this.safeTicker({symbol:n,timestamp:i,datetime:this.iso8601(i),high:m,low:g,bid:p,bidVolume:this.safeString2(e,"bidSize","bid1Size"),ask:f,askVolume:this.safeString2(e,"askSize","ask1Size"),vwap:void 0,open:h,close:d,last:d,previousClose:void 0,change:void 0,percentage:c,average:void 0,baseVolume:u,quoteVolume:l,info:e},t)}async fetchTicker(e,t={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchTicker() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};s.spot?i.category="spot":s.option?i.category="option":s.linear?i.category="linear":s.inverse&&(i.category="inverse");const r=await this.publicGetV5MarketTickers(this.extend(i,t)),o=this.safeDict(r,"result",{}),n=this.safeList(o,"list",[]),d=this.safeDict(n,0);return this.parseTicker(d,s)}async fetchTickers(e=void 0,t={}){let s,i;if(await this.loadMarkets(),void 0!==e){i=[];const r=this.handleMarketTypeAndParams("fetchTickers",void 0,t)[0];let o;for(let t=0;t<e.length;t++){const n=e[t];if(s=-1===n.indexOf("/")?this.safeMarket(n,void 0,void 0,r):this.market(n),void 0===o)o=s.type;else if(s.type!==o)throw new a.BadRequest(this.id+" fetchTickers can only accept a list of symbols of the same type");i.push(s.symbol)}}const r={};let o;[o,t]=this.handleMarketTypeAndParams("fetchTickers",s,t);const n=this.safeString(t,"subType");let d;[d,t]=this.handleSubTypeAndParams("fetchTickers",s,t,"linear"),"spot"===o&&void 0===n?r.category="spot":"swap"===o||"future"===o||void 0!==d?r.category=d:"option"===o&&(r.category="option");const h=await this.publicGetV5MarketTickers(this.extend(r,t)),c=this.safeDict(h,"result",{}),l=this.safeList(c,"list",[]);return this.parseTickers(l,i)}parseOHLCV(e,t=void 0){const s=t.inverse?6:5;return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,s)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchOHLCV() requires a symbol argument");await this.loadMarkets();let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e3);const n=this.market(e);let d,h={symbol:n.id};if(void 0===i&&(i=200),void 0!==s&&(h.start=s),void 0!==i&&(h.limit=i),[h,r]=this.handleUntilOption("end",h,r),h.interval=this.safeString(this.timeframes,t,t),n.spot)h.category="spot",d=await this.publicGetV5MarketKline(this.extend(h,r));else{const e=this.safeString(r,"price");if(r=this.omit(r,"price"),n.linear)h.category="linear";else{if(!n.inverse)throw new a.NotSupported(this.id+" fetchOHLCV() is not supported for option markets");h.category="inverse"}d="mark"===e?await this.publicGetV5MarketMarkPriceKline(this.extend(h,r)):"index"===e?await this.publicGetV5MarketIndexPriceKline(this.extend(h,r)):"premiumIndex"===e?await this.publicGetV5MarketPremiumIndexPriceKline(this.extend(h,r)):await this.publicGetV5MarketKline(this.extend(h,r))}const c=this.safeDict(d,"result",{}),l=this.safeList(c,"list",[]);return this.parseOHLCVs(l,n,t,s,i)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"timestamp");e=this.omit(e,"timestamp");const i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t,void 0,"swap"),a=this.safeNumber(e,"fundingRate"),o=this.safeInteger(e,"nextFundingTime");return{info:e,symbol:r,markPrice:this.safeNumber(e,"markPrice"),indexPrice:this.safeNumber(e,"indexPrice"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:this.iso8601(s),fundingRate:a,fundingTimestamp:o,fundingDatetime:this.iso8601(o),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){let s;await this.loadMarkets();const i={};if(void 0!==e){e=this.marketSymbols(e),s=this.market(e[0]);1===e.length&&(i.symbol=s.id)}let r;if([r,t]=this.handleMarketTypeAndParams("fetchFundingRates",s,t),"swap"!==r)throw new a.NotSupported(this.id+" fetchFundingRates() does not support "+r+" markets");{let e;[e,t]=this.handleSubTypeAndParams("fetchFundingRates",s,t,"linear"),i.category=e}const o=await this.publicGetV5MarketTickers(this.extend(i,t));let n=this.safeValue(o,"result",[]);const d=this.safeInteger(o,"time");n=this.safeValue(n,"list");const h={};for(let e=0;e<n.length;e++){n[e].timestamp=d;const t=this.parseFundingRate(n[e],void 0);h[t.symbol]=t}return this.filterByArray(h,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),r)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,200);void 0===s&&(s=200);const o={limit:s},n=this.market(e);let d;if(e=n.symbol,o.symbol=n.id,[d,i]=this.getBybitType("fetchFundingRateHistory",n,i),"spot"===d||"option"===d)throw new a.NotSupported(this.id+" fetchFundingRateHistory() only support linear and inverse market");o.category=d,void 0!==t&&(o.startTime=t);const h=this.safeInteger(i,"until"),c=this.safeInteger(i,"endTime",h);if(i=this.omit(i,["endTime","until"]),void 0!==c)o.endTime=c;else if(void 0!==t){const e=288e5;o.endTime=t+s*e}const l=await this.publicGetV5MarketFundingHistory(this.extend(o,i)),u=[],p=this.safeDict(l,"result"),f=this.safeList(p,"list");for(let e=0;e<f.length;e++){const t=f[e],s=this.safeInteger(t,"fundingRateTimestamp");u.push({info:t,symbol:this.safeSymbol(this.safeString(t,"symbol"),void 0,void 0,"swap"),fundingRate:this.safeNumber(t,"fundingRate"),timestamp:s,datetime:this.iso8601(s)})}const m=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(m,e,t,s)}parseTrade(e,t=void 0){const s=this.safeStringN(e,["execId","id","tradeId"]),i=this.safeString(e,"symbol");let r="createType"in e?"contract":"spot";void 0!==t&&(r=t.type);const a=this.safeString(e,"category");void 0!==a&&"spot"===a&&(r="spot");const n=(t=this.safeMarket(i,t,void 0,r)).symbol,d=this.safeStringN(e,["execQty","orderQty","size"]),h=this.safeStringN(e,["execPrice","orderPrice","price"]),c=this.safeString(e,"execValue"),l=this.safeIntegerN(e,["time","execTime","tradeTime"]);let u=this.safeStringLower(e,"side");if(void 0===u){const t=this.safeInteger(e,"isBuyer");void 0!==t&&(u=t?"buy":"sell")}const p=this.safeBool(e,"isMaker");let f;if(void 0!==p)f=p?"maker":"taker";else{let t=this.safeString(e,"lastLiquidityInd");"UNKNOWN"===t&&(t=void 0),void 0!==t&&(f="TAKER"===t||"MAKER"===t?t.toLowerCase():"AddedLiquidity"===t?"maker":"taker")}let m=this.safeStringLower(e,"orderType");"unknown"===m&&(m=void 0);const g=this.safeString(e,"execFee");let v;if(void 0!==g){const s=this.safeString(e,"feeRate");let i;i=t.spot?o.Y.stringGt(g,"0")?"buy"===u?t.base:t.quote:"buy"===u?t.quote:t.base:t.inverse?t.base:t.settle,v={cost:g,currency:i,rate:s}}return this.safeTrade({id:s,info:e,timestamp:l,datetime:this.iso8601(l),symbol:n,order:this.safeString(e,"orderId"),type:m,side:u,takerOrMaker:f,price:h,amount:d,cost:c,fee:v},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};let n;void 0!==s&&(o.limit=s),[n,i]=this.getBybitType("fetchTrades",r,i),o.category=n;const d=await this.publicGetV5MarketRecentTrade(this.extend(o,i)),h=this.safeDict(d,"result",{}),c=this.safeList(h,"list",[]);return this.parseTrades(c,r,t,s)}async fetchOrderBook(e,t=void 0,s={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchOrderBook() requires a symbol argument");await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let o=25;i.spot?(o=50,r.category="spot"):i.option?r.category="option":i.linear?r.category="linear":i.inverse&&(r.category="inverse"),r.limit=void 0!==t?t:o;const n=await this.publicGetV5MarketOrderbook(this.extend(r,s)),d=this.safeDict(n,"result",{}),h=this.safeInteger(d,"ts");return this.parseOrderBook(d,e,h,"b","a")}parseBalance(e){const t=this.safeInteger(e,"time"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeDict(e,"result",{}),r=this.safeValueN(i,["loanAccountList","list","balance"]);if(void 0===r){const e="USDC",t=this.account();t.free=this.safeString(i,"availableBalance"),t.total=this.safeString(i,"walletBalance"),s[e]=t}else for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"accountType");if("UNIFIED"===i||"CONTRACT"===i||"SPOT"===i){const e=this.safeList(t,"coin");for(let t=0;t<e.length;t++){const i=this.account(),r=e[t],a=this.safeString(r,"borrowAmount"),n=this.safeString(r,"accruedInterest");void 0!==a&&void 0!==n&&(i.debt=o.Y.stringAdd(a,n)),i.total=this.safeString(r,"walletBalance"),i.free=this.safeString2(r,"availableToWithdraw","free");const d=this.safeString(r,"coin");s[this.safeCurrencyCode(d)]=i}}else{const e=this.account(),i=this.safeString(t,"loan"),r=this.safeString(t,"interest");void 0!==i&&void 0!==r&&(e.debt=o.Y.stringAdd(i,r)),e.total=this.safeString2(t,"total","walletBalance"),e.free=this.safeStringN(t,["free","availableBalanceWithoutConvert","availableBalance","transferBalance"]),e.used=this.safeString(t,"locked");const a=this.safeStringN(t,["tokenId","coin","currencyCoin"]);s[this.safeCurrencyCode(a)]=e}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t={},[s,i]=await this.isUnifiedEnabled(),r=s||i;let a,o;[a,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[o,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e),"swap"!==a&&"future"!==a||(a=o);const n=void 0!==a?a.toLowerCase():void 0,d="spot"===a,h="linear"===a,c="inverse"===a,l="fund"===n||"funding"===n;r?a=c?"contract":"unified":(h||c)&&(a="contract");const u=this.safeDict(this.options,"accountsByType",{}),p=this.safeStringUpper(u,a,a);let f,m;return[f,e]=this.handleMarginModeAndParams("fetchBalance",e),d&&void 0!==f?m=await this.privateGetV5SpotCrossMarginTradeAccount(this.extend(t,e)):l?(t.accountType="FUND",m=await this.privateGetV5AssetTransferQueryAccountCoinsBalance(this.extend(t,e))):(t.accountType=p,m=await this.privateGetV5AccountWalletBalance(this.extend(t,e))),this.parseBalance(m)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"open",PENDING_NEW:"open",REJECTED:"rejected",PARTIALLY_FILLED_CANCELLED:"closed",Created:"open",New:"open",Rejected:"rejected",PartiallyFilled:"open",PartiallyFilledCanceled:"closed",Filled:"closed",PendingCancel:"open",Cancelled:"canceled",Untriggered:"open",Deactivated:"canceled",Triggered:"open",Active:"open"},e,e)}parseTimeInForce(e){return this.safeString({GoodTillCancel:"GTC",ImmediateOrCancel:"IOC",FillOrKill:"FOK",PostOnly:"PO"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"code");if(void 0!==s&&"0"!==s){const t="spot"===this.safeString(e,"category")?"spot":"contract";return this.safeOrder({info:e,status:"rejected",id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"orderLinkId"),symbol:this.safeSymbol(this.safeString(e,"symbol"),void 0,void 0,t)})}const i=this.safeString(e,"symbol"),r="tpslMode"in e;let a;a=void 0!==t?t.type:r?"contract":"spot";const n=(t=this.safeMarket(i,t,void 0,a)).symbol,d=this.safeInteger2(e,"createdTime","createdAt"),h=this.safeString(e,"orderId"),c=this.safeStringLower(e,"orderType"),l=this.safeString(e,"price"),u=this.safeString(e,"qty"),p=this.safeString(e,"cumExecValue"),f=this.safeString(e,"cumExecQty"),m=this.safeString(e,"leavesQty"),g=this.safeInteger2(e,"updatedTime","updatedAt"),v=this.safeString(e,"orderStatus"),y=this.parseOrderStatus(v),w=this.safeStringLower(e,"side");let b;const S=this.safeString(e,"cumExecFee");if(void 0!==S){let e;e=t.spot?o.Y.stringGt(S,"0")?"buy"===w?t.base:t.quote:"buy"===w?t.quote:t.base:t.inverse?t.base:t.settle,b={cost:this.parseNumber(S),currency:e}}let k=this.safeString(e,"orderLinkId");void 0!==k&&k.length<1&&(k=void 0);const O=this.omitZero(this.safeString(e,"avgPrice")),T=this.safeString(e,"timeInForce"),P=this.parseTimeInForce(T),I=this.omitZero(this.safeString(e,"triggerPrice")),x=this.safeBool(e,"reduceOnly");let A=this.omitZero(this.safeString(e,"takeProfit")),M=this.omitZero(this.safeString(e,"stopLoss"));const C="1"===this.safeString(e,"triggerDirection"),E=void 0!==I&&x;return void 0===M&&E&&(C&&"buy"===w&&(M=I),C||"sell"!==w||(M=I)),void 0===A&&E&&(C&&"sell"===w&&(A=I),C||"buy"!==w||(A=I)),this.safeOrder({info:e,id:h,clientOrderId:k,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:g,lastUpdateTimestamp:g,symbol:n,type:c,timeInForce:P,postOnly:void 0,reduceOnly:this.safeBool(e,"reduceOnly"),side:w,price:l,stopPrice:I,triggerPrice:I,takeProfitPrice:A,stopLossPrice:M,amount:u,cost:p,average:O,filled:f,remaining:m,status:y,fee:b,trades:void 0},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new a.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","buy",t,1,s)}async createMarketSellOrderWithCost(e,t,s={}){await this.loadMarkets();if(!(await this.isUnifiedEnabled())[1])throw new a.NotSupported(this.id+" createMarketSellOrderWithCost() supports UTA accounts only");if(!this.market(e).spot)throw new a.NotSupported(this.id+" createMarketSellOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","sell",t,1,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),[n,d]=await this.isUnifiedEnabled(),h=n||d;if("USDC"===o.settle&&!h)return await this.createUsdcOrder(e,t,s,i,r,a);const c=void 0!==this.safeString2(a,"trailingAmount","trailingStop"),l=this.createOrderRequest(e,t,s,i,r,a,d),u=this.safeDict(this.options,"createOrder",{}),p=this.safeString(u,"method","privatePostV5OrderCreate");let f;f=c||"privatePostV5PositionTradingStop"===p?await this.privatePostV5PositionTradingStop(l):await this.privatePostV5OrderCreate(l);const m=this.safeDict(f,"result",{});return this.parseOrder(m,o)}createOrderRequest(e,t,s,i,r=void 0,n={},d=!0){const h=this.market(e);e=h.symbol;const c=t.toLowerCase();if(void 0===r&&"limit"===c)throw new a.ArgumentsRequired(this.id+" createOrder requires a price argument for limit orders");let l;[l,n]=this.handleOptionAndParams(n,"createOrder","method","privatePostV5OrderCreate");const u={symbol:h.id};let p=this.safeValue2(n,"triggerPrice","stopPrice");const f=this.safeValue(n,"stopLossPrice"),m=this.safeValue(n,"takeProfitPrice"),g=this.safeValue(n,"stopLoss"),v=this.safeValue(n,"takeProfit"),y=this.safeString2(n,"trailingTriggerPrice","activePrice",this.numberToString(r)),w=this.safeString2(n,"trailingAmount","trailingStop"),b=void 0!==w,S=void 0!==p,k=void 0!==f,O=void 0!==m,T=void 0!==g,P=void 0!==v,I="market"===c,x="limit"===c,A="buy"===s,M="privatePostV5PositionTradingStop"===l,C=this.getAmount(e,i),E=void 0!==r?this.getPrice(e,this.numberToString(r)):void 0;if(b||M){if(T||P||S||h.spot)throw new a.InvalidOrder(this.id+" the API endpoint used only supports contract trailingAmount, stopLossPrice and takeProfitPrice orders");(k||O)&&(k?(u.stopLoss=this.getPrice(e,f),x&&(u.tpslMode="Partial",u.slOrderType="Limit",u.slLimitPrice=E,u.slSize=C)):O&&(u.takeProfit=this.getPrice(e,m),x&&(u.tpslMode="Partial",u.tpOrderType="Limit",u.tpLimitPrice=E,u.tpSize=C)))}else{u.side=this.capitalize(s),u.orderType=this.capitalize(c);const e=this.safeStringLower(n,"timeInForce");let t;[t,n]=this.handlePostOnly(I,"postonly"===e,n),t?u.timeInForce="PostOnly":"gtc"===e?u.timeInForce="GTC":"fok"===e?u.timeInForce="FOK":"ioc"===e&&(u.timeInForce="IOC"),h.spot&&(void 0!==p?u.orderFilter="StopOrder":(void 0!==f||void 0!==m||T||P)&&(u.orderFilter="tpslOrder"));const i=this.safeString(n,"clientOrderId");void 0!==i?u.orderLinkId=i:h.option&&(u.orderLinkId=this.uuid16()),x&&(u.price=E)}h.spot?u.category="spot":h.linear?u.category="linear":h.inverse?u.category="inverse":h.option&&(u.category="option");const _=this.safeString(n,"cost");n=this.omit(n,"cost");const B="market"===c&&"buy"===s&&(void 0!==r||void 0!==_);if(h.spot&&"market"===t&&d&&!B)if(void 0!==_||void 0!==r){let t;if(u.marketUnit="quoteCoin",void 0!==_)t=_;else{t=o.Y.stringMul(C,E)}u.qty=this.getCost(e,t)}else u.marketUnit="baseCoin",u.qty=C;else if(h.spot&&"market"===t&&"buy"===s){let t=!0;if([t,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0),t){if(void 0===r&&void 0===_)throw new a.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const t=o.Y.stringMul(C,E),s=void 0!==_?_:t;u.qty=this.getCost(e,s)}}else u.qty=this.getCost(e,this.numberToString(i))}else b||M||(u.qty=C);if(b)void 0!==y&&(u.activePrice=this.getPrice(e,y)),u.trailingStop=w;else if(S&&!M){const t=this.safeString(n,"triggerDirection");if(n=this.omit(n,["triggerPrice","stopPrice","triggerDirection"]),h.spot){if(void 0!==t)throw new a.NotSupported(this.id+" createOrder() : trigger order does not support triggerDirection for spot markets yet")}else{if(void 0===t)throw new a.ArgumentsRequired(this.id+' stop/trigger orders require a triggerDirection parameter, either "above" or "below" to determine the direction of the trigger.');const e="above"===t||"1"===t;u.triggerDirection=e?1:2}u.triggerPrice=this.getPrice(e,p)}else!k&&!O||M||(u.triggerDirection=A?k?1:2:k?2:1,p=k?f:m,u.triggerPrice=this.getPrice(e,p),u.reduceOnly=!0);if((T||P)&&!M){if(T){const t=this.safeValue2(g,"triggerPrice","stopPrice",g);u.stopLoss=this.getPrice(e,t);const s=this.safeValue(g,"price");void 0!==s&&(u.tpslMode="Partial",u.slOrderType="Limit",u.slLimitPrice=this.getPrice(e,s))}if(P){const t=this.safeValue2(v,"triggerPrice","stopPrice",v);u.takeProfit=this.getPrice(e,t);const s=this.safeValue(v,"price");void 0!==s&&(u.tpslMode="Partial",u.tpOrderType="Limit",u.tpLimitPrice=this.getPrice(e,s))}}return n=this.omit(n,["stopPrice","timeInForce","stopLossPrice","takeProfitPrice","postOnly","clientOrderId","triggerPrice","stopLoss","takeProfit","trailingAmount","trailingTriggerPrice"]),this.extend(u,n)}async createOrders(e,t={}){await this.loadMarkets();const s=(await this.isUnifiedEnabled())[1],i=[],r=[];for(let t=0;t<e.length;t++){const a=e[t],o=this.safeString(a,"symbol");r.push(o);const n=this.safeString(a,"type"),d=this.safeString(a,"side"),h=this.safeValue(a,"amount"),c=this.safeValue(a,"price"),l=this.safeValue(a,"params",{}),u=this.createOrderRequest(o,n,d,h,c,l,s);i.push(u)}const o=this.marketSymbols(r,void 0,!1,!0,!0),n=this.market(o[0]);let d;if([d,t]=this.getBybitType("createOrders",n,t),"inverse"===d)throw new a.NotSupported(this.id+" createOrders does not allow inverse orders");const h={category:d,request:i},c=await this.privatePostV5OrderCreateBatch(this.extend(h,t)),l=this.safeDict(c,"result",{}),u=this.safeList(l,"list",[]),p=this.safeDict(c,"retExtInfo",{}),f=this.safeList(p,"list",[]);for(let e=0;e<f.length;e++){const t=f[e];0!==this.safeInteger(t,"code")&&(u[e]=this.extend(u[e],t))}return this.parseOrders(u)}async createUsdcOrder(e,t,s,i,r=void 0,n={}){await this.loadMarkets();const d=this.market(e);if("market"===t)throw new a.NotSupported(this.id+" createOrder does not allow market orders for "+e+" markets");const h=t.toLowerCase();if(void 0===r&&"limit"===h)throw new a.ArgumentsRequired(this.id+" createOrder requires a price argument for limit orders");const c={symbol:d.id,side:this.capitalize(s),orderType:this.capitalize(h),timeInForce:"GoodTillCancel",orderQty:this.getAmount(e,i)},l="market"===h;void 0!==("limit"===h)&&(c.orderPrice=this.getPrice(e,this.numberToString(r)));const u=this.safeString(n,"time_in_force"),p=this.safeStringLower(n,"timeInForce");if(this.isPostOnly(l,"PostOnly"===u,n)?c.time_in_force="PostOnly":"gtc"===p?c.time_in_force="GoodTillCancel":"fok"===p?c.time_in_force="FillOrKill":"ioc"===p&&(c.time_in_force="ImmediateOrCancel"),d.swap){const t=this.safeValue2(n,"stopPrice","triggerPrice"),s=this.safeValue(n,"stopLossPrice",t),i=this.safeValue(n,"takeProfitPrice"),r=this.safeValue(n,"stopLoss"),a=this.safeValue(n,"takeProfit"),h=void 0!==s,l=void 0!==r,u=void 0!==a;if(h||void 0!==i){c.orderFilter="StopOrder",c.trigger_by="LastPrice";const t=h?s:i,r=this.getPrice(e,t);c.triggerPrice=r;const a=this.numberToString(d.precision.price);c.basePrice=h?o.Y.stringSub(r,a):o.Y.stringAdd(r,a)}else if(l||u){if(l){const t=this.safeValue2(r,"triggerPrice","stopPrice",r);c.stopLoss=this.getPrice(e,t)}if(u){const t=this.safeValue2(a,"triggerPrice","stopPrice",a);c.takeProfit=this.getPrice(e,t)}}else c.orderFilter="Order"}const f=this.safeString(n,"clientOrderId");let m;void 0!==f?c.orderLinkId=f:d.option&&(c.orderLinkId=this.uuid16()),n=this.omit(n,["stopPrice","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","postOnly","clientOrderId"]),m=d.option?await this.privatePostOptionUsdcOpenapiPrivateV1PlaceOrder(this.extend(c,n)):await this.privatePostPerpetualUsdcOpenapiPrivateV1PlaceOrder(this.extend(c,n));const g=this.safeDict(m,"result",{});return this.parseOrder(g,d)}async editUsdcOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={symbol:n.id,orderId:e};let h;if(void 0!==r&&(d.orderQty=this.getAmount(t,r)),void 0!==a&&(d.orderPrice=this.getPrice(t,a)),n.option)h=await this.privatePostOptionUsdcOpenapiPrivateV1ReplaceOrder(this.extend(d,o));else{const e=this.safeBool2(o,"stop","trigger",!1),s=this.safeValue2(o,"stopPrice","triggerPrice"),i=this.safeValue(o,"stopLossPrice"),r=void 0!==i,a=this.safeValue(o,"takeProfitPrice");(r||void 0!==a||e)&&(d.orderFilter=e?"StopOrder":"Order",void 0!==s&&(d.triggerPrice=this.getPrice(t,s)),void 0!==i&&(d.stopLoss=this.getPrice(t,i)),void 0!==a&&(d.takeProfit=this.getPrice(t,a))),o=this.omit(o,["stop","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),h=await this.privatePostPerpetualUsdcOpenapiPrivateV1ReplaceOrder(this.extend(d,o))}const c=this.safeDict(h,"result",{});return this.parseOrder(c,n)}editOrderRequest(e,t,s,i,r=void 0,a=void 0,o={}){const n=this.market(t),d={symbol:n.id,orderId:e};n.spot?d.category="spot":n.linear?d.category="linear":n.inverse?d.category="inverse":n.option&&(d.category="option"),void 0!==r&&(d.qty=this.getAmount(t,r)),void 0!==a&&(d.price=this.getPrice(t,this.numberToString(a)));let h=this.safeString2(o,"triggerPrice","stopPrice");const c=this.safeString(o,"stopLossPrice"),l=this.safeString(o,"takeProfitPrice"),u=this.safeValue(o,"stopLoss"),p=this.safeValue(o,"takeProfit"),f=void 0!==c,m=void 0!==u,g=void 0!==p;if((f||void 0!==l)&&(h=f?c:l),void 0!==h){const e="0"===h?h:this.getPrice(t,h);d.triggerPrice=e;const s=this.safeString(o,"triggerBy","LastPrice");d.triggerBy=s}if(m||g){if(m){const e=this.safeString2(u,"triggerPrice","stopPrice",u),s="0"===e?e:this.getPrice(t,e);d.stopLoss=s;const i=this.safeString(o,"slTriggerBy","LastPrice");d.slTriggerBy=i}if(g){const e=this.safeString2(p,"triggerPrice","stopPrice",p),s="0"===e?e:this.getPrice(t,e);d.takeProfit=s;const i=this.safeString(o,"tpTriggerBy","LastPrice");d.tpTriggerBy=i}}const v=this.safeString(o,"clientOrderId");return void 0!==v&&(d.orderLinkId=v),o=this.omit(o,["stopPrice","stopLossPrice","takeProfitPrice","triggerPrice","clientOrderId","stopLoss","takeProfit"]),d}async editOrder(e,t,s,i,r=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);if(void 0===t)throw new a.ArgumentsRequired(this.id+" editOrder() requires a symbol argument");const[h,c]=await this.isUnifiedEnabled(),l=h||c;if("USDC"===d.settle&&!l)return await this.editUsdcOrder(e,t,s,i,r,o,n);const u=this.editOrderRequest(e,t,s,i,r,o,n),p=await this.privatePostV5OrderAmend(this.extend(u,n)),f=this.safeDict(p,"result",{});return this.safeOrder({info:p,id:this.safeString(f,"orderId")})}async cancelUsdcOrder(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelUsdcOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),r={symbol:i.id},o=this.safeBool2(s,"stop","trigger",!1);let n;s=this.omit(s,["stop","trigger"]),void 0!==e&&(r.orderId=e),i.option?n=await this.privatePostOptionUsdcOpenapiPrivateV1CancelOrder(this.extend(r,s)):(r.orderFilter=o?"StopOrder":"Order",n=await this.privatePostPerpetualUsdcOpenapiPrivateV1CancelOrder(this.extend(r,s)));const d=this.safeDict(n,"result",{});return this.parseOrder(d,i)}cancelOrderRequest(e,t=void 0,s={}){const i=this.market(t),r={symbol:i.id};if(i.spot){const e=this.safeBool2(s,"stop","trigger",!1);s=this.omit(s,["stop","trigger"]),r.orderFilter=e?"StopOrder":"Order"}return void 0!==e&&(r.orderId=e),i.spot?r.category="spot":i.linear?r.category="linear":i.inverse?r.category="inverse":i.option&&(r.category="option"),this.extend(r,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[r,o]=await this.isUnifiedEnabled(),n=r||o;if("USDC"===i.settle&&!n)return await this.cancelUsdcOrder(e,t,s);const d=this.cancelOrderRequest(e,t,s),h=await this.privatePostV5OrderCancel(d),c=this.safeDict(h,"result",{});return this.parseOrder(c,i)}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!(await this.isUnifiedEnabled())[1])throw new a.NotSupported(this.id+" cancelOrders() supports UTA accounts only");let r;if([r,s]=this.getBybitType("cancelOrders",i,s),"inverse"===r)throw new a.NotSupported(this.id+" cancelOrders does not allow inverse orders");const o=[],n=this.safeList2(s,"clientOrderIds","clientOids",[]);s=this.omit(s,["clientOrderIds","clientOids"]);for(let e=0;e<n.length;e++)o.push({symbol:i.id,orderLinkId:this.safeString(n,e)});for(let t=0;t<e.length;t++)o.push({symbol:i.id,orderId:this.safeString(e,t)});const d={category:r,request:o},h=await this.privatePostV5OrderCancelBatch(this.extend(d,s)),c=this.safeDict(h,"result",{}),l=this.safeList(c,"list",[]);return this.parseOrders(l,i)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={timeWindow:this.parseToInt(e/1e3)};let i;[i,t]=this.handleMarketTypeAndParams("cancelAllOrdersAfter",void 0,t,"swap");const r=this.safeString({spot:"SPOT",swap:"DERIVATIVES",option:"OPTIONS"},i,i);s.product=r;return await this.privatePostV5OrderDisconnectedCancelAll(this.extend(s,t))}async cancelOrdersForSymbols(e,t={}){await this.loadMarkets();if(!(await this.isUnifiedEnabled())[1])throw new a.NotSupported(this.id+" cancelOrdersForSymbols() supports UTA accounts only");const s=[];let i;for(let r=0;r<e.length;r++){const o=e[r],n=this.safeString(o,"symbol"),d=this.market(n);let h;if([h,t]=this.getBybitType("cancelOrders",d,t),"inverse"===h)throw new a.NotSupported(this.id+" cancelOrdersForSymbols does not allow inverse orders");if(void 0!==i&&i!==h)throw new a.ExchangeError(this.id+" cancelOrdersForSymbols requires all orders to be of the same category (linear, spot or option))");i=h;const c=this.safeString(o,"id"),l=this.safeString(o,"clientOrderId");let u="orderId";void 0!==l&&(u="orderLinkId");const p={symbol:d.id};p[u]="orderId"===u?c:l,s.push(p)}const r={category:i,request:s},o=await this.privatePostV5OrderCancelBatch(this.extend(r,t)),n=this.safeDict(o,"result",{}),d=this.safeList(n,"list",[]);return this.parseOrders(d,void 0)}async cancelAllUsdcOrders(e=void 0,t={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" cancelAllUsdcOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;if(s.option)r=await this.privatePostOptionUsdcOpenapiPrivateV1CancelAll(this.extend(i,t));else{const e=this.safeBool2(t,"stop","trigger",!1);i.orderFilter=e?"StopOrder":"Order",t=this.omit(t,["stop","trigger"]),r=await this.privatePostPerpetualUsdcOpenapiPrivateV1CancelAll(this.extend(i,t))}const o=this.safeValue(r,"result",[]);return Array.isArray(o)?this.parseOrders(o,s):r}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const[s,i]=await this.isUnifiedEnabled(),r=s||i;let o;const n={};if(void 0!==e){o=this.market(e);if("USDC"===o.settle&&!r)return await this.cancelAllUsdcOrders(e,t);n.symbol=o.id}let d;if([d,t]=this.getBybitType("cancelAllOrders",o,t),n.category=d,"option"===d&&!r)throw new a.NotSupported(this.id+" cancelAllOrders() Normal Account not support "+d+" market");if("linear"===d||"inverse"===d){const s=this.safeString(t,"baseCoin");if(void 0===e&&void 0===s){const e=this.safeString(this.options,"defaultSettle","USDT");n.settleCoin=this.safeString(t,"settleCoin",e)}}const h=this.safeBool2(t,"stop","trigger",!1);t=this.omit(t,["stop","trigger"]),h&&(n.orderFilter="StopOrder");const c=await this.privatePostV5OrderCancelAll(this.extend(n,t)),l=this.safeDict(c,"result",{}),u=this.safeList(l,"list");return Array.isArray(u)?this.parseOrders(u,o):c}async fetchUsdcOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let o;void 0!==e&&(r=this.market(e),a.symbol=r.id),[o,i]=this.handleMarketTypeAndParams("fetchOrders",r,i),a.category="swap"===o?"PERPETUAL":"OPTION";const n=this.safeBool2(i,"stop","trigger",!1);i=this.omit(i,["stop","trigger"]),n&&(a.orderFilter="StopOrder"),void 0!==s&&(a.limit=s);const d=await this.privatePostOptionUsdcOpenapiPrivateV1QueryOrderHistory(this.extend(a,i)),h=this.safeDict(d,"result",{}),c=this.safeList(h,"dataList",[]);return this.parseOrders(c,r,t,s)}async fetchOrderClassic(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();if(this.market(t).spot)throw new a.NotSupported(this.id+" fetchOrder() is not supported for spot markets");const i={orderId:e},r=await this.fetchOrders(t,void 0,void 0,this.extend(i,s)),o=r.length;if(0===o){const t=this.safeBoolN(s,["trigger","stop"],!1)?"":'If you are trying to fetch SL/TP conditional order, you might try setting params["trigger"] = true';throw new a.OrderNotFound("Order "+e.toString()+" was not found."+t)}if(o>1)throw new a.InvalidOrder(this.id+" returned more than one order");return this.safeValue(r,0)}async fetchOrder(e,t=void 0,s={}){const i=await this.isUnifiedEnabled();if(this.safeBool(i,1))throw new a.NotSupported(this.id+" fetchOrder() is not supported after the 5/02 update for UTA accounts, please use fetchOpenOrder or fetchClosedOrder");return await this.fetchOrderClassic(e,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const r=await this.isUnifiedEnabled();if(this.safeBool(r,1))throw new a.NotSupported(this.id+" fetchOrders() is not supported after the 5/02 update for UTA accounts, please use fetchOpenOrders, fetchClosedOrders or fetchCanceledOrders");return await this.fetchOrdersClassic(e,t,s,i)}async fetchOrdersClassic(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),r)return await this.fetchPaginatedCallCursor("fetchOrders",e,t,s,i,"nextPageCursor","cursor",void 0,50);const[o,n]=await this.isUnifiedEnabled(),d=o||n,h={};let c,l,u=!1;if(void 0!==e&&(c=this.market(e),u="USDC"===c.settle,h.symbol=c.id),[l,i]=this.getBybitType("fetchOrders",c,i),("option"===l||u)&&!d)return await this.fetchUsdcOrders(e,t,s,i);if("spot"===l)throw new a.NotSupported(this.id+" fetchOrders() is not supported for spot markets");h.category=l;const p=this.safeBoolN(i,["trigger","stop"],!1);i=this.omit(i,["trigger","stop"]),p&&(h.orderFilter="StopOrder"),void 0!==s&&(h.limit=s),void 0!==t&&(h.startTime=t);const f=this.safeInteger(i,"until"),m=this.safeInteger(i,"endTime",f);i=this.omit(i,["endTime","until"]),void 0!==m&&(h.endTime=m);const g=await this.privateGetV5OrderHistory(this.extend(h,i)),v=this.addPaginationCursorToResult(g);return this.parseOrders(v,c,t,s)}async fetchClosedOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.fetchClosedOrders(t,void 0,void 0,this.extend(i,s)),o=r.length;if(0===o){const t=this.safeBoolN(s,["trigger","stop"],!1)?"":'If you are trying to fetch SL/TP conditional order, you might try setting params["trigger"] = true';throw new a.OrderNotFound("Order "+e.toString()+" was not found."+t)}if(o>1)throw new a.InvalidOrder(this.id+" returned more than one order");return this.safeValue(r,0)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.fetchOpenOrders(t,void 0,void 0,this.extend(i,s)),o=r.length;if(0===o){const t=this.safeBoolN(s,["trigger","stop"],!1)?"":'If you are trying to fetch SL/TP conditional order, you might try setting params["trigger"] = true';throw new a.OrderNotFound("Order "+e.toString()+" was not found."+t)}if(o>1)throw new a.InvalidOrder(this.id+" returned more than one order");return this.safeValue(r,0)}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchCanceledAndClosedOrders","paginate"),r)return await this.fetchPaginatedCallCursor("fetchCanceledAndClosedOrders",e,t,s,i,"nextPageCursor","cursor",void 0,50);const[a,o]=await this.isUnifiedEnabled(),n=a||o,d={};let h,c,l=!1;if(void 0!==e&&(h=this.market(e),l="USDC"===h.settle,d.symbol=h.id),[c,i]=this.getBybitType("fetchCanceledAndClosedOrders",h,i),("option"===c||l)&&!n)return await this.fetchUsdcOrders(e,t,s,i);d.category=c;const u=this.safeBoolN(i,["trigger","stop"],!1);i=this.omit(i,["trigger","stop"]),u&&(d.orderFilter="StopOrder"),void 0!==s&&(d.limit=s),void 0!==t&&(d.startTime=t);const p=this.safeInteger(i,"until"),f=this.safeInteger(i,"endTime",p);i=this.omit(i,["endTime","until"]),void 0!==f&&(d.endTime=f);const m=await this.privateGetV5OrderHistory(this.extend(d,i)),g=this.addPaginationCursorToResult(m);return this.parseOrders(g,h,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return await this.fetchCanceledAndClosedOrders(e,t,s,this.extend({orderStatus:"Filled"},i))}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return await this.fetchCanceledAndClosedOrders(e,t,s,this.extend({orderStatus:"Cancelled"},i))}async fetchUsdcOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;void 0!==e&&(a=this.market(e),r.symbol=a.id),[o,i]=this.handleMarketTypeAndParams("fetchUsdcOpenOrders",a,i),r.category="swap"===o?"perpetual":"option";const n=await this.privatePostOptionUsdcOpenapiPrivateV1QueryActiveOrders(this.extend(r,i)),d=this.safeDict(n,"result",{}),h=this.safeList(d,"dataList",[]);return this.parseOrders(h,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r)return await this.fetchPaginatedCallCursor("fetchOpenOrders",e,t,s,i,"nextPageCursor","cursor",void 0,50);const[a,o]=await this.isUnifiedEnabled(),n=a||o,d={};let h,c,l=!1;if(void 0!==e&&(h=this.market(e),l="USDC"===h.settle,d.symbol=h.id),[c,i]=this.getBybitType("fetchOpenOrders",h,i),"linear"===c||"inverse"===c){const t=this.safeString(i,"baseCoin");if(void 0===e&&void 0===t){const e=this.safeString(this.options,"defaultSettle","USDT"),t=this.safeString(i,"settleCoin",e);d.settleCoin=t,l="USDC"===t}}if(("option"===c||l)&&!n)return await this.fetchUsdcOpenOrders(e,t,s,i);d.category=c;const u=this.safeBool2(i,"stop","trigger",!1);i=this.omit(i,["stop","trigger"]),u&&(d.orderFilter="StopOrder"),void 0!==s&&(d.limit=s);const p=await this.privateGetV5OrderRealtime(this.extend(d,i)),f=this.addPaginationCursorToResult(p);return this.parseOrders(f,h,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a={},o=this.safeString2(r,"clientOrderId","orderLinkId");return void 0!==o?a.orderLinkId=o:a.orderId=e,r=this.omit(r,["clientOrderId","orderLinkId"]),await this.fetchMyTrades(t,s,i,this.extend(a,r))}async fetchMyUsdcTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e?(r=this.market(e),a.symbol=r.id,a.category=r.option?"OPTION":"PERPETUAL"):a.category="PERPETUAL";const o=await this.privatePostOptionUsdcOpenapiPrivateV1ExecutionList(this.extend(a,i)),n=this.safeDict(o,"result",{}),d=this.safeList(n,"dataList",[]);return this.parseTrades(d,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchMyTrades",e,t,s,i,"nextPageCursor","cursor",void 0,100);const[a,o]=await this.isUnifiedEnabled(),n=a||o;let d,h,c={execType:"Trade"},l=!1;if(void 0!==e&&(d=this.market(e),l="USDC"===d.settle,c.symbol=d.id),[h,i]=this.getBybitType("fetchMyTrades",d,i),("option"===h||l)&&!n)return await this.fetchMyUsdcTrades(e,t,s,i);c.category=h,void 0!==s&&(c.limit=s),void 0!==t&&(c.startTime=t),[c,i]=this.handleUntilOption("endTime",c,i);const u=await this.privateGetV5ExecutionList(this.extend(c,i)),p=this.addPaginationCursorToResult(u);return this.parseTrades(p,d,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addressDeposit"),i=this.safeString(e,"tagDeposit"),r=this.safeString(t,"code"),a=this.safeString(e,"chain");return this.checkAddress(s),{currency:r,address:s,tag:i,network:a,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let s=this.currency(e);const i={coin:s.id},r=await this.privateGetV5AssetDepositQueryAddress(this.extend(i,t)),a=this.safeDict(r,"result",{}),o=this.safeList(a,"chains",[]),n=this.safeString(a,"coin");s=this.currency(n);const d=this.parseDepositAddresses(o,[s.code],!1,{currency:s.code});return this.indexBy(d,"network")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const[s,i]=this.handleNetworkCodeAndParams(t),r=this.networkCodeToId(s),a=this.currency(e),o={coin:a.id};void 0!==r&&(o.chainType=r);const n=await this.privateGetV5AssetDepositQueryAddress(this.extend(o,i)),d=this.safeDict(n,"result",{}),h=this.safeList(d,"chains",[]),c=this.indexBy(h,"chain"),l=this.selectNetworkIdFromRawNetworks(e,s,c),u=this.safeDict(c,l,{});return this.parseDepositAddress(u,a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallCursor("fetchDeposits",e,t,s,i,"nextPageCursor","cursor",void 0,50);let a,o={};void 0!==e&&(a=this.currency(e),o.coin=a.id),void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.privateGetV5AssetDepositQueryRecord(this.extend(o,i)),d=this.addPaginationCursorToResult(n);return this.parseTransactions(d,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallCursor("fetchWithdrawals",e,t,s,i,"nextPageCursor","cursor",void 0,50);let a,o={};void 0!==e&&(a=this.currency(e),o.coin=a.id),void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.privateGetV5AssetWithdrawQueryRecord(this.extend(o,i)),d=this.addPaginationCursorToResult(n);return this.parseTransactions(d,a,t,s)}parseTransactionStatus(e){return this.safeString({0:"unknown",1:"pending",2:"processing",3:"ok",4:"fail",SecurityCheck:"pending",Pending:"pending",success:"ok",CancelByUser:"canceled",Reject:"rejected",Fail:"failed",BlockchainConfirmed:"ok"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),r=this.safeInteger2(e,"createTime","successAt"),a=this.safeInteger(e,"updateTime"),o=this.parseTransactionStatus(this.safeString(e,"status")),n=this.safeNumber2(e,"depositFee","withdrawFee"),d="depositFee"in e?"deposit":"withdrawal";let h;void 0!==n&&(h={cost:n,currency:i});const c=this.safeString(e,"toAddress");return{info:e,id:this.safeString2(e,"id","withdrawId"),txid:this.safeString(e,"txID"),timestamp:r,datetime:this.iso8601(r),network:this.networkIdToCode(this.safeString(e,"chain")),address:void 0,addressTo:c,addressFrom:void 0,tag:this.safeString(e,"tag"),tagTo:void 0,tagFrom:void 0,type:d,amount:this.safeNumber(e,"amount"),currency:i,status:o,updated:a,fee:h,internal:void 0,comment:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={},a=await this.isUnifiedEnabled();let o,n,d,h="coin";a[1]?(h="currency",void 0!==t&&(r.startTime=t)):void 0!==t&&(r.start_date=this.yyyymmdd(t)),void 0!==e&&(o=this.currency(e),r[h]=o.id),void 0!==s&&(r.limit=s),[n,i]=this.handleSubTypeAndParams("fetchLedger",void 0,i),d=a[1]?"inverse"===n?await this.privateGetV5AccountContractTransactionLog(this.extend(r,i)):await this.privateGetV5AccountTransactionLog(this.extend(r,i)):await this.privateGetV2PrivateWalletFundRecords(this.extend(r,i));const c=this.addPaginationCursorToResult(d);return this.parseLedger(c,o,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString2(e,"coin","currency"),i=this.safeCurrencyCode(s,t),r=this.safeString2(e,"amount","change"),a=this.safeString2(e,"wallet_balance","cashBalance"),n=o.Y.stringLt(r,"0")?"out":"in";let d;if(void 0!==a&&void 0!==r){const e="out"===n?r:o.Y.stringNeg(r);d=o.Y.stringAdd(a,e)}let h=this.parse8601(this.safeString(e,"exec_time"));void 0===h&&(h=this.safeInteger(e,"transactionTime"));const c=this.parseLedgerEntryType(this.safeString(e,"type")),l=this.safeString(e,"id"),u=this.safeString(e,"tx_id");return{id:l,currency:i,account:this.safeString(e,"wallet_id"),referenceAccount:void 0,referenceId:u,status:void 0,amount:this.parseNumber(o.Y.stringAbs(r)),before:this.parseNumber(d),after:this.parseNumber(a),fee:this.parseNumber(this.safeString(e,"fee")),direction:n,timestamp:h,datetime:this.iso8601(h),type:c,info:e}}parseLedgerEntryType(e){return this.safeString({Deposit:"transaction",Withdraw:"transaction",RealisedPNL:"trade",Commission:"fee",Refund:"cashback",Prize:"prize",ExchangeOrderWithdraw:"transaction",ExchangeOrderDeposit:"transaction",TRANSFER_IN:"transaction",TRANSFER_OUT:"transaction",TRADE:"trade",SETTLEMENT:"trade",DELIVERY:"trade",LIQUIDATION:"trade",BONUS:"Prize",FEE_REFUND:"cashback",INTEREST:"transaction",CURRENCY_BUY:"trade",CURRENCY_SELL:"trade"},e,e)}async withdraw(e,t,s,i=void 0,r={}){let a;[i,r]=this.handleWithdrawTagAndParams(i,r),[a,r]=this.handleOptionAndParams(r,"withdraw","accountType","SPOT"),await this.loadMarkets(),this.checkAddress(s);const o=this.currency(e),n={coin:o.id,amount:this.numberToString(t),address:s,timestamp:this.milliseconds(),accountType:a};void 0!==i&&(n.tag=i);const[d,h]=this.handleNetworkCodeAndParams(r),c=this.networkCodeToId(d);void 0!==c&&(n.chain=c.toUpperCase());const l=await this.privatePostV5AssetWithdrawCreate(this.extend(n,h)),u=this.safeDict(l,"result",{});return this.parseTransaction(u,o)}async fetchPosition(e,t={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchPosition() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:s.id},[r,o]=await this.isUnifiedEnabled(),n=r||o,d="USDC"===s.settle;let h,c;[c,t]=this.getBybitType("fetchPosition",s,t),"option"!==c&&!d||n?(i.category=c,h=await this.privateGetV5PositionList(this.extend(i,t))):(i.category="option"===c?"OPTION":"PERPETUAL",h=await this.privatePostOptionUsdcOpenapiPrivateV1QueryPosition(this.extend(i,t)));const l=this.safeDict(h,"result",{}),u=this.safeList2(l,"list","dataList",[]),p=this.safeInteger(h,"time"),f=this.safeDict(u,0,{}),m=this.parsePosition(f,s);return m.timestamp=p,m.datetime=this.iso8601(p),m}async fetchUsdcPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i,r;if(Array.isArray(e)){if(1!==e.length)throw new a.ArgumentsRequired(this.id+" fetchUsdcPositions() takes an array with exactly one symbol");const t=this.safeString(e,0);i=this.market(t),s.symbol=i.id}else void 0!==e&&(i=this.market(e),s.symbol=i.id);[r,t]=this.getBybitType("fetchUsdcPositions",i,t),s.category="option"===r?"OPTION":"PERPETUAL";const o=await this.privatePostOptionUsdcOpenapiPrivateV1QueryPosition(this.extend(s,t)),n=this.safeDict(o,"result",{}),d=this.safeList(n,"dataList",[]),h=[];for(let e=0;e<d.length;e++){let t=d[e];"data"in t&&"is_valid"in t&&(t=this.safeDict(t,"data")),h.push(this.parsePosition(t,i))}return this.filterByArrayPositions(h,"symbol",e,!1)}async fetchPositions(e=void 0,t={}){let s;if(await this.loadMarkets(),void 0!==e&&Array.isArray(e)){const t=e.length;if(t>1)throw new a.ArgumentsRequired(this.id+" fetchPositions() does not accept an array with more than one symbol");1===t&&(s=e[0]),e=this.marketSymbols(e)}else void 0!==e&&(s=e,e=[this.symbol(s)]);const[i,r]=await this.isUnifiedEnabled(),o=i||r,n={};let d,h,c=!1;if(void 0!==s&&(d=this.market(s),s=d.symbol,n.symbol=d.id,c="USDC"===d.settle),[h,t]=this.getBybitType("fetchPositions",d,t),"linear"===h||"inverse"===h){const e=this.safeString(t,"baseCoin");if("linear"===h){if(void 0===s&&void 0===e){const e=this.safeString(this.options,"defaultSettle","USDT"),s=this.safeString(t,"settleCoin",e);n.settleCoin=s,c="USDC"===s}}else void 0===s&&void 0===e&&(n.category="inverse")}if(("option"===h||c)&&!o)return await this.fetchUsdcPositions(e,t);t=this.omit(t,["type"]),n.category=h;const l=await this.privateGetV5PositionList(this.extend(n,t)),u=this.addPaginationCursorToResult(l),p=[];for(let e=0;e<u.length;e++){let t=u[e];"data"in t&&"is_valid"in t&&(t=this.safeDict(t,"data")),p.push(this.parsePosition(t))}return this.filterByArrayPositions(p,"symbol",e,!1)}parsePosition(e,t=void 0){const s=void 0!==this.safeString(e,"closedSize"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t,void 0,"contract");const r=o.Y.stringAbs(this.safeString2(e,"size","qty"));let a=this.safeString(e,"side");void 0!==a&&(a="Buy"===a?s?"short":"long":"Sell"===a?s?"long":"short":void 0);const n=this.safeString2(e,"positionValue","cumExitValue"),d=this.omitZero(this.safeString(e,"unrealisedPnl"));let h=this.safeStringN(e,["positionIM","cumEntryValue"]),c=this.safeString(e,"positionMM");const l=this.safeIntegerN(e,["createdTime","createdAt"]);let u=this.parse8601(this.safeString(e,"updated_at"));void 0===u&&(u=this.safeIntegerN(e,["updatedTime","updatedAt","updatedTime"]));const p=this.safeInteger(e,"tradeMode",0);let f;(!this.options.enableUnifiedAccount||this.options.enableUnifiedAccount&&t.inverse)&&(s||(f=1===p?"isolated":"cross"));let m=this.safeString(e,"positionBalance");const g=this.omitZero(this.safeStringN(e,["entryPrice","avgPrice","avgEntryPrice"])),v=this.omitZero(this.safeString(e,"liqPrice")),y=this.safeString(e,"leverage");if(void 0!==v)if("USDC"===t.settle){const e=o.Y.stringAbs(o.Y.stringSub(g,v));m=o.Y.stringAdd(o.Y.stringAdd(o.Y.stringMul(e,r),c),d)}else{const s=this.safeString(e,"bustPrice");if(t.linear){const e=o.Y.stringAbs(o.Y.stringSub(v,s));c=o.Y.stringMul(e,r),void 0!==g&&(h=o.Y.stringDiv(o.Y.stringMul(r,g),y))}else{const e=o.Y.stringAbs(o.Y.stringSub(s,v)),t=o.Y.stringMul(s,v);c=o.Y.stringDiv(o.Y.stringMul(r,e),t),void 0!==g&&(h=o.Y.stringDiv(r,o.Y.stringMul(g,y)))}}const w=o.Y.stringDiv(c,n),b=o.Y.stringDiv(c,m,4);return this.safePosition({info:e,id:void 0,symbol:t.symbol,timestamp:l,datetime:this.iso8601(l),lastUpdateTimestamp:u,initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(o.Y.stringDiv(h,n)),maintenanceMargin:this.parseNumber(c),maintenanceMarginPercentage:this.parseNumber(w),entryPrice:this.parseNumber(g),notional:this.parseNumber(n),leverage:this.parseNumber(y),unrealizedPnl:this.parseNumber(d),realizedPnl:this.safeNumber(e,"closedPnl"),contracts:this.parseNumber(r),contractSize:this.safeNumber(t,"contractSize"),marginRatio:this.parseNumber(b),liquidationPrice:this.parseNumber(v),markPrice:this.safeNumber(e,"markPrice"),lastPrice:this.safeNumber(e,"avgExitPrice"),collateral:this.parseNumber(m),marginMode:f,side:a,percentage:void 0,stopLossPrice:this.safeNumber2(e,"stop_loss","stopLoss"),takeProfitPrice:this.safeNumber2(e,"take_profit","takeProfit")})}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.fetchPosition(e,t);return this.parseLeverage(i,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"marginMode"),longLeverage:i,shortLeverage:i}}async setMarginMode(e,t=void 0,s={}){await this.loadMarkets();const[i,r]=await this.isUnifiedEnabled();let o,n;if(i||r){if("isolated"===e)e="ISOLATED_MARGIN";else if("cross"===e)e="REGULAR_MARGIN";else{if("portfolio"!==e)throw new a.NotSupported(this.id+" setMarginMode() marginMode must be either [isolated, cross, portfolio]");e="PORTFOLIO_MARGIN"}const t={setMarginMode:e};n=await this.privatePostV5AccountSetMarginMode(this.extend(t,s))}else{if(void 0===t)throw new a.ArgumentsRequired(this.id+" setMarginMode() requires a symbol parameter for non unified account");o=this.market(t);if("USDC"===o.settle){if("cross"===e)e="REGULAR_MARGIN";else{if("portfolio"!==e)throw new a.NotSupported(this.id+" setMarginMode() for usdc market marginMode must be either [cross, portfolio]");e="PORTFOLIO_MARGIN"}const t={setMarginMode:e};n=await this.privatePostV5AccountSetMarginMode(this.extend(t,s))}else{let t,i,r,d;if([t,s]=this.getBybitType("setPositionMode",o,s),"cross"===e)i=0;else{if("isolated"!==e)throw new a.NotSupported(this.id+" setMarginMode() with symbol marginMode must be either [isolated, cross]");i=1}const h=this.safeString(s,"leverage");if(void 0===h){if(r=this.safeString2(s,"sell_leverage","sellLeverage"),d=this.safeString2(s,"buy_leverage","buyLeverage"),void 0===r&&void 0===d)throw new a.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter or sell_leverage and buy_leverage parameters");void 0===d&&(d=r),void 0===r&&(r=d),s=this.omit(s,["buy_leverage","sell_leverage","sellLeverage","buyLeverage"])}else r=h,d=h,s=this.omit(s,"leverage");const c={category:t,symbol:o.id,tradeMode:i,buyLeverage:d,sellLeverage:r};n=await this.privatePostV5PositionSwitchIsolated(this.extend(c,s))}}return n}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[r,o]=await this.isUnifiedEnabled(),n=r||o,d="USDC"===i.settle,h=this.numberToString(e),c={symbol:i.id,buyLeverage:h,sellLeverage:h};let l;if(d&&!n)c.leverage=h,l=await this.privatePostPerpetualUsdcOpenapiPrivateV1PositionLeverageSave(this.extend(c,s));else{if(c.buyLeverage=h,c.sellLeverage=h,i.linear)c.category="linear";else{if(!i.inverse)throw new a.NotSupported(this.id+" setLeverage() only support linear and inverse market");c.category="inverse"}l=await this.privatePostV5PositionSetLeverage(this.extend(c,s))}return l}async setPositionMode(e,t=void 0,s={}){let i,r;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),r=e?3:0;const a={mode:r};if(void 0===t?a.coin="USDT":a.symbol=i.id,void 0!==t)a.category=i.linear?"linear":"inverse";else{let e;[e,s]=this.getBybitType("setPositionMode",i,s),a.category=e}s=this.omit(s,"type");return await this.privatePostV5PositionSwitchMode(this.extend(a,s))}async fetchDerivativesOpenInterestHistory(e,t="1h",s=void 0,i=void 0,r={}){await this.loadMarkets();let o=this.market(e);const n=o.linear?"linear":"inverse",d=this.safeString(r,"category",n),h=this.safeDict(this.options,"intervals"),c=this.safeString(h,t);if(void 0===c)throw new a.BadRequest(this.id+" fetchOpenInterestHistory() cannot use the "+t+" timeframe");const l={symbol:o.id,intervalTime:c,category:d};void 0!==s&&(l.startTime=s);const u=this.safeInteger(r,"until");r=this.omit(r,["until"]),void 0!==u&&(l.endTime=u),void 0!==i&&(l.limit=i);const p=await this.publicGetV5MarketOpenInterest(this.extend(l,r)),f=this.safeDict(p,"result",{}),m=this.addPaginationCursorToResult(p),g=this.safeString(f,"symbol");return o=this.safeMarket(g,o,void 0,"contract"),this.parseOpenInterests(m,o,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();let s=this.market(e);if(!s.contract)throw new a.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i=this.safeString(t,"interval","1h"),r=this.safeDict(this.options,"intervals"),o=this.safeString(r,i);if(void 0===o)throw new a.BadRequest(this.id+" fetchOpenInterest() cannot use the "+i+" timeframe");const n=s.linear?"linear":"inverse",d=this.safeString(t,"category",n),h={symbol:s.id,intervalTime:o,category:d},c=await this.publicGetV5MarketOpenInterest(this.extend(h,t)),l=this.safeDict(c,"result",{}),u=this.safeString(l,"symbol");s=this.safeMarket(u,s,void 0,"contract");const p=this.addPaginationCursorToResult(c);return this.parseOpenInterest(p[0],s)}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,r={}){if("1m"===t)throw new a.BadRequest(this.id+"fetchOpenInterestHistory cannot use the 1m timeframe");await this.loadMarkets();if(this.safeBool(r,"paginate"))return r=this.omit(r,"paginate"),await this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory",e,s,i,t,r,500);const o=this.market(e);if(o.spot||o.option)throw new a.BadRequest(this.id+" fetchOpenInterestHistory() symbol does not support market "+e);const n={symbol:o.id};return void 0!==i&&(n.limit=i),await this.fetchDerivativesOpenInterestHistory(e,t,s,i,r)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeNumber2(e,"open_interest","openInterest");return this.safeOpenInterest({symbol:t.symbol,openInterestAmount:void 0,openInterestValue:i,timestamp:s,datetime:this.iso8601(s),info:e},t)}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},r=await this.privateGetV5SpotCrossMarginTradeLoanInfo(this.extend(i,t)),a=this.safeInteger(r,"time"),o=this.safeDict(r,"result",{});return o.timestamp=a,this.parseBorrowRate(o,s)}parseBorrowRate(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"coin");return{currency:this.safeCurrencyCode(i,t),rate:this.safeNumber(e,"interestRate"),period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=await this.privateGetV5SpotCrossMarginTradeAccount(this.extend({},r)),o=this.safeDict(a,"result",{}),n=this.safeList(o,"loanAccountList",[]),d=this.parseBorrowInterests(n,void 0);return this.filterByCurrencySinceLimit(d,e,s,i)}parseBorrowInterest(e,t=void 0){return{symbol:void 0,marginMode:"cross",currency:this.safeCurrencyCode(this.safeString(e,"tokenId")),interest:this.safeNumber(e,"interest"),interestRate:void 0,amountBorrowed:this.safeNumber(e,"loan"),timestamp:void 0,datetime:void 0,info:e}}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.safeString(r,"transferId",this.uuid()),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.currency(e),c=this.currencyToPrecision(e,t),l={transferId:a,fromAccountType:n,toAccountType:d,coin:h.id,amount:c},u=await this.privatePostV5AssetTransferInterTransfer(this.extend(l,r)),p=this.safeInteger(u,"time"),f=this.safeDict(u,"result",{}),m=this.safeStringN(u,["retCode","retMsg"]),g=this.parseTransferStatus(m);return this.extend(this.parseTransfer(f,h),{timestamp:p,datetime:this.iso8601(p),amount:this.parseNumber(c),fromAccount:s,toAccount:i,status:g})}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchTransfers","paginate"),a)return await this.fetchPaginatedCallCursor("fetchTransfers",e,t,s,i,"nextPageCursor","cursor",void 0,50);let o={};void 0!==e&&(r=this.safeCurrency(e),o.coin=r.id),void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.privateGetV5AssetTransferQueryInterTransferList(this.extend(o,i)),d=this.addPaginationCursorToResult(n);return this.parseTransfers(d,r,t,s)}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={coin:i.id,qty:this.currencyToPrecision(e,t)},a=await this.privatePostV5SpotCrossMarginTradeLoan(this.extend(r,s)),o=this.safeDict(a,"result",{}),n=this.parseMarginLoan(o,i);return this.extend(n,{symbol:void 0,amount:t})}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={coin:i.id,qty:this.numberToString(t)},a=await this.privatePostV5SpotCrossMarginTradeRepay(this.extend(r,s)),o=this.safeDict(a,"result",{}),n=this.parseMarginLoan(o,i);return this.extend(n,{symbol:void 0,amount:t})}parseMarginLoan(e,t=void 0){return{id:this.safeString2(e,"transactId","repayId"),currency:this.safeString(t,"code"),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}parseTransferStatus(e){return this.safeString({0:"ok",OK:"ok",SUCCESS:"ok"},e,e)}parseTransfer(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"fromAccountType"),a=this.safeString(e,"toAccountType"),o=this.safeDict(this.options,"accountsById",{}),n=this.safeString(o,r,r),d=this.safeString(o,a,a);return{info:e,id:this.safeString(e,"transferId"),timestamp:i,datetime:this.iso8601(i),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:n,toAccount:d,status:this.parseTransferStatus(this.safeString(e,"status"))}}async fetchDerivativesMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};s.linear?i.category="linear":s.inverse&&(i.category="inverse");const r=await this.publicGetV5MarketRiskLimit(this.extend(i,t)),a=this.safeDict(r,"result"),o=this.safeList(a,"list");return this.parseMarketLeverageTiers(o,s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();let s;if(s=this.market(e),s.spot||s.option)throw new a.BadRequest(this.id+" fetchMarketLeverageTiers() symbol does not support market "+e);return s.id,await this.fetchDerivativesMarketLeverageTiers(e,t)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol"),i=void 0!==t?t.type:"contract";return{info:e,symbol:this.safeSymbol(s,t,void 0,i),maker:this.safeNumber(e,"makerFeeRate"),taker:this.safeNumber(e,"takerFeeRate"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.linear?"linear":s.inverse?"inverse":s.spot?"spot":"option",i.category=r;const a=await this.privateGetV5AccountFeeRate(this.extend(i,t)),o=this.safeDict(a,"result",{}),n=this.safeList(o,"list",[]),d=this.safeDict(n,0,{});return this.parseTradingFee(d,s)}async fetchTradingFees(e={}){let t;if(await this.loadMarkets(),[t,e]=this.handleOptionAndParams(e,"fetchTradingFees","type","future"),"spot"===t)throw new a.NotSupported(this.id+" fetchTradingFees() is not supported for spot market");const s=await this.privateGetV5AccountFeeRate(e);let i=this.safeDict(s,"result",{});i=this.safeList(i,"list",[]);const r={};for(let e=0;e<i.length;e++){const t=this.parseTradingFee(i[e]);r[t.symbol]=t}return r}parseDepositWithdrawFee(e,t=void 0){const s=this.safeList(e,"chains",[]),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(0!==i)for(let e=0;e<i;e++){const a=s[e],o=this.safeString(a,"chain"),n=this.safeString(t,"code"),d=this.networkIdToCode(o,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(a,"withdrawFee"),percentage:!1}},1===i&&(r.withdraw.fee=this.safeNumber(a,"withdrawFee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){this.checkRequiredCredentials(),await this.loadMarkets();const s=await this.privateGetV5AssetCoinQueryInfo(t),i=this.safeDict(s,"result",{}),r=this.safeList(i,"rows",[]);return this.parseDepositWithdrawFees(r,e,"coin")}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let o,n;if(void 0!==e&&(o=this.market(e),r.symbol=o.id),[n,i]=this.getBybitType("fetchSettlementHistory",o,i),"spot"===n)throw new a.NotSupported(this.id+" fetchSettlementHistory() is not supported for spot market");r.category=n,void 0!==s&&(r.limit=s);const d=await this.publicGetV5MarketDeliveryPrice(this.extend(r,i)),h=this.safeDict(d,"result",{}),c=this.safeList(h,"list",[]),l=this.parseSettlements(c,o),u=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(u,o.symbol,t,s)}async fetchMySettlementHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let o,n;if(void 0!==e&&(o=this.market(e),r.symbol=o.id),[n,i]=this.getBybitType("fetchMySettlementHistory",o,i),"spot"===n||"inverse"===n)throw new a.NotSupported(this.id+" fetchMySettlementHistory() is not supported for spot market");r.category="linear",void 0!==s&&(r.limit=s);const d=await this.privateGetV5AssetDeliveryRecord(this.extend(r,i)),h=this.safeDict(d,"result",{}),c=this.safeList(h,"list",[]),l=this.parseSettlements(c,o),u=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(u,o.symbol,t,s)}parseSettlement(e,t){const s=this.safeInteger(e,"deliveryTime"),i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"deliveryPrice"),timestamp:s,datetime:this.iso8601(s)}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++)s.push(this.parseSettlement(e[i],t));return s}async fetchVolatilityHistory(e,t={}){await this.loadMarkets();const s={category:"option",baseCoin:this.currency(e).id},i=await this.publicGetV5MarketHistoricalVolatility(this.extend(s,t)),r=this.safeList(i,"result",[]);return this.parseVolatilityHistory(r)}parseVolatilityHistory(e){const t=[];for(let s=0;s<e.length;s++){const i=e[s],r=this.safeInteger(i,"time");t.push({info:e,timestamp:r,datetime:this.iso8601(r),volatility:this.safeNumber(i,"value")})}return t}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id,category:"option"},r=await this.publicGetV5MarketTickers(this.extend(i,t)),a=this.safeInteger(r,"time"),o=this.safeDict(r,"result",{}),n=this.safeList(o,"list",[]),d=this.parseGreeks(n[0],s);return this.extend(d,{timestamp:a,datetime:this.iso8601(a)})}parseGreeks(e,t=void 0){const s=this.safeString(e,"symbol");return{symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,delta:this.safeNumber(e,"delta"),gamma:this.safeNumber(e,"gamma"),theta:this.safeNumber(e,"theta"),vega:this.safeNumber(e,"vega"),rho:void 0,bidSize:this.safeNumber(e,"bid1Size"),askSize:this.safeNumber(e,"ask1Size"),bidImpliedVolatility:this.safeNumber(e,"bid1Iv"),askImpliedVolatility:this.safeNumber(e,"ask1Iv"),markImpliedVolatility:this.safeNumber(e,"markIv"),bidPrice:this.safeNumber(e,"bid1Price"),askPrice:this.safeNumber(e,"ask1Price"),markPrice:this.safeNumber(e,"markPrice"),lastPrice:this.safeNumber(e,"lastPrice"),underlyingPrice:this.safeNumber(e,"underlyingPrice"),info:e}}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyLiquidations","paginate"),r)return await this.fetchPaginatedCallCursor("fetchMyLiquidations",e,t,s,i,"nextPageCursor","cursor",void 0,100);let a,o,n={execType:"BustTrade"};void 0!==e&&(a=this.market(e),n.symbol=a.id),[o,i]=this.getBybitType("fetchMyLiquidations",a,i),n.category=o,void 0!==s&&(n.limit=s),void 0!==t&&(n.startTime=t),[n,i]=this.handleUntilOption("endTime",n,i);const d=await this.privateGetV5ExecutionList(this.extend(n,i)),h=this.addPaginationCursorToResult(d);return this.parseLiquidations(h,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"execTime"),r=this.safeString(e,"execQty"),a=this.safeString(t,"contractSize"),n=this.safeString(e,"execPrice"),d=o.Y.stringMul(r,a),h=o.Y.stringMul(d,n);return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t,void 0,"contract"),contracts:this.parseNumber(r),contractSize:this.parseNumber(a),price:this.parseNumber(n),baseValue:this.parseNumber(d),quoteValue:this.parseNumber(h),timestamp:i,datetime:this.iso8601(i)})}async getLeverageTiersPaginated(e=void 0,t={}){let s;await this.loadMarkets(),void 0!==e&&(s=this.market(e));let i,r=!1;if([r,t]=this.handleOptionAndParams(t,"getLeverageTiersPaginated","paginate"),r)return await this.fetchPaginatedCallCursor("getLeverageTiersPaginated",e,void 0,void 0,t,"nextPageCursor","cursor",void 0,100);[i,t]=this.handleSubTypeAndParams("getLeverageTiersPaginated",s,t,"linear");const a={category:i},o=await this.publicGetV5MarketRiskLimit(this.extend(a,t)),n=this.addPaginationCursorToResult(o),d=this.safeDict(n,0),h=n.length-1,c=this.safeDict(n,h),l=this.safeString(d,"nextPageCursor");return c.info={nextPageCursor:l},n[h]=c,n}async fetchLeverageTiers(e=void 0,t={}){let s,i;if(await this.loadMarkets(),void 0!==e){if(s=this.market(e[0]),s.spot)throw new a.NotSupported(this.id+" fetchLeverageTiers() is not supported for spot market");i=s.symbol}const r=await this.getLeverageTiersPaginated(i,this.extend({paginate:!0,paginationCalls:20},t));return e=this.marketSymbols(e),this.parseLeverageTiers(r,e,"symbol")}parseLeverageTiers(e,t=void 0,s=void 0){const i={},r=this.marketIds(t),a=this.filterByArray(e,s,r,!1),o=this.groupBy(a,s),n=Object.keys(o);for(let e=0;e<n.length;e++){const t=n[e],s=o[t];for(let e=0;e<s.length;e++){const t=this.safeInteger(s[e],"id");s[e].id=t}const r=this.safeMarket(t,void 0,void 0,"contract");i[r.symbol]=this.parseMarketLeverageTiers(this.sortBy(s,"id"),r)}return i}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(e,"symbol");t=this.safeMarket(a);let o=this.parseNumber("0");0!==i&&(o=this.safeNumber(e[i-1],"riskLimitValue")),s.push({tier:this.safeInteger(r,"id"),currency:t.settle,minNotional:o,maxNotional:this.safeNumber(r,"riskLimitValue"),maintenanceMarginRate:this.safeNumber(r,"maintenanceMargin"),maxLeverage:this.safeNumber(r,"maxLeverage"),info:r})}return s}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingHistory","paginate"),r)return await this.fetchPaginatedCallCursor("fetchFundingHistory",e,t,s,i,"nextPageCursor","cursor",void 0,100);let a,o,n={execType:"Funding"};void 0!==e&&(a=this.market(e),n.symbol=a.id),[o,i]=this.getBybitType("fetchFundingHistory",a,i),n.category=o,void 0!==e&&(n.symbol=a.id),void 0!==t&&(n.startTime=t),n.size=void 0!==s?s:100,[n,i]=this.handleUntilOption("endTime",n,i);const d=await this.privateGetV5ExecutionList(this.extend(n,i)),h=this.addPaginationCursorToResult(d);return this.parseIncomes(h,a,t,s)}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol");let i="USDT";(t=this.safeMarket(s,t,void 0,"contract")).inverse&&(i=t.quote);const r=this.safeInteger(e,"execTime");return{info:e,symbol:this.safeSymbol(s,t,"-","swap"),code:i,timestamp:r,datetime:this.iso8601(r),id:this.safeString(e,"execId"),amount:this.safeNumber(e,"execQty"),rate:this.safeNumber(e,"feeRate")}}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={category:"option",symbol:s.id},r=await this.publicGetV5MarketTickers(this.extend(i,t)),a=this.safeDict(r,"result",{}),o=this.safeList(a,"list",[]),n=this.safeDict(o,0,{});return this.parseOption(n,void 0,s)}async fetchOptionChain(e,t={}){await this.loadMarkets();const s={category:"option",baseCoin:this.currency(e).id},i=await this.publicGetV5MarketTickers(this.extend(s,t)),r=this.safeDict(i,"result",{}),a=this.safeList(r,"list",[]);return this.parseOptionChain(a,void 0,"symbol")}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"symbol");return{info:e,currency:void 0,symbol:(s=this.safeMarket(i,s)).symbol,timestamp:void 0,datetime:void 0,impliedVolatility:this.safeNumber(e,"markIv"),openInterest:this.safeNumber(e,"openInterest"),bidPrice:this.safeNumber(e,"bid1Price"),askPrice:this.safeNumber(e,"ask1Price"),midPrice:void 0,markPrice:this.safeNumber(e,"markPrice"),lastPrice:this.safeNumber(e,"lastPrice"),underlyingPrice:this.safeNumber(e,"underlyingPrice"),change:this.safeNumber(e,"change24h"),percentage:void 0,baseVolume:this.safeNumber(e,"totalVolume"),quoteVolume:void 0}}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets();let o=0;void 0!==e&&(o=e.length,o>0&&(r=this.market(e[0])));const n=this.safeInteger(i,"until");[a,i]=this.handleSubTypeAndParams("fetchPositionsHistory",r,i,"linear"),i=this.omit(i,"until");const d={category:a};void 0!==e&&1===o&&(d.symbol=r.id),void 0!==t&&(d.startTime=t),void 0!==s&&(d.limit=s),void 0!==n&&(d.endTime=n);const h=await this.privateGetV5PositionClosedPnl(this.extend(d,i)),c=this.safeDict(h,"result"),l=this.safeList(c,"list"),u=this.parsePositions(l,e,i);return this.filterBySinceLimit(u,t,s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.implodeHostname(this.urls.api[t])+"/"+e;if("public"===t)Object.keys(i).length&&(o+="?"+this.rawencode(i));else if("private"===t){this.checkRequiredCredentials();const e=o.indexOf("openapi")>=0,t=o.indexOf("unified/v3")>=0,h=o.indexOf("contract/v3")>=0,c=o.indexOf("v5")>=0,l=this.nonce().toString();if(e){a=Object.keys(i).length?this.json(i):"{}";const e=l+this.apiKey+a,t=this.hmac(this.encode(e),this.encode(this.secret),n.s,"hex");r={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-TIMESTAMP":l,"X-BAPI-SIGN":t}}else if(t||h||c){r={"Content-Type":"application/json","X-BAPI-API-KEY":this.apiKey,"X-BAPI-TIMESTAMP":l,"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()},(t||h)&&(r["X-BAPI-SIGN-TYPE"]="2");const e=this.extend({},i),c=this.rawencode(e),u=l.toString()+this.apiKey+this.options.recvWindow.toString();let p,f;"POST"===s?p=u+(a=this.json(e)):(p=u+c,o+="?"+this.rawencode(e)),f=this.secret.indexOf("PRIVATE KEY")>-1?(0,d.n)(p,this.secret,n.s):this.hmac(this.encode(p),this.encode(this.secret),n.s),r["X-BAPI-SIGN"]=f}else{const e=this.extend(i,{api_key:this.apiKey,recv_window:this.options.recvWindow,timestamp:l}),t=this.keysort(e),h=this.rawencode(t);let c;if(c=this.secret.indexOf("PRIVATE KEY")>-1?(0,d.n)(h,this.secret,n.s):this.hmac(this.encode(h),this.encode(this.secret),n.s),"POST"===s){const t=o.indexOf("spot")>=0,s=this.extend(e,{sign:c});t?(a=this.urlencode(s),r={"Content-Type":"application/x-www-form-urlencoded"}):(a=this.json(s),r={"Content-Type":"application/json"})}else o+="?"+this.rawencode(t),o+="&sign="+c}}if("POST"===s){const e=this.safeString(this.options,"brokerId");void 0!==e&&(r.Referer=e)}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,o,n,d,h){if(!n)return;const c=this.safeString2(n,"ret_code","retCode");if("0"!==c){if("30084"===c)return;let e;throw e="10005"===c&&s.indexOf("order")<0?this.id+' private api uses /user/v3/private/query-api to check if you have a unified account. The API key of user id must own one of permissions: "Account Transfer", "Subaccount Transfer", "Withdrawal" '+o:this.id+" "+o,this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new a.ExchangeError(e)}}}},8846:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5465),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"cex",name:"CEX.IO",countries:["GB","EU","CY","RU"],rateLimit:1500,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg",api:{rest:"https://cex.io/api"},www:"https://cex.io",doc:"https://cex.io/cex-api",fees:["https://cex.io/fee-schedule","https://cex.io/limits-commissions"],referral:"https://cex.io/r/0/up105393824/0/"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["currency_profile","currency_limits/","last_price/{pair}/","last_prices/{currencies}/","ohlcv/hd/{yyyymmdd}/{pair}","order_book/{pair}/","ticker/{pair}/","tickers/{currencies}/","trade_history/{pair}/"],post:["convert/{pair}","price_stats/{pair}"]},private:{post:["active_orders_status/","archived_orders/{pair}/","balance/","cancel_order/","cancel_orders/{pair}/","cancel_replace_order/{pair}/","close_position/{pair}/","get_address/","get_crypto_address","get_myfee/","get_order/","get_order_tx/","open_orders/{pair}/","open_orders/","open_position/{pair}/","open_positions/{pair}/","place_order/{pair}/","raw_tx_history"]}},fees:{trading:{maker:this.parseNumber("0.0016"),taker:this.parseNumber("0.0025")},funding:{withdraw:{},deposit:{BTC:0,ETH:0,BCH:0,DASH:0,BTG:0,ZEC:0,XRP:0,XLM:0}}},precisionMode:o.kb,exceptions:{exact:{},broad:{"Insufficient funds":r.InsufficientFunds,"Nonce must be incremented":r.InvalidNonce,"Invalid Order":r.InvalidOrder,"Order not found":r.OrderNotFound,"limit exceeded":r.RateLimitExceeded,"Invalid API key":r.AuthenticationError,"There was an error while placing your order":r.InvalidOrder,"Sorry, too many clients already":r.DDoSProtection,"Invalid Symbols Pair":r.BadSymbol,"Wrong currency pair":r.BadSymbol}},options:{fetchOHLCVWarning:!0,createMarketBuyOrderRequiresPrice:!0,order:{status:{c:"canceled",d:"closed",cd:"canceled",a:"open"}},defaultNetwork:"ERC20",defaultNetworks:{USDT:"TRC20"},networks:{ERC20:"Ethereum",BTC:"BTC",BEP20:"Binance Smart Chain",TRC20:"Tron"}}})}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===s||r-s>i){const s=await this.publicGetCurrencyProfile(e);this.options.fetchCurrencies=this.extend(t,{response:s,timestamp:r})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e);this.options.currencies={timestamp:this.milliseconds(),response:t};const s=this.safeValue(t,"data",[]),i=this.safeValue(s,"symbols",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"code"),a=this.safeCurrencyCode(s),o=!0;r[a]={id:s,code:a,name:s,active:o,deposit:void 0,withdraw:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(t,"precision"))),fee:void 0,limits:{amount:{min:this.safeNumber(t,"minimumCurrencyAmount"),max:void 0},withdraw:{min:this.safeNumber(t,"minimalWithdrawalAmount"),max:void 0}},info:t}}return r}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbols",[]),r=this.indexBy(i,"code"),o=this.safeValue(s,"pairs",[]),n=await this.publicGetCurrencyLimits(e),d=[],h=this.safeValue(n.data,"pairs");for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"symbol1"),i=this.safeString(t,"symbol2"),n=this.safeCurrencyCode(s),c=this.safeCurrencyCode(i),l=this.safeValue(r,s,{}),u=this.safeValue(r,i,{});let p=this.safeString(u,"precision","8");for(let e=0;e<o.length;e++){const t=o[e];t.symbol1===s&&t.symbol2===i&&(p=this.safeString(t,"pricePrecision",p))}const f=this.safeString(l,"precision","8"),m=this.safeString(l,"scale","0"),g=a.Y.stringSub(f,m);d.push({id:s+"/"+i,symbol:n+"/"+c,base:n,quote:c,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(g)),price:this.parseNumber(this.parsePrecision(p))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minLotSize"),max:this.safeNumber(t,"maxLotSize")},price:{min:this.safeNumber(t,"minPrice"),max:this.safeNumber(t,"maxPrice")},cost:{min:this.safeNumber(t,"minLotSizeS2"),max:void 0}},created:void 0,info:t})}return d}parseBalance(e){const t={info:e},s=this.omit(e,["username","timestamp"]),i=Object.keys(s);for(let e=0;e<i.length;e++){const r=i[e],a=this.safeValue(s,r,{}),o=this.account();o.free=this.safeString(a,"available"),o.used=this.safeString(a,"orders","0");t[this.safeCurrencyCode(r)]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetOrderBookPair(this.extend(r,s)),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,i.symbol,o)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e);if(void 0===s)s=this.milliseconds()-864e5;else if(this.options.fetchOHLCVWarning)throw new r.ExchangeError(this.id+" fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");const n={pair:o.id,yyyymmdd:this.yyyymmdd(s,"")};try{const e=await this.publicGetOhlcvHdYyyymmddPair(this.extend(n,a)),r="data"+this.safeString(this.timeframes,t,t),d=this.safeString(e,r),h=JSON.parse(d);return this.parseOHLCVs(h,o,t,s,i)}catch(e){if(e instanceof r.NullResponse)return[]}}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"volume"),r=this.safeString(e,"high"),a=this.safeString(e,"low"),o=this.safeString(e,"bid"),n=this.safeString(e,"ask"),d=this.safeString(e,"last"),h=this.safeSymbol(void 0,t);return this.safeTicker({symbol:h,timestamp:s,datetime:this.iso8601(s),high:r,low:a,bid:o,bidVolume:void 0,ask:n,askVolume:void 0,vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:i,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={currencies:Object.keys(this.currencies).join("/")},i=await this.publicGetTickersCurrencies(this.extend(s,t)),r=this.safeValue(i,"data",[]),a={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,":");a[i.symbol]=this.parseTicker(t,i)}return this.filterByArrayTickers(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"tid"),r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"amount");return t=this.safeMarket(void 0,t),this.safeTrade({info:e,id:i,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:undefined,side:r,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTradeHistoryPair(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetMyfee(e),s=this.safeValue(t,"data",{}),i={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],r=this.market(t),o=this.safeValue(s,r.id,{}),n=this.safeString(o,"buyMaker"),d=this.safeString(o,"buy"),h=this.parseNumber(a.Y.stringDiv(n,"100")),c=this.parseNumber(a.Y.stringDiv(d,"100"));i[t]={info:o,symbol:t,maker:h,taker:c,percentage:!0}}return i}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e),h={pair:d.id,type:s};if("market"===t&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeString(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);h.amount=t}else h.amount=this.amountToPrecision(e,i);"limit"===t?h.price=this.numberToString(o):h.order_type=t;const c=await this.privatePostPlaceOrderPair(this.extend(h,n)),l=this.safeString(c,"amount"),u=this.safeString(c,"pending"),p=this.safeValue(c,"time"),f=this.safeValue(c,"complete")?"closed":"open";let m;return void 0!==l&&void 0!==u&&(m=a.Y.stringMax(a.Y.stringSub(l,u),"0")),this.safeOrder({id:this.safeString(c,"id"),info:c,clientOrderId:void 0,timestamp:p,datetime:this.iso8601(p),lastTradeTimestamp:void 0,type:t,side:this.safeString(c,"type"),symbol:d.symbol,status:f,price:this.safeString(c,"price"),amount:l,cost:void 0,average:void 0,remaining:u,filled:m,fee:void 0,trades:void 0})}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privatePostCancelOrder(this.extend(i,s));return this.extend(this.parseOrder({}),{info:r,type:void 0,id:e,status:"canceled"})}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders requires a symbol.");await this.loadMarkets();const s={pair:this.market(e).id};return await this.privatePostCancelOrdersPair(this.extend(s,t))}parseOrder(e,t=void 0){let s,i=this.safeValue(e,"time");"string"==typeof i&&i.indexOf("T")>=0?i=this.parse8601(i):void 0!==i&&(i=parseInt(i));const r=this.safeString(e,"symbol1"),o=this.safeString(e,"symbol2");if(void 0===t&&void 0!==r&&void 0!==o){const e=this.safeCurrencyCode(r),i=this.safeCurrencyCode(o);void 0!==e&&void 0!==i&&(s=e+"/"+i),s in this.markets&&(t=this.market(s))}const n=this.parseOrderStatus(this.safeString(e,"status")),d=this.safeString(e,"price");let h=this.omitZero(this.safeString(e,"amount"));if(void 0!==h)h=a.Y.stringAbs(h);else if(void 0!==t){const s="a:"+t.base+"cds:";h=a.Y.stringAbs(this.safeString(e,s))}const c=this.safeString2(e,"pending","remains"),l=a.Y.stringSub(h,c);let u,p;if(void 0!==t){s=t.symbol;const i=this.safeString(e,"ta:"+t.quote),r=this.safeString(e,"tta:"+t.quote);p=a.Y.stringAdd(i,r);const o="fa:"+t.base,n="tfa:"+t.base,d="fa:"+t.quote,h="tfa:"+t.quote;let c=this.safeString(e,"tradingFeeMaker");if(c||(c=this.safeString(e,"tradingFeeTaker",c)),c&&(c=a.Y.stringDiv(c,"100")),o in e||n in e){const s=this.safeNumber2(e,o,n);u={currency:t.base,rate:this.parseNumber(c),cost:s}}else if(d in e||h in e){const s=this.safeNumber2(e,d,h);u={currency:t.quote,rate:this.parseNumber(c),cost:s}}}p||(p=a.Y.stringMul(d,l));const f=this.safeString(e,"type");let m;const g=this.safeString(e,"id");if("vtx"in e){m=[];for(let i=0;i<e.vtx.length;i++){const r=e.vtx[i],o=this.safeString(r,"type");if("cancel"===o)continue;const n=this.safeString(r,"price");if(void 0===n)continue;if("costsNothing"===o)continue;const d=this.parse8601(this.safeString(r,"time")),h=this.safeString(r,"amount"),c=this.safeString(r,"fee_amount");let l,u=a.Y.stringAbs(h);"sell"===o?(l=u,u=a.Y.stringDiv(a.Y.stringAdd(c,l),n)):l=a.Y.stringMul(u,n),m.push({id:this.safeString(r,"id"),timestamp:d,datetime:this.iso8601(d),order:g,symbol:s,price:this.parseNumber(n),amount:this.parseNumber(u),cost:this.parseNumber(l),side:o,fee:{cost:this.parseNumber(c),currency:t.quote},info:r,type:void 0,takerOrMaker:void 0})}}return this.safeOrder({info:e,id:g,clientOrderId:void 0,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,status:n,symbol:s,type:void 0===d?"market":"limit",timeInForce:void 0,postOnly:void 0,side:f,price:d,stopPrice:void 0,triggerPrice:void 0,cost:p,amount:h,filled:l,remaining:c,trades:m,fee:u,average:void 0})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;void 0!==e?(a=this.market(e),r.pair=a.id,o=await this.privatePostOpenOrdersPair(this.extend(r,i))):o=await this.privatePostOpenOrders(this.extend(r,i));for(let e=0;e<o.length;e++)o[e]=this.extend(o[e],{status:"open"});return this.parseOrders(o,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id},n=await this.privatePostArchivedOrdersPair(this.extend(o,i));return this.parseOrders(n,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e.toString()},r=await this.privatePostGetOrderTx(this.extend(i,s)),a=this.safeValue(r,"data",{});return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={limit:s,pair:this.market(e).id,dateFrom:t},o=await this.privatePostArchivedOrdersPair(this.extend(r,i)),n=[];for(let e=0;e<o.length;e++){const t=o[e],s=this.parseOrderStatus(this.safeString(t,"status")),i=this.safeString(t,"symbol1"),r=this.safeString(t,"symbol2"),d=this.safeCurrencyCode(i),h=this.safeCurrencyCode(r),c=d+"/"+h,l=this.safeString(t,"type"),u=this.safeNumber(t,"a:"+i+":cds"),p=this.safeNumber(t,"a:"+r+":cds"),f=this.safeNumber(t,"f:"+r+":cds"),m=this.safeString(t,"amount"),g=this.safeString(t,"price"),v=this.safeString(t,"remains"),y=a.Y.stringSub(m,v);let w,b,S,k;if(g){const e=this.safeString(t,"ta:"+r,"0"),s=this.safeString(t,"tta:"+r,"0"),i=this.safeString(t,"fa:"+r,"0"),o=this.safeString(t,"tfa:"+r,"0");b="sell"===l?a.Y.stringAdd(a.Y.stringAdd(e,s),a.Y.stringAdd(i,o)):a.Y.stringSub(a.Y.stringAdd(e,s),a.Y.stringAdd(i,o)),k="limit",w=m,S=a.Y.stringDiv(b,y)}else k="market",w=u,b=p,S=a.Y.stringDiv(w,b);const O=this.safeString(t,"time"),T=this.safeString(t,"lastTxTime"),P=this.parse8601(O),I=this.safeOrder({info:t,id:this.safeString(t,"id"),timestamp:P,datetime:this.iso8601(P),lastUpdated:this.parse8601(T),status:s,symbol:c,side:l,price:g,amount:w,average:S,type:k,filled:y,cost:b,remaining:v,fee:{cost:f,currency:h}});n.push(I)}return n}parseOrderStatus(e){return this.safeString(this.options.order.status,e,e)}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){if(void 0===a)throw new r.ArgumentsRequired(this.id+" editOrder() requires a amount argument");if(void 0===o)throw new r.ArgumentsRequired(this.id+" editOrder() requires a price argument");await this.loadMarkets();const d=this.market(t),h={pair:d.id,type:i,amount:a,price:o,order_id:e},c=await this.privatePostCancelReplaceOrderPair(this.extend(h,n));return this.parseOrder(c,d)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},[i,r]=this.handleNetworkCodeAndParams(t),a=await this.privatePostGetCryptoAddress(this.extend(s,r)),o=this.safeValue(a,"data",{}),n=this.safeValue(o,"addresses",[]),d=this.indexBy(n,"blockchain"),h=this.selectNetworkIdFromRawNetworks(e,i,d),c=this.safeValue(d,h,{}),l=this.safeString2(c,"address","destination");return this.checkAddress(l),{currency:e,address:l,tag:this.safeString2(c,"destinationTag","memo"),network:this.networkIdToCode(h),info:o}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,s=this.hmac(this.encode(t),this.encode(this.secret),n.s);a=this.json(this.extend({key:this.apiKey,signature:s.toUpperCase(),nonce:e},d)),r={"Content-Type":"application/json"}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(Array.isArray(n))return n;if("true"!==o){if(void 0===n)throw new r.NullResponse(this.id+" returned "+this.json(n));if((!("e"in n)||!("ok"in n)||"ok"!==n.ok)&&"error"in n){const e=this.safeString(n,"error"),t=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,t),this.throwBroadlyMatchedException(this.exceptions.broad,e,t),new r.ExchangeError(t)}}}}},7504:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(5661),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(5354);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinbase",name:"Coinbase Advanced",countries:["US"],pro:!0,certified:!0,rateLimit:34,version:"v2",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!0,createConvertTrade:!0,createDepositAddress:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrder:!0,createMarketSellOrderWithCost:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,deposit:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchConvertQuote:!0,fetchConvertTrade:!0,fetchConvertTradeHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:"emulated",fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL2OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyBuys:!0,fetchMySells:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:"emulated",fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg",api:{rest:"https://api.coinbase.com"},www:"https://www.coinbase.com",doc:["https://developers.coinbase.com/api/v2","https://docs.cloud.coinbase.com/advanced-trade/docs/welcome"],fees:["https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees","https://www.coinbase.com/advanced-fees"],referral:"https://www.coinbase.com/join/58cbe25a355148797479dbd2"},requiredCredentials:{apiKey:!0,secret:!0},api:{v2:{public:{get:{currencies:10.6,"currencies/crypto":10.6,time:10.6,"exchange-rates":10.6,"users/{user_id}":10.6,"prices/{symbol}/buy":10.6,"prices/{symbol}/sell":10.6,"prices/{symbol}/spot":10.6}},private:{get:{accounts:10.6,"accounts/{account_id}":10.6,"accounts/{account_id}/addresses":10.6,"accounts/{account_id}/addresses/{address_id}":10.6,"accounts/{account_id}/addresses/{address_id}/transactions":10.6,"accounts/{account_id}/transactions":10.6,"accounts/{account_id}/transactions/{transaction_id}":10.6,"accounts/{account_id}/buys":10.6,"accounts/{account_id}/buys/{buy_id}":10.6,"accounts/{account_id}/sells":10.6,"accounts/{account_id}/sells/{sell_id}":10.6,"accounts/{account_id}/deposits":10.6,"accounts/{account_id}/deposits/{deposit_id}":10.6,"accounts/{account_id}/withdrawals":10.6,"accounts/{account_id}/withdrawals/{withdrawal_id}":10.6,"payment-methods":10.6,"payment-methods/{payment_method_id}":10.6,user:10.6,"user/auth":10.6},post:{accounts:10.6,"accounts/{account_id}/primary":10.6,"accounts/{account_id}/addresses":10.6,"accounts/{account_id}/transactions":10.6,"accounts/{account_id}/transactions/{transaction_id}/complete":10.6,"accounts/{account_id}/transactions/{transaction_id}/resend":10.6,"accounts/{account_id}/buys":10.6,"accounts/{account_id}/buys/{buy_id}/commit":10.6,"accounts/{account_id}/sells":10.6,"accounts/{account_id}/sells/{sell_id}/commit":10.6,"accounts/{account_id}/deposits":10.6,"accounts/{account_id}/deposits/{deposit_id}/commit":10.6,"accounts/{account_id}/withdrawals":10.6,"accounts/{account_id}/withdrawals/{withdrawal_id}/commit":10.6},put:{"accounts/{account_id}":10.6,user:10.6},delete:{"accounts/{id}":10.6,"accounts/{account_id}/transactions/{transaction_id}":10.6}}},v3:{public:{get:{"brokerage/time":3,"brokerage/market/product_book":3,"brokerage/market/products":3,"brokerage/market/products/{product_id}":3,"brokerage/market/products/{product_id}/candles":3,"brokerage/market/products/{product_id}/ticker":3}},private:{get:{"brokerage/accounts":1,"brokerage/accounts/{account_uuid}":1,"brokerage/orders/historical/batch":1,"brokerage/orders/historical/fills":1,"brokerage/orders/historical/{order_id}":1,"brokerage/products":3,"brokerage/products/{product_id}":3,"brokerage/products/{product_id}/candles":3,"brokerage/products/{product_id}/ticker":3,"brokerage/best_bid_ask":3,"brokerage/product_book":3,"brokerage/transaction_summary":3,"brokerage/portfolios":1,"brokerage/portfolios/{portfolio_uuid}":1,"brokerage/convert/trade/{trade_id}":1,"brokerage/cfm/balance_summary":1,"brokerage/cfm/positions":1,"brokerage/cfm/positions/{product_id}":1,"brokerage/cfm/sweeps":1,"brokerage/intx/portfolio/{portfolio_uuid}":1,"brokerage/intx/positions/{portfolio_uuid}":1,"brokerage/intx/positions/{portfolio_uuid}/{symbol}":1,"brokerage/payment_methods":1,"brokerage/payment_methods/{payment_method_id}":1},post:{"brokerage/orders":1,"brokerage/orders/batch_cancel":1,"brokerage/orders/edit":1,"brokerage/orders/edit_preview":1,"brokerage/orders/preview":1,"brokerage/portfolios":1,"brokerage/portfolios/move_funds":1,"brokerage/convert/quote":1,"brokerage/convert/trade/{trade_id}":1,"brokerage/cfm/sweeps/schedule":1,"brokerage/intx/allocate":1,"brokerage/orders/close_position":1},put:{"brokerage/portfolios/{portfolio_uuid}":1},delete:{"brokerage/portfolios/{portfolio_uuid}":1,"brokerage/cfm/sweeps":1}}}},fees:{trading:{taker:this.parseNumber("0.012"),maker:this.parseNumber("0.006"),tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.006")],[this.parseNumber("10000"),this.parseNumber("0.004")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("15000000"),this.parseNumber("0.0016")],[this.parseNumber("75000000"),this.parseNumber("0.0012")],[this.parseNumber("250000000"),this.parseNumber("0.0008")],[this.parseNumber("400000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.0025")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("15000000"),this.parseNumber("0.0006")],[this.parseNumber("75000000"),this.parseNumber("0.0003")],[this.parseNumber("250000000"),this.parseNumber("0.0")],[this.parseNumber("400000000"),this.parseNumber("0.0")]]}}},precisionMode:o.kb,exceptions:{exact:{two_factor_required:r.AuthenticationError,param_required:r.ExchangeError,validation_error:r.ExchangeError,invalid_request:r.ExchangeError,personal_details_required:r.AuthenticationError,identity_verification_required:r.AuthenticationError,jumio_verification_required:r.AuthenticationError,jumio_face_match_verification_required:r.AuthenticationError,unverified_email:r.AuthenticationError,authentication_error:r.AuthenticationError,invalid_authentication_method:r.AuthenticationError,invalid_token:r.AuthenticationError,revoked_token:r.AuthenticationError,expired_token:r.AuthenticationError,invalid_scope:r.AuthenticationError,not_found:r.ExchangeError,rate_limit_exceeded:r.RateLimitExceeded,internal_server_error:r.ExchangeError,UNSUPPORTED_ORDER_CONFIGURATION:r.BadRequest,INSUFFICIENT_FUND:r.BadRequest,PERMISSION_DENIED:r.PermissionDenied,INVALID_ARGUMENT:r.BadRequest},broad:{"request timestamp expired":r.InvalidNonce,"order with this orderID was not found":r.OrderNotFound}},timeframes:{"1m":"ONE_MINUTE","5m":"FIVE_MINUTE","15m":"FIFTEEN_MINUTE","30m":"THIRTY_MINUTE","1h":"ONE_HOUR","2h":"TWO_HOUR","6h":"SIX_HOUR","1d":"ONE_DAY"},commonCurrencies:{CGLD:"CELO"},options:{usePrivate:!1,brokerId:"ccxt",stablePairs:["BUSD-USD","CBETH-ETH","DAI-USD","GUSD-USD","GYEN-USD","PAX-USD","PAX-USDT","USDC-EUR","USDC-GBP","USDT-EUR","USDT-GBP","USDT-USD","USDT-USDC","WBTC-BTC"],fetchCurrencies:{expires:5e3},accounts:["wallet","fiat"],v3Accounts:["ACCOUNT_TYPE_CRYPTO","ACCOUNT_TYPE_FIAT"],networks:{ERC20:"ethereum",XLM:"stellar"},createMarketBuyOrderRequiresPrice:!0,advanced:!0,fetchMarkets:"fetchMarketsV3",fetchTicker:"fetchTickerV3",fetchTickers:"fetchTickersV3",fetchAccounts:"fetchAccountsV3",fetchBalance:"v2PrivateGetAccounts",fetchTime:"v2PublicGetTime",user_native_currency:"USD"}})}async fetchTime(e={}){const t=this.safeString(this.options,"fetchTime","v2PublicGetTime"),s=this.safeString(e,"method",t);let i;return e=this.omit(e,"method"),"v2PublicGetTime"===s?(i=await this.v2PublicGetTime(e),i=this.safeDict(i,"data",{})):i=await this.v3PublicGetBrokerageTime(e),this.safeTimestamp2(i,"epoch","epochSeconds")}async fetchAccounts(e={}){return"fetchAccountsV3"===this.safeString(this.options,"fetchAccounts","fetchAccountsV3")?await this.fetchAccountsV3(e):await this.fetchAccountsV2(e)}async fetchAccountsV2(e={}){await this.loadMarkets();let t=!1;if([t,e]=this.handleOptionAndParams(e,"fetchAccounts","paginate"),t)return await this.fetchPaginatedCallCursor("fetchAccounts",void 0,void 0,void 0,e,"next_starting_after","starting_after",void 0,100);const s=await this.v2PrivateGetAccounts(this.extend({limit:100},e)),i=this.safeList(s,"data",[]),r=this.safeDict(s,"pagination",{}),a=this.safeString(r,"next_starting_after"),o=this.safeList(s,"data",[]),n=o.length-1,d=this.safeDict(o,n);return void 0!==a&&""!==a&&(d.next_starting_after=a,o[n]=d),this.parseAccounts(i,e)}async fetchAccountsV3(e={}){await this.loadMarkets();let t=!1;if([t,e]=this.handleOptionAndParams(e,"fetchAccounts","paginate"),t)return await this.fetchPaginatedCallCursor("fetchAccounts",void 0,void 0,void 0,e,"cursor","cursor",void 0,250);const s=await this.v3PrivateGetBrokerageAccounts(this.extend({limit:250},e)),i=this.safeList(s,"accounts",[]),r=i.length-1,a=this.safeDict(i,r),o=this.safeString(s,"cursor");return void 0!==o&&""!==o&&(a.cursor=o,i[r]=a),this.parseAccounts(i,e)}async fetchPortfolios(e={}){const t=await this.v3PrivateGetBrokeragePortfolios(e),s=this.safeList(t,"portfolios",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e];i.push({id:this.safeString(t,"uuid"),type:this.safeString(t,"type"),code:void 0,info:t})}return i}parseAccount(e){const t=this.safeBool(e,"active"),s=this.safeString(e,"currency"),i=this.safeDict(e,"currency",{}),r=this.safeString(i,"code",s),a=this.safeString(e,"name"),o=this.safeString(e,"type"),n=a.split(" ");return{id:this.safeString2(e,"id","uuid"),type:void 0!==t?this.safeStringLower(n,1):o,code:this.safeCurrencyCode(r),info:e}}async createDepositAddress(e,t={}){let s=this.safeString(t,"account_id");if(t=this.omit(t,"account_id"),void 0===s){await this.loadAccounts();for(let t=0;t<this.accounts.length;t++){const i=this.accounts[t];if(i.code===e&&"wallet"===i.type){s=i.id;break}}}if(void 0===s)throw new r.ExchangeError(this.id+" createDepositAddress() could not find the account with matching currency code, specify an `account_id` extra param");const i={account_id:s},a=await this.v2PrivatePostAccountsAccountIdAddresses(this.extend(i,t)),o=this.safeDict(a,"data",{});return{currency:e,tag:this.safeString(o,"destination_tag"),address:this.safeString(o,"address"),info:a}}async fetchMySells(e=void 0,t=void 0,s=void 0,i={}){const r=this.prepareAccountRequest(s,i);await this.loadMarkets();const a=this.omit(i,["account_id","accountId"]),o=await this.v2PrivateGetAccountsAccountIdSells(this.extend(r,a));return this.parseTrades(o.data,void 0,t,s)}async fetchMyBuys(e=void 0,t=void 0,s=void 0,i={}){const r=this.prepareAccountRequest(s,i);await this.loadMarkets();const a=this.omit(i,["account_id","accountId"]),o=await this.v2PrivateGetAccountsAccountIdBuys(this.extend(r,a));return this.parseTrades(o.data,void 0,t,s)}async fetchTransactionsWithMethod(e,t=void 0,s=void 0,i=void 0,r={}){let a;[a,r]=await this.prepareAccountRequestWithCurrencyCode(t,i,r),await this.loadMarkets();const o=await this[e](this.extend(a,r));return this.parseTransactions(o.data,void 0,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdWithdrawals",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsWithMethod("v2PrivateGetAccountsAccountIdDeposits",e,t,s,i)}parseTransactionStatus(e){return this.safeString({created:"pending",completed:"ok",canceled:"canceled"},e,e)}parseTransaction(e,t=void 0){let s,i;if("send"===this.safeString(e,"type")){const t=this.safeDict(e,"network",{});s=this.safeDict(t,"transaction_amount",{}),i=this.safeDict(t,"transaction_fee",{})}else s=this.safeDict(e,"subtotal",{}),i=this.safeDict(e,"fee",{});let r=this.parseTransactionStatus(this.safeString(e,"status"));if(void 0===r){r=this.safeBool(e,"committed")?"ok":"pending"}const a=this.safeString(e,"id"),o=this.safeString(s,"currency"),n=this.safeString(i,"currency"),d=this.safeString(e,"created_at"),h=this.safeDict(e,"to",{}),c=this.safeString(h,"address");return{info:e,id:a,txid:a,timestamp:this.parse8601(d),datetime:d,network:void 0,address:c,addressTo:c,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:this.safeString(e,"resource"),amount:this.safeNumber(s,"amount"),currency:this.safeCurrencyCode(o,t),status:r,updated:this.parse8601(this.safeString(e,"updated_at")),fee:{cost:this.safeNumber(i,"amount"),currency:this.safeCurrencyCode(n)}}}parseTrade(e,t=void 0){let s;const i=this.safeDict(e,"total",{}),r=this.safeDict(e,"amount",{}),o=this.safeDict(e,"subtotal",{}),n=this.safeDict(e,"fee",{}),d=this.safeString(e,"product_id");if(void 0!==(t=this.safeMarket(d,t,"-")))s=t.symbol;else{const e=this.safeString(r,"currency"),t=this.safeString(i,"currency");if(void 0!==e&&void 0!==t){s=this.safeCurrencyCode(e)+"/"+this.safeCurrencyCode(t)}}const h=this.safeBool(e,"size_in_quote"),c=this.safeString(e,"price");let l,u=this.safeString(e,"size");h&&(l=u,u=a.Y.stringDiv(u,c));const p=this.safeString(e,"commission"),f=this.safeString(r,"amount",u),m=this.safeString(o,"amount",l);let g,v;g=void 0!==m&&void 0!==f?a.Y.stringDiv(m,f):c,v=void 0!==g&&void 0!==f?a.Y.stringMul(g,f):m;let y=this.safeString(n,"currency");const w=this.safeNumber(n,"amount",this.parseNumber(p));void 0===y&&void 0!==t&&void 0!==w&&(y=t.quote);const b=this.safeStringN(e,["created_at","trade_time","time"]),S=this.safeStringLower2(e,"resource","side"),k=this.safeStringLower(e,"liquidity_indicator");return this.safeTrade({info:e,id:this.safeString2(e,"id","trade_id"),order:this.safeString(e,"order_id"),timestamp:this.parse8601(b),datetime:b,symbol:s,type:void 0,side:"unknown_order_side"===S?void 0:S,takerOrMaker:"unknown_liquidity_indicator"===k?void 0:k,price:g,amount:f,cost:v,fee:{cost:w,currency:this.safeCurrencyCode(y)}})}async fetchMarkets(e={}){return"fetchMarketsV3"===this.safeString(this.options,"fetchMarkets","fetchMarketsV3")?await this.fetchMarketsV3(e):await this.fetchMarketsV2(e)}async fetchMarketsV2(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeDict(t,"currencies",{}),i=this.safeDict(t,"exchangeRates",{}),r=this.safeList(s,"data",[]),a=this.indexBy(r,"id"),o=this.safeDict(this.safeDict(i,"data",{}),"rates",{}),n=Object.keys(o),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeCurrencyCode(t);if("crypto"===(t in a?"fiat":"crypto"))for(let e=0;e<r.length;e++){const i=r[e],a=this.safeString(i,"id"),o=this.safeCurrencyCode(a);d.push({id:t+"-"+a,symbol:s+"/"+o,base:s,quote:o,settle:void 0,baseId:t,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(i,"min_size"),max:void 0}},info:i})}}return d}async fetchMarketsV3(e={}){let t=!1;[t,e]=this.handleOptionAndParams(e,"fetchMarkets","usePrivate",!1);const s=[];t?s.push(this.v3PrivateGetBrokerageProducts(e)):s.push(this.v3PublicGetBrokerageMarketProducts(e)),this.checkRequiredCredentials(!1)&&s.push(this.v3PrivateGetBrokerageTransactionSummary(e));let i=[];try{i=[this.v3PublicGetBrokerageMarketProducts(this.extend(e,{product_type:"FUTURE"})),this.v3PublicGetBrokerageMarketProducts(this.extend(e,{product_type:"FUTURE",contract_expiry_type:"PERPETUAL"}))],this.checkRequiredCredentials(!1)&&(i.push(this.extend(e,{product_type:"FUTURE"})),i.push(this.extend(e,{product_type:"FUTURE",contract_expiry_type:"PERPETUAL"})))}catch(e){i=[]}const r=await Promise.all(s);let a;try{a=await Promise.all(i)}catch(e){a=[]}const o=this.safeDict(r,0,{}),n=this.safeDict(r,1,{}),d=this.safeDict(a,0,{}),h=this.safeDict(a,1,{}),c=this.safeDict(a,2,{}),l=this.safeDict(a,3,{}),u=this.safeDict(n,"fee_tier",{}),p=this.safeDict(c,"fee_tier",{}),f=this.safeDict(l,"fee_tier",{}),m=this.safeList(o,"products",[]),g=[];for(let e=0;e<m.length;e++)g.push(this.parseSpotMarket(m[e],u));const v=this.safeList(d,"products",[]);for(let e=0;e<v.length;e++)g.push(this.parseContractMarket(v[e],p));const y=this.safeList(h,"products",[]);for(let e=0;e<y.length;e++)g.push(this.parseContractMarket(y[e],f));return g}parseSpotMarket(e,t){const s=this.safeString(e,"product_id"),i=this.safeString(e,"base_currency_id"),r=this.safeString(e,"quote_currency_id"),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r),n=this.safeStringLower(e,"product_type"),d=this.safeBool(e,"trading_disabled"),h=this.safeList(this.options,"stablePairs",[]),c=this.safeNumber(this.fees.trading,"taker"),l=this.safeNumber(this.fees.trading,"maker"),u=this.inArray(s,h)?1e-5:this.safeNumber(t,"taker_fee_rate",c),p=this.inArray(s,h)?0:this.safeNumber(t,"maker_fee_rate",l);return this.safeMarketStructure({id:s,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:n,spot:"spot"===n,margin:void 0,swap:!1,future:!1,option:!1,active:!d,contract:!1,linear:void 0,inverse:void 0,taker:u,maker:p,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"base_increment"),price:this.safeNumber2(e,"price_increment","quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"base_min_size"),max:this.safeNumber(e,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"quote_min_size"),max:this.safeNumber(e,"quote_max_size")}},created:void 0,info:e})}parseContractMarket(e,t){const s=this.safeString(e,"product_id"),i=this.safeDict(e,"future_product_details",{}),r=this.safeString(i,"contract_expiry_type"),a=this.safeNumber(i,"contract_size"),o=this.safeString(i,"contract_expiry"),n=this.parse8601(o),d=this.iso8601(n),h="PERPETUAL"===r,c=this.safeString(i,"contract_root_unit"),l=this.safeString(e,"quote_currency_id"),u=this.safeCurrencyCode(c),p=this.safeCurrencyCode(l),f=this.safeBool(e,"is_disabled");let m,g=u+"/"+p;h?(m="swap",g=g+":"+p):(m="future",g=g+":"+p+"-"+this.yymmdd(n));const v=this.safeNumber(t,"taker_fee_rate"),y=this.safeNumber(t,"maker_fee_rate"),w=v||this.parseNumber("0.06"),b=y||this.parseNumber("0.04");return this.safeMarketStructure({id:s,symbol:g,base:u,quote:p,settle:p,baseId:c,quoteId:l,settleId:l,type:m,spot:!1,margin:!1,swap:h,future:!h,option:!1,active:!f,contract:!0,linear:!0,inverse:!1,taker:w,maker:b,contractSize:a,expiry:n,expiryDatetime:d,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"base_increment"),price:this.safeNumber2(e,"price_increment","quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"base_min_size"),max:this.safeNumber(e,"base_max_size")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"quote_min_size"),max:this.safeNumber(e,"quote_max_size")}},created:void 0,info:e})}async fetchCurrenciesFromCache(e={}){const t=this.safeDict(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===s||r-s>i){const s=[this.v2PublicGetCurrencies(e),this.v2PublicGetCurrenciesCrypto(e)],i=await Promise.all(s),a=this.safeDict(i,0,{}),o=this.safeDict(i,1,{}),n=this.safeList(a,"data",[]),d=this.safeList(o,"data",[]),h=await this.v2PublicGetExchangeRates(e);this.options.fetchCurrencies=this.extend(t,{currencies:this.arrayConcat(n,d),exchangeRates:h,timestamp:r})}return this.safeDict(this.options,"fetchCurrencies",{})}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s=this.safeList(t,"currencies",[]),i={},r={},a={};for(let e=0;e<s.length;e++){const t=s[e],o=this.safeString(t,"asset_id"),n=this.safeString2(t,"id","code"),d=this.safeCurrencyCode(n),h=this.safeString(t,"name");if(this.options.networks[d]=h.toLowerCase(),this.options.networksById[d]=h.toLowerCase(),i[d]={info:t,id:n,code:d,type:void 0!==o?"crypto":"fiat",name:this.safeString(t,"name"),active:!0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(t,"min_size"),max:void 0},withdraw:{min:void 0,max:void 0}}},void 0!==o){const e=h.toLowerCase();r[d]=e,a[e]=d}}return this.options.networks=this.extend(r,this.options.networks),this.options.networksById=this.extend(a,this.options.networksById),i}async fetchTickers(e=void 0,t={}){return"fetchTickersV3"===this.safeString(this.options,"fetchTickers","fetchTickersV3")?await this.fetchTickersV3(e,t):await this.fetchTickersV2(e,t)}async fetchTickersV2(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v2PublicGetExchangeRates(this.extend({},t)),i=this.safeDict(s,"data",{}),r=this.safeDict(i,"rates",{}),a=this.safeString(i,"currency"),o={},n=Object.keys(r);for(let e=0;e<n.length;e++){const t=n[e],s=t+"-"+a,i=this.safeMarket(s,void 0,"-");o[i.symbol]=this.parseTicker(r[t],i)}return this.filterByArrayTickers(o,"symbol",e)}async fetchTickersV3(e=void 0,t={}){await this.loadMarkets();const s={};let i,r;void 0!==(e=this.marketSymbols(e))&&(s.product_ids=this.marketIds(e)),[i,t]=this.handleMarketTypeAndParams("fetchTickers",this.getMarketFromSymbols(e),t,"default"),void 0!==i&&"default"!==i&&(s.product_type="swap"===i?"FUTURE":"SPOT");let a=!1;[a,t]=this.handleOptionAndParams(t,"fetchTickers","usePrivate",!1),r=a?await this.v3PrivateGetBrokerageProducts(this.extend(s,t)):await this.v3PublicGetBrokerageMarketProducts(this.extend(s,t));const o=this.safeList(r,"products",[]),n={};for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"product_id"),i=this.safeMarket(s,void 0,"-");n[i.symbol]=this.parseTicker(t,i)}return this.filterByArrayTickers(n,"symbol",e)}async fetchTicker(e,t={}){return"fetchTickerV3"===this.safeString(this.options,"fetchTicker","fetchTickerV3")?await this.fetchTickerV3(e,t):await this.fetchTickerV2(e,t)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.extend({symbol:s.id},t),r=await this.v2PublicGetPricesSymbolSpot(i),a=await this.v2PublicGetPricesSymbolBuy(i),o=await this.v2PublicGetPricesSymbolSell(i),n=this.safeDict(r,"data",{}),d=this.safeDict(a,"data",{}),h=this.safeDict(o,"data",{}),c={bid:this.safeNumber(h,"amount"),ask:this.safeNumber(d,"amount"),price:this.safeNumber(n,"amount")};return this.parseTicker(c,s)}async fetchTickerV3(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_id:s.id,limit:1};let r,a=!1;[a,t]=this.handleOptionAndParams(t,"fetchTicker","usePrivate",!1),r=a?await this.v3PrivateGetBrokerageProductsProductIdTicker(this.extend(i,t)):await this.v3PublicGetBrokerageMarketProductsProductIdTicker(this.extend(i,t));const o=this.safeList(r,"trades",[]),n=this.parseTicker(o[0],s);return n.bid=this.safeNumber(r,"best_bid"),n.ask=this.safeNumber(r,"best_ask"),n}parseTicker(e,t=void 0){let s,i,r=this.safeNumber(e,"bid"),a=this.safeNumber(e,"ask");if("bids"in e){const t=this.safeList(e,"bids",[]),o=this.safeList(e,"asks",[]);r=this.safeNumber(t[0],"price"),s=this.safeNumber(t[0],"size"),a=this.safeNumber(o[0],"price"),i=this.safeNumber(o[0],"size")}const o=this.safeString(e,"product_id"),n=this.safeNumber(e,"price"),d=this.safeString(e,"time");return this.safeTicker({symbol:this.safeSymbol(o,t),timestamp:this.parse8601(d),datetime:d,bid:r,ask:a,last:n,high:void 0,low:void 0,bidVolume:s,askVolume:i,vwap:void 0,open:void 0,close:n,previousClose:void 0,change:void 0,percentage:this.safeNumber(e,"price_percentage_change_24h"),average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}parseCustomBalance(e,t={}){const s=this.safeList2(e,"data","accounts",[]),i=this.safeList(t,"type",this.options.accounts),r=this.safeList(t,"type",this.options.v3Accounts),o={info:e};for(let e=0;e<s.length;e++){const t=s[e],n=this.safeString(t,"type");if(this.inArray(n,i)){const e=this.safeDict(t,"balance");if(void 0!==e){const t=this.safeString(e,"currency"),s=this.safeCurrencyCode(t),i=this.safeString(e,"amount"),r=i;let n=this.safeDict(o,s);void 0===n?(n=this.account(),n.free=r,n.total=i):(n.free=a.Y.stringAdd(n.free,i),n.total=a.Y.stringAdd(n.total,i)),o[s]=n}}else if(this.inArray(n,r)){const e=this.safeDict(t,"available_balance"),s=this.safeDict(t,"hold");if(void 0!==e&&void 0!==s){const t=this.safeString(e,"currency"),i=this.safeCurrencyCode(t),r=this.safeString(s,"value"),n=this.safeString(e,"value"),d=a.Y.stringAdd(r,n);let h=this.safeDict(o,i);void 0===h?(h=this.account(),h.free=n,h.used=r,h.total=d):(h.free=a.Y.stringAdd(h.free,n),h.used=a.Y.stringAdd(h.used,r),h.total=a.Y.stringAdd(h.total,d)),o[i]=h}}}return this.safeBalance(o)}async fetchBalance(e={}){await this.loadMarkets();const t={};let s;const i=this.safeBool(e,"v3",!1);let r;e=this.omit(e,["v3"]),[r,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const a=this.safeString(this.options,"fetchBalance","v3PrivateGetBrokerageAccounts");return"future"===r?s=await this.v3PrivateGetBrokerageCfmBalanceSummary(this.extend(t,e)):i||"v3PrivateGetBrokerageAccounts"===a?(t.limit=250,s=await this.v3PrivateGetBrokerageAccounts(this.extend(t,e))):(t.limit=100,s=await this.v2PrivateGetAccounts(this.extend(t,e))),e.type=r,this.parseCustomBalance(s,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o=!1;if([o,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),o)return await this.fetchPaginatedCallCursor("fetchLedger",e,t,s,i,"next_starting_after","starting_after",void 0,100);void 0!==e&&(r=this.currency(e)),[a,i]=await this.prepareAccountRequestWithCurrencyCode(e,s,i);const n=await this.v2PrivateGetAccountsAccountIdTransactions(this.extend(a,i)),d=this.parseLedger(n.data,r,t,s),h=d.length;if(0===h)return d;const c=h-1,l=this.safeDict(d,c),u=this.safeDict(n,"pagination",{}),p=this.safeString(u,"next_starting_after");return void 0!==p&&""!==p&&(l.next_starting_after=p,d[c]=l),d}parseLedgerEntryStatus(e){return this.safeString({completed:"ok"},e,e)}parseLedgerEntryType(e){return this.safeString({buy:"trade",sell:"trade",fiat_deposit:"transaction",fiat_withdrawal:"transaction",exchange_deposit:"transaction",exchange_withdrawal:"transaction",send:"transaction",pro_deposit:"transaction",pro_withdrawal:"transaction"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeDict(e,"amount",{});let i,r=this.safeString(s,"amount");a.Y.stringLt(r,"0")?(i="out",r=a.Y.stringNeg(r)):i="in";const o=this.safeString(s,"currency"),n=this.safeCurrencyCode(o,t);let d;const h=this.safeDict(e,"network",{}),c=this.safeDict(h,"transaction_fee");if(void 0!==c){const e=this.safeString(c,"currency"),s=this.safeCurrencyCode(e,t);d={cost:this.safeNumber(c,"amount"),currency:s}}const l=this.parse8601(this.safeString(e,"created_at")),u=this.safeString(e,"id"),p=this.parseLedgerEntryType(this.safeString(e,"type")),f=this.parseLedgerEntryStatus(this.safeString(e,"status")),m=this.safeString(e,"resource_path");let g;if(void 0!==m){const e=m.split("/");e.length>3&&(g=e[3])}return{info:e,id:u,timestamp:l,datetime:this.iso8601(l),direction:i,account:g,referenceId:void 0,referenceAccount:void 0,type:p,currency:n,amount:this.parseNumber(r),before:void 0,after:void 0,status:f,fee:d}}async findAccountId(e,t={}){await this.loadMarkets(),await this.loadAccounts(!1,t);for(let t=0;t<this.accounts.length;t++){const s=this.accounts[t];if(s.code===e)return s.id}}prepareAccountRequest(e=void 0,t={}){const s=this.safeString2(t,"account_id","accountId");if(void 0===s)throw new r.ArgumentsRequired(this.id+" prepareAccountRequest() method requires an account_id (or accountId) parameter");const i={account_id:s};return void 0!==e&&(i.limit=e),i}async prepareAccountRequestWithCurrencyCode(e=void 0,t=void 0,s={}){let i=this.safeString2(s,"account_id","accountId");if(s=this.omit(s,["account_id","accountId"]),void 0===i){if(void 0===e)throw new r.ArgumentsRequired(this.id+" prepareAccountRequestWithCurrencyCode() method requires an account_id (or accountId) parameter OR a currency code argument");if(i=await this.findAccountId(e,s),void 0===i)throw new r.ExchangeError(this.id+" prepareAccountRequestWithCurrencyCode() could not find account id for "+e)}const a={account_id:i};return void 0!==t&&(a.limit=t),[a,s]}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e);let h={client_order_id:this.safeString(this.options,"brokerId","ccxt")+"-"+this.uuid(),product_id:d.id,side:s.toUpperCase()};const c=this.safeNumberN(n,["stopPrice","stop_price","triggerPrice"]),l=this.safeNumber(n,"stopLossPrice"),u=this.safeNumber(n,"takeProfitPrice"),p=void 0!==c,f=void 0!==l,m=void 0!==u,g=this.safeString(n,"timeInForce"),v="PO"===g||this.safeBool2(n,"postOnly","post_only",!1),y=this.safeString(n,"end_time");let w=this.safeString(n,"stop_direction");if("limit"===t)if(p)if(void 0===w&&(w="buy"===s?"STOP_DIRECTION_STOP_DOWN":"STOP_DIRECTION_STOP_UP"),"GTD"===g||void 0!==y){if(void 0===y)throw new r.ExchangeError(this.id+" createOrder() requires an end_time parameter for a GTD order");h.order_configuration={stop_limit_stop_limit_gtd:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o),stop_price:this.priceToPrecision(e,c),stop_direction:w,end_time:y}}}else h.order_configuration={stop_limit_stop_limit_gtc:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o),stop_price:this.priceToPrecision(e,c),stop_direction:w}};else if(f||m){let t;f?(void 0===w&&(w="buy"===s?"STOP_DIRECTION_STOP_UP":"STOP_DIRECTION_STOP_DOWN"),t=this.priceToPrecision(e,l)):(void 0===w&&(w="buy"===s?"STOP_DIRECTION_STOP_DOWN":"STOP_DIRECTION_STOP_UP"),t=this.priceToPrecision(e,u)),h.order_configuration={stop_limit_stop_limit_gtc:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o),stop_price:t,stop_direction:w}}}else if("GTD"===g||void 0!==y){if(void 0===y)throw new r.ExchangeError(this.id+" createOrder() requires an end_time parameter for a GTD order");h.order_configuration={limit_limit_gtd:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o),end_time:y,post_only:v}}}else h.order_configuration="IOC"===g?{sor_limit_ioc:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o)}}:"FOK"===g?{limit_limit_fok:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o)}}:{limit_limit_gtc:{base_size:this.amountToPrecision(e,i),limit_price:this.priceToPrecision(e,o),post_only:v}};else{if(p||f||m)throw new r.NotSupported(this.id+" createOrder() only stop limit orders are supported");if(d.spot&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);h.order_configuration={market_market_ioc:{quote_size:t}}}else h.order_configuration={market_market_ioc:{base_size:this.amountToPrecision(e,i)}}}const b=this.safeString(n,"marginMode");void 0!==b&&("isolated"===b?h.margin_type="ISOLATED":"cross"===b&&(h.margin_type="CROSS")),n=this.omit(n,["timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","stopPrice","stop_price","stopDirection","stop_direction","clientOrderId","postOnly","post_only","end_time","marginMode"]);let S;this.safeBool2(n,"preview","test",!1)?(n=this.omit(n,["preview","test"]),h=this.omit(h,"client_order_id"),S=await this.v3PrivatePostBrokerageOrdersPreview(this.extend(h,n))):S=await this.v3PrivatePostBrokerageOrders(this.extend(h,n));if(!0!==this.safeBool(S,"success")){const e=this.safeDict(S,"error_response"),t=this.safeString(e,"error"),s=this.safeString(e,"message");if(void 0!==e)throw this.throwExactlyMatchedException(this.exceptions.exact,t,s),this.throwBroadlyMatchedException(this.exceptions.broad,t,s),new r.ExchangeError(s)}const k=this.safeDict(S,"success_response",{});return this.parseOrder(k,d)}parseOrder(e,t=void 0){const s=this.safeString(e,"product_id"),i=this.safeSymbol(s,t,"-");void 0!==i&&(t=this.safeMarket(i,t));const r=this.safeDict(e,"order_configuration",{}),a=this.safeDict(r,"limit_limit_gtc"),o=this.safeDict(r,"limit_limit_gtd"),n=this.safeDict(r,"sor_limit_ioc"),d=this.safeDict(r,"stop_limit_stop_limit_gtc"),h=this.safeDict(r,"stop_limit_stop_limit_gtd"),c=this.safeDict(r,"market_market_ioc"),l=void 0!==d||void 0!==h;let u,p,f,m;if(void 0!==a||void 0!==o||void 0!==n){let e;e=void 0!==a?a:void 0!==o?o:n,u=this.safeString(e,"limit_price"),p=this.safeString(e,"base_size"),f=this.safeBool(e,"post_only")}else if(l){const e=void 0!==d?d:h;u=this.safeString(e,"limit_price"),p=this.safeString(e,"base_size"),f=this.safeBool(e,"post_only"),m=this.safeString(e,"stop_price")}else p=this.safeString(c,"base_size");const g=this.safeString(e,"created_time");let v;return void 0!==this.safeString(e,"total_fees")&&void 0!==t&&(v=t.quote),this.safeOrder({info:e,id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:this.parse8601(g),datetime:g,lastTradeTimestamp:void 0,symbol:i,type:this.parseOrderType(this.safeString(e,"order_type")),timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:f,side:this.safeStringLower(e,"side"),price:u,stopPrice:m,triggerPrice:m,amount:p,filled:this.safeString(e,"filled_size"),remaining:void 0,cost:void 0,average:this.safeString(e,"average_filled_price"),status:this.parseOrderStatus(this.safeString(e,"status")),fee:{cost:this.safeString(e,"total_fees"),currency:v},trades:void 0},t)}parseOrderStatus(e){const t={OPEN:"open",FILLED:"closed",CANCELLED:"canceled",EXPIRED:"canceled",FAILED:"canceled",UNKNOWN_ORDER_STATUS:void 0};return this.safeString(t,e,e)}parseOrderType(e){if("UNKNOWN_ORDER_TYPE"===e)return;return this.safeString({MARKET:"market",LIMIT:"limit",STOP:"limit",STOP_LIMIT:"limit"},e,e)}parseTimeInForce(e){const t={GOOD_UNTIL_CANCELLED:"GTC",GOOD_UNTIL_DATE_TIME:"GTD",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK",UNKNOWN_TIME_IN_FORCE:void 0};return this.safeString(t,e,e)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.cancelOrders([e],t,s);return this.safeDict(i,0,{})}async cancelOrders(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const a={order_ids:e},o=await this.v3PrivatePostBrokerageOrdersBatchCancel(this.extend(a,s)),n=this.safeList(o,"results",[]);for(let e=0;e<n.length;e++){if(!0!==this.safeBool(n[e],"success"))throw new r.BadRequest(this.id+" cancelOrders() has failed, check your arguments and parameters")}return this.parseOrders(n,i)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={order_id:e};void 0!==r&&(d.size=this.amountToPrecision(t,r)),void 0!==a&&(d.price=this.priceToPrecision(t,a));let h;return this.safeBool2(o,"preview","test",!1)?(o=this.omit(o,["preview","test"]),h=await this.v3PrivatePostBrokerageOrdersEditPreview(this.extend(d,o))):h=await this.v3PrivatePostBrokerageOrdersEdit(this.extend(d,o)),this.parseOrder(h,n)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={order_id:e},a=await this.v3PrivateGetBrokerageOrdersHistoricalOrderId(this.extend(r,s)),o=this.safeDict(a,"order",{});return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=100,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),a)return await this.fetchPaginatedCallCursor("fetchOrders",e,t,s,i,"cursor","cursor",void 0,1e3);void 0!==e&&(r=this.market(e));const o={};void 0!==r&&(o.product_id=r.id),void 0!==s&&(o.limit=s),void 0!==t&&(o.start_date=this.iso8601(t));const n=this.safeIntegerN(i,["until"]);void 0!==n&&(i=this.omit(i,["until"]),o.end_date=this.iso8601(n));const d=await this.v3PrivateGetBrokerageOrdersHistoricalBatch(this.extend(o,i)),h=this.safeList(d,"orders",[]),c=this.safeDict(h,0),l=this.safeString(d,"cursor");return void 0!==l&&""!==l&&(c.cursor=l,h[0]=c),this.parseOrders(h,r,t,s)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={order_status:e};void 0!==a&&(o.product_id=a.id),void 0===i&&(i=100),o.limit=i,void 0!==s&&(o.start_date=this.iso8601(s));const n=this.safeIntegerN(r,["until"]);void 0!==n&&(r=this.omit(r,["until"]),o.end_date=this.iso8601(n));const d=await this.v3PrivateGetBrokerageOrdersHistoricalBatch(this.extend(o,r)),h=this.safeList(d,"orders",[]),c=this.safeDict(h,0),l=this.safeString(d,"cursor");return void 0!==l&&""!==l&&(c.cursor=l,h[0]=c),this.parseOrders(h,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r?await this.fetchPaginatedCallCursor("fetchOpenOrders",e,t,s,i,"cursor","cursor",void 0,100):await this.fetchOrdersByStatus("OPEN",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r?await this.fetchPaginatedCallCursor("fetchClosedOrders",e,t,s,i,"cursor","cursor",void 0,100):await this.fetchOrdersByStatus("FILLED",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("CANCELLED",e,t,s,i)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();i=void 0===i?300:Math.min(i,300);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,299);const n=this.market(e),d={product_id:n.id,granularity:this.safeString(this.timeframes,t,t)},h=this.safeIntegerN(r,["until","end"]);r=this.omit(r,["until"]);const c=i*this.parseTimeframe(t);let l,u;if(void 0!==s)l=this.numberToString(this.parseToInt(s/1e3));else{const e=this.seconds().toString();l=a.Y.stringSub(e,c.toString())}d.start=l,d.end=void 0!==h?this.numberToString(this.parseToInt(h/1e3)):a.Y.stringAdd(l,c.toString());let p=!1;[p,r]=this.handleOptionAndParams(r,"fetchOHLCV","usePrivate",!1),u=p?await this.v3PrivateGetBrokerageProductsProductIdCandles(this.extend(d,r)):await this.v3PublicGetBrokerageMarketProductsProductIdCandles(this.extend(d,r));const f=this.safeList(u,"candles",[]);return this.parseOHLCVs(f,n,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"start"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e),o={product_id:a.id};let n,d;if(void 0!==t&&(o.start=this.numberToString(this.parseToInt(t/1e3))),void 0!==s&&(o.limit=Math.min(s,1e3)),[n,i]=this.handleOptionAndParams(i,"fetchTrades","until"),void 0!==n)o.end=this.numberToString(this.parseToInt(n/1e3));else if(void 0!==t)throw new r.ArgumentsRequired(this.id+" fetchTrades() requires a `until` parameter when you use `since` argument");let h=!1;[h,i]=this.handleOptionAndParams(i,"fetchTrades","usePrivate",!1),d=h?await this.v3PrivateGetBrokerageProductsProductIdTicker(this.extend(o,i)):await this.v3PublicGetBrokerageMarketProductsProductIdTicker(this.extend(o,i));const c=this.safeList(d,"trades",[]);return this.parseTrades(c,a,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallCursor("fetchMyTrades",e,t,s,i,"cursor","cursor",void 0,100);void 0!==e&&(r=this.market(e));const o={};void 0!==r&&(o.product_id=r.id),void 0!==s&&(o.limit=s),void 0!==t&&(o.start_sequence_timestamp=this.iso8601(t));const n=this.safeIntegerN(i,["until"]);void 0!==n&&(i=this.omit(i,["until"]),o.end_sequence_timestamp=this.iso8601(n));const d=await this.v3PrivateGetBrokerageOrdersHistoricalFills(this.extend(o,i)),h=this.safeList(d,"fills",[]),c=this.safeDict(h,0),l=this.safeString(d,"cursor");return void 0!==l&&""!==l&&(c.cursor=l,h[0]=c),this.parseTrades(h,r,t,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={product_id:this.market(e).id};let r;void 0!==t&&(i.limit=t);let a=!1;[a,s]=this.handleOptionAndParams(s,"fetchOrderBook","usePrivate",!1),r=a?await this.v3PrivateGetBrokerageProductBook(this.extend(i,s)):await this.v3PublicGetBrokerageMarketProductBook(this.extend(i,s));const o=this.safeDict(r,"pricebook",{}),n=this.safeString(o,"time"),d=this.parse8601(n);return this.parseOrderBook(o,e,d,"bids","asks","price","size")}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s={};void 0!==(e=this.marketSymbols(e))&&(s.product_ids=this.marketIds(e));const i=await this.v3PrivateGetBrokerageBestBidAsk(this.extend(s,t)),r=this.safeList(i,"pricebooks",[]);return this.parseTickers(r,e)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);let n=this.safeString2(a,"account_id","accountId");if(a=this.omit(a,["account_id","accountId"]),void 0===n){if(void 0===e)throw new r.ArgumentsRequired(this.id+" withdraw() requires an account_id (or accountId) parameter OR a currency code argument");if(n=await this.findAccountId(e,a),void 0===n)throw new r.ExchangeError(this.id+" withdraw() could not find account id for "+e)}const d={account_id:n,type:"send",to:s,amount:t,currency:o.id};void 0!==i&&(d.destination_tag=i);const h=await this.v2PrivatePostAccountsAccountIdTransactions(this.extend(d,a)),c=this.safeDict(h,"data",{});return this.parseTransaction(c,o)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e);let i;[i,t]=await this.prepareAccountRequestWithCurrencyCode(s.code);const r=await this.v2PrivateGetAccountsAccountIdAddresses(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.parseDepositAddresses(a,void 0,!1);return this.indexBy(o,"network")}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");this.checkAddress(s);const i=this.safeString(e,"network"),r=this.safeCurrencyCode(void 0,t),a=this.safeString(e,"address_label").split(" "),o=this.safeString(a,0),n=this.safeDict(e,"address_info");return{info:e,currency:this.safeCurrencyCode(o,t),address:s,tag:this.safeString(n,"destination_tag"),network:this.networkIdToCode(i,r)}}async deposit(e,t,s,i={}){await this.loadMarkets();let a=this.safeString2(i,"account_id","accountId");if(i=this.omit(i,["account_id","accountId"]),void 0===a){if(void 0===e)throw new r.ArgumentsRequired(this.id+" deposit() requires an account_id (or accountId) parameter OR a currency code argument");if(a=await this.findAccountId(e,i),void 0===a)throw new r.ExchangeError(this.id+" deposit() could not find account id for "+e)}const o={account_id:a,amount:this.numberToString(t),currency:e.toUpperCase(),payment_method:s},n=await this.v2PrivatePostAccountsAccountIdDeposits(this.extend(o,i)),d=this.safeDict(n,"data",{});return this.parseTransaction(d)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();let i=this.safeString2(s,"account_id","accountId");if(s=this.omit(s,["account_id","accountId"]),void 0===i){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchDeposit() requires an account_id (or accountId) parameter OR a currency code argument");if(i=await this.findAccountId(t,s),void 0===i)throw new r.ExchangeError(this.id+" fetchDeposit() could not find account id for "+t)}const a={account_id:i,deposit_id:e},o=await this.v2PrivateGetAccountsAccountIdDepositsDepositId(this.extend(a,s)),n=this.safeDict(o,"data",{});return this.parseTransaction(n)}async fetchConvertQuote(e,t,s=void 0,i={}){await this.loadMarkets();const r={from_account:e,to_account:t,amount:this.numberToString(s)},a=await this.v3PrivatePostBrokerageConvertQuote(this.extend(r,i)),o=this.safeDict(a,"trade",{});return this.parseConversion(o)}async createConvertTrade(e,t,s,i=void 0,r={}){await this.loadMarkets();const a={trade_id:e,from_account:t,to_account:s},o=await this.v3PrivatePostBrokerageConvertTradeTradeId(this.extend(a,r)),n=this.safeDict(o,"trade",{});return this.parseConversion(n)}async fetchConvertTrade(e,t=void 0,s={}){if(await this.loadMarkets(),void 0===t)throw new r.ArgumentsRequired(this.id+" fetchConvertTrade() requires a code argument");const i=this.safeString(s,"toCode");if(void 0===i)throw new r.ArgumentsRequired(this.id+" fetchConvertTrade() requires a toCode parameter");s=this.omit(s,"toCode");const a={trade_id:e,from_account:t,to_account:i},o=await this.v3PrivateGetBrokerageConvertTradeTradeId(this.extend(a,s)),n=this.safeDict(o,"trade",{});return this.parseConversion(n)}parseConversion(e,t=void 0,s=void 0){const i=this.safeString(e,"source_currency"),r=this.safeCurrencyCode(i,t),a=this.safeString(e,"target_currency"),o=this.safeCurrencyCode(a,s),n=this.safeDict(e,"user_entered_amount"),d=this.safeDict(e,"total_fee"),h=this.safeDict(d,"amount");return{info:e,timestamp:void 0,datetime:void 0,id:this.safeString(e,"id"),fromCurrency:r,fromAmount:this.safeNumber(n,"value"),toCurrency:o,toAmount:void 0,price:void 0,fee:this.safeNumber(h,"value")}}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(!i.future)throw new r.NotSupported(this.id+" closePosition() only supported for futures markets");const a=this.safeString2(s,"client_order_id","clientOrderId");s=this.omit(s,"clientOrderId");const o={product_id:i.id};if(void 0===a)throw new r.ArgumentsRequired(this.id+" closePosition() requires a clientOrderId parameter");o.client_order_id=a;const n=await this.v3PrivatePostBrokerageOrdersClosePosition(this.extend(o,s)),d=this.safeDict(n,"success_response",{});return this.parseOrder(d)}async fetchPositions(e=void 0,t={}){let s,i,a;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))&&(s=this.market(e[0])),[i,t]=this.handleMarketTypeAndParams("fetchPositions",s,t),"future"===i)a=await this.v3PrivateGetBrokerageCfmPositions(t);else{let e;if([e,t]=this.handleOptionAndParams(t,"fetchPositions","portfolio"),void 0===e)throw new r.ArgumentsRequired(this.id+' fetchPositions() requires a "portfolio" value in params (eg: dbcb91e7-2bc9-515), or set as exchange.options["portfolio"]. You can get a list of portfolios with fetchPortfolios()');const s={portfolio_uuid:e};a=await this.v3PrivateGetBrokerageIntxPositionsPortfolioUuid(this.extend(s,t))}const o=this.safeList(a,"positions",[]);return this.parsePositions(o,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.future){const e=this.safeString(s,"product_id");if(void 0===e)throw new r.ArgumentsRequired(this.id+' fetchPosition() requires a "product_id" in params');const a={product_id:e};i=await this.v3PrivateGetBrokerageCfmPositionsProductId(this.extend(a,t))}else{let e;if([e,t]=this.handleOptionAndParams(t,"fetchPositions","portfolio"),void 0===e)throw new r.ArgumentsRequired(this.id+' fetchPosition() requires a "portfolio" value in params (eg: dbcb91e7-2bc9-515), or set as exchange.options["portfolio"]. You can get a list of portfolios with fetchPortfolios()');const a={symbol:s.id,portfolio_uuid:e};i=await this.v3PrivateGetBrokerageIntxPositionsPortfolioUuidSymbol(this.extend(a,t))}const a=this.safeDict(i,"position",{});return this.parsePosition(a,s)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol","");t=this.safeMarket(s,t);const i=this.safeString(e,"margin_type");let r;void 0!==i&&(r="MARGIN_TYPE_CROSS"===i?"cross":"isolated");const a=this.safeDict(e,"position_notional",{}),o="POSITION_SIDE_LONG"===this.safeString(e,"position_side")?"long":"short",n=this.safeDict(e,"unrealized_pnl",{}),d=this.safeDict(e,"liquidation_price",{}),h=this.safeNumber(d,"value"),c=this.safeDict(e,"vwap",{}),l=this.safeDict(e,"portfolio_summary",{});return this.safePosition({info:e,id:this.safeString(e,"product_id"),symbol:this.safeSymbol(s,t),notional:this.safeNumber(a,"value"),marginMode:r,liquidationPrice:h,entryPrice:this.safeNumber(c,"value"),unrealizedPnl:this.safeNumber(n,"value"),realizedPnl:void 0,percentage:void 0,contracts:this.safeNumber(e,"net_size"),contractSize:t.contractSize,markPrice:void 0,lastPrice:void 0,side:o,hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:this.safeNumber(l,"collateral"),initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchTradingFees(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e);const s="spot"===t,i={product_type:s?"SPOT":"FUTURE"},r=await this.v3PrivateGetBrokerageTransactionSummary(this.extend(i,e)),a=this.safeDict(r,"fee_tier",{}),o=this.safeNumber(a,"taker_fee_rate"),n=this.safeNumber(a,"maker_fee_rate"),d={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],i=this.market(t);(s&&i.spot||!s&&!i.spot)&&(d[t]={info:r,symbol:t,maker:o,taker:n,percentage:!0})}return d}createAuthToken(e,t=void 0,s=void 0){let i;if(void 0!==s){i=t+" "+s.replace("https://","");const e=i.indexOf("?");e>0&&(i=i.slice(0,e))}const r=this.randomBytes(16),a={aud:["retail_rest_api_proxy"],iss:"coinbase-cloud",nbf:e,exp:e+120,sub:this.apiKey,iat:e};void 0!==i&&(a.uri=i);return(0,d.a)(a,this.encode(this.secret),n.s,!1,{kid:this.apiKey,nonce:r,alg:"ES256"})}sign(e,t=[],s="GET",i={},a=void 0,o=void 0){const d=t[0],h="private"===t[1],c="v3"===d;let l="/"+(c?"api/v3":"v2")+"/"+this.implodeParams(e,i);const u=this.omit(i,this.extractParams(e)),p=l;"GET"===s&&Object.keys(u).length&&(l+="?"+this.urlencodeWithArrayRepeat(u));const f=this.urls.api.rest+l;if(h){const e=this.safeString(this.headers,"Authorization");let t;if(void 0!==e)t=e;else if(this.token&&!this.checkRequiredCredentials(!1))t="Bearer "+this.token;else{this.checkRequiredCredentials();const e=this.seconds();let i="";"GET"!==s?Object.keys(u).length&&(i=o=this.json(u)):c||Object.keys(u).length&&(i+="?"+this.urlencode(u));if(this.apiKey.indexOf("organizations/")>=0||this.secret.startsWith("-----BEGIN")){if(this.apiKey.startsWith("-----BEGIN"))throw new r.ArgumentsRequired(this.id+" apiKey should contain the name (eg: organizations/3b910e93....) and not the public key");t="Bearer "+this.createAuthToken(e,s,f)}else{const e=this.seconds().toString(),t=e+s+p+i,r=this.hmac(this.encode(t),this.encode(this.secret),n.s);a={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":r,"CB-ACCESS-TIMESTAMP":e,"Content-Type":"application/json"}}}void 0!==t&&(a={Authorization:t,"Content-Type":"application/json"},"GET"!==s&&Object.keys(u).length&&(o=this.json(u)))}return{url:f,method:s,body:o,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.id+" "+o;let l=this.safeString(n,"error");if(void 0!==l){const e=this.safeString(n,"error_description");throw this.throwExactlyMatchedException(this.exceptions.exact,l,c),this.throwBroadlyMatchedException(this.exceptions.broad,e,c),new r.ExchangeError(c)}const u=this.safeList(n,"errors");if(void 0!==u&&Array.isArray(u)){if(u.length>0){l=this.safeString(u[0],"id");const e=this.safeString(u[0],"message");if(void 0!==l)throw this.throwExactlyMatchedException(this.exceptions.exact,l,c),this.throwBroadlyMatchedException(this.exceptions.broad,e,c),new r.ExchangeError(c)}}const p=this.options.advanced;if(!("data"in n)&&!p)throw new r.ExchangeError(this.id+" failed due to a malformed response "+this.json(n))}}},3278:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(7504);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinbaseadvanced",name:"Coinbase Advanced",alias:!0})}}},4293:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1552),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinbaseexchange",name:"Coinbase Exchange",countries:["US"],rateLimit:100,userAgent:this.userAgents.chrome,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingRate:!1,fetchLedger:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:"emulated",fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"6h":21600,"1d":86400},hostname:"exchange.coinbase.com",urls:{test:{public:"https://api-public.sandbox.exchange.coinbase.com",private:"https://api-public.sandbox.exchange.coinbase.com"},logo:"https://github.com/ccxt/ccxt/assets/43336371/34a65553-88aa-4a38-a714-064bd228b97e",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},www:"https://coinbase.com/",doc:"https://docs.cloud.coinbase.com/exchange/docs/",fees:["https://docs.pro.coinbase.com/#fees","https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:["currencies","products","products/{id}","products/{id}/book","products/{id}/candles","products/{id}/stats","products/{id}/ticker","products/{id}/trades","time","products/spark-lines"]},private:{get:["address-book","accounts","accounts/{id}","accounts/{id}/holds","accounts/{id}/ledger","accounts/{id}/transfers","coinbase-accounts","fills","funding","fees","margin/profile_information","margin/buying_power","margin/withdrawal_power","margin/withdrawal_power_all","margin/exit_plan","margin/liquidation_history","margin/position_refresh_amounts","margin/status","oracle","orders","orders/{id}","orders/client:{client_oid}","otc/orders","payment-methods","position","profiles","profiles/{id}","reports/{report_id}","transfers","transfers/{transfer_id}","users/self/exchange-limits","users/self/hold-balances","users/self/trailing-volume","withdrawals/fee-estimate","conversions/{conversion_id}","conversions/fees"],post:["conversions","deposits/coinbase-account","deposits/payment-method","coinbase-accounts/{id}/addresses","funding/repay","orders","position/close","profiles/margin-transfer","profiles/transfer","reports","withdrawals/coinbase","withdrawals/coinbase-account","withdrawals/crypto","withdrawals/payment-method"],delete:["orders","orders/client:{client_oid}","orders/{id}"]}},commonCurrencies:{CGLD:"CELO"},precisionMode:o.kb,fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.004"),taker:this.parseNumber("0.006")},funding:{tierBased:!1,percentage:!1,withdraw:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:25},deposit:{BCH:0,BTC:0,LTC:0,ETH:0,EUR:.15,USD:10}}},exceptions:{exact:{"Insufficient funds":r.InsufficientFunds,NotFound:r.OrderNotFound,"Invalid API Key":r.AuthenticationError,"invalid signature":r.AuthenticationError,"Invalid Passphrase":r.AuthenticationError,"Invalid order id":r.InvalidOrder,"Private rate limit exceeded":r.RateLimitExceeded,"Trading pair not available":r.PermissionDenied,"Product not found":r.InvalidOrder},broad:{"Order already done":r.OrderNotFound,"order not found":r.OrderNotFound,"price too small":r.InvalidOrder,"price too precise":r.InvalidOrder,"under maintenance":r.OnMaintenance,"size is too small":r.InvalidOrder,"Cancel only mode":r.OnMaintenance}}})}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"id"),a=this.safeString(i,"name"),o=this.safeCurrencyCode(r),n=this.safeValue(i,"details",{}),d="online"===this.safeString(i,"status");s[o]={id:r,code:o,info:i,type:this.safeString(n,"type"),name:a,active:d,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.safeNumber(i,"max_precision"),limits:{amount:{min:this.safeNumber(n,"min_size"),max:void 0},withdraw:{min:this.safeNumber(n,"min_withdrawal_amount"),max:void 0}},networks:{}}}return s}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"id"),[a,o]=r.split("-"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeString(i,"status");s.push(this.extend(this.fees.trading,{id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:this.safeValue(i,"margin_enabled"),swap:!1,future:!1,option:!1,active:"online"===h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(i,"base_increment"),price:this.safeNumber(i,"quote_increment")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(i,"min_market_funds"),max:void 0}},created:void 0,info:i}))}return s}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseAccounts(t,e)}parseAccount(e){const t=this.safeString(e,"currency");return{id:this.safeString(e,"id"),type:void 0,code:this.safeCurrencyCode(t),info:e}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.used=this.safeString(i,"hold"),o.total=this.safeString(i,"balance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={id:this.marketId(e),level:2},r=await this.publicGetProductsIdBook(this.extend(i,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"sequence"),a}parseTicker(e,t=void 0){let s,i,r,a,o,n,d,h;const c=void 0===t?void 0:t.symbol;return Array.isArray(e)?(a=this.safeString(e,4),s=this.milliseconds()):(s=this.parse8601(this.safeValue(e,"time")),i=this.safeString(e,"bid"),r=this.safeString(e,"ask"),o=this.safeString(e,"high"),n=this.safeString(e,"low"),d=this.safeString(e,"open"),a=this.safeString2(e,"price","last"),h=this.safeString(e,"volume")),this.safeTicker({symbol:c,timestamp:s,datetime:this.iso8601(s),high:o,low:n,bid:i,bidVolume:void 0,ask:r,askVolume:void 0,vwap:void 0,open:d,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetProductsSparkLines(this.extend({},t)),i={},r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeValue(s,t,[]),o=this.safeValue(a,0,[]),n=this.safeMarket(t,void 0,"-");i[n.symbol]=this.parseTicker(o,n)}return this.filterByArrayTickers(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={id:s.id},r=this.safeString(this.options,"fetchTickerMethod","publicGetProductsIdTicker"),a=await this[r](this.extend(i,t));return this.parseTicker(a,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString2(e,"time","created_at")),i=this.safeString(e,"product_id");let r,a,o;t=this.safeMarket(i,t,"-");const n=this.safeStringLower(t,"quoteId");if(void 0!==n){const s=n+"_value";o=this.safeString(e,s);const i=this.safeString(e,"liquidity");void 0!==i&&(a="T"===i?"taker":"maker",r=this.safeString(t,a))}const d={cost:this.safeString2(e,"fill_fees","fee"),currency:t.quote,rate:r},h=this.safeString(e,"trade_id");let c="buy"===e.side?"sell":"buy";const l=this.safeString(e,"order_id"),u=this.safeString(e,"maker_order_id"),p=this.safeString(e,"taker_order_id");(void 0!==l||void 0!==u&&void 0!==p)&&(c="buy"===e.side?"buy":"sell");const f=this.safeString(e,"price"),m=this.safeString(e,"size");return this.safeTrade({id:h,order:l,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,takerOrMaker:a,side:c,price:f,amount:m,fee:d,cost:o},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i,100);await this.loadMarkets();const o=this.market(e),n={product_id:o.id};void 0!==s&&(n.limit=s),void 0!==t&&(n.start_date=this.iso8601(t));const d=this.safeValue2(i,"until","end_date");void 0!==d&&(i=this.omit(i,["until"]),n.end_date=this.iso8601(d));const h=await this.privateGetFills(this.extend(n,i));return this.parseTrades(h,o,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={id:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetProductsIdTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFees(e),s=this.safeNumber(t,"maker_fee_rate"),i=this.safeNumber(t,"taker_fee_rate"),r={};for(let e=0;e<this.symbols.length;e++){const a=this.symbols[e];r[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!0}}return r}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,3),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,300);const o=this.market(e),n=this.safeInteger(this.timeframes,t),d={id:o.id};d.granularity=void 0!==n?n:t;const h=this.safeValue2(r,"until","end");if(r=this.omit(r,["until"]),void 0!==s)if(d.start=this.iso8601(s),i=void 0===i?300:Math.min(300,i),void 0===h){const e=1e3*n;this.isRoundNumber(s%e)?d.end=this.iso8601(this.sum((i-1)*e,s)):d.end=this.iso8601(this.sum(i*e,s))}else d.end=this.iso8601(h);const c=await this.publicGetProductsIdCandles(this.extend(d,r));return this.parseOHLCVs(c,o,t,s,i)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeTimestamp(t,"epoch")}parseOrderStatus(e){return this.safeString({pending:"open",active:"open",open:"open",done:"closed",canceled:"canceled",canceling:"open"},e,e)}parseOrder(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"product_id");t=this.safeMarket(i,t,"-");let r=this.parseOrderStatus(this.safeString(e,"status"));const a=this.safeString(e,"done_reason");"closed"===r&&"canceled"===a&&(r="canceled");const o=this.safeString(e,"price"),n=this.safeString(e,"filled_size"),d=this.safeString(e,"size",n),h=this.safeString(e,"executed_value"),c=this.safeNumber(e,"fill_fees");let l;void 0!==c&&(l={cost:c,currency:t.quote,rate:void 0});const u=this.safeString(e,"id"),p=this.safeString(e,"type"),f=this.safeString(e,"side"),m=this.safeString(e,"time_in_force"),g=this.safeValue(e,"post_only"),v=this.safeNumber(e,"stop_price"),y=this.safeString(e,"client_oid");return this.safeOrder({id:u,clientOrderId:y,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:r,symbol:t.symbol,type:p,timeInForce:m,postOnly:g,side:f,price:o,stopPrice:v,triggerPrice:v,cost:h,amount:d,filled:n,remaining:void 0,fee:l,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},r=this.safeString2(s,"clientOrderId","client_oid");let a;void 0===r?(a="privateGetOrdersId",i.id=e):(a="privateGetOrdersClientClientOid",i.client_oid=r,s=this.omit(s,["clientOrderId","client_oid"]));const o=await this[a](this.extend(i,s));return this.parseOrder(o)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={order_id:e},n=await this.privateGetFills(this.extend(o,r));return this.parseTrades(n,a,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOpenOrders(e,t,s,this.extend({status:"all"},i))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchOpenOrders",e,t,s,i,100);const a={};let o;void 0!==e&&(o=this.market(e),a.product_id=o.id),void 0!==s&&(a.limit=s),void 0!==t&&(a.start_date=this.iso8601(t));const n=this.safeValue2(i,"until","end_date");void 0!==n&&(i=this.omit(i,["until"]),a.end_date=this.iso8601(n));const d=await this.privateGetOrders(this.extend(a,i));return this.parseOrders(d,o,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOpenOrders(e,t,s,this.extend({status:"done"},i))}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={type:t,side:s,product_id:o.id},d=this.safeString2(a,"clientOrderId","client_oid");void 0!==d&&(n.client_oid=d);const h=this.safeNumberN(a,["stopPrice","stop_price","triggerPrice"]);void 0!==h&&(n.stop_price=this.priceToPrecision(e,h));const c=this.safeString2(a,"timeInForce","time_in_force");void 0!==c&&(n.time_in_force=c);if(this.safeValue2(a,"postOnly","post_only",!1)&&(n.post_only=!0),a=this.omit(a,["timeInForce","time_in_force","stopPrice","stop_price","clientOrderId","client_oid","postOnly","post_only","triggerPrice"]),"limit"===t)n.price=this.priceToPrecision(e,r),n.size=this.amountToPrecision(e,i);else if("market"===t){let t=this.safeNumber2(a,"cost","funds");void 0===t?void 0!==r&&(t=i*r):a=this.omit(a,["cost","funds"]),void 0!==t?n.funds=this.costToPrecision(e,t):n.size=this.amountToPrecision(e,i)}const l=await this.privatePostOrders(this.extend(n,a));return this.parseOrder(l,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},r=this.safeString2(s,"clientOrderId","client_oid");let a,o;return void 0===r?(a="privateDeleteOrdersId",i.id=e):(a="privateDeleteOrdersClientClientOid",i.client_oid=r,s=this.omit(s,["clientOrderId","client_oid"])),void 0!==t&&(o=this.market(t),i.product_id=o.symbol),await this[a](this.extend(i,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;return void 0!==e&&(i=this.market(e),s.product_id=i.symbol),await this.privateDeleteOrders(this.extend(s,t))}async fetchPaymentMethods(e={}){return await this.privateGetPaymentMethods(e)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={currency:o.id,amount:t};let d="privatePostWithdrawals";"payment_method_id"in a?d+="PaymentMethod":"coinbase_account_id"in a?d+="CoinbaseAccount":(d+="Crypto",n.crypto_address=s,void 0!==i&&(n.destination_tag=i));const h=await this[d](this.extend(n,a));if(!h)throw new r.ExchangeError(this.id+" withdraw() error: "+this.json(h));return this.parseTransaction(h,o)}parseLedgerEntryType(e){return this.safeString({transfer:"transfer",match:"trade",fee:"fee",rebate:"rebate",conversion:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i,r=this.safeString(e,"amount");const o=this.safeString(e,"balance"),n=a.Y.stringSub(o,r);a.Y.stringLt(r,"0")?(i="out",r=a.Y.stringAbs(r)):i="in";const d=this.parseNumber(r),h=this.parseNumber(o),c=this.parseNumber(n),l=this.parse8601(this.safeValue(e,"created_at")),u=this.parseLedgerEntryType(this.safeString(e,"type")),p=this.safeCurrencyCode(void 0,t),f=this.safeValue(e,"details",{});let m,g,v;"transfer"===u?(m=this.safeString(f,"from"),g=this.safeString(f,"to"),v=this.safeString(f,"profile_transfer_id")):v=this.safeString(f,"order_id");return{id:s,currency:p,account:m,referenceAccount:g,referenceId:v,status:"ok",amount:d,before:c,after:h,fee:void 0,direction:i,timestamp:l,datetime:this.iso8601(l),type:u,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchLedger() requires a code param");await this.loadMarkets(),await this.loadAccounts();const a=this.currency(e),o=this.indexBy(this.accounts,"code"),n=this.safeValue(o,e);if(void 0===n)throw new r.ExchangeError(this.id+" fetchLedger() could not find account id for "+e);const d={id:n.id};void 0!==t&&(d.start_date=this.iso8601(t)),void 0!==s&&(d.limit=s);const h=this.safeValue2(i,"until","end_date");void 0!==h&&(i=this.omit(i,["until"]),d.end_date=this.iso8601(h));const c=await this.privateGetAccountsIdLedger(this.extend(d,i));for(let t=0;t<c.length;t++)c[t].currency=e;return this.parseLedger(c,a,t,s)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),await this.loadAccounts();let o=this.safeString(i,"id");if(void 0===o&&void 0!==e){a=this.currency(e);const t=this.indexBy(this.accounts,"code"),s=this.safeValue(t,e);if(void 0===s)throw new r.ExchangeError(this.id+" fetchDepositsWithdrawals() could not find account id for "+e);o=s.id}const n={};let d;if(void 0!==o&&(n.id=o),void 0!==s&&(n.limit=s),void 0===o){d=await this.privateGetTransfers(this.extend(n,i));for(let e=0;e<d.length;e++){const t=this.safeString(d[e],"account_id"),s=this.safeValue(this.accountsById,t),i=this.safeString(s,"code");d[e].currency=i}}else{d=await this.privateGetAccountsIdTransfers(this.extend(n,i));for(let t=0;t<d.length;t++)d[t].currency=e}return this.parseTransactions(d,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({type:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({type:"withdraw"},i))}parseTransactionStatus(e){if(this.safeValue(e,"canceled_at"))return"canceled";const t=this.safeValue(e,"processed_at"),s=this.safeValue(e,"completed_at");return s?"ok":t&&!s?"failed":"pending"}parseTransaction(e,t=void 0){const s=this.safeValue(e,"details",{}),i=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t);let o=this.safeNumber(e,"amount"),n=this.safeString(e,"type"),d=this.safeString(s,"crypto_address");d=this.safeString(e,"crypto_address",d);const h={currency:void 0,cost:void 0,rate:void 0};if("withdraw"===n){n="withdrawal",d=this.safeString(s,"sent_to_address",d);const e=this.safeNumber(s,"fee");void 0!==e&&(void 0!==o&&(o-=e),h.cost=e,h.currency=a)}const c=this.safeString(s,"network");return{info:e,id:this.safeString(e,"id"),txid:this.safeString(s,"crypto_transaction_hash"),type:n,currency:a,network:this.networkIdToCode(c),amount:o,status:this.parseTransactionStatus(e),timestamp:i,datetime:this.iso8601(i),address:d,addressFrom:void 0,addressTo:this.safeString(s,"crypto_address"),tag:this.safeString(s,"destination_tag"),tagFrom:void 0,tagTo:void 0,updated:this.parse8601(this.safeString(e,"processed_at")),comment:void 0,internal:!1,fee:h}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeValue(this.options,"coinbaseAccounts");void 0===i&&(i=await this.privateGetCoinbaseAccounts(),this.options.coinbaseAccounts=i,this.options.coinbaseAccountsByCurrencyId=this.indexBy(i,"currency"));const a=s.id,o=this.safeValue(this.options.coinbaseAccountsByCurrencyId,a);if(void 0===o)throw new r.InvalidAddress(this.id+" createDepositAddress() could not find currency code "+e+" with id = "+a+" in this.options['coinbaseAccountsByCurrencyId']");const n={id:o.id},d=await this.privatePostCoinbaseAccountsIdAddresses(this.extend(n,t)),h=this.safeString(d,"address"),c=this.safeString(d,"destination_tag");return{currency:e,address:this.checkAddress(h),tag:c,info:d}}sign(e,t="public",s="GET",i={},a=void 0,o=void 0){let d="/"+this.implodeParams(e,i);const h=this.omit(i,this.extractParams(e));"GET"===s&&Object.keys(h).length&&(d+="?"+this.urlencode(h));const c=this.implodeHostname(this.urls.api[t])+d;if("private"===t){this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"!==s&&Object.keys(h).length&&(t=o=this.json(h));const i=e+s+d+t;let c;try{c=this.base64ToBinary(this.secret)}catch(e){throw new r.AuthenticationError(this.id+" sign() invalid base64 secret")}const l=this.hmac(this.encode(i),c,n.s,"base64");a={"CB-ACCESS-KEY":this.apiKey,"CB-ACCESS-SIGN":l,"CB-ACCESS-TIMESTAMP":e,"CB-ACCESS-PASSPHRASE":this.password,"Content-Type":"application/json"}}return{url:c,method:s,body:o,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){if(400===e||404===e){if("{"===o[0]){const e=this.safeString(n,"message"),t=this.id+" "+e;throw this.throwExactlyMatchedException(this.exceptions.exact,e,t),this.throwBroadlyMatchedException(this.exceptions.broad,e,t),new r.ExchangeError(t)}throw new r.ExchangeError(this.id+" "+o)}}async request(e,t="public",s="GET",i={},a=void 0,o=void 0,n={}){const d=await this.fetch2(e,t,s,i,a,o,n);if("string"!=typeof d&&"message"in d)throw new r.ExchangeError(this.id+" "+this.json(d));return d}}},1558:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(2609),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinbaseinternational",name:"Coinbase International",countries:["US"],certified:!0,pro:!0,rateLimit:100,version:"v1",userAgent:this.userAgents.chrome,headers:{"CB-VERSION":"2018-05-30"},has:{CORS:!0,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketBuyOrderWithCost:!1,createMarketOrderWithCost:!1,createMarketSellOrder:!0,createMarketSellOrderWithCost:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL2OrderBook:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyBuys:!0,fetchMySells:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!1,fetchOrders:!1,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!1,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMargin:!0,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/866ae638-6ab5-4ebf-ab2c-cdcce9545625",api:{rest:"https://api.international.coinbase.com/api"},test:{rest:"https://api-n5e1.coinbase.com/api"},www:"https://international.coinbase.com",doc:["https://docs.cloud.coinbase.com/intx/docs"],fees:["https://help.coinbase.com/en/international-exchange/trading-deposits-withdrawals/international-exchange-fees"],referral:""},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{v1:{public:{get:["assets","assets/{assets}","assets/{asset}/networks","instruments","instruments/{instrument}","instruments/{instrument}/quote","instruments/{instrument}/funding","instruments/{instrument}/candles"]},private:{get:["orders","orders/{id}","portfolios","portfolios/{portfolio}","portfolios/{portfolio}/detail","portfolios/{portfolio}/summary","portfolios/{portfolio}/balances","portfolios/{portfolio}/balances/{asset}","portfolios/{portfolio}/positions","portfolios/{portfolio}/positions/{instrument}","portfolios/fills","portfolios/{portfolio}/fills","transfers","transfers/{transfer_uuid}"],post:["orders","portfolios","portfolios/margin","portfolios/transfer","transfers/withdraw","transfers/address","transfers/create-counterparty-id","transfers/validate-counterparty-id","transfers/withdraw/counterparty"],put:["orders/{id}","portfolios/{portfolio}"],delete:["orders","orders/{id}"]}}},fees:{trading:{taker:this.parseNumber("0.004"),maker:this.parseNumber("0.002"),tierBased:!0,percentage:!0,tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("1000000"),this.parseNumber("0.004")],[this.parseNumber("5000000"),this.parseNumber("0.0035")],[this.parseNumber("10000000"),this.parseNumber("0.0035")],[this.parseNumber("50000000"),this.parseNumber("0.003")],[this.parseNumber("250000000"),this.parseNumber("0.0025")]],maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("5000000"),this.parseNumber("0.001")],[this.parseNumber("10000000"),this.parseNumber("0.0008")],[this.parseNumber("50000000"),this.parseNumber("0.0005")],[this.parseNumber("250000000"),this.parseNumber("0")]]}}},precisionMode:o.kb,exceptions:{exact:{},broad:{DUPLICATE_CLIENT_ORDER_ID:r.DuplicateOrderId,"Order rejected":r.InvalidOrder,"market orders must be IoC":r.InvalidOrder,"tif is required":r.InvalidOrder,"Invalid replace order request":r.InvalidOrder,Unauthorized:r.PermissionDenied,"invalid result_limit":r.BadRequest,"is a required field":r.BadRequest,"Not Found":r.BadRequest,"ip not allowed":r.AuthenticationError}},timeframes:{"1m":"ONE_MINUTE","5m":"FIVE_MINUTE","15m":"FIFTEEN_MINUTE","30m":"THIRTY_MINUTE","1h":"ONE_HOUR","2h":"TWO_HOUR","6h":"SIX_HOUR","1d":"ONE_DAY"},options:{brokerId:"nfqkvdjp",portfolio:"",withdraw:{method:"v1PrivatePostTransfersWithdraw"},networksById:{ethereum:"ETH",arbitrum:"ARBITRUM",avacchain:"AVAX",optimism:"OPTIMISM",polygon:"MATIC",solana:"SOL",bitcoin:"BTC"}}})}async handlePortfolioAndParams(e,t={}){let s;if([s,t]=this.handleOptionAndParams(t,e,"portfolio"),void 0!==s&&""!==s)return[s,t];const i=this.safeString(this.options,"portfolio");if(void 0!==i&&""!==i)return[i,t];const a=await this.fetchAccounts();for(let e=0;e<a.length;e++){const s=a[e],i=this.safeDict(s,"info",{});if(this.safeBool(i,"is_default")){const e=this.safeString(i,"portfolio_id");return this.options.portfolio=e,[e,t]}}throw new r.ArgumentsRequired(this.id+" "+e+'() requires a portfolio parameter or set the default portfolio with this.options["portfolio"]')}async handleNetworkIdAndParams(e,t,s){let i;if([i,s]=this.handleOptionAndParams(s,t,"network_arn_id"),void 0===i){await this.loadCurrencyNetworks(e);const t=this.currencies[e].networks,a=this.safeString2(s,"networkCode","network");if(void 0===a){if(this.isEmpty(t))throw new r.BadRequest(this.id+" createDepositAddress network not found for currency "+e+" please specify networkId in params");i=this.findDefaultNetwork(t).id}else i=this.networkCodeToId(a,e)}return[i,s]}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.v1PrivateGetPortfolios(e);return this.parseAccounts(t,e)}parseAccount(e){return{id:this.safeString2(e,"portfolio_id","portfolio_uuid"),type:void 0,code:void 0,info:e}}async fetchOHLCV(e,t="1m",s=void 0,i=100,a={}){await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,a,1e4);const n=this.market(e),d={instrument:n.id,granularity:this.safeString(this.timeframes,t,t)};if(void 0===s)throw new r.ArgumentsRequired(this.id+" fetchOHLCV() requires a since argument");d.start=this.iso8601(s);const h=this.safeInteger(a,"until");void 0!==h&&(a=this.omit(a,"until"),d.end=this.iso8601(h));const c=await this.v1PublicGetInstrumentsInstrumentCandles(this.extend(d,a)),l=this.safeList(c,"aggregations",[]);return this.parseOHLCVs(l,n,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString2(e,"start","time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a,o=!1;[o,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),[a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","maxEntriesPerRequest",100);const n="ccxtPageKey";if(o)return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory",e,t,s,i,n,a);const d=this.market(e),h=this.safeInteger(i,n,1)-1,c={instrument:d.id,result_offset:this.safeInteger2(i,"offset","result_offset",h*a)};void 0!==s&&(c.result_limit=s);const l=await this.v1PublicGetInstrumentsInstrumentFunding(this.extend(c,i)),u=this.safeList(l,"results",[]);return this.parseFundingRateHistories(u,d,t,s)}parseFundingRateHistory(e,t=void 0){return this.parseFundingRate(e,t)}parseFundingRate(e,t=void 0){const s=this.safeString2(e,"event_time","time");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:this.parse8601(s),datetime:s,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(s),fundingDatetime:s,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={type:"FUNDING"};let a,o;void 0!==e&&(a=this.market(e)),[o,i]=this.handleOptionAndParams(i,"fetchFundingHistory","portfolios"),void 0!==o&&(r.portfolios=o),void 0!==t&&(r.time_from=this.iso8601(t)),r.result_limit=void 0!==s?s:100;const n=await this.v1PrivateGetTransfers(this.extend(r,i)),d=this.safeList(n,"results",[]);return this.parseIncomes(d,a,t,s)}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeInteger(e,"created_at"),r=this.parse8601(i),a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a);return{info:e,symbol:t.symbol,code:o,timestamp:r,datetime:this.iso8601(r),id:this.safeString(e,"transfer_uuid"),amount:this.safeNumber(e,"amount"),rate:void 0}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={type:"INTERNAL"};let a,o;void 0!==e&&(a=this.currency(e)),[o,i]=this.handleOptionAndParams(i,"fetchTransfers","portfolios"),void 0!==o&&(r.portfolios=o),void 0!==t&&(r.time_from=this.iso8601(t)),r.result_limit=void 0!==s?s:100;const n=await this.v1PrivateGetTransfers(this.extend(r,i)),d=this.safeList(n,"results",[]);return this.parseTransfers(d,a,t,s)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.parse8601(s),r=this.safeString(e,"asset"),a=this.safeCurrencyCode(r),o=this.safeDict(e,"from_portfolio",{}),n=this.safeString(o,"id"),d=this.safeDict(e,"to_portfolio",{}),h=this.safeString(d,"id");return{info:e,id:this.safeString(e,"transfer_uuid"),timestamp:i,datetime:this.iso8601(i),currency:a,amount:this.safeNumber(e,"amount"),fromAccount:n,toAccount:h,status:this.parseTransferStatus(this.safeString(e,"status"))}}parseTransferStatus(e){return this.safeString({FAILED:"failed",PROCESSED:"ok",NEW:"pending",STARTED:"pending"},e,e)}async createDepositAddress(e,t={}){let s,i;await this.loadMarkets(),[s,t]=this.handleOptionAndParams(t,"createDepositAddress","method","v1PrivatePostTransfersAddress"),[i,t]=await this.handlePortfolioAndParams("createDepositAddress",t);const r={portfolio:i};if("v1PrivatePostTransfersAddress"===s){const s=this.currency(e);let i;r.asset=s.id,[i,t]=await this.handleNetworkIdAndParams(e,"createDepositAddress",t),r.network_arn_id=i}const a=await this[s](this.extend(r,t));return{currency:e,tag:this.safeString(a,"destination_tag"),address:this.safeString2(a,"address","counterparty_id"),info:a}}findDefaultNetwork(e){const t=this.toArray(e);for(let e=0;e<t.length;e++){const s=t[e].info;if(!0===this.safeBool(s,"is_default",!1))return t[e]}return t[0]}async loadCurrencyNetworks(e,t={}){const s=this.currency(e);if(void 0!==this.safeDict(s,"networks"))return;const i={asset:s.id},r=await this.v1PublicGetAssetsAssetNetworks(i);s.networks=this.parseNetworks(r)}parseNetworks(e,t={}){const s={};for(let i=0;i<e.length;i++){const r=this.extend(this.parseNetwork(e[i]),t);s[r.network]=r}return s}parseNetwork(e,t={}){const s=this.safeString(e,"asset_name"),i=this.safeCurrencyCode(s),r=this.safeString(e,"network_arn_id"),a=this.safeStringN(e,["network_name","display_name","network_arn_id"],"");return this.safeNetwork({info:e,id:r,name:this.safeString(e,"display_name"),network:this.networkIdToCode(a,i),active:void 0,deposit:void 0,withdraw:void 0,precision:void 0,fee:void 0,limits:{withdraw:{min:this.safeNumber(e,"min_withdrawal_amt"),max:this.safeNumber(e,"max_withdrawal_amt")},deposit:{min:void 0,max:void 0}}})}async setMargin(e,t,s={}){let i;if([i,s]=await this.handlePortfolioAndParams("setMargin",s),void 0!==e)throw new r.BadRequest(this.id+" setMargin() only allows setting margin to full portfolio");const a={portfolio:i,margin_override:t};return await this.v1PrivatePostPortfoliosMargin(this.extend(a,s))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),[r,i]=this.handleOptionAndParams(i,"fetchDepositsWithdrawals","paginate"),[a,i]=this.handleOptionAndParams(i,"fetchDepositsWithdrawals","maxEntriesPerRequest",100);const o="ccxtPageKey";if(r)return await this.fetchPaginatedCallIncremental("fetchDepositsWithdrawals",e,t,s,i,o,a);const n=this.safeInteger(i,o,1)-1,d={result_offset:this.safeInteger2(i,"offset","result_offset",n*a)};if(void 0!==t&&(d.time_from=this.iso8601(t)),void 0!==s){const e=Math.min(s,100);d.result_limit=e}let h,c;[h,i]=this.handleOptionAndParams(i,"fetchDepositsWithdrawals","portfolios"),void 0!==h&&(d.portfolios=h),[c,i]=this.handleOptionAndParams(i,"fetchDepositsWithdrawals","until"),void 0!==c&&(d.time_to=this.iso8601(c));const l=await this.v1PrivateGetTransfers(this.extend(d,i)),u=this.safeList(l,"results",[]);return this.parseTransactions(u)}async fetchPosition(e,t={}){let s;await this.loadMarkets(),e=this.symbol(e),[s,t]=await this.handlePortfolioAndParams("fetchPosition",t);const i={portfolio:s,instrument:this.marketId(e)},r=await this.v1PrivateGetPortfoliosPortfolioPositionsInstrument(this.extend(i,t));return this.parsePosition(r)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");let i=this.safeString(e,"net_size");t=this.safeMarket(s,t,"-");let r="long";return a.Y.stringLe(i,"0")&&(r="short",i=a.Y.stringMul("-1",i)),this.safePosition({info:e,id:this.safeString(e,"id"),symbol:t.symbol,entryPrice:void 0,markPrice:this.safeNumber(e,"mark_price"),notional:void 0,collateral:void 0,unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),side:r,contracts:this.parseNumber(i),contractSize:this.safeNumber(t,"contractSize"),timestamp:void 0,datetime:void 0,hedged:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,initialMargin:this.safeNumber(e,"im_contribution"),initialMarginPercentage:void 0,leverage:void 0,liquidationPrice:void 0,marginRatio:void 0,marginMode:void 0,percentage:void 0})}async fetchPositions(e=void 0,t={}){let s;await this.loadMarkets(),[s,t]=await this.handlePortfolioAndParams("fetchPositions",t);const i={portfolio:s},r=await this.v1PrivateGetPortfoliosPortfolioPositions(this.extend(i,t)),a=this.parsePositions(r);return this.isEmpty(e)?a:(e=this.marketSymbols(e),this.filterByArrayPositions(a,"symbol",e,!1))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),i.type="WITHDRAW",await this.fetchDepositsWithdrawals(e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.loadMarkets(),i.type="DEPOSIT",await this.fetchDepositsWithdrawals(e,t,s,i)}parseTransactionStatus(e){return this.safeString({PROCESSED:"ok",NEW:"pending",STARTED:"pending",FAILED:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"updated_at"),i=this.safeDict(e,"from_portfolio",{}),r=this.safeStringN(e,["from_address","from_cb_account",this.safeStringN(i,["id","uuid","name"]),"from_counterparty_id"]),a=this.safeDict(e,"from_portfolio",{}),o=this.safeStringN(e,["to_address","to_cb_account",this.safeStringN(a,["id","uuid","name"]),"to_counterparty_id"]);return{info:e,id:this.safeString(e,"transfer_uuid"),txid:this.safeString(e,"transaction_uuid"),timestamp:this.parse8601(s),datetime:s,network:this.networkIdToCode(this.safeString(e,"network_name")),address:void 0,addressTo:o,addressFrom:r,tag:void 0,tagTo:void 0,tagFrom:void 0,type:this.safeString(e,"resource"),amount:this.safeNumber(e,"amount"),currency:this.safeCurrencyCode(this.safeString(e,"asset"),t),status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.parse8601(s),fee:{cost:void 0,currency:void 0}}}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"event_time");return this.safeTrade({info:e,id:this.safeString2(e,"fill_id","exec_id"),order:this.safeString(e,"order_id"),timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,t),type:void 0,side:this.safeStringLower(e,"side"),takerOrMaker:void 0,price:this.safeNumber(e,"fill_price"),amount:this.safeNumber(e,"fill_qty"),cost:void 0,fee:{cost:this.safeNumber(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"fee_asset"))}})}async fetchMarkets(e={}){const t=await this.v1PublicGetInstruments(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"base_asset_name"),i=this.safeString(e,"quote_asset_name"),r="SPOT"===this.safeString(e,"type"),a=this.fees;let o,n=s+"/"+i;return r||(o=i,n+=":"+i),{id:t,lowercaseId:t.toLowerCase(),symbol:n,base:s,quote:i,settle:o||void 0,baseId:s,quoteId:i,settleId:o||void 0,type:r?"spot":"swap",spot:r,margin:!1,swap:!r,future:!1,option:!1,active:"TRADING"===this.safeString(e,"trading_state"),contract:!r,linear:r?void 0:o===i,inverse:r?void 0:o!==i,taker:a.trading.taker,maker:a.trading.maker,contractSize:r?void 0:1,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"base_increment"),price:this.safeNumber(e,"quote_increment"),cost:this.safeNumber(e,"quote_increment")},limits:{leverage:{min:void 0,max:this.safeNumber(e,"base_imf")},amount:{min:void 0,max:r?void 0:this.safeNumber(e,"position_limit_qty")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"min_notional_value"),max:void 0}},info:e,created:void 0}}async fetchCurrencies(e={}){const t=await this.v1PublicGetAssets(e),s={};for(let e=0;e<t.length;e++){const i=this.parseCurrency(t[e]);s[i.code]=i}return s}parseCurrency(e){const t=this.safeString(e,"asset_name"),s=this.safeCurrencyCode(t);return{id:t,name:s,code:s,precision:void 0,info:e,active:"ACTIVE"===this.safeString(e,"status"),deposit:void 0,withdraw:void 0,networks:void 0,fee:void 0,fees:void 0,limits:this.limits}}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetInstruments(t),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeSymbol(r),o=this.safeDict(t,"quote",{});i[a]=this.parseTicker(o,this.safeMarket(r))}return this.filterByArray(i,"symbol",e,!0)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument:this.marketId(e)},r=await this.v1PublicGetInstrumentsInstrumentQuote(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"timestamp");return this.safeTicker({info:e,symbol:this.safeSymbol(void 0,t),timestamp:this.parse8601(s),datetime:s,bid:this.safeNumber(e,"best_bid_price"),bidVolume:this.safeNumber(e,"best_bid_size"),ask:this.safeNumber(e,"best_ask_price"),askVolume:this.safeNumber(e,"best_ask_size"),high:void 0,low:void 0,open:void 0,close:void 0,last:void 0,change:void 0,percentage:void 0,average:void 0,vwap:void 0,baseVolume:void 0,quoteVolume:void 0,previousClose:void 0})}async fetchBalance(e={}){let t;await this.loadMarkets(),[t,e]=await this.handlePortfolioAndParams("fetchBalance",e);const s={portfolio:t},i=await this.v1PrivateGetPortfoliosPortfolioBalances(this.extend(s,e));return this.parseBalance(i)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"asset_name"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"quantity"),o.used=this.safeString(i,"hold"),t[a]=o}return this.safeBalance(t)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a={asset:this.currency(e).id,ammount:t,from:s,to:i},o=await this.v1PrivatePostPortfoliosTransfer(this.extend(a,r));return{info:o,id:void 0,timestamp:void 0,datetime:void 0,currency:e,amount:t,fromAccount:s,toAccount:i,status:this.safeBool(o,"success")?"ok":"failed"}}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);let d=t.toUpperCase();const h=this.safeNumberN(o,["triggerPrice","stopPrice","stop_price"]);let c=this.safeString(this.options,"brokerId","nfqkvdjp")+"-"+this.uuid();c=c.slice(0,17);const l={client_order_id:c,side:s.toUpperCase(),instrument:n.id,size:this.amountToPrecision(n.symbol,i)};if(void 0!==h&&(d="limit"===t?"STOP_LIMIT":"STOP",l.stop_price=h),l.type=d,"limit"===t){if(void 0===a)throw new r.InvalidOrder(this.id+"createOrder() requires a price parameter for a limit order types");l.price=a}let u;[u,o]=await this.handlePortfolioAndParams("createOrder",o),void 0!==u&&(l.portfolio=u);const p=this.safeBool2(o,"postOnly","post_only");let f=this.safeString2(o,"tif","timeInForce");if("MARKET"===d){if(void 0!==f&&"IOC"!==f)throw new r.InvalidOrder(this.id+'createOrder() market orders must have tif set to "IOC"');f="IOC"}else f=void 0===f?"GTC":f;void 0!==p&&(l.post_only=p),l.tif=f,o=this.omit(o,["client_order_id","user","postOnly","timeInForce"]);const m=await this.v1PrivatePostOrders(this.extend(l,o));return this.parseOrder(m,n)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeNumber(e,"fee");let r;void 0!==i&&(r={cost:i});const a=this.safeString2(e,"submit_time","event_time");return this.safeOrder({info:e,id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:this.parse8601(a),datetime:a,lastTradeTimestamp:void 0,symbol:this.safeSymbol(s,t),type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.safeString(e,"tif"),postOnly:void 0,side:this.safeStringLower(e,"side"),price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stop_price"),triggerPrice:this.safeString(e,"stop_price"),amount:this.safeString(e,"size"),filled:this.safeString(e,"exec_qty"),remaining:this.safeString(e,"leaves_qty"),cost:void 0,average:this.safeString(e,"avg_price"),status:this.parseOrderStatus(this.safeString(e,"order_status")),fee:r,trades:void 0},t)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIAL_FILLED:"open",FILLED:"closed",CANCELED:"canceled",REPLACED:"canceled",PENDING_CANCEL:"open",REJECTED:"rejected",PENDING_NEW:"open",EXPIRED:"expired",PENDING_REPLACE:"open"},e,e)}parseOrderType(e){if("UNKNOWN_ORDER_TYPE"===e)return;return this.safeString({MARKET:"market",LIMIT:"limit",STOP:"limit",STOP_LIMIT:"limit"},e,e)}async cancelOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),[i,s]=await this.handlePortfolioAndParams("cancelOrder",s);const r={portfolio:i,id:e};let a;void 0!==t&&(a=this.market(t));const o=await this.v1PrivateDeleteOrdersId(this.extend(r,s));return this.parseOrder(o,a)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets(),[s,t]=await this.handlePortfolioAndParams("cancelAllOrders",t);const i={portfolio:s};let r;e&&(r=this.market(e),i.instrument=r.id);const a=await this.v1PrivateDeleteOrders(this.extend(i,t));return this.parseOrders(a,r)}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t),h={id:e};let c;[c,n]=await this.handlePortfolioAndParams("editOrder",n),void 0!==c&&(h.portfolio=c),void 0!==a&&(h.size=this.amountToPrecision(t,a)),void 0!==o&&(h.price=this.priceToPrecision(t,o));const l=this.safeNumberN(n,["stopPrice","stop_price","triggerPrice"]);void 0!==l&&(h.stop_price=l);const u=this.safeString2(n,"client_order_id","clientOrderId");if(void 0===u)throw new r.BadRequest(this.id+" editOrder() requires a clientOrderId parameter");h.client_order_id=u;const p=await this.v1PrivatePutOrdersId(this.extend(h,n));return this.parseOrder(p,d)}async fetchOrder(e,t=void 0,s={}){let i,r;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),[r,s]=await this.handlePortfolioAndParams("fetchOrder",s);const a={id:e,portfolio:r},o=await this.v1PrivateGetOrdersId(this.extend(a,s));return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),[a,i]=await this.handlePortfolioAndParams("fetchOpenOrders",i);let o,n=!1;[n,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),[o,i]=this.handleOptionAndParams(i,"fetchOpenOrders","maxEntriesPerRequest",100);const d="ccxtPageKey";if(n)return await this.fetchPaginatedCallIncremental("fetchOpenOrders",e,t,s,i,d,o);const h=this.safeInteger(i,d,1)-1,c={portfolio:a,result_offset:this.safeInteger2(i,"offset","result_offset",h*o)};let l;if(e&&(l=this.market(e),c.instrument=e),void 0!==s){if(s>100)throw new r.BadRequest(this.id+" fetchOpenOrders() maximum limit is 100");c.result_limit=s}void 0!==t&&(c.ref_datetime=this.iso8601(t));const u=await this.v1PrivateGetOrders(this.extend(c,i)),p=this.safeList(u,"results",[]);return this.parseOrders(p,l,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=!1;[a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate");const o="ccxtPageKey";let n,d;if([n,i]=this.handleOptionAndParams(i,"fetchMyTrades","maxEntriesPerRequest",100),a)return await this.fetchPaginatedCallIncremental("fetchMyTrades",e,t,s,i,o,n);void 0!==e&&(d=this.market(e));const h=this.safeInteger(i,o,1)-1,c={result_offset:this.safeInteger2(i,"offset","result_offset",h*n)};if(void 0!==s){if(s>100)throw new r.BadRequest(this.id+" fetchMyTrades() maximum limit is 100. Consider setting paginate to true to fetch more trades.");c.result_limit=s}void 0!==t&&(c.time_from=this.iso8601(t));const l=this.safeStringN(i,["until"]);void 0!==l&&(i=this.omit(i,["until"]),c.ref_datetime=this.iso8601(l));const u=await this.v1PrivateGetPortfoliosFills(this.extend(c,i)),p=this.safeList(u,"results",[]);return this.parseTrades(p,d,t,s)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e);let o,n,d;[o,r]=await this.handlePortfolioAndParams("withdraw",r),[n,r]=this.handleOptionAndParams(r,"withdraw","method","v1PrivatePostTransfersWithdraw"),[d,r]=await this.handleNetworkIdAndParams(e,"withdraw",r);const h={portfolio:o,type:"send",asset:a.id,address:s,amount:t,currency:a.id,network_arn_id:d,nonce:this.nonce()},c=await this[n](this.extend(h,r));return this.parseTransaction(c,a)}safeNetwork(e){let t=this.safeBool(e,"withdraw"),s=this.safeBool(e,"deposit");const i=this.safeDict(e,"limits"),r=this.safeDict(i,"withdraw"),a=this.safeNumber(r,"max"),o=this.safeDict(i,"deposit"),n=this.safeNumber(o,"max");void 0===t&&void 0!==a&&(t=a>0),void 0===s&&void 0!==n&&(s=n>0);const d=this.safeString(e,"id"),h=t&&s;return{info:e.info,id:d,name:this.safeString(e,"name"),network:this.safeString(e,"network"),active:this.safeBool(e,"active",h),deposit:s,withdraw:t,fee:this.safeNumber(e,"fee"),precision:this.safeNumber(e,"precision"),limits:{withdraw:{min:this.safeNumber(r,"min"),max:a},deposit:{min:this.safeNumber(o,"min"),max:n}}}}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){const o=t[0],d="private"===t[1];let h="/"+o+"/"+this.implodeParams(e,i);const c=this.omit(i,this.extractParams(e)),l="/api"+h;"GET"!==s&&"DELETE"!==s||Object.keys(c).length&&(h+="?"+this.urlencodeWithArrayRepeat(c));const u=this.urls.api.rest+h;if(d){this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"!==s&&Object.keys(c).length&&(t=a=this.json(c));const i=e+s+l+t;r={"CB-ACCESS-TIMESTAMP":e,"CB-ACCESS-SIGN":this.hmac(this.encode(i),this.base64ToBinary(this.secret),n.s,"base64"),"CB-ACCESS-PASSPHRASE":this.password,"CB-ACCESS-KEY":this.apiKey}}return{url:u,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.id+" "+o,l=this.safeString(n,"title");if(void 0!==l)throw this.throwExactlyMatchedException(this.exceptions.exact,l,c),this.throwBroadlyMatchedException(this.exceptions.broad,l,c),new r.ExchangeError(c)}}},2741:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2938),r=s(2079),a=s(1579),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coincheck",name:"coincheck",countries:["JP","ID"],rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,ws:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg",api:{rest:"https://coincheck.com/api"},www:"https://coincheck.com",doc:"https://coincheck.com/documents/exchange/api",fees:["https://coincheck.com/exchange/fee","https://coincheck.com/info/fee"]},api:{public:{get:["exchange/orders/rate","order_books","rate/{pair}","ticker","trades"]},private:{get:["accounts","accounts/balance","accounts/leverage_balance","bank_accounts","deposit_money","exchange/orders/opens","exchange/orders/transactions","exchange/orders/transactions_pagination","exchange/leverage/positions","lending/borrows/matches","send_money","withdraws"],post:["bank_accounts","deposit_money/{id}/fast","exchange/orders","exchange/transfers/to_leverage","exchange/transfers/from_leverage","lending/borrows","lending/borrows/{id}/repay","send_money","withdraws"],delete:["bank_accounts/{id}","exchange/orders/{id}","withdraws/{id}"]}},markets:{"BTC/JPY":this.safeMarketStructure({id:"btc_jpy",symbol:"BTC/JPY",base:"BTC",quote:"JPY",baseId:"btc",quoteId:"jpy",type:"spot",spot:!0}),"ETC/JPY":this.safeMarketStructure({id:"etc_jpy",symbol:"ETC/JPY",base:"ETC",quote:"JPY",baseId:"etc",quoteId:"jpy",type:"spot",spot:!0}),"FCT/JPY":this.safeMarketStructure({id:"fct_jpy",symbol:"FCT/JPY",base:"FCT",quote:"JPY",baseId:"fct",quoteId:"jpy",type:"spot",spot:!0}),"MONA/JPY":this.safeMarketStructure({id:"mona_jpy",symbol:"MONA/JPY",base:"MONA",quote:"JPY",baseId:"mona",quoteId:"jpy",type:"spot",spot:!0}),"ETC/BTC":this.safeMarketStructure({id:"etc_btc",symbol:"ETC/BTC",base:"ETC",quote:"BTC",baseId:"etc",quoteId:"btc",type:"spot",spot:!0})},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0"),taker:this.parseNumber("0")}},precisionMode:a.kb,exceptions:{exact:{"disabled API Key":r.AuthenticationError,"invalid authentication":r.AuthenticationError},broad:{}}})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const r=s[i],a=this.currency(r).id;if(a in e){const s=this.account(),i=a+"_reserved";s.free=this.safeString(e,a),s.used=this.safeString(e,i),t[r]=s}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalance(e);return this.parseBalance(t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privateGetExchangeOrdersOpens(i),o=this.safeValue(a,"orders",[]),n=this.parseOrders(o,r,t,s),d=[];for(let e=0;e<n.length;e++)d.push(this.extend(n[e],{status:"open"}));return d}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_type"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"pending_amount"),o=this.safeString(e,"pending_amount"),n=this.safeString(e,"rate"),d=this.safeString(e,"pair"),h=this.safeSymbol(d,t,"_");return this.safeOrder({id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,amount:a,remaining:o,filled:void 0,side:i,type:void 0,timeInForce:void 0,postOnly:void 0,status:undefined,symbol:h,price:n,stopPrice:void 0,triggerPrice:void 0,cost:void 0,fee:void 0,info:e,average:void 0,trades:void 0},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id},a=await this.publicGetOrderBooks(this.extend(r,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"timestamp"),r=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){if("BTC/JPY"!==e)throw new r.BadSymbol(this.id+" fetchTicker() supports BTC/JPY only");await this.loadMarkets();const s=this.market(e),i={pair:s.id},a=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(a,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"created_at")),i=this.safeString(e,"id"),r=this.safeString(e,"rate"),a=this.safeString(e,"pair"),o=(t=this.safeMarket(a,t,"_")).baseId,n=t.quoteId,d=t.symbol;let h,c,l,u,p,f;if("liquidity"in e){"T"===this.safeString(e,"liquidity")?h="taker":"M"===this.safeString(e,"liquidity")&&(h="maker");const t=this.safeValue(e,"funds",{});c=this.safeString(t,o),l=this.safeString(t,n),p={currency:this.safeString(e,"fee_currency"),cost:this.safeString(e,"fee")},u=this.safeString(e,"side"),f=this.safeString(e,"order_id")}else c=this.safeString(e,"amount"),u=this.safeString(e,"order_type");return this.safeTrade({id:i,info:e,datetime:this.iso8601(s),timestamp:s,symbol:d,type:void 0,side:u,order:f,takerOrMaker:h,price:r,amount:c,cost:l,fee:p},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={};void 0!==s&&(a.limit=s);const o=await this.privateGetExchangeOrdersTransactionsPagination(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e),s=this.safeValue(t,"exchange_fees",{}),i={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],r=this.market(t),a=this.safeValue(s,r.id,{});i[t]={info:a,symbol:t,maker:this.safeNumber(a,"maker_fee"),taker:this.safeNumber(a,"taker_fee"),percentage:!0,tierBased:!1}}return i}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={pair:o.id};if("market"===t){const e=t+"_"+s;n.order_type=e;n[("buy"===s?e+"_":"")+"amount"]=i}else n.order_type=s,n.rate=r,n.amount=i;const d=await this.privatePostExchangeOrders(this.extend(n,a)),h=this.safeString(d,"id");return this.safeOrder({id:h,info:d},o)}async cancelOrder(e,t=void 0,s={}){const i={id:e},r=await this.privateDeleteExchangeOrdersId(this.extend(i,s));return this.parseOrder(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.currency=r.id),void 0!==s&&(a.limit=s);const o=await this.privateGetDepositMoney(this.extend(a,i)),n=this.safeList(o,"deposits",[]);return this.parseTransactions(n,r,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={};void 0!==s&&(a.limit=s);const o=await this.privateGetWithdraws(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,r,t,s,{type:"withdrawal"})}parseTransactionStatus(e){return this.safeString({pending:"pending",processing:"pending",finished:"ok",canceled:"canceled",confirmed:"pending",received:"ok"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.parse8601(this.safeString(e,"created_at")),r=this.safeString(e,"address"),a=this.safeNumber(e,"amount"),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.parseTransactionStatus(this.safeString(e,"status")),h=this.parse8601(this.safeString(e,"confirmed_at"));let c;const l=this.safeNumber(e,"fee");return void 0!==l&&(c={cost:l,currency:n}),{info:e,id:s,txid:void 0,timestamp:i,datetime:this.iso8601(i),network:void 0,address:r,addressTo:r,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:a,currency:n,status:d,updated:h,comment:void 0,internal:void 0,fee:c}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n=this.urls.api.rest+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t="";"GET"===s?Object.keys(d).length&&(n+="?"+this.urlencode(this.keysort(d))):Object.keys(d).length&&(t=a=this.urlencode(this.keysort(d)));const i=e+n+t;r={"Content-Type":"application/x-www-form-urlencoded","ACCESS-KEY":this.apiKey,"ACCESS-NONCE":e,"ACCESS-SIGNATURE":this.hmac(this.encode(i),this.encode(this.secret),o.s)}}return{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(!this.safeBool(n,"success",!0)){const e=this.safeString(n,"error"),t=this.id+" "+this.json(n);throw this.throwExactlyMatchedException(this.exceptions.exact,e,t),this.throwBroadlyMatchedException(this.exceptions.broad,o,t),new r.ExchangeError(this.id+" "+this.json(n))}}}},9344:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(5277),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(4035);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinex",name:"CoinEx",version:"v2",countries:["CN"],rateLimit:2.5,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,borrowCrossMargin:!1,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!0,createStopLossOrder:!0,createTakeProfitOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressByNetwork:!1,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!0,fetchIsolatedBorrowRates:!1,fetchLeverage:!0,fetchLeverages:!1,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionHistory:!0,fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!1,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","12h":"12hour","1d":"1day","3d":"3day","1w":"1week"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg",api:{public:"https://api.coinex.com",private:"https://api.coinex.com",perpetualPublic:"https://api.coinex.com/perpetual",perpetualPrivate:"https://api.coinex.com/perpetual"},www:"https://www.coinex.com",doc:"https://docs.coinex.com/api/v2",fees:"https://www.coinex.com/fees",referral:"https://www.coinex.com/register?refer_code=yw5fz"},api:{v1:{public:{get:{"amm/market":1,"common/currency/rate":1,"common/asset/config":1,"common/maintain/info":1,"common/temp-maintain/info":1,"margin/market":1,"market/info":1,"market/list":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/detail":1}},private:{get:{"account/amm/balance":40,"account/investment/balance":40,"account/balance/history":40,"account/market/fee":40,"balance/coin/deposit":40,"balance/coin/withdraw":40,"balance/info":40,"balance/deposit/address/{coin_type}":40,"contract/transfer/history":40,"credit/info":40,"credit/balance":40,"investment/transfer/history":40,"margin/account":1,"margin/config":1,"margin/loan/history":40,"margin/transfer/history":40,"order/deals":40,"order/finished":40,"order/pending":8,"order/status":8,"order/status/batch":8,"order/user/deals":40,"order/stop/finished":40,"order/stop/pending":8,"order/user/trade/fee":1,"order/market/trade/info":1,"sub_account/balance":1,"sub_account/transfer/history":40,"sub_account/auth/api":40,"sub_account/auth/api/{user_auth_id}":40},post:{"balance/coin/withdraw":40,"contract/balance/transfer":40,"margin/flat":40,"margin/loan":40,"margin/transfer":40,"order/limit/batch":40,"order/ioc":13.334,"order/limit":13.334,"order/market":13.334,"order/modify":13.334,"order/stop/limit":13.334,"order/stop/market":13.334,"order/stop/modify":13.334,"sub_account/transfer":40,"sub_account/register":1,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api":40},put:{"balance/deposit/address/{coin_type}":40,"sub_account/unfrozen":40,"sub_account/frozen":40,"sub_account/auth/api/{user_auth_id}":40,"v1/account/settings":40},delete:{"balance/coin/withdraw":40,"order/pending/batch":40,"order/pending":13.334,"order/stop/pending":40,"order/stop/pending/{id}":13.334,"order/pending/by_client_id":40,"order/stop/pending/by_client_id":40,"sub_account/auth/api/{user_auth_id}":40,"sub_account/authorize/{id}":40}},perpetualPublic:{get:{ping:1,time:1,"market/list":1,"market/limit_config":1,"market/ticker":1,"market/ticker/all":1,"market/depth":1,"market/deals":1,"market/funding_history":1,"market/kline":1}},perpetualPrivate:{get:{"market/user_deals":1,"asset/query":40,"order/pending":8,"order/finished":40,"order/stop_finished":40,"order/stop_pending":8,"order/status":8,"order/stop_status":8,"position/finished":40,"position/pending":40,"position/funding":40,"position/adl_history":40,"market/preference":40,"position/margin_history":40,"position/settle_history":40},post:{"market/adjust_leverage":1,"market/position_expect":1,"order/put_limit":20,"order/put_market":20,"order/put_stop_limit":20,"order/put_stop_market":20,"order/modify":20,"order/modify_stop":20,"order/cancel":20,"order/cancel_all":40,"order/cancel_batch":40,"order/cancel_stop":20,"order/cancel_stop_all":40,"order/close_limit":20,"order/close_market":20,"position/adjust_margin":20,"position/stop_loss":20,"position/take_profit":20,"position/market_close":20,"order/cancel/by_client_id":20,"order/cancel_stop/by_client_id":20,"market/preference":20}}},v2:{public:{get:{"maintain/info":1,ping:1,time:1,"spot/market":1,"spot/ticker":1,"spot/depth":1,"spot/deals":1,"spot/kline":1,"spot/index":1,"futures/market":1,"futures/ticker":1,"futures/depth":1,"futures/deals":1,"futures/kline":1,"futures/index":1,"futures/funding-rate":1,"futures/funding-rate-history":1,"futures/position-level":1,"futures/liquidation-history":1,"futures/basis-history":1,"assets/deposit-withdraw-config":1,"assets/all-deposit-withdraw-config":1}},private:{get:{"account/subs":1,"account/subs/api-detail":40,"account/subs/info":1,"account/subs/api":40,"account/subs/transfer-history":40,"account/subs/spot-balance":1,"account/trade-fee-rate":40,"assets/spot/balance":40,"assets/futures/balance":40,"assets/margin/balance":1,"assets/financial/balance":40,"assets/amm/liquidity":40,"assets/credit/info":40,"assets/margin/borrow-history":40,"assets/margin/interest-limit":1,"assets/deposit-address":40,"assets/deposit-history":40,"assets/withdraw":40,"assets/transfer-history":40,"spot/order-status":8,"spot/batch-order-status":8,"spot/pending-order":8,"spot/finished-order":40,"spot/pending-stop-order":8,"spot/finished-stop-order":40,"spot/user-deals":40,"spot/order-deals":40,"futures/order-status":8,"futures/batch-order-status":1,"futures/pending-order":8,"futures/finished-order":40,"futures/pending-stop-order":8,"futures/finished-stop-order":40,"futures/user-deals":1,"futures/order-deals":1,"futures/pending-position":40,"futures/finished-position":1,"futures/position-margin-history":1,"futures/position-funding-history":40,"futures/position-adl-history":1,"futures/position-settle-history":1},post:{"account/subs":40,"account/subs/frozen":40,"account/subs/unfrozen":40,"account/subs/api":40,"account/subs/edit-api":40,"account/subs/delete-api":40,"account/subs/transfer":40,"account/settings":40,"assets/margin/borrow":40,"assets/margin/repay":40,"assets/renewal-deposit-address":40,"assets/withdraw":40,"assets/cancel-withdraw":40,"assets/transfer":40,"assets/amm/add-liquidity":1,"assets/amm/remove-liquidity":1,"spot/order":13.334,"spot/stop-order":13.334,"spot/batch-order":40,"spot/batch-stop-order":1,"spot/modify-order":13.334,"spot/modify-stop-order":13.334,"spot/cancel-all-order":1,"spot/cancel-order":6.667,"spot/cancel-stop-order":6.667,"spot/cancel-batch-order":10,"spot/cancel-batch-stop-order":10,"spot/cancel-order-by-client-id":1,"spot/cancel-stop-order-by-client-id":1,"futures/order":20,"futures/stop-order":20,"futures/batch-order":1,"futures/batch-stop-order":1,"futures/modify-order":20,"futures/modify-stop-order":20,"futures/cancel-all-order":1,"futures/cancel-order":10,"futures/cancel-stop-order":10,"futures/cancel-batch-order":20,"futures/cancel-batch-stop-order":20,"futures/cancel-order-by-client-id":1,"futures/cancel-stop-order-by-client-id":1,"futures/close-position":20,"futures/adjust-position-margin":20,"futures/adjust-position-leverage":20,"futures/set-position-stop-loss":20,"futures/set-position-take-profit":20}}}},fees:{trading:{maker:.001,taker:.001},funding:{withdraw:{BCH:0,BTC:.001,LTC:.001,ETH:.001,ZEC:1e-4,DASH:1e-4}}},limits:{amount:{min:.001,max:void 0}},options:{brokerId:"x-167673045",createMarketBuyOrderRequiresPrice:!0,defaultType:"spot",defaultSubType:"linear",fetchDepositAddress:{fillResponseFromRequest:!0},accountsByType:{spot:"SPOT",margin:"MARGIN",swap:"FUTURES"},accountsById:{SPOT:"spot",MARGIN:"margin",FUTURES:"swap"},networks:{BEP20:"BSC",TRX:"TRC20",ETH:"ERC20"}},commonCurrencies:{ACM:"Actinium"},precisionMode:o.kb,exceptions:{exact:{23:r.PermissionDenied,24:r.AuthenticationError,25:r.AuthenticationError,34:r.AuthenticationError,35:r.ExchangeNotAvailable,36:r.RequestTimeout,213:r.RateLimitExceeded,107:r.InsufficientFunds,158:r.PermissionDenied,600:r.OrderNotFound,601:r.InvalidOrder,602:r.InvalidOrder,606:r.InvalidOrder,3008:r.RequestTimeout,3109:r.InsufficientFunds,3127:r.InvalidOrder,3606:r.InvalidOrder,3610:r.ExchangeError,3612:r.InvalidOrder,3613:r.InvalidOrder,3614:r.InvalidOrder,3615:r.InvalidOrder,3616:r.InvalidOrder,3617:r.InvalidOrder,3618:r.InvalidOrder,3619:r.InvalidOrder,3620:r.InvalidOrder,3621:r.InvalidOrder,3622:r.InvalidOrder,3627:r.InvalidOrder,3628:r.InvalidOrder,3629:r.InvalidOrder,3632:r.InvalidOrder,3633:r.InvalidOrder,3634:r.InvalidOrder,3635:r.InvalidOrder,4001:r.ExchangeNotAvailable,4002:r.RequestTimeout,4003:r.ExchangeError,4004:r.BadRequest,4005:r.AuthenticationError,4006:r.AuthenticationError,4007:r.PermissionDenied,4008:r.AuthenticationError,4009:r.ExchangeError,4010:r.ExchangeError,4011:r.PermissionDenied,4017:r.ExchangeError,4115:r.AccountSuspended,4117:r.BadSymbol,4123:r.RateLimitExceeded,4130:r.ExchangeError,4158:r.ExchangeError,4213:r.RateLimitExceeded,4512:r.PermissionDenied},broad:{"ip not allow visit":r.PermissionDenied,"service too busy":r.ExchangeNotAvailable}}})}async fetchCurrencies(e={}){const t=await this.v2PublicGetAssetsAllDepositWithdrawConfig(e),s=this.safeList(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeDict(t,"asset",{}),a=this.safeList(t,"chains",[]),o=this.safeString(r,"ccy");if(void 0===o)continue;const n=this.safeCurrencyCode(o),d=this.safeBool(r,"deposit_enabled"),h=this.safeBool(r,"withdraw_enabled"),c=this.safeDict(a,0,{}),l=this.parsePrecision(this.safeString(c,"withdrawal_precision"));i[n]={id:o,code:n,name:void 0,active:d&&h,deposit:d,withdraw:h,fee:void 0,precision:this.parseNumber(l),limits:{amount:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{},info:t};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"chain"),r=this.parsePrecision(this.safeString(t,"withdrawal_precision")),o=this.safeString(t,"withdrawal_fee"),d=this.safeString(t,"min_deposit_amount"),h=this.safeString(t,"min_withdraw_amount"),c=this.safeBool(t,"deposit_enabled"),l=this.safeBool(t,"withdraw_enabled"),u={id:s,network:s,name:void 0,active:c&&l,deposit:c,withdraw:l,fee:this.parseNumber(o),precision:this.parseNumber(r),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.parseNumber(d),max:void 0},withdraw:{min:this.parseNumber(h),max:void 0}},info:t},p=this.safeDict(i[n],"networks",{});p[s]=u,i[n].networks=p}}return i}async fetchMarkets(e={}){const t=[this.fetchSpotMarkets(e),this.fetchContractMarkets(e)],s=await Promise.all(t),i=s[0],r=s[1];return this.arrayConcat(i,r)}async fetchSpotMarkets(e){const t=await this.v2PublicGetSpotMarket(e),s=this.safeList(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"market"),a=this.safeString(t,"base_ccy"),o=this.safeString(t,"quote_ccy"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=n+"/"+d;i.push({id:r,symbol:h,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(t,"taker_fee_rate"),maker:this.safeNumber(t,"maker_fee_rate"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"base_ccy_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quote_ccy_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}async fetchContractMarkets(e){const t=await this.v2PublicGetFuturesMarket(e),s=this.safeList(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.fees,a=this.safeList(t,"leverage",[]),o=this.safeString(t,"contract_type"),n="linear"===o,d="inverse"===o,h=this.safeString(t,"market"),c=this.safeString(t,"base_ccy"),l=this.safeString(t,"quote_ccy"),u=this.safeCurrencyCode(c),p=this.safeCurrencyCode(l),f="linear"===o?"USDT":c,m=this.safeCurrencyCode(f),g=u+"/"+p+":"+m,v=a.length;i.push({id:h,symbol:g,base:u,quote:p,settle:m,baseId:c,quoteId:l,settleId:f,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:void 0,contract:!0,linear:n,inverse:d,taker:r.trading.taker,maker:r.trading.maker,contractSize:this.parseNumber("1"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"base_ccy_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quote_ccy_precision")))},limits:{leverage:{min:this.safeNumber(a,0),max:this.safeNumber(a,v-1)},amount:{min:this.safeNumber(t,"min_amount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}parseTicker(e,t=void 0){const s="mark_price"in e?"swap":"spot",i=this.safeString(e,"market"),r=this.safeSymbol(i,t,void 0,s);return this.safeTicker({symbol:r,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"volume_buy"),ask:void 0,askVolume:this.safeString(e,"volume_sell"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id};let r;r=s.swap?await this.v2PublicGetFuturesTicker(this.extend(i,t)):await this.v2PublicGetSpotTicker(this.extend(i,t));const a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){let s;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))){const t=this.safeValue(e,0);s=this.market(t)}const[i,r]=this.handleMarketTypeAndParams("fetchTickers",s,t);let a;a="swap"===i?await this.v2PublicGetFuturesTicker(r):await this.v2PublicGetSpotTicker(r);const o=this.safeList(a,"data",[]);return this.parseTickers(o,e)}async fetchTime(e={}){const t=await this.v2PublicGetTime(e),s=this.safeDict(t,"data",{});return this.safeInteger(s,"timestamp")}async fetchOrderBook(e,t=20,s={}){await this.loadMarkets();const i=this.market(e);void 0===t&&(t=20);const r={market:i.id,limit:t,interval:"0"};let a;a=i.swap?await this.v2PublicGetFuturesDepth(this.extend(r,s)):await this.v2PublicGetSpotDepth(this.extend(r,s));const o=this.safeDict(a,"data",{}),n=this.safeDict(o,"depth",{}),d=this.safeInteger(n,"updated_at");return this.parseOrderBook(n,e,d)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"created_at");let i=this.safeString(this.options,"defaultType");void 0!==t&&(i=t.type);const r=this.safeString(e,"market");return t=this.safeMarket(r,t,void 0,i),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,id:this.safeString(e,"deal_id"),order:this.safeString(e,"order_id"),type:void 0,side:this.safeString(e,"side"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:this.safeString(e,"deal_money"),fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};let o;return void 0!==s&&(a.limit=s),o=r.swap?await this.v2PublicGetFuturesDeals(this.extend(a,i)):await this.v2PublicGetSpotDeals(this.extend(a,i)),this.parseTrades(o.data,r,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id};let r;r=s.spot?await this.v2PublicGetSpotMarket(this.extend(i,t)):await this.v2PublicGetFuturesMarket(this.extend(i,t));const a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTradingFee(o,s)}async fetchTradingFees(e={}){let t,s;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e),s="swap"===t?await this.v2PublicGetFuturesMarket(e):await this.v2PublicGetSpotMarket(e);const i=this.safeList(s,"data",[]),r={};for(let e=0;e<i.length;e++){const s=i[e],a=this.safeString(s,"market"),o=this.safeMarket(a,void 0,void 0,t);r[o.symbol]=this.parseTradingFee(s,o)}return r}parseTradingFee(e,t=void 0){const s=this.safeValue(e,"market");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:!0,tierBased:!0}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"created_at"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"value")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,period:this.safeString(this.timeframes,t,t)};let n;void 0!==i&&(o.limit=i),n=a.swap?await this.v2PublicGetFuturesKline(this.extend(o,r)):await this.v2PublicGetSpotKline(this.extend(o,r));const d=this.safeList(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}async fetchMarginBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetAssetsMarginBalance(e),s={info:t},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeDict(t,"available",{}),o=this.safeDict(t,"frozen",{}),n=this.safeDict(t,"repaid",{}),d=this.safeDict(t,"interest",{}),h=this.account(),c=this.safeString(t,"base_ccy"),l=this.safeCurrencyCode(c);h.free=this.safeString(r,"base_ccy"),h.used=this.safeString(o,"base_ccy");const u=this.safeString(n,"base_ccy"),p=this.safeString(d,"base_ccy");h.debt=a.Y.stringAdd(u,p),s[l]=h}return this.safeBalance(s)}async fetchSpotBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetAssetsSpotBalance(e),s={info:t},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),s[a]=o}return this.safeBalance(s)}async fetchSwapBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetAssetsFuturesBalance(e),s={info:t},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),s[a]=o}return this.safeBalance(s)}async fetchFinancialBalance(e={}){await this.loadMarkets();const t=await this.v2PrivateGetAssetsFinancialBalance(e),s={info:t},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.used=this.safeString(t,"frozen"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){let t,s;[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[s,e]=this.handleMarginModeAndParams("fetchBalance",e);const i=void 0!==s||"margin"===t;return"swap"===t?await this.fetchSwapBalance(e):"financial"===t?await this.fetchFinancialBalance(e):i?await this.fetchMarginBalance(e):await this.fetchSpotBalance(e)}parseOrderStatus(e){return this.safeString({rejected:"rejected",open:"open",not_deal:"open",part_deal:"open",done:"closed",cancel:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeInteger(e,"created_at");let r=this.safeInteger(e,"updated_at");0===r&&(r=i);const a=this.safeString(e,"market"),o=this.safeString(this.options,"defaultType");let n=this.safeStringLower(e,"market_type",o);"futures"===n&&(n="swap");const d="swap"===n?"swap":"spot";t=this.safeMarket(a,t,void 0,d);const h=this.safeString(e,"fee_ccy");let c=this.safeCurrencyCode(h);void 0===c&&(c=t.quote);let l=this.safeString(e,"side");"long"===l?l="buy":"short"===l&&(l="sell");let u=this.safeString(e,"client_id");return""===u&&(u=void 0),this.safeOrder({id:this.safeStringN(e,["position_id","order_id","stop_id"]),clientOrderId:u,datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:r,status:this.parseOrderStatus(s),symbol:t.symbol,type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:l,price:this.safeString(e,"price"),stopPrice:this.safeString(e,"trigger_price"),triggerPrice:this.safeString(e,"trigger_price"),takeProfitPrice:this.safeNumber(e,"take_profit_price"),stopLossPrice:this.safeNumber(e,"stop_loss_price"),cost:this.safeString(e,"filled_value"),average:this.safeString(e,"avg_entry_price"),amount:this.safeString(e,"amount"),filled:this.safeString(e,"filled_amount"),remaining:this.safeString(e,"unfilled_amount"),trades:void 0,fee:{currency:c,cost:this.safeString2(e,"quote_fee","fee")},info:e},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}createOrderRequest(e,t,s,i,o=void 0,n={}){const d=this.market(e),h=d.swap,c=this.safeString2(n,"client_id","clientOrderId"),l=this.safeString2(n,"stopPrice","triggerPrice"),u=this.safeString(n,"stopLossPrice"),p=this.safeString(n,"takeProfitPrice"),f=this.safeString(n,"option"),m="market"===t,g=this.isPostOnly(m,"maker_only"===f,n),v=this.safeStringUpper(n,"timeInForce"),y=this.safeBool(n,"reduceOnly");if(y&&!d.swap)throw new r.InvalidOrder(this.id+" createOrder() does not support reduceOnly for "+d.type+" orders, reduceOnly orders are supported for swap markets only");const w={market:d.id};if(void 0===c){const e="x-167673045",t=this.safeString(this.options,"brokerId",e);w.client_id=t+"-"+this.uuid16()}else w.client_id=c;if(void 0===u&&void 0===p){y||(w.side=s);let i=t;g?i="maker_only":void 0!==v&&("IOC"===v?i="ioc":"FOK"===v&&(i="fok")),m||(w.price=this.priceToPrecision(e,o)),w.type=i}if(h)w.market_type="FUTURES",u||p?u?(w.stop_loss_price=this.priceToPrecision(e,u),w.stop_loss_type=this.safeString(n,"stop_type","latest_price")):p&&(w.take_profit_price=this.priceToPrecision(e,p),w.take_profit_type=this.safeString(n,"stop_type","latest_price")):(w.amount=this.amountToPrecision(e,i),void 0!==l&&(w.trigger_price=this.priceToPrecision(e,l),w.trigger_price_type=this.safeString(n,"stop_type","latest_price")));else{let d;if([d,n]=this.handleMarginModeAndParams("createOrder",n),w.market_type=void 0!==d?"MARGIN":"SPOT","market"===t&&"buy"===s){let t=!0;[t,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const s=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),t){if(void 0===o&&void 0===s)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const t=this.numberToString(i),r=this.numberToString(o),n=this.parseToNumeric(a.Y.stringMul(t,r)),d=void 0!==s?s:n;w.amount=this.costToPrecision(e,d)}}else w.amount=this.costToPrecision(e,i)}else w.amount=this.amountToPrecision(e,i);void 0!==l&&(w.trigger_price=this.priceToPrecision(e,l))}return n=this.omit(n,["reduceOnly","timeInForce","postOnly","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(w,n)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"reduceOnly"),d=void 0!==this.safeString2(a,"stopPrice","triggerPrice"),h=void 0!==this.safeString(a,"stopLossPrice"),c=void 0!==this.safeString(a,"takeProfitPrice"),l=h||c,u=this.createOrderRequest(e,t,s,i,r,a);let p;o.spot?p=d?await this.v2PrivatePostSpotStopOrder(u):await this.v2PrivatePostSpotOrder(u):d?p=await this.v2PrivatePostFuturesStopOrder(u):l?h?p=await this.v2PrivatePostFuturesSetPositionStopLoss(u):c&&(p=await this.v2PrivatePostFuturesSetPositionTakeProfit(u)):p=n?await this.v2PrivatePostFuturesClosePosition(u):await this.v2PrivatePostFuturesOrder(u);const f=this.safeDict(p,"data",{});return this.parseOrder(f,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i,a=!1,o=!1,n=!1;for(let t=0;t<e.length;t++){const d=e[t],h=this.safeString(d,"symbol");if(void 0===i)i=h;else if(i!==h)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const c=this.safeString(d,"type"),l=this.safeString(d,"side"),u=this.safeValue(d,"amount"),p=this.safeValue(d,"price"),f=this.safeValue(d,"params",{});if("limit"!==c)throw new r.NotSupported(this.id+" createOrders() does not support "+c+" orders, only limit orders are accepted");a=this.safeValue(f,"reduceOnly");const m=this.safeNumber2(f,"stopPrice","triggerPrice"),g=this.safeNumber(f,"stopLossPrice"),v=this.safeNumber(f,"takeProfitPrice");o=void 0!==m;n=void 0!==g||void 0!==v;const y=this.createOrderRequest(h,c,l,u,p,f);s.push(y)}const d=this.market(i),h={market:d.id,orders:s};let c;if(d.spot)c=o?await this.v2PrivatePostSpotBatchStopOrder(h):await this.v2PrivatePostSpotBatchOrder(h);else if(o)c=await this.v2PrivatePostFuturesBatchStopOrder(h);else{if(n)throw new r.NotSupported(this.id+" createOrders() does not support stopLossPrice or takeProfitPrice orders");if(a)throw new r.NotSupported(this.id+" createOrders() does not support reduceOnly orders");c=await this.v2PrivatePostFuturesBatchOrder(h)}const l=this.safeList(c,"data",[]),u=[];for(let e=0;e<l.length;e++){const t=l[e];let s;const i=this.safeInteger(t,"code");void 0!==i&&(s=0!==i?"rejected":"open");const r=this.safeDict(t,"data",{});let a;d.spot&&!o?(t.status=s,a=this.parseOrder(t,d)):(r.status=s,a=this.parseOrder(r,d)),u.push(a)}return u}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={market:i.id},o=this.safeBool2(s,"stop","trigger");let n;s=this.omit(s,["stop","trigger"]),o?a.stop_ids=e:a.order_ids=e,i.spot?n=o?await this.v2PrivatePostSpotCancelBatchStopOrder(this.extend(a,s)):await this.v2PrivatePostSpotCancelBatchOrder(this.extend(a,s)):(a.market_type="FUTURES",n=o?await this.v2PrivatePostFuturesCancelBatchStopOrder(this.extend(a,s)):await this.v2PrivatePostFuturesCancelBatchOrder(this.extend(a,s)));const d=this.safeList(n,"data",[]),h=[];for(let e=0;e<d.length;e++){const t=d[e],s=this.safeDict(t,"data",{}),r=this.parseOrder(s,i);h.push(r)}return h}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" editOrder() requires a symbol argument");await this.loadMarkets();const d=this.market(t),h={market:d.id};let c;void 0!==a&&(h.amount=this.amountToPrecision(t,a)),void 0!==o&&(h.price=this.priceToPrecision(t,o));const l=this.safeStringN(n,["stopPrice","triggerPrice","trigger_price"]);n=this.omit(n,["stopPrice","triggerPrice"]);const u=void 0!==l;let p;u?(h.trigger_price=this.priceToPrecision(t,l),h.stop_id=this.parseToNumeric(e)):h.order_id=this.parseToNumeric(e),[p,n]=this.handleMarginModeAndParams("editOrder",n),d.spot?(h.market_type=void 0!==p?"MARGIN":"SPOT",c=u?await this.v2PrivatePostSpotModifyStopOrder(this.extend(h,n)):await this.v2PrivatePostSpotModifyOrder(this.extend(h,n))):(h.market_type="FUTURES",c=u?await this.v2PrivatePostFuturesModifyStopOrder(this.extend(h,n)):await this.v2PrivatePostFuturesModifyOrder(this.extend(h,n)));const f=this.safeDict(c,"data",{});return this.parseOrder(f,d)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeBool2(s,"stop","trigger"),o=i.swap,n={market:i.id};let d;[d,s]=this.handleMarginModeAndParams("cancelOrder",s),n.market_type=o?"FUTURES":void 0!==d?"MARGIN":"SPOT";const h=this.safeString2(s,"client_id","clientOrderId");let c,l;if(s=this.omit(s,["stop","trigger","clientOrderId"]),void 0!==h?(n.client_id=h,c=a?o?await this.v2PrivatePostFuturesCancelStopOrderByClientId(this.extend(n,s)):await this.v2PrivatePostSpotCancelStopOrderByClientId(this.extend(n,s)):o?await this.v2PrivatePostFuturesCancelOrderByClientId(this.extend(n,s)):await this.v2PrivatePostSpotCancelOrderByClientId(this.extend(n,s))):a?(n.stop_id=this.parseToNumeric(e),c=o?await this.v2PrivatePostFuturesCancelStopOrder(this.extend(n,s)):await this.v2PrivatePostSpotCancelStopOrder(this.extend(n,s))):(n.order_id=this.parseToNumeric(e),c=o?await this.v2PrivatePostFuturesCancelOrder(this.extend(n,s)):await this.v2PrivatePostSpotCancelOrder(this.extend(n,s))),void 0!==h){const e=this.safeList(c,"data",[]);l=this.safeDict(e[0],"data",{})}else l=this.safeDict(c,"data",{});return this.parseOrder(l,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={market:s.id};let a;if(s.swap)i.market_type="FUTURES",a=await this.v2PrivatePostFuturesCancelAllOrder(this.extend(i,t));else{let e;[e,t]=this.handleMarginModeAndParams("cancelAllOrders",t),i.market_type=void 0!==e?"MARGIN":"SPOT",a=await this.v2PrivatePostSpotCancelAllOrder(this.extend(i,t))}return[this.safeOrder({info:a})]}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={market:i.id,order_id:this.parseToNumeric(e)};let o;o=i.swap?await this.v2PrivateGetFuturesOrderStatus(this.extend(a,s)):await this.v2PrivateGetSpotOrderStatus(this.extend(a,s));const n=this.safeDict(o,"data",{});return this.parseOrder(n,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==t&&(o=this.market(t),a.market=o.id),void 0!==i&&(a.limit=i);const n=this.safeBool2(r,"stop","trigger");let d,h;r=this.omit(r,["stop","trigger"]),[d,r]=this.handleMarketTypeAndParams("fetchOrdersByStatus",o,r);const c="finished"===e||"closed"===e,l="pending"===e||"open"===e;if("swap"===d)a.market_type="FUTURES",c?h=n?await this.v2PrivateGetFuturesFinishedStopOrder(this.extend(a,r)):await this.v2PrivateGetFuturesFinishedOrder(this.extend(a,r)):l&&(h=n?await this.v2PrivateGetFuturesPendingStopOrder(this.extend(a,r)):await this.v2PrivateGetFuturesPendingOrder(this.extend(a,r)));else{let t;[t,r]=this.handleMarginModeAndParams("fetchOrdersByStatus",r),a.market_type=void 0!==t?"MARGIN":"SPOT",c?h=n?await this.v2PrivateGetSpotFinishedStopOrder(this.extend(a,r)):await this.v2PrivateGetSpotFinishedOrder(this.extend(a,r)):"pending"===e&&(h=n?await this.v2PrivateGetSpotPendingStopOrder(this.extend(a,r)):await this.v2PrivateGetSpotPendingOrder(this.extend(a,r)))}const u=this.safeList(h,"data",[]);return this.parseOrders(u,o,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchOrdersByStatus("pending",e,t,s,i);for(let e=0;e<r.length;e++)r[e].status="open";return r}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString2(t,"chain","network");if(void 0===i)throw new r.ArgumentsRequired(this.id+" createDepositAddress() requires a network parameter");t=this.omit(t,"network");const a={ccy:s.id,chain:this.networkCodeToId(i,s.code)},o=await this.v2PrivatePostAssetsRenewalDepositAddress(this.extend(a,t)),n=this.safeDict(o,"data",{});return this.parseDepositAddress(n,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeDict(s,"networks",{}),a=this.safeString2(t,"network","chain");t=this.omit(t,"network");const o=Object.keys(i).length;if(void 0!==i&&o>1){if(void 0===a)throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() "+e+" requires a network parameter");if(!(a in i))throw new r.ExchangeError(this.id+" fetchDepositAddress() "+a+" network not supported for "+e)}const n={ccy:s.id,chain:a},d=await this.v2PrivateGetAssetsDepositAddress(this.extend(n,t)),h=this.safeDict(d,"data",{}),c=this.parseDepositAddress(h,s),l=this.safeDict(this.options,"fetchDepositAddress",{});return this.safeBool(l,"fillResponseFromRequest",!0)&&(c.network=this.networkIdToCode(a,s).toUpperCase()),c}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=s.split(":");let r,a;return i.length>1&&"cfx"!==i[0]?(r=i[0],a=i[1]):r=s,{info:e,currency:this.safeCurrencyCode(void 0,t),address:r,tag:a,network:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e);let o,n={market:a.id};if(void 0!==s&&(n.limit=s),void 0!==t&&(n.start_time=t),[n,i]=this.handleUntilOption("end_time",n,i),a.swap)n.market_type="FUTURES",o=await this.v2PrivateGetFuturesUserDeals(this.extend(n,i));else{let e;[e,i]=this.handleMarginModeAndParams("fetchMyTrades",i),n.market_type=void 0!==e?"MARGIN":"SPOT",o=await this.v2PrivateGetSpotUserDeals(this.extend(n,i))}const d=this.safeList(o,"data",[]);return this.parseTrades(d,a,t,s)}async fetchPositions(e=void 0,t={}){let s;await this.loadMarkets(),[s,t]=this.handleOptionAndParams(t,"fetchPositions","method","v2PrivateGetFuturesPendingPosition");const i={market_type:"FUTURES"};let a,o;if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new r.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;a=this.market(t),i.market=a.id}o="v2PrivateGetFuturesPendingPosition"===s?await this.v2PrivateGetFuturesPendingPosition(this.extend(i,t)):await this.v2PrivateGetFuturesFinishedPosition(this.extend(i,t));const n=this.safeList(o,"data",[]),d=[];for(let e=0;e<n.length;e++)d.push(this.parsePosition(n[e],a));return this.filterByArrayPositions(d,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_type:"FUTURES",market:s.id},r=await this.v2PrivateGetFuturesPendingPosition(this.extend(i,t)),a=this.safeList(r,"data",[]);return this.parsePosition(a[0],s)}parsePosition(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,void 0,"swap");const i=this.safeInteger(e,"created_at");return this.safePosition({info:e,id:this.safeInteger(e,"position_id"),symbol:t.symbol,notional:this.safeNumber(e,"settle_value"),marginMode:this.safeString(e,"margin_mode"),liquidationPrice:this.safeNumber(e,"liq_price"),entryPrice:this.safeNumber(e,"avg_entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),realizedPnl:this.safeNumber(e,"realized_pnl"),percentage:void 0,contracts:this.safeNumber(e,"close_avbl"),contractSize:this.safeNumber(t,"contractSize"),markPrice:void 0,lastPrice:void 0,side:this.safeString(e,"side"),hedged:void 0,timestamp:i,datetime:this.iso8601(i),lastUpdateTimestamp:this.safeInteger(e,"updated_at"),maintenanceMargin:this.safeNumber(e,"maintenance_margin_value"),maintenanceMarginPercentage:this.safeNumber(e,"maintenance_margin_rate"),collateral:this.safeNumber(e,"margin_avbl"),initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:this.safeNumber(e,"position_margin_rate"),stopLossPrice:this.omitZero(this.safeString(e,"stop_loss_price")),takeProfitPrice:this.omitZero(this.safeString(e,"take_profit_price"))})}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("isolated"!==(e=e.toLowerCase())&&"cross"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");await this.loadMarkets();const i=this.market(t);if("swap"!==i.type)throw new r.BadSymbol(this.id+" setMarginMode() supports swap contracts only");const a=this.safeInteger(s,"leverage"),o=this.safeInteger(i.limits.leverage,"max",100);if(void 0===a)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter");if(a<1||a>o)throw new r.BadRequest(this.id+" setMarginMode() leverage should be between 1 and "+o.toString()+" for "+t);const n={market:i.id,market_type:"FUTURES",margin_mode:e,leverage:a};return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(n,s))}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.swap)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");let a;[a,s]=this.handleMarginModeAndParams("setLeverage",s,"cross");const o=this.safeInteger(i.limits.leverage,"min",1),n=this.safeInteger(i.limits.leverage,"max",100);if(e<o||e>n)throw new r.BadRequest(this.id+" setLeverage() leverage should be between "+o.toString()+" and "+n.toString()+" for "+t);const d={market:i.id,market_type:"FUTURES",margin_mode:a,leverage:e};return await this.v2PrivatePostFuturesAdjustPositionLeverage(this.extend(d,s))}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=this.marketIds(e);s.market=t.join(",")}const i=await this.v2PublicGetFuturesPositionLevel(this.extend(s,t)),r=this.safeList(i,"data",[]);return this.parseLeverageTiers(r,e,"market")}parseMarketLeverageTiers(e,t=void 0){const s=[],i=this.safeList(e,"level",[]);let r=0;for(let a=0;a<i.length;a++){const o=i[a],n=this.safeString(e,"market");t=this.safeMarket(n,t,void 0,"swap");const d=this.safeNumber(o,"amount");s.push({tier:this.sum(a,1),currency:t.linear?t.base:t.quote,minNotional:r,maxNotional:d,maintenanceMarginRate:this.safeNumber(o,"maintenance_margin_rate"),maxLeverage:this.safeInteger(o,"leverage"),info:o}),r=d}return s}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),o=this.amountToPrecision(e,t);let n=o;"reduce"===s&&(n=a.Y.stringNeg(o));const d={market:r.id,market_type:"FUTURES",amount:n},h=await this.v2PrivatePostFuturesAdjustPositionMargin(this.extend(d,i)),c=this.safeDict(h,"data"),l=this.safeStringLower(h,"message"),u="reduce"===s?"reduce":"add";return this.extend(this.parseMarginModification(c,r),{type:u,amount:this.parseNumber(t),status:l})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeInteger2(e,"updated_at","created_at"),r=this.safeString(e,"margin_change");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),type:void 0,marginMode:"isolated",amount:this.parseNumber(a.Y.stringAbs(r)),total:this.safeNumber(e,"margin_avbl"),code:t.quote,status:void 0,timestamp:i,datetime:this.iso8601(i)}}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();let a={market:this.market(e).id,market_type:"FUTURES"};[a,i]=this.handleUntilOption("end_time",a,i),void 0!==t&&(a.start_time=t),void 0!==s&&(a.limit=s);const o=await this.v2PrivateGetFuturesPositionFundingHistory(this.extend(a,i)),n=this.safeList(o,"data",[]),d=[];for(let t=0;t<n.length;t++){const s=n[t],i=this.safeInteger(s,"created_at"),r=this.safeString(s,"ccy"),a=this.safeCurrencyCode(r);d.push({info:s,symbol:e,code:a,timestamp:i,datetime:this.iso8601(i),id:this.safeNumber(s,"position_id"),amount:this.safeNumber(s,"funding_value")})}return d}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={market:s.id},a=await this.v2PublicGetFuturesFundingRate(this.extend(i,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseFundingRate(n,s)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"latest_funding_time"),i=this.safeInteger(e,"next_funding_time"),r=this.safeString(e,"market");return{info:e,symbol:this.safeSymbol(r,t,void 0,"swap"),markPrice:this.safeNumber(e,"mark_price"),indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"latest_funding_rate"),fundingTimestamp:s,fundingDatetime:this.iso8601(s),nextFundingRate:this.safeNumber(e,"next_funding_rate"),nextFundingTimestamp:i,nextFundingDatetime:this.iso8601(i),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(void 0!==(e=this.marketSymbols(e))){const t=this.safeValue(e,0);if(i=this.market(t),!i.swap)throw new r.BadSymbol(this.id+" fetchFundingRates() supports swap contracts only");const a=this.marketIds(e);s.market=a.join(",")}const a=await this.v2PublicGetFuturesFundingRate(this.extend(s,t)),o=this.safeList(a,"data",[]),n=this.parseFundingRates(o,i);return this.filterByArray(n,"symbol",e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o=this.safeStringUpper2(r,"network","chain");r=this.omit(r,"network"),i&&(s=s+":"+i);const n={ccy:a.id,to_address:s,amount:this.numberToString(t)};void 0!==o&&(n.chain=this.networkCodeToId(o));const d=await this.v2PrivatePostAssetsWithdraw(this.extend(n,r)),h=this.safeDict(d,"data",{});return this.parseTransaction(h,a)}parseTransactionStatus(e){return this.safeString({audit:"pending",pass:"pending",processing:"pending",confirming:"pending",not_pass:"failed",cancel:"canceled",finish:"ok",fail:"failed"},e,e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,1e3);const o=this.market(e);let n={market:o.id};void 0!==t&&(n.start_time=t),void 0!==s&&(n.limit=s),[n,i]=this.handleUntilOption("end_time",n,i);const d=await this.v2PublicGetFuturesFundingRateHistory(this.extend(n,i)),h=this.safeList(d,"data",[]),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"market"),i=this.safeSymbol(s,o,void 0,"swap"),r=this.safeInteger(t,"funding_time");c.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"actual_funding_rate"),timestamp:r,datetime:this.iso8601(r)})}const l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,o.symbol,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"to_address");let i=this.safeString(e,"memo");void 0!==i&&i.length<1&&(i=void 0);let r=this.safeString(e,"remark");void 0!==r&&r.length<1&&(r=void 0);let a=this.safeString(e,"tx_id");void 0!==a&&a.length<1&&(a=void 0);const o=this.safeString(e,"ccy"),n=this.safeCurrencyCode(o,t),d=this.safeInteger(e,"created_at"),h="withdraw_id"in e?"withdrawal":"deposit",c=this.safeString(e,"chain");let l=this.safeString(e,"tx_fee");const u="local"===this.safeStringLower2(e,"withdraw_method","deposit_method");let p=this.safeNumber(e,"actual_amount");void 0===p&&(p=this.safeNumber(e,"amount")),"deposit"===h&&(l="0");const f=this.safeString(e,"fee_asset"),m={cost:this.parseNumber(l),currency:this.safeCurrencyCode(f)};return{info:e,id:this.safeString2(e,"withdraw_id","deposit_id"),txid:a,timestamp:d,datetime:this.iso8601(d),network:this.networkIdToCode(c),address:s,addressTo:s,addressFrom:void 0,tag:i,tagTo:void 0,tagFrom:void 0,type:h,amount:p,currency:n,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:void 0,fee:m,comment:r,internal:u}}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n=this.currencyToPrecision(e,t),d=this.safeDict(this.options,"accountsById",{}),h=this.safeString(d,s,s),c=this.safeString(d,i,i),l={ccy:o.id,amount:n,from_account_type:h,to_account_type:c};if("margin"===s||"margin"===i){const e=this.safeString(a,"symbol");if(void 0===e)throw new r.ArgumentsRequired(this.id+" transfer() the symbol parameter must be defined for a margin account");a=this.omit(a,"symbol"),l.market=this.marketId(e)}if("spot"!==s&&"spot"!==i)throw new r.BadRequest(this.id+" transfer() can only be between spot and swap, or spot and margin, either the fromAccount or toAccount must be spot");const u=await this.v2PrivatePostAssetsTransfer(this.extend(l,a));return this.extend(this.parseTransfer(u,o),{amount:this.parseNumber(n),fromAccount:s,toAccount:i})}parseTransferStatus(e){return this.safeString({0:"ok",SUCCESS:"ok",OK:"ok",finished:"ok",FINISHED:"ok"},e,e)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.safeString(e,"ccy"),r=this.safeString(e,"from_account_type"),a=this.safeString(e,"to_account_type"),o=this.safeValue(this.options,"accountsById",{});return{id:void 0,timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(o,r,r),toAccount:this.safeString(o,a,a),status:this.parseTransferStatus(this.safeString2(e,"code","status"))}}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTransfers() requires a code argument");const a=this.currency(e);let o,n={ccy:a.id};[o,i]=this.handleMarginModeAndParams("fetchTransfers",i),n.transfer_type=void 0!==o?"MARGIN":"FUTURES",void 0!==t&&(n.start_time=t),void 0!==s&&(n.limit=s),[n,i]=this.handleUntilOption("end_time",n,i);const d=await this.v2PrivateGetAssetsTransferHistory(this.extend(n,i)),h=this.safeList(d,"data",[]);return this.parseTransfers(h,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.ccy=a.id),void 0!==s&&(r.limit=s);const o=await this.v2PrivateGetAssetsWithdraw(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.ccy=a.id),void 0!==s&&(r.limit=s);const o=await this.v2PrivateGetAssetsDepositHistory(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}parseIsolatedBorrowRate(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,void 0,"spot");const i=this.safeString(e,"ccy"),r=this.safeNumber(e,"daily_interest_rate");let a,o;return i===t.baseId?a=r:i===t.quoteId&&(o=r),{symbol:t.symbol,base:t.base,baseRate:a,quote:t.quote,quoteRate:o,period:864e5,timestamp:void 0,datetime:void 0,info:e}}async fetchIsolatedBorrowRate(e,t={}){await this.loadMarkets();const s=this.safeString(t,"code");if(void 0===s)throw new r.ArgumentsRequired(this.id+" fetchIsolatedBorrowRate() requires a code parameter");t=this.omit(t,"code");const i=this.currency(s),a=this.market(e),o={market:a.id,ccy:i.id},n=await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(o,t)),d=this.safeDict(n,"data",{});return this.parseIsolatedBorrowRate(d,a)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==t&&(o=this.market(t),a.market=o.id),void 0!==i&&(a.limit=i);const n=await this.v2PrivateGetAssetsMarginBorrowHistory(this.extend(a,r)),d=this.safeValue(n,"data",[]),h=this.parseBorrowInterests(d,o);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t,void 0,"spot");const i=this.safeInteger(e,"expired_at");return{account:void 0,symbol:t.symbol,marginMode:"isolated",marginType:void 0,currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"to_repaied_amount"),interestRate:this.safeNumber(e,"daily_interest_rate"),amountBorrowed:this.safeNumber(e,"borrow_amount"),timestamp:i,datetime:this.iso8601(i),info:e}}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o=this.safeBool2(i,"isAutoRenew","is_auto_renew",!1);i=this.omit(i,"isAutoRenew");const n={market:r.id,ccy:a.id,borrow_amount:this.currencyToPrecision(t,s),is_auto_renew:o},d=await this.v2PrivatePostAssetsMarginBorrow(this.extend(n,i)),h=this.safeDict(d,"data",{}),c=this.parseMarginLoan(h,a);return this.extend(c,{amount:s,symbol:e})}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o={market:r.id,ccy:a.id,amount:this.currencyToPrecision(t,s)},n=await this.v2PrivatePostAssetsMarginRepay(this.extend(o,i)),d=this.safeDict(n,"data",{}),h=this.parseMarginLoan(d,a);return this.extend(h,{amount:s,symbol:e})}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"ccy"),i=this.safeString(e,"market"),r=this.safeInteger(e,"expired_at");return{id:this.safeInteger(e,"borrow_id"),currency:this.safeCurrencyCode(s,t),amount:this.safeString(e,"borrow_amount"),symbol:this.safeSymbol(i,void 0,void 0,"spot"),timestamp:r,datetime:this.iso8601(r),info:e}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={ccy:s.id},r=await this.v2PublicGetAssetsDepositWithdrawConfig(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseDepositWithdrawFee(a,s)}parseDepositWithdrawFee(e,t=void 0){const s={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}},i=this.safeList(e,"chains",[]),r=this.safeDict(e,"asset",{});for(let e=0;e<i.length;e++){const t=i[e];if(this.safeBool(t,"withdraw_enabled")){s.withdraw.fee=this.safeNumber(t,"withdrawal_fee"),s.withdraw.percentage=!1;const e=this.safeString(t,"chain");if(e){const i=this.networkIdToCode(e,this.safeString(r,"ccy"));s.networks[i]={withdraw:{fee:this.safeNumber(t,"withdrawal_fee"),percentage:!1},deposit:{fee:void 0,percentage:void 0}}}}}return s}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.safeString(t,"code");if(void 0===s)throw new r.ArgumentsRequired(this.id+" fetchLeverage() requires a code parameter");t=this.omit(t,"code");const i=this.currency(s),a=this.market(e),o={market:a.id,ccy:i.id},n=await this.v2PrivateGetAssetsMarginInterestLimit(this.extend(o,t)),d=this.safeDict(n,"data",{});return this.parseLeverage(d,a)}parseLeverage(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t,void 0,"spot"),marginMode:"isolated",longLeverage:i,shortLeverage:i}}async fetchPositionHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r={market_type:"FUTURES",market:this.market(e).id};void 0!==s&&(r.limit=s),void 0!==t&&(r.start_time=t),[r,i]=this.handleUntilOption("end_time",r,i);const a=await this.v2PrivateGetFuturesFinishedPosition(this.extend(r,i)),o=this.safeList(a,"data",[]),n=this.parsePositions(o);return this.filterBySymbolSinceLimit(n,e,t,s)}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),r=this.safeBool(t,"margin",!1);let a;return[a,t]=super.handleMarginModeAndParams(e,t,s),void 0===a&&("margin"!==i&&!0!==r||(a="isolated")),[a,t]}nonce(){return this.milliseconds()}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){e=this.implodeParams(e,i);const o=t[0],h=t[1];let c=this.urls.api[h]+"/"+o+"/"+e,l=this.omit(i,this.extractParams(e));const u=this.nonce().toString();if("POST"===s){const t=e.split("/"),s=this.safeString(t,0,""),r=t.length,a=this.safeString(t,r-1,"").split("_"),o=a.length,n=this.safeString(a,o-1,"");if("order"===s&&("limit"===n||"market"===n)){if(void 0===this.safeString(i,"client_id")){const e="x-167673045",t=this.safeValue(this.options,"brokerId",e);l.client_id=t+"_"+this.uuid16()}}}if("perpetualPrivate"===h){this.checkRequiredCredentials(),l=this.extend({access_id:this.apiKey,timestamp:u},l),l=this.keysort(l);const e=this.rawencode(l);r={Authorization:this.hash(this.encode(e+"&secret_key="+this.secret),n.s).toLowerCase(),AccessId:this.apiKey},"GET"===s||"PUT"===s?c+="?"+e:(r["Content-Type"]="application/x-www-form-urlencoded",a=e)}else if("public"===h||"perpetualPublic"===h)Object.keys(l).length&&(c+="?"+this.urlencode(l));else if("v1"===o){this.checkRequiredCredentials(),l=this.extend({access_id:this.apiKey,tonce:u},l),l=this.keysort(l);const e=this.rawencode(l);r={Authorization:this.hash(this.encode(e+"&secret_key="+this.secret),d.F).toUpperCase(),"Content-Type":"application/json"},"GET"===s||"DELETE"===s||"PUT"===s?c+="?"+e:a=this.json(l)}else if("v2"===o){this.checkRequiredCredentials(),l=this.keysort(l);const t=this.rawencode(l);let i=s+"/"+o+"/"+e;"POST"===s?i+=a=this.json(l):t&&(i+="?"+t),i+=u+this.secret;const d=this.hash(this.encode(i),n.s);r={"Content-Type":"application/json",Accept:"application/json","X-COINEX-KEY":this.apiKey,"X-COINEX-SIGN":d,"X-COINEX-TIMESTAMP":u},"POST"!==s&&t&&(c+="?"+t)}return{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeValue(n,"data"),u=this.safeString(n,"message");if("0"!==c||"Success"!==u&&"Succeeded"!==u&&"ok"!==u.toLowerCase()&&!l){const e=this.id+" "+u;throw this.throwBroadlyMatchedException(this.exceptions.broad,u,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}async fetchMarginAdjustmentHistory(e=void 0,t=void 0,s=void 0,i=void 0,a={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory() requires a symbol argument");const o=this.safeInteger2(a,"positionId","position_id");if(a=this.omit(a,"positionId"),void 0===o)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory() requires a positionId parameter");let n={market:this.market(e).id,market_type:"FUTURES",position_id:o};[n,a]=this.handleUntilOption("end_time",n,a),void 0!==s&&(n.start_time=s),void 0!==i&&(n.limit=i);const d=await this.v2PrivateGetFuturesPositionMarginHistory(this.extend(n,a)),h=this.safeList(d,"data",[]),c=this.parseMarginModifications(h,void 0,"market","swap");return this.filterBySymbolSinceLimit(c,e,s,i)}}},7477:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(2948),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinlist",name:"Coinlist",countries:["US"],version:"v1",rateLimit:300,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,deposit:!1,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrder:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!0,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!0,ws:!1},timeframes:{"1m":"1m","5m":"5m","30m":"30m"},urls:{logo:"https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/281108917-eff2ae1d-ce8a-4b2a-950d-8678b12da965.jpg",api:{public:"https://trade-api.coinlist.co",private:"https://trade-api.coinlist.co"},www:"https://coinlist.co",doc:["https://trade-docs.coinlist.co"],fees:"https://coinlist.co/fees"},api:{public:{get:{"v1/symbols":1,"v1/symbols/summary":1,"v1/symbols/{symbol}":1,"v1/symbols/{symbol}/summary":1,"v1/symbols/{symbol}/book":1,"v1/symbols/{symbol}/quote":1,"v1/symbols/{symbol}/candles":1,"v1/symbols/{symbol}/auctions":1,"v1/symbols/{symbol}/auctions/{auction_code}":1,"v1/time":1,"v1/assets":1,"v1/leaderboard":1,"v1/affiliate/{competition_code}":1,"v1/competition/{competition_id}":1}},private:{get:{"v1/fees":1,"v1/accounts":1,"v1/accounts/{trader_id}":1,"v1/accounts/{trader_id}/alias":1,"v1/accounts/{trader_id}/ledger":1,"v1/accounts/{trader_id}/wallets":1,"v1/accounts/{trader_id}/wallet-ledger":1,"v1/accounts/{trader_id}/ledger-summary":1,"v1/keys":1,"v1/fills":1,"v1/orders":1,"v1/orders/{order_id}":1,"v1/reports":1,"v1/balances":1,"v1/transfers":1,"v1/user":1,"v1/credits":1,"v1/positions":1,"v1/accounts/{trader_id}/competitions":1},post:{"v1/keys":1,"v1/orders":1,"v1/orders/cancel-all-after":1,"v1/reports":1,"v1/transfers/to-wallet":1,"v1/transfers/from-wallet":1,"v1/transfers/internal-transfer":1,"v1/transfers/withdrawal-request":1,"v1/orders/bulk":1,"v1/accounts/{trader_id}/competitions":1,"v1/accounts/{trader_id}/create-competition":1},patch:{"v1/orders/{order_id}":1,"v1/orders/bulk":1},delete:{"v1/keys/{key}":1,"v1/orders":1,"v1/orders/{order_id}":1,"v1/orders/bulk":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,taker:this.parseNumber("0.0045"),maker:this.parseNumber("0.0025"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0045")],[this.parseNumber("20000"),this.parseNumber("0.003")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("750000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("2500000"),this.parseNumber("0.0013")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.001")],[this.parseNumber("50000000"),this.parseNumber("0.0005")],[this.parseNumber("100000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("20000"),this.parseNumber("0.0025")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.002")],[this.parseNumber("500000"),this.parseNumber("0.0015")],[this.parseNumber("750000"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.001")],[this.parseNumber("2500000"),this.parseNumber("0.0008")],[this.parseNumber("5000000"),this.parseNumber("0.0007")],[this.parseNumber("10000000"),this.parseNumber("0.0006")],[this.parseNumber("50000000"),this.parseNumber("0.0000")],[this.parseNumber("100000000"),this.parseNumber("0.00")]]}}},precisionMode:a.kb,options:{accountsByType:{"CoinList Pro":"trading","CoinList Pro trading account":"trading",Pro:"trading",pro:"trading",trade:"trading",trading:"trading",CoinList:"funding","CoinList wallet":"funding",Wallet:"funding",wallet:"funding",fund:"funding",funding:"funding"}},exceptions:{exact:{AUTH_SIG_INVALID:r.AuthenticationError,DENIED_MAINTENANCE:r.OnMaintenance,ORDER_REJECT_BAD_STATUS:r.InvalidOrder,ORDER_REJECT_INVALID_POST_ONLY:r.InvalidOrder,ORDER_REJECT_INVALID_CLOSE_ONLY:r.InvalidOrder,ORDER_REJECT_POST_ONLY_REQUIRED:r.InvalidOrder,ORDER_REJECT_FROZEN_ORDER:r.InvalidOrder,ORDER_REJECT_LIMIT_PRICE_PROTECTION_VIOLATION:r.InvalidOrder,ORDER_REJECT_CLOSED:r.NotSupported,ORDER_REJECT_MAX_ORDERS:r.BadRequest,ORDER_REJECT_NOT_FOUND:r.OrderNotFound,ORDER_REJECT_PARSE_ERROR:r.BadRequest,ORDER_REJECT_PRICE_INVALID:r.InvalidOrder,ORDER_REJECT_QUANTITY_ZERO:r.InvalidOrder,ORDER_REJECT_TOKEN_LIMIT:r.InsufficientFunds,ORDER_REJECT_TOKEN_LIMIT_OTHER:r.InvalidOrder,ORDER_REJECT_SELF_TRADE:r.InvalidOrder,ORDER_VALIDATE_BAD_SIZE_ALIGNMENT:r.InvalidOrder,ORDER_VALIDATE_BAD_TICK_ALIGNMENT:r.InvalidOrder,ORDER_VALIDATE_SYMBOL_NOT_FOUND:r.BadSymbol,TRANSFERS_WITHDRAWAL_REQUEST_TOO_LARGE:r.InsufficientFunds,WITHDRAWAL_REQUEST_NOT_ALLOWED:r.PermissionDenied},broad:{"A destinationAddress is required for non-USD withdrawals":r.InvalidAddress,"fails to match the JsonSchema date-time format pattern":r.BadRequest,"is required":r.ArgumentsRequired,"must be a string":r.BadRequest,"must be a valid GUID":r.BadRequest,"must be greater than or equal to":r.BadRequest,"must be less than or equal to":r.BadRequest,"must be one of":r.BadRequest,"Symbol not found":r.BadSymbol}}})}calculateRateLimiterCost(e,t,s,i,r={}){if(Array.isArray(i)){const e=i.length;return Math.ceil(e/2)}return 1}async fetchTime(e={}){const t=await this.publicGetV1Time(e),s=this.safeString(t,"iso");return this.parse8601(s)}async fetchCurrencies(e={}){const t=await this.publicGetV1Assets(e),s=this.safeValue(t,"assets",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.safeBool(t,"is_transferable",!1),n=o,d=o,h=o,c=this.safeString(t,"decimal_places"),l=this.parseNumber(this.parsePrecision(c)),u=this.safeString(t,"min_withdrawal");i[a]={id:r,code:a,name:a,info:t,active:h,deposit:d,withdraw:n,fee:void 0,precision:l,limits:{amount:{min:void 0,max:void 0},withdraw:{min:u,max:void 0}},networks:{}}}return i}async fetchMarkets(e={}){const t=await this.publicGetV1Symbols(e),s=this.safeValue(t,"symbols",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"base_currency"),i=this.safeString(e,"quote_currency"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeString(e,"minimum_size_increment"),n=this.safeString(e,"minimum_price_increment"),d=this.safeString(e,"list_time");return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(o),price:this.parseNumber(n)},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:this.parse8601(d),info:e}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV1SymbolsSummary(this.extend({},t));return this.parseTickers(s,e,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetV1SymbolsSymbolSummary(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){const s=this.safeValue(e,"last_trade",{}),i=this.parse8601(this.safeString(s,"logicalTime")),r=this.safeString(e,"highest_bid"),a=this.safeString(e,"lowest_ask"),o=this.safeString(e,"volume_base_24h"),n=this.safeString(e,"volume_quote_24h"),d=this.safeString(e,"highest_price_24h"),h=this.safeString(e,"lowest_price_24h"),c=this.safeString(e,"last_price"),l=this.safeString(e,"price_change_percent_24h");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:void 0,high:d,low:h,close:c,bid:r,bidVolume:void 0,ask:a,askVolume:void 0,vwap:void 0,previousClose:void 0,change:void 0,percentage:l,average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id},r=await this.publicGetV1SymbolsSymbolBook(this.extend(i,s)),a=this.parse8601(this.safeString(r,"logical_time")),o=this.parseOrderBook(r,e,a);return o.nonce=void 0,o}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t),n={symbol:a.id,granularity:o};if(void 0!==s)if(n.start_time=this.iso8601(s),void 0!==i){const e=1e3*this.parseTimeframe(t);n.end_time=this.iso8601(this.sum(s,e*i))}else n.end_time=this.iso8601(this.milliseconds());const d=this.safeInteger(r,"until");void 0!==d&&(r=this.omit(r,["until"]),n.end_time=this.iso8601(d));const h=await this.publicGetV1SymbolsSymbolCandles(this.extend(n,r)),c=this.safeList(h,"candles",[]);return this.parseOHLCVs(c,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,0)),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t&&(a.start_time=this.iso8601(t)),void 0!==s&&(a.count=Math.min(s,500));const o=this.safeInteger(i,"until");void 0!==o&&(i=this.omit(i,["until"]),a.end_time=this.iso8601(o));const n=await this.publicGetV1SymbolsSymbolAuctions(this.extend(a,i)),d=this.safeList(n,"auctions",[]);return this.parseTrades(d,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString(e,"auction_code"),a=this.parse8601(this.safeString(e,"logical_time")),n=this.safeString(e,"price");let d=this.safeString2(e,"volume","quantity");const h=this.safeString(e,"order_id");let c,l;const u=this.safeString(e,"fee");if(void 0!==u){o.Y.stringLt(d,"0")?(l="sell",d=o.Y.stringNeg(d)):l="buy",c={cost:u,currency:this.safeString(e,"fee_currency")}}else{const t=this.safeString(e,"imbalance");l=o.Y.stringLt(t,"0")?"buy":"sell"}const p=this.safeString(e,"fee_type");return this.safeTrade({id:r,order:h,timestamp:a,datetime:this.iso8601(a),symbol:i,type:void 0,side:l,takerOrMaker:p,price:n,amount:d,cost:void 0,fee:c,info:e},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetV1Fees(e),s=this.safeValue(t,"fees_by_symbols",{}),i={},r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeValue(s,t,{}),o=this.parseFeeTiers(a),n=this.safeValue(a,"base",{}),d=this.safeValue(n,"fees",{}),h=t.split(",");for(let e=0;e<h.length;e++){const s=h[e],r=this.safeMarket(s).symbol,n={};n[t]=a,i[r]={info:n,symbol:r,maker:this.safeNumber(d,"maker"),taker:this.safeNumber(d,"taker"),percentage:!0,tierBased:!0,tiers:o}}}return i}parseFeeTiers(e,t=void 0){let s=[],i=[];const r=Object.keys(e),a=r.length;if(a>0){for(let t=0;t<a;t++){const a=r[t],o=this.safeValue(e,a,{}),n=this.safeValue(o,"fees",{}),d=this.safeString(n,"taker"),h=this.safeString(n,"maker");i.push([void 0,this.parseNumber(h)]),s.push([void 0,this.parseNumber(d)])}s=this.sortBy(s,1,!0),i=this.sortBy(i,1,!0);const t=this.safeDict(s,0,[]),o=this.safeDict(this,"fees",{}),n=this.safeDict(o,"trading",{}),d=this.safeDict(n,"tiers",{}),h=this.safeList(d,"taker",[]),c=this.safeList(d,"maker",[]),l=h.length,u=t.length;if(a===l&&u>0)for(let e=0;e<a;e++)s[e][0]=h[e][0],i[e][0]=c[e][0]}return{maker:i,taker:s}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetV1Accounts(e),s=this.safeValue(t,"accounts",[]);return this.parseAccounts(s,e)}parseAccount(e){return{id:this.safeString(e,"trader_id"),type:"trading",code:void 0,info:e}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV1Balances(e);return this.parseBalance(t)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"asset_balances",{}),i=this.safeValue(e,"asset_holds",{}),r=Object.keys(s);for(let e=0;e<r.length;e++){const a=r[e],o=this.safeCurrencyCode(a),n=this.account();n.total=this.safeString(s,a),n.used=this.safeString(i,a,"0"),t[o]=n}return this.safeBalance(t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==t&&(r.start_time=this.iso8601(t)),void 0!==s&&(r.count=s);const o=this.safeInteger(i,"until");void 0!==o&&(i=this.omit(i,["until"]),r.end_time=this.iso8601(o));const n=await this.privateGetV1Fills(this.extend(r,i)),d=this.safeList(n,"fills",[]);return this.parseTrades(d,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(a,r))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=this.safeString(i,"status");void 0===r&&(r=["accepted","done","canceled","rejected","pending"]);const a={status:r};let o;void 0!==e&&(o=this.market(e),a.symbol=o.id),void 0!==t&&(a.start_time=this.iso8601(t)),void 0!==s&&(a.count=s);const n=this.safeInteger(i,"until");void 0!==n&&(i=this.omit(i,["until"]),a.end_time=this.iso8601(n));const d=await this.privateGetV1Orders(this.extend(a,i)),h=this.safeList(d,"orders",[]);return this.parseOrders(h,o,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetV1OrdersOrderId(this.extend(i,s));return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return this.fetchOrders(e,t,s,this.extend({status:"accepted"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return this.fetchOrders(e,t,s,this.extend({status:"done"},i))}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();return this.fetchOrders(e,t,s,this.extend({status:"canceled"},i))}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};void 0!==e&&(s=this.market(e),i.symbol=s.id);const r=[await this.privateDeleteV1Orders(this.extend(i,t))];return this.parseOrders(r,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateDeleteV1OrdersOrderId(this.extend(i,s));return this.parseOrder(r)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets(),s=e;const i=await this.privateDeleteV1OrdersBulk(s),r=this.safeList(i,"order_ids",[]),a=[],o=this.safeString(i,"timestamp");for(let e=0;e<r.length;e++)a.push(this.safeOrder({info:r[e],id:r[e],lastUpdateTimestamp:this.parse8601(o)}));return a}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={symbol:n.id,type:t,side:s,size:this.amountToPrecision(e,i)};let h,c=!1;if("limit"===t||"stop_limit"===t||"take_limit"===t){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for a "+t+" order");d.price=this.priceToPrecision(e,a)}else c=!0;[h,o]=this.handlePostOnly(c,!1,o),h&&(d.post_only=!0);const l=this.safeNumberN(o,["triggerPrice","trigger_price","stopPrice","stop_price"]);if(void 0!==l)o=this.omit(o,["triggerPrice","trigger_price","stopPrice"]),d.stop_price=this.priceToPrecision(e,l),"market"===t?d.type="stop_market":"limit"===t&&(d.type="stop_limit");else if("stop_market"===t||"stop_limit"===t||"take_market"===t||"take_limit"===t)throw new r.ArgumentsRequired(this.id+" createOrder() requires a stopPrice parameter for stop-loss and take-profit orders");const u=this.safeString2(o,"clientOrderId","client_id");void 0!==u&&(d.client_id=u,o=this.omit(o,["clientOrderId","client_id"]));const p=await this.privatePostV1Orders(this.extend(d,o)),f=this.safeDict(p,"order",{});return this.parseOrder(f,n)}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){if(await this.loadMarkets(),void 0===a)throw new r.ArgumentsRequired(this.id+" editOrder() requires an amount argument");const d=this.market(t),h={order_id:e,type:s,side:i,size:this.amountToPrecision(t,a)};void 0!==o&&(h.price=this.priceToPrecision(t,o));const c=await this.privatePatchV1OrdersOrderId(this.extend(h,n));return this.parseOrder(c,d)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=this.safeString(e,"client_id");let a=this.safeString2(e,"created_at","epoch_timestamp");void 0===a&&(a=this.safeString(e,"timestamp"));const o=this.parse8601(a),n=this.parseOrderStatus(this.safeString(e,"status")),d=this.parseOrderType(this.safeString(e,"type")),h=this.safeString(e,"side"),c=this.safeString(e,"price"),l=this.safeString(e,"stop_price"),u=this.safeString(e,"average_fill_price"),p=this.safeString(e,"size"),f=this.safeString(e,"size_filled"),m=this.safeString(e,"fill_fees"),g=this.safeValue(e,"post_only");let v;return void 0!==m&&(v={currency:t.quote,cost:m,rate:void 0}),this.safeOrder({id:s,clientOrderId:r,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,status:n,symbol:t.symbol,type:d,timeInForce:"GTC",side:h,price:c,stopPrice:l,triggerPrice:l,average:u,amount:p,cost:void 0,filled:f,remaining:void 0,fee:v,trades:void 0,info:e,postOnly:g},t)}parseOrderStatus(e){return this.safeString({pending:"open",accepted:"open",rejected:"rejected",done:"closed",canceled:"canceled"},e,e)}parseOrderType(e){return this.safeString({market:"market",limit:"limit",stop_market:"market",stop_limit:"limit",take_market:"market",take_limit:"limit"},e,e)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t)},n=this.safeValue(this.options,"accountsByType",{}),d=this.safeString(n,s,s),h=this.safeString(n,i,i);let c;"funding"===d&&"trading"===h?c=await this.privatePostV1TransfersFromWallet(this.extend(o,r)):"trading"===d&&"funding"===h?c=await this.privatePostV1TransfersToWallet(this.extend(o,r)):(o.from_trader_id=d,o.to_trader_id=h,c=await this.privatePostV1TransfersInternalTransfer(this.extend(o,r)));return this.parseTransfer(c,a)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={};void 0!==t&&(a.start_time=this.iso8601(t)),void 0!==s&&(a.count=s);const o=this.safeInteger(i,"until");void 0!==o&&(i=this.omit(i,["until"]),a.end_time=this.iso8601(o));const n=await this.privateGetV1Transfers(this.extend(a,i)),d=this.safeList(n,"transfers",[]);return this.parseTransfers(d,r,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"asset"),i=this.safeString(e,"confirmed_at"),r=this.parse8601(i),a=this.safeString(e,"status");let n,d,h,c=this.safeString(e,"amount");if(void 0!==c){o.Y.stringLt(c,"0")?(n="trading",d="funding",c=o.Y.stringNeg(c)):(n="funding",d="trading"),h=this.parseNumber(c)}return{info:e,id:this.safeString(e,"transfer_id"),timestamp:r,datetime:this.iso8601(r),currency:this.safeCurrencyCode(s,t),amount:h,fromAccount:n,toAccount:d,status:this.parseTransferStatus(a)}}parseTransferStatus(e){return this.safeString({confirmed:"ok"},e,e)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDepositsWithdrawals() requires a code argument");const a=this.safeString2(i,"trader_id","traderId");if(void 0===a)throw new r.ArgumentsRequired(this.id+" fetchDepositsWithdrawals() requires a traderId argument in the params");await this.loadMarkets();const o=this.currency(e),n={asset:o.id,trader_id:a};void 0!==s&&(n.count=s),i=this.omit(i,["trader_id","traderId"]);const d=await this.privateGetV1AccountsTraderIdWalletLedger(this.extend(n,i));return this.parseTransactions(d,o,t,s)}async withdraw(e,t,s,i=void 0,r={}){await this.loadMarkets();const a=this.currency(e),o={asset:a.id,amount:this.currencyToPrecision(e,t),destination_address:s},n=await this.privatePostV1TransfersWithdrawalRequest(this.extend(o,r)),d=this.safeDict(n,"data",{});return this.parseTransaction(d,a)}parseTransaction(e,t=void 0){const s=this.safeString(e,"asset"),i=this.safeCurrencyCode(s,t),r=this.safeString2(e,"id","transfer_id"),a=this.safeNumber(e,"amount"),o=this.parse8601(this.safeString(e,"created_at"));let n,d=this.safeString(e,"type",void 0);d=void 0===d?"withdrawal":this.parseTransactionType(d);const h=this.safeString(e,"withdrawal_fee_amount");return void 0!==h&&(n={cost:h,currency:i}),{info:e,id:r,txid:void 0,timestamp:o,datetime:this.iso8601(o),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:d,amount:a,currency:i,status:void 0,updated:void 0,fee:n,comment:this.safeString(e,"description"),internal:void 0}}parseTransactionType(e){return this.safeString({CRYPTO_DEPOSIT:"deposit",CRYPTO_WITHDRAWAL:"withdrawal",PRO_TRANSFER:"transfer"},e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const a=this.safeString2(i,"trader_id","traderId");if(void 0===a)throw new r.ArgumentsRequired(this.id+" fetchLedger() requires a traderId argument in the params");await this.loadMarkets();const o={trader_id:a};let n;void 0!==e&&(n=this.currency(e)),void 0!==t&&(o.start_time=this.iso8601(t)),void 0!==s&&(o.count=s);const d=this.safeInteger(i,"until");void 0!==d&&(i=this.omit(i,["until"]),o.end_time=this.iso8601(d)),i=this.omit(i,["trader_id","traderId"]);const h=await this.privateGetV1AccountsTraderIdLedger(this.extend(o,i)),c=this.safeValue(h,"transactions",[]);return this.parseLedger(c,n,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transaction_id"),i=this.safeString(e,"created_at"),r=this.parse8601(i);let a=this.safeString(e,"amount");let n;o.Y.stringLt(a,"0")?(n="out",a=o.Y.stringNeg(a)):n="in";const d=this.safeString(e,"asset"),h=this.safeCurrencyCode(d,t),c=this.parseLedgerEntryType(this.safeString(e,"type"));return{info:e,id:s,timestamp:r,datetime:this.iso8601(r),direction:n,account:"trading",referenceId:void 0,referenceAccount:void 0,type:c,currency:h,amount:this.parseNumber(a),before:void 0,after:void 0,status:"ok",fee:void 0}}parseLedgerEntryType(e){return this.safeString({"atomic token swap":"trade",fee:"fee",deposit:"transfer",withdrawal:"transfer"},e,e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),d="/"+this.implodeParams(e,i);let h=this.urls.api[t]+d;const c=Array.isArray(i);let l;if(c||(l=this.urlencode(o)),"private"===t){this.checkRequiredCredentials();const e=this.seconds().toString();let t=e+s+d;"POST"===s||"PATCH"===s||c?t+=a=this.json(o):void 0!==l&&0!==l.length&&(t+="?"+l,h+="?"+l);const i=this.hmac(this.encode(t),this.base64ToBinary(this.secret),n.s,"base64");r={"CL-ACCESS-KEY":this.apiKey,"CL-ACCESS-SIG":i,"CL-ACCESS-TIMESTAMP":e,"Content-Type":"application/json"}}else void 0!==l&&0!==l.length&&(h+="?"+l);return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n){if(404===e&&s.indexOf("/orders/")>=0&&"GET"===i){const e=s.split("/orders/"),t=this.safeString(e,1);throw new r.OrderNotFound(this.id+" order "+t+" not found (or rejected on the exchange side)")}return}const c=this.safeString(n,"status"),l=this.safeString(n,"message_code");if(void 0!==l||void 0!==c&&200!==e&&202!==e&&"200"!==c&&"202"!==c){const e=this.id+" "+o,t=this.safeString(n,"message");throw this.throwBroadlyMatchedException(this.exceptions.broad,t,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),new r.ExchangeError(e)}}}},6016:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8109),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinmate",name:"CoinMate",countries:["GB","CZ","EU"],rateLimit:600,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:"emulated",reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg",api:{rest:"https://coinmate.io/api"},www:"https://coinmate.io",fees:"https://coinmate.io/fees",doc:["https://coinmate.docs.apiary.io","https://coinmate.io/developers"],referral:"https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0"},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},api:{public:{get:["orderBook","ticker","tickerAll","products","transactions","tradingPairs"]},private:{post:["balances","bitcoinCashWithdrawal","bitcoinCashDepositAddresses","bitcoinDepositAddresses","bitcoinWithdrawal","bitcoinWithdrawalFees","buyInstant","buyLimit","cancelOrder","cancelOrderWithInfo","createVoucher","dashDepositAddresses","dashWithdrawal","ethereumWithdrawal","ethereumDepositAddresses","litecoinWithdrawal","litecoinDepositAddresses","openOrders","order","orderHistory","orderById","pusherAuth","redeemVoucher","replaceByBuyLimit","replaceByBuyInstant","replaceBySellLimit","replaceBySellInstant","rippleDepositAddresses","rippleWithdrawal","sellInstant","sellLimit","transactionHistory","traderFees","tradeHistory","transfer","transferHistory","unconfirmedBitcoinDeposits","unconfirmedBitcoinCashDeposits","unconfirmedDashDeposits","unconfirmedEthereumDeposits","unconfirmedLitecoinDeposits","unconfirmedRippleDeposits","cancelAllOpenOrders","withdrawVirtualCurrency","virtualCurrencyDepositAddresses","unconfirmedVirtualCurrencyDeposits","adaWithdrawal","adaDepositAddresses","unconfirmedAdaDeposits","solWithdrawal","solDepositAddresses","unconfirmedSolDeposits"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.006"),maker:this.parseNumber("0.004"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.006")],[this.parseNumber("10000"),this.parseNumber("0.003")],[this.parseNumber("100000"),this.parseNumber("0.0023")],[this.parseNumber("250000"),this.parseNumber("0.0021")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0015")],[this.parseNumber("3000000"),this.parseNumber("0.0012")],[this.parseNumber("15000000"),this.parseNumber("0.001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("10000"),this.parseNumber("0.002")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("250000"),this.parseNumber("0.0009")],[this.parseNumber("500000"),this.parseNumber("0.0005")],[this.parseNumber("1000000"),this.parseNumber("0.0003")],[this.parseNumber("3000000"),this.parseNumber("0.0002")],[this.parseNumber("15000000"),this.parseNumber("-0.0004")]]}}},options:{withdraw:{fillResponsefromRequest:!0,methods:{BTC:"privatePostBitcoinWithdrawal",LTC:"privatePostLitecoinWithdrawal",BCH:"privatePostBitcoinCashWithdrawal",ETH:"privatePostEthereumWithdrawal",XRP:"privatePostRippleWithdrawal",DASH:"privatePostDashWithdrawal",DAI:"privatePostDaiWithdrawal",ADA:"privatePostAdaWithdrawal",SOL:"privatePostSolWithdrawal"}}},exceptions:{exact:{"No order with given ID":r.OrderNotFound},broad:{"Not enough account balance available":r.InsufficientFunds,"Incorrect order ID":r.InvalidOrder,"Minimum Order Size ":r.InvalidOrder,"max allowed precision":r.InvalidOrder,"TOO MANY REQUESTS":r.RateLimitExceeded,"Access denied.":r.AuthenticationError}},precisionMode:o.kb})}async fetchMarkets(e={}){const t=await this.publicGetTradingPairs(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"name"),a=this.safeString(t,"firstCurrency"),o=this.safeString(t,"secondCurrency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=n+"/"+d;i.push({id:r,symbol:h,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"lotDecimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"priceDecimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}parseBalance(e){const t=this.safeValue(e,"data",{}),s={info:e},i=Object.keys(t);for(let e=0;e<i.length;e++){const r=i[e],a=this.safeCurrencyCode(r),o=this.safeValue(t,r),n=this.account();n.free=this.safeString(o,"available"),n.used=this.safeString(o,"reserved"),n.total=this.safeString(o,"balance"),s[a]=n}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalances(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={currencyPair:i.id,groupByPriceLimit:"False"},a=(await this.publicGetOrderBook(this.extend(r,s))).data,o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},r=await this.publicGetTicker(this.extend(i,t)),a=this.safeDict(r,"data");return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickerAll(t),i=this.safeValue(s,"data",{}),r=Object.keys(i),a={};for(let e=0;e<r.length;e++){const t=this.market(r[e]),s=this.parseTicker(this.safeValue(i,r[e]),t);a[t.symbol]=s}return this.filterByArrayTickers(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeNumber(e,"last");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeNumber(e,"high"),low:this.safeNumber(e,"low"),bid:this.safeNumber(e,"bid"),bidVolume:void 0,ask:this.safeNumber(e,"ask"),vwap:void 0,askVolume:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"amount"),quoteVolume:void 0,info:e},t)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={limit:1e3};if(void 0!==s&&(r.limit=s),void 0!==t&&(r.timestampFrom=t),void 0!==e){const t=this.currency(e);r.currency=t.id}const a=(await this.privatePostTransferHistory(this.extend(r,i))).data;return this.parseTransactions(a,void 0,t,s)}parseTransactionStatus(e){return this.safeString({COMPLETED:"ok",WAITING:"pending",SENT:"pending",CREATED:"pending",OK:"ok",NEW:"pending",CANCELED:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"amountCurrency"),r=this.safeCurrencyCode(i,t);return{info:e,id:this.safeString2(e,"transactionId","id"),txid:this.safeString(e,"txid"),type:this.safeStringLower(e,"transferType"),currency:r,network:this.safeString(e,"walletType"),amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"transferStatus")),timestamp:s,datetime:this.iso8601(s),address:this.safeString(e,"destination"),addressFrom:void 0,addressTo:void 0,tag:this.safeString(e,"destinationTag"),tagFrom:void 0,tagTo:void 0,updated:void 0,comment:void 0,internal:void 0,fee:{cost:this.safeNumber(e,"fee"),currency:r,rate:void 0}}}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n=this.safeValue(this.options,"withdraw",{}),d=this.safeValue(n,"methods",{}),h=this.safeString(d,e);if(void 0===h){const e=Object.keys(d);throw new r.ExchangeError(this.id+" withdraw() only allows withdrawing the following currencies: "+e.join(", "))}const c={amount:this.currencyToPrecision(e,t),address:s};void 0!==i&&(c.destinationTag=i);const l=await this[h](this.extend(c,a)),u=this.safeValue(l,"data"),p=this.parseTransaction(u,o);return this.safeBool(n,"fillResponseFromRequest",!0)&&(p.amount=t,p.currency=e,p.address=s,p.tag=i,p.type="withdrawal",p.status="pending"),p}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),void 0===s&&(s=1e3);const r={limit:s};if(void 0!==e){const t=this.market(e);r.currencyPair=t.id}void 0!==t&&(r.timestampFrom=t);const a=await this.privatePostTradeHistory(this.extend(r,i)),o=this.safeList(a,"data",[]);return this.parseTrades(o,void 0,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"currencyPair");t=this.safeMarket(s,t,"_");const i=this.safeString(e,"price"),r=this.safeString(e,"amount"),a=this.safeStringLower2(e,"type","tradeType"),o=this.safeStringLower(e,"orderType"),n=this.safeString(e,"orderId"),d=this.safeString(e,"transactionId"),h=this.safeInteger2(e,"timestamp","createdTimestamp");let c;const l=this.safeString(e,"fee");void 0!==l&&(c={cost:l,currency:t.quote});let u=this.safeString(e,"feeType");return u="MAKER"===u?"maker":"taker",this.safeTrade({id:d,info:e,timestamp:h,datetime:this.iso8601(h),symbol:t.symbol,type:o,side:a,order:n,takerOrMaker:u,price:i,amount:r,cost:void 0,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={currencyPair:r.id,minutesIntoHistory:10},o=await this.publicGetTransactions(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currencyPair:s.id},r=await this.privatePostTraderFees(this.extend(i,t)),o=this.safeValue(r,"data",{}),n=this.safeString(o,"maker"),d=this.safeString(o,"taker"),h=this.parseNumber(a.Y.stringDiv(n,"100")),c=this.parseNumber(a.Y.stringDiv(d,"100"));return{info:o,symbol:s.symbol,maker:h,taker:c,percentage:!0,tierBased:!0}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const r=await this.privatePostOpenOrders(this.extend({},i));return this.parseOrders(r.data,void 0,t,s,{status:"open"})}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={currencyPair:a.id};void 0!==s&&(o.limit=s);const n=await this.privatePostOrderHistory(this.extend(o,i));return this.parseOrders(n.data,a,t,s)}parseOrderStatus(e){return this.safeString({FILLED:"closed",CANCELLED:"canceled",PARTIALLY_FILLED:"open",OPEN:"open"},e,e)}parseOrderType(e){return this.safeString({LIMIT:"limit",MARKET:"market"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),r=this.safeStringLower(e,"type"),a=this.safeString(e,"price"),o=this.safeString(e,"originalAmount"),n=this.safeString2(e,"remainingAmount","amount"),d=this.parseOrderStatus(this.safeString(e,"status")),h=this.parseOrderType(this.safeString(e,"orderTradeType")),c=this.safeString(e,"avgPrice"),l=this.safeString(e,"currencyPair"),u=this.safeSymbol(l,t,"_"),p=this.safeString(e,"clientOrderId"),f=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:p,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,symbol:u,type:h,timeInForce:void 0,postOnly:void 0,side:r,price:a,stopPrice:f,triggerPrice:f,amount:o,cost:void 0,average:c,filled:void 0,remaining:n,status:d,trades:void 0,info:e,fee:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();let o="privatePost"+this.capitalize(s);const n=this.market(e),d={currencyPair:n.id};"market"===t?("buy"===s?d.total=this.amountToPrecision(e,i):d.amount=this.amountToPrecision(e,i),o+="Instant"):(d.amount=this.amountToPrecision(e,i),d.price=this.priceToPrecision(e,r),o+=this.capitalize(t));const h=await this[o](this.extend(d,a)),c=this.safeString(h,"data");return this.safeOrder({info:h,id:c},n)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e};let r;t&&(r=this.market(t));const a=await this.privatePostOrderById(this.extend(i,s)),o=this.safeDict(a,"data");return this.parseOrder(o,r)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},r=await this.privatePostCancelOrderWithInfo(this.extend(i,s)),a=this.safeDict(r,"data");return this.parseOrder(a)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+e;if("public"===t)Object.keys(i).length&&(o+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=e+this.uid+this.apiKey,s=this.hmac(this.encode(t),this.encode(this.secret),n.s);a=this.urlencode(this.extend({clientId:this.uid,nonce:e,publicKey:this.apiKey,signature:s.toUpperCase()},i)),r={"Content-Type":"application/x-www-form-urlencoded"}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"errorMessage");if(void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}}},8692:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(1671),r=s(2079),a=s(1579),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinmetro",name:"Coinmetro",countries:["EE"],version:"v1",rateLimit:200,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!1,borrowCrossMargin:!0,borrowIsolatedMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!0,createDepositAddress:!1,createOrder:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,deposit:!1,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledAndClosedOrders:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,sandbox:!0,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1,ws:!1},timeframes:{"1m":"60000","5m":"300000","30m":"1800000","4h":"14400000","1d":"86400000"},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/e86f87ec-6ba3-4410-962b-f7988c5db539",api:{public:"https://api.coinmetro.com",private:"https://api.coinmetro.com"},test:{public:"https://api.coinmetro.com/open",private:"https://api.coinmetro.com/open"},www:"https://coinmetro.com/",doc:["https://documenter.getpostman.com/view/3653795/SVfWN6KS"],fees:"https://help.coinmetro.com/hc/en-gb/articles/6844007317789-What-are-the-fees-on-Coinmetro-",referral:"https://go.coinmetro.com/?ref=crypto24"},api:{public:{get:{"demo/temp":1,"exchange/candles/{pair}/{timeframe}/{from}/{to}":3,"exchange/prices":1,"exchange/ticks/{pair}/{from}":3,assets:1,markets:1,"exchange/book/{pair}":3,"exchange/bookUpdates/{pair}/{from}":1}},private:{get:{"users/balances":1,"users/wallets":1,"users/wallets/history/{since}":1.67,"exchange/orders/status/{orderID}":1,"exchange/orders/active":1,"exchange/orders/history/{since}":1.67,"exchange/fills/{since}":1.67,"exchange/margin":1},post:{jwt:1,jwtDevice:1,devices:1,"jwt-read-only":1,"exchange/orders/create":1,"exchange/orders/modify/{orderID}":1,"exchange/swap":1,"exchange/swap/confirm/{swapId}":1,"exchange/orders/close/{orderID}":1,"exchange/orders/hedge":1},put:{jwt:1,"exchange/orders/cancel/{orderID}":1,"users/margin/collateral":1,"users/margin/primary/{currency}":1}}},requiredCredentials:{apiKey:!1,secret:!1,uid:!0,token:!0},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},precisionMode:a.kb,options:{currenciesByIdForParseMarket:void 0,currencyIdsListForParseMarket:void 0},exceptions:{exact:{"Both buyingCurrency and sellingCurrency are required":r.InvalidOrder,"One and only one of buyingQty and sellingQty is required":r.InvalidOrder,"Invalid buyingCurrency":r.InvalidOrder,"Invalid 'from'":r.BadRequest,"Invalid sellingCurrency":r.InvalidOrder,"Invalid buyingQty":r.InvalidOrder,"Invalid sellingQty":r.InvalidOrder,"Insufficient balance":r.InsufficientFunds,"Expiration date is in the past or too near in the future":r.InvalidOrder,Forbidden:r.PermissionDenied,"Order Not Found":r.OrderNotFound,"since must be a millisecond timestamp":r.BadRequest,"This pair is disabled on margin":r.BadSymbol},broad:{"accessing from a new IP":r.PermissionDenied,"available to allocate as collateral":r.InsufficientFunds,"At least":r.BadRequest,"collateral is not allowed":r.BadRequest,"Insufficient liquidity":r.InvalidOrder,"Insufficient order size":r.InvalidOrder,"Invalid quantity":r.InvalidOrder,"Invalid Stop Loss":r.InvalidOrder,"Invalid stop price!":r.InvalidOrder,"Not enough balance":r.InsufficientFunds,"Not enough margin":r.InsufficientFunds,"orderType missing":r.BadRequest,"Server Timeout":r.ExchangeError,"Time in force has to be IOC or FOK for market orders":r.InvalidOrder,"Too many attempts":r.RateLimitExceeded}}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"symbol"),a=this.safeCurrencyCode(r),o=this.safeValue(i,"canWithdraw"),n=this.safeValue(i,"canDeposit"),d=!this.safeValue(i,"canTrade")||o,h=this.safeNumber(i,"minQty");s[a]=this.safeCurrencyStructure({id:r,code:a,name:a,info:i,active:d,deposit:n,withdraw:o,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(i,"digits"))),limits:{amount:{min:h,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}})}if(void 0===this.safeValue(this.options,"currenciesByIdForParseMarket")){const e=this.indexBy(s,"id");this.options.currenciesByIdForParseMarket=e,this.options.currencyIdsListForParseMarket=Object.keys(e)}return s}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e);return void 0===this.safeValue(this.options,"currenciesByIdForParseMarket")&&await this.fetchCurrencies(),this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"pair"),s=this.parseMarketId(t),i=this.safeString(s,"baseId"),r=this.safeString(s,"quoteId"),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r),n=this.parseMarketPrecisionAndLimits(i),d=this.parseMarketPrecisionAndLimits(r),h=this.safeBool(e,"margin",!1),c=this.safeValue(this.fees,"trading",{});return this.safeMarketStructure({id:t,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:h,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(c,"taker"),maker:this.safeNumber(c,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:n.precision,price:this.parseNumber(this.parsePrecision(this.safeString(e,"precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:n.minLimit,max:void 0},price:{min:void 0,max:void 0},cost:{min:d.minLimit,max:void 0}},created:void 0,info:e})}parseMarketId(e){let t,s;const i=this.safeValue(this.options,"currencyIdsListForParseMarket",[]);for(let r=0;r<i.length;r++){const a=i[r],o=e.indexOf(a);if(-1!==o){const r=e.replace(a,"");if(this.inArray(r,i)){0===o?(t=a,s=r):(t=r,s=a);break}}}return{baseId:t,quoteId:s}}parseMarketPrecisionAndLimits(e){const t=this.safeValue(this.options,"currenciesByIdForParseMarket",{}),s=this.safeValue(t,e,{}),i=this.safeValue(s,"limits",{}),r=this.safeValue(i,"amount",{}),a=this.safeNumber(r,"min");return{precision:this.safeNumber(s,"precision"),minLimit:a}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={pair:a.id,timeframe:this.safeString(this.timeframes,t,t)};let n;if(void 0!==s){if(o.from=s,void 0!==i){const e=1e3*this.parseTimeframe(t);n=this.sum(s,e*i)}}else o.from=":from";n=this.safeInteger(r,"until",n),void 0!==n?(r=this.omit(r,["until"]),o.to=n):o.to=":to";const d=await this.publicGetExchangeCandlesPairTimeframeFromTo(this.extend(o,r)),h=this.safeList(d,"candleHistory",[]);return this.parseOHLCVs(h,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};a.from=void 0!==t?t:"";const o=await this.publicGetExchangeTicksPairFrom(this.extend(a,i)),n=this.safeList(o,"tickHistory",[]);return this.parseTrades(n,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};a.since=void 0!==t?t:0;const o=await this.privateGetExchangeFillsSince(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"symbol","pair"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeStringN(e,["_id","seqNum","seqNumber"]),a=this.safeInteger(e,"timestamp"),o=this.safeString(e,"price"),n=this.safeString(e,"qty"),d=this.safeString(e,"orderID"),h=this.safeString(e,"side");return this.safeTrade({id:r,order:d,timestamp:a,datetime:this.iso8601(a),symbol:i,type:void 0,side:h,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:void 0,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={pair:this.market(e).id},r=await this.publicGetExchangeBookPair(this.extend(i,s)),a=this.safeValue(r,"book",{}),o={bids:this.safeValue(a,"bid",{}),asks:this.safeValue(a,"ask",{})},n=this.parseOrderBook(o,e);return n.nonce=this.safeInteger(a,"seqNumber"),n}parseBidsAsks(e,t=0,s=1,i=2){const r=Object.keys(e),a=[];for(let t=0;t<r.length;t++){const s=this.safeString(r,t),i=this.safeNumber(r,t),o=this.safeNumber(e,s);a.push([i,o])}return a}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetExchangePrices(t),i=this.safeValue(s,"latestPrices",[]),r=this.safeValue(s,"24hInfo",[]),a={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"pair");void 0!==s&&(a[s]=t)}for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"pair");if(void 0!==s){const e=this.safeValue(a,s,{});a[s]=this.extend(t,e)}}const o=Object.values(a);return this.parseTickers(o,e)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetExchangePrices(t),i=this.safeList(s,"latestPrices",[]);return this.parseTickers(i,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");t=this.safeMarket(s,t);const i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"bid"),a=this.safeString(e,"ask"),n=this.safeString(e,"h"),d=this.safeString(e,"l"),h=this.safeString(e,"price"),c=this.safeString(e,"v"),l=this.safeString(e,"delta"),u=o.Y.stringMul(l,"100");return this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:void 0,high:n,low:d,close:void 0,last:h,bid:r,bidVolume:void 0,ask:a,askVolume:void 0,vwap:void 0,previousClose:void 0,change:void 0,percentage:u,average:void 0,baseVolume:c,quoteVolume:void 0,info:e},t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUsersWallets(e),s=this.safeList(t,"list",[]);return this.parseBalance(s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=this.safeDict(e,s,{}),r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.used=this.safeString(i,"reserved"),t[a]=o}return this.safeBalance(t)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;r.since=void 0!==t?t:"",void 0!==e&&(a=this.currency(e));const o=await this.privateGetUsersWalletsHistorySince(this.extend(r,i)),n=this.safeValue(o,"list",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"currency"),i=this.safeValue(t,"balanceHistory",[]);for(let e=0;e<i.length;e++){const t=i[e];t.currencyId=s,d.push(t)}}return this.parseLedger(d,a,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"currencyId");e=this.omit(e,"currencyId"),t=this.safeCurrency(i,t);const r=this.safeString(e,"description",""),[a,n]=this.parseLedgerEntryDescription(r),d=this.safeValue(e,"JSONdata",{}),h={cost:this.safeString(d,"fees"),currency:void 0};let c,l=this.safeString(e,"amount");return void 0!==l&&(o.Y.stringLt(l,"0")?(c="out",l=o.Y.stringAbs(l)):o.Y.stringGt(l,"0")&&(c="in")),this.safeLedgerEntry({info:e,id:void 0,timestamp:this.parse8601(s),datetime:s,direction:c,account:void 0,referenceId:n,referenceAccount:void 0,type:a,currency:t,amount:l,before:void 0,after:void 0,status:void 0,fee:h},t)}parseLedgerEntryDescription(e){let t,s,i=[];void 0!==e&&(i=e.split(" "));return i.length>1&&(t=this.parseLedgerEntryType(i[0]),s="-"!==i[1]?i[1]:this.safeString(i,2)),[t,s]}parseLedgerEntryType(e){return this.safeString({Deposit:"transaction",Withdraw:"transaction",Order:"trade"},e,e)}async createOrder(e,t,s,i,a=void 0,n={}){await this.loadMarkets();const d=this.market(e);let h,c={};c.orderType=t,void 0!==i&&(h=this.amountToPrecision(e,i));let l,u=this.safeValue(n,"cost");if(n=this.omit(n,"cost"),"limit"===t){if(void 0===a&&void 0===u)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price or params.cost argument for a "+t+" order");if(void 0!==a&&void 0!==i){const e=o.Y.stringMul(this.numberToString(a),this.numberToString(h));u=this.parseToNumeric(e)}}void 0!==u&&(l=this.costToPrecision(e,u)),"sell"===s?c=this.handleCreateOrderSide(d.baseId,d.quoteId,h,l,c):"buy"===s&&(c=this.handleCreateOrderSide(d.quoteId,d.baseId,l,h,c));const p=this.safeValue(n,"timeInForce");void 0!==p&&(n=this.omit(n,"timeInForce"),c.timeInForce=this.encodeOrderTimeInForce(p));const f=this.safeString2(n,"triggerPrice","stopPrice");void 0!==f&&(n=this.omit(n,["triggerPrice"]),c.stopPrice=this.priceToPrecision(e,f));const m=this.safeValue(n,"userData",{}),g=this.safeString2(n,"clientOrderId","comment");void 0!==g&&(n=this.omit(n,["clientOrderId"]),m.comment=g);const v=this.safeString(n,"stopLossPrice");void 0!==v&&(n=this.omit(n,"stopLossPrice"),m.stopLoss=this.priceToPrecision(e,v));const y=this.safeString(n,"takeProfitPrice");void 0!==y&&(n=this.omit(n,"takeProfitPrice"),m.takeProfit=this.priceToPrecision(e,y)),this.isEmpty(m)||(c.userData=m);const w=await this.privatePostExchangeOrdersCreate(this.extend(c,n));return this.parseOrder(w,d)}handleCreateOrderSide(e,t,s,i,r={}){return r.sellingCurrency=e,r.buyingCurrency=t,void 0!==s&&(r.sellingQty=s),void 0!==i&&(r.buyingQty=i),r}encodeOrderTimeInForce(e){return this.safeValue({GTC:1,IOC:2,GTD:3,FOK:4},e,e)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderID:e};[s,s]=this.handleMarginModeAndParams("cancelOrder",s);const r=this.safeBool(s,"margin",!1);let a;return s=this.omit(s,"margin"),a=r?await this.privatePostExchangeOrdersCloseOrderID(this.extend(i,s)):await this.privatePutExchangeOrdersCancelOrderID(this.extend(i,s)),this.parseOrder(a)}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString(s,"orderId");if(void 0===i)throw new r.ArgumentsRequired(this.id+" closePosition() requires a orderId parameter");const a={orderID:i},o=await this.privatePostExchangeOrdersCloseOrderID(this.extend(a,s));return this.parseOrder(o)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privateGetExchangeOrdersActive(i),o=this.parseOrders(a,r,t,s);for(let e=0;e<o.length;e++){o[e].status="open"}return o}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==t&&(a.since=t);const o=await this.privateGetExchangeOrdersHistorySince(this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderID:e},r=await this.privateGetExchangeOrdersStatusOrderID(this.extend(i,s));return this.parseOrder(r)}parseOrder(e,t=void 0){let s=this.safeInteger(e,"creationTime");let i;!0===this.safeValue(e,"canceled")?void 0===s?(s=this.safeInteger(e,"completionTime"),i="rejected"):i="canceled":(i=this.safeString(e,"status"),e=this.omit(e,"status"));const r=this.safeString(e,"orderType");let a=this.safeString(e,"buyingQty"),n=this.safeString(e,"sellingQty");const d=this.safeString(e,"boughtQty"),h=this.safeString(e,"soldQty");"market"===r&&(void 0===a&&void 0!==d&&"0"!==d&&(a=d),void 0===n&&void 0!==h&&"0"!==h&&(n=h));const c=this.safeString(e,"buyingCurrency",""),l=this.safeString(e,"sellingCurrency",""),u=c+l,p=l+c;let f,m,g,v,y,w=a,b=a;const S=this.indexBy(this.markets,"id");let k,O;void 0!==this.safeValue(S,u)?(f="buy",m=u,b=n,g=d,v=h,y="base"):void 0!==this.safeValue(S,p)&&(f="sell",m=p,w=n,g=h,v=d,y="quote"),void 0!==w&&void 0!==b&&(k=o.Y.stringDiv(b,w)),t=this.safeMarket(m,t);const T=this.safeString(e,"fees");void 0!==T&&void 0!==y&&(O={currency:t[y],cost:T,rate:void 0});const P=this.safeValue(e,"fills",[]),I=this.safeValue(e,"userData",{}),x=this.safeString(e,"stopPrice"),A=this.safeString(I,"comment"),M=this.safeString(I,"takeProfit"),C=this.safeString(I,"stopLoss");return this.safeOrder({id:this.safeString(e,"orderID"),clientOrderId:A,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"lastFillTime"),status:i,symbol:t.symbol,type:r,timeInForce:this.parseOrderTimeInForce(this.safeInteger(e,"timeInForce")),side:f,price:k,triggerPrice:x,takeProfitPrice:M,stopLossPrice:C,average:void 0,amount:w,cost:v,filled:g,remaining:void 0,fee:O,fees:void 0,trades:P,info:e},t)}parseOrderTimeInForce(e){const t=[void 0,"GTC","IOC","GTD","FOK"];return this.safeValue(t,e,e)}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={};r[i.id]=this.currencyToPrecision(e,t);const a=await this.privatePutUsersMarginCollateral(this.extend(r,s)),o=this.safeValue(a,"result",{}),n=this.parseMarginLoan(o,i);return this.extend(n,{amount:t})}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"coin");return{id:void 0,currency:this.safeCurrencyCode(s,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),n="/"+this.implodeParams(e,i);let d=this.urls.api[t]+n;const h=this.urlencode(o);for(void 0===r&&(r={}),r.CCXT="true","private"===t?(void 0===this.uid&&void 0!==this.apiKey&&(this.uid=this.apiKey),void 0===this.token&&void 0!==this.secret&&(this.token=this.secret),"https://api.coinmetro.com/jwt"===d?(r["X-Device-Id"]="bypass",void 0!==this.twofa&&(r["X-OTP"]=this.twofa)):"https://api.coinmetro.com/jwtDevice"===d?(r["X-Device-Id"]=this.uid,void 0!==this.twofa&&(r["X-OTP"]=this.twofa)):(r.Authorization="Bearer "+this.token,d.startsWith("https://api.coinmetro.com/open")||(this.checkRequiredCredentials(),r["X-Device-Id"]=this.uid)),"POST"!==s&&"PUT"!==s||(r["Content-Type"]="application/x-www-form-urlencoded",a=this.urlencode(o))):0!==h.length&&(d+="?"+h);d.endsWith("/");)d=d.slice(0,d.length-1);return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&200!==e&&201!==e&&202!==e){const e=this.id+" "+o,t=this.safeString(n,"message");throw this.throwBroadlyMatchedException(this.exceptions.broad,t,e),this.throwExactlyMatchedException(this.exceptions.exact,t,e),new r.ExchangeError(e)}}}},5377:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(6658),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinone",name:"CoinOne",countries:["KR"],rateLimit:50,version:"v2",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,ws:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",api:{rest:"https://api.coinone.co.kr",v2Public:"https://api.coinone.co.kr/public/v2",v2Private:"https://api.coinone.co.kr/v2",v2_1Private:"https://api.coinone.co.kr/v2.1"},www:"https://coinone.co.kr",doc:"https://doc.coinone.co.kr"},requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:["orderbook","ticker","ticker_utc","trades"]},v2Public:{get:["range_units","markets/{quote_currency}","markets/{quote_currency}/{target_currency}","orderbook/{quote_currency}/{target_currency}","trades/{quote_currency}/{target_currency}","ticker_new/{quote_currency}","ticker_new/{quote_currency}/{target_currency}","ticker_utc_new/{quote_currency}","ticker_utc_new/{quote_currency}/{target_currency}","currencies","currencies/{currency}","chart/{quote_currency}/{target_currency}"]},private:{post:["account/deposit_address","account/btc_deposit_address","account/balance","account/daily_balance","account/user_info","account/virtual_account","order/cancel_all","order/cancel","order/limit_buy","order/limit_sell","order/complete_orders","order/limit_orders","order/order_info","transaction/auth_number","transaction/history","transaction/krw/history","transaction/btc","transaction/coin"]},v2Private:{post:["account/balance","account/deposit_address","account/user_info","account/virtual_account","order/cancel","order/limit_buy","order/limit_sell","order/limit_orders","order/complete_orders","order/query_order","transaction/auth_number","transaction/btc","transaction/history","transaction/krw/history"]},v2_1Private:{post:["account/balance/all","account/balance","account/trade_fee","account/trade_fee/{quote_currency}/{target_currency}","order/limit","order/cancel","order/cancel/all","order/open_orders","order/open_orders/all","order/complete_orders","order/complete_orders/all","order/info","transaction/krw/history","transaction/coin/history","transaction/coin/withdrawal/limit"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:.002,maker:.002}},precisionMode:o.kb,exceptions:{104:r.OrderNotFound,107:r.BadRequest,108:r.BadSymbol,405:r.OnMaintenance},commonCurrencies:{SOC:"Soda Coin"}})}async fetchCurrencies(e={}){const t=await this.v2PublicGetCurrencies(e),s={},i=this.safeValue(t,"currencies",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"name"),o=this.safeCurrencyCode(r),n="normal"===this.safeString(t,"withdraw_status",""),d="normal"===this.safeString(t,"deposit_status","");s[o]={id:r,code:o,info:t,name:a,active:n&&d,deposit:d,withdraw:n,fee:this.safeNumber(t,"withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(t,"max_precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(t,"withdrawal_min_amount"),max:void 0}},networks:{}}}return s}async fetchMarkets(e={}){const t=await this.v2PublicGetTickerNewQuoteCurrency({quote_currency:"KRW"}),s=this.safeValue(t,"tickers",[]),i=[];for(let e=0;e<s.length;e++){const t=this.safeValue(s,e),r=this.safeString(t,"id"),a=this.safeStringUpper(t,"target_currency"),o=this.safeStringUpper(t,"quote_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);i.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-4"),price:this.parseNumber("1e-4"),cost:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}parseBalance(e){const t={info:e},s=this.omit(e,["errorCode","result","normalWallets"]),i=Object.keys(s);for(let e=0;e<i.length;e++){const r=i[e],a=s[r],o=this.safeCurrencyCode(r),n=this.account();n.free=this.safeString(a,"avail"),n.total=this.safeString(a,"balance"),t[o]=n}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v2PrivatePostAccountBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={quote_currency:i.quote,target_currency:i.base};void 0!==t&&(r.size=t);const a=await this.v2PublicGetOrderbookQuoteCurrencyTargetCurrency(this.extend(r,s)),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","qty")}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={quote_currency:"KRW"};let i,r;if(void 0!==(e=this.marketSymbols(e))){const a=this.safeString(e,0);i=this.market(a),s.quote_currency=i.quote,s.target_currency=i.base,r=await this.v2PublicGetTickerNewQuoteCurrencyTargetCurrency(this.extend(s,t))}else r=await this.v2PublicGetTickerNewQuoteCurrency(this.extend(s,t));const a=this.safeList(r,"tickers",[]);return this.parseTickers(a,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={quote_currency:s.quote,target_currency:s.base},r=await this.v2PublicGetTickerNewQuoteCurrencyTargetCurrency(this.extend(i,t)),a=this.safeValue(r,"tickers",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"last"),r=this.safeValue(e,"best_asks"),a=this.safeValue(e,"best_bids"),o=this.safeString(e,"target_currency"),n=this.safeString(e,"quote_currency"),d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n);return this.safeTicker({symbol:d+"/"+h,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(a,"price"),bidVolume:this.safeString(a,"qty"),ask:this.safeString(r,"price"),askVolume:this.safeString(r,"qty"),vwap:void 0,open:this.safeString(e,"first"),close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"target_volume"),quoteVolume:this.safeString(e,"quote_volume"),info:e},t)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp");t=this.safeMarket(void 0,t);const i=this.safeValue(e,"is_seller_maker");let r;void 0!==i&&(r=i?"sell":"buy");const o=this.safeString(e,"price"),n=this.safeString(e,"qty"),d=this.safeString(e,"orderId");let h,c=this.safeString(e,"fee");if(void 0!==c){c=a.Y.stringAbs(c);let s=this.safeString(e,"feeRate");s=a.Y.stringAbs(s);h={cost:c,currency:"sell"===r?t.quote:t.base,rate:s}}return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:s,datetime:this.iso8601(s),order:d,symbol:t.symbol,type:void 0,side:r,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={quote_currency:r.quote,target_currency:r.base};void 0!==s&&(a.size=Math.min(s,200));const o=await this.v2PublicGetTradesQuoteCurrencyTargetCurrency(this.extend(a,i)),n=this.safeList(o,"transactions",[]);return this.parseTrades(n,r,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){if("limit"!==t)throw new r.ExchangeError(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const n=this.market(e),d={price:a,currency:n.id,qty:i},h="privatePostOrder"+this.capitalize(t)+this.capitalize(s),c=await this[h](this.extend(d,o));return this.parseOrder(c,n)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={order_id:e,currency:i.id},o=await this.v2PrivatePostOrderQueryOrder(this.extend(a,s));return this.parseOrder(o,i)}parseOrderStatus(e){return this.safeString({live:"open",partially_filled:"open",partially_canceled:"open",filled:"closed",canceled:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"baseCurrency"),r=this.safeString(e,"targetCurrency");let o,n,d;void 0!==i&&(o=this.safeCurrencyCode(i)),void 0!==r&&(n=this.safeCurrencyCode(r)),void 0!==o&&void 0!==n&&(d=o+"/"+n,t=this.safeMarket(d,t,"/"));const h=this.safeTimestamp2(e,"timestamp","updatedAt");let c=this.safeString2(e,"type","side");"ask"===c?c="sell":"bid"===c&&(c="buy");const l=this.safeString(e,"remainQty"),u=this.safeString2(e,"originalQty","qty");let p,f=this.safeString(e,"status");if("live"===f&&void 0!==l&&void 0!==u){a.Y.stringLt(l,u)&&(f="canceled")}f=this.parseOrderStatus(f);const m=this.safeString(e,"fee");if(void 0!==m){const t="sell"===c?n:o;p={cost:m,rate:this.safeString(e,"feeRate"),currency:t}}return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,symbol:d,type:"limit",timeInForce:void 0,postOnly:void 0,side:c,price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:this.safeString(e,"averageExecutedPrice"),amount:u,filled:this.safeString(e,"executedQty"),remaining:l,status:f,fee:p,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ExchangeError(this.id+" fetchOpenOrders() allows fetching closed orders with a specific symbol");await this.loadMarkets();const a=this.market(e),o={currency:a.id},n=await this.privatePostOrderLimitOrders(this.extend(o,i)),d=this.safeList(n,"limitOrders",[]);return this.parseOrders(d,a,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={currency:a.id},n=await this.v2PrivatePostOrderCompleteOrders(this.extend(o,i)),d=this.safeList(n,"completeOrders",[]);return this.parseTrades(d,a,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");const i=this.safeNumber(s,"price"),a=this.safeNumber(s,"qty"),o=this.safeInteger(s,"is_ask");if(void 0===i||void 0===a||void 0===o)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument.");await this.loadMarkets();const n={order_id:e,price:i,qty:a,is_ask:o,currency:this.marketId(t)},d=await this.v2PrivatePostOrderCancel(this.extend(n,s));return this.safeOrder(d)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.v2PrivatePostAccountDepositAddress(t),i=this.safeValue(s,"walletAddress",{}),r=Object.keys(i),a={};for(let e=0;e<r.length;e++){const t=r[e],s=i[t];if(!s||"-1"===s)continue;const o=t.split("_"),n=this.safeValue(o,0),d=this.safeValue(o,1),h=this.safeCurrencyCode(n);let c=this.safeValue(a,h);void 0===c&&(c={currency:h,address:void 0,tag:void 0,info:s});const l=this.safeString(c,"address",s);this.checkAddress(l),c.address=l,c.info=l,"tag"!==d&&"memo"!==d||(c.tag=s,c.info=[l,s]),a[h]=c}return a}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));let h=this.urls.api.rest+"/";if("v2Public"===t?(h=this.urls.api.v2Public+"/",t="public"):"v2Private"===t?h=this.urls.api.v2Private+"/":"v2_1Private"===t&&(h=this.urls.api.v2_1Private+"/"),"public"===t)h+=o,Object.keys(d).length&&(h+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),h+=o;const e=this.nonce().toString(),t=this.json(this.extend({access_token:this.apiKey,nonce:e},i)),s=this.stringToBase64(t);a=s;const d=this.secret.toUpperCase();r={"Content-Type":"application/json","X-COINONE-PAYLOAD":s,"X-COINONE-SIGNATURE":this.hmac(this.encode(s),this.encode(d),n.Zf)}}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"error_code");if(void 0!==c&&"0"!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions,c,e),new r.ExchangeError(e)}}}},2692:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4935),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinsph",name:"Coins.ph",countries:["PH"],version:"v1",rateLimit:50,certified:!1,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,deposit:!0,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:void 0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!0,ws:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/225719995-48ab2026-4ddb-496c-9da7-0d7566617c9b.jpg",api:{public:"https://api.pro.coins.ph",private:"https://api.pro.coins.ph"},www:"https://coins.ph/",doc:["https://coins-docs.github.io/rest-api"],fees:"https://support.coins.ph/hc/en-us/sections/4407198694681-Limits-Fees"},api:{public:{get:{"openapi/v1/ping":1,"openapi/v1/time":1,"openapi/quote/v1/ticker/24hr":{cost:1,noSymbolAndNoSymbols:40,byNumberOfSymbols:[[101,40],[21,20],[0,1]]},"openapi/quote/v1/ticker/price":{cost:1,noSymbol:2},"openapi/quote/v1/ticker/bookTicker":{cost:1,noSymbol:2},"openapi/v1/exchangeInfo":10,"openapi/quote/v1/depth":{cost:1,byLimit:[[101,5],[0,1]]},"openapi/quote/v1/klines":1,"openapi/quote/v1/trades":1,"openapi/v1/pairs":1,"openapi/quote/v1/avgPrice":1}},private:{get:{"openapi/wallet/v1/config/getall":10,"openapi/wallet/v1/deposit/address":10,"openapi/wallet/v1/deposit/history":1,"openapi/wallet/v1/withdraw/history":1,"openapi/v1/account":10,"openapi/v1/openOrders":{cost:3,noSymbol:40},"openapi/v1/asset/tradeFee":1,"openapi/v1/order":2,"openapi/v1/historyOrders":{cost:10,noSymbol:40},"openapi/v1/myTrades":10,"openapi/v1/capital/deposit/history":1,"openapi/v1/capital/withdraw/history":1,"openapi/v3/payment-request/get-payment-request":1,"merchant-api/v1/get-invoices":1,"openapi/account/v3/crypto-accounts":1,"openapi/transfer/v3/transfers/{id}":1},post:{"openapi/wallet/v1/withdraw/apply":600,"openapi/v1/order/test":1,"openapi/v1/order":1,"openapi/v1/capital/withdraw/apply":1,"openapi/v1/capital/deposit/apply":1,"openapi/v3/payment-request/payment-requests":1,"openapi/v3/payment-request/delete-payment-request":1,"openapi/v3/payment-request/payment-request-reminder":1,"openapi/v1/userDataStream":1,"merchant-api/v1/invoices":1,"merchant-api/v1/invoices-cancel":1,"openapi/convert/v1/get-supported-trading-pairs":1,"openapi/convert/v1/get-quote":1,"openapi/convert/v1/accpet-quote":1,"openapi/fiat/v1/support-channel":1,"openapi/fiat/v1/cash-out":1,"openapi/fiat/v1/history":1,"openapi/migration/v4/sellorder":1,"openapi/migration/v4/validate-field":1,"openapi/transfer/v3/transfers":1},delete:{"openapi/v1/order":1,"openapi/v1/openOrders":1,"openapi/v1/userDataStream":1}}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.003"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.003")],[this.parseNumber("500000"),this.parseNumber("0.0027")],[this.parseNumber("1000000"),this.parseNumber("0.0024")],[this.parseNumber("2500000"),this.parseNumber("0.002")],[this.parseNumber("5000000"),this.parseNumber("0.0018")],[this.parseNumber("10000000"),this.parseNumber("0.0015")],[this.parseNumber("100000000"),this.parseNumber("0.0012")],[this.parseNumber("500000000"),this.parseNumber("0.0009")],[this.parseNumber("1000000000"),this.parseNumber("0.0007")],[this.parseNumber("2500000000"),this.parseNumber("0.0005")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0025")],[this.parseNumber("500000"),this.parseNumber("0.0022")],[this.parseNumber("1000000"),this.parseNumber("0.0018")],[this.parseNumber("2500000"),this.parseNumber("0.0015")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.001")],[this.parseNumber("100000000"),this.parseNumber("0.0008")],[this.parseNumber("500000000"),this.parseNumber("0.0007")],[this.parseNumber("1000000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000000"),this.parseNumber("0.0005")]]}}},precisionMode:a.kb,options:{createMarketBuyOrderRequiresPrice:!0,withdraw:{warning:!1},deposit:{warning:!1},createOrder:{timeInForce:"GTC",newOrderRespType:{market:"FULL",limit:"FULL"}},fetchTicker:{method:"publicGetOpenapiQuoteV1Ticker24hr"},fetchTickers:{method:"publicGetOpenapiQuoteV1Ticker24hr"},networks:{TRC20:"TRX",ERC20:"ETH",BEP20:"BSC",ARB:"ARBITRUM"}},exceptions:{exact:{"-1000":r.BadRequest,"-1001":r.BadRequest,"-1002":r.AuthenticationError,"-1003":r.RateLimitExceeded,"-1004":r.InvalidOrder,"-1006":r.BadResponse,"-1007":r.BadResponse,"-1014":r.InvalidOrder,"-1015":r.RateLimitExceeded,"-1016":r.NotSupported,"-1020":r.NotSupported,"-1021":r.BadRequest,"-1022":r.BadRequest,"-1023":r.AuthenticationError,"-1024":r.BadRequest,"-1025":r.BadRequest,"-1030":r.ExchangeError,"-1100":r.BadRequest,"-1101":r.BadRequest,"-1102":r.BadRequest,"-1103":r.BadRequest,"-1104":r.BadRequest,"-1105":r.BadRequest,"-1106":r.BadRequest,"-1111":r.BadRequest,"-1112":r.BadResponse,"-1114":r.BadRequest,"-1115":r.InvalidOrder,"-1116":r.InvalidOrder,"-1117":r.InvalidOrder,"-1118":r.InvalidOrder,"-1119":r.InvalidOrder,"-1120":r.BadRequest,"-1121":r.BadSymbol,"-1122":r.InvalidOrder,"-1125":r.BadRequest,"-1127":r.BadRequest,"-1128":r.BadRequest,"-1130":r.BadRequest,"-1131":r.InsufficientFunds,"-1132":r.InvalidOrder,"-1133":r.InvalidOrder,"-1134":r.InvalidOrder,"-1135":r.InvalidOrder,"-1136":r.InvalidOrder,"-1137":r.InvalidOrder,"-1138":r.InvalidOrder,"-1139":r.InvalidOrder,"-1140":r.InvalidOrder,"-1141":r.DuplicateOrderId,"-1142":r.InvalidOrder,"-1143":r.OrderNotFound,"-1144":r.InvalidOrder,"-1145":r.InvalidOrder,"-1146":r.InvalidOrder,"-1147":r.InvalidOrder,"-1148":r.InvalidOrder,"-1149":r.InvalidOrder,"-1150":r.InvalidOrder,"-1151":r.BadSymbol,"-1152":r.NotSupported,"-1153":r.AuthenticationError,"-1154":r.BadRequest,"-1155":r.BadRequest,"-1156":r.InvalidOrder,"-1157":r.BadSymbol,"-1158":r.InvalidOrder,"-1159":r.InvalidOrder,"-1160":r.BadRequest,"-1161":r.BadRequest,"-2010":r.InvalidOrder,"-2013":r.OrderNotFound,"-2011":r.BadRequest,"-2014":r.BadRequest,"-2015":r.AuthenticationError,"-2016":r.BadResponse,"-3126":r.InvalidOrder,"-3127":r.InvalidOrder,"-4001":r.BadRequest,"-100011":r.BadSymbol,"-100012":r.BadSymbol,"-30008":r.InsufficientFunds,"-30036":r.InsufficientFunds,403:r.ExchangeNotAvailable},broad:{"Unknown order sent":r.OrderNotFound,"Duplicate order sent":r.DuplicateOrderId,"Market is closed":r.BadSymbol,"Account has insufficient balance for requested action":r.InsufficientFunds,"Market orders are not supported for this symbol":r.BadSymbol,"Iceberg orders are not supported for this symbol":r.BadSymbol,"Stop loss orders are not supported for this symbol":r.BadSymbol,"Stop loss limit orders are not supported for this symbol":r.BadSymbol,"Take profit orders are not supported for this symbol":r.BadSymbol,"Take profit limit orders are not supported for this symbol":r.BadSymbol,"Price* QTY is zero or less":r.BadRequest,"IcebergQty exceeds QTY":r.BadRequest,"This action disabled is on this account":r.PermissionDenied,"Unsupported order combination":r.InvalidOrder,"Order would trigger immediately":r.InvalidOrder,"Cancel order is invalid. Check origClOrdId and orderId":r.InvalidOrder,"Order would immediately match and take":r.OrderImmediatelyFillable,PRICE_FILTER:r.InvalidOrder,LOT_SIZE:r.InvalidOrder,MIN_NOTIONAL:r.InvalidOrder,MAX_NUM_ORDERS:r.InvalidOrder,MAX_ALGO_ORDERS:r.InvalidOrder,BROKER_MAX_NUM_ORDERS:r.InvalidOrder,BROKER_MAX_ALGO_ORDERS:r.InvalidOrder,ICEBERG_PARTS:r.BadRequest}}})}calculateRateLimiterCost(e,t,s,i,r={}){if("noSymbol"in r&&!("symbol"in i))return r.noSymbol;if("noSymbolAndNoSymbols"in r&&!("symbol"in i)&&!("symbols"in i))return r.noSymbolAndNoSymbols;if("byNumberOfSymbols"in r&&"symbols"in i){const e=i.symbols.length,t=r.byNumberOfSymbols;for(let s=0;s<t.length;s++){const i=t[s];if(e>=i[0])return i[1]}}else if("byLimit"in r&&"limit"in i){const e=i.limit,t=r.byLimit;for(let s=0;s<t.length;s++){const i=t[s];if(e>=i[0])return i[1]}}return this.safeValue(r,"cost",1)}async fetchStatus(e={}){return{status:"ok",updated:void 0,eta:void 0,url:void 0,info:await this.publicGetOpenapiV1Ping(e)}}async fetchTime(e={}){const t=await this.publicGetOpenapiV1Time(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.publicGetOpenapiV1ExchangeInfo(e),s=this.safeValue(t,"symbols"),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"baseAsset"),o=this.safeString(t,"quoteAsset"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.indexBy(this.safeValue(t,"filters"),"filterType"),c=this.safeValue(h,"LOT_SIZE",{}),l=this.safeValue(h,"PRICE_FILTER",{}),u=this.safeValue(h,"NOTIONAL",{});i.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"trading"===this.safeStringLower(t,"status"),contract:!1,linear:void 0,inverse:void 0,taker:void 0,maker:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.safeString(c,"stepSize")),price:this.parseNumber(this.safeString(l,"tickSize"))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(this.safeString(c,"minQty")),max:this.parseNumber(this.safeString(c,"maxQty"))},price:{min:this.parseNumber(this.safeString(l,"minPrice")),max:this.parseNumber(this.safeString(l,"maxPrice"))},cost:{min:this.parseNumber(this.safeString(u,"minNotional")),max:void 0}},created:void 0,info:t})}return this.setMarkets(i),i}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=[];for(let s=0;s<e.length;s++){const i=this.market(e[s]).id;t.push(i)}s.symbols=t}const i=this.safeValue(this.options,"fetchTickers",{}),r=this.safeString(i,"method","publicGetOpenapiQuoteV1Ticker24hr");let a;return a="publicGetOpenapiQuoteV1TickerPrice"===r?await this.publicGetOpenapiQuoteV1TickerPrice(this.extend(s,t)):"publicGetOpenapiQuoteV1TickerBookTicker"===r?await this.publicGetOpenapiQuoteV1TickerBookTicker(this.extend(s,t)):await this.publicGetOpenapiQuoteV1Ticker24hr(this.extend(s,t)),this.parseTickers(a,e,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=this.safeValue(this.options,"fetchTicker",{}),a=this.safeString(r,"method","publicGetOpenapiQuoteV1Ticker24hr");let o;return o="publicGetOpenapiQuoteV1TickerPrice"===a?await this.publicGetOpenapiQuoteV1TickerPrice(this.extend(i,t)):"publicGetOpenapiQuoteV1TickerBookTicker"===a?await this.publicGetOpenapiQuoteV1TickerBookTicker(this.extend(i,t)):await this.publicGetOpenapiQuoteV1Ticker24hr(this.extend(i,t)),this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"closeTime"),r=this.safeString(e,"bidPrice"),a=this.safeString(e,"askPrice"),n=this.safeString(e,"bidQty"),d=this.safeString(e,"askQty"),h=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume"),l=this.safeString(e,"openPrice"),u=this.safeString(e,"highPrice"),p=this.safeString(e,"lowPrice"),f=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"weightedAvgPrice"),g=this.safeString(e,"priceChange");let v=this.safeString(e,"priceChangePercent");return v=o.Y.stringMul(v,"100"),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:l,high:u,low:p,close:this.safeString2(e,"lastPrice","price"),bid:r,bidVolume:n,ask:a,askVolume:d,vwap:m,previousClose:f,change:g,percentage:v,average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetOpenapiQuoteV1Depth(this.extend(i,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t),n={symbol:a.id,interval:o};if(void 0!==s)if(n.startTime=s,n.limit=1e3,void 0!==i){const e=1e3*this.parseTimeframe(t);n.endTime=this.sum(s,e*(i-1))}else n.endTime=this.milliseconds();else void 0!==i&&(n.limit=i);const d=await this.publicGetOpenapiQuoteV1Klines(this.extend(n,r));return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t?a.limit=1e3:void 0!==s&&(a.limit=s);const o=await this.publicGetOpenapiQuoteV1Trades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==t?(o.startTime=t,o.limit=1e3):void 0!==s&&(o.limit=s);const n=await this.privateGetOpenapiV1MyTrades(this.extend(o,i));return this.parseTrades(n,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");const o={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(o,a))}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"id","tradeId"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"time"),n=this.safeString(e,"price"),d=this.safeString(e,"qty");let h;const c=this.safeString(e,"commission");if(void 0!==c){const t=this.safeString(e,"commissionAsset");h={cost:c,currency:this.safeCurrencyCode(t)}}const l=this.safeValue2(e,"isBuyer","isBuyerMaker",void 0);let u;void 0!==l&&(u=!0===l?"buy":"sell");const p=this.safeString2(e,"isMaker",void 0);let f,m;return void 0!==p&&(f="true"===p?"maker":"taker"),void 0!==a&&(m=this.safeString(e,"quoteQty")),this.safeTrade({id:r,order:a,timestamp:o,datetime:this.iso8601(o),symbol:i,type:undefined,side:u,takerOrMaker:f,price:n,amount:d,cost:m,fee:h,info:e},t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetOpenapiV1Account(e);return this.parseBalance(t)}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"free"),o.used=this.safeString(i,"locked"),s[a]=o}return this.safeBalance(s)}async createOrder(e,t,s,i,a=void 0,n={}){await this.loadMarkets();const d=this.market(e),h=this.safeBool(n,"test",!1);n=this.omit(n,"test");let c=this.safeString(n,"type",t);c=this.encodeOrderType(c),n=this.omit(n,"type");const l=this.encodeOrderSide(s),u={symbol:d.id,type:c,side:l},p=this.safeValue(this.options,"createOrder",{});let f,m=this.safeValue(p,"newOrderRespType",{});if("LIMIT"===c||"STOP_LOSS_LIMIT"===c||"TAKE_PROFIT_LIMIT"===c||"LIMIT_MAKER"===c){if(void 0===a)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for a "+t+" order");m=this.safeString(m,"limit","FULL"),u.price=this.priceToPrecision(e,a),u.quantity=this.amountToPrecision(e,i),"LIMIT_MAKER"!==c&&(u.timeInForce=this.safeString(p,"timeInForce","GTC"))}else if("MARKET"===c||"STOP_LOSS"===c||"TAKE_PROFIT"===c)if(m=this.safeString(m,"market","FULL"),"SELL"===l)u.quantity=this.amountToPrecision(e,i);else if("BUY"===l){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber2(n,"cost","quoteOrderQty");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(a),n=o.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);u.quoteOrderQty=t}if("STOP_LOSS"===c||"STOP_LOSS_LIMIT"===c||"TAKE_PROFIT"===c||"TAKE_PROFIT_LIMIT"===c){const t=this.safeString2(n,"triggerPrice","stopPrice");if(void 0===t)throw new r.InvalidOrder(this.id+" createOrder () requires a triggerPrice or stopPrice param for stop_loss, take_profit, stop_loss_limit, and take_profit_limit orders");u.stopPrice=this.priceToPrecision(e,t)}return u.newOrderRespType=m,n=this.omit(n,"price","stopPrice","triggerPrice","quantity","quoteOrderQty"),f=h?await this.privatePostOpenapiV1OrderTest(this.extend(u,n)):await this.privatePostOpenapiV1Order(this.extend(u,n)),this.parseOrder(f,d)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},r=this.safeValue2(s,"origClientOrderId","clientOrderId");void 0!==r?i.origClientOrderId=r:i.orderId=e,s=this.omit(s,["clientOrderId","origClientOrderId"]);const a=await this.privateGetOpenapiV1Order(this.extend(i,s));return this.parseOrder(a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id);const o=await this.privateGetOpenapiV1OpenOrders(this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==t?(o.startTime=t,o.limit=1e3):void 0!==s&&(o.limit=s);const n=await this.privateGetOpenapiV1HistoryOrders(this.extend(o,i));return this.parseOrders(n,a,t,s)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},r=this.safeValue2(s,"origClientOrderId","clientOrderId");void 0!==r?i.origClientOrderId=r:i.orderId=e,s=this.omit(s,["clientOrderId","origClientOrderId"]);const a=await this.privateDeleteOpenapiV1Order(this.extend(i,s));return this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");let s;await this.loadMarkets();const i={};void 0!==e&&(s=this.market(e),i.symbol=s.id);const a=await this.privateDeleteOpenapiV1OpenOrders(this.extend(i,t));return this.parseOrders(a,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=this.safeInteger2(e,"time","transactTime"),a=this.safeValue(e,"fills",void 0);let n=this.safeString(e,"stopPrice");return o.Y.stringEq(n,"0")&&(n=void 0),this.safeOrder({id:s,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"status")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeString(e,"price"),stopPrice:n,triggerPrice:n,average:void 0,amount:this.safeString(e,"origQty"),cost:this.safeString(e,"cummulativeQuoteQty"),filled:this.safeString(e,"executedQty"),remaining:void 0,fee:void 0,fees:void 0,trades:a,info:e},t)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell"},e,e)}encodeOrderSide(e){return this.safeString({buy:"BUY",sell:"SELL"},e,e)}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit",STOP_LOSS:"market",STOP_LOSS_LIMIT:"limit",TAKE_PROFIT:"market",TAKE_PROFIT_LIMIT:"limit"},e,e)}encodeOrderType(e){return this.safeString({market:"MARKET",limit:"LIMIT",limit_maker:"LIMIT_MAKER",stop_loss:"STOP_LOSS",stop_loss_limit:"STOP_LOSS_LIMIT",take_profit:"TAKE_PROFIT",take_profit_limit:"TAKE_PROFIT_LIMIT"},e,e)}parseOrderStatus(e){return this.safeString({NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",REJECTED:"rejected"},e,e)}parseOrderTimeInForce(e){return this.safeString({GTC:"GTC",FOK:"FOK",IOC:"IOC"},e,e)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateGetOpenapiV1AssetTradeFee(this.extend(i,t)),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetOpenapiV1AssetTradeFee(e),s={};for(let e=0;e<t.length;e++){const i=this.parseTradingFee(t[e]);s[i.symbol]=i}return s}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:(t=this.safeMarket(s,t)).symbol,maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission"),percentage:void 0,tierBased:void 0}}async withdraw(e,t,s,i=void 0,a={}){const o=this.safeValue(this.options,"withdraw");if(this.safeBool(o,"warning",!0))throw new r.InvalidAddress(this.id+" withdraw() makes a withdrawals only to coins_ph account, add .options['withdraw']['warning'] = false to make a withdrawal to your coins_ph account");const n=this.safeString(a,"network"),d=this.networkCodeToId(n,e);if(void 0===d)throw new r.BadRequest(this.id+" withdraw() require network parameter");await this.loadMarkets();const h=this.currency(e),c={coin:h.id,amount:this.numberToString(t),network:d,address:s};void 0!==i&&(c.withdrawOrderId=i),a=this.omit(a,"network");const l=await this.privatePostOpenapiWalletV1WithdrawApply(this.extend(c,a));return this.parseTransaction(l,h)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.coin=r.id),void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s);const o=await this.privateGetOpenapiWalletV1DepositHistory(this.extend(a,i));return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.coin=r.id),void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s);const o=await this.privateGetOpenapiWalletV1WithdrawHistory(this.extend(a,i));return this.parseTransactions(o,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address");let r=this.safeString(e,"addressTag");void 0!==r&&r.length<1&&(r=void 0);const a=this.safeString(e,"txId"),o=this.safeString(e,"coin"),n=this.safeCurrencyCode(o,t);let d;d=this.safeInteger2(e,"insertTime","applyTime");let h;const c=this.safeString(e,"withdrawOrderId"),l=this.safeString(e,"depositOrderId");void 0!==c?h="withdrawal":void 0!==l&&(h="deposit");const u=this.parseTransactionStatus(this.safeString(e,"status")),p=this.safeNumber(e,"amount"),f=this.safeNumber(e,"transactionFee");let m;void 0!==f&&(m={currency:n,cost:f});const g=this.safeString(e,"network"),v="Internal"===g;return{info:e,id:s,txid:a,timestamp:d,datetime:this.iso8601(d),network:g,address:i,addressTo:i,addressFrom:void 0,tag:r,tagTo:r,tagFrom:void 0,type:h,amount:p,currency:n,status:u,updated:undefined,internal:v,comment:void 0,fee:m}}parseTransactionStatus(e){return this.safeString({0:"pending",1:"ok",2:"failed",3:"pending"},e,e)}async fetchDepositAddress(e,t={}){const s=this.safeString(t,"network"),i=this.networkCodeToId(s,e);if(void 0===i)throw new r.BadRequest(this.id+" fetchDepositAddress() require network parameter");await this.loadMarkets();const a=this.currency(e),o={coin:a.id,network:i};t=this.omit(t,"network");const n=await this.privateGetOpenapiWalletV1DepositAddress(this.extend(o,t));return this.parseDepositAddress(n,a)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"coin");return{currency:this.safeCurrencyCode(s,t),address:this.safeString(e,"address"),tag:this.safeString(e,"addressTag"),network:null,info:e}}urlEncodeQuery(e={}){let t="";const s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i];if(Array.isArray(e[r])){0!==i&&(t+="&");const s=e[r];e=this.omit(e,r);t+=this.parseArrayParam(s,r)}}const i=this.urlencode(e);return 0!==i.length?i+"&"+t:t}parseArrayParam(e,t){let s=this.json(e);s=s.replace("[","%5B"),s=s.replace("]","%5D");return t+"="+s}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t],d=this.omit(i,this.extractParams(e));if(o=o+"/"+this.implodeParams(e,i),"private"===t){this.checkRequiredCredentials(),d.timestamp=this.milliseconds();if(void 0===this.safeInteger(d,"recvWindow")){const e=this.safeInteger(this.options,"recvWindow");void 0!==e&&(d.recvWindow=e)}d=this.urlEncodeQuery(d);o=o+"?"+d+"&signature="+this.hmac(this.encode(d),this.encode(this.secret),n.s),r={"X-COINS-APIKEY":this.apiKey}}else d=this.urlEncodeQuery(d),0!==d.length&&(o+="?"+d);return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code",void 0);if(void 0!==c&&"200"!==c&&"0"!==c){const e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}}},1669:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9360),r=s(2079),a=s(1579),o=s(7481),n=s(5147);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"coinspot",name:"CoinSpot",countries:["AU"],rateLimit:1e3,pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,ws:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg",api:{public:"https://www.coinspot.com.au/pubapi",private:"https://www.coinspot.com.au/api"},www:"https://www.coinspot.com.au",doc:"https://www.coinspot.com.au/api",referral:"https://www.coinspot.com.au/register?code=PJURCU"},api:{public:{get:["latest"]},private:{post:["orders","orders/history","my/coin/deposit","my/coin/send","quote/buy","quote/sell","my/balances","my/orders","my/buy","my/sell","my/buy/cancel","my/sell/cancel","ro/my/balances","ro/my/balances/{cointype}","ro/my/deposits","ro/my/withdrawals","ro/my/transactions","ro/my/transactions/{cointype}","ro/my/transactions/open","ro/my/transactions/{cointype}/open","ro/my/sendreceive","ro/my/affiliatepayments","ro/my/referralpayments"]}},markets:{"ADA/AUD":this.safeMarketStructure({id:"ada",symbol:"ADA/AUD",base:"ADA",quote:"AUD",baseId:"ada",quoteId:"aud",type:"spot",spot:!0}),"BTC/AUD":this.safeMarketStructure({id:"btc",symbol:"BTC/AUD",base:"BTC",quote:"AUD",baseId:"btc",quoteId:"aud",type:"spot",spot:!0}),"ETH/AUD":this.safeMarketStructure({id:"eth",symbol:"ETH/AUD",base:"ETH",quote:"AUD",baseId:"eth",quoteId:"aud",type:"spot",spot:!0}),"XRP/AUD":this.safeMarketStructure({id:"xrp",symbol:"XRP/AUD",base:"XRP",quote:"AUD",baseId:"xrp",quoteId:"aud",type:"spot",spot:!0}),"LTC/AUD":this.safeMarketStructure({id:"ltc",symbol:"LTC/AUD",base:"LTC",quote:"AUD",baseId:"ltc",quoteId:"aud",type:"spot",spot:!0}),"DOGE/AUD":this.safeMarketStructure({id:"doge",symbol:"DOGE/AUD",base:"DOGE",quote:"AUD",baseId:"doge",quoteId:"aud",type:"spot",spot:!0}),"RFOX/AUD":this.safeMarketStructure({id:"rfox",symbol:"RFOX/AUD",base:"RFOX",quote:"AUD",baseId:"rfox",quoteId:"aud",type:"spot",spot:!0}),"POWR/AUD":this.safeMarketStructure({id:"powr",symbol:"POWR/AUD",base:"POWR",quote:"AUD",baseId:"powr",quoteId:"aud",type:"spot",spot:!0}),"NEO/AUD":this.safeMarketStructure({id:"neo",symbol:"NEO/AUD",base:"NEO",quote:"AUD",baseId:"neo",quoteId:"aud",type:"spot",spot:!0}),"TRX/AUD":this.safeMarketStructure({id:"trx",symbol:"TRX/AUD",base:"TRX",quote:"AUD",baseId:"trx",quoteId:"aud",type:"spot",spot:!0}),"EOS/AUD":this.safeMarketStructure({id:"eos",symbol:"EOS/AUD",base:"EOS",quote:"AUD",baseId:"eos",quoteId:"aud",type:"spot",spot:!0}),"XLM/AUD":this.safeMarketStructure({id:"xlm",symbol:"XLM/AUD",base:"XLM",quote:"AUD",baseId:"xlm",quoteId:"aud",type:"spot",spot:!0}),"RHOC/AUD":this.safeMarketStructure({id:"rhoc",symbol:"RHOC/AUD",base:"RHOC",quote:"AUD",baseId:"rhoc",quoteId:"aud",type:"spot",spot:!0}),"GAS/AUD":this.safeMarketStructure({id:"gas",symbol:"GAS/AUD",base:"GAS",quote:"AUD",baseId:"gas",quoteId:"aud",type:"spot",spot:!0})},commonCurrencies:{DRK:"DASH"},options:{fetchBalance:"private_post_my_balances"},precisionMode:a.kb})}parseBalance(e){const t={info:e},s=this.safeValue2(e,"balance","balances");if(Array.isArray(s))for(let e=0;e<s.length;e++){const i=s[e],r=Object.keys(i);for(let e=0;e<r.length;e++){const s=r[e],a=i[s],o=this.safeCurrencyCode(s),n=this.account();n.total=this.safeString(a,"balance"),t[o]=n}}else{const e=Object.keys(s);for(let i=0;i<e.length;i++){const r=e[i],a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(s,r),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(this.options,"fetchBalance","private_post_my_balances"),s=await this[t](e);return this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={cointype:i.id},a=await this.privatePostOrders(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"buyorders","sellorders","rate","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.publicGetLatest(t);let r=s.id;r=r.toLowerCase();const a=this.safeValue(i,"prices"),o=this.safeDict(a,r);return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetLatest(t),i={},r=this.safeValue(s,"prices"),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],s=this.safeMarket(t);if(s.spot){const e=s.symbol,a=r[t];i[e]=this.parseTicker(a,s)}}return this.filterByArrayTickers(i,"symbol",e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={cointype:r.id},o=await this.privatePostOrdersHistory(this.extend(a,i)),n=this.safeList(o,"orders",[]);return this.parseTrades(n,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e)),void 0!==t&&(r.startdate=this.yyyymmdd(t));const o=await this.privatePostRoMyTransactions(this.extend(r,i)),n=this.safeValue(o,"buyorders",[]);for(let e=0;e<n.length;e++)n[e].side="buy";const d=this.safeValue(o,"sellorders",[]);for(let e=0;e<d.length;e++)d[e].side="sell";const h=this.arrayConcat(n,d);return this.parseTrades(h,a,t,s)}parseTrade(e,t=void 0){let s,i,r;const a=this.safeString(e,"audtotal"),o=this.safeString(e,"total",a),d=this.safeString(e,"side"),h=this.safeString(e,"amount"),c=this.safeString(e,"market"),l=this.safeSymbol(c,t,"/"),u=this.safeInteger(e,"solddate");if(void 0!==u)i=this.safeString(e,"rate"),s=u;else{i=n.Y.stringDiv(o,h);const t=this.safeString(e,"created");s=this.parse8601(t);const a=this.safeString(e,"audfeeExGst"),d=this.safeString(e,"audGst"),c=n.Y.stringAdd(a,d),l="AUD";r={cost:this.parseNumber(c),currency:this.safeCurrencyCode(l)}}return this.safeTrade({info:e,id:void 0,symbol:l,timestamp:s,datetime:this.iso8601(s),order:void 0,type:void 0,side:d,takerOrMaker:void 0,price:this.parseNumber(i),amount:this.parseNumber(h),cost:this.parseNumber(o),fee:r},t)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n="privatePostMy"+this.capitalize(s);if("market"===t)throw new r.ExchangeError(this.id+" createOrder() allows limit orders only");const d={cointype:this.market(e).id,amount:i,rate:a};return await this[n](this.extend(d,o))}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if("buy"!==i&&"sell"!==i)throw new r.ArgumentsRequired(this.id+' cancelOrder() requires a side parameter, "buy" or "sell"');s=this.omit(s,"side");const a={id:e};let o;return o="buy"===i?await this.privatePostMyBuyCancel(this.extend(a,s)):await this.privatePostMySellCancel(this.extend(a,s)),this.safeOrder({info:o})}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const n=this.urls.api[t]+"/"+e;if("private"===t){this.checkRequiredCredentials();const e=this.nonce();a=this.json(this.extend({nonce:e},i)),r={"Content-Type":"application/json",key:this.apiKey,sign:this.hmac(this.encode(a),this.encode(this.secret),o.Zf)}}return{url:n,method:s,body:a,headers:r}}}},6068:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4295),r=s(5147),a=s(2079),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"cryptocom",name:"Crypto.com",countries:["MT"],version:"v2",rateLimit:10,certified:!0,pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!0,option:!0,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!0,closeAllPositions:!1,closePosition:!0,createMarketBuyOrderWithCost:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:"emulated",fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchGreeks:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMySettlementHistory:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!1,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!0,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!1,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"7D","2w":"14D","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/147792121-38ed5e36-c229-48d6-b49a-48d05fc19ed4.jpeg",test:{v1:"https://uat-api.3ona.co/exchange/v1",v2:"https://uat-api.3ona.co/v2",derivatives:"https://uat-api.3ona.co/v2"},api:{v1:"https://api.crypto.com/exchange/v1",v2:"https://api.crypto.com/v2",derivatives:"https://deriv-api.crypto.com/v1"},www:"https://crypto.com/",referral:{url:"https://crypto.com/exch/kdacthrnxt",discount:.15},doc:["https://exchange-docs.crypto.com/exchange/v1/rest-ws/index.html","https://exchange-docs.crypto.com/spot/index.html","https://exchange-docs.crypto.com/derivatives/index.html"],fees:"https://crypto.com/exchange/document/fees-limits"},api:{v1:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1},post:{"public/staking/get-conversion-rate":2}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/create-order-list":10/3,"private/cancel-order":2/3,"private/cancel-order-list":10/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3,"private/create-subaccount-transfer":10/3,"private/get-subaccount-balances":10/3,"private/get-order-list":10/3,"private/create-withdrawal":10/3,"private/get-currency-networks":10/3,"private/get-deposit-address":10/3,"private/get-accounts":10/3,"private/get-withdrawal-history":10/3,"private/get-deposit-history":10/3,"private/get-fee-rate":2,"private/get-instrument-fee-rate":2,"private/staking/stake":2,"private/staking/unstake":2,"private/staking/get-staking-position":2,"private/staking/get-staking-instruments":2,"private/staking/get-open-stake":2,"private/staking/get-stake-history":2,"private/staking/get-reward-history":2,"private/staking/convert":2,"private/staking/get-open-convert":2,"private/staking/get-convert-history":2}}},v2:{public:{get:{"public/auth":1,"public/get-instruments":1,"public/get-book":1,"public/get-candlestick":1,"public/get-ticker":1,"public/get-trades":1,"public/margin/get-transfer-currencies":1,"public/margin/get-load-currenices":1,"public/respond-heartbeat":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/create-withdrawal":10/3,"private/get-withdrawal-history":10/3,"private/get-currency-networks":10/3,"private/get-deposit-history":10/3,"private/get-deposit-address":10/3,"private/export/create-export-request":10/3,"private/export/get-export-requests":10/3,"private/export/download-export-output":10/3,"private/get-account-summary":10/3,"private/create-order":2/3,"private/cancel-order":2/3,"private/cancel-all-orders":2/3,"private/create-order-list":10/3,"private/get-order-history":10/3,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/get-accounts":10/3,"private/get-subaccount-balances":10/3,"private/create-subaccount-transfer":10/3,"private/otc/get-otc-user":10/3,"private/otc/get-instruments":10/3,"private/otc/request-quote":100,"private/otc/accept-quote":100,"private/otc/get-quote-history":10/3,"private/otc/get-trade-history":10/3,"private/otc/create-order":10/3}}},derivatives:{public:{get:{"public/auth":10/3,"public/get-instruments":10/3,"public/get-book":1,"public/get-candlestick":1,"public/get-trades":1,"public/get-tickers":1,"public/get-valuations":1,"public/get-expired-settlement-price":10/3,"public/get-insurance":1}},private:{post:{"private/set-cancel-on-disconnect":10/3,"private/get-cancel-on-disconnect":10/3,"private/user-balance":10/3,"private/user-balance-history":10/3,"private/get-positions":10/3,"private/create-order":2/3,"private/create-order-list":10/3,"private/cancel-order":2/3,"private/cancel-order-list":10/3,"private/cancel-all-orders":2/3,"private/close-position":10/3,"private/convert-collateral":10/3,"private/get-order-history":100,"private/get-open-orders":10/3,"private/get-order-detail":1/3,"private/get-trades":100,"private/change-account-leverage":10/3,"private/get-transactions":10/3,"private/create-subaccount-transfer":10/3,"private/get-subaccount-balances":10/3,"private/get-order-list":10/3}}}},fees:{trading:{maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0015")],[this.parseNumber("100000"),this.parseNumber("0.001")],[this.parseNumber("250000"),this.parseNumber("0.0009")],[this.parseNumber("1000000"),this.parseNumber("0.0008")],[this.parseNumber("20000000"),this.parseNumber("0.0007")],[this.parseNumber("100000000"),this.parseNumber("0.0006")],[this.parseNumber("200000000"),this.parseNumber("0.0004")]],taker:[[this.parseNumber("0"),this.parseNumber("0.004")],[this.parseNumber("25000"),this.parseNumber("0.0035")],[this.parseNumber("50000"),this.parseNumber("0.0025")],[this.parseNumber("100000"),this.parseNumber("0.0016")],[this.parseNumber("250000"),this.parseNumber("0.00015")],[this.parseNumber("1000000"),this.parseNumber("0.00014")],[this.parseNumber("20000000"),this.parseNumber("0.00013")],[this.parseNumber("100000000"),this.parseNumber("0.00012")],[this.parseNumber("200000000"),this.parseNumber("0.0001")]]}}},options:{defaultType:"spot",accountsById:{funding:"SPOT",spot:"SPOT",margin:"MARGIN",derivatives:"DERIVATIVES",swap:"DERIVATIVES",future:"DERIVATIVES"},networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON"},broker:"CCXT"},commonCurrencies:{USD_STABLE_COIN:"USDC"},precisionMode:o.kb,exceptions:{exact:{219:a.InvalidOrder,314:a.InvalidOrder,10001:a.ExchangeError,10002:a.PermissionDenied,10003:a.PermissionDenied,10004:a.BadRequest,10005:a.PermissionDenied,10006:a.DDoSProtection,10007:a.InvalidNonce,10008:a.BadRequest,10009:a.BadRequest,20001:a.BadRequest,20002:a.InsufficientFunds,20005:a.AccountNotEnabled,30003:a.BadSymbol,30004:a.BadRequest,30005:a.BadRequest,30006:a.InvalidOrder,30007:a.InvalidOrder,30008:a.InvalidOrder,30009:a.InvalidOrder,30010:a.BadRequest,30013:a.InvalidOrder,30014:a.InvalidOrder,30016:a.InvalidOrder,30017:a.InvalidOrder,30023:a.InvalidOrder,30024:a.InvalidOrder,30025:a.InvalidOrder,40001:a.BadRequest,40002:a.BadRequest,40003:a.BadRequest,40004:a.BadRequest,40005:a.BadRequest,40006:a.BadRequest,40007:a.BadRequest,40101:a.AuthenticationError,40102:a.InvalidNonce,40103:a.AuthenticationError,40104:a.AuthenticationError,40107:a.BadRequest,40401:a.OrderNotFound,40801:a.RequestTimeout,42901:a.RateLimitExceeded,43005:a.InvalidOrder,50001:a.ExchangeError,9010001:a.OnMaintenance},broad:{}}})}async fetchMarkets(e={}){const t=await this.v1PublicGetPublicGetInstruments(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"data",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"inst_type"),a="CCY_PAIR"===s,o="PERPETUAL_SWAP"===s,n="FUTURE"===s,d="WARRANT"===s,h=this.safeString(t,"base_ccy"),c=this.safeString(t,"quote_ccy"),l=a?void 0:c,u=this.safeCurrencyCode(h),p=this.safeCurrencyCode(c),f=a?void 0:this.safeCurrencyCode(l),m=this.safeStringLower(t,"put_call"),g=this.safeString(t,"strike"),v=this.safeValue(t,"margin_buy_enabled"),y=this.safeValue(t,"margin_sell_enabled"),w=this.omitZero(this.safeString(t,"expiry_timestamp_ms")),b=void 0!==w?parseInt(w):void 0;let S,k,O=u+"/"+p;if("CCY_PAIR"===s)S="spot",k=!1;else if("PERPETUAL_SWAP"===s)S="swap",O=O+":"+p,k=!0;else if("FUTURE"===s)S="future",O=O+":"+p+"-"+this.yymmdd(b),k=!0;else if("WARRANT"===s){S="option";const e="call"===m?"C":"P";O=O+":"+p+"-"+this.yymmdd(b)+"-"+g+"-"+e,k=!0}r.push({id:this.safeString(t,"symbol"),symbol:O,base:u,quote:p,settle:f,baseId:h,quoteId:c,settleId:l,type:S,spot:a,margin:v||y,swap:o,future:n,option:d,active:this.safeValue(t,"tradable"),contract:k,linear:!!k||void 0,inverse:!k&&void 0,contractSize:this.safeNumber(t,"contract_size"),expiry:b,expiryDatetime:this.iso8601(b),strike:this.parseNumber(g),optionType:m,precision:{price:this.parseNumber(this.safeString(t,"price_tick_size")),amount:this.parseNumber(this.safeString(t,"qty_tick_size"))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(t,"max_leverage")},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return r}async fetchTickers(e=void 0,t={}){let s;await this.loadMarkets();const i={};if(void 0!==e){let t;if(Array.isArray(e)){if(e.length>1)throw new a.BadRequest(this.id+" fetchTickers() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;s=this.market(t),i.instrument_name=s.id}const r=await this.v1PublicGetPublicGetTickers(this.extend(i,t)),o=this.safeValue(r,"result",{}),n=this.safeList(o,"data",[]);return this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchOrders",e,t,s,i);const o={};void 0!==e&&(r=this.market(e),o.instrument_name=r.id),void 0!==t&&(o.start_time=t),void 0!==s&&(o.limit=s);const n=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==n&&(o.end_time=n);const d=await this.v1PrivatePostPrivateGetOrderHistory(this.extend(o,i)),h=this.safeValue(d,"result",{}),c=this.safeList(h,"data",[]);return this.parseOrders(c,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);const a=this.market(e),o={instrument_name:a.id};void 0!==t&&(o.start_ts=t),void 0!==s&&(o.count=s);const n=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==n&&(o.end_ts=n);const d=await this.v1PublicGetPublicGetTrades(this.extend(o,i)),h=this.safeValue(d,"result",{}),c=this.safeList(h,"data",[]);return this.parseTrades(c,a,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,300);const o=this.market(e),n={instrument_name:o.id,timeframe:this.safeString(this.timeframes,t,t)};void 0!==i&&(i>300&&(i=300),n.count=i);const d=this.microseconds(),h=this.parseTimeframe(t),c=this.safeInteger(r,"until",d);r=this.omit(r,["until"]),void 0!==s?(n.start_ts=s-1e3*h,n.end_ts=void 0!==i?this.sum(s,h*i*1e3):c):n.end_ts=c;const l=await this.v1PublicGetPublicGetCandlestick(this.extend(n,r)),u=this.safeValue(l,"result",{}),p=this.safeList(u,"data",[]);return this.parseOHLCVs(p,o,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={instrument_name:this.market(e).id};t&&(i.depth=t);const r=await this.v1PublicGetPublicGetBook(this.extend(i,s)),a=this.safeValue(r,"result",{}),o=this.safeValue(a,"data",[]),n=this.safeValue(o,0),d=this.safeInteger(n,"t");return this.parseOrderBook(n,e,d)}parseBalance(e){const t=this.safeValue(e,"result",{}),s=this.safeValue(t,"data",[]),i=this.safeValue(s[0],"position_balances",[]),r={info:e};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"instrument_name"),a=this.safeCurrencyCode(s),o=this.account();o.total=this.safeString(t,"quantity"),o.used=this.safeString(t,"reserved_qty"),r[a]=o}return this.safeBalance(r)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PrivatePostPrivateUserBalance(e);return this.parseBalance(t)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={order_id:e},a=await this.v1PrivatePostPrivateGetOrderDetail(this.extend(r,s)),o=this.safeDict(a,"result",{});return this.parseOrder(o,i)}createOrderRequest(e,t,s,i,a=void 0,o={}){const n=this.market(e),d=t.toUpperCase(),h={instrument_name:n.id,side:s.toUpperCase(),quantity:this.amountToPrecision(e,i)};"LIMIT"!==d&&"STOP_LIMIT"!==d&&"TAKE_PROFIT_LIMIT"!==d||(h.price=this.priceToPrecision(e,a));const c=this.safeString(this.options,"broker","CCXT");let l,u;h.broker_id=c,[l,o]=this.handleMarketTypeAndParams("createOrder",n,o),[u,o]=this.customHandleMarginModeAndParams("createOrder",o),"margin"===l||void 0!==u?h.spot_margin="MARGIN":"spot"===l&&(h.spot_margin="SPOT");const p=this.safeStringUpper2(o,"timeInForce","time_in_force");void 0!==p&&(h.time_in_force="GTC"===p?"GOOD_TILL_CANCEL":"IOC"===p?"IMMEDIATE_OR_CANCEL":"FOK"===p?"FILL_OR_KILL":p);(this.safeBool(o,"postOnly",!1)||"PO"===p)&&(h.exec_inst=["POST_ONLY"],h.time_in_force="GOOD_TILL_CANCEL");const f=this.safeStringN(o,["stopPrice","triggerPrice","ref_price"]),m=this.safeNumber(o,"stopLossPrice"),g=this.safeNumber(o,"takeProfitPrice"),v=void 0!==m,y=void 0!==g;if(void 0!==f){h.ref_price=this.priceToPrecision(e,f);const t=this.numberToString(a);"LIMIT"===d||"STOP_LIMIT"===d||"TAKE_PROFIT_LIMIT"===d?"buy"===s?r.Y.stringLt(t,f)?h.type="TAKE_PROFIT_LIMIT":h.type="STOP_LIMIT":r.Y.stringLt(t,f)?h.type="STOP_LIMIT":h.type="TAKE_PROFIT_LIMIT":"buy"===s?r.Y.stringLt(t,f)?h.type="TAKE_PROFIT":h.type="STOP_LOSS":r.Y.stringLt(t,f)?h.type="STOP_LOSS":h.type="TAKE_PROFIT"}else v?(h.type="LIMIT"===d||"STOP_LIMIT"===d?"STOP_LIMIT":"STOP_LOSS",h.ref_price=this.priceToPrecision(e,m)):y?(h.type="LIMIT"===d||"TAKE_PROFIT_LIMIT"===d?"TAKE_PROFIT_LIMIT":"TAKE_PROFIT",h.ref_price=this.priceToPrecision(e,g)):h.type=d;return o=this.omit(o,["postOnly","clientOrderId","timeInForce","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(h,o)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.createOrderRequest(e,t,s,i,r,a),d=await this.v1PrivatePostPrivateCreateOrder(n),h=this.safeDict(d,"result",{});return this.parseOrder(h,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.safeString(i,"type"),o=this.safeString(i,"side"),n=this.safeValue(i,"amount"),d=this.safeValue(i,"price"),h=this.safeValue(i,"params",{}),c=this.createAdvancedOrderRequest(r,a,o,n,d,h);s.push(c)}const i={contingency_type:this.safeString(t,"contingency_type","LIST"),order_list:s},r=await this.v1PrivatePostPrivateCreateOrderList(this.extend(i,t)),a=this.safeValue(r,"result",[]),o=this.safeString(a,"list_id");if(void 0!==o){const e=[{order_id:o}];return this.parseOrders(e)}return this.parseOrders(a)}createAdvancedOrderRequest(e,t,s,i,o=void 0,n={}){const d=this.market(e),h=t.toUpperCase(),c={instrument_name:d.id,side:s.toUpperCase()};"LIMIT"!==h&&"STOP_LIMIT"!==h&&"TAKE_PROFIT_LIMIT"!==h||(c.price=this.priceToPrecision(e,o));const l=this.safeString(this.options,"broker","CCXT");c.broker_id=l;const u=this.safeStringUpper2(n,"timeInForce","time_in_force");void 0!==u&&(c.time_in_force="GTC"===u?"GOOD_TILL_CANCEL":"IOC"===u?"IMMEDIATE_OR_CANCEL":"FOK"===u?"FILL_OR_KILL":u);(this.safeBool(n,"postOnly",!1)||"PO"===u)&&(c.exec_inst=["POST_ONLY"],c.time_in_force="GOOD_TILL_CANCEL");const p=this.safeStringN(n,["stopPrice","triggerPrice","ref_price"]),f=void 0!==this.safeNumber(n,"stopLossPrice"),m=void 0!==this.safeNumber(n,"takeProfitPrice");if(void 0!==p){const e=this.numberToString(o);"LIMIT"===h||"STOP_LIMIT"===h||"TAKE_PROFIT_LIMIT"===h?"buy"===s?r.Y.stringLt(e,p)?c.type="TAKE_PROFIT_LIMIT":c.type="STOP_LIMIT":r.Y.stringLt(e,p)?c.type="STOP_LIMIT":c.type="TAKE_PROFIT_LIMIT":"buy"===s?r.Y.stringLt(e,p)?c.type="TAKE_PROFIT":c.type="STOP_LOSS":r.Y.stringLt(e,p)?c.type="STOP_LOSS":c.type="TAKE_PROFIT"}else c.type=f?"LIMIT"===h||"STOP_LIMIT"===h?"STOP_LIMIT":"STOP_LOSS":m?"LIMIT"===h||"TAKE_PROFIT_LIMIT"===h?"TAKE_PROFIT_LIMIT":"TAKE_PROFIT":h;if("buy"!==s||"MARKET"!==h&&"STOP_LOSS"!==h&&"TAKE_PROFIT"!==h)c.quantity=this.amountToPrecision(e,i);else{let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber2(n,"cost","notional");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new a.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),a=this.numberToString(o),n=r.Y.stringMul(s,a);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);c.notional=t}return n=this.omit(n,["postOnly","clientOrderId","timeInForce","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(c,n)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};return void 0!==e&&(s=this.market(e),i.instrument_name=s.id),await this.v1PrivatePostPrivateCancelAllOrders(this.extend(i,t))}async cancelOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={order_id:e},a=await this.v1PrivatePostPrivateCancelOrder(this.extend(r,s)),o=this.safeDict(a,"result",{});return this.parseOrder(o,i)}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),r=[];for(let t=0;t<e.length;t++){const s=e[t],a={instrument_name:i.id,order_id:s.toString()};r.push(a)}const o={contingency_type:"LIST",order_list:r},n=await this.v1PrivatePostPrivateCancelOrderList(this.extend(o,s)),d=this.safeList(n,"result",[]);return this.parseOrders(d,i,void 0,void 0,s)}async cancelOrdersForSymbols(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"id"),a=this.safeString(i,"symbol"),o={instrument_name:this.market(a).id,order_id:r.toString()};s.push(o)}const i={contingency_type:"LIST",order_list:s},r=await this.v1PrivatePostPrivateCancelOrderList(this.extend(i,t)),a=this.safeList(r,"result",[]);return this.parseOrders(a,void 0,void 0,void 0,t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.instrument_name=r.id);const o=await this.v1PrivatePostPrivateGetOpenOrders(this.extend(a,i)),n=this.safeValue(o,"result",{}),d=this.safeList(n,"data",[]);return this.parseOrders(d,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);const a={};let o;void 0!==e&&(o=this.market(e),a.instrument_name=o.id),void 0!==t&&(a.start_time=t),void 0!==s&&(a.limit=s);const n=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==n&&(a.end_time=n);const d=await this.v1PrivatePostPrivateGetTrades(this.extend(a,i)),h=this.safeValue(d,"result",{}),c=this.safeList(h,"data",[]);return this.parseTrades(c,o,t,s)}parseAddress(e){let t,s,i;if(e.indexOf("?")>0){[t,i]=e.split("?");s=i.split("=")[1]}else t=e;return[t,s]}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.safeCurrency(e),o={currency:a.id,amount:t,address:s};let n;void 0!==i&&(o.address_tag=i),[n,r]=this.handleNetworkCodeAndParams(r);const d=this.networkCodeToId(n);void 0!==d&&(o.network_id=d);const h=await this.v1PrivatePostPrivateCreateWithdrawal(this.extend(o,r)),c=this.safeDict(h,"result");return this.parseTransaction(c,a)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s={currency:this.safeCurrency(e).id},i=await this.v1PrivatePostPrivateGetDepositAddress(this.extend(s,t)),r=this.safeValue(i,"result",{}),o=this.safeValue(r,"deposit_address_list",[]),n=o.length;if(0===n)throw new a.ExchangeError(this.id+" fetchDepositAddressesByNetwork() generating address...");const d={};for(let e=0;e<n;e++){const t=this.safeValue(o,e),s=this.safeString(t,"address"),i=this.safeString(t,"currency"),r=this.safeCurrencyCode(i),[a,n]=this.parseAddress(s);this.checkAddress(a);const h=this.safeString(t,"network"),c=this.networkIdToCode(h,r);d[c]={info:t,currency:r,address:a,tag:n,network:c}}return d}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);if(s in i)return i[s];return i[Object.keys(i)[0]]}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.safeCurrency(e),a.currency=r.id),void 0!==t&&(a.start_ts=t),void 0!==s&&(a.page_size=s);const o=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==o&&(a.end_ts=o);const n=await this.v1PrivatePostPrivateGetDepositHistory(this.extend(a,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"deposit_list",[]);return this.parseTransactions(h,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.safeCurrency(e),a.currency=r.id),void 0!==t&&(a.start_ts=t),void 0!==s&&(a.page_size=s);const o=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==o&&(a.end_ts=o);const n=await this.v1PrivatePostPrivateGetWithdrawalHistory(this.extend(a,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"withdrawal_list",[]);return this.parseTransactions(h,r,t,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"i");t=this.safeMarket(i,t,"_");const r=this.safeString(t,"quote"),a=this.safeString(e,"a");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeNumber(e,"h"),low:this.safeNumber(e,"l"),bid:this.safeNumber(e,"b"),bidVolume:void 0,ask:this.safeNumber(e,"k"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:this.safeString(e,"c"),average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:"USD"===r?this.safeString(e,"vv"):void 0,info:e},t)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"t","create_time"),i=this.safeString2(e,"i","instrument_name");t=this.safeMarket(i,t,"_");const a=this.safeString(e,"fee_instrument_name"),o=this.safeString(e,"fees");return this.safeTrade({info:e,id:this.safeString2(e,"d","trade_id"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeString(e,"order_id"),side:this.safeStringLower2(e,"s","side"),takerOrMaker:this.safeStringLower(e,"taker_side"),price:this.safeNumber2(e,"p","traded_price"),amount:this.safeNumber2(e,"q","traded_quantity"),cost:void 0,type:void 0,fee:{currency:this.safeCurrencyCode(a),cost:this.parseNumber(r.Y.stringNeg(o))}},t)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseOrderStatus(e){return this.safeString({ACTIVE:"open",CANCELED:"canceled",FILLED:"closed",REJECTED:"rejected",EXPIRED:"expired"},e,e)}parseTimeInForce(e){return this.safeString({GOOD_TILL_CANCEL:"GTC",IMMEDIATE_OR_CANCEL:"IOC",FILL_OR_KILL:"FOK"},e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"code");if(void 0!==s&&0!==s)return this.safeOrder({id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_oid"),info:e,status:"rejected"});const i=this.safeInteger(e,"create_time"),r=this.safeString(e,"instrument_name"),a=this.safeSymbol(r,t),o=this.safeValue(e,"exec_inst");let n;if(void 0!==o){n=!1;for(let e=0;e<o.length;e++){if("POST_ONLY"===o[e]){n=!0;break}}}const d=this.safeString(e,"fee_instrument_name");return this.safeOrder({info:e,id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_oid"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"update_time"),status:this.parseOrderStatus(this.safeString(e,"status")),symbol:a,type:this.safeStringLower(e,"order_type"),timeInForce:this.parseTimeInForce(this.safeString(e,"time_in_force")),postOnly:n,side:this.safeStringLower(e,"side"),price:this.safeNumber(e,"limit_price"),amount:this.safeNumber(e,"quantity"),filled:this.safeNumber(e,"cumulative_quantity"),remaining:void 0,average:this.safeNumber(e,"avg_price"),cost:this.safeNumber(e,"cumulative_value"),fee:{currency:this.safeCurrencyCode(d),cost:this.safeNumber(e,"cumulative_fee")},trades:[]},t)}parseDepositStatus(e){return this.safeString({0:"pending",1:"ok",2:"failed",3:"pending"},e,e)}parseWithdrawalStatus(e){return this.safeString({0:"pending",1:"pending",2:"failed",3:"pending",4:"failed",5:"ok",6:"canceled"},e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"status");let r;"client_wid"in e?(s="withdrawal",r=this.parseWithdrawalStatus(i)):(s="deposit",r=this.parseDepositStatus(i));const a=this.safeString(e,"address"),[o,n]=this.parseAddress(a),d=this.safeString(e,"currency"),h=this.safeCurrencyCode(d,t),c=this.safeInteger(e,"create_time"),l=this.safeNumber(e,"fee");let u;return void 0!==l&&(u={currency:h,cost:l}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:c,datetime:this.iso8601(c),network:void 0,address:o,addressTo:o,addressFrom:void 0,tag:n,tagTo:n,tagFrom:void 0,type:s,amount:this.safeNumber(e,"amount"),currency:h,status:r,updated:this.safeInteger(e,"update_time"),internal:void 0,comment:this.safeString(e,"client_wid"),fee:u}}customHandleMarginModeAndParams(e,t={}){const s=this.safeString(this.options,"defaultType"),i=this.safeBool(t,"margin",!1);let r;if(t=this.omit(t,"margin"),[r,t]=this.handleMarginModeAndParams(e,t),void 0!==r){if("cross"!==r)throw new a.NotSupported(this.id+" only cross margin is supported")}else"margin"!==s&&!0!==i||(r="cross");return[r,t]}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"network_list"),i=s.length,r={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};if(void 0!==s)for(let e=0;e<i;e++){const a=s[e],o=this.safeString(a,"network_id"),n=this.safeString(t,"code"),d=this.networkIdToCode(o,n);r.networks[d]={deposit:{fee:void 0,percentage:void 0},withdraw:{fee:this.safeNumber(a,"withdrawal_fee"),percentage:!1}},1===i&&(r.withdraw.fee=this.safeNumber(a,"withdrawal_fee"),r.withdraw.percentage=!1)}return r}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v1PrivatePostPrivateGetCurrencyNetworks(t),i=this.safeValue(s,"result"),r=this.safeList(i,"currency_map");return this.parseDepositWithdrawFees(r,e,"full_name")}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.safeCurrency(e)),void 0!==t&&(r.start_time=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==o&&(r.end_time=o);const n=await this.v1PrivatePostPrivateGetTransactions(this.extend(r,i)),d=this.safeValue(n,"result",{}),h=this.safeValue(d,"data",[]);return this.parseLedger(h,a,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"event_timestamp_ms"),i=this.safeString(e,"instrument_name");let a,o=this.safeString(e,"transaction_qty");return r.Y.stringLt(o,"0")?(a="out",o=r.Y.stringAbs(o)):a="in",{id:this.safeString(e,"order_id"),direction:a,account:this.safeString(e,"account_id"),referenceId:this.safeString(e,"trade_id"),referenceAccount:this.safeString(e,"trade_match_id"),type:this.parseLedgerEntryType(this.safeString(e,"journal_type")),currency:this.safeCurrencyCode(i,t),amount:this.parseNumber(o),timestamp:s,datetime:this.iso8601(s),before:void 0,after:void 0,status:void 0,fee:{currency:void 0,cost:void 0},info:e}}parseLedgerEntryType(e){return this.safeString({TRADING:"trade",TRADE_FEE:"fee",WITHDRAW_FEE:"fee",WITHDRAW:"withdrawal",DEPOSIT:"deposit",ROLLBACK_WITHDRAW:"rollback",ROLLBACK_DEPOSIT:"rollback",FUNDING:"fee",REALIZED_PNL:"trade",INSURANCE_FUND:"insurance",SOCIALIZED_LOSS:"trade",LIQUIDATION_FEE:"fee",SESSION_RESET:"reset",ADJUSTMENT:"adjustment",SESSION_SETTLE:"settlement",UNCOVERED_LOSS:"trade",ADMIN_ADJUSTMENT:"adjustment",DELIST:"delist",SETTLEMENT_FEE:"fee",AUTO_CONVERSION:"conversion",MANUAL_CONVERSION:"conversion"},e,e)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.v1PrivatePostPrivateGetAccounts(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"master_account",{}),r=this.safeValue(s,"sub_account_list",[]);return r.push(i),this.parseAccounts(r,e)}parseAccount(e){return{id:this.safeString(e,"uuid"),type:this.safeString(e,"label"),code:void 0,info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),void 0!==e&&(r=this.market(e)),[a,i]=this.handleMarketTypeAndParams("fetchSettlementHistory",r,i),this.checkRequiredArgument("fetchSettlementHistory",a,"type",["future","option","WARRANT","FUTURE"]),"option"===a&&(a="WARRANT");const o={instrument_type:a.toUpperCase()},n=await this.v1PublicGetPublicGetExpiredSettlementPrice(this.extend(o,i)),d=this.safeValue(n,"result",{}),h=this.safeValue(d,"data",[]),c=this.parseSettlements(h,r),l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}parseSettlement(e,t){const s=this.safeInteger(e,"x"),i=this.safeString(e,"i");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"v"),timestamp:s,datetime:this.iso8601(s)}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++)s.push(this.parseSettlement(e[i],t));return s}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),r)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i);const o=this.market(e);if(!o.swap)throw new a.BadSymbol(this.id+" fetchFundingRateHistory() supports swap contracts only");const n={instrument_name:o.id,valuation_type:"funding_hist"};void 0!==t&&(n.start_ts=t),void 0!==s&&(n.count=s);const d=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==d&&(n.end_ts=d);const h=await this.v1PublicGetPublicGetValuations(this.extend(n,i)),c=this.safeValue(h,"result",{}),l=this.safeValue(c,"data",[]),u=this.safeString(c,"instrument_name"),p=[];for(let e=0;e<l.length;e++){const t=l[e],s=this.safeInteger(t,"t");p.push({info:t,symbol:this.safeSymbol(u,o),fundingRate:this.safeNumber(t,"v"),timestamp:s,datetime:this.iso8601(s)})}const f=this.sortBy(p,"timestamp");return this.filterBySymbolSinceLimit(f,o.symbol,t,s)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},r=await this.v1PrivatePostPrivateGetPositions(this.extend(i,t)),a=this.safeDict(r,"result",{}),o=this.safeList(a,"data",[]);return this.parsePosition(this.safeDict(o,0),s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new a.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;i=this.market(t),s.instrument_name=i.id}const r=await this.v1PrivatePostPrivateGetPositions(this.extend(s,t)),o=this.safeValue(r,"result",{}),n=this.safeValue(o,"data",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"instrument_name"),i=this.safeMarket(s,void 0,void 0,"contract");d.push(this.parsePosition(t,i))}return this.filterByArrayPositions(d,"symbol",void 0,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeSymbol(s,t,void 0,"contract"),a=this.safeInteger(e,"update_timestamp_ms"),o=this.safeString(e,"quantity");return this.safePosition({info:e,id:void 0,symbol:i,timestamp:a,datetime:this.iso8601(a),hedged:void 0,side:r.Y.stringGt(o,"0")?"buy":"sell",contracts:r.Y.stringAbs(o),contractSize:t.contractSize,entryPrice:void 0,markPrice:void 0,notional:void 0,leverage:void 0,collateral:this.safeNumber(e,"open_pos_cost"),initialMargin:this.safeNumber(e,"cost"),maintenanceMargin:void 0,initialMarginPercentage:void 0,maintenanceMarginPercentage:void 0,unrealizedPnl:this.safeNumber(e,"open_position_pnl"),liquidationPrice:void 0,marginMode:void 0,percentage:void 0,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}nonce(){return this.milliseconds()}paramsToString(e,t){if(t>=3)return e.toString();if("string"==typeof e)return e;let s,i="";if(Array.isArray(e))s=e;else{const t=this.keysort(e);s=Object.keys(t)}for(let r=0;r<s.length;r++){const a=s[r];i+=a;const o=e[a];if("undefined"===o)i+="null";else if(Array.isArray(o))for(let e=0;e<o.length;e++)i+=this.paramsToString(o[e],t+1);else i+=o.toString()}return i}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={instrument_name:i.id,type:"MARKET"},a=this.safeStringUpper(s,"type"),o=this.safeString(s,"price");void 0!==a&&(r.type=a),void 0!==o&&(r.price=this.priceToPrecision(i.symbol,o));const n=await this.v1PrivatePostPrivateClosePosition(this.extend(r,s)),d=this.safeDict(n,"result");return this.parseOrder(d,i)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},r=await this.v1PrivatePostPrivateGetInstrumentFeeRate(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseTradingFee(a,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v1PrivatePostPrivateGetFeeRate(e),s=this.safeDict(t,"result",{});return this.parseTradingFees(s)}parseTradingFees(e){const t={};t.info=e;for(let s=0;s<this.symbols.length;s++){const i=this.symbols[s],a=this.market(i).swap,o=a?"effective_deriv_taker_rate_bps":"effective_spot_taker_rate_bps",n=a?"effective_deriv_maker_rate_bps":"effective_spot_maker_rate_bps",d={info:e,symbol:i,maker:this.parseNumber(r.Y.stringDiv(this.safeString(e,n),"10000")),taker:this.parseNumber(r.Y.stringDiv(this.safeString(e,o),"10000")),percentage:void 0,tierBased:void 0};t[i]=d}return t}parseTradingFee(e,t=void 0){const s=this.safeString(e,"instrument_name");return{info:e,symbol:this.safeSymbol(s,t),maker:this.parseNumber(r.Y.stringDiv(this.safeString(e,"effective_maker_rate_bps"),"10000")),taker:this.parseNumber(r.Y.stringDiv(this.safeString(e,"effective_taker_rate_bps"),"10000")),percentage:void 0,tierBased:void 0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeString(t,0),d=this.safeString(t,1);let h=this.urls.api[o]+"/"+e;const c=this.omit(i,this.extractParams(e));if("public"===d)Object.keys(c).length&&(h+="?"+this.urlencode(c));else{this.checkRequiredCredentials();const t=this.nonce().toString(),s=this.extend({},i),o=Object.keys(s),d=this.paramsToString(s,0),h=e+t+this.apiKey+d+t,c=this.hmac(this.encode(h),this.encode(this.secret),n.s),l=o.length;if(a=this.json({id:t,method:e,params:i,api_key:this.apiKey,sig:c,nonce:t}),0===l){const e="{}",t="[]";a=a.replace(t,e)}r={"Content-Type":"application/json"}}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,o,n,d,h){const c=this.safeString(n,"code");if("0"!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),new a.ExchangeError(this.id+" "+o)}}}},8686:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8093),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"currencycom",name:"Currency.com",countries:["BY"],rateLimit:100,certified:!1,pro:!0,version:"v2",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:void 0,cancelAllOrders:void 0,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:void 0,createLimitOrder:!0,createMarketOrder:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:"emulated",fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowRateHistory:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:void 0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL2OrderBook:!0,fetchLedger:!0,fetchLedgerEntry:!1,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:void 0,fetchOrderTrades:void 0,fetchPosition:void 0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:"emulated",fetchTransfers:void 0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:void 0,sandbox:!0,setLeverage:void 0,setMarginMode:void 0,setPositionMode:void 0,signIn:void 0,transfer:void 0,withdraw:void 0},timeframes:{"1m":"1m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},hostname:"backend.currency.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg",api:{public:"https://api-adapter.{hostname}/api",private:"https://api-adapter.{hostname}/api",marketcap:"https://marketcap.{hostname}/api"},test:{public:"https://demo-api-adapter.{hostname}/api",private:"https://demo-api-adapter.{hostname}/api"},www:"https://www.currency.com",referral:"https://currency.com/trading/signup?c=362jaimv&pid=referral",doc:["https://currency.com/api"],fees:"https://currency.com/fees-charges"},api:{public:{get:{"v1/time":1,"v1/exchangeInfo":1,"v1/depth":1,"v1/aggTrades":1,"v1/klines":1,"v1/ticker/24hr":1,"v2/time":1,"v2/exchangeInfo":1,"v2/depth":1,"v2/aggTrades":1,"v2/klines":1,"v2/ticker/24hr":1}},marketcap:{get:{"v1/assets":1,"v1/candles":1,"v1/orderbook":1,"v1/summary":1,"v1/ticker":1,"v1/token/assets":1,"v1/token/orderbook":1,"v1/token/summary":1,"v1/token/ticker":1,"v1/token/trades":1,"v1/token_crypto/OHLC":1,"v1/token_crypto/assets":1,"v1/token_crypto/orderbook":1,"v1/token_crypto/summary":1,"v1/token_crypto/ticker":1,"v1/token_crypto/trades":1,"v1/trades":1}},private:{get:{"v1/account":1,"v1/currencies":1,"v1/deposits":1,"v1/depositAddress":1,"v1/ledger":1,"v1/leverageSettings":1,"v1/myTrades":1,"v1/openOrders":1,"v1/tradingPositions":1,"v1/tradingPositionsHistory":1,"v1/transactions":1,"v1/withdrawals":1,"v2/account":1,"v2/currencies":1,"v2/deposits":1,"v2/depositAddress":1,"v2/ledger":1,"v2/leverageSettings":1,"v2/myTrades":1,"v2/openOrders":1,"v2/tradingPositions":1,"v2/tradingPositionsHistory":1,"v2/transactions":1,"v2/withdrawals":1,"v2/fetchOrder":1},post:{"v1/order":1,"v1/updateTradingPosition":1,"v1/updateTradingOrder":1,"v1/closeTradingPosition":1,"v2/order":1,"v2/updateTradingPosition":1,"v2/updateTradingOrder":1,"v2/closeTradingPosition":1},delete:{"v1/order":1,"v2/order":1}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,taker:this.parseNumber("0.002"),maker:this.parseNumber("0.002")}},precisionMode:o.kb,options:{defaultTimeInForce:"GTC",warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,parseOrderToPrecision:!1,newOrderRespType:{market:"FULL",limit:"RESULT",stop:"RESULT"},leverage_markets_suffix:"_LEVERAGE",collateralCurrencies:["USD","EUR","USDT"]},exceptions:{broad:{"FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order":r.InvalidOrder,"API key does not exist":r.AuthenticationError,"Order would trigger immediately.":r.InvalidOrder,"Account has insufficient balance for requested action.":r.InsufficientFunds,"Rest API trading is not enabled.":r.ExchangeNotAvailable,"Combination of parameters invalid":r.BadRequest,"Invalid limit price":r.BadRequest,"Only leverage symbol allowed here:":r.BadSymbol,"market data service is not available":r.ExchangeNotAvailable,"your time is ahead of server":r.InvalidNonce,"Can not find account":r.BadRequest,"You mentioned an invalid value for the price parameter":r.BadRequest},exact:{"-1000":r.ExchangeNotAvailable,"-1013":r.InvalidOrder,"-1022":r.AuthenticationError,"-1030":r.InvalidOrder,"-1100":r.InvalidOrder,"-1104":r.ExchangeError,"-1025":r.AuthenticationError,"-1128":r.BadRequest,"-2010":r.ExchangeError,"-2011":r.OrderNotFound,"-2013":r.OrderNotFound,"-2014":r.AuthenticationError,"-2015":r.AuthenticationError}},commonCurrencies:{ACN:"Accenture",AMC:"AMC Entertainment Holdings",BNS:"Bank of Nova Scotia",CAR:"Avis Budget Group Inc",CLR:"Continental Resources",EDU:"New Oriental Education & Technology Group Inc",ETN:"Eaton",FOX:"Fox Corporation",GM:"General Motors Co",IQ:"iQIYI",OSK:"Oshkosh",PLAY:"Dave & Buster's Entertainment"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetV2Time(e);return this.safeInteger(t,"serverTime")}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetV2Currencies(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"displaySymbol"),a=this.safeCurrencyCode(r),o=this.safeNumber(i,"commissionFixed");s[a]={id:r,code:a,type:this.safeStringLower(i,"type"),name:this.safeString(i,"name"),active:void 0,deposit:void 0,withdraw:void 0,fee:o,precision:this.parseNumber(this.parsePrecision(this.safeString(i,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(i,"minWithdrawal"),max:this.safeNumber(i,"maxWithdrawal")},deposit:{min:this.safeNumber(i,"minDeposit"),max:void 0}},info:i}}return s}async fetchMarkets(e={}){const t=await this.publicGetV2ExchangeInfo(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"symbols",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),o=this.safeString(t,"baseAsset"),n=this.safeString(t,"quoteAsset"),d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n);let c=d+"/"+h;const l=this.safeString(t,"marketType"),u="SPOT"===l,p=!1,f="LEVERAGE"===l,m=f?"swap":"spot",g=void 0;f&&(c=c.replace(this.options.leverage_markets_suffix,""),c+=":"+h);const v="TRADING"===this.safeString(t,"status"),y=this.safeString2(t,"exchangeFee","tradingFee");let w=this.safeString(t,"makerFee",y),b=this.safeString(t,"takerFee",y);w=a.Y.stringDiv(w,"100"),b=a.Y.stringDiv(b,"100");const S=this.safeValue(t,"filters",[]),k=this.indexBy(S,"filterType");let O,T,P=this.safeNumber(t,"tickSize");if("PRICE_FILTER"in k){const e=this.safeValue(k,"PRICE_FILTER",{});P=this.safeNumber(e,"tickSize"),O=this.safeNumber(e,"minPrice");const t=this.safeString(e,"maxPrice");void 0!==t&&a.Y.stringGt(t,"0")&&(T=t)}let I=this.parseNumber(this.parsePrecision(this.safeString(t,"baseAssetPrecision"))),x={min:void 0,max:void 0};if("LOT_SIZE"in k){const e=this.safeValue(k,"LOT_SIZE",{});I=this.safeNumber(e,"stepSize"),x={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}let A,M={min:void 0,max:void 0};if("MARKET_LOT_SIZE"in k){const e=this.safeValue(k,"MARKET_LOT_SIZE",{});M={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}if("MIN_NOTIONAL"in k){const e=this.safeValue(k,"MIN_NOTIONAL",{});A=this.safeNumber(e,"minNotional")}const C=f||p;i.push({id:r,symbol:c,base:d,quote:h,settle:void 0,baseId:o,quoteId:n,settleId:void 0,type:m,spot:u,margin:g,swap:f,future:p,option:!1,active:v,contract:C,linear:!!C||void 0,inverse:void 0,taker:this.parseNumber(b),maker:this.parseNumber(w),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:I,price:P},limits:{leverage:{min:void 0,max:void 0},amount:x,market:M,price:{min:O,max:this.parseNumber(T)},cost:{min:A,max:void 0}},created:void 0,info:t})}return i}async fetchAccounts(e={}){const t=await this.privateGetV2Account(e),s=this.safeValue(t,"balances",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"accountId"),a=this.safeString(t,"asset"),o=this.safeCurrencyCode(a);i.push({id:r,type:void 0,currency:o,info:t})}return i}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e),s=this.safeNumber(t,"makerCommission"),i=this.safeNumber(t,"takerCommission"),r={};for(let e=0;e<this.symbols.length;e++){const a=this.symbols[e];r[a]={info:t,symbol:a,maker:s,taker:i,percentage:!0,tierBased:!1}}return r}parseBalance(e,t=void 0){const s={info:e},i=this.safeValue(e,"balances",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"free"),o.used=this.safeString(t,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV2Account(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetV2Depth(this.extend(i,s)),a=this.parseOrderBook(r,e);return a.nonce=this.safeInteger(r,"lastUpdateId"),a}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"closeTime","timestamp"),i=this.safeString2(e,"symbol","symbolName");t=this.safeMarket(i,t,"/");const r=this.safeString(e,"lastPrice");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString2(e,"bidPrice","bid"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString2(e,"askPrice","ofr"),askVolume:this.safeString(e,"ofrQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:r,last:r,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetV2Ticker24hr(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV2Ticker24hr(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,interval:this.safeString(this.timeframes,t,t)};void 0!==s&&(o.startTime=s),void 0!==i&&(o.limit=Math.min(i,1e3));const n=await this.publicGetV2Klines(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),r=this.safeString2(e,"q","qty"),a=this.safeString2(e,"a","id");let o;const n=this.safeString(e,"orderId");let d,h;"m"in e?(o=e.m?"sell":"buy",d="taker"):"isBuyer"in e&&(o=e.isBuyer?"buy":"sell",d=e.isMaker?"maker":"taker"),"commission"in e&&(h={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))});const c=this.safeString(e,"symbol"),l=this.safeSymbol(c,t);return this.safeTrade({id:a,order:n,timestamp:s,datetime:this.iso8601(s),symbol:l,type:void 0,takerOrMaker:d,side:o,price:i,amount:r,cost:void 0,fee:h,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=Math.min(s,1e3)),void 0!==t&&(a.startTime=t);const o=await this.publicGetV2AggTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"/"),r=this.safeString(e,"orderId"),o=this.safeString(e,"price"),n=this.safeString2(e,"origQty","quantity"),d=this.safeString(e,"executedQty"),h=a.Y.stringAbs(d),c=this.parseOrderStatus(this.safeString(e,"status")),l=this.parseOrderTimeInForce(this.safeString2(e,"timeInForce","timeInForceType")),u=this.parseOrderType(this.safeString(e,"type")),p=this.parseOrderSide(this.safeString(e,"side")),f=this.safeIntegerN(e,["time","transactTime","timestamp"]),m=this.safeValue(e,"fills");return this.safeOrder({info:e,id:r,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,symbol:i,type:u,timeInForce:l,side:p,price:o,stopPrice:void 0,triggerPrice:void 0,amount:n,cost:void 0,average:void 0,filled:h,remaining:void 0,status:c,fee:void 0,trades:m},t)}parseOrderStatus(e){return this.safeString({NEW:"open",CREATED:"open",MODIFIED:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"},e,e)}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit",STOP:"stop"},e,e)}parseOrderTimeInForce(e){return this.safeString({GTC:"GTC",FOK:"FOK",IOC:"IOC"},e,e)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell"},e,e)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);let d;if(n.margin&&(d=this.safeString(this.options,"accountId"),d=this.safeString(o,"accountId",d),void 0===d))throw new r.ArgumentsRequired(this.id+" createOrder() requires an accountId parameter or an exchange.options['accountId'] option for "+n.type+" markets");const h=this.safeValue(this.options.newOrderRespType,t,"RESULT"),c={symbol:n.id,quantity:this.amountToPrecision(e,i),type:t.toUpperCase(),side:s.toUpperCase(),newOrderRespType:h};if("limit"===t)c.price=this.priceToPrecision(e,a),c.timeInForce=this.options.defaultTimeInForce;else if("stop"===t)c.type="STOP",c.price=this.priceToPrecision(e,a);else if("market"===t){const t=this.safeValue2(o,"triggerPrice","stopPrice");o=this.omit(o,["triggerPrice","stopPrice"]),void 0!==t&&(c.type="STOP",c.price=this.priceToPrecision(e,t))}const l=await this.privatePostV2Order(this.extend(c,o));return this.parseOrder(l,n)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i={orderId:e,symbol:this.market(t).id},a=await this.privateGetV2FetchOrder(this.extend(i,s));return this.parseOrder(a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();const o={};if(void 0!==e)a=this.market(e),o.symbol=a.id;else if(this.options.warnOnFetchOpenOrdersWithoutSymbol){const e=this.symbols.length,t=this.parseToInt(e/2);throw new r.ExchangeError(this.id+" fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "+t.toString()+" seconds. Do not call this method frequently to avoid ban. Set "+this.id+'.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.')}const n=await this.privateGetV2OpenOrders(this.extend(o,i));return this.parseOrders(n,a,t,s,i)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeValue(s,"origClientOrderId"),o={symbol:i.id};void 0===a?o.orderId=e:o.origClientOrderId=a;const n=await this.privateDeleteV2Order(this.extend(o,s));return this.parseOrder(n,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==s&&(o.limit=s);const n=await this.privateGetV2MyTrades(this.extend(o,i));return this.parseTrades(n,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Deposits",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Withdrawals",e,t,s,i)}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByMethod("privateGetV2Transactions",e,t,s,i)}async fetchTransactionsByMethod(e,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();const o={};let n,d;if(void 0!==t&&(n=this.currency(t)),void 0!==s&&(o.startTime=s),void 0!==i&&(o.limit=i),"privateGetV2Deposits"===e)d=await this.privateGetV2Deposits(this.extend(o,a));else if("privateGetV2Withdrawals"===e)d=await this.privateGetV2Withdrawals(this.extend(o,a));else{if("privateGetV2Transactions"!==e)throw new r.NotSupported(this.id+" fetchTransactionsByMethod() not support this method");d=await this.privateGetV2Transactions(this.extend(o,a))}return this.parseTransactions(d,n,s,i,a)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i,t),a=this.safeString(e,"commission"),o={currency:void 0,cost:void 0,rate:void 0};return void 0!==a&&(o.currency=r,o.cost=a),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"blockchainTransactionHash"),type:this.parseTransactionType(this.safeString(e,"type")),currency:r,network:void 0,amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatus(this.safeString(e,"state")),timestamp:s,datetime:this.iso8601(s),address:void 0,addressFrom:void 0,addressTo:void 0,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:void 0,internal:void 0,comment:void 0,fee:o}}parseTransactionStatus(e){return this.safeString({APPROVAL:"pending",PROCESSED:"ok"},e,e)}parseTransactionType(e){return this.safeString({deposit:"deposit",withdrawal:"withdrawal"},e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e)),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=await this.privateGetV2Ledger(this.extend(r,i));return this.parseLedger(o,a,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),r=a.Y.stringAbs(i),o=this.safeInteger(e,"timestamp"),n=this.safeString(e,"currency"),d=this.safeCurrencyCode(n,t),h=this.safeString(e,"commission");let c;void 0!==h&&(c={currency:d,cost:h});const l=a.Y.stringLt(i,"0")?"out":"in";return{id:s,timestamp:o,datetime:this.iso8601(o),direction:l,account:void 0,referenceId:this.safeString(e,"blockchainTransactionHash"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:d,amount:r,before:void 0,after:this.safeString(e,"balance"),status:this.parseLedgerEntryStatus(this.safeString(e,"status")),fee:c,info:e}}parseLedgerEntryStatus(e){return this.safeString({APPROVAL:"pending",PROCESSED:"ok",CANCELLED:"canceled"},e,e)}parseLedgerEntryType(e){return this.safeString({deposit:"transaction",withdrawal:"transaction",exchange_commission:"fee"},e,e)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateGetV2LeverageSettings(this.extend(i,t));return this.parseLeverage(r,s)}parseLeverage(e,t=void 0){const s=this.safeInteger(e,"value");return{info:e,symbol:t.symbol,marginMode:void 0,longLeverage:s,shortLeverage:s}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},r=await this.privateGetV2DepositAddress(this.extend(i,t));return this.parseDepositAddress(r,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:(t=this.safeCurrency(void 0,t)).code,address:s,tag:void 0,network:void 0,info:e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/"+e;if("historicalTrades"===e&&(r={"X-MBX-APIKEY":this.apiKey}),"private"===t){this.checkRequiredCredentials();let e=this.urlencode(this.extend({timestamp:this.nonce(),recvWindow:this.options.recvWindow},i));e+="&signature="+this.hmac(this.encode(e),this.encode(this.secret),n.s),r={"X-MBX-APIKEY":this.apiKey},"GET"===s||"DELETE"===s?o+="?"+e:(a=e,r["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(o+="?"+this.urlencode(i));return o=this.implodeHostname(o),{url:o,method:s,body:a,headers:r}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetV2TradingPositions(t),i=this.safeList(s,"positions",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=(t=this.safeMarket(this.safeString(e,"symbol"),t)).symbol,i=this.safeInteger(e,"createdTimestamp"),r=this.safeString(e,"openQuantity"),o=a.Y.stringGt(r,"0")?"long":"short",n=a.Y.stringAbs(r),d=this.safeNumber(e,"openPrice"),h=this.safeNumber(e,"upl"),c=this.safeString(e,"margin"),l=a.Y.stringDiv("1",c);return this.safePosition({info:e,symbol:s,timestamp:i,datetime:this.iso8601(i),lastUpdateTimestamp:void 0,contracts:this.parseNumber(n),contractSize:void 0,entryPrice:d,collateral:void 0,side:o,unrealizedProfit:h,leverage:l,percentage:void 0,marginMode:void 0,notional:void 0,markPrice:void 0,lastPrice:void 0,liquidationPrice:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:this.parseNumber(c),maintenanceMarginPercentage:void 0,marginRatio:void 0,id:void 0,unrealizedPnl:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}handleErrors(e,t,s,i,a,o,n,d,h){if(418===e||429===e)throw new r.DDoSProtection(this.id+" "+e.toString()+" "+t+" "+o);if(e>=400){if(o.indexOf("Price * QTY is zero or less")>=0)throw new r.InvalidOrder(this.id+" order cost = amount * price is zero or less "+o);if(o.indexOf("LOT_SIZE")>=0)throw new r.InvalidOrder(this.id+" order amount should be evenly divisible by lot size "+o);if(o.indexOf("PRICE_FILTER")>=0)throw new r.InvalidOrder(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "+o)}if(void 0===n)return;const c=this.safeString(n,"code");if(void 0!==c&&"0"!==c){const e=this.id+" "+this.json(n);this.throwExactlyMatchedException(this.exceptions.exact,c,e);const t=this.safeString(n,"msg");throw this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new r.ExchangeError(e)}}}},1080:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7227),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"delta",name:"Delta Exchange",countries:["VC"],rateLimit:300,version:"v2",has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!0,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchGreeks:!0,fetchIndexOHLCV:!0,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginMode:!0,fetchMarginModes:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMySettlementHistory:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!1,fetchOrderBook:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransfer:void 0,fetchTransfers:void 0,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!1,fetchWithdrawal:void 0,fetchWithdrawals:void 0,reduceMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","1d":"1d","7d":"7d","1w":"1w","2w":"2w","1M":"30d"},urls:{logo:"https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg",test:{public:"https://testnet-api.delta.exchange",private:"https://testnet-api.delta.exchange"},api:{public:"https://api.delta.exchange",private:"https://api.delta.exchange"},www:"https://www.delta.exchange",doc:["https://docs.delta.exchange"],fees:"https://www.delta.exchange/fees",referral:"https://www.delta.exchange/app/signup/?code=IULYNB"},api:{public:{get:["assets","indices","products","products/{symbol}","tickers","tickers/{symbol}","l2orderbook/{symbol}","trades/{symbol}","stats","history/candles","history/sparklines","settings"]},private:{get:["orders","products/{product_id}/orders/leverage","positions/margined","positions","orders/history","fills","fills/history/download/csv","wallet/balances","wallet/transactions","wallet/transactions/download","wallets/sub_accounts_transfer_history","users/trading_preferences","sub_accounts","profile","deposits/address","orders/leverage"],post:["orders","orders/bracket","orders/batch","products/{product_id}/orders/leverage","positions/change_margin","positions/close_all","wallets/sub_account_balance_transfer","orders/cancel_after","orders/leverage"],put:["orders","orders/bracket","orders/batch","positions/auto_topup","users/update_mmp","users/reset_mmp"],delete:["orders","orders/all","orders/batch"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100"),this.parseNumber("0.0013")],[this.parseNumber("250"),this.parseNumber("0.0013")],[this.parseNumber("1000"),this.parseNumber("0.001")],[this.parseNumber("5000"),this.parseNumber("0.0009")],[this.parseNumber("10000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("100"),this.parseNumber("0.001")],[this.parseNumber("250"),this.parseNumber("0.0009")],[this.parseNumber("1000"),this.parseNumber("0.00075")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0005")]]}}},options:{networks:{TRC20:"TRC20(TRON)",BEP20:"BEP20(BSC)"}},precisionMode:a.kb,requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{insufficient_margin:r.InsufficientFunds,order_size_exceed_available:r.InvalidOrder,risk_limits_breached:r.BadRequest,invalid_contract:r.BadSymbol,immediate_liquidation:r.InvalidOrder,out_of_bankruptcy:r.InvalidOrder,self_matching_disrupted_post_only:r.InvalidOrder,immediate_execution_post_only:r.InvalidOrder,bad_schema:r.BadRequest,invalid_api_key:r.AuthenticationError,invalid_signature:r.AuthenticationError,open_order_not_found:r.OrderNotFound,unavailable:r.ExchangeNotAvailable},broad:{}}})}createExpiredOptionMarket(e){const t="USDT",s=e.split("-"),i=e.split("/");let r,a,o;e.indexOf("/")>-1?(r=this.safeString(i,0),a=this.safeString(s,1),o=this.safeString(s,3)):(r=this.safeString(s,1),a=this.safeString(s,3),o=this.safeString(s,0));const n=t,d=this.safeString(s,2),h=this.convertExpireDate(a),c=this.parse8601(h);return{id:o+"-"+r+"-"+d+"-"+a,symbol:r+"/"+t+":"+n+"-"+a+"-"+d+"-"+o,base:r,quote:t,settle:n,baseId:r,quoteId:t,settleId:n,active:!1,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:this.parseNumber("1"),expiry:c,expiryDatetime:h,optionType:"C"===o?"call":"put",strike:this.parseNumber(d),precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.endsWith("-C")||e.endsWith("-P")||e.startsWith("C-")||e.startsWith("P-"))&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}async fetchTime(e={}){const t=await this.publicGetSettings(e),s=this.safeDict(t,"result",{});return this.safeIntegerProduct(s,"server_time",.001)}async fetchStatus(e={}){const t=await this.publicGetSettings(e),s=this.safeDict(t,"result",{});return{status:"true"===this.safeString(s,"under_maintenance")?"maintenance":"ok",updated:this.safeIntegerProduct(s,"server_time",.001,this.milliseconds()),eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeList(t,"result",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeInteger(t,"id"),o=this.safeCurrencyCode(r),n="enabled"===this.safeString(t,"deposit_status"),d="enabled"===this.safeString(t,"withdrawal_status"),h=n&&d;i[o]={id:r,numericId:a,code:o,name:this.safeString(t,"name"),info:t,active:h,deposit:n,withdraw:d,fee:this.safeNumber(t,"base_withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(t,"precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(t,"min_withdrawal_amount"),max:void 0}},networks:{}}}return i}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);(void 0===this.safeDict(this.options,"currenciesByNumericId")||e)&&(this.options.currenciesByNumericId=this.indexByStringifiedNumericId(this.currencies));return(void 0===this.safeDict(this.options,"marketsByNumericId")||e)&&(this.options.marketsByNumericId=this.indexByStringifiedNumericId(this.markets)),s}indexByStringifiedNumericId(e){const t={};if(void 0===e)return;const s=Object.keys(e);for(let i=0;i<s.length;i++){const r=e[s[i]],a=this.safeString(r,"numericId");void 0!==a&&(t[a]=r)}return t}async fetchMarkets(e={}){const t=await this.publicGetProducts(e),s=this.safeList(t,"result",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e];let r=this.safeString(t,"contract_type");if("options_combos"===r)continue;const a=this.safeDict(t,"quoting_asset",{}),o=this.safeDict(t,"underlying_asset",{}),n=this.safeDict(t,"settling_asset"),d=this.safeDict(t,"product_specs",{}),h=this.safeString(o,"symbol"),c=this.safeString(a,"symbol"),l=this.safeString(n,"symbol"),u=this.safeString(t,"symbol"),p=this.safeInteger(t,"id"),f=this.safeCurrencyCode(h),m=this.safeCurrencyCode(c),g=this.safeCurrencyCode(l),v="put_options"===r,y="move_options"===r,w="spot"===r,b="perpetual_futures"===r,S="futures"===r,k="call_options"===r||v||y,O=this.safeString(t,"strike_price"),T=this.safeString(t,"settlement_time"),P=this.parse8601(T),I=this.safeNumber(t,"contract_value");let x;x=w?this.parseNumber(this.parsePrecision(this.safeString(d,"underlying_precision"))):this.parseNumber("1");const A=g===f;let M,C=f+"/"+m;if(b||S||k)if(C=C+":"+g,S||k)if(C=C+"-"+this.yymmdd(P),k){r="option";let e="C";M="call",v?(e="P",M="put"):y&&(e="M",M="move"),C=C+"-"+O+"-"+e}else r="future";else r="swap";const E=this.safeString(t,"state");i.push({id:u,numericId:p,symbol:C,base:f,quote:m,settle:g,baseId:h,quoteId:c,settleId:l,type:r,spot:w,margin:!!w&&void 0,swap:b,future:S,option:k,active:"live"===E,contract:!w,linear:w?void 0:A,inverse:w?void 0:!A,taker:this.safeNumber(t,"taker_commission_rate"),maker:this.safeNumber(t,"maker_commission_rate"),contractSize:I,expiry:P,expiryDatetime:T,strike:this.parseNumber(O),optionType:M,precision:{amount:x,price:this.safeNumber(t,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber("1"),max:this.safeNumber(t,"position_size_limit")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"min_size"),max:void 0}},created:this.parse8601(this.safeString(t,"launch_time")),info:t})}return i}parseTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeString(e,"close"),o=this.safeDict(e,"quotes",{});return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeNumber(e,"high"),low:this.safeNumber(e,"low"),bid:this.safeNumber(o,"best_bid"),bidVolume:this.safeNumber(o,"bid_size"),ask:this.safeNumber(o,"best_ask"),askVolume:this.safeNumber(o,"ask_size"),vwap:void 0,open:this.safeString(e,"open"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeNumber(e,"volume"),quoteVolume:this.safeNumber(e,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTickersSymbol(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.safeList(s,"result",[]),r={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);r[t.symbol]=t}return this.filterByArrayTickers(r,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetL2orderbookSymbol(this.extend(r,s)),o=this.safeDict(a,"result",{});return this.parseOrderBook(o,i.symbol,void 0,"buy","sell","price","size")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"order_id");let r=this.parse8601(this.safeString(e,"created_at"));r=this.safeIntegerProduct(e,"timestamp",.001,r);const a=this.safeString(e,"price"),o=this.safeString(e,"size"),n=this.safeDict(e,"product",{}),d=this.safeString(n,"symbol"),h=this.safeSymbol(d,t),c=this.safeString(e,"seller_role");let l=this.safeString(e,"side");void 0===l&&("taker"===c?l="sell":"maker"===c&&(l="buy"));const u=this.safeString(e,"role"),p=this.safeDict(e,"meta_data",{});let f=this.safeString(p,"order_type");void 0!==f&&(f=f.replace("_order",""));const m=this.safeString(e,"commission");let g;if(void 0!==m){const e=this.safeDict(n,"settling_asset",{}),t=this.safeString(e,"symbol");g={cost:m,currency:this.safeCurrencyCode(t)}}return this.safeTrade({id:s,order:i,timestamp:r,datetime:this.iso8601(r),symbol:h,type:f,side:l,price:a,amount:o,cost:void 0,takerOrMaker:u,fee:g,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetTradesSymbol(this.extend(a,i)),n=this.safeList(o,"result",[]);return this.parseTrades(n,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={resolution:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t);if(i=i||2e3,void 0===s){const e=this.seconds();o.end=e,o.start=e-i*n}else{const e=this.parseToInt(s/1e3);o.start=e,o.end=this.sum(e,i*n)}const d=this.safeString(r,"price");o.symbol="mark"===d?"MARK:"+a.id:"index"===d?a.info.spot_index.symbol:a.id,r=this.omit(r,"price");const h=await this.publicGetHistoryCandles(this.extend(o,r)),c=this.safeList(h,"result",[]);return this.parseOHLCVs(c,a,t,s,i)}parseBalance(e){const t=this.safeList(e,"result",[]),s={info:e},i=this.safeDict(this.options,"currenciesByNumericId",{});for(let e=0;e<t.length;e++){const r=t[e],a=this.safeString(r,"asset_id"),o=this.safeDict(i,a),n=void 0===o?a:o.code,d=this.account();d.total=this.safeString(r,"balance"),d.free=this.safeString(r,"available_balance"),s[n]=d}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetWalletBalances(e);return this.parseBalance(t)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_id:s.numericId},r=await this.privateGetPositions(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositionsMargined(t),i=this.safeList(s,"result",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"product_symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeIntegerProduct(e,"timestamp",.001),a=this.safeString(e,"size");let n;return void 0!==a&&(o.Y.stringGt(a,"0")?n="buy":o.Y.stringLt(a,"0")&&(n="sell")),this.safePosition({info:e,id:void 0,symbol:i,notional:void 0,marginMode:void 0,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber(e,"entry_price"),unrealizedPnl:void 0,percentage:void 0,contracts:this.parseNumber(a),contractSize:this.safeNumber(t,"contractSize"),markPrice:void 0,side:n,hedged:void 0,timestamp:r,datetime:this.iso8601(r),maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}parseOrderStatus(e){return this.safeString({open:"open",pending:"open",closed:"closed",cancelled:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"client_order_id"),r=this.parse8601(this.safeString(e,"created_at")),a=this.safeString(e,"product_id"),o=this.safeDict(this.options,"marketsByNumericId",{}),n=void 0===(t=this.safeValue(o,a,t))?a:t.symbol,d=this.parseOrderStatus(this.safeString(e,"state")),h=this.safeString(e,"side");let c=this.safeString(e,"order_type");c=c.replace("_order","");const l=this.safeString(e,"limit_price"),u=this.safeString(e,"size"),p=this.safeString(e,"unfilled_size"),f=this.safeString(e,"average_fill_price");let m;const g=this.safeString(e,"paid_commission");if(void 0!==g){let e;if(void 0!==t){const s=this.safeDict(t.info,"settling_asset",{}),i=this.safeString(s,"symbol");e=this.safeCurrencyCode(i)}m={cost:g,currency:e}}return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:n,type:c,side:h,price:l,amount:u,cost:void 0,average:f,filled:void 0,remaining:p,status:d,fee:m,trades:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=t+"_order",n=this.market(e),d={product_id:n.numericId,size:this.amountToPrecision(n.symbol,i),side:s,order_type:o};"limit"===t&&(d.limit_price=this.priceToPrecision(n.symbol,r));const h=this.safeString2(a,"clientOrderId","client_order_id");a=this.omit(a,["clientOrderId","client_order_id"]),void 0!==h&&(d.client_order_id=h);const c=this.safeBool(a,"reduceOnly");c&&(d.reduce_only=c,a=this.omit(a,"reduceOnly"));const l=await this.privatePostOrders(this.extend(d,a)),u=this.safeDict(l,"result",{});return this.parseOrder(u,n)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={id:parseInt(e),product_id:n.numericId};void 0!==r&&(d.size=parseInt(this.amountToPrecision(t,r))),void 0!==a&&(d.limit_price=this.priceToPrecision(t,a));const h=await this.privatePutOrders(this.extend(d,o)),c=this.safeDict(h,"result");return this.parseOrder(c,n)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={id:parseInt(e),product_id:i.numericId},o=await this.privateDeleteOrders(this.extend(a,s)),n=this.safeDict(o,"result");return this.parseOrder(n,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={product_id:this.market(e).numericId},i=this.privateDeleteOrdersAll(this.extend(s,t));return[this.safeOrder({info:i})]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrders",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersWithMethod("privateGetOrdersHistory",e,t,s,i)}async fetchOrdersWithMethod(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o,n;void 0!==t&&(o=this.market(t),a.product_ids=o.numericId),void 0!==s&&(a.start_time=s.toString()+"000"),void 0!==i&&(a.page_size=i),"privateGetOrders"===e?n=await this.privateGetOrders(this.extend(a,r)):"privateGetOrdersHistory"===e&&(n=await this.privateGetOrdersHistory(this.extend(a,r)));const d=this.safeList(n,"result",[]);return this.parseOrders(d,o,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.product_ids=a.numericId),void 0!==t&&(r.start_time=t.toString()+"000"),void 0!==s&&(r.page_size=s);const o=await this.privateGetFills(this.extend(r,i)),n=this.safeList(o,"result",[]);return this.parseTrades(n,a,t,s)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset_id=a.numericId),void 0!==s&&(r.page_size=s);const o=await this.privateGetWalletTransactions(this.extend(r,i)),n=this.safeList(o,"result",[]);return this.parseLedger(n,a,t,s)}parseLedgerEntryType(e){return this.safeString({pnl:"pnl",deposit:"transaction",withdrawal:"transaction",commission:"fee",conversion:"trade",referral_bonus:"referral",commission_rebate:"rebate"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"uuid");let i;const r=this.safeDict(e,"meta_data",{}),a=this.safeString(r,"transaction_id");let n=this.safeString(e,"transaction_type");"deposit"===n||"commission_rebate"===n||"referral_bonus"===n||"pnl"===n||"withdrawal_cancellation"===n||"promo_credit"===n?i="in":"withdrawal"!==n&&"commission"!==n&&"conversion"!==n&&"perpetual_futures_funding"!==n||(i="out"),n=this.parseLedgerEntryType(n);const d=this.safeString(e,"asset_id"),h=this.safeDict(this.options,"currenciesByNumericId"),c=void 0===(t=this.safeValue(h,d,t))?void 0:t.code,l=this.safeString(e,"amount"),u=this.parse8601(this.safeString(e,"created_at")),p=this.safeString(e,"balance"),f=o.Y.stringMax("0",o.Y.stringSub(p,l));return{info:e,id:s,direction:i,account:undefined,referenceId:a,referenceAccount:undefined,type:n,currency:c,amount:this.parseNumber(l),before:this.parseNumber(f),after:this.parseNumber(p),status:"ok",timestamp:u,datetime:this.iso8601(u),fee:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={asset_symbol:s.id},r=this.safeStringUpper(t,"network");void 0!==r&&(i.network=this.networkCodeToId(r,e),t=this.omit(t,"network"));const a=await this.privateGetDepositsAddress(this.extend(i,t)),o=this.safeDict(a,"result",{});return this.parseDepositAddress(o,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"asset_symbol"),r=this.safeString(e,"network");return this.checkAddress(s),{currency:this.safeCurrencyCode(i,t),address:s,tag:this.safeString(e,"memo"),network:this.networkIdToCode(r),info:e}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},a=await this.publicGetTickersSymbol(this.extend(i,t)),o=this.safeDict(a,"result",{});return this.parseFundingRate(o,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(this.extend({contract_types:"perpetual_futures"},t)),i=this.safeList(s,"result",[]),r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),r=this.safeString(e,"funding_rate"),a=o.Y.stringDiv(r,"100");return{info:e,symbol:this.safeSymbol(i,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"spot_price"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:this.iso8601(s),fundingRate:this.parseNumber(a),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e);t=t.toString(),"reduce"===s&&(t=o.Y.stringMul(t,"-1"));const a={product_id:r.numericId,delta_margin:t},n=await this.privatePostPositionsChangeMargin(this.extend(a,i)),d=this.safeDict(n,"result",{});return this.parseMarginModification(d,r)}parseMarginModification(e,t=void 0){const s=this.safeString(e,"product_symbol");return{info:e,symbol:(t=this.safeMarket(s,t)).symbol,type:void 0,marginMode:"isolated",amount:void 0,total:this.safeNumber(e,"margin"),code:void 0,status:void 0,timestamp:void 0,datetime:void 0}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i={symbol:s.id},a=await this.publicGetTickersSymbol(this.extend(i,t)),o=this.safeDict(a,"result",{});return this.parseOpenInterest(o,s)}parseOpenInterest(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol");return this.safeOpenInterest({symbol:this.safeSymbol(i,t),baseVolume:this.safeNumber(e,"oi_value"),quoteVolume:this.safeNumber(e,"oi_value_usd"),openInterestAmount:this.safeNumber(e,"oi_contracts"),openInterestValue:this.safeNumber(e,"oi"),timestamp:s,datetime:this.iso8601(s),info:e},t)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={product_id:s.numericId},r=await this.privateGetProductsProductIdOrdersLeverage(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"index_symbol"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"margin_mode"),longLeverage:i,shortLeverage:i}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i={product_id:this.market(t).numericId,leverage:e};return await this.privatePostProductsProductIdOrdersLeverage(this.extend(i,s))}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={states:"expired"};void 0!==s&&(a.page_size=s);const o=await this.publicGetProducts(this.extend(a,i)),n=this.safeList(o,"result",[]),d=this.parseSettlements(n,r),h=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(h,r.symbol,t,s)}parseSettlement(e,t){const s=this.safeString(e,"settlement_time"),i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settlement_price"),timestamp:this.parse8601(s),datetime:s}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++)s.push(this.parseSettlement(e[i],t));return s}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTickersSymbol(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseGreeks(a,s)}parseGreeks(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",.001),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeDict(e,"greeks",{}),o=this.safeDict(e,"quotes",{});return{symbol:r,timestamp:s,datetime:this.iso8601(s),delta:this.safeNumber(a,"delta"),gamma:this.safeNumber(a,"gamma"),theta:this.safeNumber(a,"theta"),vega:this.safeNumber(a,"vega"),rho:this.safeNumber(a,"rho"),bidSize:this.safeNumber(o,"bid_size"),askSize:this.safeNumber(o,"ask_size"),bidImpliedVolatility:this.safeNumber(o,"bid_iv"),askImpliedVolatility:this.safeNumber(o,"ask_iv"),markImpliedVolatility:this.safeNumber(o,"mark_iv"),bidPrice:this.safeNumber(o,"best_bid"),askPrice:this.safeNumber(o,"best_ask"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,underlyingPrice:this.safeNumber(e,"spot_price"),info:e}}async closeAllPositions(e={}){await this.loadMarkets();const t=await this.privatePostPositionsCloseAll(this.extend({close_all_portfolio:!0,close_all_isolated:!0},e));return[this.parsePosition(this.safeDict(t,"result",{}))]}async fetchMarginMode(e,t={}){let s;await this.loadMarkets(),void 0!==e&&(s=this.market(e));const i=await this.privateGetProfile(t),r=this.safeDict(i,"result",{});return this.parseMarginMode(r,s)}parseMarginMode(e,t=void 0){let s;return void 0!==t&&(s=t.symbol),{info:e,symbol:s,marginMode:this.safeString(e,"margin_mode")}}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTickersSymbol(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseOption(a,void 0,s)}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"symbol");s=this.safeMarket(i,s);const r=this.safeDict(e,"quotes",{}),a=this.safeIntegerProduct(e,"timestamp",.001);return{info:e,currency:void 0,symbol:s.symbol,timestamp:a,datetime:this.iso8601(a),impliedVolatility:this.safeNumber(r,"mark_iv"),openInterest:this.safeNumber(e,"oi"),bidPrice:this.safeNumber(r,"best_bid"),askPrice:this.safeNumber(r,"best_ask"),midPrice:this.safeNumber(r,"impact_mid_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,underlyingPrice:this.safeNumber(e,"spot_price"),change:void 0,percentage:void 0,baseVolume:this.safeNumber(e,"volume"),quoteVolume:void 0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o="/"+this.version+"/"+this.implodeParams(e,i);let d=this.urls.api[t]+o;const h=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(h).length&&(d+="?"+this.urlencode(h));else if("private"===t){this.checkRequiredCredentials();const e=this.seconds().toString();r={"api-key":this.apiKey,timestamp:e};let t=s+e+o;if("GET"===s||"DELETE"===s){if(Object.keys(h).length){const e="?"+this.urlencode(h);t+=e,d+=e}}else t+=a=this.json(h),r["Content-Type"]="application/json";const i=this.hmac(this.encode(t),this.encode(this.secret),n.s);r.signature=i}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeDict(n,"error",{}),l=this.safeString(c,"code");if(void 0!==l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,l,e),new r.ExchangeError(e)}}}},2591:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(4012),r=s(1579),a=s(2079),o=s(5147),n=s(4852),d=s(8995);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"deribit",name:"Deribit",countries:["NL"],version:"v2",userAgent:void 0,rateLimit:50,pro:!0,has:{CORS:!0,spot:!1,margin:!1,swap:!0,future:!0,option:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!0,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTrailingAmountOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFees:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchGreeks:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverageTiers:!1,fetchLiquidations:!0,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyLiquidations:!0,fetchMySettlementHistory:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!0,fetchUnderlyingAssets:!1,fetchVolatilityHistory:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,sandbox:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1","3m":"3","5m":"5","10m":"10","15m":"15","30m":"30","1h":"60","2h":"120","3h":"180","6h":"360","12h":"720","1d":"1D"},urls:{test:{rest:"https://test.deribit.com"},logo:"https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg",api:{rest:"https://www.deribit.com"},www:"https://www.deribit.com",doc:["https://docs.deribit.com/v2","https://github.com/deribit"],fees:"https://www.deribit.com/pages/information/fees",referral:{url:"https://www.deribit.com/reg-1189.4038",discount:.1}},api:{public:{get:{auth:1,exchange_token:1,fork_token:1,set_heartbeat:1,disable_heartbeat:1,get_time:1,hello:1,status:1,test:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,get_announcements:1,get_book_summary_by_currency:1,get_book_summary_by_instrument:1,get_contract_size:1,get_currencies:1,get_delivery_prices:1,get_funding_chart_data:1,get_funding_rate_history:1,get_funding_rate_value:1,get_historical_volatility:1,get_index:1,get_index_price:1,get_index_price_names:1,get_instrument:1,get_instruments:1,get_last_settlements_by_currency:1,get_last_settlements_by_instrument:1,get_last_trades_by_currency:1,get_last_trades_by_currency_and_time:1,get_last_trades_by_instrument:1,get_last_trades_by_instrument_and_time:1,get_mark_price_history:1,get_order_book:1,get_trade_volumes:1,get_tradingview_chart_data:1,get_volatility_index_data:1,ticker:1}},private:{get:{logout:1,enable_cancel_on_disconnect:1,disable_cancel_on_disconnect:1,get_cancel_on_disconnect:1,subscribe:1,unsubscribe:1,unsubscribe_all:1,change_api_key_name:1,change_scope_in_api_key:1,change_subaccount_name:1,create_api_key:1,create_subaccount:1,disable_api_key:1,disable_tfa_for_subaccount:1,enable_affiliate_program:1,enable_api_key:1,get_access_log:1,get_account_summary:1,get_affiliate_program_info:1,get_email_language:1,get_new_announcements:1,get_portfolio_margins:1,get_position:1,get_positions:1,get_subaccounts:1,get_subaccounts_details:1,get_transaction_log:1,list_api_keys:1,remove_api_key:1,remove_subaccount:1,reset_api_key:1,set_announcement_as_read:1,set_api_key_as_default:1,set_email_for_subaccount:1,set_email_language:1,set_password_for_subaccount:1,toggle_notifications_from_subaccount:1,toggle_subaccount_login:1,execute_block_trade:4,get_block_trade:1,get_last_block_trades_by_currency:1,invalidate_block_trade_signature:1,verify_block_trade:4,buy:4,sell:4,edit:4,edit_by_label:4,cancel:4,cancel_all:4,cancel_all_by_currency:4,cancel_all_by_instrument:4,cancel_by_label:4,close_position:4,get_margins:1,get_mmp_config:1,get_open_orders_by_currency:1,get_open_orders_by_instrument:1,get_order_history_by_currency:1,get_order_history_by_instrument:1,get_order_margin_by_ids:1,get_order_state:1,get_stop_order_history:1,get_trigger_order_history:1,get_user_trades_by_currency:1,get_user_trades_by_currency_and_time:1,get_user_trades_by_instrument:1,get_user_trades_by_instrument_and_time:1,get_user_trades_by_order:1,reset_mmp:1,set_mmp_config:1,get_settlement_history_by_instrument:1,get_settlement_history_by_currency:1,cancel_transfer_by_id:1,cancel_withdrawal:1,create_deposit_address:1,get_current_deposit_address:1,get_deposits:1,get_transfers:1,get_withdrawals:1,submit_transfer_to_subaccount:1,submit_transfer_to_user:1,withdraw:1}}},exceptions:{9999:a.PermissionDenied,1e4:a.AuthenticationError,10001:a.ExchangeError,10002:a.InvalidOrder,10003:a.InvalidOrder,10004:a.OrderNotFound,10005:a.InvalidOrder,10006:a.InvalidOrder,10007:a.InvalidOrder,10008:a.InvalidOrder,10009:a.InsufficientFunds,10010:a.OrderNotFound,10011:a.InvalidOrder,10012:a.InvalidOrder,10013:a.PermissionDenied,10014:a.PermissionDenied,10015:a.PermissionDenied,10016:a.PermissionDenied,10017:a.PermissionDenied,10018:a.PermissionDenied,10019:a.PermissionDenied,10020:a.ExchangeError,10021:a.InvalidOrder,10022:a.InvalidOrder,10023:a.InvalidOrder,10024:a.InvalidOrder,10025:a.InvalidOrder,10026:a.InvalidOrder,10027:a.InvalidOrder,10028:a.DDoSProtection,10029:a.OrderNotFound,10030:a.ExchangeError,10031:a.ExchangeError,10032:a.InvalidOrder,10033:a.NotSupported,10034:a.InvalidOrder,10035:a.InvalidOrder,10036:a.InvalidOrder,10040:a.ExchangeNotAvailable,10041:a.OnMaintenance,10043:a.InvalidOrder,10044:a.InvalidOrder,10045:a.InvalidOrder,10046:a.InvalidOrder,10047:a.DDoSProtection,10048:a.ExchangeError,11008:a.InvalidOrder,11029:a.BadRequest,11030:a.ExchangeError,11031:a.ExchangeError,11035:a.DDoSProtection,11036:a.InvalidOrder,11037:a.BadRequest,11038:a.InvalidOrder,11039:a.InvalidOrder,11041:a.InvalidOrder,11042:a.PermissionDenied,11043:a.BadRequest,11044:a.InvalidOrder,11045:a.BadRequest,11046:a.BadRequest,11047:a.BadRequest,11048:a.ExchangeError,11049:a.BadRequest,11050:a.BadRequest,11051:a.OnMaintenance,11052:a.ExchangeError,11053:a.ExchangeError,11090:a.InvalidAddress,11091:a.InvalidAddress,11092:a.InvalidAddress,11093:a.DDoSProtection,11094:a.ExchangeError,11095:a.ExchangeError,11096:a.ExchangeError,12e3:a.AuthenticationError,12001:a.DDoSProtection,12002:a.ExchangeError,12998:a.AuthenticationError,12003:a.AuthenticationError,12004:a.AuthenticationError,12005:a.AuthenticationError,12100:a.ExchangeError,12999:a.AuthenticationError,13e3:a.AuthenticationError,13001:a.AuthenticationError,13002:a.PermissionDenied,13003:a.AuthenticationError,13004:a.AuthenticationError,13005:a.AuthenticationError,13006:a.AuthenticationError,13007:a.AuthenticationError,13008:a.ExchangeError,13009:a.AuthenticationError,13010:a.BadRequest,13011:a.BadRequest,13012:a.PermissionDenied,13013:a.BadRequest,13014:a.BadRequest,13015:a.BadRequest,13016:a.BadRequest,13017:a.ExchangeError,13018:a.ExchangeError,13019:a.ExchangeError,13020:a.ExchangeError,13021:a.PermissionDenied,13025:a.ExchangeError,"-32602":a.BadRequest,"-32601":a.BadRequest,"-32700":a.BadRequest,"-32000":a.BadRequest,11054:a.InvalidOrder},precisionMode:r.kb,options:{code:"BTC",fetchBalance:{code:"BTC"},fetchPositions:{code:"BTC"},transfer:{method:"privateGetSubmitTransferToSubaccount"}}})}createExpiredOptionMarket(e){let t,s="USD";const i=e.split("-"),r=e.split("/");let a,o;e.indexOf("/")>-1?(a=this.safeString(r,0),o=this.safeString(i,1),e.indexOf("USDC")>-1&&(a+="_USDC")):(a=this.safeString(i,0),o=this.convertMarketIdExpireDate(this.safeString(i,1))),e.indexOf("USDC")>-1?(s="USDC",t="USDC"):t=a;let n=a;if(a.indexOf("_")>-1){const e=a.split("_");n=this.safeString(e,0)}const d=this.safeString(i,2),h=this.safeString(i,3),c=this.convertExpireDate(o),l=this.parse8601(c);return{id:a+"-"+this.convertExpireDateToMarketIdDate(o)+"-"+d+"-"+h,symbol:n+"/"+s+":"+t+"-"+o+"-"+d+"-"+h,base:a,quote:s,settle:t,baseId:a,quoteId:s,settleId:t,active:!1,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:void 0,expiry:l,expiryDatetime:c,optionType:"C"===h?"call":"put",strike:this.parseNumber(d),precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.endsWith("-C")||e.endsWith("-P"))&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}async fetchTime(e={}){const t=await this.publicGetGetTime(e);return this.safeInteger(t,"result")}async fetchCurrencies(e={}){const t=await this.publicGetGetCurrencies(e),s=this.safeValue(t,"result",{}),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(t,"currency_long");i[a]={info:t,code:a,id:r,name:o,active:void 0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(t,"withdrawal_fee"),precision:this.parseNumber(this.parsePrecision(this.safeString(t,"fee_precision"))),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},networks:void 0}}return i}codeFromOptions(e,t={}){const s=this.safeValue(this.options,"code","BTC"),i=this.safeValue(this.options,e,{}),r=this.safeValue(i,"code",s);return this.safeValue(t,"code",r)}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeValue(t,"result");return{status:"false"===this.safeString(s,"locked")?"ok":"maintenance",updated:this.safeIntegerProduct(t,"usIn",.001,this.milliseconds()),eta:void 0,url:void 0,info:t}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetGetSubaccounts(e),s=this.safeValue(t,"result",[]);return this.parseAccounts(s)}parseAccount(e,t=void 0){return{info:e,id:this.safeString(e,"id"),type:this.safeString(e,"type"),code:this.safeCurrencyCode(void 0,t)}}async fetchMarkets(e={}){const t=[],s=[],i={};let r;if([r,e]=this.handleOptionAndParams(e,"fetchMarkets","fetchAllMarkets",!0),r){const s=await this.publicGetGetInstruments(e);t.push(s)}else{const s=await this.publicGetGetCurrencies(e),i=this.safeValue(s,"result",[]);for(let s=0;s<i.length;s++){const r={currency:this.safeString(i[s],"currency")},a=await this.publicGetGetInstruments(this.extend(r,e));t.push(a)}}for(let e=0;e<t.length;e++){const r=this.safeValue(t[e],"result",[]);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeString(t,"kind"),o="spot"===a,n=this.safeString(t,"instrument_name"),d=this.safeString(t,"base_currency"),h=this.safeString(t,"counter_currency"),c=this.safeString(t,"settlement_currency"),l=this.safeCurrencyCode(d),u=this.safeCurrencyCode(h),p=this.safeCurrencyCode(c),f="perpetual"===this.safeValue(t,"settlement_period"),m=!f&&a.indexOf("future")>=0,g=a.indexOf("option")>=0,v=a.indexOf("combo")>=0,y=this.safeInteger(t,"expiration_timestamp");let w,b,S=n,k="swap";if(m?k="future":g?k="option":o&&(k="spot"),o)S=l+"/"+u;else if(!v&&(S=l+"/"+u+":"+p,(g||m)&&(S=S+"-"+this.yymmdd(y,""),g))){w=this.safeNumber(t,"strike"),b=this.safeString(t,"option_type");const e="call"===b?"C":"P";S=S+"-"+this.numberToString(w)+"-"+e}if(this.safeValue(i,S))continue;i[S]=!0;const O=this.safeNumber(t,"min_trade_amount"),T=this.safeNumber(t,"tick_size");s.push({id:n,symbol:S,base:l,quote:u,settle:p,baseId:d,quoteId:h,settleId:c,type:k,spot:o,margin:!1,swap:f,future:m,option:g,active:this.safeValue(t,"is_active"),contract:!o,linear:p===u,inverse:p!==u,taker:this.safeNumber(t,"taker_commission"),maker:this.safeNumber(t,"maker_commission"),contractSize:this.safeNumber(t,"contract_size"),expiry:y,expiryDatetime:this.iso8601(y),strike:w,optionType:b,precision:{amount:O,price:T},limits:{leverage:{min:void 0,max:void 0},amount:{min:O,max:void 0},price:{min:T,max:void 0},cost:{min:void 0,max:void 0}},created:this.safeInteger(t,"creation_timestamp"),info:t})}}return s}parseBalance(e){const t={info:e},s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s),r=this.account();return r.free=this.safeString(e,"available_funds"),r.used=this.safeString(e,"maintenance_margin"),r.total=this.safeString(e,"equity"),t[i]=r,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchBalance",e),s={currency:this.currency(t).id},i=await this.privateGetGetAccountSummary(this.extend(s,e)),r=this.safeValue(i,"result",{});return this.parseBalance(r)}async createDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privateGetCreateDepositAddress(this.extend(s,t)),r=this.safeValue(i,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,info:i}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privateGetGetCurrentDepositAddress(this.extend(s,t)),r=this.safeValue(i,"result",{}),a=this.safeString(r,"address");return this.checkAddress(a),{currency:e,address:a,tag:void 0,network:void 0,info:i}}parseTicker(e,t=void 0){const s=this.safeInteger2(e,"timestamp","creation_timestamp"),i=this.safeString(e,"instrument_name"),r=this.safeSymbol(i,t),a=this.safeString2(e,"last_price","last"),o=this.safeValue(e,"stats",e);return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(o,"high","max_price"),low:this.safeString2(o,"low","min_price"),bid:this.safeString2(e,"best_bid_price","bid_price"),bidVolume:this.safeString(e,"best_bid_amount"),ask:this.safeString2(e,"best_ask_price","ask_price"),askVolume:this.safeString(e,"best_ask_amount"),vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(o,"volume"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},r=await this.publicGetTicker(this.extend(i,t)),a=this.safeDict(r,"result");return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString2(t,"code","currency");if(t=this.omit(t,["code"]),void 0===s)throw new a.ArgumentsRequired(this.id+" fetchTickers requires a currency/code (eg: BTC/ETH/USDT) parameter to fetch tickers for");const i={currency:this.currency(s).id},r=await this.publicGetGetBookSummaryByCurrency(this.extend(i,t)),o=this.safeList(r,"result",[]),n={};for(let e=0;e<o.length;e++){const t=this.parseTicker(o[e]);n[t.symbol]=t}return this.filterByArrayTickers(n,"symbol",e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,5e3);const o=this.market(e),n={instrument_name:o.id,resolution:this.safeString(this.timeframes,t,t)},d=this.parseTimeframe(t),h=this.milliseconds();void 0===s?(void 0===i&&(i=1e3),n.start_timestamp=h-(i-1)*d*1e3,n.end_timestamp=h):(s=Math.max(s-1,0),n.start_timestamp=s,n.end_timestamp=void 0===i?h:this.sum(s,i*d*1e3));const c=this.safeInteger(r,"until");void 0!==c&&(r=this.omit(r,"until"),n.end_timestamp=c);const l=await this.publicGetGetTradingviewChartData(this.extend(n,r)),u=this.safeValue(l,"result",{}),p=this.convertTradingViewToOHLCV(u,"ticks","open","high","low","close","volume",!0);return this.parseOHLCVs(p,o,t,s,i)}parseTrade(e,t=void 0){const s=this.safeString(e,"trade_id"),i=this.safeString(e,"instrument_name"),r=this.safeSymbol(i,t),a=this.safeInteger(e,"timestamp"),n=this.safeString(e,"direction"),d=this.safeString(e,"price");t=this.safeMarket(i,t);const h=this.safeString(e,"amount");let c=o.Y.stringMul(h,d);t.inverse&&(c=o.Y.stringDiv(h,d));const l=this.safeString(e,"liquidity");let u;void 0!==l&&(u="M"===l?"maker":"taker");const p=this.safeString(e,"fee");let f;if(void 0!==p){const t=this.safeString(e,"fee_currency");f={cost:p,currency:this.safeCurrencyCode(t)}}return this.safeTrade({id:s,info:e,timestamp:a,datetime:this.iso8601(a),symbol:r,order:this.safeString(e,"order_id"),type:this.safeString(e,"order_type"),side:n,takerOrMaker:u,price:d,amount:h,cost:c,fee:f},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={instrument_name:r.id,include_old:!0};void 0!==t&&(a.start_timestamp=t),void 0!==s&&(a.count=Math.min(s,1e3));const o=this.safeInteger2(i,"until","end_timestamp");let n;void 0!==o&&(i=this.omit(i,["until"]),a.end_timestamp=o),n=void 0!==t||"end_timestamp"in a?await this.publicGetGetLastTradesByInstrumentAndTime(this.extend(a,i)):await this.publicGetGetLastTradesByInstrument(this.extend(a,i));const d=this.safeValue(n,"result",{}),h=this.safeList(d,"trades",[]);return this.parseTrades(h,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=this.codeFromOptions("fetchTradingFees",e),s={currency:this.currency(t).id,extended:!0},i=await this.privateGetGetAccountSummary(this.extend(s,e)),r=this.safeValue(i,"result",{}),a=this.safeValue(r,"fees",[]);let o={},n={},d={};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"instrument_type");"future"===s?n={info:t,maker:this.safeNumber(t,"maker_fee"),taker:this.safeNumber(t,"taker_fee")}:"perpetual"===s?o={info:t,maker:this.safeNumber(t,"maker_fee"),taker:this.safeNumber(t,"taker_fee")}:"option"===s&&(d={info:t,maker:this.safeNumber(t,"maker_fee"),taker:this.safeNumber(t,"taker_fee")})}const h={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],s=this.market(t);let i={info:s,symbol:t,percentage:!0,tierBased:!0,maker:s.maker,taker:s.taker};s.swap?i=this.extend(i,o):s.future?i=this.extend(i,n):s.option&&(i=this.extend(i,d)),h[t]=i}return h}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={instrument_name:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetGetOrderBook(this.extend(r,s)),o=this.safeValue(a,"result",{}),n=this.safeInteger(o,"timestamp"),d=this.safeInteger(o,"change_id"),h=this.parseOrderBook(o,i.symbol,n);return h.nonce=d,h}parseOrderStatus(e){return this.safeString({open:"open",cancelled:"canceled",filled:"closed",rejected:"rejected",untriggered:"open"},e,e)}parseTimeInForce(e){return this.safeString({good_til_cancelled:"GTC",fill_or_kill:"FOK",immediate_or_cancel:"IOC"},e,e)}parseOrderType(e){return this.safeString({stop_limit:"limit",take_limit:"limit",stop_market:"market",take_market:"market"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);const i=this.safeInteger(e,"creation_timestamp"),r=this.safeInteger(e,"last_update_timestamp"),a=this.safeString(e,"order_id");let n=this.safeString(e,"price");"market_price"===n&&(n=void 0);const d=this.safeString(e,"average_price"),h=this.safeString(e,"filled_amount"),c=this.safeString(e,"amount");let l,u=o.Y.stringMul(h,d);if(t.inverse&&"0"!==d&&(u=o.Y.stringDiv(c,d)),void 0!==h){o.Y.stringGt(h,"0")&&(l=r)}const p=this.parseOrderStatus(this.safeString(e,"order_state")),f=this.safeStringLower(e,"direction");let m,g=this.safeString(e,"commission");void 0!==g&&(g=o.Y.stringAbs(g),m={cost:g,currency:t.base});const v=this.safeString(e,"order_type"),y=this.parseOrderType(v),w=this.safeValue(e,"trades"),b=this.parseTimeInForce(this.safeString(e,"time_in_force")),S=this.safeValue(e,"stop_price"),k=this.safeValue(e,"post_only");return this.safeOrder({info:e,id:a,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:l,symbol:t.symbol,type:y,timeInForce:b,postOnly:k,side:f,price:n,stopPrice:S,triggerPrice:S,amount:c,cost:u,average:d,filled:h,remaining:void 0,status:p,fee:m,trades:w},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e};let r;void 0!==t&&(r=this.market(t));const a=await this.privateGetGetOrderState(this.extend(i,s)),o=this.safeDict(a,"result");return this.parseOrder(o,r)}async createOrder(e,t,s,i,r=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={instrument_name:n.id,amount:this.amountToPrecision(e,i),type:t},h=this.safeString(o,"trigger","last_price"),c=this.safeStringUpper(o,"timeInForce"),l=this.safeValue2(o,"reduceOnly","reduce_only"),u=this.safeValue(o,"stopLossPrice"),p=this.safeValue(o,"takeProfitPrice"),f=this.safeString2(o,"trailingAmount","trigger_offset"),m=void 0!==f,g="stop_limit"===t,v="stop_market"===t,y="take_limit"===t,w="take_market"===t,b=g||v||void 0!==u,S=y||w||void 0!==p;if(b&&S)throw new a.InvalidOrder(this.id+" createOrder () only allows one of stopLossPrice or takeProfitPrice to be specified");const k=b||S,O="limit"===t||g||y,T="market"===t||v||w,P=this.safeValue(o,"post_only"),I=this.isPostOnly(T,P,o);if(O?(d.type="limit",d.price=this.priceToPrecision(e,r)):d.type="market",m)d.trigger=h,d.type="trailing_stop",d.trigger_offset=this.parseToNumeric(f);else if(k){const t=void 0!==u?u:p;d.trigger_price=this.priceToPrecision(e,t),d.trigger=h,d.type=b?T?"stop_market":"stop_limit":T?"take_market":"take_limit"}let x;l&&(d.reduce_only=!0),I&&(d.post_only=!0,d.reject_post_only=!0),void 0!==c&&("GTC"===c&&(d.time_in_force="good_til_cancelled"),"IOC"===c&&(d.time_in_force="immediate_or_cancel"),"FOK"===c&&(d.time_in_force="fill_or_kill")),o=this.omit(o,["timeInForce","stopLossPrice","takeProfitPrice","postOnly","reduceOnly","trailingAmount"]),x="Buy"===this.capitalize(s)?await this.privateGetBuy(this.extend(d,o)):await this.privateGetSell(this.extend(d,o));const A=this.safeValue(x,"result",{}),M=this.safeValue(A,"order"),C=this.safeValue(A,"trades",[]);return M.trades=C,this.parseOrder(M,n)}async editOrder(e,t,s,i,r=void 0,o=void 0,n={}){if(void 0===r)throw new a.ArgumentsRequired(this.id+" editOrder() requires an amount argument");await this.loadMarkets();const d={order_id:e,amount:this.amountToPrecision(t,r)};void 0!==o&&(d.price=this.priceToPrecision(t,o));const h=this.safeString2(n,"trailingAmount","trigger_offset");void 0!==h&&(d.trigger_offset=this.parseToNumeric(h),n=this.omit(n,"trigger_offset"));const c=await this.privateGetEdit(this.extend(d,n)),l=this.safeValue(c,"result",{}),u=this.safeValue(l,"order"),p=this.safeValue(l,"trades",[]);return u.trades=p,this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetCancel(this.extend(i,s)),a=this.safeDict(r,"result",{});return this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;if(void 0===e)i=await this.privateGetCancelAll(this.extend(s,t));else{const r=this.market(e);s.instrument_name=r.id,i=await this.privateGetCancelAllByInstrument(this.extend(s,t))}return[this.safeOrder({info:i})]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;if(void 0===e){const e=this.codeFromOptions("fetchOpenOrders",i),t=this.currency(e);r.currency=t.id,o=await this.privateGetGetOpenOrdersByCurrency(this.extend(r,i))}else a=this.market(e),r.instrument_name=a.id,o=await this.privateGetGetOpenOrdersByInstrument(this.extend(r,i));const n=this.safeList(o,"result",[]);return this.parseOrders(n,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;if(void 0===e){const e=this.codeFromOptions("fetchClosedOrders",i),t=this.currency(e);r.currency=t.id,o=await this.privateGetGetOrderHistoryByCurrency(this.extend(r,i))}else a=this.market(e),r.instrument_name=a.id,o=await this.privateGetGetOrderHistoryByInstrument(this.extend(r,i));const n=this.safeList(o,"result",[]);return this.parseOrders(n,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={order_id:e},o=await this.privateGetGetUserTradesByOrder(this.extend(a,r)),n=this.safeList(o,"result",[]);return this.parseTrades(n,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={include_old:!0};let a,o;if(void 0!==s&&(r.count=s),void 0===e){const e=this.codeFromOptions("fetchMyTrades",i),s=this.currency(e);r.currency=s.id,void 0===t?o=await this.privateGetGetUserTradesByCurrency(this.extend(r,i)):(r.start_timestamp=t,o=await this.privateGetGetUserTradesByCurrencyAndTime(this.extend(r,i)))}else a=this.market(e),r.instrument_name=a.id,void 0===t?o=await this.privateGetGetUserTradesByInstrument(this.extend(r,i)):(r.start_timestamp=t,o=await this.privateGetGetUserTradesByInstrumentAndTime(this.extend(r,i)));const n=this.safeValue(o,"result",{}),d=this.safeList(n,"trades",[]);return this.parseTrades(d,a,t,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchDeposits() requires a currency code argument");await this.loadMarkets();const r=this.currency(e),o={currency:r.id};void 0!==s&&(o.count=s);const n=await this.privateGetGetDeposits(this.extend(o,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"data",[]);return this.parseTransactions(h,r,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchWithdrawals() requires a currency code argument");await this.loadMarkets();const r=this.currency(e),o={currency:r.id};void 0!==s&&(o.count=s);const n=await this.privateGetGetWithdrawals(this.extend(o,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"data",[]);return this.parseTransactions(h,r,t,s,i)}parseTransactionStatus(e){return this.safeString({completed:"ok",unconfirmed:"pending"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t),r=this.safeInteger2(e,"created_timestamp","received_timestamp"),a=this.safeInteger(e,"updated_timestamp"),o=this.parseTransactionStatus(this.safeString(e,"state")),n=this.safeString(e,"address"),d=this.safeNumber(e,"fee");let h,c="deposit";return void 0!==d&&(c="withdrawal",h={cost:d,currency:i}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transaction_id"),timestamp:r,datetime:this.iso8601(r),address:n,addressTo:n,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:c,amount:this.safeNumber(e,"amount"),currency:i,status:o,updated:a,network:void 0,internal:void 0,comment:void 0,fee:h}}parsePosition(e,t=void 0){const s=this.safeString(e,"instrument_name");t=this.safeMarket(s,t);let i=this.safeString(e,"direction");i="buy"===i?"long":"short";const r=this.safeString(e,"floating_profit_loss"),a=this.safeString(e,"initial_margin"),n=this.safeString(e,"size_currency"),d=this.safeString(e,"maintenance_margin"),h=this.milliseconds();return this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:h,datetime:this.iso8601(h),lastUpdateTimestamp:void 0,initialMargin:this.parseNumber(a),initialMarginPercentage:this.parseNumber(o.Y.stringMul(o.Y.stringDiv(a,n),"100")),maintenanceMargin:this.parseNumber(d),maintenanceMarginPercentage:this.parseNumber(o.Y.stringMul(o.Y.stringDiv(d,n),"100")),entryPrice:this.safeNumber(e,"average_price"),notional:this.parseNumber(n),leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.parseNumber(r),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"estimated_liquidation_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,collateral:void 0,marginMode:void 0,side:i,percentage:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchPosition(e,t={}){await this.loadMarkets();const s={instrument_name:this.market(e).id},i=await this.privateGetGetPosition(this.extend(s,t)),r=this.safeDict(i,"result");return this.parsePosition(r)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();let s,i=this.safeString(t,"kind");if(void 0===e)s=this.codeFromOptions("fetchPositions",t);else if("string"==typeof e)s=e,e=void 0;else if(Array.isArray(e)){if(1!==e.length)throw new a.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");const t=this.market(e[0]),r=t.settle;s=void 0!==r?r:t.base,i=t.info.kind}const r={currency:this.currency(s).id};void 0!==i&&(r.kind=i);const o=await this.privateGetGetPositions(this.extend(r,t)),n=this.safeList(o,"result");return this.parsePositions(n,e)}async fetchVolatilityHistory(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.publicGetGetHistoricalVolatility(this.extend(s,t));return this.parseVolatilityHistory(i)}parseVolatilityHistory(e){const t=this.safeValue(e,"result",[]),s=[];for(let e=0;e<t.length;e++){const i=this.safeInteger(t[e],0),r=this.safeNumber(t[e],1);s.push({info:r,timestamp:i,datetime:this.iso8601(i),volatility:r})}return s}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchTransfers() requires a currency code argument");await this.loadMarkets();const r=this.currency(e),o={currency:r.id};void 0!==s&&(o.count=s);const n=await this.privateGetGetTransfers(this.extend(o,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"data",[]);return this.parseTransfers(h,r,t,s,i)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={amount:t,currency:a.id,destination:i};let n,d=this.safeString(r,"method");if(r=this.omit(r,"method"),void 0===d){const e=this.safeValue(this.options,"transfer",{});d=this.safeString(e,"method","privateGetSubmitTransferToSubaccount")}n="privateGetSubmitTransferToUser"===d?await this.privateGetSubmitTransferToUser(this.extend(o,r)):await this.privateGetSubmitTransferToSubaccount(this.extend(o,r));const h=this.safeDict(n,"result",{});return this.parseTransfer(h,a)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"created_timestamp"),i=this.safeString(e,"state"),r=this.safeString(e,"other_side"),a=this.safeString(e,"direction"),o=this.safeString(e,"currency");return{info:e,id:this.safeString(e,"id"),status:this.parseTransferStatus(i),amount:this.safeNumber(e,"amount"),currency:this.safeCurrencyCode(o,t),fromAccount:"payment"!==a?r:void 0,toAccount:"payment"===a?r:void 0,timestamp:s,datetime:this.iso8601(s)}}parseTransferStatus(e){return this.safeString({prepared:"pending",confirmed:"ok",cancelled:"cancelled",waiting_for_admin:"pending"},e,e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={currency:a.id,address:s,amount:t};void 0!==this.twofa&&(o.tfa=(0,d.O)(this.twofa));const n=await this.privateGetWithdraw(this.extend(o,r));return this.parseTransaction(n,a)}parseDepositWithdrawFee(e,t=void 0){return{info:e,withdraw:{fee:this.safeNumber(e,"withdrawal_fee"),percentage:!1},deposit:{fee:void 0,percentage:void 0},networks:{}}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetGetCurrencies(t),i=this.safeList(s,"result",[]);return this.parseDepositWithdrawFees(i,e,"currency")}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.milliseconds(),r={instrument_name:s.id,start_timestamp:i-288e5,end_timestamp:i},a=await this.publicGetGetFundingRateValue(this.extend(r,t));return this.parseFundingRate(a,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,720);const o=this.milliseconds();void 0===t&&(t=o-2592e6);const n={instrument_name:r.id,start_timestamp:t-1,end_timestamp:o},d=await this.publicGetGetFundingRateHistory(this.extend(n,i)),h=[],c=this.safeValue(d,"result",[]);for(let e=0;e<c.length;e++){const t=c[e],s=this.parseFundingRate(t,r);h.push(s)}return this.filterBySymbolSinceLimit(h,e,t,s)}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.iso8601(s),r=this.safeNumber2(e,"result","interest_8h");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:void 0,indexPrice:this.safeNumber(e,"index_price"),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:s,datetime:i,fundingRate:r,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLiquidations","paginate"),r)return await this.fetchPaginatedCallCursor("fetchLiquidations",e,t,s,i,"continuation","continuation",void 0);const o=this.market(e);if(o.spot)throw new a.NotSupported(this.id+" fetchLiquidations() does not support "+o.type+" markets");const n={instrument_name:o.id,type:"bankruptcy"};void 0!==t&&(n.search_start_timestamp=t),void 0!==s&&(n.count=s);const d=await this.publicGetGetLastSettlementsByInstrument(this.extend(n,i)),h=this.safeValue(d,"result",{}),c=this.safeString(h,"continuation"),l=this.safeValue(h,"settlements",[]),u=this.addPaginationCursorToResult(c,l);return this.parseLiquidations(u,o,t,s)}addPaginationCursorToResult(e,t){if(void 0!==e){const s=t.length;if(s>0){const i=t[0],r=t[s-1];i.continuation=e,r.continuation=e,t[0]=i,t[s-1]=r}}return t}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchMyLiquidations() requires a symbol argument");await this.loadMarkets();const r=this.market(e);if(r.spot)throw new a.NotSupported(this.id+" fetchMyLiquidations() does not support "+r.type+" markets");const o={instrument_name:r.id,type:"bankruptcy"};void 0!==t&&(o.search_start_timestamp=t),void 0!==s&&(o.count=s);const n=await this.privateGetGetSettlementHistoryByInstrument(this.extend(o,i)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"settlements",[]);return this.parseLiquidations(h,r,t,s)}parseLiquidation(e,t=void 0){const s=this.safeInteger(e,"timestamp");return this.safeLiquidation({info:e,symbol:this.safeSymbol(void 0,t),contracts:void 0,contractSize:this.safeNumber(t,"contractSize"),price:void 0,baseValue:this.safeNumber(e,"session_bankrupcy"),quoteValue:void 0,timestamp:s,datetime:this.iso8601(s)})}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},r=await this.publicGetTicker(this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseGreeks(a,s)}parseGreeks(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"instrument_name"),r=this.safeSymbol(i,t),a=this.safeValue(e,"greeks",{});return{symbol:r,timestamp:s,datetime:this.iso8601(s),delta:this.safeNumber(a,"delta"),gamma:this.safeNumber(a,"gamma"),theta:this.safeNumber(a,"theta"),vega:this.safeNumber(a,"vega"),rho:this.safeNumber(a,"rho"),bidSize:this.safeNumber(e,"best_bid_amount"),askSize:this.safeNumber(e,"best_ask_amount"),bidImpliedVolatility:this.safeNumber(e,"bid_iv"),askImpliedVolatility:this.safeNumber(e,"ask_iv"),markImpliedVolatility:this.safeNumber(e,"mark_iv"),bidPrice:this.safeNumber(e,"best_bid_price"),askPrice:this.safeNumber(e,"best_ask_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:this.safeNumber(e,"last_price"),underlyingPrice:this.safeNumber(e,"underlying_price"),info:e}}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_name:s.id},r=await this.publicGetGetBookSummaryByInstrument(this.extend(i,t)),a=this.safeList(r,"result",[]),o=this.safeDict(a,0,{});return this.parseOption(o,void 0,s)}async fetchOptionChain(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id,kind:"option"},i=await this.publicGetGetBookSummaryByCurrency(this.extend(s,t)),r=this.safeList(i,"result",[]);return this.parseOptionChain(r,"base_currency","instrument_name")}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"instrument_name");s=this.safeMarket(i,s);const r=this.safeString(e,"base_currency"),a=this.safeCurrencyCode(r,t),o=this.safeInteger(e,"timestamp");return{info:e,currency:a,symbol:s.symbol,timestamp:o,datetime:this.iso8601(o),impliedVolatility:void 0,openInterest:this.safeNumber(e,"open_interest"),bidPrice:this.safeNumber(e,"bid_price"),askPrice:this.safeNumber(e,"ask_price"),midPrice:this.safeNumber(e,"mid_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:this.safeNumber(e,"last"),underlyingPrice:this.safeNumber(e,"underlying_price"),change:void 0,percentage:this.safeNumber(e,"price_change"),baseVolume:this.safeNumber(e,"volume"),quoteVolume:this.safeNumber(e,"volume_usd")}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/api/"+this.version+"/"+t+"/"+e;if("public"===t&&Object.keys(i).length&&(o+="?"+this.urlencode(i)),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.milliseconds().toString(),a="";Object.keys(i).length&&(o+="?"+this.urlencode(i));const d=t+"\n"+e+"\n"+(s+"\n"+o+"\n"+a+"\n"),h=this.hmac(this.encode(d),this.encode(this.secret),n.s);r={Authorization:"deri-hmac-sha256 id="+this.apiKey+",ts="+t+",sig="+h+",nonce="+e}}return{url:this.urls.api.rest+o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,o,n,d,h){if(!n)return;const c=this.safeValue(n,"error");if(void 0!==c){const e=this.safeString(c,"code"),t=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions,e,t),new a.ExchangeError(t)}}}},779:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9420),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"digifinex",name:"DigiFinex",countries:["SG"],version:"v3",rateLimit:900,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","4h":"240","12h":"720","1d":"1D","1w":"1W"},urls:{logo:"https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",api:{rest:"https://openapi.digifinex.com"},www:"https://www.digifinex.com",doc:["https://docs.digifinex.com"],fees:"https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",referral:"https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp"},api:{public:{spot:{get:["{market}/symbols","kline","margin/currencies","margin/symbols","markets","order_book","ping","spot/symbols","time","trades","trades/symbols","ticker","currencies"]},swap:{get:["public/api_weight","public/candles","public/candles_history","public/depth","public/funding_rate","public/funding_rate_history","public/instrument","public/instruments","public/ticker","public/tickers","public/time","public/trades"]}},private:{spot:{get:["{market}/financelog","{market}/mytrades","{market}/order","{market}/order/detail","{market}/order/current","{market}/order/history","margin/assets","margin/financelog","margin/mytrades","margin/order","margin/order/current","margin/order/history","margin/positions","otc/financelog","spot/assets","spot/financelog","spot/mytrades","spot/order","spot/order/current","spot/order/history","deposit/address","deposit/history","withdraw/history"],post:["{market}/order/cancel","{market}/order/new","{market}/order/batch_new","margin/order/cancel","margin/order/new","margin/position/close","spot/order/cancel","spot/order/new","transfer","withdraw/new","withdraw/cancel"]},swap:{get:["account/balance","account/positions","account/finance_record","account/trading_fee_rate","account/transfer_record","account/funding_fee","trade/history_orders","trade/history_trades","trade/open_orders","trade/order_info"],post:["account/leverage","account/position_mode","account/position_margin","trade/batch_cancel_order","trade/batch_order","trade/cancel_order","trade/order_place","follow/sponsor_order","follow/close_order","follow/cancel_order","follow/user_center_current","follow/user_center_history","follow/expert_current_open_order","follow/add_algo","follow/cancel_algo","follow/account_available","follow/plan_task","follow/instrument_list"]}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:a.kb,exceptions:{exact:{10001:[r.BadRequest,"Wrong request method, please check it's a GET ot POST request"],10002:[r.AuthenticationError,"Invalid ApiKey"],10003:[r.AuthenticationError,"Sign doesn't match"],10004:[r.BadRequest,"Illegal request parameters"],10005:[r.DDoSProtection,"Request frequency exceeds the limit"],10006:[r.PermissionDenied,"Unauthorized to execute this request"],10007:[r.PermissionDenied,"IP address Unauthorized"],10008:[r.InvalidNonce,"Timestamp for this request is invalid, timestamp must within 1 minute"],10009:[r.NetworkError,"Unexist endpoint, please check endpoint URL"],10011:[r.AccountSuspended,"ApiKey expired. Please go to client side to re-create an ApiKey"],20001:[r.PermissionDenied,"Trade is not open for this trading pair"],20002:[r.PermissionDenied,"Trade of this trading pair is suspended"],20003:[r.InvalidOrder,"Invalid price or amount"],20007:[r.InvalidOrder,"Price precision error"],20008:[r.InvalidOrder,"Amount precision error"],20009:[r.InvalidOrder,"Amount is less than the minimum requirement"],20010:[r.InvalidOrder,"Cash Amount is less than the minimum requirement"],20011:[r.InsufficientFunds,"Insufficient balance"],20012:[r.BadRequest,"Invalid trade type, valid value: buy/sell)"],20013:[r.InvalidOrder,"No order info found"],20014:[r.BadRequest,"Invalid date, Valid format: 2018-07-25)"],20015:[r.BadRequest,"Date exceeds the limit"],20018:[r.PermissionDenied,"Your trading rights have been banned by the system"],20019:[r.BadSymbol,'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front'],20020:[r.DDoSProtection,"You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate."],5e4:[r.ExchangeError,"Exception error"],20021:[r.BadRequest,"Invalid currency"],20022:[r.BadRequest,"The ending timestamp must be larger than the starting timestamp"],20023:[r.BadRequest,"Invalid transfer type"],20024:[r.BadRequest,"Invalid amount"],20025:[r.BadRequest,"This currency is not transferable at the moment"],20026:[r.InsufficientFunds,"Transfer amount exceed your balance"],20027:[r.PermissionDenied,"Abnormal account status"],20028:[r.PermissionDenied,"Blacklist for transfer"],20029:[r.PermissionDenied,"Transfer amount exceed your daily limit"],20030:[r.BadRequest,"You have no position on this trading pair"],20032:[r.PermissionDenied,"Withdrawal limited"],20033:[r.BadRequest,"Wrong Withdrawal ID"],20034:[r.PermissionDenied,"Withdrawal service of this crypto has been closed"],20035:[r.PermissionDenied,"Withdrawal limit"],20036:[r.ExchangeError,"Withdrawal cancellation failed"],20037:[r.InvalidAddress,"The withdrawal address, Tag or chain type is not included in the withdrawal management list"],20038:[r.InvalidAddress,"The withdrawal address is not on the white list"],20039:[r.ExchangeError,"Can't be canceled in current status"],20040:[r.RateLimitExceeded,"Withdraw too frequently; limitation: 3 times a minute, 100 times a day"],20041:[r.PermissionDenied,"Beyond the daily withdrawal limit"],20042:[r.BadSymbol,"Current trading pair does not support API trading"],400002:[r.BadRequest,"Invalid Parameter"]},broad:{}},options:{defaultType:"spot",types:["spot","margin","otc"],createMarketBuyOrderRequiresPrice:!0,accountsByType:{spot:"1",margin:"2",OTC:"3"},networks:{ARBITRUM:"Arbitrum",AVALANCEC:"AVAX-CCHAIN",AVALANCEX:"AVAX-XCHAIN",BEP20:"BEP20",BSC:"BEP20",CARDANO:"Cardano",CELO:"Celo",CHILIZ:"Chiliz",COSMOS:"COSMOS",CRC20:"Crypto.com",CRONOS:"Crypto.com",DOGECOIN:"DogeChain",ERC20:"ERC20",ETH:"ERC20",ETHW:"ETHW",IOTA:"MIOTA",KLAYTN:"KLAY",MATIC:"Polygon",METIS:"MetisDAO",MOONBEAM:"GLMR",MOONRIVER:"Moonriver",OPTIMISM:"OPETH",POLYGON:"Polygon",RIPPLE:"XRP",SOLANA:"SOL",STELLAR:"Stella",TERRACLASSIC:"TerraClassic",TERRA:"Terra",TON:"Ton",TRC20:"TRC20",TRON:"TRC20",TRX:"TRC20",VECHAIN:"Vechain"}},commonCurrencies:{BHT:"Black House Test",EPS:"Epanus",FREE:"FreeRossDAO",MBN:"Mobilian Coin",TEL:"TEL666"}})}async fetchCurrencies(e={}){const t=await this.publicSpotGetCurrencies(e),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),n=this.safeInteger(t,"deposit_status",1)>0,d=this.safeInteger(t,"withdraw_status",1)>0,h=n&&d,c=this.safeString(t,"min_withdraw_fee"),l=this.safeString(t,"min_withdraw_amount"),u=this.safeString(t,"min_deposit_amount"),p=this.parseNumber(u),f=this.parseNumber(l),m=this.parseNumber(c),g=o.Y.stringMin(c,o.Y.stringMin(u,l)),v=this.parseNumber(g),y=this.safeString(t,"chain");let w;void 0!==y&&(w=this.networkIdToCode(y));const b={info:t,id:y,network:w,active:h,fee:m,precision:v,deposit:n,withdraw:d,limits:{amount:{min:void 0,max:void 0},withdraw:{min:f,max:void 0},deposit:{min:p,max:void 0}}};a in i?(Array.isArray(i[a].info)?i[a].info.push(t):i[a].info=[i[a].info,t],d&&(i[a].withdraw=!0,i[a].limits.withdraw.min=Math.min(i[a].limits.withdraw.min,f)),n&&(i[a].deposit=!0,i[a].limits.deposit.min=Math.min(i[a].limits.deposit.min,p)),h&&(i[a].active=!0)):i[a]={id:r,code:a,info:t,type:void 0,name:void 0,active:h,deposit:n,withdraw:d,fee:this.parseNumber(c),precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:f,max:void 0},deposit:{min:p,max:void 0}},networks:{}},void 0!==y?i[a].networks[y]=b:(i[a].active=h,i[a].fee=this.parseNumber(c),i[a].deposit=n,i[a].withdraw=d,i[a].limits={amount:{min:void 0,max:void 0},withdraw:{min:f,max:void 0},deposit:{min:p,max:void 0}}),i[a].precision=void 0===i[a].precision?v:Math.max(i[a].precision,v)}return i}async fetchMarkets(e={}){const t=this.safeValue(this.options,"fetchMarkets",{});return"fetch_markets_v2"===this.safeString(t,"method","fetch_markets_v2")?await this.fetchMarketsV2(e):await this.fetchMarketsV1(e)}async fetchMarketsV2(e={}){const t=this.safeString(this.options,"defaultType"),[s,i]=this.handleMarginModeAndParams("fetchMarketsV2",e),r=[];void 0!==s?r.push(this.publicSpotGetMarginSymbols(i)):r.push(this.publicSpotGetTradesSymbols(i)),r.push(this.publicSwapGetPublicInstruments(e));const a=await Promise.all(r),o=a[0],n=a[1],d=this.safeValue(o,"symbol_list",[]),h=this.safeValue(n,"data",[]),c=this.arrayConcat(d,h),l=[];for(let e=0;e<c.length;e++){const i=c[e],r=this.safeString2(i,"symbol","instrument_id"),a=this.safeString2(i,"base_asset","base_currency"),o=this.safeString2(i,"quote_asset","quote_currency"),n=this.safeString(i,"clear_currency"),d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),u=this.safeCurrencyCode(n);let p=this.safeInteger(i,"is_allow",1),f="margin"===t?"margin":"spot";const m=void 0===u,g=!m,v=void 0!==s||void 0;let y,w,b=d+"/"+h;if(g){f="swap",b=d+"/"+h+":"+u,y=this.safeValue(i,"is_inverse"),w=!y;this.safeValue(i,"isTrading")&&(p=1)}l.push({id:r,symbol:b,base:d,quote:h,settle:u,baseId:a,quoteId:o,settleId:n,type:f,spot:m,margin:v,swap:g,future:!1,option:!1,active:!!p,contract:g,linear:w,inverse:y,contractSize:this.safeNumber(i,"contract_value"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(i,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(i,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber2(i,"minimum_amount","min_order_amount"),max:void 0},price:{min:this.safeNumber(i,"tick_size"),max:void 0},cost:{min:this.safeNumber(i,"minimum_value"),max:void 0}},created:void 0,info:i})}return l}async fetchMarketsV1(e={}){const t=await this.publicSpotGetMarkets(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"market"),[a,o]=r.split("_"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);i.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(t,"price_precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(t,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_volume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"min_amount"),max:void 0}},info:t})}return i}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),n=this.account(),d=this.safeString2(i,"free","avail_balance"),h=this.safeString2(i,"total","equity");n.free=d,n.used=o.Y.stringSub(h,d),n.total=h,t[a]=n}return this.safeBalance(t)}async fetchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const[s,i]=this.handleMarginModeAndParams("fetchBalance",e);let a;if(void 0!==s||"margin"===t)t="margin",a=await this.privateSpotGetMarginAssets(i);else if("spot"===t)a=await this.privateSpotGetSpotAssets(i);else{if("swap"!==t)throw new r.NotSupported(this.id+" fetchBalance() not support this market type");a=await this.privateSwapGetAccountBalance(i)}const o="swap"===t?"data":"list",n=this.safeValue(a,o,[]);return this.parseBalance(n)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[r,a]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),o={};let n,d,h;return void 0!==t&&(o.limit=t),"swap"===r?(o.instrument_id=i.id,n=await this.publicSwapGetPublicDepth(this.extend(o,a))):(o.symbol=i.id,n=await this.publicSpotGetOrderBook(this.extend(o,a))),"swap"===r?(h=this.safeValue(n,"data",{}),d=this.safeInteger(h,"timestamp")):(h=n,d=this.safeTimestamp(n,"date")),this.parseOrderBook(h,i.symbol,d)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i,r;void 0!==s&&(i=this.market(s)),[r,t]=this.handleMarketTypeAndParams("fetchTickers",i,t);const a={};let o;o="swap"===r?await this.publicSwapGetPublicTickers(this.extend(a,t)):await this.publicSpotGetTicker(this.extend(a,t));const n={},d=this.safeValue2(o,"ticker","data",[]),h=this.safeInteger(o,"date");for(let e=0;e<d.length;e++){const t=this.extend({date:h},d[e]),s=this.parseTicker(t);n[s.symbol]=s}return this.filterByArrayTickers(n,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let r;s.swap?(i.instrument_id=s.id,r=await this.publicSwapGetPublicTicker(this.extend(i,t))):(i.symbol=s.id,r=await this.publicSpotGetTicker(this.extend(i,t)));const a=this.safeInteger(r,"date"),o=this.safeValue(r,"ticker",[]),n=this.safeValue(r,"data",{}),d=this.safeValue(o,0,{});let h;return h=s.swap?n:this.extend({date:a},d),this.parseTicker(h,s)}parseTicker(e,t=void 0){const s=void 0!==this.safeNumber(e,"index_price")?"contract":"spot",i=this.safeStringUpper2(e,"symbol","instrument_id"),r=this.safeSymbol(i,t,void 0,s);t=this.safeMarket(i,t,void 0,s);let a=this.safeTimestamp(e,"date");t.swap&&(a=this.safeInteger(e,"timestamp"));const o=this.safeString(e,"last");return this.safeTicker({symbol:r,timestamp:a,datetime:this.iso8601(a),high:this.safeString2(e,"high","high_24h"),low:this.safeString2(e,"low","low_24h"),bid:this.safeString2(e,"buy","best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString2(e,"sell","best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:o,last:o,previousClose:void 0,change:void 0,percentage:this.safeString2(e,"change","price_change_percent"),average:void 0,baseVolume:this.safeString2(e,"vol","volume_24h"),quoteVolume:this.safeString(e,"base_vol"),info:e},t)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","trade_id"),i=this.safeString(e,"order_id"),r=this.safeString(e,"price"),a=this.safeStringN(e,["amount","volume","size"]),o=this.safeStringUpper2(e,"symbol","instrument_id"),n=this.safeSymbol(o,t);void 0===t&&(t=this.safeMarket(o));let d,h,c,l=this.safeTimestamp2(e,"date","timestamp"),u=this.safeString2(e,"type","side");if("swap"===t.type){l=this.safeInteger(e,"trade_time");const t=this.safeString(e,"order_type"),s=this.safeString(e,"match_role"),i=this.safeString(e,"direction");void 0!==t&&(d="0"===t?"limit":void 0),h="1"===s?"taker":"2"===s?"maker":void 0,"1"===u||"1"===i?u="buy":"2"===u||"2"===i||"3"===u||"3"===i?u="sell":"4"!==u&&"4"!==i||(u="buy")}else{const t=u.split("_");u=this.safeString(t,0),d=this.safeString(t,1),void 0===d&&(d="limit");h=this.safeValue(e,"is_maker")?"maker":"taker"}const p=this.safeString(e,"fee");if(void 0!==p){const t=this.safeString(e,"fee_currency");let s;void 0!==t&&(s=this.safeCurrencyCode(t)),c={cost:p,currency:s}}return this.safeTrade({id:s,info:e,timestamp:l,datetime:this.iso8601(l),symbol:n,type:d,order:i,side:u,price:r,amount:a,cost:void 0,takerOrMaker:h,fee:c},t)}async fetchTime(e={}){const t=await this.publicSpotGetTime(e);return this.safeTimestamp(t,"server_time")}async fetchStatus(e={}){const t=await this.publicSpotGetPing(e);return{status:0===this.safeInteger(t,"code")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={};let o;void 0!==s&&(a.limit=r.swap?Math.min(s,100):s),r.swap?(a.instrument_id=r.id,o=await this.publicSwapGetPublicTrades(this.extend(a,i))):(a.symbol=r.id,o=await this.publicSpotGetTrades(this.extend(a,i)));const n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}parseOHLCV(e,t=void 0){return t.swap?[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]:[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,1)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={};let n,d;if(a.swap)o.instrument_id=a.id,o.granularity=t,void 0!==i&&(o.limit=Math.min(i,100)),n=await this.publicSwapGetPublicCandles(this.extend(o,r));else{if(o.symbol=a.id,o.period=this.safeString(this.timeframes,t,t),void 0!==s){const e=this.parseToInt(s/1e3);if(o.start_time=e,void 0!==i){const s=this.parseTimeframe(t);o.end_time=this.sum(e,i*s)}}else if(void 0!==i){const e=this.seconds(),s=this.parseTimeframe(t),r=i;o.start_time=this.sum(e,-r*s)}n=await this.publicSpotGetKline(this.extend(o,r))}if(a.swap){const e=this.safeValue(n,"data",{});d=this.safeValue(e,"candles",[])}else d=this.safeValue(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.handleMarginModeAndParams("createOrder",a)[0],d=this.createOrderRequest(e,t,s,i,r,a);let h;h=o.swap?await this.privateSwapPostTradeOrderPlace(d):void 0!==n?await this.privateSpotPostMarginOrderNew(d):await this.privateSpotPostSpotOrderNew(d);const c=this.parseOrder(h,o);return c.symbol=o.symbol,c.type=t,c.side=s,c.amount=i,c.price=r,c}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i,a;for(let t=0;t<e.length;t++){const o=e[t],n=this.safeString(o,"symbol");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const d=this.safeString(o,"type"),h=this.safeString(o,"side"),c=this.safeValue(o,"amount"),l=this.safeValue(o,"price"),u=this.safeValue(o,"params",{}),p=this.handleMarginModeAndParams("createOrders",u)[0];if(void 0!==p)if(void 0===a)a=p;else if(a!==p)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same margin mode (isolated or cross)");const f=this.createOrderRequest(n,d,h,c,l,u);s.push(f)}const o=this.market(i),n={};let d;o.swap?d=await this.privateSwapPostTradeBatchOrder(s):(n.market=void 0!==a?"margin":"spot",n.symbol=o.id,n.list=this.json(s),d=await this.privateSpotPostMarketOrderBatchNew(n));let h=[];h=o.swap?this.safeValue(d,"data",[]):this.safeValue(d,"order_ids",[]);const c=[];for(let t=0;t<e.length;t++){const s=e[t],i={};i.order_id=h[t],i.instrument_id=o.id,i.amount=this.safeNumber(s,"amount"),i.price=this.safeNumber(s,"price"),c.push(i)}return this.parseOrders(c,o)}createOrderRequest(e,t,s,i,a=void 0,n={}){const d=this.market(e);let h,c;[h,n]=this.handleMarketTypeAndParams("createOrderRequest",d,n),[c,n]=this.handleMarginModeAndParams("createOrderRequest",n),void 0!==c&&(h="margin");const l={},u="swap"===h,p="market"===t,f="limit"===t;l[u?"instrument_id":"symbol"]=d.id;let m,g=this.isPostOnly(p,!1,n);if(u){const t=this.safeBool(n,"reduceOnly",!1),r=this.safeString(n,"timeInForce");let o;if("buy"===s){const e=t?4:1;l.type=e}else{const e=t?3:2;l.type=e}f&&(o=0),"FOK"===r?o=p?15:9:"IOC"===r?o=p?13:4:"GTC"===r||p?o=14:"PO"===r&&(g=!0),void 0!==a&&(l.price=this.priceToPrecision(e,a)),l.order_type=o,l.size=i,n=this.omit(n,["reduceOnly","timeInForce"])}else{m=!0===g?1:2,l.market=h;let d,c="";"market"===t?c="_market":l.price=this.priceToPrecision(e,a),l.type=s+c;let u=!0;if([u,n]=this.handleOptionAndParams(n,"createOrderRequest","createMarketBuyOrderRequiresPrice",!0),p&&"buy"===s){const t=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==t)d=this.costToPrecision(e,t);else if(u){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const t=this.numberToString(i),s=this.numberToString(a),r=this.parseNumber(o.Y.stringMul(t,s));d=this.costToPrecision(e,r)}}else d=this.costToPrecision(e,i)}else d=this.amountToPrecision(e,i);l.amount=d}return g&&(l.post_only=m||g),n=this.omit(n,["postOnly"]),this.extend(l,n)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async cancelOrder(e,t=void 0,s={}){let i,a;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),e=e.toString(),[a,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const o={order_id:e};if("swap"===a){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");o.instrument_id=i.id}else o.market=a;const[n,d]=this.handleMarginModeAndParams("cancelOrder",s);let h;if(void 0!==n||"margin"===a)a="margin",h=await this.privateSpotPostMarginOrderCancel(this.extend(o,d));else if("spot"===a)h=await this.privateSpotPostSpotOrderCancel(this.extend(o,d));else{if("swap"!==a)throw new r.NotSupported(this.id+" cancelOrder() not support this market type");h=await this.privateSwapPostTradeCancelOrder(this.extend(o,d))}if("spot"===a||"margin"===a){if(1!==this.safeValue(h,"success",[]).length)throw new r.OrderNotFound(this.id+" cancelOrder() "+e+" not found");const t=this.parseCancelOrders(h);return this.safeDict(t,0)}return this.safeOrder({info:h,orderId:this.safeString(h,"data")})}parseCancelOrders(e){const t=this.safeList(e,"success"),s=this.safeList(e,"error"),i=[];for(let e=0;e<t.length;e++){const s=t[e];i.push(this.safeOrder({info:s,id:s,status:"canceled"}))}for(let e=0;e<s.length;e++){const t=s[e];i.push(this.safeOrder({info:t,id:this.safeString2(t,"order-id","order_id"),status:"failed",clientOrderId:this.safeString(t,"client-order-id")}))}return i}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString(this.options,"defaultType","spot"),r=this.safeString(s,"type",i);s=this.omit(s,"type");const a={market:r,order_id:e.join(",")},o=await this.privateSpotPostSpotOrderCancel(this.extend(a,s));return this.parseCancelOrders(o)}parseOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"canceled",4:"canceled"},e,e)}parseOrder(e,t=void 0){let s,i,r,a,o=this.safeString(e,"type");const n=this.safeString2(e,"symbol","instrument_id"),d=this.safeSymbol(n,t);if("swap"===(t=this.market(d)).type){const t=this.safeInteger(e,"order_type");void 0!==t&&(9===t||10===t||11===t||12===t||15===t?r="FOK":1===t||2===t||3===t||4===t||13===t?r="IOC":6!==t&&7!==t&&8!==t&&14!==t||(r="GTC"),a=0===t||1===t||4===t||5===t||9===t||10===t?"limit":"market"),"1"===o?o="open long":"2"===o?o="open short":"3"===o?o="close long":"4"===o&&(o="close short"),s=this.safeInteger(e,"insert_time"),i=this.safeInteger(e,"time_stamp")}else if(s=this.safeTimestamp(e,"created_date"),i=this.safeTimestamp(e,"finished_date"),void 0!==o){const e=o.split("_");e.length>1?(o=e[0],a=e[1]):a="limit"}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","data"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,symbol:d,type:a,timeInForce:r,postOnly:void 0,side:o,price:this.safeNumber(e,"price"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeNumber2(e,"amount","size"),filled:this.safeNumber2(e,"executed_amount","filled_qty"),remaining:void 0,cost:void 0,average:this.safeNumber2(e,"avg_price","price_avg"),status:this.parseOrderStatus(this.safeString2(e,"status","state")),fee:{cost:this.safeNumber(e,"fee")},trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o;await this.loadMarkets(),void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchOpenOrders",a,i);const[n,d]=this.handleMarginModeAndParams("fetchOpenOrders",i),h={},c="swap"===o;if(c?(void 0!==t&&(h.start_timestamp=t),void 0!==s&&(h.limit=s)):h.market=o,void 0!==a){h[c?"instrument_id":"symbol"]=a.id}let l;if(void 0!==n||"margin"===o)o="margin",l=await this.privateSpotGetMarginOrderCurrent(this.extend(h,d));else if("spot"===o)l=await this.privateSpotGetSpotOrderCurrent(this.extend(h,d));else{if("swap"!==o)throw new r.NotSupported(this.id+" fetchOpenOrders() not support this market type");l=await this.privateSwapGetTradeOpenOrders(this.extend(h,d))}const u=this.safeList(l,"data",[]);return this.parseOrders(u,a,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o;await this.loadMarkets(),void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchOrders",a,i);const[n,d]=this.handleMarginModeAndParams("fetchOrders",i),h={};if("swap"===o?void 0!==t&&(h.start_timestamp=t):(h.market=o,void 0!==t&&(h.start_time=this.parseToInt(t/1e3))),void 0!==a){h["swap"===o?"instrument_id":"symbol"]=a.id}let c;if(void 0!==s&&(h.limit=s),void 0!==n||"margin"===o)o="margin",c=await this.privateSpotGetMarginOrderHistory(this.extend(h,d));else if("spot"===o)c=await this.privateSpotGetSpotOrderHistory(this.extend(h,d));else{if("swap"!==o)throw new r.NotSupported(this.id+" fetchOrders() not support this market type");c=await this.privateSwapGetTradeHistoryOrders(this.extend(h,d))}const l=this.safeList(c,"data",[]);return this.parseOrders(l,a,t,s)}async fetchOrder(e,t=void 0,s={}){let i,a;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),[a,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);const[o,n]=this.handleMarginModeAndParams("fetchOrder",s),d={order_id:e};let h;if("swap"===a?void 0!==i&&(d.instrument_id=i.id):d.market=a,void 0!==o||"margin"===a)a="margin",h=await this.privateSpotGetMarginOrder(this.extend(d,n));else if("spot"===a)h=await this.privateSpotGetSpotOrder(this.extend(d,n));else{if("swap"!==a)throw new r.NotSupported(this.id+" fetchOrder() not support this market type");h=await this.privateSwapGetTradeOrderInfo(this.extend(d,n))}const c=this.safeValue(h,"data"),l="swap"===a?c:this.safeValue(c,0);if(void 0===l)throw new r.OrderNotFound(this.id+" fetchOrder() order "+e.toString()+" not found");return this.parseOrder(l,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets();const o={};let n;void 0!==e&&(a=this.market(e)),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",a,i);const[d,h]=this.handleMarginModeAndParams("fetchMyTrades",i);"swap"===n?void 0!==t&&(o.start_timestamp=t):(o.market=n,void 0!==t&&(o.start_time=this.parseToInt(t/1e3)));let c;if(void 0!==e&&(o["swap"===n?"instrument_id":"symbol"]=a.id),void 0!==s&&(o.limit=s),void 0!==d||"margin"===n)n="margin",c=await this.privateSpotGetMarginMytrades(this.extend(o,h));else if("spot"===n)c=await this.privateSpotGetSpotMytrades(this.extend(o,h));else{if("swap"!==n)throw new r.NotSupported(this.id+" fetchMyTrades() not support this market type");c=await this.privateSwapGetTradeHistoryTrades(this.extend(o,h))}const l="swap"===n?"data":"list",u=this.safeList(c,l,[]);return this.parseTrades(u,a,t,s)}parseLedgerEntryType(e){return this.safeString({},e,e)}parseLedgerEntry(e,t=void 0){const s=this.parseLedgerEntryType(this.safeString2(e,"type","finance_type")),i=this.safeCurrencyCode(this.safeString2(e,"currency_mark","currency"),t),r=this.safeNumber2(e,"num","change"),a=this.safeNumber(e,"balance");let o=this.safeTimestamp(e,"time");return void 0===o&&(o=this.safeInteger(e,"timestamp")),{info:e,id:void 0,direction:void 0,account:void 0,referenceId:void 0,referenceAccount:void 0,type:s,currency:i,amount:r,before:void 0,after:a,status:void 0,timestamp:o,datetime:this.iso8601(o),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;[o,i]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);const[n,d]=this.handleMarginModeAndParams("fetchLedger",i);"swap"===o?void 0!==t&&(a.start_timestamp=t):(a.market=o,void 0!==t&&(a.start_time=this.parseToInt(t/1e3)));const h="swap"===o?"currency":"currency_mark";let c,l,u;if(void 0!==e&&(c=this.currency(e),a[h]=c.id),void 0!==s&&(a.limit=s),void 0!==n||"margin"===o)o="margin",l=await this.privateSpotGetMarginFinancelog(this.extend(a,d));else if("spot"===o)l=await this.privateSpotGetSpotFinancelog(this.extend(a,d));else{if("swap"!==o)throw new r.NotSupported(this.id+" fetchLedger() not support this market type");l=await this.privateSwapGetAccountFinanceRecord(this.extend(a,d))}if("swap"===o)u=this.safeValue(l,"data",[]);else{const e=this.safeValue(l,"data",{});u=this.safeValue(e,"finance",[])}return this.parseLedger(u,c,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),r=this.safeStringUpper(e,"currency");return{info:e,currency:this.safeCurrencyCode(r),address:s,tag:i,network:void 0}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},a=await this.privateSpotGetDepositAddress(this.extend(i,t)),o=this.safeValue(a,"data",[]),n=this.parseDepositAddresses(o,[s.code]),d=this.safeValue(n,e);if(void 0===d)throw new r.InvalidAddress(this.id+" fetchDepositAddress() did not return an address for "+e+" - create the deposit address in the user settings on the exchange website first.");return d}async fetchTransactionsByType(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets();const o={};let n;void 0!==t&&(a=this.currency(t),o.currency=a.id),void 0!==i&&(o.size=Math.min(500,i)),n="deposit"===e?await this.privateSpotGetDepositHistory(this.extend(o,r)):await this.privateSpotGetWithdrawHistory(this.extend(o,r));const d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,s,i,{type:e})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("deposit",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsByType("withdrawal",e,t,s,i)}parseTransactionStatus(e){return this.safeString({1:"pending",2:"pending",3:"ok",4:"failed"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","withdraw_id"),i=this.safeString(e,"address"),r=this.safeString(e,"memo"),a=this.safeString(e,"hash"),o=this.safeStringUpper(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.parse8601(this.safeString(e,"created_date")),h=this.parse8601(this.safeString(e,"finished_date")),c=this.parseTransactionStatus(this.safeString(e,"state")),l=this.safeNumber(e,"amount"),u=this.safeNumber(e,"fee");let p;void 0!==u&&(p={currency:n,cost:u});const f=this.safeString(e,"chain");return{info:e,id:s,txid:a,timestamp:d,datetime:this.iso8601(d),network:f,address:i,addressTo:i,addressFrom:void 0,tag:r,tagTo:r,tagFrom:void 0,type:void 0,amount:l,currency:n,status:c,updated:h,internal:void 0,comment:void 0,fee:p}}parseTransferStatus(e){return this.safeString({0:"ok"},e,e)}parseTransfer(e,t=void 0){let s,i;const r=this.safeInteger(e,"type");1===r?(s="spot",i="swap"):2===r&&(s="swap",i="spot");const a=this.safeInteger(e,"timestamp");return{info:e,id:this.safeString(e,"transfer_id"),timestamp:a,datetime:this.iso8601(a),currency:this.safeCurrencyCode(this.safeString(e,"currency"),t),amount:this.safeNumber(e,"amount"),fromAccount:s,toAccount:i,status:this.parseTransferStatus(this.safeString(e,"code"))}}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={currency_mark:a.id,num:this.currencyToPrecision(e,t),from:n,to:d},c=await this.privateSpotPostTransfer(this.extend(h,r));return this.parseTransfer(c,a)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={address:s,amount:this.currencyToPrecision(e,t),currency:a.id};void 0!==i&&(o.memo=i);const n=await this.privateSpotPostWithdrawNew(this.extend(o,r));return this.parseTransaction(n,a)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==t&&(o=this.market(t),a.symbol=o.id);const n=await this.privateSpotGetMarginPositions(this.extend(a,r)),d=this.safeValue(n,"positions"),h=this.parseBorrowInterests(d,o);return this.filterByCurrencySinceLimit(h,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"amount"),r=this.safeString(e,"leverage_ratio"),a=o.Y.stringDiv(i,r),n=o.Y.stringSub(i,a),d=void 0===t?void 0:t.base,h=this.safeSymbol(s,t);return{account:h,symbol:h,currency:d,interest:void 0,interestRate:.001,amountBorrowed:this.parseNumber(n),timestamp:void 0,datetime:void 0,info:e}}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();const s=await this.privateSpotGetMarginAssets(this.extend({},t)),i=this.safeValue(s,"list",[]);let r=[];for(let t=0;t<i.length;t++){const s=i[t];this.safeString(s,"currency")===e&&(r=s)}const a=this.currency(e);return this.parseBorrowRate(r,a)}async fetchCrossBorrowRates(e={}){await this.loadMarkets();const t=await this.privateSpotGetMarginAssets(e),s=this.safeValue(t,"list",[]);return this.parseBorrowRates(s,"currency")}parseBorrowRate(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(i,t),rate:.001,period:864e5,timestamp:s,datetime:this.iso8601(s),info:e}}parseBorrowRates(e,t){const s={};for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,t),o=this.safeCurrencyCode(a),n=this.parseBorrowRate(r);s[o]=n}return s}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={instrument_id:s.id},a=await this.publicSwapGetPublicFundingRate(this.extend(i,t)),o=this.safeValue(a,"data",{});return this.parseFundingRate(o,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeInteger(e,"funding_time"),r=this.safeInteger(e,"next_funding_time");return{info:e,symbol:this.safeSymbol(s,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:this.safeString(e,"next_funding_rate"),nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e);if(!a.swap)throw new r.BadSymbol(this.id+" fetchFundingRateHistory() supports swap contracts only");const o={instrument_id:a.id};void 0!==t&&(o.start_timestamp=t),void 0!==s&&(o.limit=s);const n=await this.publicSwapGetPublicFundingRateHistory(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.safeValue(d,"funding_rates",[]),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(d,"instrument_id"),i=this.safeSymbol(s),r=this.safeInteger(t,"time");c.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"rate"),timestamp:r,datetime:this.iso8601(r)})}const l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadRequest(this.id+" fetchTradingFee() supports swap markets only");const i={instrument_id:s.id},a=await this.privateSwapGetAccountTradingFeeRate(this.extend(i,t)),o=this.safeValue(a,"data",{});return this.parseTradingFee(o,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"instrument_id");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"maker_fee_rate"),taker:this.safeNumber(e,"taker_fee_rate"),percentage:void 0,tierBased:void 0}}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i,a;if(void 0!==(e=this.marketSymbols(e))){let t;if(Array.isArray(e)){if(e.length>1)throw new r.BadRequest(this.id+" fetchPositions() symbols argument cannot contain more than 1 symbol");t=e[0]}else t=e;i=this.market(t)}[a,t]=this.handleMarketTypeAndParams("fetchPositions",i,t);const[o,n]=this.handleMarginModeAndParams("fetchPositions",t);if(void 0!==o&&(a="margin"),void 0!==i){s["swap"===a?"instrument_id":"symbol"]=i.id}let d;if("spot"===a||"margin"===a)d=await this.privateSpotGetMarginPositions(this.extend(s,n));else{if("swap"!==a)throw new r.NotSupported(this.id+" fetchPositions() not support this market type");d=await this.privateSwapGetAccountPositions(this.extend(s,n))}const h="swap"===a?"data":"positions",c=this.safeValue(d,h,[]),l=[];for(let e=0;e<c.length;e++)l.push(this.parsePosition(c[e],i));return this.filterByArrayPositions(l,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let a;[a,t]=this.handleMarketTypeAndParams("fetchPosition",s,t);const[o,n]=this.handleMarginModeAndParams("fetchPosition",t);void 0!==o&&(a="margin");let d;if(i["swap"===a?"instrument_id":"symbol"]=s.id,"spot"===a||"margin"===a)d=await this.privateSpotGetMarginPositions(this.extend(i,n));else{if("swap"!==a)throw new r.NotSupported(this.id+" fetchPosition() not support this market type");d=await this.privateSwapGetAccountPositions(this.extend(i,n))}const h="swap"===a?"data":"positions",c=this.safeValue(d,h,[]),l=this.parsePosition(c[0],s);return"swap"===a||(l.collateral=this.safeNumber(d,"margin"),l.marginRatio=this.safeNumber(d,"margin_rate")),l}parsePosition(e,t=void 0){const s=this.safeString2(e,"instrument_id","symbol"),i=(t=this.safeMarket(s,t)).symbol;let r=this.safeString(e,"margin_mode");r=void 0!==r?"crossed"===r?"cross":"isolated":"crossed";const a=this.safeInteger(e,"timestamp");let o=this.safeString(e,"side");return"go_long"===o?o="long":"go_short"===o&&(o="short"),this.safePosition({info:e,id:void 0,symbol:i,notional:this.safeNumber(e,"amount"),marginMode:r,liquidationPrice:this.safeNumber(e,"liquidation_price"),entryPrice:this.safeNumber2(e,"avg_cost","entry_price"),unrealizedPnl:this.safeNumber(e,"unrealized_pnl"),contracts:this.safeNumber(e,"avail_position"),contractSize:this.safeNumber(t,"contractSize"),markPrice:this.safeNumber(e,"last"),side:o,hedged:void 0,timestamp:a,datetime:this.iso8601(a),maintenanceMargin:this.safeNumber(e,"margin"),maintenanceMarginPercentage:this.safeNumber(e,"maint_margin_ratio"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber2(e,"leverage","leverage_ratio"),marginRatio:this.safeNumber(e,"margin_ratio"),percentage:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if("swap"!==i.type)throw new r.BadSymbol(this.id+" setLeverage() supports swap contracts only");if(e<1||e>100)throw new r.BadRequest(this.id+" leverage should be between 1 and 100");const a={instrument_id:i.id,leverage:e},o=this.safeString2(this.options,"marginMode","defaultMarginMode");let n=this.safeStringLower2(s,"marginMode","defaultMarginMode",o);if(void 0!==n&&(n="cross"===n?"crossed":"isolated",a.margin_mode=n,s=this.omit(s,["marginMode","defaultMarginMode"])),"isolated"===n){const e=this.safeString(s,"side");void 0!==e?(a.side=e,s=this.omit(s,"side")):this.checkRequiredArgument("setLeverage",e,"side",["long","short"])}return await this.privateSwapPostAccountLeverage(this.extend(a,s))}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.safeCurrencyCode(e),a.currency=r.id),void 0!==t&&(a.start_timestamp=t),void 0!==s&&(a.limit=s);const o=await this.privateSwapGetAccountTransferRecord(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTransfers(n,r,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSwapGetPublicInstruments(t),i=this.safeValue(s,"data",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"instrument_id")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadRequest(this.id+" fetchMarketLeverageTiers() supports swap markets only");const i={instrument_id:s.id},a=await this.publicSwapGetPublicInstrument(this.extend(i,t)),o=this.safeValue(a,"data",{});return this.parseMarketLeverageTiers(o,s)}parseMarketLeverageTiers(e,t=void 0){const s=[],i=this.safeValue(e,"open_max_limits",{});for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(e,"instrument_id");t=this.safeMarket(o),s.push({tier:this.sum(r,1),currency:t.settle,minNotional:void 0,maxNotional:this.safeNumber(a,"max_limit"),maintenanceMarginRate:void 0,maxLeverage:this.safeNumber(a,"leverage"),info:a})}return s}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),a=this.safeBool(t,"margin",!1);let o;if([o,t]=super.handleMarginModeAndParams(e,t,s),void 0!==o){if("cross"!==o)throw new r.NotSupported(this.id+" only cross margin is supported")}else"margin"!==i&&!0!==a||(o="cross");return[o,t]}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicSpotGetCurrencies(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);for(let s=0;s<e.length;s++){const r=e[s],a=this.safeString(r,"currency"),o=this.safeCurrencyCode(a);if(void 0===t||this.inArray(o,t)){void 0===this.safeValue(i,o)&&(i[o]=this.depositWithdrawFee({}),i[o].info=[]),i[o].info.push(r);const e=this.safeString(r,"chain"),t=this.safeValue(r,"min_withdraw_fee"),s={fee:t,percentage:void 0===t&&void 0},a={fee:void 0,percentage:void 0};if(void 0!==e){const t=this.networkIdToCode(e);i[o].networks[t]={withdraw:s,deposit:a}}else i[o].withdraw=s,i[o].deposit=a}}const r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],s=this.currency(t);i[t]=this.assignDefaultDepositWithdrawFees(i[t],s)}return i}async addMargin(e,t,s={}){const i=this.safeString(s,"side");return this.checkRequiredArgument("addMargin",i,"side",["long","short"]),await this.modifyMarginHelper(e,t,1,s)}async reduceMargin(e,t,s={}){const i=this.safeString(s,"side");return this.checkRequiredArgument("reduceMargin",i,"side",["long","short"]),await this.modifyMarginHelper(e,t,2,s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.safeString(i,"side"),a=this.market(e),o={instrument_id:a.id,amount:this.numberToString(t),type:s,side:r},n=await this.privateSwapPostAccountPositionMargin(this.extend(o,i)),d=0===this.safeInteger(n,"code")?"ok":"failed",h=this.safeValue(n,"data",{});return this.extend(this.parseMarginModification(h,a),{status:d})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeInteger(e,"type");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),type:1===i?"add":"reduce",marginMode:"isolated",amount:this.safeNumber(e,"amount"),total:void 0,code:t.settle,status:void 0,timestamp:void 0,datetime:void 0}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a={};[a,i]=this.handleUntilOption("end_timestamp",a,i),void 0!==e&&(r=this.market(e),a.instrument_id=r.id),void 0!==s&&(a.limit=s),void 0!==t&&(a.start_timestamp=t);const o=await this.privateSwapGetAccountFundingFee(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseIncomes(n,r,t,s)}parseIncome(e,t=void 0){const s=this.safeString(e,"instrument_id"),i=this.safeString(e,"currency"),r=this.safeInteger(e,"timestamp");return{info:e,symbol:this.safeSymbol(s,t,void 0,"swap"),code:this.safeCurrencyCode(i),timestamp:r,datetime:this.iso8601(r),id:void 0,amount:this.safeNumber(e,"amount")}}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);"cross"===(e=e.toLowerCase())&&(e="crossed");const a={instrument_id:i.id,margin_mode:e};return await this.privateSwapPostAccountPositionMode(this.extend(a,s))}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){const o="private"===t[0],d="spot"===t[1]?"/v3":"/swap/v2",h=d+("/"+this.implodeParams(e,i));let c=this.urls.api.rest+h;const l=this.omit(i,this.extractParams(e));let u;if(u=o&&"/swap/v2"===d&&"POST"===s?JSON.stringify(i):this.urlencode(this.keysort(l)),o){let e,t;"/swap/v2"===d?(t=this.milliseconds().toString(),e=t+s+h,"GET"===s?u&&(e+="?"+u):"POST"===s&&(e+=u)):(t=this.nonce().toString(),e=u);const i=this.hmac(this.encode(e),this.encode(this.secret),n.s);"GET"===s?u&&(c+="?"+u):"POST"===s&&(r={"Content-Type":"application/x-www-form-urlencoded"},u&&(a=u)),r={"ACCESS-KEY":this.apiKey,"ACCESS-SIGN":i,"ACCESS-TIMESTAMP":t}}else u&&(c+="?"+u);return{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeString(n,"code");if("0"===c||"200"===c)return;const l=this.id+" "+o;if(void 0===c)throw new r.BadResponse(l);const u=[r.ExchangeError,l],[p,f]=this.safeValue(this.exceptions.exact,c,u);throw new p(f)}}},7057:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1352),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"exmo",name:"EXMO",countries:["LT"],rateLimit:100,version:"v1.1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!0,cancelOrder:!0,cancelOrders:!1,createDepositAddress:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledOrders:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:"emulated",fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!0,setMargin:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","45m":"45","1h":"60","2h":"120","3h":"180","4h":"240","1d":"D","1w":"W","1M":"M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg",api:{public:"https://api.exmo.com",private:"https://api.exmo.com",web:"https://exmo.me"},www:"https://exmo.me",referral:"https://exmo.me/?ref=131685",doc:["https://exmo.me/en/api_doc?ref=131685"],fees:"https://exmo.com/en/docs/fees"},api:{web:{get:["ctrl/feesAndLimits","en/docs/fees"]},public:{get:["currency","currency/list/extended","order_book","pair_settings","ticker","trades","candles_history","required_amount","payments/providers/crypto/list"]},private:{post:["user_info","order_create","order_cancel","stop_market_order_create","stop_market_order_cancel","user_open_orders","user_trades","user_cancelled_orders","order_trades","deposit_address","withdraw_crypt","withdraw_get_txid","excode_create","excode_load","code_check","wallet_history","wallet_operations","margin/user/order/create","margin/user/order/update","margin/user/order/cancel","margin/user/position/close","margin/user/position/margin_add","margin/user/position/margin_remove","margin/currency/list","margin/pair/list","margin/settings","margin/funding/list","margin/user/info","margin/user/order/list","margin/user/order/history","margin/user/order/trades","margin/user/order/max_quantity","margin/user/position/list","margin/user/position/margin_remove_info","margin/user/position/margin_add_info","margin/user/wallet/list","margin/user/wallet/history","margin/user/trade/list","margin/trades","margin/liquidation/feed"]}},fees:{trading:{feeSide:"get",tierBased:!0,percentage:!0,maker:this.parseNumber("0.004"),taker:this.parseNumber("0.004")},transaction:{tierBased:!1,percentage:!1}},options:{networks:{ETH:"ERC20",TRX:"TRC20"},fetchTradingFees:{method:"fetchPrivateTradingFees"},margin:{fillResponseFromRequest:!0}},commonCurrencies:{GMT:"GMT Token"},precisionMode:o.kb,exceptions:{exact:{140434:r.BadRequest,40005:r.AuthenticationError,40009:r.InvalidNonce,40015:r.ExchangeError,40016:r.OnMaintenance,40017:r.AuthenticationError,40032:r.PermissionDenied,40033:r.PermissionDenied,40034:r.RateLimitExceeded,50052:r.InsufficientFunds,50054:r.InsufficientFunds,50304:r.OrderNotFound,50173:r.OrderNotFound,50277:r.InvalidOrder,50319:r.InvalidOrder,50321:r.InvalidOrder,50381:r.InvalidOrder},broad:{"range period is too long":r.BadRequest,"invalid syntax":r.BadRequest,"API rate limit exceeded":r.RateLimitExceeded}}})}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a={position_id:r.id,quantity:t};let o;"add"===s?o=await this.privatePostMarginUserPositionMarginAdd(this.extend(a,i)):"reduce"===s&&(o=await this.privatePostMarginUserPositionMarginRemove(this.extend(a,i)));const n=this.parseMarginModification(o,r),d=this.safeValue(this.options,"margin",{});return this.safeBool(d,"fillResponseFromRequest",!0)&&(n.type=s,n.amount=t),n}parseMarginModification(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:this.safeValue(t,"quote"),status:"ok",timestamp:void 0,datetime:void 0}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchTradingFees(e={}){const t=this.safeValue(this.options,"fetchTradingFees",{}),s=this.safeString(t,"method","fetchPrivateTradingFees"),i=this.safeString(e,"method",s);return e=this.omit(e,"method"),"fetchPrivateTradingFees"===i?await this.fetchPrivateTradingFees(e):await this.fetchPublicTradingFees(e)}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostMarginPairList(e),s=this.safeValue(t,"pairs",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"name"),o=this.safeSymbol(r,void 0,"_"),n=this.safeString(t,"trade_maker_fee"),d=this.safeString(t,"trade_taker_fee"),h=this.parseNumber(a.Y.stringDiv(n,"100")),c=this.parseNumber(a.Y.stringDiv(d,"100"));i[o]={info:t,symbol:o,maker:h,taker:c,percentage:!0,tierBased:!0}}return i}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetPairSettings(e),s={};for(let e=0;e<this.symbols.length;e++){const i=this.symbols[e],r=this.market(i),o=this.safeValue(t,r.id,{}),n=this.safeString(o,"commission_maker_percent"),d=this.safeString(o,"commission_taker_percent"),h=this.parseNumber(a.Y.stringDiv(n,"100")),c=this.parseNumber(a.Y.stringDiv(d,"100"));s[i]={info:o,symbol:i,maker:h,taker:c,percentage:!0,tierBased:!0}}return s}parseFixedFloatValue(e){if(void 0===e||"-"===e)return;if(""===e)return 0;const t=e.indexOf("%")>=0,s=e.split(" ")[0].replace("%",""),i=parseFloat(s);if(i>0&&t)throw new r.ExchangeError(this.id+" parseFixedFloatValue() detected an unsupported non-zero percentage-based fee "+e);return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i={},r=Object.keys(s);for(let t=0;t<r.length;t++){const a=r[t];if(void 0!==e&&!this.inArray(a,e))continue;i[a]={deposit:void 0,withdraw:void 0};const o=this.currency(a),n=this.safeString(o,"id"),d=this.safeValue(s,n,[]);for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"type"),r=this.safeString(t,"commission_desc"),o=this.parseFixedFloatValue(r);i[a][s]=o}i[a].info=d}return this.options.transactionFees=i,i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPaymentsProvidersCryptoList(t),i=this.parseDepositWithdrawFees(s,e);return this.options.transactionFees=i,i}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e);for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"type"),o=this.safeString(r,"name"),n=this.networkIdToCode(o,this.safeString(t,"code")),d=this.safeString(r,"commission_desc");let h,c=[];if(void 0!==d){c=d.split("%");h=c.length>=2}void 0===this.safeValue(s.networks,n)&&(s.networks[n]={withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}),s.networks[n][a]={fee:this.parseFixedFloatValue(this.safeString(c,0)),percentage:h}}return this.assignDefaultDepositWithdrawFees(s)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyListExtended(e),s=await this.publicGetPaymentsProvidersCryptoList(e),i={};for(let e=0;e<t.length;e++){const r=t[e],o=this.safeString(r,"name"),n=this.safeString(r,"description"),d=this.safeValue(s,o);let h=!1,c="crypto";const l={deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}};let u,p,f;if(void 0===d)h=!0,c="fiat";else for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"type"),i=this.safeString(t,"min");let r=this.safeString(t,"max");a.Y.stringEq(r,"0.0")&&(r=void 0);const o=this.safeValue(t,"enabled");if("deposit"===s?o&&!p?p=!0:o||(p=!1):"withdraw"===s&&(o&&!f?f=!0:o||(f=!1)),o){h=!0;const e=this.numberToString(l[s].min);if((void 0===l[s].min||a.Y.stringLt(i,e))&&(l[s].min=i,l[s].max=r,"withdraw"===s)){const e=this.safeString(t,"commission_desc");u=this.parseFixedFloatValue(e)}}}const m=this.safeCurrencyCode(o);i[m]={id:o,code:m,name:n,type:c,active:h,deposit:p,withdraw:f,fee:u,precision:this.parseNumber("1e-8"),limits:l,info:d,networks:{}}}return i}async fetchMarkets(e={}){const t=await this.publicGetPairSettings(e);let s={};if(this.checkRequiredCredentials(!1)){const t=await this.privatePostMarginPairList(e),i=this.safeValue(t,"pairs");s=this.indexBy(i,"name")}const i=Object.keys(t),r=[];for(let e=0;e<i.length;e++){const o=i[e],n=t[o],d=this.safeValue(s,o),h=o.replace("_","/"),[c,l]=h.split("/"),u=this.safeCurrencyCode(c),p=this.safeCurrencyCode(l),f=this.safeString(n,"commission_taker_percent"),m=this.safeString(n,"commission_maker_percent"),g=this.safeString(n,"max_quantity"),v=this.safeString(d,"max_order_quantity");r.push({id:o,symbol:h,base:u,quote:p,settle:void 0,baseId:c,quoteId:l,settleId:void 0,type:"spot",spot:!0,margin:void 0!==d,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(a.Y.stringDiv(f,"100")),maker:this.parseNumber(a.Y.stringDiv(m,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber(this.parsePrecision(this.safeString(n,"price_precision")))},limits:{leverage:{min:void 0,max:this.safeNumber(n,"leverage")},amount:{min:this.safeNumber(n,"min_quantity"),max:this.parseNumber(a.Y.stringMax(g,v))},price:{min:this.safeNumber(n,"min_price"),max:this.safeNumber(n,"max_price")},cost:{min:this.safeNumber(n,"min_amount"),max:this.safeNumber(n,"max_amount")}},created:void 0,info:n})}return r}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,resolution:this.safeString(this.timeframes,t,t)},n=3e3,d=this.parseTimeframe(t),h=this.milliseconds();if(void 0===s)i=void 0===i?1e3:Math.min(i,n),o.from=this.parseToInt(h/1e3)-i*d-1,o.to=this.parseToInt(h/1e3);else{o.from=this.parseToInt(s/1e3)-1,i=void 0===i?n:Math.min(i,n);const e=this.sum(s,i*d*1e3);o.to=this.parseToInt(e/1e3)}const c=await this.publicGetCandlesHistory(this.extend(o,r)),l=this.safeList(c,"candles",[]);return this.parseOHLCVs(l,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}parseBalance(e){const t={info:e},s=this.safeValue(e,"wallets");if(void 0!==s){const e=Object.keys(s);for(let i=0;i<e.length;i++){const r=e[i],a=s[r],o=this.safeCurrencyCode(r),n=this.account();n.used=this.safeString(a,"used"),n.free=this.safeString(a,"free"),n.total=this.safeString(a,"balance"),t[o]=n}}else{const s=this.safeValue(e,"balances",{}),i=this.safeValue(e,"reserved",{}),r=Object.keys(s);for(let e=0;e<r.length;e++){const a=r[e],o=this.safeCurrencyCode(a),n=this.account();a in s&&(n.free=this.safeString(s,a)),a in i&&(n.used=this.safeString(i,a)),t[o]=n}}return this.safeBalance(t)}async fetchBalance(e={}){let t,s;if(await this.loadMarkets(),[t,e]=this.handleMarginModeAndParams("fetchBalance",e),"cross"===t)throw new r.BadRequest(this.id+" does not support cross margin");return s="isolated"===t?await this.privatePostMarginUserWalletList(e):await this.privatePostUserInfo(e),this.parseBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id};void 0!==t&&(r.limit=t);const a=await this.publicGetOrderBook(this.extend(r,s)),o=this.safeDict(a,i.id);return this.parseOrderBook(o,i.symbol,void 0,"bid","ask")}async fetchOrderBooks(e=void 0,t=void 0,s={}){let i;if(await this.loadMarkets(),void 0===e){if(i=this.ids.join(","),i.length>2048){const e=this.ids.length;throw new r.ExchangeError(this.id+" fetchOrderBooks() has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const a={pair:i};void 0!==t&&(a.limit=t);const o=await this.publicGetOrderBook(this.extend(a,s)),n={},d=Object.keys(o);for(let e=0;e<d.length;e++){const t=d[e],s=this.safeSymbol(t);n[s]=this.parseOrderBook(o[t],s,void 0,"bid","ask")}return n}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated");t=this.safeMarket(void 0,t);const i=this.safeString(e,"last_trade");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy_price"),bidVolume:void 0,ask:this.safeString(e,"sell_price"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol"),quoteVolume:this.safeString(e,"vol_curr"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTicker(t),i={},r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeMarket(t,void 0,"_"),o=a.symbol,n=this.safeValue(s,t);i[o]=this.parseTicker(n,a)}return this.filterByArrayTickers(i,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t),i=this.market(e);return this.parseTicker(s[i.id],i)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date"),i=this.safeString(e,"trade_id"),r=this.safeString(e,"order_id"),o=this.safeString(e,"price"),n=this.safeString(e,"quantity"),d=this.safeString(e,"amount"),h=this.safeString2(e,"type","trade_type"),c=this.safeString(e,"pair"),l=(t=this.safeMarket(c,t,"_")).symbol,u=this.safeValue(e,"is_maker");let p;void 0!==u&&(p=u?"maker":"taker");const f=this.safeString(e,"exec_type",p);let m;const g=this.safeString(e,"commission_amount");if(void 0!==g){const t=this.safeString(e,"commission_currency"),s=this.safeCurrencyCode(t);let i=this.safeString(e,"commission_percent");void 0!==i&&(i=a.Y.stringDiv(i,"1000",18)),m={cost:g,currency:s,rate:i}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:l,order:r,type:undefined,side:h,takerOrMaker:f,price:o,amount:n,cost:d,fee:m},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id},o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,r.id,[]);return this.parseTrades(n,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");let a;if([a,i]=this.handleMarginModeAndParams("fetchMyTrades",i),"cross"===a)throw new r.BadRequest(this.id+"only isolated margin is supported");await this.loadMarkets();const o=this.market(e).id,n="isolated"!==a;void 0===s&&(s=100);const d={};n?d.pair=o:d.pair_name=o,void 0!==s&&(d.limit=s);const h=this.safeInteger(i,"offset",0);let c;if(d.offset=h,n)c=await this.privatePostUserTrades(this.extend(d,i));else{const e=await this.privatePostMarginTrades(this.extend(d,i));c=this.safeValue(e,"trades")}let l=[];const u=Object.keys(c);for(let e=0;e<u.length;e++){const i=u[e],r=this.safeMarket(i,void 0,"_"),a=c[i],o=this.parseTrades(a,r,t,s);l=this.arrayConcat(l,o)}return this.filterBySinceLimit(l,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d="market"===t&&void 0===a;let h;if([h,o]=this.handleMarginModeAndParams("createOrder",o),"cross"===h)throw new r.BadRequest(this.id+" only supports isolated margin");const c="isolated"!==h,l=this.safeNumberN(o,["triggerPrice","stopPrice","stop_price"]),u={pair:n.id,quantity:this.amountToPrecision(n.symbol,i)};let p=this.safeValue2(o,"client_id","clientOrderId");if(void 0!==p){if(p=this.safeInteger2(o,"client_id","clientOrderId"),void 0===p)throw new r.BadRequest(this.id+" createOrder() client order id must be an integer / numeric literal");u.client_id=p}const f=this.safeNumber(o,"leverage");if(!c&&void 0===f)throw new r.ArgumentsRequired(this.id+' createOrder requires an extra param params["leverage"] for margin orders');let m;if(o=this.omit(o,["stopPrice","stop_price","triggerPrice","timeInForce","client_id","clientOrderId"]),void 0!==a&&(u.price=this.priceToPrecision(n.symbol,a)),c)if(void 0!==l){if("limit"===t)throw new r.BadRequest(this.id+" createOrder () cannot create stop limit orders for spot, only stop market");u.type=s,u.trigger_price=this.priceToPrecision(e,l),m=await this.privatePostStopMarketOrderCreate(this.extend(u,o))}else{const e=this.safeString(o,"exec_type");let i;[i,o]=this.handlePostOnly("market"===t,"post_only"===e,o);const r=this.safeString(o,"timeInForce");u.price=d?0:this.priceToPrecision(n.symbol,a),"limit"===t?u.type=s:"market"===t&&(u.type="market_"+s),i?u.exec_type="post_only":void 0!==r&&(u.exec_type=r),m=await this.privatePostOrderCreate(this.extend(u,o))}else void 0!==l?(u.stop_price=this.priceToPrecision(e,l),u.type="limit"===t?"stop_limit_"+s:"market"===t?"stop_"+s:t):u.type="limit"===t||"market"===t?t+"_"+s:t,m=await this.privatePostMarginUserOrderCreate(this.extend(u,o));return this.parseOrder(m,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},a=this.safeValue2(s,"trigger","stop");let o,n;if(s=this.omit(s,["trigger","stop"]),[o,s]=this.handleMarginModeAndParams("cancelOrder",s),"cross"===o)throw new r.BadRequest(this.id+" only supports isolated margin");return"isolated"===o?(i.order_id=e,n=await this.privatePostMarginUserOrderCancel(this.extend(i,s))):a?(i.parent_order_id=e,n=await this.privatePostStopMarketOrderCancel(this.extend(i,s))):(i.order_id=e,n=await this.privatePostOrderCancel(this.extend(i,s))),this.parseOrder(n)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e.toString()},r=await this.privatePostOrderTrades(this.extend(i,s)),a=this.parseOrder(r);return a.id=e.toString(),a}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){let o,n;if([o,a]=this.handleMarginModeAndParams("fetchOrderTrades",a),"cross"===o)throw new r.BadRequest(this.id+" only supports isolated margin");void 0!==t&&(n=this.market(t));const d={order_id:e.toString()};let h;h="isolated"===o?await this.privatePostMarginUserOrderTrades(this.extend(d,a)):await this.privatePostOrderTrades(this.extend(d,a));const c=this.safeList(h,"trades");return this.parseTrades(c,n,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol),[a,i]=this.handleMarginModeAndParams("fetchOpenOrders",i);let o,n=[];if("cross"===a||"isolated"===a){o=await this.privatePostMarginUserOrderList(i),i=this.extend(i,{status:"open"});const e=this.safeValue(o,"orders");n=this.parseOrders(e,r,t,s,i)}else{o=await this.privatePostUserOpenOrders(i);const e=Object.keys(o);for(let r=0;r<e.length;r++){const a=e[r],d=this.safeMarket(a);i=this.extend(i,{status:"open"});const h=this.parseOrders(o[a],d,t,s,i);n=this.arrayConcat(n,h)}}return n}parseStatus(e){if(void 0===e)return;return e.indexOf("cancel")>=0&&(e="canceled"),this.safeString({cancel_started:"canceled"},e,e)}parseSide(e){return this.safeString({limit_buy:"buy",limit_sell:"sell",market_buy:"buy",market_sell:"sell",stop_buy:"buy",stop_sell:"sell",stop_limit_buy:"buy",stop_limit_sell:"sell",trailing_stop_buy:"buy",trailing_stop_sell:"sell",stop_market_sell:"sell",stop_market_buy:"buy",buy:"buy",sell:"sell"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"order_id","parent_order_id"),i=this.safeIntegerProduct2(e,"event_time","created",1e-6),r=this.safeTimestamp(e,"created",i),a=this.safeString2(e,"type","order_type"),o=this.parseSide(a);let n;"pair"in e?n=e.pair:"in_currency"in e&&"out_currency"in e&&(n="buy"===o?e.in_currency+"_"+e.out_currency:e.out_currency+"_"+e.in_currency);const d=(t=this.safeMarket(n,t)).symbol;let h=this.safeString(e,"quantity");if(void 0===h){const t="buy"===o?"in_amount":"out_amount";h=this.safeString(e,t)}const c=this.safeString(e,"price"),l=this.safeString(e,"amount"),u=this.safeValue(e,"trades",[]),p=this.safeInteger(e,"client_id");let f,m=this.safeString(e,"stop_price");return"0"===m&&(m=void 0),"buy"!==a&&"sell"!==a&&(f=a),this.safeOrder({id:s,clientOrderId:p,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:this.safeIntegerProduct(e,"updated",1e-6),status:this.parseStatus(this.safeString(e,"order_status")),symbol:d,type:f,timeInForce:void 0,postOnly:void 0,side:o,price:c,stopPrice:m,triggerPrice:m,cost:l,amount:h,filled:void 0,remaining:void 0,average:void 0,trades:u,fee:void 0,info:e},t)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){let a;if(await this.loadMarkets(),[a,i]=this.handleMarginModeAndParams("fetchOrders",i),"cross"===a)throw new r.BadRequest(this.id+" only supports isolated margin");void 0===s&&(s=100);const o="isolated"!==a;if(void 0!==e){e=this.market(e).symbol}const n={limit:s};let d,h;if(n.offset=void 0!==t?s:0,n.limit=s,void 0!==e&&(d=this.market(e)),o)return h=await this.privatePostUserCancelledOrders(this.extend(n,i)),i=this.extend(i,{status:"canceled"}),this.parseOrders(h,d,t,s,i);{const e=await this.privatePostMarginUserOrderHistory(this.extend(n,i)),r=this.safeValue(e,"items"),a=this.parseOrders(r,d,t,s,i),o=[];for(let e=0;e<a.length;e++){const t=a[e];"canceled"===t.status&&o.push(t)}return o}}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);let h;if([h,n]=this.handleMarginModeAndParams("editOrder",n),"isolated"!==h)throw new r.BadRequest(this.id+" editOrder() can only be used for isolated margin orders");const c=this.safeNumberN(n,["triggerPrice","stopPrice","stop_price"]);n=this.omit(n,["triggerPrice","stopPrice"]);const l={order_id:e};void 0!==a&&(l.quantity=a),void 0!==o&&(l.price=this.priceToPrecision(d.symbol,o)),void 0!==c&&(l.stop_price=this.priceToPrecision(d.symbol,c));const u=await this.privatePostMarginUserOrderUpdate(this.extend(l,n));return this.parseOrder(u)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostDepositAddress(t),i=this.safeString(s,e);let r,a;if(i){const e=i.split(",");r=e[0];e.length>1&&(a=e[1])}return this.checkAddress(r),{currency:e,address:r,tag:a,network:void 0,info:s}}getMarketFromTrades(e){const t=this.indexBy(e,"pair"),s=Object.keys(t);if(1===s.length)return this.markets[s[0]]}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={amount:t,currency:a.id,address:s};void 0!==i&&(o.invoice=i);const n=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeString(n,d,d),void 0!==d&&(o.transport=d,r=this.omit(r,"network"));const h=await this.privatePostWithdrawCrypt(this.extend(o,r));return this.parseTransaction(h,a)}parseTransactionStatus(e){return this.safeString({transferred:"ok",paid:"ok",pending:"pending",processing:"pending",verifying:"pending"},e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp2(e,"dt","created");let i=this.safeString(e,"amount");void 0!==i&&(i=a.Y.stringAbs(i));let r=this.safeString(e,"txid");if(void 0===r){const t=this.safeValue(e,"extra",{}),s=this.safeString(t,"txid");""!==s&&(r=s)}const o=this.safeString(e,"type"),n=this.safeString2(e,"curr","currency"),d=this.safeCurrencyCode(n,t);let h,c;const l=this.safeString(e,"account");if("deposit"===o)c=l;else if("withdrawal"===o&&(h=l,void 0!==h)){const e=h.split(":");2===e.length&&(h=this.safeString(e,1),h=h.replace(" ",""))}const u={currency:void 0,cost:void 0,rate:void 0};if(!this.fees.transaction.percentage){const t="withdrawal"===o?"withdraw":"deposit";let s=this.safeString(e,"commission");if(void 0===s){const e=this.safeValue(this.options,"transactionFees",{}),i=this.safeValue(e,d,{});s=this.safeString(i,t)}"cashback"===this.safeString(e,"provider")&&(s="0"),void 0!==s&&("withdrawal"===o&&(i=a.Y.stringSub(i,s)),u.cost=this.parseNumber(s),u.currency=d)}return{info:e,id:this.safeString2(e,"order_id","task_id"),txid:r,type:o,currency:d,network:this.safeString(e,"provider"),amount:this.parseNumber(i),status:this.parseTransactionStatus(this.safeStringLower(e,"status")),timestamp:s,datetime:this.iso8601(s),address:h,addressFrom:void 0,addressTo:h,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:this.safeTimestamp(e,"updated"),comment:c,internal:void 0,fee:u}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==t&&(r.date=this.parseToInt(t/1e3)),void 0!==e&&(a=this.currency(e));const o=await this.privatePostWalletHistory(this.extend(r,i));return this.parseTransactions(o.history,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={type:"withdraw"};void 0!==s&&(a.limit=s),void 0!==e&&(r=this.currency(e),a.currency=r.id);const o=await this.privatePostWalletOperations(this.extend(a,i)),n=this.safeList(o,"items",[]);return this.parseTransactions(n,r,t,s)}async fetchWithdrawal(e,t=void 0,s={}){let i;await this.loadMarkets();const r={order_id:e,type:"withdraw"};void 0!==t&&(i=this.currency(t),r.currency=i.id);const a=await this.privatePostWalletOperations(this.extend(r,s)),o=this.safeValue(a,"items",[]),n=this.safeDict(o,0,{});return this.parseTransaction(n,i)}async fetchDeposit(e=void 0,t=void 0,s={}){let i;await this.loadMarkets();const r={order_id:e,type:"deposit"};void 0!==t&&(i=this.currency(t),r.currency=i.id);const a=await this.privatePostWalletOperations(this.extend(r,s)),o=this.safeValue(a,"items",[]),n=this.safeDict(o,0,{});return this.parseTransaction(n,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={type:"deposit"};void 0!==s&&(a.limit=s),void 0!==e&&(r=this.currency(e),a.currency=r.id);const o=await this.privatePostWalletOperations(this.extend(a,i)),n=this.safeList(o,"items",[]);return this.parseTransactions(n,r,t,s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/";if("web"!==t&&(o+=this.version+"/"),o+=e,"public"===t||"web"===t)Object.keys(i).length&&(o+="?"+this.urlencode(i));else if("private"===t){this.checkRequiredCredentials();const e=this.nonce();a=this.urlencode(this.extend({nonce:e},i)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),n.Zf)}}return{url:o,method:s,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n){if("error"in n&&!("result"in n)){const e=this.safeValue(n,"error",{}),t=this.safeString(e,"msg"),s=this.safeString(e,"code"),i=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,s,i),this.throwBroadlyMatchedException(this.exceptions.broad,t,i),new r.ExchangeError(i)}if("result"in n||"errmsg"in n){let e=this.safeBool(n,"result",!1);if("string"==typeof e&&(e="true"===e||"1"===e),!e){let e;const t=this.safeString2(n,"error","errmsg"),s=t.split(":");if(s.length>1){const t=s[0].split(" ");e=t.length>1?t[1]:t[0]}const i=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,i),this.throwBroadlyMatchedException(this.exceptions.broad,t,i),new r.ExchangeError(i)}}}}}},3042:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(7996);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"fmfwio",name:"FMFW.io",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/159177712-b685b40c-5269-4cea-ac83-f7894c49525d.jpg",api:{public:"https://api.fmfw.io/api/3",private:"https://api.fmfw.io/api/3"},www:"https://fmfw.io",doc:"https://api.fmfw.io/",fees:"https://fmfw.io/fees-and-limits",referral:"https://fmfw.io/referral/da948b21d6c92d69"},fees:{trading:{maker:this.parseNumber("0.005"),taker:this.parseNumber("0.005")}}})}}},9403:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7418),r=s(5147),a=s(1579),o=s(2079),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"gate",name:"Gate.io",countries:["KR"],rateLimit:50,version:"v4",certified:!0,pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg",doc:"https://www.gate.io/docs/developers/apiv4/en/",www:"https://gate.io/",api:{public:{wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",sub_accounts:"https://api.gateio.ws/api/v4",earn:"https://api.gateio.ws/api/v4"},private:{withdrawals:"https://api.gateio.ws/api/v4",wallet:"https://api.gateio.ws/api/v4",futures:"https://api.gateio.ws/api/v4",margin:"https://api.gateio.ws/api/v4",delivery:"https://api.gateio.ws/api/v4",spot:"https://api.gateio.ws/api/v4",options:"https://api.gateio.ws/api/v4",subAccounts:"https://api.gateio.ws/api/v4",unified:"https://api.gateio.ws/api/v4",rebate:"https://api.gateio.ws/api/v4",earn:"https://api.gateio.ws/api/v4",account:"https://api.gateio.ws/api/v4",loan:"https://api.gateio.ws/api/v4"}},test:{public:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4",options:"https://fx-api-testnet.gateio.ws/api/v4"},private:{futures:"https://fx-api-testnet.gateio.ws/api/v4",delivery:"https://fx-api-testnet.gateio.ws/api/v4",options:"https://fx-api-testnet.gateio.ws/api/v4"}},referral:{url:"https://www.gate.io/signup/2436035",discount:.2}},has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,addMargin:!0,borrowCrossMargin:!0,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!0,createMarketBuyOrderWithCost:!0,createMarketOrder:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,createTakeProfitOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchGreeks:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverages:!0,fetchLeverageTiers:!0,fetchLiquidations:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!0,fetchMySettlementHistory:!0,fetchMyTrades:!0,fetchNetworkDepositAddress:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!0,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactionFees:!0,fetchUnderlyingAssets:!0,fetchVolatilityHistory:!1,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!0,repayIsolatedMargin:!0,sandbox:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},api:{public:{wallet:{get:{currency_chains:1}},spot:{get:{currencies:1,"currencies/{currency}":1,currency_pairs:1,"currency_pairs/{currency_pair}":1,tickers:1,order_book:1,trades:1,candlesticks:1,time:1}},margin:{get:{currency_pairs:1,"currency_pairs/{currency_pair}":1,funding_book:1,"cross/currencies":1,"cross/currencies/{currency}":1,"uni/currency_pairs":1,"uni/currency_pairs/{currency_pair}":1}},flash_swap:{get:{currencies:1}},futures:{get:{"{settle}/contracts":1,"{settle}/contracts/{contract}":1,"{settle}/order_book":1,"{settle}/trades":1,"{settle}/candlesticks":1,"{settle}/premium_index":1,"{settle}/tickers":1,"{settle}/funding_rate":1,"{settle}/insurance":1,"{settle}/contract_stats":1,"{settle}/index_constituents/{index}":1,"{settle}/liq_orders":1}},delivery:{get:{"{settle}/contracts":1,"{settle}/contracts/{contract}":1,"{settle}/order_book":1,"{settle}/trades":1,"{settle}/candlesticks":1,"{settle}/tickers":1,"{settle}/insurance":1}},options:{get:{underlyings:1,expirations:1,contracts:1,"contracts/{contract}":1,settlements:1,"settlements/{contract}":1,order_book:1,tickers:1,"underlying/tickers/{underlying}":1,candlesticks:1,"underlying/candlesticks":1,trades:1}},earn:{get:{"uni/currencies":1,"uni/currencies/{currency}":1}}},private:{withdrawals:{post:{withdrawals:20},delete:{"withdrawals/{withdrawal_id}":1}},wallet:{get:{deposit_address:1,withdrawals:1,deposits:1,sub_account_transfers:1,withdraw_status:1,sub_account_balances:2.5,sub_account_margin_balances:2.5,sub_account_futures_balances:2.5,sub_account_cross_margin_balances:2.5,saved_address:1,fee:1,total_balance:2.5,small_balance:1,small_balance_history:1},post:{transfers:2.5,sub_account_transfers:2.5,sub_account_to_sub_account:2.5,small_balance:1}},subAccounts:{get:{sub_accounts:2.5,"sub_accounts/{user_id}":2.5,"sub_accounts/{user_id}/keys":2.5,"sub_accounts/{user_id}/keys/{key}":2.5},post:{sub_accounts:2.5,"sub_accounts/{user_id}/keys":2.5,"sub_accounts/{user_id}/lock":2.5,"sub_accounts/{user_id}/unlock":2.5},put:{"sub_accounts/{user_id}/keys/{key}":2.5},delete:{"sub_accounts/{user_id}/keys/{key}":2.5}},unified:{get:{accounts:20/15,account_mode:20/15,borrowable:20/15,transferable:20/15,loans:20/15,loan_records:20/15,interest_records:20/15,estimate_rate:20/15,currency_discount_tiers:20/15},post:{account_mode:20/15,loans:200/15}},spot:{get:{fee:1,batch_fee:1,accounts:1,account_book:1,open_orders:1,orders:1,"orders/{order_id}":1,my_trades:1,price_orders:1,"price_orders/{order_id}":1},post:{batch_orders:.4,cross_liquidate_orders:1,orders:.4,cancel_batch_orders:20/75,countdown_cancel_all:20/75,amend_batch_orders:.4,price_orders:.4},delete:{orders:20/75,"orders/{order_id}":20/75,price_orders:20/75,"price_orders/{order_id}":20/75},patch:{"orders/{order_id}":.4}},margin:{get:{accounts:20/15,account_book:20/15,funding_accounts:20/15,auto_repay:20/15,transferable:20/15,loans:20/15,"loans/{loan_id}":20/15,"loans/{loan_id}/repayment":20/15,loan_records:20/15,"loan_records/{loan_record_id}":20/15,borrowable:20/15,"cross/accounts":20/15,"cross/account_book":20/15,"cross/loans":20/15,"cross/loans/{loan_id}":20/15,"cross/repayments":20/15,"cross/interest_records":20/15,"cross/transferable":20/15,"cross/estimate_rate":20/15,"cross/borrowable":20/15,"uni/estimate_rate":20/15,"uni/loans":20/15,"uni/loan_records":20/15,"uni/interest_records":20/15,"uni/borrowable":20/15},post:{auto_repay:20/15,loans:20/15,merged_loans:20/15,"loans/{loan_id}/repayment":20/15,"cross/loans":20/15,"cross/repayments":20/15,"uni/loans":20/15},patch:{"loans/{loan_id}":20/15,"loan_records/{loan_record_id}":20/15},delete:{"loans/{loan_id}":20/15}},flash_swap:{get:{currencies:1,currency_pairs:1,orders:1,"orders/{order_id}":1},post:{orders:1,"orders/preview":1}},futures:{get:{"{settle}/accounts":1,"{settle}/account_book":1,"{settle}/positions":1,"{settle}/positions/{contract}":1,"{settle}/dual_comp/positions/{contract}":1,"{settle}/orders":1,"{settle}/orders_timerange":1,"{settle}/orders/{order_id}":1,"{settle}/my_trades":1,"{settle}/my_trades_timerange":1,"{settle}/position_close":1,"{settle}/liquidates":1,"{settle}/auto_deleverages":1,"{settle}/fee":1,"{settle}/risk_limit_tiers":1,"{settle}/price_orders":1,"{settle}/price_orders/{order_id}":1},post:{"{settle}/positions/{contract}/margin":1,"{settle}/positions/{contract}/leverage":1,"{settle}/positions/{contract}/risk_limit":1,"{settle}/dual_mode":1,"{settle}/dual_comp/positions/{contract}/margin":1,"{settle}/dual_comp/positions/{contract}/leverage":1,"{settle}/dual_comp/positions/{contract}/risk_limit":1,"{settle}/orders":.4,"{settle}/batch_orders":.4,"{settle}/countdown_cancel_all":.4,"{settle}/batch_cancel_orders":.4,"{settle}/price_orders":.4},put:{"{settle}/orders/{order_id}":1},delete:{"{settle}/orders":20/75,"{settle}/orders/{order_id}":20/75,"{settle}/price_orders":20/75,"{settle}/price_orders/{order_id}":20/75}},delivery:{get:{"{settle}/accounts":20/15,"{settle}/account_book":20/15,"{settle}/positions":20/15,"{settle}/positions/{contract}":20/15,"{settle}/orders":20/15,"{settle}/orders/{order_id}":20/15,"{settle}/my_trades":20/15,"{settle}/position_close":20/15,"{settle}/liquidates":20/15,"{settle}/settlements":20/15,"{settle}/price_orders":20/15,"{settle}/price_orders/{order_id}":20/15},post:{"{settle}/positions/{contract}/margin":20/15,"{settle}/positions/{contract}/leverage":20/15,"{settle}/positions/{contract}/risk_limit":20/15,"{settle}/orders":20/15,"{settle}/price_orders":20/15},delete:{"{settle}/orders":20/15,"{settle}/orders/{order_id}":20/15,"{settle}/price_orders":20/15,"{settle}/price_orders/{order_id}":20/15}},options:{get:{my_settlements:20/15,accounts:20/15,account_book:20/15,positions:20/15,"positions/{contract}":20/15,position_close:20/15,orders:20/15,"orders/{order_id}":20/15,my_trades:20/15},post:{orders:20/15},delete:{orders:20/15,"orders/{order_id}":20/15}},earn:{get:{"uni/currencies":20/15,"uni/currencies/{currency}":20/15,"uni/lends":20/15,"uni/lend_records":20/15,"uni/interests/{currency}":20/15,"uni/interest_records":20/15,"uni/interest_status/{currency}":20/15},post:{"uni/lends":20/15},put:{"uni/interest_reinvest":20/15},patch:{"uni/lends":20/15}},loan:{get:{"collateral/orders":20/15,"collateral/orders/{order_id}":20/15,"collateral/repay_records":20/15,"collateral/collaterals":20/15,"collateral/total_amount":20/15,"collateral/ltv":20/15,"collateral/currencies":20/15,"multi_collateral/orders":20/15,"multi_collateral/orders/{order_id}":20/15,"multi_collateral/repay":20/15,"multi_collateral/mortgage":20/15,"multi_collateral/currency_quota":20/15,"multi_collateral/currencies":20/15,"multi_collateral/ltv":20/15,"multi_collateral/fixed_rate":20/15},post:{"collateral/orders":20/15,"collateral/repay":20/15,"collateral/collaterals":20/15,"multi_collateral/orders":20/15,"multi_collateral/repay":20/15,"multi_collateral/mortgage":20/15}},account:{get:{detail:20/15,stp_groups:20/15,"stp_groups/{stp_id}/users":20/15},post:{stp_groups:20/15,"stp_groups/{stp_id}/users":20/15},delete:{"stp_groups/{stp_id}/users":20/15}},rebate:{get:{"agency/transaction_history":20/15,"agency/commission_history":20/15}}}},timeframes:{"10s":"10s","1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","8h":"8h","1d":"1d","7d":"7d","1w":"7d"},commonCurrencies:{"88MPH":"MPH",AXIS:"AXISDEFI",BIFI:"BITCOINFILE",BOX:"DEFIBOX",BYN:"BEYONDFI",EGG:"GOOSEFINANCE",GTC:"GAMECOM",GTC_HT:"GAMECOM_HT",GTC_BSC:"GAMECOM_BSC",HIT:"HITCHAIN",MM:"MILLION",MPH:"MORPHER",POINT:"GATEPOINT",RAI:"RAIREFLEXINDEX",SBTC:"SUPERBITCOIN",TNC:"TRINITYNETWORKCREDIT",VAI:"VAIOT",TRAC:"TRACO"},requiredCredentials:{apiKey:!0,secret:!0},headers:{"X-Gate-Channel-Id":"ccxt"},options:{sandboxMode:!1,createOrder:{expiration:86400},createMarketBuyOrderRequiresPrice:!0,networks:{AVAXC:"AVAX_C",BEP20:"BSC",EOS:"EOS",ERC20:"ETH",GATECHAIN:"GTEVM",HRC20:"HT",KUSAMA:"KSMSM",NEAR:"NEAR",OKC:"OKT",OPTIMISM:"OPETH",POLKADOT:"DOTSM",TRC20:"TRX"},timeInForce:{GTC:"gtc",IOC:"ioc",PO:"poc",POC:"poc",FOK:"fok"},accountsByType:{funding:"spot",spot:"spot",margin:"margin",cross_margin:"cross_margin",cross:"cross_margin",isolated:"margin",swap:"futures",future:"delivery",futures:"futures",delivery:"delivery",option:"options",options:"options"},swap:{fetchMarkets:{settlementCurrencies:["usdt","btc"]}},future:{fetchMarkets:{settlementCurrencies:["usdt"]}}},precisionMode:a.kb,fees:{trading:{tierBased:!0,feeSide:"get",percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00185")],[this.parseNumber("3"),this.parseNumber("0.00175")],[this.parseNumber("6"),this.parseNumber("0.00165")],[this.parseNumber("12.5"),this.parseNumber("0.00155")],[this.parseNumber("25"),this.parseNumber("0.00145")],[this.parseNumber("75"),this.parseNumber("0.00135")],[this.parseNumber("200"),this.parseNumber("0.00125")],[this.parseNumber("500"),this.parseNumber("0.00115")],[this.parseNumber("1250"),this.parseNumber("0.00105")],[this.parseNumber("2500"),this.parseNumber("0.00095")],[this.parseNumber("3000"),this.parseNumber("0.00085")],[this.parseNumber("6000"),this.parseNumber("0.00075")],[this.parseNumber("11000"),this.parseNumber("0.00065")],[this.parseNumber("20000"),this.parseNumber("0.00055")],[this.parseNumber("40000"),this.parseNumber("0.00055")],[this.parseNumber("75000"),this.parseNumber("0.00055")]],taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("1.5"),this.parseNumber("0.00195")],[this.parseNumber("3"),this.parseNumber("0.00185")],[this.parseNumber("6"),this.parseNumber("0.00175")],[this.parseNumber("12.5"),this.parseNumber("0.00165")],[this.parseNumber("25"),this.parseNumber("0.00155")],[this.parseNumber("75"),this.parseNumber("0.00145")],[this.parseNumber("200"),this.parseNumber("0.00135")],[this.parseNumber("500"),this.parseNumber("0.00125")],[this.parseNumber("1250"),this.parseNumber("0.00115")],[this.parseNumber("2500"),this.parseNumber("0.00105")],[this.parseNumber("3000"),this.parseNumber("0.00095")],[this.parseNumber("6000"),this.parseNumber("0.00085")],[this.parseNumber("11000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")],[this.parseNumber("40000"),this.parseNumber("0.00065")],[this.parseNumber("75000"),this.parseNumber("0.00065")]]}},swap:{tierBased:!0,feeSide:"base",percentage:!0,maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0005"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0000")],[this.parseNumber("1.5"),this.parseNumber("-0.00005")],[this.parseNumber("3"),this.parseNumber("-0.00005")],[this.parseNumber("6"),this.parseNumber("-0.00005")],[this.parseNumber("12.5"),this.parseNumber("-0.00005")],[this.parseNumber("25"),this.parseNumber("-0.00005")],[this.parseNumber("75"),this.parseNumber("-0.00005")],[this.parseNumber("200"),this.parseNumber("-0.00005")],[this.parseNumber("500"),this.parseNumber("-0.00005")],[this.parseNumber("1250"),this.parseNumber("-0.00005")],[this.parseNumber("2500"),this.parseNumber("-0.00005")],[this.parseNumber("3000"),this.parseNumber("-0.00008")],[this.parseNumber("6000"),this.parseNumber("-0.01000")],[this.parseNumber("11000"),this.parseNumber("-0.01002")],[this.parseNumber("20000"),this.parseNumber("-0.01005")],[this.parseNumber("40000"),this.parseNumber("-0.02000")],[this.parseNumber("75000"),this.parseNumber("-0.02005")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00050")],[this.parseNumber("1.5"),this.parseNumber("0.00048")],[this.parseNumber("3"),this.parseNumber("0.00046")],[this.parseNumber("6"),this.parseNumber("0.00044")],[this.parseNumber("12.5"),this.parseNumber("0.00042")],[this.parseNumber("25"),this.parseNumber("0.00040")],[this.parseNumber("75"),this.parseNumber("0.00038")],[this.parseNumber("200"),this.parseNumber("0.00036")],[this.parseNumber("500"),this.parseNumber("0.00034")],[this.parseNumber("1250"),this.parseNumber("0.00032")],[this.parseNumber("2500"),this.parseNumber("0.00030")],[this.parseNumber("3000"),this.parseNumber("0.00030")],[this.parseNumber("6000"),this.parseNumber("0.00030")],[this.parseNumber("11000"),this.parseNumber("0.00030")],[this.parseNumber("20000"),this.parseNumber("0.00030")],[this.parseNumber("40000"),this.parseNumber("0.00030")],[this.parseNumber("75000"),this.parseNumber("0.00030")]]}}},exceptions:{exact:{INVALID_PARAM_VALUE:o.BadRequest,INVALID_PROTOCOL:o.BadRequest,INVALID_ARGUMENT:o.BadRequest,INVALID_REQUEST_BODY:o.BadRequest,MISSING_REQUIRED_PARAM:o.ArgumentsRequired,BAD_REQUEST:o.BadRequest,INVALID_CONTENT_TYPE:o.BadRequest,NOT_ACCEPTABLE:o.BadRequest,METHOD_NOT_ALLOWED:o.BadRequest,NOT_FOUND:o.ExchangeError,AUTHENTICATION_FAILED:o.AuthenticationError,INVALID_CREDENTIALS:o.AuthenticationError,INVALID_KEY:o.AuthenticationError,IP_FORBIDDEN:o.AuthenticationError,READ_ONLY:o.PermissionDenied,INVALID_SIGNATURE:o.AuthenticationError,MISSING_REQUIRED_HEADER:o.AuthenticationError,REQUEST_EXPIRED:o.AuthenticationError,ACCOUNT_LOCKED:o.AccountSuspended,FORBIDDEN:o.PermissionDenied,SUB_ACCOUNT_NOT_FOUND:o.ExchangeError,SUB_ACCOUNT_LOCKED:o.AccountSuspended,MARGIN_BALANCE_EXCEPTION:o.ExchangeError,MARGIN_TRANSFER_FAILED:o.ExchangeError,TOO_MUCH_FUTURES_AVAILABLE:o.ExchangeError,FUTURES_BALANCE_NOT_ENOUGH:o.InsufficientFunds,ACCOUNT_EXCEPTION:o.ExchangeError,SUB_ACCOUNT_TRANSFER_FAILED:o.ExchangeError,ADDRESS_NOT_USED:o.ExchangeError,TOO_FAST:o.RateLimitExceeded,WITHDRAWAL_OVER_LIMIT:o.ExchangeError,API_WITHDRAW_DISABLED:o.ExchangeNotAvailable,INVALID_WITHDRAW_ID:o.ExchangeError,INVALID_WITHDRAW_CANCEL_STATUS:o.ExchangeError,INVALID_PRECISION:o.InvalidOrder,INVALID_CURRENCY:o.BadSymbol,INVALID_CURRENCY_PAIR:o.BadSymbol,POC_FILL_IMMEDIATELY:o.OrderImmediatelyFillable,ORDER_NOT_FOUND:o.OrderNotFound,CLIENT_ID_NOT_FOUND:o.OrderNotFound,ORDER_CLOSED:o.InvalidOrder,ORDER_CANCELLED:o.InvalidOrder,QUANTITY_NOT_ENOUGH:o.InvalidOrder,BALANCE_NOT_ENOUGH:o.InsufficientFunds,MARGIN_NOT_SUPPORTED:o.InvalidOrder,MARGIN_BALANCE_NOT_ENOUGH:o.InsufficientFunds,AMOUNT_TOO_LITTLE:o.InvalidOrder,AMOUNT_TOO_MUCH:o.InvalidOrder,REPEATED_CREATION:o.InvalidOrder,LOAN_NOT_FOUND:o.OrderNotFound,LOAN_RECORD_NOT_FOUND:o.OrderNotFound,NO_MATCHED_LOAN:o.ExchangeError,NOT_MERGEABLE:o.ExchangeError,NO_CHANGE:o.ExchangeError,REPAY_TOO_MUCH:o.ExchangeError,TOO_MANY_CURRENCY_PAIRS:o.InvalidOrder,TOO_MANY_ORDERS:o.InvalidOrder,TOO_MANY_REQUESTS:o.RateLimitExceeded,MIXED_ACCOUNT_TYPE:o.InvalidOrder,AUTO_BORROW_TOO_MUCH:o.ExchangeError,TRADE_RESTRICTED:o.InsufficientFunds,USER_NOT_FOUND:o.AccountNotEnabled,CONTRACT_NO_COUNTER:o.ExchangeError,CONTRACT_NOT_FOUND:o.BadSymbol,RISK_LIMIT_EXCEEDED:o.ExchangeError,INSUFFICIENT_AVAILABLE:o.InsufficientFunds,LIQUIDATE_IMMEDIATELY:o.InvalidOrder,LEVERAGE_TOO_HIGH:o.InvalidOrder,LEVERAGE_TOO_LOW:o.InvalidOrder,ORDER_NOT_OWNED:o.ExchangeError,ORDER_FINISHED:o.ExchangeError,POSITION_CROSS_MARGIN:o.ExchangeError,POSITION_IN_LIQUIDATION:o.ExchangeError,POSITION_IN_CLOSE:o.ExchangeError,POSITION_EMPTY:o.InvalidOrder,REMOVE_TOO_MUCH:o.ExchangeError,RISK_LIMIT_NOT_MULTIPLE:o.ExchangeError,RISK_LIMIT_TOO_HIGH:o.ExchangeError,RISK_LIMIT_TOO_lOW:o.ExchangeError,PRICE_TOO_DEVIATED:o.InvalidOrder,SIZE_TOO_LARGE:o.InvalidOrder,SIZE_TOO_SMALL:o.InvalidOrder,PRICE_OVER_LIQUIDATION:o.InvalidOrder,PRICE_OVER_BANKRUPT:o.InvalidOrder,ORDER_POC_IMMEDIATE:o.OrderImmediatelyFillable,INCREASE_POSITION:o.InvalidOrder,CONTRACT_IN_DELISTING:o.ExchangeError,INTERNAL:o.ExchangeNotAvailable,SERVER_ERROR:o.ExchangeNotAvailable,TOO_BUSY:o.ExchangeNotAvailable,CROSS_ACCOUNT_NOT_FOUND:o.ExchangeError,RISK_LIMIT_TOO_LOW:o.BadRequest,AUTO_TRIGGER_PRICE_LESS_LAST:o.InvalidOrder,AUTO_TRIGGER_PRICE_GREATE_LAST:o.InvalidOrder,POSITION_HOLDING:o.BadRequest,USER_LOAN_EXCEEDED:o.BadRequest},broad:{}}})}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}createExpiredOptionMarket(e){const t="USDT",s=t,i=e.split("-"),r=e.split("/"),a=e.split("_");let o,n=this.safeString(i,1);e.indexOf("/")>-1?o=this.safeString(r,0):(o=this.safeString(a,0),n=n.slice(2,8));const d=this.safeString(i,2),h=this.safeString(i,3),c=this.convertExpireDate(n),l=this.parse8601(c);return{id:o+"_"+t+"-20"+n+"-"+d+"-"+h,symbol:o+"/"+t+":"+s+"-"+n+"-"+d+"-"+h,base:o,quote:t,settle:s,baseId:o,quoteId:t,settleId:s,active:!1,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:this.parseNumber("1"),expiry:l,expiryDatetime:c,optionType:"C"===h?"call":"put",strike:this.parseNumber(d),precision:{amount:this.parseNumber("1"),price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.indexOf("-C")>-1||e.indexOf("-P")>-1)&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}async fetchMarkets(e={}){const t=this.safeBool(this.options,"sandboxMode",!1);let s=[this.fetchContractMarkets(e),this.fetchOptionMarkets(e)];if(!t){const t=[this.fetchSpotMarkets(e)];s=this.arrayConcat(s,t)}const i=await Promise.all(s),r=this.safeValue(i,0,[]),a=this.safeValue(i,1,[]),o=this.safeValue(i,2,[]),n=this.arrayConcat(r,a);return this.arrayConcat(n,o)}async fetchSpotMarkets(e={}){const t=await this.publicMarginGetCurrencyPairs(e),s=await this.publicSpotGetCurrencyPairs(e),i=this.indexBy(t,"id"),a=[];for(let e=0;e<s.length;e++){const t=s[e],o=this.safeString(t,"id"),n=this.safeValue(i,o),d=this.deepExtend(n,t),[h,c]=o.split("_"),l=this.safeCurrencyCode(h),u=this.safeCurrencyCode(c),p=this.safeString(d,"fee"),f=this.safeString(d,"maker_fee_rate",p),m=this.parseNumber(this.parsePrecision(this.safeString(d,"amount_precision"))),g=this.safeString(d,"trade_status"),v=void 0!==this.safeNumber(d,"leverage");a.push({id:o,symbol:l+"/"+u,base:l,quote:u,settle:void 0,baseId:h,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:v,swap:!1,future:!1,option:!1,active:"tradable"===g,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(r.Y.stringDiv(p,"100")),maker:this.parseNumber(r.Y.stringDiv(f,"100")),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:m,price:this.parseNumber(this.parsePrecision(this.safeString(d,"precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(d,"leverage",1)},amount:{min:this.safeNumber(t,"min_base_amount",m),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(d,"min_quote_amount"),max:v?this.safeNumber(d,"max_quote_amount"):void 0}},created:void 0,info:d})}return a}async fetchContractMarkets(e={}){const t=[],s=this.getSettlementCurrencies("swap","fetchMarkets"),i=this.getSettlementCurrencies("future","fetchMarkets");for(let i=0;i<s.length;i++){const r=s[i],a={settle:r},o=await this.publicFuturesGetSettleContracts(this.extend(a,e));for(let e=0;e<o.length;e++){const s=this.parseContractMarket(o[e],r);t.push(s)}}for(let s=0;s<i.length;s++){const r=i[s],a={settle:r},o=await this.publicDeliveryGetSettleContracts(this.extend(a,e));for(let e=0;e<o.length;e++){const s=this.parseContractMarket(o[e],r);t.push(s)}}return t}parseContractMarket(e,t){const s=this.safeString(e,"name"),i=s.split("_"),a=this.safeString(i,0),o=this.safeString(i,1),n=this.safeString(i,2),d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),c=this.safeCurrencyCode(t),l=this.safeTimestamp(e,"expire_time");let u="",p="swap";void 0!==n?(u=d+"/"+h+":"+c+"-"+this.yymmdd(l,""),p="future"):u=d+"/"+h+":"+c;const f=this.safeString(e,"order_price_deviate"),m=this.safeString(e,"mark_price"),g=r.Y.stringSub("1",f),v=r.Y.stringAdd("1",f),y=r.Y.stringMul(g,m),w=r.Y.stringMul(v,m),b=this.safeString(e,"taker_fee_rate"),S=this.safeString(e,"maker_fee_rate",b),k=h===c;return{id:s,symbol:u,base:d,quote:h,settle:c,baseId:a,quoteId:o,settleId:t,type:p,spot:!1,margin:!1,swap:"swap"===p,future:"future"===p,option:"option"===p,active:!0,contract:!0,linear:k,inverse:!k,taker:this.parseNumber(r.Y.stringDiv(b,"100")),maker:this.parseNumber(r.Y.stringDiv(S,"100")),contractSize:this.safeNumber(e,"quanto_multiplier"),expiry:l,expiryDatetime:this.iso8601(l),strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1"),price:this.safeNumber(e,"order_price_round")},limits:{leverage:{min:this.safeNumber(e,"leverage_min"),max:this.safeNumber(e,"leverage_max")},amount:{min:this.safeNumber(e,"order_size_min"),max:this.safeNumber(e,"order_size_max")},price:{min:this.parseNumber(y),max:this.parseNumber(w)},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchOptionMarkets(e={}){const t=[],s=await this.fetchOptionUnderlyings();for(let i=0;i<s.length;i++){const a=s[i],o=this.extend({},e);o.underlying=a;const n=await this.publicOptionsGetContracts(o);for(let e=0;e<n.length;e++){const s=n[e],i=this.safeString(s,"name"),o=a.split("_"),d=this.safeString(o,0),h=this.safeString(o,1),c=this.safeCurrencyCode(d),l=this.safeCurrencyCode(h);let u=c+"/"+l;const p=this.safeTimestamp(s,"expiration_time"),f=this.safeString(s,"strike_price"),m=this.safeValue(s,"is_call"),g=m?"C":"P",v=m?"call":"put";u=u+":"+l+"-"+this.yymmdd(p)+"-"+f+"-"+g;const y=this.safeString(s,"order_price_deviate"),w=this.safeString(s,"mark_price"),b=r.Y.stringSub("1",y),S=r.Y.stringAdd("1",y),k=r.Y.stringMul(b,w),O=r.Y.stringMul(S,w),T=this.safeString(s,"taker_fee_rate"),P=this.safeString(s,"maker_fee_rate",T);t.push({id:i,symbol:u,base:c,quote:l,settle:l,baseId:d,quoteId:h,settleId:h,type:"option",spot:!1,margin:!1,swap:!1,future:!1,option:!0,active:!0,contract:!0,linear:!0,inverse:!1,taker:this.parseNumber(r.Y.stringDiv(T,"100")),maker:this.parseNumber(r.Y.stringDiv(P,"100")),contractSize:this.parseNumber("1"),expiry:p,expiryDatetime:this.iso8601(p),strike:f,optionType:v,precision:{amount:this.parseNumber("1"),price:this.safeNumber(s,"order_price_round")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(s,"order_size_min"),max:this.safeNumber(s,"order_size_max")},price:{min:this.parseNumber(k),max:this.parseNumber(O)},cost:{min:void 0,max:void 0}},created:this.safeTimestamp(s,"create_time"),info:s})}}return t}async fetchOptionUnderlyings(){const e=await this.publicOptionsGetUnderlyings(),t=[];for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"name");void 0!==r&&t.push(r)}return t}prepareRequest(e=void 0,t=void 0,s={}){const i={};if(void 0!==e)e.contract?(i.contract=e.id,e.option||(i.settle=e.settleId)):i.currency_pair=e.id;else{const e="swap"===t;if(e||"future"===t){const t=e?"usdt":"btc",r=this.safeStringLower(s,"settle",t);s=this.omit(s,"settle"),i.settle=r}}return[i,s]}spotOrderPrepareRequest(e=void 0,t=!1,s={}){const[i,r]=this.getMarginMode(t,s),a={};if(!t){if(void 0===e)throw new o.ArgumentsRequired(this.id+" spotOrderPrepareRequest() requires a market argument for non-stop orders");a.account=i,a.currency_pair=e.id}return[a,r]}multiOrderSpotPrepareRequest(e=void 0,t=!1,s={}){const[i,r]=this.getMarginMode(t,s),a={account:i};return void 0!==e&&(t?a.market=e.id:a.currency_pair=e.id),[a,r]}getMarginMode(e,t){const s=this.safeStringLower2(this.options,"defaultMarginMode","marginMode","spot");let i=this.safeStringLower2(t,"marginMode","account",s);if(t=this.omit(t,["marginMode","account"]),"cross"===i?i="cross_margin":"isolated"===i?i="margin":""===i&&(i="spot"),e&&("spot"===i&&(i="normal"),"cross_margin"===i))throw new o.BadRequest(this.id+" getMarginMode() does not support stop orders for cross margin");return[i,t]}getSettlementCurrencies(e,t){const s=this.safeValue(this.options,e,{}),i=this.safeValue(s,t,{}),r="swap"===e?["usdt"]:["btc"];return this.safeValue(i,"settlementCurrencies",r)}async fetchCurrencies(e={}){if(void 0!==this.safeValue(this.urls,"apiBackup"))return;const t=await this.publicSpotGetCurrencies(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency"),a=this.safeStringLower(i,"currency"),o=r.split("_")[0],n=this.safeCurrencyCode(o),d=this.safeString(i,"chain");let h;void 0!==d&&(h=this.networkIdToCode(d,n));const c=this.safeValue(i,"delisted"),l=this.safeBool(i,"withdraw_disabled",!1),u=this.safeBool(i,"deposit_disabled",!1),p=this.safeBool(i,"trade_disabled",!1),f=!l,m=!u,g=!c&&!p&&f&&m;void 0===this.safeValue(s,n)&&(s[n]={id:n.toLowerCase(),code:n,info:void 0,name:void 0,active:g,deposit:m,withdraw:f,fee:void 0,fees:[],precision:this.parseNumber("1e-4"),limits:this.limits,networks:{}});let v=this.safeValue(s[n],"deposit");v=m||v;let y=this.safeValue(s[n],"withdraw");y=f||y;const w=this.safeValue(s[n],"networks",{});void 0!==h&&(w[h]={info:i,id:d,network:h,currencyId:r,lowerCaseCurrencyId:a,deposit:m,withdraw:f,active:g,fee:void 0,precision:this.parseNumber("1e-4"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}}}),s[n].networks=w;const b=this.safeValue(s[n],"info",[]);b.push(i),s[n].info=b,s[n].active=v&&y,s[n].deposit=v,s[n].withdraw=y}return s}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new o.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const[i,r]=this.prepareRequest(s,void 0,t),a=await this.publicFuturesGetSettleContractsContract(this.extend(i,r));return this.parseFundingRate(a)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const[s,i]=this.prepareRequest(void 0,"swap",t),r=await this.publicFuturesGetSettleContracts(this.extend(s,i)),a=this.parseFundingRates(r);return this.filterByArray(a,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"name"),i=this.safeSymbol(s,t,"_","swap"),r=this.safeNumber(e,"mark_price"),a=this.safeNumber(e,"index_price"),o=this.safeNumber(e,"interest_rate"),n=this.safeNumber(e,"funding_rate"),d=this.safeTimestamp(e,"funding_next_apply"),h=this.safeNumber(e,"funding_rate_indicative");return{info:e,symbol:i,markPrice:r,indexPrice:a,interestRate:o,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:n,fundingTimestamp:d,fundingDatetime:this.iso8601(d),nextFundingRate:h,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchNetworkDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privateWalletGetDepositAddress(this.extend(s,t)),r=this.safeValue(i,"multichain_addresses"),a=this.safeString(i,"currency");e=this.safeCurrencyCode(a);const o={};for(let t=0;t<r.length;t++){const s=r[t];if(this.safeInteger(s,"obtain_failed"))continue;const i=this.safeString(s,"chain"),a=this.safeString(s,"address"),n=this.safeString(s,"payment_id");o[i]={info:s,code:e,currency:e,address:a,tag:n}}return o}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeStringUpper(t,"network");t=this.omit(t,"network");const r={currency:s.id},a=await this.privateWalletGetDepositAddress(this.extend(r,t)),n=this.safeString(a,"currency");e=this.safeCurrencyCode(n);const d=this.networkCodeToId(i,e);let h,c,l;if(void 0!==d){const t=this.safeValue(a,"multichain_addresses");for(let s=0;s<t.length;s++){const i=t[s];if(d===this.safeString(i,"chain")){if(this.safeInteger(i,"obtain_failed"))break;l=this.safeString(i,"address"),c=this.safeString(i,"payment_id"),h=this.networkIdToCode(d,e);break}}}else{const e=this.safeString(a,"address");if(void 0!==e){if(e.indexOf("New address is being generated for you, please wait")>=0)throw new o.BadResponse(this.id+" New address is being generated for you, please wait a few seconds and try again to get the address.");if(e.indexOf(" ")>=0){const t=e.split(" ");l=t[0],c=t[1]}else l=e}}return this.checkAddress(l),{info:a,code:e,currency:e,address:l,tag:c,network:h}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency_pair:s.id},r=await this.privateWalletGetFee(this.extend(i,t));return this.parseTradingFee(r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateWalletGetFee(e);return this.parseTradingFees(t)}parseTradingFees(e){const t={};for(let s=0;s<this.symbols.length;s++){const i=this.symbols[s],r=this.market(i);t[i]=this.parseTradingFee(e,r)}return t}parseTradingFee(e,t=void 0){const s=this.safeValue(e,"gt_discount"),i=s?"gt_taker_fee":"taker_fee",r=s?"gt_maker_fee":"maker_fee",a=this.safeValue(t,"contract"),o=a?"futures_taker_fee":i,n=a?"futures_maker_fee":r;return{info:e,symbol:this.safeString(t,"symbol"),maker:this.safeNumber(e,n),taker:this.safeNumber(e,o),percentage:void 0,tierBased:void 0}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t),i={};let r={};for(let t=0;t<s.length;t++){r={};const a=s[t],o=this.safeString(a,"currency"),n=this.safeCurrencyCode(o);if(void 0!==e&&!this.inArray(n,e))continue;const d=this.safeValue(a,"withdraw_fix_on_chains");if(void 0===d)r=this.safeNumber(a,"withdraw_fix");else{const e=Object.keys(d);for(let t=0;t<e.length;t++){const s=e[t];r[s]=this.parseNumber(d[s])}}i[n]={withdraw:r,deposit:void 0,info:a}}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateWalletGetWithdrawStatus(t);return this.parseDepositWithdrawFees(s,e,"currency")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"withdraw_fix_on_chains"),i={info:e,withdraw:{fee:this.safeNumber(e,"withdraw_fix"),percentage:!1},deposit:{fee:this.safeNumber(e,"deposit"),percentage:!1},networks:{}};if(void 0!==s){const e=Object.keys(s);for(let t=0;t<e.length;t++){const r=e[t];i.networks[r]={withdraw:{fee:this.parseNumber(s[r]),percentage:!1},deposit:{fee:void 0,percentage:void 0}}}}return i}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol);const[a,n]=this.handleMarketTypeAndParams("fetchFundingHistory",r,i),[d,h]=this.prepareRequest(r,a,n);let c;if(d.type="fund",void 0!==t&&(d.from=this.parseToInt(t/1e3)),void 0!==s&&(d.limit=s),"swap"===a)c=await this.privateFuturesGetSettleAccountBook(this.extend(d,h));else{if("future"!==a)throw new o.NotSupported(this.id+" fetchFundingHistory() only support swap & future market type");c=await this.privateDeliveryGetSettleAccountBook(this.extend(d,h))}return this.parseFundingHistories(c,e,t,s)}parseFundingHistories(e,t,s,i){const r=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.parseFundingHistory(s);r.push(i)}const a=this.sortBy(r,"timestamp");return this.filterBySymbolSinceLimit(a,t,s,i)}parseFundingHistory(e,t=void 0){const s=this.safeTimestamp(e,"time"),i=this.safeString(e,"text");return t=this.safeMarket(i,t,"_","swap"),{info:e,symbol:this.safeString(t,"symbol"),code:this.safeString(t,"settle"),timestamp:s,datetime:this.iso8601(s),id:void 0,amount:this.safeNumber(e,"change")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),[r,a]=this.prepareRequest(i,i.type,s);let n;if(void 0!==t&&(r.limit=t),r.with_id=!0,i.spot||i.margin)n=await this.publicSpotGetOrderBook(this.extend(r,a));else if(i.swap)n=await this.publicFuturesGetSettleOrderBook(this.extend(r,a));else if(i.future)n=await this.publicDeliveryGetSettleOrderBook(this.extend(r,a));else{if(!i.option)throw new o.NotSupported(this.id+" fetchOrderBook() not support this market type");n=await this.publicOptionsGetOrderBook(this.extend(r,a))}let d=this.safeInteger(n,"current");i.spot||(d*=1e3);const h=i.spot?0:"p",c=i.spot?1:"s",l=this.safeInteger(n,"id"),u=this.parseOrderBook(n,e,d,"bids","asks",h,c);return u.nonce=l,u}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,r]=this.prepareRequest(s,void 0,t);let a,n;if(s.spot||s.margin)a=await this.publicSpotGetTickers(this.extend(i,r));else if(s.swap)a=await this.publicFuturesGetSettleTickers(this.extend(i,r));else if(s.future)a=await this.publicDeliveryGetSettleTickers(this.extend(i,r));else{if(!s.option)throw new o.NotSupported(this.id+" fetchTicker() not support this market type");{const e=s.id.split("-");i.underlying=this.safeString(e,0),a=await this.publicOptionsGetTickers(this.extend(i,r))}}if(s.option)for(let e=0;e<a.length;e++){const t=a[e];if(t.name===s.id){n=t;break}}else n=this.safeValue(a,0);return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.safeStringN(e,["currency_pair","contract","name"]),i="mark_price"in e?"contract":"spot",r=this.safeSymbol(s,t,"_",i),a=this.safeString2(e,"last","last_price"),o=this.safeStringN(e,["lowest_ask","a","ask1_price"]),n=this.safeStringN(e,["highest_bid","b","bid1_price"]),d=this.safeString(e,"high_24h"),h=this.safeString(e,"low_24h"),c=this.safeString2(e,"B","bid1_size"),l=this.safeString2(e,"A","ask1_size"),u=this.safeInteger(e,"t");let p=this.safeString2(e,"base_volume","volume_24h_base");"nan"===p&&(p="0");let f=this.safeString2(e,"quote_volume","volume_24h_quote");"nan"===f&&(f="0");const m=this.safeString(e,"change_percentage");return this.safeTicker({symbol:r,timestamp:u,datetime:this.iso8601(u),high:d,low:h,bid:n,bidVolume:c,ask:o,askVolume:l,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:m,average:void 0,baseVolume:p,quoteVolume:f,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;void 0!==s&&(i=this.market(s));const[r,a]=this.handleMarketTypeAndParams("fetchTickers",i,t),[n,d]=this.prepareRequest(void 0,r,a);let h;if(n.timezone="utc0","spot"===r||"margin"===r)h=await this.publicSpotGetTickers(this.extend(n,d));else if("swap"===r)h=await this.publicFuturesGetSettleTickers(this.extend(n,d));else if("future"===r)h=await this.publicDeliveryGetSettleTickers(this.extend(n,d));else{if("option"!==r)throw new o.NotSupported(this.id+' fetchTickers() not support this market type, provide symbols or set params["defaultType"] to one from spot/margin/swap/future/option');{this.checkRequiredArgument("fetchTickers",e,"symbols");const t=i.id.split("-");n.underlying=this.safeString(t,0),h=await this.publicOptionsGetTickers(this.extend(n,d))}}return this.parseTickers(h,e)}parseBalanceHelper(e){const t=this.account();return t.used=this.safeString2(e,"freeze","locked"),t.free=this.safeString(e,"available"),t.total=this.safeString(e,"total"),"borrowed"in e&&(t.debt=this.safeString(e,"borrowed")),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"symbol");e=this.omit(e,"symbol");const[s,i]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[r,a]=this.prepareRequest(void 0,s,i),[n,d]=this.getMarginMode(!1,a);if(void 0!==t){const e=this.market(t);r.currency_pair=e.id}let h;if("spot"===s)if("spot"===n)h=await this.privateSpotGetAccounts(this.extend(r,d));else if("margin"===n)h=await this.privateMarginGetAccounts(this.extend(r,d));else{if("cross_margin"!==n)throw new o.NotSupported(this.id+" fetchBalance() not support this marginMode");h=await this.privateMarginGetCrossAccounts(this.extend(r,d))}else if("funding"===s)h=await this.privateMarginGetFundingAccounts(this.extend(r,d));else if("swap"===s)h=await this.privateFuturesGetSettleAccounts(this.extend(r,d));else if("future"===s)h=await this.privateDeliveryGetSettleAccounts(this.extend(r,d));else{if("option"!==s)throw new o.NotSupported(this.id+" fetchBalance() not support this market type");h=await this.privateOptionsGetAccounts(this.extend(r,d))}("swap"===s||"future"===s||"option"===s)&&(h=[h]);const c={info:h},l="margin"===n;let u=h;if("balances"in u){const e=[],t=this.safeValue(u,"balances",[]),s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i],a=t[r];a.currency=r,e.push(a)}u=e}for(let e=0;e<u.length;e++){const t=u[e];if(l){const e=this.safeString(t,"currency_pair"),s=this.safeSymbol(e,void 0,"_","margin"),i=this.safeValue(t,"base",{}),r=this.safeValue(t,"quote",{}),a=this.safeCurrencyCode(this.safeString(i,"currency")),o=this.safeCurrencyCode(this.safeString(r,"currency")),n={};n[a]=this.parseBalanceHelper(i),n[o]=this.parseBalanceHelper(r),c[s]=this.safeBalance(n)}else{c[this.safeCurrencyCode(this.safeString(t,"currency"))]=this.parseBalanceHelper(t)}}return l?c:this.safeBalance(c)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e3);if(a.option)return await this.fetchOptionOHLCV(e,t,s,i,r);const n=this.safeString(r,"price");let d={};[d,r]=this.prepareRequest(a,void 0,r),d.interval=this.safeString(this.timeframes,t,t);let h=a.contract?1999:1e3;i=void 0===i?h:Math.min(i,h);let c,l=this.safeInteger(r,"until");if(void 0!==l&&(l=this.parseToInt(l/1e3),r=this.omit(r,"until")),void 0!==s){const e=this.parseTimeframe(t);d.from=this.parseToInt(s/1e3);const r=(i-1)*e,a=this.sum(d.from,r),o=this.seconds(),n=Math.min(a,o);d.to=void 0!==l?Math.min(n,l):n}else void 0!==l&&(d.to=l),d.limit=i;if(a.contract){h=1999;("mark"===n||"index"===n)&&(d.contract=n+"_"+a.id,r=this.omit(r,"price")),a.future?c=await this.publicDeliveryGetSettleCandlesticks(this.extend(d,r)):a.swap&&(c=await this.publicFuturesGetSettleCandlesticks(this.extend(d,r)))}else c=await this.publicSpotGetCandlesticks(this.extend(d,r));return this.parseOHLCVs(c,a,t,s,i)}async fetchOptionOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o={};[o,r]=this.prepareRequest(a,void 0,r),o.interval=this.safeString(this.timeframes,t,t);const n=await this.publicOptionsGetCandlesticks(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new o.BadSymbol(this.id+" fetchFundingRateHistory() supports swap contracts only");const[a,n]=this.prepareRequest(r,void 0,i);void 0!==s&&(a.limit=s);const d=await this.publicFuturesGetSettleFundingRate(this.extend(a,n)),h=[];for(let t=0;t<d.length;t++){const s=d[t],i=this.safeTimestamp(s,"t");h.push({info:s,symbol:e,fundingRate:this.safeNumber(s,"r"),timestamp:i,datetime:this.iso8601(i)})}const c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,r.symbol,t,s)}parseOHLCV(e,t=void 0){return Array.isArray(e)?[this.safeTimestamp(e,0),this.safeNumber(e,5),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,6)]:[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);const a=this.market(e),[n,d]=this.prepareRequest(a,void 0,i),h=this.safeInteger2(i,"to","until");let c;if(void 0!==h&&(i=this.omit(i,["until"]),n.to=this.parseToInt(h/1e3)),void 0!==s&&(n.limit=Math.min(s,1e3)),void 0!==t&&a.contract&&(n.from=this.parseToInt(t/1e3)),"spot"===a.type||"margin"===a.type)c=await this.publicSpotGetTrades(this.extend(n,d));else if(a.swap)c=await this.publicFuturesGetSettleTrades(this.extend(n,d));else if(a.future)c=await this.publicDeliveryGetSettleTrades(this.extend(n,d));else{if("option"!==a.type)throw new o.NotSupported(this.id+" fetchTrades() not support this market type.");c=await this.publicOptionsGetTrades(this.extend(n,d))}return this.parseTrades(c,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){if(void 0===t)throw new o.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");await this.loadMarkets();return await this.fetchMyTrades(t,s,i,{order_id:e})}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,n=!1;if([n,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),n)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);let d={};const h=void 0!==e?this.market(e):void 0,c=this.safeInteger(i,"until");i=this.omit(i,["until"]),[r,i]=this.handleMarketTypeAndParams("fetchMyTrades",h,i);let l;if("swap"===r||"future"===r||"option"===r?([d,i]=this.prepareRequest(h,r,i),"option"===r&&(i=this.omit(i,"order_id"))):(void 0!==h&&(d.currency_pair=h.id),[a,i]=this.getMarginMode(!1,i),d.account=a),void 0!==s&&(d.limit=s),void 0!==t&&(d.from=this.parseToInt(t/1e3)),void 0!==c&&(d.to=this.parseToInt(c/1e3)),"spot"===r||"margin"===r)l=await this.privateSpotGetMyTrades(this.extend(d,i));else if("swap"===r)l=await this.privateFuturesGetSettleMyTradesTimerange(this.extend(d,i));else if("future"===r)l=await this.privateDeliveryGetSettleMyTrades(this.extend(d,i));else{if("option"!==r)throw new o.NotSupported(this.id+" fetchMyTrades() not support this market type.");l=await this.privateOptionsGetMyTrades(this.extend(d,i))}return this.parseTrades(l,h,t,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","trade_id");let i=this.safeTimestamp2(e,"time","create_time");i=this.safeInteger(e,"create_time_ms",i);const a=this.safeString2(e,"currency_pair","contract"),o="contract"in e?"contract":"spot";t=this.safeMarket(a,t,"_",o);let n=this.safeString2(e,"amount","size");const d=this.safeString(e,"price"),h=r.Y.stringLt(n,"0")?"sell":"buy";n=r.Y.stringAbs(n);const c=this.safeString2(e,"side","type",h),l=this.safeString(e,"order_id"),u=this.safeString(e,"fee"),p=this.omitZero(this.safeString(e,"gt_fee")),f=this.omitZero(this.safeString(e,"point_fee")),m=[];if(void 0!==u){const s=this.safeString(e,"fee_currency");let i=this.safeCurrencyCode(s);void 0===i&&(i=this.safeString(t,"settle")),m.push({cost:u,currency:i})}void 0!==p&&m.push({cost:p,currency:"GT"}),void 0!==f&&m.push({cost:f,currency:"GatePoint"});const g=this.safeString(e,"role");return this.safeTrade({info:e,id:s,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:l,type:void 0,side:c,takerOrMaker:g,price:d,amount:n,cost:void 0,fee:void 0,fees:m},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchDeposits",e,t,s,i);let a,o={};if(void 0!==e&&(a=this.currency(e),o.currency=a.id),void 0!==s&&(o.limit=s),void 0!==t){const e=this.parseToInt(t/1e3);o.from=e,o.to=this.sum(e,2592e3)}[o,i]=this.handleUntilOption("to",o,i);const n=await this.privateWalletGetDeposits(this.extend(o,i));return this.parseTransactions(n,a)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchWithdrawals",e,t,s,i);let a,o={};if(void 0!==e&&(a=this.currency(e),o.currency=a.id),void 0!==s&&(o.limit=s),void 0!==t){const e=this.parseToInt(t/1e3);o.from=e,o.to=this.sum(e,2592e3)}[o,i]=this.handleUntilOption("to",o,i);const n=await this.privateWalletGetWithdrawals(this.extend(o,i));return this.parseTransactions(n,a)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={currency:a.id,address:s,amount:this.currencyToPrecision(e,t)};void 0!==i&&(o.memo=i);const n=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeStringLower(n,d,d),void 0!==d?(o.chain=d,r=this.omit(r,"network")):o.chain=a.id;const h=await this.privateWithdrawalsPostWithdrawals(this.extend(o,r));return this.parseTransaction(h,a)}parseTransactionStatus(e){return this.safeString({PEND:"pending",REQUEST:"pending",DMOVE:"pending",MANUAL:"pending",VERIFY:"pending",PROCES:"pending",EXTPEND:"pending",SPLITPEND:"pending",CANCEL:"canceled",FAIL:"failed",INVALID:"failed",DONE:"ok",BCODE:"ok"},e,e)}parseTransactionType(e){return this.safeString({d:"deposit",w:"withdrawal"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i,a=this.safeString(e,"amount");void 0!==s&&("b"===s[0]?(i=r.Y.stringGt(a,"0")?"deposit":"withdrawal",a=r.Y.stringAbs(a)):i=this.parseTransactionType(s[0]));const o=this.safeString(e,"fee");"withdrawal"===i&&(a=r.Y.stringSub(a,o));const n=this.safeStringUpper(e,"chain"),d=this.safeString(e,"currency"),h=this.safeCurrencyCode(d),c=this.safeString(e,"txid"),l=this.safeString(e,"status"),u=this.parseTransactionStatus(l),p=this.safeString(e,"address"),f=this.safeString(e,"memo"),m=this.safeTimestamp(e,"timestamp");return{info:e,id:s,txid:c,currency:h,amount:this.parseNumber(a),network:this.networkIdToCode(n),address:p,addressTo:void 0,addressFrom:void 0,tag:f,tagTo:void 0,tagFrom:void 0,status:u,type:i,timestamp:m,datetime:this.iso8601(m),updated:void 0,internal:void 0,comment:void 0,fee:{currency:h,cost:this.parseNumber(o)}}}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeValue(a,"trigger"),d=this.safeValue2(a,"triggerPrice","stopPrice"),h=this.safeValue(a,"stopLossPrice",d),c=this.safeValue(a,"takeProfitPrice"),l=!(void 0!==h||void 0!==c)&&void 0===n,u=this.createOrderRequest(e,t,s,i,r,a);let p;return p=o.spot||o.margin?l?await this.privateSpotPostOrders(u):await this.privateSpotPostPriceOrders(u):o.swap?l?await this.privateFuturesPostSettleOrders(u):await this.privateFuturesPostSettlePriceOrders(u):o.future?l?await this.privateDeliveryPostSettleOrders(u):await this.privateDeliveryPostSettlePriceOrders(u):await this.privateOptionsPostOrders(u),this.parseOrder(p,o)}createOrdersRequest(e,t={}){const s=[],i=[],r=e.length;if(0===r)throw new o.BadRequest(this.id+" createOrders() requires at least one order");if(r>10)throw new o.BadRequest(this.id+" createOrders() accepts a maximum of 10 orders at a time");for(let r=0;r<e.length;r++){const a=e[r],n=this.safeString(a,"symbol");i.push(n);const d=this.safeString(a,"type"),h=this.safeString(a,"side"),c=this.safeValue(a,"amount"),l=this.safeValue(a,"price"),u=this.safeValue(a,"params",{}),p=this.extend(u,t);if(void 0!==this.safeValueN(u,["triggerPrice","stopPrice","takeProfitPrice","stopLossPrice"]))throw new o.NotSupported(this.id+" createOrders() does not support advanced order properties (stopPrice, takeProfitPrice, stopLossPrice)");p.textIsRequired=!0;const f=this.createOrderRequest(n,d,h,c,l,p);s.push(f)}const a=this.marketSymbols(i,void 0,!1,!0,!0),n=this.market(a[0]);if(n.future||n.option)throw new o.NotSupported(this.id+" createOrders() does not support futures or options markets");return s}async createOrders(e,t={}){await this.loadMarkets();const s=this.createOrdersRequest(e,t),i=e[0],r=this.market(i.symbol);let a;return r.spot?a=await this.privateSpotPostBatchOrders(s):r.swap&&(a=await this.privateFuturesPostSettleBatchOrders(s)),this.parseOrders(a)}createOrderRequest(e,t,s,i,a=void 0,n={}){const d=this.market(e),h=d.contract,c=this.safeValue(n,"trigger"),l=this.safeValue2(n,"triggerPrice","stopPrice"),u=this.safeValue(n,"stopLossPrice",l),p=this.safeValue(n,"takeProfitPrice"),f=void 0!==u,m=void 0!==p,g=f||m;if(f&&m)throw new o.ExchangeError(this.id+" createOrder() stopLossPrice and takeProfitPrice cannot both be defined");const v=this.safeValue(n,"reduceOnly"),y=this.safeStringLowerN(n,["timeInForce","tif","time_in_force"]);let w;[w,n]=this.handlePostOnly("market"===t,"poc"===y,n);let b=this.handleTimeInForce(n);w&&(b="poc"),n=this.omit(n,["stopPrice","triggerPrice","stopLossPrice","takeProfitPrice","reduceOnly","timeInForce","postOnly"]);const S="limit"===t,k="market"===t;if(S&&void 0===a)throw new o.ArgumentsRequired(this.id+" createOrder () requires a price argument for "+t+" orders");if(k){if("poc"===b||"gtc"===b)throw new o.ExchangeError(this.id+' createOrder () timeInForce for market order can only be "FOK" or "IOC"');if(void 0===b){const e=this.safeString(this.options,"defaultTimeInForce","IOC");b=this.safeString(this.options.timeInForce,e,"ioc")}h&&(a=0)}if(h){if(this.safeValue(n,"close"))i=0;else{const t=this.amountToPrecision(e,i),a="sell"===s?r.Y.stringNeg(t):t;i=parseInt(a)}}let O;if(!g&&void 0===c){if(h)O={contract:d.id,size:i},d.option||(O.settle=d.settleId),O.price=k?a:0===a?"0":this.priceToPrecision(e,a),void 0!==v&&(O.reduce_only=v),void 0!==b&&(O.tif=b);else{let h;if([h,n]=this.getMarginMode(!1,n),O={currency_pair:d.id,type:t,account:h,side:s},k&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===a)throw new o.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),o=this.numberToString(a),n=r.Y.stringMul(s,o);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);O.amount=t}else O.amount=this.amountToPrecision(e,i);S&&(O.price=this.priceToPrecision(e,a)),void 0!==b&&(O.time_in_force=b)}let c=this.safeString2(n,"text","clientOrderId");const l=this.safeBool(n,"textIsRequired",!1);if(void 0!==c){if(c.length>28)throw new o.BadRequest(this.id+" createOrder () clientOrderId or text param must be up to 28 characters");n=this.omit(n,["text","clientOrderId","textIsRequired"]),"t"!==c[0]&&(c="t-"+c),O.text=c}else l&&(O.text="t-"+this.uuid16())}else{if(d.option)throw new o.NotSupported(this.id+" createOrder() conditional option orders are not supported");if(h){if(O={initial:{contract:d.id,size:i},settle:d.settleId},O.initial.price="market"===t||0===a?"0":this.priceToPrecision(e,a),void 0===c){let t,i;f?(t="buy"===s?1:2,i=this.priceToPrecision(e,u)):m&&(t="buy"===s?2:1,i=this.priceToPrecision(e,p));const r=this.safeInteger(n,"price_type",0);if(r<0||r>2)throw new o.BadRequest(this.id+" createOrder () price_type should be 0 latest deal price, 1 mark price, 2 index price");n=this.omit(n,["price_type"]),O.trigger={price_type:r,price:this.priceToPrecision(e,i),rule:t}}void 0!==v&&(O.initial.reduce_only=v),void 0!==b&&(O.initial.tif=b)}else{const r=this.safeValue(this.options,"createOrder",{});let o;if([o,n]=this.getMarginMode(!0,n),void 0===b&&(b="gtc"),O={put:{type:t,side:s,price:this.priceToPrecision(e,a),amount:this.amountToPrecision(e,i),account:o,time_in_force:b},market:d.id},void 0===c){const t=this.safeInteger(r,"expiration"),i=this.safeInteger(n,"expiration",t);let a,o;f?(a="buy"===s?">=":"<=",o=this.priceToPrecision(e,u)):m&&(a="buy"===s?"<=":">=",o=this.priceToPrecision(e,p)),O.trigger={price:this.priceToPrecision(e,o),rule:a,expiration:i}}}}return this.extend(O,n)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new o.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}editOrderRequest(e,t,s,i,a=void 0,n=void 0,d={}){const h=this.market(t),[c,l]=this.handleMarketTypeAndParams("editOrder",h,d),u=this.convertTypeToAccount(c);if("spot"===u&&!("limit"===s))throw new o.InvalidOrder(this.id+" editOrder() does not support "+s+" orders for "+c+" markets");const p={order_id:e.toString(),currency_pair:h.id,account:u};return void 0!==a&&(h.spot?p.amount=this.amountToPrecision(t,a):p.size="sell"===i?this.parseToNumeric(r.Y.stringNeg(this.amountToPrecision(t,a))):this.parseToNumeric(this.amountToPrecision(t,a))),void 0!==n&&(p.price=this.priceToPrecision(t,n)),h.spot||(p.settle=h.settleId),this.extend(p,l)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editOrderRequest(e,t,s,i,r,a,o);let h;return h=n.spot?await this.privateSpotPatchOrdersOrderId(d):await this.privateFuturesPutSettleOrdersOrderId(d),this.parseOrder(h,n)}parseOrderStatus(e){return this.safeString({open:"open",_new:"open",filled:"closed",cancelled:"canceled",liquidated:"closed",ioc:"canceled",failed:"canceled",expired:"canceled",finished:"closed",finish:"closed",succeeded:"closed"},e,e)}parseOrder(e,t=void 0){if(!this.safeBool(e,"succeeded",!0))return this.safeOrder({clientOrderId:this.safeString(e,"text"),info:e,status:"rejected",id:this.safeString(e,"id")});const s=this.safeValue2(e,"put","initial",{}),i=this.safeValue(e,"trigger",{});let a=this.safeString(s,"contract"),o=this.safeString(s,"type"),n=this.safeStringUpper2(s,"time_in_force","tif"),d=this.safeString2(s,"amount","size"),h=this.safeString(s,"side"),c=this.safeString(s,"price");a=this.safeString(e,"contract",a),o=this.safeString(e,"type",o),n=this.safeStringUpper2(e,"time_in_force","tif",n),"POC"===n&&(n="PO");const l="PO"===n;d=this.safeString2(e,"amount","size",d),h=this.safeString(e,"side",h),c=this.safeString(e,"price",c);let u=this.safeString(e,"left"),p=this.safeString(e,"filled_total");const f=this.safeNumber(i,"price");let m=this.safeNumber2(e,"avg_deal_price","fill_price");if(f&&(u=d,p="0"),a){o=r.Y.stringEquals(c,"0")&&"IOC"===n?"market":"limit",h=r.Y.stringGt(d,"0")?"buy":"sell"}const g=this.safeStringN(e,["finish_as","status","open"]);let v=this.safeInteger(e,"create_time_ms");void 0===v&&(v=this.safeTimestamp2(e,"create_time","ctime"));let y=this.safeInteger(e,"update_time_ms");void 0===y&&(y=this.safeTimestamp2(e,"update_time","finish_time"));let w="contract";("currency_pair"in e||"market"in e)&&(w="spot");const b=this.safeString2(e,"currency_pair","market",a),S=this.safeSymbol(b,t,"_",w),k=[],O=this.safeString(e,"gt_fee");O&&k.push({currency:"GT",cost:O});const T=this.safeString(e,"fee");T&&k.push({currency:this.safeCurrencyCode(this.safeString(e,"fee_currency")),cost:T});const P=this.safeString(e,"rebated_fee");P&&k.push({currency:this.safeCurrencyCode(this.safeString(e,"rebated_fee_currency")),cost:r.Y.stringNeg(P)});const I=k.length>1,x=this.parseOrderStatus(g);let A=r.Y.stringAbs(u);if("spot"===this.safeString(e,"account")){const t=this.safeString(e,"avg_deal_price");m=this.parseNumber(t),"market"===o&&"buy"===h&&(A=r.Y.stringDiv(u,t),c=void 0,p=d,d=r.Y.stringDiv(d,t))}return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"text"),timestamp:v,datetime:this.iso8601(v),lastTradeTimestamp:y,status:x,symbol:S,type:o,timeInForce:n,postOnly:l,reduceOnly:this.safeValue(e,"is_reduce_only"),side:h,price:c,stopPrice:f,triggerPrice:f,average:m,amount:r.Y.stringAbs(d),cost:r.Y.stringAbs(p),filled:void 0,remaining:A,fee:I?void 0:this.safeValue(k,0),fees:I?k:[],trades:void 0,info:e},t)}fetchOrderRequest(e,t=void 0,s={}){const i=void 0===t?void 0:this.market(t),r=this.safeBoolN(s,["trigger","is_stop_order","stop"],!1);s=this.omit(s,["is_stop_order","stop","trigger"]);let a=this.safeString2(s,"text","clientOrderId"),o=e;void 0!==a&&(s=this.omit(s,["text","clientOrderId"]),"t"!==a[0]&&(a="t-"+a),o=a);const[n,d]=this.handleMarketTypeAndParams("fetchOrder",i,s),h="swap"===n||"future"===n||"option"===n,[c,l]=h?this.prepareRequest(i,n,d):this.spotOrderPrepareRequest(i,r,d);return c.order_id=o.toString(),[c,l]}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=void 0===t?void 0:this.market(t),r=this.handleMarketTypeAndParams("fetchOrder",i,s),a=this.safeString(r,0),n=this.safeBoolN(s,["trigger","is_stop_order","stop"],!1),[d,h]=this.fetchOrderRequest(e,t,s);let c;if("spot"===a||"margin"===a)c=n?await this.privateSpotGetPriceOrdersOrderId(this.extend(d,h)):await this.privateSpotGetOrdersOrderId(this.extend(d,h));else if("swap"===a)c=n?await this.privateFuturesGetSettlePriceOrdersOrderId(this.extend(d,h)):await this.privateFuturesGetSettleOrdersOrderId(this.extend(d,h));else if("future"===a)c=n?await this.privateDeliveryGetSettlePriceOrdersOrderId(this.extend(d,h)):await this.privateDeliveryGetSettleOrdersOrderId(this.extend(d,h));else{if("option"!==a)throw new o.NotSupported(this.id+" fetchOrder() not support this market type");c=await this.privateOptionsGetOrdersOrderId(this.extend(d,h))}return this.parseOrder(c,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("finished",e,t,s,i)}fetchOrdersByStatusRequest(e,t=void 0,s=void 0,i=void 0,r={}){let a;void 0!==t&&(a=this.market(t),t=a.symbol);const o=this.safeBool2(r,"stop","trigger");r=this.omit(r,["stop","trigger"]);const[n,d]=this.handleMarketTypeAndParams("fetchOrdersByStatus",a,r),h="spot"===n||"margin"===n,[c,l]=h?this.multiOrderSpotPrepareRequest(a,o,d):this.prepareRequest(a,n,d);"closed"===e&&(e="finished"),c.status=e,void 0!==i&&(c.limit=i),void 0!==s&&h&&(c.from=this.parseToInt(s/1e3));const[u,p]=this.handleParamString2(l,"lastId","last_id");return void 0!==u&&(c.last_id=u),[c,p]}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t),t=a.symbol);const n=this.safeBool2(r,"stop","trigger");r=this.omit(r,["trigger","stop"]);const d=this.handleMarketTypeAndParams("fetchOrdersByStatus",a,r),h=this.safeString(d,0);r.type=h;const[c,l]=this.fetchOrdersByStatusRequest(e,t,s,i,r),u=("spot"===h||"margin"===h)&&"open"===e&&!n;let p;if("spot"===h||"margin"===h)p=u?await this.privateSpotGetOpenOrders(this.extend(c,l)):n?await this.privateSpotGetPriceOrders(this.extend(c,l)):await this.privateSpotGetOrders(this.extend(c,l));else if("swap"===h)p=n?await this.privateFuturesGetSettlePriceOrders(this.extend(c,l)):await this.privateFuturesGetSettleOrders(this.extend(c,l));else if("future"===h)p=n?await this.privateDeliveryGetSettlePriceOrders(this.extend(c,l)):await this.privateDeliveryGetSettleOrders(this.extend(c,l));else{if("option"!==h)throw new o.NotSupported(this.id+" fetchOrders() not support this market type");p=await this.privateOptionsGetOrders(this.extend(c,l))}let f=p;if(u){f=[];for(let e=0;e<p.length;e++){const t=this.safeValue(p[e],"orders");f=this.arrayConcat(f,t)}}const m=this.parseOrders(f,a,s,i);return this.filterBySymbolSinceLimit(m,t,s,i)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=void 0===t?void 0:this.market(t),r=this.safeBoolN(s,["is_stop_order","stop","trigger"],!1);s=this.omit(s,["is_stop_order","stop","trigger"]);const[a,n]=this.handleMarketTypeAndParams("cancelOrder",i,s),[d,h]="spot"===a||"margin"===a?this.spotOrderPrepareRequest(i,r,n):this.prepareRequest(i,a,n);let c;if(d.order_id=e,"spot"===a||"margin"===a)c=r?await this.privateSpotDeletePriceOrdersOrderId(this.extend(d,h)):await this.privateSpotDeleteOrdersOrderId(this.extend(d,h));else if("swap"===a)c=r?await this.privateFuturesDeleteSettlePriceOrdersOrderId(this.extend(d,h)):await this.privateFuturesDeleteSettleOrdersOrderId(this.extend(d,h));else if("future"===a)c=r?await this.privateDeliveryDeleteSettlePriceOrdersOrderId(this.extend(d,h)):await this.privateDeliveryDeleteSettleOrdersOrderId(this.extend(d,h));else{if("option"!==a)throw new o.NotSupported(this.id+" cancelOrder() not support this market type");c=await this.privateOptionsDeleteOrdersOrderId(this.extend(d,h))}return this.parseOrder(c,i)}async cancelOrders(e,t=void 0,s={}){let i,r;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const a=void 0===i?"usdt":i.settle,n=this.safeStringLower(s,"settle",a);[r,s]=this.handleMarketTypeAndParams("cancelOrders",i,s);const d="spot"===r;if(d&&void 0===t)throw new o.ArgumentsRequired(this.id+" cancelOrders requires a symbol argument for spot markets");if(d){const i=[];for(let s=0;s<e.length;s++){const r={id:e[s],symbol:t};i.push(r)}return await this.cancelOrdersForSymbols(i,s)}const h=[{settle:n}];for(let t=0;t<e.length;t++)h.push(e[t]);const c=await this.privateFuturesPostSettleBatchCancelOrders(h);return this.parseOrders(c)}async cancelOrdersForSymbols(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.market(r);if(!a.spot)throw new o.NotSupported(this.id+" cancelOrdersForSymbols() supports only spot markets");const n={id:this.safeString(i,"id"),currency_pair:a.id};s.push(n)}const i=await this.privateSpotPostCancelBatchOrders(s);return this.parseOrders(i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=void 0===e?void 0:this.market(e),i=this.safeBool2(t,"stop","trigger");t=this.omit(t,["stop","trigger"]);const[r,a]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[n,d]="spot"===r?this.multiOrderSpotPrepareRequest(s,i,a):this.prepareRequest(s,r,a);let h;if("spot"===r||"margin"===r)h=i?await this.privateSpotDeletePriceOrders(this.extend(n,d)):await this.privateSpotDeleteOrders(this.extend(n,d));else if("swap"===r)h=i?await this.privateFuturesDeleteSettlePriceOrders(this.extend(n,d)):await this.privateFuturesDeleteSettleOrders(this.extend(n,d));else if("future"===r)h=i?await this.privateDeliveryDeleteSettlePriceOrders(this.extend(n,d)):await this.privateDeliveryDeleteSettleOrders(this.extend(n,d));else{if("option"!==r)throw new o.NotSupported(this.id+" cancelAllOrders() not support this market type");h=await this.privateOptionsDeleteOrders(this.extend(n,d))}return this.parseOrders(h,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),n=this.convertTypeToAccount(s),d=this.convertTypeToAccount(i),h=this.currencyToPrecision(e,t),c={currency:a.id,amount:h};if(n in this.options.accountsByType?c.from=n:(c.from="margin",c.currency_pair=n),d in this.options.accountsByType?c.to=d:(c.to="margin",c.currency_pair=d),"margin"===n||"margin"===d){const e=this.safeString2(r,"symbol","currency_pair");if(void 0===e)throw new o.ArgumentsRequired(this.id+' transfer requires params["symbol"] for isolated margin transfers');const t=this.market(e);c.currency_pair=t.id,r=this.omit(r,"symbol")}"futures"!==d&&"delivery"!==d&&"futures"!==n&&"delivery"!==n||(c.settle=a.id);const l=await this.privateWalletPostTransfers(this.extend(c,r));return this.parseTransfer(l,a)}parseTransfer(e,t=void 0){return{id:this.safeString(e,"tx_id"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<0||e>100)throw new o.BadRequest(this.id+" setLeverage() leverage should be between 1 and 100");await this.loadMarkets();const i=this.market(t),[r,a]=this.prepareRequest(i,void 0,s),n=this.safeString2(this.options,"marginMode","defaultMarginMode"),d=this.safeString(a,"cross_leverage_limit");let h,c=this.safeString(a,"marginMode",n),l=this.numberToString(e);if(void 0!==d&&(c="cross",l=d),"cross"===c||"cross_margin"===c?(r.cross_leverage_limit=l,r.leverage="0"):r.leverage=l,i.swap)h=await this.privateFuturesPostSettlePositionsContractLeverage(this.extend(r,a));else{if(!i.future)throw new o.NotSupported(this.id+" setLeverage() not support this market type");h=await this.privateDeliveryPostSettlePositionsContractLeverage(this.extend(r,a))}return h}parsePosition(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t,"_","contract");const i=this.safeString2(e,"size","accum_size");let a=this.safeString(e,"side");void 0===a&&(r.Y.stringGt(i,"0")?a="long":r.Y.stringLt(i,"0")&&(a="short"));const o=this.safeString(e,"maintenance_rate"),n=this.safeString(e,"value"),d=this.safeString(e,"leverage");let h;void 0!==d&&(h="0"===d?"cross":"isolated");let c,l=this.safeString(e,"pnl_fee");if(void 0===l){const e="0.00075";l=r.Y.stringMul(e,n),c=r.Y.stringAdd(r.Y.stringDiv(n,d),l)}let u=this.safeTimestamp2(e,"open_time","first_open_time");return 0===u&&(u=void 0),this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:u,datetime:this.iso8601(u),lastUpdateTimestamp:this.safeTimestamp2(e,"update_time","time"),initialMargin:this.parseNumber(c),initialMarginPercentage:this.parseNumber(r.Y.stringDiv(c,n)),maintenanceMargin:this.parseNumber(r.Y.stringMul(o,n)),maintenanceMarginPercentage:this.parseNumber(o),entryPrice:this.safeNumber(e,"entry_price"),notional:this.parseNumber(n),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.safeNumber(e,"unrealised_pnl"),realizedPnl:this.safeNumber2(e,"realised_pnl","pnl"),contracts:this.parseNumber(r.Y.stringAbs(i)),contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liq_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:void 0,collateral:this.safeNumber(e,"margin"),marginMode:h,side:a,percentage:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new o.BadRequest(this.id+" fetchPosition() supports contract markets only");let i={};[i,t]=this.prepareRequest(s,s.type,t);const r=this.extend(i,t);let a;return s.swap?a=await this.privateFuturesGetSettlePositionsContract(r):s.future?a=await this.privateDeliveryGetSettlePositionsContract(r):"option"===s.type&&(a=await this.privateOptionsGetPositionsContract(r)),this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){let s,i;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e,void 0,!0,!0,!0))){e.length>0&&(s=this.market(e[0]))}let r,a={};if([i,t]=this.handleMarketTypeAndParams("fetchPositions",s,t),void 0!==i&&"spot"!==i||(i="swap"),"option"===i){if(void 0!==e){const e=s.id.split("-");a.underlying=this.safeString(e,0)}}else[a,t]=this.prepareRequest(void 0,i,t);return"swap"===i?r=await this.privateFuturesGetSettlePositions(this.extend(a,t)):"future"===i?r=await this.privateDeliveryGetSettlePositions(this.extend(a,t)):"option"===i&&(r=await this.privateOptionsGetPositions(this.extend(a,t))),this.parsePositions(r,e)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const[s,i]=this.handleMarketTypeAndParams("fetchLeverageTiers",void 0,t),[r,a]=this.prepareRequest(void 0,s,i);if("future"!==s&&"swap"!==s)throw new o.BadRequest(this.id+" fetchLeverageTiers only supports swap and future");let n;if("swap"===s)n=await this.publicFuturesGetSettleContracts(this.extend(r,a));else{if("future"!==s)throw new o.NotSupported(this.id+" fetchLeverageTiers() not support this market type");n=await this.publicDeliveryGetSettleContracts(this.extend(r,a))}return this.parseLeverageTiers(n,e,"name")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),[i,r]=this.handleMarketTypeAndParams("fetchMarketLeverageTiers",s,t),[a,n]=this.prepareRequest(s,i,r);if("future"!==i&&"swap"!==i)throw new o.BadRequest(this.id+" fetchMarketLeverageTiers only supports swap and future");const d=await this.privateFuturesGetSettleRiskLimitTiers(this.extend(a,n));return this.parseMarketLeverageTiers(d,s)}parseEmulatedLeverageTiers(e,t=void 0){const s=this.safeString(e,"maintenance_rate"),i=this.safeString(e,"leverage_max"),a=this.safeString(e,"risk_limit_step"),o=this.safeString(e,"risk_limit_max"),n=r.Y.stringDiv("1",i);let d=s,h=n,c="0";const l=[];for(;r.Y.stringLt(c,o);){const i=r.Y.stringAdd(c,a);l.push({tier:this.parseNumber(r.Y.stringDiv(i,a)),currency:this.safeString(t,"settle"),minNotional:this.parseNumber(c),maxNotional:this.parseNumber(i),maintenanceMarginRate:this.parseNumber(d),maxLeverage:this.parseNumber(r.Y.stringDiv("1",h)),info:e}),d=r.Y.stringAdd(d,s),h=r.Y.stringAdd(h,n),c=i}return l}parseMarketLeverageTiers(e,t=void 0){if(!Array.isArray(e))return this.parseEmulatedLeverageTiers(e,t);let s=0;const i=[];for(let r=0;r<e.length;r++){const a=e[r],o=this.safeNumber(a,"risk_limit");i.push({tier:this.sum(r,1),currency:t.base,minNotional:s,maxNotional:o,maintenanceMarginRate:this.safeNumber(a,"maintenance_rate"),maxLeverage:this.safeNumber(a,"leverage_max"),info:a}),s=o}return i}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a={currency:r.id.toUpperCase(),amount:this.currencyToPrecision(t,s)},o=this.market(e);a.currency_pair=o.id,a.type="repay";const n=await this.privateMarginPostUniLoans(this.extend(a,i));return this.parseMarginLoan(n,r)}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={currency:i.id.toUpperCase(),amount:this.currencyToPrecision(e,t)};let a=await this.privateMarginPostCrossRepayments(this.extend(r,s));return a=this.safeValue(a,0),this.parseMarginLoan(a,i)}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a={currency:r.id.toUpperCase(),amount:this.currencyToPrecision(t,s)};let o;const n=this.market(e);return a.currency_pair=n.id,a.type="borrow",o=await this.privateMarginPostUniLoans(this.extend(a,i)),this.parseMarginLoan(o,r)}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={currency:i.id.toUpperCase(),amount:this.currencyToPrecision(e,t)},a=await this.privateMarginPostCrossLoans(this.extend(r,s));return this.parseMarginLoan(a,i)}parseMarginLoan(e,t=void 0){const s=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let i=this.safeInteger(e,"create_time");"isolated"===s&&(i=this.safeTimestamp(e,"create_time"));const r=this.safeString(e,"currency"),a=this.safeString(e,"currency_pair");return{id:this.safeInteger(e,"id"),currency:this.safeCurrencyCode(r,t),amount:this.safeNumber(e,"amount"),symbol:this.safeSymbol(a,void 0,"_","margin"),timestamp:i,datetime:this.iso8601(i),info:e}}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){const d=t[0],h=t[1];let c=this.omit(i,this.extractParams(e));if(e.indexOf("settle")>-1&&e.endsWith("batch_cancel_orders")){const t=this.safeDict(i,0);e=this.implodeParams(e,t);const s=[],r=i;for(let e=1;e<r.length;e++)s.push(i[e]);i=s,c=s}else if(Array.isArray(i)){const t=this.safeValue(i,0,{});e=this.implodeParams(e,t)}else e=this.implodeParams(e,i);const l=""===e?"":"/"+e;let u="/"+h+l;"subAccounts"!==h&&"withdrawals"!==h||(u=l);let p=this.urls.api[d][h];if(void 0===p)throw new o.NotSupported(this.id+" does not have a testnet for the "+h+" market type.");if(p+=u,"public"===d)Object.keys(c).length&&(p+="?"+this.urlencode(c));else{this.checkRequiredCredentials();let t="",i=!1;if(("futures"===h||"delivery"===h)&&"POST"===s){const t=e.split("/"),s=this.safeString(t,1,"");i=s.indexOf("dual")>=0||s.indexOf("positions")>=0}if("GET"===s||"DELETE"===s||i||"PATCH"===s)Object.keys(c).length&&(t=this.urlencode(c),p+="?"+t),"PATCH"===s&&(a=this.json(c));else{const e=this.safeValue(c,"query",{});Object.keys(e).length&&(t=this.urlencode(e),p+="?"+t),c=this.omit(c,"query"),a=this.json(c)}const o=void 0===a?"":a,d=this.hash(this.encode(o),n.Zf),l=this.seconds().toString(),f="/api/"+this.version+u,m=[s.toUpperCase(),f,t,d,l].join("\n"),g=this.hmac(this.encode(m),this.encode(this.secret),n.Zf);r={KEY:this.apiKey,Timestamp:l,SIGN:g,"Content-Type":"application/json"}}return{url:p,method:s,body:a,headers:r}}async modifyMarginHelper(e,t,s={}){await this.loadMarkets();const i=this.market(e),[r,a]=this.prepareRequest(i,void 0,s);let n;if(r.change=this.numberToString(t),i.swap)n=await this.privateFuturesPostSettlePositionsContractMargin(this.extend(r,a));else{if(!i.future)throw new o.NotSupported(this.id+" modifyMarginHelper() not support this market type");n=await this.privateDeliveryPostSettlePositionsContractMargin(this.extend(r,a))}return this.parseMarginModification(n,i)}parseMarginModification(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t,"_","contract");const i=this.safeNumber(e,"margin");return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:i,code:this.safeValue(t,"quote"),status:"ok",timestamp:void 0,datetime:void 0}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,-t,s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,s)}async fetchOpenInterestHistory(e,t="5m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOpenInterestHistory","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory",e,s,i,t,r,100);const n=this.market(e);if(!n.swap)throw new o.BadRequest(this.id+" fetchOpenInterest() supports swap markets only");const d={contract:n.id,settle:n.settleId,interval:this.safeString(this.timeframes,t,t)};void 0!==i&&(d.limit=i),void 0!==s&&(d.from=s);const h=await this.publicFuturesGetSettleContractStats(this.extend(d,r));return this.parseOpenInterests(h,n,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeTimestamp(e,"time");return{symbol:this.safeString(t,"symbol"),openInterestAmount:this.safeNumber(e,"open_interest"),openInterestValue:this.safeNumber(e,"open_interest_usd"),timestamp:s,datetime:this.iso8601(s),info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchSettlementHistory() requires a symbol argument");await this.loadMarkets();const r=this.market(e);let a;if([a,i]=this.handleMarketTypeAndParams("fetchSettlementHistory",r,i),"option"!==a)throw new o.NotSupported(this.id+" fetchSettlementHistory() supports option markets only");const n=r.id.split("-"),d={underlying:this.safeString(n,0)};void 0!==t&&(d.from=t),void 0!==s&&(d.limit=s);const h=await this.publicOptionsGetSettlements(this.extend(d,i)),c=this.parseSettlements(h,r),l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}async fetchMySettlementHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchMySettlementHistory() requires a symbol argument");await this.loadMarkets();const r=this.market(e);let a;if([a,i]=this.handleMarketTypeAndParams("fetchMySettlementHistory",r,i),"option"!==a)throw new o.NotSupported(this.id+" fetchMySettlementHistory() supports option markets only");const n=r.id,d=n.split("-"),h={underlying:this.safeString(d,0),contract:n};void 0!==t&&(h.from=t),void 0!==s&&(h.limit=s);const c=await this.privateOptionsGetMySettlements(this.extend(h,i)),l=this.safeValue(c,"result",{}),u=this.safeValue(l,"list",[]),p=this.parseSettlements(u,r),f=this.sortBy(p,"timestamp");return this.filterBySymbolSinceLimit(f,r.symbol,t,s)}parseSettlement(e,t){const s=this.safeTimestamp(e,"time"),i=this.safeString(e,"contract");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settle_price"),timestamp:s,datetime:this.iso8601(s)}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++)s.push(this.parseSettlement(e[i],t));return s}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o,n=!1;if([n,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),n)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i);let d={};if([r,i]=this.handleMarketTypeAndParams("fetchLedger",void 0,i),"spot"!==r&&"margin"!==r||void 0!==e&&(a=this.currency(e),d.currency=a.id),"swap"===r||"future"===r){const e="swap"===r?"usdt":"btc",t=this.safeStringLower(i,"settle",e);i=this.omit(i,"settle"),d.settle=t}return void 0!==t&&(d.from=t),void 0!==s&&(d.limit=s),[d,i]=this.handleUntilOption("to",d,i),"spot"===r?o=await this.privateSpotGetAccountBook(this.extend(d,i)):"margin"===r?o=await this.privateMarginGetAccountBook(this.extend(d,i)):"swap"===r?o=await this.privateFuturesGetSettleAccountBook(this.extend(d,i)):"future"===r?o=await this.privateDeliveryGetSettleAccountBook(this.extend(d,i)):"option"===r&&(o=await this.privateOptionsGetAccountBook(this.extend(d,i))),this.parseLedger(o,a,t,s)}parseLedgerEntry(e,t=void 0){let s,i=this.safeString(e,"change");r.Y.stringLt(i,"0")?(s="out",i=r.Y.stringAbs(i)):s="in";const a=this.safeString(e,"currency"),o=this.safeString(e,"type"),n=this.safeString(e,"time");let d;d=n.length>10?parseInt(n):1e3*parseInt(n);const h=this.safeString(e,"balance"),c=this.safeString(e,"change"),l=this.parseNumber(r.Y.stringSub(h,c));return{id:this.safeString(e,"id"),direction:s,account:void 0,referenceAccount:void 0,referenceId:void 0,type:this.parseLedgerEntryType(o),currency:this.safeCurrencyCode(a,t),amount:this.parseNumber(i),timestamp:d,datetime:this.iso8601(d),before:l,after:this.safeNumber(e,"balance"),status:void 0,fee:void 0,info:e}}parseLedgerEntryType(e){return this.safeString({deposit:"deposit",withdraw:"withdrawal",sub_account_transfer:"transfer",margin_in:"transfer",margin_out:"transfer",margin_funding_in:"transfer",margin_funding_out:"transfer",cross_margin_in:"transfer",cross_margin_out:"transfer",copy_trading_in:"transfer",copy_trading_out:"transfer",quant_in:"transfer",quant_out:"transfer",futures_in:"transfer",futures_out:"transfer",delivery_in:"transfer",delivery_out:"transfer",new_order:"trade",order_fill:"trade",referral_fee:"rebate",order_fee:"fee",interest:"interest",lend:"loan",redeem:"loan",profit:"interest",flash_swap_buy:"trade",flash_swap_sell:"trade",unknown:"unknown",set:"settlement",prem:"trade",point_refr:"rebate",point_fee:"fee",point_dnw:"deposit/withdraw",fund:"fee",refr:"rebate",fee:"fee",pnl:"trade",dnw:"deposit/withdraw"},e,e)}async setPositionMode(e,t=void 0,s={}){const i=void 0!==t?this.market(t):void 0,[r,a]=this.prepareRequest(i,"swap",s);return r.dual_mode=e,await this.privateFuturesPostSettleDualMode(this.extend(r,a))}async fetchUnderlyingAssets(e={}){let t;if(await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchUnderlyingAssets",void 0,e),void 0!==t&&"spot"!==t||(t="option"),"option"!==t)throw new o.NotSupported(this.id+" fetchUnderlyingAssets() supports option markets only");const s=await this.publicOptionsGetUnderlyings(e),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"name");void 0!==r&&i.push(r)}return i}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new o.NotSupported(this.id+" fetchLiquidations() supports swap markets only");let a={settle:r.settleId,contract:r.id};void 0!==t&&(a.from=t),void 0!==s&&(a.limit=s),[a,i]=this.handleUntilOption("to",a,i);const n=await this.publicFuturesGetSettleLiqOrders(this.extend(a,i));return this.parseLiquidations(n,r,t,s)}async fetchMyLiquidations(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchMyLiquidations() requires a symbol argument");await this.loadMarkets();const r=this.market(e),a={contract:r.id};let n;if(r.swap||r.future)void 0!==s&&(a.limit=s),a.settle=r.settleId;else if(r.option){const e=r.id.split("-");a.underlying=this.safeString(e,0)}if(r.swap)n=await this.privateFuturesGetSettleLiquidates(this.extend(a,i));else if(r.future)n=await this.privateDeliveryGetSettleLiquidates(this.extend(a,i));else{if(!r.option)throw new o.NotSupported(this.id+" fetchMyLiquidations() does not support "+r.type+" orders");n=await this.privateOptionsGetPositionClose(this.extend(a,i))}return this.parseLiquidations(n,r,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"contract"),i=this.safeTimestamp(e,"time"),a=this.safeString2(e,"size","settle_size"),o=this.safeString(e,"left","0"),n=r.Y.stringAbs(r.Y.stringSub(a,o)),d=this.safeString(t,"contractSize"),h=this.safeString2(e,"liq_price","fill_price"),c=r.Y.stringMul(n,d);let l=this.safeString(e,"pnl");return void 0===l&&(l=r.Y.stringMul(c,h)),this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.parseNumber(n),contractSize:this.parseNumber(d),price:this.parseNumber(h),baseValue:this.parseNumber(c),quoteValue:this.parseNumber(r.Y.stringAbs(l)),timestamp:i,datetime:this.iso8601(i)})}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i={underlying:s.info.underlying},r=await this.publicOptionsGetTickers(this.extend(i,t)),a=s.id;for(let e=0;e<r.length;e++){const t=r[e];if(this.safeString(t,"name")===a)return this.parseGreeks(t,s)}}parseGreeks(e,t=void 0){const s=this.safeString(e,"name");return{symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,delta:this.safeNumber(e,"delta"),gamma:this.safeNumber(e,"gamma"),theta:this.safeNumber(e,"theta"),vega:this.safeNumber(e,"vega"),rho:void 0,bidSize:this.safeNumber(e,"bid1_size"),askSize:this.safeNumber(e,"ask1_size"),bidImpliedVolatility:this.safeNumber(e,"bid_iv"),askImpliedVolatility:this.safeNumber(e,"ask_iv"),markImpliedVolatility:this.safeNumber(e,"mark_iv"),bidPrice:this.safeNumber(e,"bid1_price"),askPrice:this.safeNumber(e,"ask1_price"),markPrice:this.safeNumber(e,"mark_price"),lastPrice:this.safeNumber(e,"last_price"),underlyingPrice:this.parseNumber(t.info.underlying_price),info:e}}async closePosition(e,t=void 0,s={}){return s=this.extend({close:!0},s),void 0===t&&(t=""),await this.createOrder(e,"market",t,0,void 0,s)}async fetchLeverage(e,t={}){let s;await this.loadMarkets(),void 0!==e&&(s=this.market(e));const i={};let r;const a=this.safeBool(t,"unified");if(t=this.omit(t,"unified"),s.spot)i.currency_pair=s.id,r=a?await this.publicMarginGetUniCurrencyPairsCurrencyPair(this.extend(i,t)):await this.publicMarginGetCurrencyPairsCurrencyPair(this.extend(i,t));else{if(!a)throw new o.NotSupported(this.id+" fetchLeverage() does not support "+s.type+" markets");r=await this.privateUnifiedGetAccounts(this.extend(i,t))}return this.parseLeverage(r,s)}async fetchLeverages(e=void 0,t={}){let s;await this.loadMarkets(),e=this.marketSymbols(e);const i=this.safeBool(t,"unified");t=this.omit(t,"unified");let r="id";return i?(r="currency_pair",s=await this.publicMarginGetUniCurrencyPairs(t)):s=await this.publicMarginGetCurrencyPairs(t),this.parseLeverages(s,e,r,"spot")}parseLeverage(e,t=void 0){const s=this.safeString2(e,"currency_pair","id"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t,"_","spot"),marginMode:void 0,longLeverage:i,shortLeverage:i}}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={contract:s.id},r=await this.publicOptionsGetContractsContract(this.extend(i,t));return this.parseOption(r,void 0,s)}async fetchOptionChain(e,t={}){await this.loadMarkets();const s={underlying:this.currency(e).code+"_USDT"},i=await this.publicOptionsGetContracts(this.extend(s,t));return this.parseOptionChain(i,void 0,"name")}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"name");s=this.safeMarket(i,s);const r=this.safeTimestamp(e,"create_time");return{info:e,currency:void 0,symbol:s.symbol,timestamp:r,datetime:this.iso8601(r),impliedVolatility:void 0,openInterest:void 0,bidPrice:this.safeNumber(e,"bid1_price"),askPrice:this.safeNumber(e,"ask1_price"),midPrice:void 0,markPrice:this.safeNumber(e,"mark_price"),lastPrice:this.safeNumber(e,"last_price"),underlyingPrice:this.safeNumber(e,"underlying_price"),change:void 0,percentage:void 0,baseVolume:void 0,quoteVolume:void 0}}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){let r,a;if(await this.loadMarkets(),void 0!==e){1===e.length&&(r=this.market(e[0]))}[a,i]=this.handleMarketTypeAndParams("fetchPositionsHistory",r,i,"swap");const n=this.safeInteger(i,"until");i=this.omit(i,"until");let d,h={};if([h,i]=this.prepareRequest(r,a,i),void 0!==s&&(h.limit=s),void 0!==t&&(h.from=this.parseToInt(t/1e3)),void 0!==n&&(h.to=this.parseToInt(n/1e3)),"swap"===a)d=await this.privateFuturesGetSettlePositionClose(this.extend(h,i));else{if("future"!==a)throw new o.NotSupported(this.id+" fetchPositionsHistory() does not support markets of type "+a);d=await this.privateDeliveryGetSettlePositionClose(this.extend(h,i))}return this.parsePositions(d,e,i)}handleErrors(e,t,s,i,r,a,n,d,h){if(void 0===n)return;const c=this.safeString(n,"label");if(void 0!==c){const e=this.id+" "+a;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),new o.ExchangeError(e)}}}},784:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(9403);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"gateio",alias:!0})}}},8823:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3434),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"gemini",name:"Gemini",countries:["US"],rateLimit:100,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:"emulated",postOnly:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg",api:{public:"https://api.gemini.com",private:"https://api.gemini.com",web:"https://docs.gemini.com",webExchange:"https://exchange.gemini.com"},www:"https://gemini.com/",doc:["https://docs.gemini.com/rest-api","https://docs.sandbox.gemini.com"],test:{public:"https://api.sandbox.gemini.com",private:"https://api.sandbox.gemini.com",web:"https://docs.gemini.com",webExchange:"https://exchange.gemini.com"},fees:["https://gemini.com/api-fee-schedule","https://gemini.com/trading-fees","https://gemini.com/transfer-fees"]},api:{webExchange:{get:[""]},web:{get:["rest-api"]},public:{get:{"v1/symbols":5,"v1/symbols/details/{symbol}":5,"v1/staking/rates":5,"v1/pubticker/{symbol}":5,"v2/ticker/{symbol}":5,"v2/candles/{symbol}/{timeframe}":5,"v1/trades/{symbol}":5,"v1/auction/{symbol}":5,"v1/auction/{symbol}/history":5,"v1/pricefeed":5,"v1/book/{symbol}":5,"v1/earn/rates":5}},private:{post:{"v1/staking/unstake":1,"v1/staking/stake":1,"v1/staking/rewards":1,"v1/staking/history":1,"v1/order/new":1,"v1/order/cancel":1,"v1/wrap/{symbol}":1,"v1/order/cancel/session":1,"v1/order/cancel/all":1,"v1/order/status":1,"v1/orders":1,"v1/mytrades":1,"v1/notionalvolume":1,"v1/tradevolume":1,"v1/clearing/new":1,"v1/clearing/status":1,"v1/clearing/cancel":1,"v1/clearing/confirm":1,"v1/balances":1,"v1/balances/staking":1,"v1/notionalbalances/{currency}":1,"v1/transfers":1,"v1/addresses/{network}":1,"v1/deposit/{network}/newAddress":1,"v1/deposit/{currency}/newAddress":1,"v1/withdraw/{currency}":1,"v1/account/transfer/{currency}":1,"v1/payments/addbank":1,"v1/payments/methods":1,"v1/payments/sen/withdraw":1,"v1/balances/earn":1,"v1/earn/interest":1,"v1/earn/history":1,"v1/approvedAddresses/{network}/request":1,"v1/approvedAddresses/account/{network}":1,"v1/approvedAddresses/{network}/remove":1,"v1/account":1,"v1/account/create":1,"v1/account/list":1,"v1/heartbeat":1,"v1/roles":1}}},precisionMode:o.kb,fees:{trading:{taker:.004,maker:.002}},httpExceptions:{400:r.BadRequest,403:r.PermissionDenied,404:r.OrderNotFound,406:r.InsufficientFunds,429:r.RateLimitExceeded,500:r.ExchangeError,502:r.ExchangeNotAvailable,503:r.OnMaintenance},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1hr","6h":"6hr","1d":"1day"},exceptions:{exact:{AuctionNotOpen:r.BadRequest,ClientOrderIdTooLong:r.BadRequest,ClientOrderIdMustBeString:r.BadRequest,ConflictingOptions:r.BadRequest,EndpointMismatch:r.BadRequest,EndpointNotFound:r.BadRequest,IneligibleTiming:r.BadRequest,InsufficientFunds:r.InsufficientFunds,InvalidJson:r.BadRequest,InvalidNonce:r.InvalidNonce,InvalidApiKey:r.AuthenticationError,InvalidOrderType:r.InvalidOrder,InvalidPrice:r.InvalidOrder,InvalidQuantity:r.InvalidOrder,InvalidSide:r.InvalidOrder,InvalidSignature:r.AuthenticationError,InvalidSymbol:r.BadRequest,InvalidTimestampInPayload:r.BadRequest,Maintenance:r.OnMaintenance,MarketNotOpen:r.InvalidOrder,MissingApikeyHeader:r.AuthenticationError,MissingOrderField:r.InvalidOrder,MissingRole:r.AuthenticationError,MissingPayloadHeader:r.AuthenticationError,MissingSignatureHeader:r.AuthenticationError,NoSSL:r.AuthenticationError,OptionsMustBeArray:r.BadRequest,OrderNotFound:r.OrderNotFound,RateLimit:r.RateLimitExceeded,System:r.ExchangeError,UnsupportedOption:r.BadRequest},broad:{"The Gemini Exchange is currently undergoing maintenance.":r.OnMaintenance,"We are investigating technical issues with the Gemini Exchange.":r.ExchangeNotAvailable,"Internal Server Error":r.ExchangeNotAvailable}},options:{fetchMarketsMethod:"fetch_markets_from_api",fetchMarketFromWebRetries:10,fetchMarketsFromAPI:{fetchDetailsForAllSymbols:!1,quoteCurrencies:["USDT","GUSD","USD","DAI","EUR","GBP","SGD","BTC","ETH","LTC","BCH"]},fetchMarkets:{webApiEnable:!0,webApiRetries:10},fetchUsdtMarkets:["btcusdt","ethusdt"],fetchCurrencies:{webApiEnable:!0,webApiRetries:5,webApiMuteFailure:!0},fetchTickerMethod:"fetchTickerV1",networks:{BTC:"bitcoin",ERC20:"ethereum",BCH:"bitcoincash",LTC:"litecoin",ZEC:"zcash",FIL:"filecoin",DOGE:"dogecoin",XTZ:"tezos",AVAXX:"avalanche",SOL:"solana",ATOM:"cosmos",DOT:"polkadot"},nonce:"milliseconds",conflictingMarkets:{paxgusd:{base:"PAXG",quote:"USD"}}}})}async fetchCurrencies(e={}){return await this.fetchCurrenciesFromWeb(e)}async fetchCurrenciesFromWeb(e={}){const t=await this.fetchWebEndpoint("fetchCurrencies","webExchangeGet",!0,'="currencyData">',"<\/script>");if(void 0===t)return;const s={};this.options.tradingPairs=this.safeList(t,"tradingPairs");const i=this.safeValue(t,"currencies",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,0),a=this.safeCurrencyCode(r),o=this.safeString(t,7)?"fiat":"crypto",n=this.parseNumber(this.parsePrecision(this.safeString(t,5))),d={},h=this.safeString(t,9);let c;void 0!==h&&(c=this.networkIdToCode(h)),void 0!==c&&(d[c]={info:t,id:h,network:c,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:n,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}),s[a]={info:t,id:r,code:a,name:this.safeString(t,1),active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,type:o,precision:n,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:d}}return s}async fetchMarkets(e={}){if("fetch_markets_from_web"===this.safeValue(this.options,"fetchMarketsMethod","fetch_markets_from_api")){const t=[];t.push(this.fetchMarketsFromWeb(e)),t.push(this.fetchUSDTMarkets(e));const s=await Promise.all(t);return this.arrayConcat(s[0],s[1])}return await this.fetchMarketsFromAPI(e)}async fetchMarketsFromWeb(e={}){const t=await this.fetchWebEndpoint("fetchMarkets","webGetRestApi",!1,'<h1 id="symbols-and-minimums">Symbols and minimums</h1>'),s=this.id+" fetchMarketsFromWeb() the API doc HTML markup has changed, breaking the parser of order limits and precision info for markets.",i=t.split("tbody>");if(i.length<2)throw new r.NotSupported(s);const a=i[1].split("\n<tr>\n"),o=a.length;if(o<2)throw new r.NotSupported(s);const n=[];for(let e=1;e<o;e++){const t=a[e],i=t.split("</td>\n");if(i.length<5)throw new r.NotSupported(s);let o=i[0].replace("<td>","");o=o.replace("*","");const d=i[1].replace("<td>","").split(" "),h=this.safeNumber(d,0),c=i[2].replace("<td>","").split(" "),l=o.length-0,u=l-3,p=i[3].replace("<td>","").split(" "),f=this.safeStringLower(p,1,o.slice(u,l)),m=this.safeStringLower(c,1,o.replace(f,"")),g=this.safeCurrencyCode(m),v=this.safeCurrencyCode(f);n.push({id:o,symbol:g+"/"+v,base:g,quote:v,settle:void 0,baseId:m,quoteId:f,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(c,0),price:this.safeNumber(p,0)},limits:{leverage:{min:void 0,max:void 0},amount:{min:h,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return n}parseMarketActive(e){return void 0===e||this.safeBool({open:!0,closed:!1,cancel_only:!0,post_only:!0,limit_only:!0},e,!0)}async fetchUSDTMarkets(e={}){if("test"in this.urls)return[];const t=this.safeValue(this.options,"fetchUsdtMarkets",[]),s=[];for(let i=0;i<t.length;i++){const r={symbol:t[i]},a=await this.publicGetV1SymbolsDetailsSymbol(this.extend(r,e));s.push(this.parseMarket(a))}return s}async fetchMarketsFromAPI(e={}){const t=await this.publicGetV1Symbols(e),s=[],i=this.safeDict(this.options,"fetchMarketsFromAPI",{}),r=[];for(let e=0;e<t.length;e++)"efilfil"!==t[e]&&r.push(t[e]);if(this.safeBool(i,"fetchDetailsForAllSymbols",!1)){const t=[];for(let s=0;s<r.length;s++){const i={symbol:r[s]};t.push(this.publicGetV1SymbolsDetailsSymbol(this.extend(i,e)))}const i=await Promise.all(t);for(let e=0;e<i.length;e++)s.push(this.parseMarket(i[e]))}else{const e=this.safeList(this.options,"tradingPairs");if(void 0!==e){const t=this.indexBy(e,0);for(let e=0;e<r.length;e++){const i=r[e],a=this.safeList(t,i.toUpperCase());void 0!==a&&s.push(this.parseMarket(a))}}else for(let e=0;e<r.length;e++)s.push(this.parseMarket(r[e]))}return s}parseMarket(e){let t,s,i,r,a,o,n,d,h,c,l,u=!1;const p="string"==typeof e,f=Array.isArray(e);if(p||f){p?t=e:(t=this.safeStringLower(e,0),a=this.parseNumber(this.parsePrecision(this.safeString(e,1))),o=this.parseNumber(this.parsePrecision(this.safeString(e,2))),n=this.safeNumber(e,3));const d=t.toUpperCase(),h=d.indexOf("PERP")>=0,c=d.replace("PERP",""),l=this.safeDict(this.options,"conflictingMarkets",{}),u=c.toLowerCase();if(u in l){const e=l[u];s=e.base,i=e.quote,h&&(r=e.quote)}else{const e=this.handleOption("fetchMarketsFromAPI","quoteCurrencies",[]);for(let t=0;t<e.length;t++){const a=e[t];if(c.endsWith(a)){const e=this.parseToInt(-1*a.length);s=c.slice(0,e),i=a,h&&(r=a);break}}}}else t=this.safeStringLower(e,"symbol"),o=this.safeNumber(e,"tick_size"),a=this.safeNumber(e,"quote_increment"),n=this.safeNumber(e,"min_order_size"),d=this.parseMarketActive(this.safeString(e,"status")),s=this.safeString(e,"base_currency"),i=this.safeString(e,"quote_currency"),r=this.safeString(e,"contract_price_currency");const m=this.safeCurrencyCode(s),g=this.safeCurrencyCode(i),v=this.safeCurrencyCode(r);let y=m+"/"+g;void 0!==r&&(y=y+":"+v,u=!0,h=a,c=!0,l=!1);return{id:t,symbol:y,base:m,quote:g,settle:v,baseId:s,quoteId:i,settleId:r,type:u?"swap":"spot",spot:!u,margin:!1,swap:u,future:!1,option:!1,active:d,contract:u,linear:c,inverse:l,contractSize:h,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:a,amount:o},limits:{leverage:{min:void 0,max:void 0},amount:{min:n,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit_bids=t,r.limit_asks=t);const a=await this.publicGetV1BookSymbol(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","amount")}async fetchTickerV1(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetV1PubtickerSymbol(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickerV2(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetV2TickerSymbol(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickerV1AndV2(e,t={}){const s=await this.fetchTickerV1(e,t),i=await this.fetchTickerV2(e,t);return this.deepExtend(s,{open:i.open,high:i.high,low:i.low,change:i.change,percentage:i.percentage,average:i.average,info:i.info})}async fetchTicker(e,t={}){const s=this.safeValue(this.options,"fetchTickerMethod","fetchTickerV1");return"fetchTickerV1"===s?await this.fetchTickerV1(e,t):"fetchTickerV2"===s?await this.fetchTickerV2(e,t):await this.fetchTickerV1AndV2(e,t)}parseTicker(e,t=void 0){const s=this.safeValue(e,"volume",{}),i=this.safeInteger(s,"timestamp");let r;const a=this.safeStringLower(e,"pair");let o,n,d,h;if(t=this.safeMarket(a,t),void 0!==a&&void 0===t){7===a.length-0?(o=a.slice(0,4),n=a.slice(4,7)):(o=a.slice(0,3),n=a.slice(3,6)),d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n),r=d+"/"+h}void 0===r&&void 0!==t&&(r=t.symbol,o=this.safeStringUpper(t,"baseId"),n=this.safeStringUpper(t,"quoteId"));const c=this.safeString(e,"price"),l=this.safeString2(e,"last","close",c),u=this.safeString(e,"percentChange24h"),p=this.safeString(e,"open"),f=this.safeString(s,o),m=this.safeString(s,n);return this.safeTicker({symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:p,close:l,last:l,previousClose:void 0,change:void 0,percentage:u,average:void 0,baseVolume:f,quoteVolume:m,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV1Pricefeed(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"tid"),r=this.safeString(e,"order_id"),a=this.safeString(e,"fee_currency"),o=this.safeCurrencyCode(a),n={cost:this.safeString(e,"fee_amount"),currency:o},d=this.safeString(e,"price"),h=this.safeString(e,"amount"),c=this.safeStringLower(e,"type"),l=this.safeSymbol(void 0,t);return this.safeTrade({id:i,order:r,info:e,timestamp:s,datetime:this.iso8601(s),symbol:l,type:void 0,side:c,takerOrMaker:void 0,price:d,cost:void 0,amount:h,fee:n},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit_trades=Math.min(s,500)),void 0!==t&&(a.timestamp=t);const o=await this.publicGetV1TradesSymbol(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.total=this.safeString(i,"amount"),t[a]=o}return this.safeBalance(t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostV1Notionalvolume(e),s=this.safeString(t,"api_maker_fee_bps"),i=this.safeString(t,"api_taker_fee_bps"),r=a.Y.stringDiv(s,"10000"),o=a.Y.stringDiv(i,"10000"),n=this.parseNumber(r),d=this.parseNumber(o),h={};for(let e=0;e<this.symbols.length;e++){const s=this.symbols[e];h[s]={info:t,symbol:s,maker:n,taker:d,percentage:!0,tierBased:!0}}return h}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostV1Balances(e);return this.parseBalance(t)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"original_amount"),r=this.safeString(e,"remaining_amount"),a=this.safeString(e,"executed_amount");let o="closed";e.is_live&&(o="open"),e.is_cancelled&&(o="canceled");const n=this.safeString(e,"price"),d=this.safeString(e,"avg_execution_price");let h=this.safeString(e,"type");h="exchange limit"===h?"limit":"market buy"===h||"market sell"===h?"market":e.type;const c=this.safeString(e,"symbol"),l=this.safeSymbol(c,t),u=this.safeString(e,"order_id"),p=this.safeStringLower(e,"side"),f=this.safeString(e,"client_order_id"),m=this.safeValue(e,"options",[]),g=this.safeString(m,0);let v="GTC",y=!1;return void 0!==g&&("immediate-or-cancel"===g?v="IOC":"fill-or-kill"===g?v="FOK":"maker-or-cancel"===g&&(v="PO",y=!0)),this.safeOrder({id:u,clientOrderId:f,info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:o,symbol:l,type:h,timeInForce:v,postOnly:y,side:p,price:n,stopPrice:void 0,triggerPrice:void 0,average:d,cost:void 0,amount:i,filled:a,remaining:r,fee:undefined,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privatePostV1OrderStatus(this.extend(i,s));return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.privatePostV1Orders(i);let a;return void 0!==e&&(a=this.market(e)),this.parseOrders(r,a,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r.ExchangeError(this.id+" createOrder() allows limit orders only");let n=this.safeString2(o,"clientOrderId","client_order_id");o=this.omit(o,["clientOrderId","client_order_id"]),void 0===n&&(n=this.milliseconds().toString());const d=this.market(e),h=this.amountToPrecision(e,i),c=this.priceToPrecision(e,a),l={client_order_id:n,symbol:d.id,amount:h,price:c,side:s,type:"exchange limit"};t=this.safeString(o,"type",t),o=this.omit(o,"type");const u=this.safeString2(o,"stop_price","stopPrice");if(o=this.omit(o,["stop_price","stopPrice","type"]),"stopLimit"===t)throw new r.ArgumentsRequired(this.id+" createOrder() requires a stopPrice parameter or a stop_price parameter for "+t+" orders");if(void 0!==u)l.stop_price=this.priceToPrecision(e,u),l.type="exchange stop limit";else{const e=this.safeString(o,"timeInForce");o=this.omit(o,"timeInForce"),void 0!==e&&("IOC"===e||"immediate-or-cancel"===e?l.options=["immediate-or-cancel"]:"FOK"===e||"fill-or-kill"===e?l.options=["fill-or-kill"]:"PO"===e&&(l.options=["maker-or-cancel"]));const t=this.safeBool(o,"postOnly",!1);o=this.omit(o,"postOnly"),t&&(l.options=["maker-or-cancel"]);const s=this.safeString(o,"options");void 0!==s&&(l.options=[s])}const p=await this.privatePostV1OrderNew(this.extend(l,o));return this.parseOrder(p)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privatePostV1OrderCancel(this.extend(i,s));return this.parseOrder(r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==s&&(o.limit_trades=s),void 0!==t&&(o.timestamp=this.parseToInt(t/1e3));const n=await this.privatePostV1Mytrades(this.extend(o,i));return this.parseTrades(n,a,t,s)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={currency:o.id,amount:t,address:s},d=await this.privatePostV1WithdrawCurrency(this.extend(n,a));if("error"===this.safeString(d,"result"))throw new r.ExchangeError(this.id+" withdraw() failed: "+this.json(d));return this.parseTransaction(d,o)}nonce(){return"milliseconds"===this.safeString(this.options,"nonce","milliseconds")?this.milliseconds():this.seconds()}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==s&&(r.limit_transfers=s),void 0!==t&&(r.timestamp=t);const a=await this.privatePostV1Transfers(this.extend(r,i));return this.parseTransactions(a)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i,t),a=this.safeString(e,"destination"),o=this.safeStringLower(e,"type"),n=this.safeString(e,"status");let d;const h=this.safeNumber(e,"feeAmount");return void 0!==h&&(d={cost:h,currency:r}),{info:e,id:this.safeString2(e,"eid","withdrawalId"),txid:this.safeString(e,"txHash"),timestamp:s,datetime:this.iso8601(s),network:void 0,address:a,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:o,amount:this.safeNumber(e,"amount"),currency:r,status:this.parseTransactionStatus(n),updated:void 0,internal:void 0,comment:this.safeString(e,"message"),fee:d}}parseTransactionStatus(e){return this.safeString({Advanced:"ok",Complete:"ok"},e,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return{currency:this.safeCurrencyCode(void 0,t),network:void 0,address:s,tag:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=await this.fetchDepositAddressesByNetwork(e,t);let i;[i,t]=this.handleNetworkCodeAndParams(t);const r=this.indexBy(this.safeValue(s,i),"currency");return this.safeValue(r,e)}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();let s;if(e=this.currency(e).code,[s,t]=this.handleNetworkCodeAndParams(t),void 0===s)throw new r.ArgumentsRequired(this.id+" fetchDepositAddresses() requires a network parameter");const i={network:this.networkCodeToId(s)},a=await this.privatePostV1AddressesNetwork(this.extend(i,t)),o=this.parseDepositAddresses(a,[e],!1,{network:s,currency:e});return this.groupBy(o,"network")}sign(e,t="public",s="GET",i={},a=void 0,o=void 0){let d="/"+this.implodeParams(e,i);const h=this.omit(i,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();if(this.apiKey.indexOf("account")<0)throw new r.AuthenticationError(this.id+" sign() requires an account-key, master-keys are not-supported");const e=this.nonce().toString(),t=this.extend({request:d,nonce:e},h);let s=this.json(t);s=this.stringToBase64(s);const i=this.hmac(this.encode(s),this.encode(this.secret),n.qt);a={"Content-Type":"text/plain","X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":s,"X-GEMINI-SIGNATURE":i}}else Object.keys(h).length&&(d+="?"+this.urlencode(h));return d=this.urls.api[t]+d,"POST"!==s&&"DELETE"!==s||(o=this.json(h)),{url:d,method:s,body:o,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n){if("string"==typeof o){const e=this.id+" "+o;this.throwBroadlyMatchedException(this.exceptions.broad,o,e)}return}if("error"===this.safeString(n,"result")){const e=this.safeString(n,"reason"),t=this.safeString(n,"message"),s=this.id+" "+t;throw this.throwExactlyMatchedException(this.exceptions.exact,e,s),this.throwExactlyMatchedException(this.exceptions.exact,t,s),this.throwBroadlyMatchedException(this.exceptions.broad,t,s),new r.ExchangeError(s)}}async createDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privatePostV1DepositCurrencyNewAddress(this.extend(s,t)),r=this.safeString(i,"address");return this.checkAddress(r),{currency:e,address:r,tag:void 0,info:i}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={timeframe:this.safeString(this.timeframes,t,t),symbol:a.id},n=await this.publicGetV2CandlesSymbolTimeframe(this.extend(o,r));return this.parseOHLCVs(n,a,t,s,i)}}},2937:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9722),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"hashkey",name:"HashKey Global",countries:["BM"],rateLimit:100,version:"v1",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!1,cancelOrder:!0,cancelOrders:!0,cancelWithdraw:!1,closePosition:!1,createConvertTrade:!1,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrder:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrderWithTakeProfitAndStopLoss:!1,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!1,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!1,createTrailingAmountOrder:!1,createTrailingPercentOrder:!1,createTriggerOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchCanceledAndClosedOrders:!0,fetchCanceledOrders:!0,fetchClosedOrder:!0,fetchClosedOrders:!1,fetchConvertCurrencies:!1,fetchConvertQuote:!1,fetchConvertTrade:!1,fetchConvertTradeHistory:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsForSymbol:!0,fetchPositionsHistory:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!1,setLeverage:!0,setMargin:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://github.com/user-attachments/assets/6dd6127b-cc19-4a13-9b29-a98d81f80e98",api:{public:"https://api-glb.hashkey.com",private:"https://api-glb.hashkey.com"},test:{public:"https://api-glb.sim.hashkeydev.com",private:"https://api-glb.sim.hashkeydev.com"},www:"https://global.hashkey.com/",doc:"https://hashkeyglobal-apidoc.readme.io/",fees:"https://support.global.hashkey.com/hc/en-us/articles/13199900083612-HashKey-Global-Fee-Structure",referral:"https://global.hashkey.com/en-US/register/invite?invite_code=82FQUN"},api:{public:{get:{"api/v1/exchangeInfo":5,"quote/v1/depth":1,"quote/v1/trades":1,"quote/v1/klines":1,"quote/v1/ticker/24hr":1,"quote/v1/ticker/price":1,"quote/v1/ticker/bookTicker":1,"quote/v1/depth/merged":1,"quote/v1/markPrice":1,"quote/v1/index":1,"api/v1/futures/fundingRate":1,"api/v1/futures/historyFundingRate":1,"api/v1/ping":1,"api/v1/time":1}},private:{get:{"api/v1/spot/order":1,"api/v1/spot/openOrders":1,"api/v1/spot/tradeOrders":5,"api/v1/futures/leverage":1,"api/v1/futures/order":1,"api/v1/futures/openOrders":1,"api/v1/futures/userTrades":1,"api/v1/futures/positions":1,"api/v1/futures/historyOrders":1,"api/v1/futures/balance":1,"api/v1/futures/liquidationAssignStatus":1,"api/v1/futures/riskLimit":1,"api/v1/futures/commissionRate":1,"api/v1/futures/getBestOrder":1,"api/v1/account/vipInfo":1,"api/v1/account":1,"api/v1/account/trades":5,"api/v1/account/type":5,"api/v1/account/checkApiKey":1,"api/v1/account/balanceFlow":5,"api/v1/spot/subAccount/openOrders":1,"api/v1/spot/subAccount/tradeOrders":1,"api/v1/subAccount/trades":1,"api/v1/futures/subAccount/openOrders":1,"api/v1/futures/subAccount/historyOrders":1,"api/v1/futures/subAccount/userTrades":1,"api/v1/account/deposit/address":1,"api/v1/account/depositOrders":1,"api/v1/account/withdrawOrders":1},post:{"api/v1/userDataStream":1,"api/v1/spot/orderTest":1,"api/v1/spot/order":1,"api/v1.1/spot/order":1,"api/v1/spot/batchOrders":5,"api/v1/futures/leverage":1,"api/v1/futures/order":1,"api/v1/futures/position/trading-stop":3,"api/v1/futures/batchOrders":5,"api/v1/account/assetTransfer":1,"api/v1/account/authAddress":1,"api/v1/account/withdraw":1},put:{"api/v1/userDataStream":1},delete:{"api/v1/spot/order":1,"api/v1/spot/openOrders":5,"api/v1/spot/cancelOrderByIds":5,"api/v1/futures/order":1,"api/v1/futures/batchOrders":1,"api/v1/futures/cancelOrderByIds":1,"api/v1/userDataStream":1}}},fees:{trading:{spot:{tierBased:!0,percentage:!0,feeSide:"get",maker:this.parseNumber("0.0012"),taker:this.parseNumber("0.0012"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.00080")],[this.parseNumber("5000000"),this.parseNumber("0.00070")],[this.parseNumber("10000000"),this.parseNumber("0.00060")],[this.parseNumber("50000000"),this.parseNumber("0.00040")],[this.parseNumber("200000000"),this.parseNumber("0.00030")],[this.parseNumber("400000000"),this.parseNumber("0.00010")],[this.parseNumber("800000000"),this.parseNumber("0.00")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0012")],[this.parseNumber("1000000"),this.parseNumber("0.00090")],[this.parseNumber("5000000"),this.parseNumber("0.00085")],[this.parseNumber("10000000"),this.parseNumber("0.00075")],[this.parseNumber("50000000"),this.parseNumber("0.00065")],[this.parseNumber("200000000"),this.parseNumber("0.00045")],[this.parseNumber("400000000"),this.parseNumber("0.00040")],[this.parseNumber("800000000"),this.parseNumber("0.00035")]]}},swap:{tierBased:!0,percentage:!0,feeSide:"get",maker:this.parseNumber("0.00025"),taker:this.parseNumber("0.00060"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.00025")],[this.parseNumber("1000000"),this.parseNumber("0.00016")],[this.parseNumber("5000000"),this.parseNumber("0.00014")],[this.parseNumber("10000000"),this.parseNumber("0.00012")],[this.parseNumber("50000000"),this.parseNumber("0.000080")],[this.parseNumber("200000000"),this.parseNumber("0.000060")],[this.parseNumber("400000000"),this.parseNumber("0.000020")],[this.parseNumber("800000000"),this.parseNumber("0.00")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00060")],[this.parseNumber("1000000"),this.parseNumber("0.00050")],[this.parseNumber("5000000"),this.parseNumber("0.00045")],[this.parseNumber("10000000"),this.parseNumber("0.00040")],[this.parseNumber("50000000"),this.parseNumber("0.00035")],[this.parseNumber("200000000"),this.parseNumber("0.00030")],[this.parseNumber("400000000"),this.parseNumber("0.00025")],[this.parseNumber("800000000"),this.parseNumber("0.00020")]]}}}},options:{broker:"10000700011",recvWindow:void 0,sandboxMode:!1,networks:{BTC:"BTC",ERC20:"ETH",AVAX:"AvalancheC",SOL:"Solana",MATIC:"Polygon",ATOM:"Cosmos",DOT:"Polkadot",LTC:"LTC",OPTIMISM:"Optimism",ARB:"Arbitrum",DOGE:"Dogecoin",TRC20:"Tron",ZKSYNC:"zkSync",TON:"TON",KLAYTN:"Klaytn",MERLINCHAIN:"Merlin Chain"},networksById:{BTC:"BTC",Bitcoin:"BTC",ETH:"ERC20",ERC20:"ERC20",AvalancheC:"AVAX","AVAX C-Chain":"AVAX",Solana:"SOL",Cosmos:"ATOM",Arbitrum:"ARB",Polygon:"MATIC",Optimism:"OPTIMISM",Polkadot:"DOT",LTC:"LTC",Litecoin:"LTC",Dogecoin:"DOGE","Merlin Chain":"MERLINCHAIN",zkSync:"ZKSYNC",TRC20:"TRC20",Tron:"TRC20",TON:"TON","BSC(BEP20)":"BSC",Klaytn:"KLAYTN"},defaultNetwork:"ERC20"},commonCurrencies:{},exceptions:{exact:{"0001":r.BadRequest,"0002":r.AuthenticationError,"0003":r.RateLimitExceeded,"0102":r.AuthenticationError,"0103":r.AuthenticationError,"0104":r.PermissionDenied,"0201":r.ExchangeError,"0202":r.PermissionDenied,"0206":r.BadRequest,"0207":r.BadRequest,"0209":r.BadRequest,"0210":r.BadRequest,"0211":r.OrderNotFound,"0401":r.InsufficientFunds,"0402":r.BadRequest,"-1000":r.ExchangeError,"-1001":r.ExchangeError,"-100010":r.BadSymbol,"-100012":r.BadSymbol,"-1002":r.AuthenticationError,"-1004":r.BadRequest,"-1005":r.PermissionDenied,"-1006":r.ExchangeError,"-1007":r.RequestTimeout,"-1014":r.InvalidOrder,"-1015":r.InvalidOrder,"-1020":r.OperationRejected,"-1021":r.InvalidNonce,"-1024":r.BadRequest,"-1101":r.ExchangeNotAvailable,"-1115":r.InvalidOrder,"-1117":r.InvalidOrder,"-1123":r.InvalidOrder,"-1124":r.InvalidOrder,"-1126":r.InvalidOrder,"-1129":r.BadRequest,"-1130":r.BadRequest,"-1132":r.BadRequest,"-1133":r.BadRequest,"-1135":r.BadRequest,"-1136":r.BadRequest,"-1138":r.InvalidOrder,"-1137":r.InvalidOrder,"-1139":r.OrderImmediatelyFillable,"-1140":r.InvalidOrder,"-1141":r.DuplicateOrderId,"-1142":r.OrderNotFillable,"-1143":r.OrderNotFound,"-1144":r.OperationRejected,"-1145":r.NotSupported,"-1146":r.RequestTimeout,"-1147":r.RequestTimeout,"-1148":r.InvalidOrder,"-1149":r.OperationRejected,"-1150":r.OperationFailed,"-1151":r.OperationRejected,"-1152":r.AccountNotEnabled,"-1153":r.InvalidOrder,"-1154":r.InvalidOrder,"-1155":r.OperationRejected,"-1156":r.OperationFailed,"-1157":r.OperationFailed,"-1158":r.OperationFailed,"-1159":r.AccountNotEnabled,"-1160":r.AccountNotEnabled,"-1161":r.OperationFailed,"-1162":r.ContractUnavailable,"-1163":r.InvalidAddress,"-1164":r.OperationFailed,"-1165":r.ArgumentsRequired,"-1166":r.OperationRejected,"-1167":r.BadRequest,"-1168":r.BadRequest,"-1169":r.PermissionDenied,"-1170":r.PermissionDenied,"-1171":r.PermissionDenied,"-1172":r.BadRequest,"-1173":r.BadRequest,"-1174":r.PermissionDenied,"-1175":r.BadRequest,"-1176":r.BadRequest,"-1177":r.InvalidOrder,"-1178":r.AccountNotEnabled,"-1179":r.AccountSuspended,"-1181":r.ExchangeError,"-1193":r.OperationRejected,"-1194":r.OperationRejected,"-1195":r.BadRequest,"-1196":r.BadRequest,"-1200":r.BadRequest,"-1201":r.BadRequest,"-1202":r.BadRequest,"-1203":r.BadRequest,"-1204":r.BadRequest,"-1205":r.AccountNotEnabled,"-1206":r.BadRequest,"-1207":r.BadRequest,"-1208":r.BadRequest,"-1209":r.BadRequest,"-2001":r.ExchangeNotAvailable,"-2002":r.OperationFailed,"-2003":r.OperationFailed,"-2004":r.OperationFailed,"-2005":r.RequestTimeout,"-2010":r.OperationRejected,"-2011":r.OperationRejected,"-2016":r.OperationRejected,"-2017":r.OperationRejected,"-2018":r.OperationRejected,"-2019":r.PermissionDenied,"-2020":r.PermissionDenied,"-2021":r.PermissionDenied,"-2022":r.OperationRejected,"-2023":r.AuthenticationError,"-2024":r.AccountNotEnabled,"-2025":r.AccountNotEnabled,"-2026":r.BadRequest,"-2027":r.OperationRejected,"-2028":r.OperationRejected,"-2029":r.OperationRejected,"-2030":r.InsufficientFunds,"-2031":r.NotSupported,"-2032":r.OperationRejected,"-2033":r.OperationFailed,"-2034":r.InsufficientFunds,"-2035":r.OperationRejected,"-2036":r.NotSupported,"-2037":r.ExchangeError,"-2038":r.InsufficientFunds,"-2039":r.NotSupported,"-2040":r.ExchangeNotAvailable,"-2041":r.BadRequest,"-2042":r.OperationRejected,"-2043":r.OperationRejected,"-2044":r.BadRequest,"-2045":r.BadRequest,"-2046":r.BadRequest,"-2048":r.BadRequest,"-2049":r.BadRequest,"-2050":r.BadRequest,"-2051":r.OperationRejected,"-2052":r.OperationRejected,"-2053":r.OperationRejected,"-2054":r.BadRequest,"-2055":r.BadRequest,"-2056":r.BadRequest,"-2057":r.BadRequest,"-3117":r.PermissionDenied,"-3143":r.PermissionDenied,"-3144":r.PermissionDenied,"-3145":r.DDoSProtection,"-4001":r.BadRequest,"-4002":r.BadRequest,"-4003":r.InsufficientFunds,"-4004":r.BadRequest,"-4005":r.BadRequest,"-4006":r.AccountNotEnabled,"-4007":r.NotSupported,"-4008":r.AccountNotEnabled,"-4009":r.PermissionDenied,"-4010":r.PermissionDenied,"-4011":r.ExchangeError,"-4012":r.ExchangeError,"-4013":r.OperationFailed},broad:{}},precisionMode:o.kb})}async fetchTime(e={}){const t=await this.publicGetApiV1Time(e);return this.safeInteger(t,"serverTime")}async fetchStatus(e={}){return{status:"ok",updated:void 0,eta:void 0,url:void 0,info:await this.publicGetApiV1Ping(e)}}async fetchMarkets(e={}){let t;const s={};[t,e]=this.handleOptionAndParams(e,"fetchMarkets","symbol"),void 0!==t&&(s.symbol=t);const i=await this.publicGetApiV1ExchangeInfo(this.extend(s,e)),r=this.safeList(i,"symbols",[]),a=this.safeList(i,"contracts",[]);let o=this.arrayConcat(r,a);return this.isEmpty(o)&&(o=[i]),this.parseMarkets(o)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quoteAsset"),i=this.safeCurrencyCode(s),r=this.safeString(e,"marginToken"),o=this.safeCurrencyCode(r);let n=this.safeString(e,"baseAsset"),d="spot",h=!0,c=!1,l="";const u=t.split("-");"PERPETUAL"===this.safeString(u,1)&&(d="swap",h=!1,c=!0,n=this.safeString(e,"underlying"),l+=":"+r);const p=this.safeCurrencyCode(n),f=p+"/"+i+l,m="TRADING"===this.safeString(e,"status");let g,v;const y=this.safeBool(e,"inverse");void 0!==y&&(y?(g=!1,v="inverse"):(g=!0,v="linear"));const w=this.safeList(e,"filters",[]),b=this.indexBy(w,"filterType"),S=this.safeDict(b,"PRICE_FILTER",{}),k=this.safeDict(b,"LOT_SIZE",{}),O=this.safeDict(b,"MIN_NOTIONAL",{}),T=this.omitZero(this.safeString(O,"min_notional")),P=this.safeString(e,"contractMultiplier");let I,x,A=this.safeString(k,"stepSize"),M=this.safeString(k,"minQty"),C=this.safeString(k,"maxQty");if(c){A=a.Y.stringDiv(A,P),M=a.Y.stringDiv(M,P),C=a.Y.stringDiv(C,P);const t=this.safeList(e,"riskLimits");if(void 0!==t){const e=this.safeDict(t,0),s=t.length,i=this.safeDict(t,s-1);let r=this.safeString(e,"initialMargin"),o=this.safeString(i,"initialMargin");a.Y.stringGt(r,o)&&([r,o]=[o,r]),I=this.parseToInt(a.Y.stringDiv("1",o)),x=this.parseToInt(a.Y.stringDiv("1",r))}}const E=this.safeDict(this.fees,"trading"),_=h?this.safeDict(E,"spot"):this.safeDict(E,"swap");return this.safeMarketStructure({id:t,symbol:f,base:p,quote:i,baseId:n,quoteId:s,active:m,type:d,subType:v,spot:h,margin:this.safeBool(e,"allowMargin"),swap:c,future:!1,option:!1,contract:c,settle:o,settleId:r,contractSize:this.parseNumber(P),linear:g,inverse:y,taker:this.safeNumber(_,"taker"),maker:this.safeNumber(_,"maker"),percentage:this.safeBool(_,"percentage"),tierBased:this.safeBool(_,"tierBased"),feeSide:this.safeString(_,"feeSide"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(A),price:this.safeNumber(S,"tickSize")},limits:{amount:{min:this.parseNumber(M),max:this.parseNumber(C)},price:{min:this.safeNumber(S,"minPrice"),max:this.safeNumber(S,"maxPrice")},leverage:{min:I,max:x},cost:{min:this.parseNumber(T),max:void 0}},created:void 0,info:e})}async fetchCurrencies(e={}){const t=await this.publicGetApiV1ExchangeInfo(e),s=this.safeList(t,"coins"),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"coinId"),a=this.safeCurrencyCode(r),o=this.safeBool(t,"allowWithdraw"),n=this.safeBool(t,"allowDeposit"),d=this.safeList(t,"chainTypes"),h=this.safeDict(this.options,"networksById"),c={};for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"chainType"),i=this.safeString(h,s,s),r=this.omitZero(this.safeString(t,"maxWithdrawQuantity")),a=this.safeBool(t,"allowDeposit"),o=this.safeBool(t,"allowWithdraw");c[i]={id:s,network:i,limits:{withdraw:{min:this.safeNumber(t,"minWithdrawQuantity"),max:this.parseNumber(r)},deposit:{min:this.safeNumber(t,"minDepositQuantity"),max:void 0}},active:a&&o,deposit:a,withdraw:o,fee:this.safeNumber(t,"withdrawFee"),precision:void 0,info:t}}i[a]={id:r,code:a,precision:void 0,type:this.parseCurrencyType(this.safeString(t,"tokenType")),name:this.safeString(t,"coinFullName"),active:o&&n,deposit:n,withdraw:o,fee:void 0,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:c,info:t}}return i}parseCurrencyType(e){return this.safeString({CHAIN_TOKEN:"crypto",ERC20_TOKEN:"crypto",BSC_TOKEN:"crypto",REAL_MONEY:"fiat"},e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetQuoteV1Depth(this.extend(i,s)),a=this.safeInteger(r,"t");return this.parseOrderBook(r,e,a,"b","a")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetQuoteV1Trades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const a="fetchMyTrades";await this.loadMarkets();const o={};let n;void 0!==e&&(n=this.market(e));let d,h,c,l="spot";if([l,i]=this.handleMarketTypeAndParams(a,n,i),void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[d,i]=this.handleOptionAndParams(i,a,"until"),void 0!==d&&(o.endTime=d),[h,i]=this.handleOptionAndParams(i,a,"accountId"),"spot"===l){let e;void 0!==n&&(o.symbol=n.id),[e,i]=this.handleOptionAndParams(i,a,"clientOrderId"),void 0!==e&&(o.clientOrderId=e),void 0!==h&&(o.accountId=h),c=await this.privateGetApiV1AccountTrades(this.extend(o,i))}else{if("swap"!==l)throw new r.NotSupported(this.id+" "+a+"() is not supported for "+l+" type of markets");if(void 0===e)throw new r.ArgumentsRequired(this.id+" "+a+"() requires a symbol argument for swap markets");o.symbol=n.id,void 0!==h?(o.subAccountId=h,c=await this.privateGetApiV1FuturesSubAccountUserTrades(this.extend(o,i))):c=await this.privateGetApiV1FuturesUserTrades(this.extend(o,i))}return this.parseTrades(c,n,t,s)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"t","time"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);let r=this.safeStringLower(e,"side");void 0!==r&&(r=this.safeString(r.split("_"),0));const a=this.safeBool(e,"isBuyer");let o;void 0!==a&&(r=a?"buy":"sell");const n=this.safeBoolN(e,["isMaker","isMarker","ibm"]);void 0!==n&&(o=n?"maker":"taker");let d=this.safeString(e,"commission"),h=this.safeString(e,"commissionAsset");const c=this.safeDict(e,"fee");let l;return void 0!==c&&(d=this.safeString(c,"fee"),h=this.safeString(c,"feeCoinId")),void 0!==d&&(l={cost:this.parseNumber(d),currency:this.safeCurrencyCode(h)}),this.safeTrade({id:this.safeString2(e,"id","tradeId"),timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,side:r,price:this.safeString2(e,"p","price"),amount:this.safeStringN(e,["q","qty","quantity"]),cost:void 0,takerOrMaker:o,type:void 0,order:this.safeString(e,"orderId"),fee:l,info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){const a="fetchOHLCV";await this.loadMarkets();let o=!1;if([o,r]=this.handleOptionAndParams(r,a,"paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e3);const n=this.market(e);t=this.safeString(this.timeframes,t,t);const d={symbol:n.id,interval:t};let h;void 0!==s&&(d.startTime=s),void 0!==i&&(d.limit=i),[h,r]=this.handleOptionAndParams(r,a,"until"),void 0!==h&&(d.endTime=h);const c=await this.publicGetQuoteV1Klines(this.extend(d,r));return this.parseOHLCVs(c,n,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetQuoteV1Ticker24hr(this.extend(i,t)),a=this.safeDict(r,0,{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetQuoteV1Ticker24hr(t);return this.parseTickers(s,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeString(e,"s"),r=(t=this.safeMarket(i,t)).symbol,a=this.safeString(e,"c");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"b"),bidVolume:void 0,ask:this.safeString(e,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"qv"),info:e},t)}async fetchLastPrices(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={};let i;[i,t]=this.handleOptionAndParams(t,"fetchLastPrices","symbol"),void 0!==i&&(s.symbol=i);const r=await this.publicGetQuoteV1TickerPrice(this.extend(s,t));return this.parseLastPrices(r,e)}parseLastPrice(e,t=void 0){const s=this.safeString(e,"s");return{symbol:(t=this.safeMarket(s,t)).symbol,timestamp:void 0,datetime:void 0,price:this.safeNumber(e,"p"),side:void 0,info:e}}async fetchBalance(e={}){await this.loadMarkets();const t={},s="fetchBalance";let i="spot";if([i,e]=this.handleMarketTypeAndParams(s,void 0,e,i),"swap"===i){const t=await this.privateGetApiV1FuturesBalance(e),s=this.safeDict(t,0,{});return this.parseSwapBalance(s)}if("spot"===i){let i;[i,e]=this.handleOptionAndParams(e,s,"accountId"),void 0!==i&&(t.accountId=i);const r=await this.privateGetApiV1Account(this.extend(t,e));return this.parseBalance(r)}throw new r.NotSupported(this.id+" "+s+"() is not supported for "+i+" type of markets")}parseBalance(e){const t={info:e},s=this.safeList(e,"balances",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"total"),o.free=this.safeString(i,"free"),o.used=this.safeString(i,"locked"),t[a]=o}return this.safeBalance(t)}parseSwapBalance(e){const t=this.safeString(e,"asset"),s=this.safeCurrencyCode(t),i=this.account();i.total=this.safeString(e,"balance");const r=this.safeString(e,"positionMargin"),o=this.safeString(e,"orderMargin");i.used=a.Y.stringAdd(r,o);const n={info:e};return n[s]=i,this.safeBalance(n)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id};let r;[r,t]=this.handleNetworkCodeAndParams(t),void 0===r&&(r=this.defaultNetworkCode(e)),i.chainType=this.networkCodeToId(r,e);const a=await this.privateGetApiV1AccountDepositAddress(this.extend(i,t)),o=this.parseDepositAddress(a,s);return o.network=r,o}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");this.checkAddress(s);let i=this.safeString(e,"addressExt");return""===i&&(i=void 0),{currency:t.code,address:s,tag:i,network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s),[o,i]=this.handleOptionAndParams(i,"fetchDeposits","until"),void 0!==o&&(r.endTime=o);const n=await this.privateGetApiV1AccountDepositOrders(this.extend(r,i));return this.parseTransactions(n,a,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s),[o,i]=this.handleOptionAndParams(i,"fetchWithdrawals","until"),void 0!==o&&(r.endTime=o);const n=await this.privateGetApiV1AccountWithdrawOrders(this.extend(r,i));return this.parseTransactions(n,a,t,s,{type:"withdrawal"})}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={coin:a.id,address:s,quantity:t};let n,d,h;void 0!==i&&(o.addressExt=i),[n,r]=this.handleOptionAndParams(r,"withdraw","clientOrderId"),void 0!==n&&(o.clientOrderId=n),[d,r]=this.handleNetworkCodeAndParams(r),void 0!==d&&(o.chainType=this.networkCodeToId(d)),[h,r]=this.handleOptionAndParams(r,"withdraw","platform"),void 0!==h&&(o.platform=h);const c=await this.privatePostApiV1AccountWithdraw(this.extend(o,r));return this.parseTransaction(c,a)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","orderId"),i=this.safeString(e,"address");let r=this.safeString(e,"status");if(void 0===r){if(this.safeBool(e,"success",!1))r="ok";else{void 0!==this.safeString(e,"addressUrl")&&(r="ok")}}const a=this.safeString(e,"txId"),o=this.safeString(e,"coin"),n=this.safeCurrencyCode(o,t),d=this.safeInteger(e,"time"),h=this.safeNumber(e,"quantity"),c=this.safeNumber(e,"fee");let l;return void 0!==c&&(l={cost:c,currency:n}),{info:e,id:s,txid:a,timestamp:d,datetime:this.iso8601(d),network:void 0,address:i,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:h,currency:n,status:this.parseTransactionStatus(r),updated:void 0,internal:void 0,comment:void 0,fee:l}}parseTransactionStatus(e){return this.safeString({1:"pending",2:"pending",3:"failed",4:"ok",5:"pending",6:"ok",7:"failed",8:"cancelled",9:"failed",10:"failed",successful:"ok",success:"ok"},e,e)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={coin:a.id,quantity:this.currencyToPrecision(e,t),fromAccountId:s,toAccountId:i};let n,d;[n,r]=this.handleOptionAndParams(r,"transfer","clientOrderId"),void 0!==n&&(o.clientOrderId=n),[d,r]=this.handleOptionAndParams(r,"transfer","remark"),void 0!==d&&(o.remark=d);const h=await this.privatePostApiV1AccountAssetTransfer(this.extend(o,r));return this.parseTransfer(h,a)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(t,"id");let r;return this.safeBool(e,"success",!1)&&(r="ok"),{id:this.safeString(e,"orderId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:r,info:e}}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetApiV1AccountType(e);return this.parseAccounts(t,e)}parseAccount(e){const t=this.safeString(e,"accountLabel");let s="";"Main Trading Account"===t||"Main Future Account"===t?s="main":"Sub Main Trading Account"!==t&&"Sub Main Future Account"!==t||(s="sub");const i=s+" "+this.parseAccountType(this.safeString(e,"accountType"));return{id:this.safeString(e,"accountId"),type:i,code:void 0,info:e}}parseAccountType(e){return this.safeString({1:"spot account",3:"swap account",5:"custody account",6:"fiat account"},e,e)}encodeAccountType(e){return this.safeInteger({spot:"1",swap:"3",custody:"5"},e,e)}encodeFlowType(e){return this.safeInteger({trade:"1",fee:"3",transfer:"51",deposit:"900",withdraw:"904"},e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const a="fetchLedger";if(void 0===t)throw new r.ArgumentsRequired(this.id+" "+a+"() requires a since argument");let o;if([o,i]=this.handleOptionAndParams(i,a,"until"),void 0===o)throw new r.ArgumentsRequired(this.id+" "+a+"() requires an until argument");await this.loadMarkets();const n=this.currency(e),d={};let h,c;d.startTime=t,void 0!==s&&(d.limit=s),d.endTime=o,[h,i]=this.handleOptionAndParams(i,a,"flowType"),void 0!==h&&(d.flowType=this.encodeFlowType(h)),[c,i]=this.handleOptionAndParams(i,a,"accountType"),void 0!==c&&(d.accountType=this.encodeAccountType(c));const l=await this.privateGetApiV1AccountBalanceFlow(this.extend(d,i));return this.parseLedger(l,n,t,s)}parseLedgerEntryType(e){return this.safeString({1:"trade",2:"fee",51:"transfer",900:"deposit",904:"withdraw"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"accountId"),r=this.safeInteger(e,"created"),a=this.parseLedgerEntryType(this.safeString(e,"flowTypeValue")),o=this.safeCurrencyCode(this.safeString(e,"coin"),t),n=this.safeString(e,"change"),d=this.parseNumber(n);let h="in";n.indexOf("-")>=0&&(h="out");const c=this.safeString(e,"total"),l=this.parseNumber(c);return{id:s,info:e,timestamp:r,datetime:this.iso8601(r),account:i,direction:h,referenceId:void 0,referenceAccount:void 0,type:a,currency:o,symbol:void 0,amount:d,before:void 0,after:l,status:"ok",fee:void 0}}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);if(n.spot)return await this.createSpotOrder(e,t,s,i,a,o);if(n.swap)return await this.createSwapOrder(e,t,s,i,a,o);throw new r.NotSupported(this.id+" createOrder() is not supported for "+n.type+" type of markets")}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() is supported for spot markets only");return s.cost=t,await this.createOrder(e,"market","buy",t,void 0,s)}async createSpotOrder(e,t,s,i,a=void 0,o={}){if(void 0!==this.safeString2(o,"stopPrice","triggerPrice"))throw new r.NotSupported(this.id+" trigger orders are not supported for spot markets");await this.loadMarkets();const n=this.market(e),d="market"===t&&"buy"===s,h=this.safeString(o,"cost");if(!d&&void 0!==h)throw new r.NotSupported(this.id+" createOrder() supports cost parameter for spot market buy orders only");const c=this.createSpotOrderRequest(e,t,s,i,a,o);let l={};return this.safeBool(o,"test")?(o=this.omit(o,"test"),l=await this.privatePostApiV1SpotOrderTest(c)):l=d&&void 0===h?await this.privatePostApiV11SpotOrder(c):await this.privatePostApiV1SpotOrder(c),this.parseOrder(l,n)}createOrderRequest(e,t,s,i,a=void 0,o={}){const n=this.market(e);if(n.spot)return this.createSpotOrderRequest(e,t,s,i,a,o);if(n.swap)return this.createSwapOrderRequest(e,t,s,i,a,o);throw new r.NotSupported(this.id+" createOrderRequest() is not supported for "+n.type+" type of markets")}createSpotOrderRequest(e,t,s,i,r=void 0,a={}){const o=this.market(e);t=t.toUpperCase();const n={symbol:o.id,side:s.toUpperCase(),type:t};let d;void 0!==i&&(n.quantity=this.amountToPrecision(e,i)),[d,a]=this.handleParamString(a,"cost"),void 0!==d&&(n.quantity=this.costToPrecision(e,d)),void 0!==r&&(n.price=this.priceToPrecision(e,r));const h="MARKET"===t;let c,l=!1;return[l,a]=this.handlePostOnly(h,"LIMIT_MAKER"===t,a),l&&"LIMIT"===t&&(n.type="LIMIT_MAKER"),[c,a]=this.handleParamString(a,"clientOrderId"),void 0!==c&&(a.newClientOrderId=c),this.extend(n,a)}createSwapOrderRequest(e,t,s,i,r=void 0,a={}){const o={symbol:this.market(e).id,type:"LIMIT",quantity:this.amountToPrecision(e,i)},n="market"===t;n&&(o.priceType="MARKET"),void 0!==r&&(o.price=this.priceToPrecision(e,r),o.priceType="INPUT");let d=!1;[d,a]=this.handleParamBool(a,"reduceOnly",d);let h,c="_OPEN";d&&(c="_CLOSE"),o.side=s.toUpperCase()+c,[h,a]=this.handleParamString(a,"timeInForce");let l=!1;[l,a]=this.handlePostOnly(n,"LIMIT_MAKER"===h,a),l&&(h="LIMIT_MAKER"),void 0!==h&&(o.timeInForce=h);void 0===this.safeString(a,"clientOrderId")&&(o.clientOrderId=this.uuid());const u=this.safeString(a,"triggerPrice");return void 0!==u&&(o.stopPrice=this.priceToPrecision(e,u),o.type="STOP",a=this.omit(a,"triggerPrice")),this.extend(o,a)}async createSwapOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.createSwapOrderRequest(e,t,s,i,r,a),d=await this.privatePostApiV1FuturesOrder(this.extend(n,a));return this.parseOrder(d,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.safeString(i,"type"),o=this.safeString(i,"side"),n=this.safeNumber(i,"amount"),d=this.safeNumber(i,"price"),h=this.safeDict(i,"params",{}),c=this.createOrderRequest(r,a,o,n,d,h);void 0===this.safeString(c,"clientOrderId")&&(c.clientOrderId=this.uuid()),s.push(c)}const i=s[0],a=this.safeString(i,"symbol"),o=this.market(a),n={orders:s};let d;if(o.spot)d=await this.privatePostApiV1SpotBatchOrders(this.extend(n,t));else{if(!o.swap)throw new r.NotSupported(this.id+" createOrderRequest() is not supported for "+o.type+" type of markets");d=await this.privatePostApiV1FuturesBatchOrders(this.extend(n,t))}const h=this.safeList(d,"result",[]),c=[];for(let e=0;e<h.length;e++){const t=this.safeDict(h,e,{}),s=this.safeDict(t,"order",{});c.push(s)}return this.parseOrders(c)}async cancelOrder(e,t=void 0,s={}){const i="cancelOrder";this.checkTypeParam(i,s),await this.loadMarkets();const a={};let o;void 0===this.safeString(s,"clientOrderId")&&(a.orderId=e),void 0!==t&&(o=this.market(t));let n,d="spot";if([d,s]=this.handleMarketTypeAndParams(i,o,s,d),"spot"===d)n=await this.privateDeleteApiV1SpotOrder(this.extend(a,s));else{if("swap"!==d)throw new r.NotSupported(this.id+" "+i+"() is not supported for "+d+" type of markets");{let e=!1;[e,s]=this.handleTriggerOptionAndParams(s,i,e),a.type=e?"STOP":"LIMIT",void 0!==o&&(a.symbol=o.id),n=await this.privateDeleteApiV1FuturesOrder(this.extend(a,s))}}return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){const s="cancelAllOrders";if(void 0===e)throw new r.ArgumentsRequired(this.id+" "+s+"() requires a symbol argument");await this.loadMarkets();const i=this.market(e),a={symbol:i.id},o=this.safeString(t,"side");let n;if(void 0!==o&&(a.side=o),i.spot)n=await this.privateDeleteApiV1SpotOpenOrders(this.extend(a,t));else{if(!i.swap)throw new r.NotSupported(this.id+" "+s+"() is not supported for "+i.type+" type of markets");n=await this.privateDeleteApiV1FuturesBatchOrders(this.extend(a,t))}const d=this.safeOrder(n);return d.info=n,[d]}async cancelOrders(e,t=void 0,s={}){const i="cancelOrders";await this.loadMarkets();const a={},o=e.join(",");let n;a.ids=o,void 0!==t&&(n=this.market(t));let d,h="spot";if([h,s]=this.handleMarketTypeAndParams(i,n,s,h),"spot"===h)d=await this.privateDeleteApiV1SpotCancelOrderByIds(this.extend(a));else{if("swap"!==h)throw new r.NotSupported(this.id+" "+i+"() is not supported for "+h+" type of markets");d=this.privateDeleteApiV1FuturesCancelOrderByIds(this.extend(a))}const c=this.safeOrder(d);return c.info=d,[c]}async fetchOrder(e,t=void 0,s={}){const i="fetchOrder";this.checkTypeParam(i,s),await this.loadMarkets();const a={};let o,n;[o,s]=this.handleParamString(s,"clientOrderId"),void 0===o&&(a.orderId=e),void 0!==t&&(n=this.market(t));let d,h="spot";if([h,s]=this.handleMarketTypeAndParams(i,n,s,h),"spot"===h){let e;void 0!==o&&(a.origClientOrderId=o),[e,s]=this.handleOptionAndParams(s,i,"accountId"),void 0!==e&&(a.accountId=e),d=await this.privateGetApiV1SpotOrder(this.extend(a,s))}else{if("swap"!==h)throw new r.NotSupported(this.id+" "+i+"() is not supported for "+h+" type of markets");{let e=!1;[e,s]=this.handleTriggerOptionAndParams(s,i,e),e&&(a.type="STOP"),d=await this.privateGetApiV1FuturesOrder(this.extend(a,s))}}return this.parseOrder(d)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const a="fetchOpenOrders";let o;this.checkTypeParam(a,i),await this.loadMarkets(),void 0!==e&&(o=this.market(e));let n="spot";if([n,i]=this.handleMarketTypeAndParams(a,o,i,n),i=this.extend({methodName:a},i),"spot"===n)return await this.fetchOpenSpotOrders(e,t,s,i);if("swap"===n)return await this.fetchOpenSwapOrders(e,t,s,i);throw new r.NotSupported(this.id+" "+a+"() is not supported for "+n+" type of markets")}async fetchOpenSpotOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a="fetchOpenSpotOrders";[a,i]=this.handleParamString(i,"methodName",a);const o={};let n,d;if([d,i]=this.handleOptionAndParams(i,a,"accountId"),void 0!==d)o.subAccountId=d,n=await this.privateGetApiV1SpotSubAccountOpenOrders(this.extend(o,i));else{let t,d;void 0!==e&&(r=this.market(e),o.symbol=r.id),void 0!==s&&(o.limit=s),[t,i]=this.handleOptionAndParams(i,a,"orderId"),void 0!==t&&(o.orderId=t),[d,i]=this.handleOptionAndParams(i,a,"side"),void 0!==d&&(o.side=d.toUpperCase()),n=await this.privateGetApiV1SpotOpenOrders(this.extend(o,i))}return this.parseOrders(n,r,t,s)}async fetchOpenSwapOrders(e=void 0,t=void 0,s=void 0,i={}){let a="fetchOpenSwapOrders";if([a,i]=this.handleParamString(i,"methodName",a),void 0===e)throw new r.ArgumentsRequired(this.id+" "+a+"() requires a symbol argument for swap market orders");const o=this.market(e),n={symbol:o.id};let d,h,c,l=!1;return[l,i]=this.handleTriggerOptionAndParams(i,a,l),n.type=l?"STOP":"LIMIT",void 0!==s&&(n.limit=s),[d,i]=this.handleOptionAndParams(i,a,"fromOrderId"),void 0!==d&&(n.fromOrderId=d),[c,i]=this.handleOptionAndParams(i,a,"accountId"),void 0!==c?(n.subAccountId=c,h=await this.privateGetApiV1FuturesSubAccountOpenOrders(this.extend(n,i))):h=await this.privateGetApiV1FuturesOpenOrders(this.extend(n,i)),this.parseOrders(h,o,t,s)}async fetchCanceledAndClosedOrders(e=void 0,t=void 0,s=void 0,i={}){const a="fetchCanceledAndClosedOrders";this.checkTypeParam(a,i),await this.loadMarkets();const o={};let n,d,h;void 0!==s&&(o.limit=s),void 0!==t&&(o.startTime=t),[n,i]=this.handleOptionAndParams(i,a,"until"),void 0!==n&&(o.endTime=n),[d,i]=this.handleOptionAndParams(i,a,"accountId"),void 0!==e&&(h=this.market(e));let c,l="spot";if([l,i]=this.handleMarketTypeAndParams(a,h,i,l),"spot"===l){let e,t;void 0!==h&&(o.symbol=h.id),[e,i]=this.handleOptionAndParams(i,a,"orderId"),void 0!==e&&(o.orderId=e),[t,i]=this.handleOptionAndParams(i,a,"side"),void 0!==t&&(o.side=t.toUpperCase()),void 0!==d&&(o.accountId=d),c=await this.privateGetApiV1SpotTradeOrders(this.extend(o,i))}else{if("swap"!==l)throw new r.NotSupported(this.id+" "+a+"() is not supported for "+l+" type of markets");{if(void 0===e)throw new r.ArgumentsRequired(this.id+" "+a+"() requires a symbol argument for swap markets");o.symbol=h.id;let t,s=!1;[s,i]=this.handleTriggerOptionAndParams(i,a,s),o.type=s?"STOP":"LIMIT",[t,i]=this.handleOptionAndParams(i,a,"fromOrderId"),void 0!==t&&(o.fromOrderId=t),void 0!==d?(o.subAccountId=d,c=await this.privateGetApiV1FuturesSubAccountHistoryOrders(this.extend(o,i))):c=await this.privateGetApiV1FuturesHistoryOrders(this.extend(o,i))}}return this.parseOrders(c,h,t,s)}checkTypeParam(e,t){const s=this.safeString(t,"type");if(void 0!==s&&"spot"!==s&&"swap"!==s)throw new r.BadRequest(this.id+" "+e+' () type parameter can not be "'+s+'". It should define the type of the market ("spot" or "swap"). To define the type of an order use the trigger parameter (true for trigger orders)')}handleTriggerOptionAndParams(e,t,s=void 0){let i=s;[i,e]=this.handleOptionAndParams(e,t,"stop",i);let r=i;return[r,e]=this.handleOptionAndParams(e,t,"trigger",r),[r,e]}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger2(e,"transactTime","time"),r=this.safeString(e,"status");let a=this.safeString(e,"type");"MARKET"===this.safeString(e,"priceType")&&(a="market");let o=this.omitZero(this.safeString(e,"price"));"STOP"===a&&(a=void 0===o?"market":"limit");let n,d=this.safeString(e,"timeInForce");[a,d,n]=this.parseOrderTypeTimeInForceAndPostOnly(a,d);const h=this.omitZero(this.safeString(e,"avgPrice"));void 0===o&&(o=h);let c,l=this.safeStringLower(e,"side");[l,c]=this.parseOrderSideAndReduceOnly(l);let u=this.safeString(e,"feeCoin");""===u&&(u=void 0);const p=this.omitZero(this.safeString(e,"stopPrice"));return this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"clientOrderId"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,lastUpdateTimestamp:this.safeInteger(e,"updateTime"),status:this.parseOrderStatus(r),symbol:t.symbol,type:a,timeInForce:d,side:l,price:o,average:h,amount:this.omitZero(this.safeString(e,"origQty")),filled:this.safeString(e,"executedQty"),remaining:void 0,stopPrice:p,triggerPrice:p,takeProfitPrice:void 0,stopLossPrice:void 0,cost:this.omitZero(this.safeString2(e,"cumulativeQuoteQty","cummulativeQuoteQty")),trades:void 0,fee:{currency:this.safeCurrencyCode(u),amount:this.omitZero(this.safeString(e,"feeAmount"))},reduceOnly:c,postOnly:n,info:e},t)}parseOrderSideAndReduceOnly(e){const t=e.split("_"),s=t[0];let i;const r=this.safeString(t,1);return void 0!==r&&("open"===r?i=!1:"close"===r&&(i=!0)),[s,i]}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",FILLED:"closed",CANCELED:"canceled",ORDER_CANCELED:"canceled",PENDING_CANCEL:"canceled",REJECTED:"rejected",ORDER_NEW:"open"},e,e)}parseOrderTypeTimeInForceAndPostOnly(e,t){let s;return"LIMIT_MAKER"===e?s=!0:"LIMIT_MAKER"!==t&&"MAKER"!==t||(s=!0,t="PO"),[e=this.parseOrderType(e),t,s]}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit",MARKET_OF_BASE:"market"},e,e)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id,timestamp:this.milliseconds()},r=await this.publicGetApiV1FuturesFundingRate(this.extend(i,t)),a=this.safeDict(r,0,{});return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s={timestamp:this.milliseconds()},i=await this.publicGetApiV1FuturesFundingRate(this.extend(s,t)),r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"swap");const i=this.safeNumber(e,"rate"),r=this.safeInteger(e,"nextSettleTime");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:i,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");const a=this.market(e),o={symbol:a.id};void 0!==s&&(o.limit=s);const n=await this.publicGetApiV1FuturesHistoryFundingRate(this.extend(o,i)),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeInteger(t,"settleTime");d.push({info:t,symbol:this.safeSymbol(this.safeString(t,"symbol"),a,void 0,"swap"),fundingRate:this.safeNumber(t,"settleRate"),timestamp:s,datetime:this.iso8601(s)})}const h=this.sortBy(d,"timestamp");return this.filterBySinceLimit(h,t,s)}async fetchPositions(e=void 0,t={}){const s="fetchPositions";if(void 0===e)throw new r.ArgumentsRequired(this.id+" "+s+"() requires a symbol argument with one single market symbol");if(1!==e.length)throw new r.NotSupported(this.id+" "+s+"() is supported for a symbol argument with one single market symbol only");return await this.loadMarkets(),await this.fetchPositionsForSymbol(e[0],this.extend({methodName:"fetchPositions"},t))}async fetchPositionsForSymbol(e,t={}){await this.loadMarkets();const s=this.market(e);let i="fetchPosition";if([i,t]=this.handleParamString(t,"methodName",i),!s.swap)throw new r.NotSupported(this.id+" "+i+"() supports swap markets only");const a={symbol:s.id};let o;[o,t]=this.handleOptionAndParams(t,i,"side"),void 0!==o&&(a.side=o.toUpperCase());const n=await this.privateGetApiV1FuturesPositions(this.extend(a,t));return this.parsePositions(n,[e])}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol;return this.safePosition({symbol:i,id:void 0,timestamp:void 0,datetime:void 0,contracts:this.safeNumber(e,"position"),contractSize:void 0,side:this.safeStringLower(e,"side"),notional:this.safeNumber(e,"positionValue"),leverage:this.safeInteger(e,"leverage"),unrealizedPnl:this.safeNumber(e,"unrealizedPnL"),realizedPnl:this.safeNumber(e,"realizedPnL"),collateral:void 0,entryPrice:this.safeNumber(e,"avgPrice"),markPrice:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),marginMode:"cross",hedged:!0,maintenanceMargin:this.safeNumber(e,"minMargin"),maintenanceMarginPercentage:void 0,initialMargin:this.safeNumber(e,"margin"),initialMarginPercentage:void 0,marginRatio:void 0,lastUpdateTimestamp:void 0,lastPrice:this.safeNumber(e,"lastPrice"),stopLossPrice:void 0,takeProfitPrice:void 0,percentage:void 0,info:e})}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.privateGetApiV1FuturesLeverage(this.extend(i,t)),a=this.safeDict(r,0,{});return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){const s=this.safeStringLower(e,"marginType"),i=this.safeNumber(e,"leverage");return{info:e,symbol:t.symbol,marginMode:s,longLeverage:i,shortLeverage:i}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i={leverage:e},a=this.market(t);i.symbol=a.id;const o=await this.privatePostApiV1FuturesLeverage(this.extend(i,s));return this.parseLeverage(o,a)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetApiV1ExchangeInfo(t),i=this.safeList(s,"contracts",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeList(e,"riskLimits",[]),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=[];for(let e=0;e<s.length;e++){const i=s[e],o=this.safeString(i,"initialMargin");r.push({tier:this.sum(e,1),currency:t.settle,minNotional:void 0,maxNotional:this.safeNumber(i,"quantity"),maintenanceMarginRate:this.safeNumber(i,"maintMargin"),maxLeverage:this.parseNumber(a.Y.stringDiv("1",o)),info:i})}return r}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.spot)return i=await this.fetchTradingFees(t),this.safeDict(i,e);if(s.swap)return i=await this.privateGetApiV1FuturesCommissionRate(this.extend({symbol:s.id},t)),this.parseTradingFee(i,s);throw new r.NotSupported(this.id+" fetchTradingFee() is not supported for "+s.type+" type of markets")}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetApiV1AccountVipInfo(e),s=this.safeList(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=this.safeDict(s,e,{}),r=this.parseTradingFee(t);i[r.symbol]=r}return i}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:(t=this.safeMarket(s,t)).symbol,maker:this.safeNumber2(e,"openMakerFee","actualMakerRate"),taker:this.safeNumber2(e,"openTakerFee","actualTakerRate"),percentage:!0,tierBased:!0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o,d=this.urls.api[t]+"/"+e;if("private"===t){this.checkRequiredCredentials();const t={timestamp:this.milliseconds()},h=this.safeInteger(this.options,"recvWindow");let c;if(void 0!==h&&(t.recvWindow=h),r={"X-HK-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},"POST"!==s||"api/v1/spot/batchOrders"!==e&&"api/v1/futures/batchOrders"!==e){const e=this.extend(t,i);c=this.hmac(this.encode(this.customUrlencode(e)),this.encode(this.secret),n.s),e.signature=c,o=this.customUrlencode(e),"GET"===s?d+="?"+o:a=o}else r["Content-Type"]="application/json",a=this.json(this.safeList(i,"orders")),c=this.hmac(this.encode(this.customUrlencode(t)),this.encode(this.secret),n.s),o=this.customUrlencode(this.extend(t,{signature:c})),d+="?"+o;r["INPUT-SOURCE"]=this.safeString(this.options,"broker","10000700011"),r.broker_sign=c}else o=this.urlencode(i),0!==o.length&&(d+="?"+o);return{url:d,method:s,body:a,headers:r}}customUrlencode(e={}){let t=this.urlencode(e);return t=t.replace("%2C",","),t}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;let c=!1,l=this.safeString(n,"code",void 0);if(0===this.safeInteger(n,"code",void 0)){const e=this.safeList(n,"result",[]);for(let t=0;t<e.length;t++){const s=this.safeDict(e,t);0!==this.safeInteger(s,"code")&&(c=!0,l=this.safeString(s,"code"))}}if(200!==e||c){const e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,l,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),new r.ExchangeError(e)}}}},7996:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(706),r=s(1579),a=s(5147),o=s(2079),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"hitbtc",name:"HitBTC",countries:["HK"],rateLimit:3.333,version:"3",has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!1,option:void 0,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,closePosition:!1,createDepositAddress:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:void 0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!0,fetchLeverageTiers:void 0,fetchLiquidations:!1,fetchMarginMode:"emulated",fetchMarginModes:!0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!0,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!0,fetchTransactions:"emulated",fetchWithdrawals:!0,reduceMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},precisionMode:r.kb,urls:{logo:"https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",test:{public:"https://api.demo.hitbtc.com/api/3",private:"https://api.demo.hitbtc.com/api/3"},api:{public:"https://api.hitbtc.com/api/3",private:"https://api.hitbtc.com/api/3"},www:"https://hitbtc.com",referral:"https://hitbtc.com/?ref_id=5a5d39a65d466",doc:["https://api.hitbtc.com","https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"],fees:["https://hitbtc.com/fees-and-limits","https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"]},api:{public:{get:{"public/currency":10,"public/currency/{currency}":10,"public/symbol":10,"public/symbol/{symbol}":10,"public/ticker":10,"public/ticker/{symbol}":10,"public/price/rate":10,"public/price/history":10,"public/price/ticker":10,"public/price/ticker/{symbol}":10,"public/trades":10,"public/trades/{symbol}":10,"public/orderbook":10,"public/orderbook/{symbol}":10,"public/candles":10,"public/candles/{symbol}":10,"public/converted/candles":10,"public/converted/candles/{symbol}":10,"public/futures/info":10,"public/futures/info/{symbol}":10,"public/futures/history/funding":10,"public/futures/history/funding/{symbol}":10,"public/futures/candles/index_price":10,"public/futures/candles/index_price/{symbol}":10,"public/futures/candles/mark_price":10,"public/futures/candles/mark_price/{symbol}":10,"public/futures/candles/premium_index":10,"public/futures/candles/premium_index/{symbol}":10,"public/futures/candles/open_interest":10,"public/futures/candles/open_interest/{symbol}":10}},private:{get:{"spot/balance":15,"spot/balance/{currency}":15,"spot/order":1,"spot/order/{client_order_id}":1,"spot/fee":15,"spot/fee/{symbol}":15,"spot/history/order":15,"spot/history/trade":15,"margin/account":1,"margin/account/isolated/{symbol}":1,"margin/account/cross/{currency}":1,"margin/order":1,"margin/order/{client_order_id}":1,"margin/config":15,"margin/history/order":15,"margin/history/trade":15,"margin/history/positions":15,"margin/history/clearing":15,"futures/balance":15,"futures/balance/{currency}":15,"futures/account":1,"futures/account/isolated/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"futures/config":15,"futures/fee":15,"futures/fee/{symbol}":15,"futures/history/order":15,"futures/history/trade":15,"futures/history/positions":15,"futures/history/clearing":15,"wallet/balance":30,"wallet/balance/{currency}":30,"wallet/crypto/address":30,"wallet/crypto/address/recent-deposit":30,"wallet/crypto/address/recent-withdraw":30,"wallet/crypto/address/check-mine":30,"wallet/transactions":30,"wallet/transactions/{tx_id}":30,"wallet/crypto/fee/estimate":30,"wallet/airdrops":30,"wallet/amount-locks":30,"sub-account":15,"sub-account/acl":15,"sub-account/balance/{subAccID}":15,"sub-account/crypto/address/{subAccID}/{currency}":15},post:{"spot/order":1,"spot/order/list":1,"margin/order":1,"margin/order/list":1,"futures/order":1,"futures/order/list":1,"wallet/crypto/address":30,"wallet/crypto/withdraw":30,"wallet/convert":30,"wallet/transfer":30,"wallet/internal/withdraw":30,"wallet/crypto/check-offchain-available":30,"wallet/crypto/fees/estimate":30,"wallet/airdrops/{id}/claim":30,"sub-account/freeze":15,"sub-account/activate":15,"sub-account/transfer":15,"sub-account/acl":15},patch:{"spot/order/{client_order_id}":1,"margin/order/{client_order_id}":1,"futures/order/{client_order_id}":1},delete:{"spot/order":1,"spot/order/{client_order_id}":1,"margin/position":1,"margin/position/isolated/{symbol}":1,"margin/order":1,"margin/order/{client_order_id}":1,"futures/position":1,"futures/position/{margin_mode}/{symbol}":1,"futures/order":1,"futures/order/{client_order_id}":1,"wallet/crypto/withdraw/{id}":30},put:{"margin/account/isolated/{symbol}":1,"futures/account/isolated/{symbol}":1,"wallet/crypto/withdraw/{id}":30}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0009"),maker:this.parseNumber("0.0009"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0007")],[this.parseNumber("100"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("5000"),this.parseNumber("0.0002")],[this.parseNumber("10000"),this.parseNumber("0.0001")],[this.parseNumber("20000"),this.parseNumber("0")],[this.parseNumber("50000"),this.parseNumber("-0.0001")],[this.parseNumber("100000"),this.parseNumber("-0.0001")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0009")],[this.parseNumber("10"),this.parseNumber("0.0008")],[this.parseNumber("100"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0007")],[this.parseNumber("1000"),this.parseNumber("0.0006")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0004")],[this.parseNumber("50000"),this.parseNumber("0.0003")],[this.parseNumber("100000"),this.parseNumber("0.0002")]]}}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},exceptions:{exact:{429:o.RateLimitExceeded,500:o.ExchangeError,503:o.ExchangeNotAvailable,504:o.ExchangeNotAvailable,600:o.PermissionDenied,800:o.ExchangeError,1002:o.AuthenticationError,1003:o.PermissionDenied,1004:o.AuthenticationError,1005:o.AuthenticationError,2001:o.BadSymbol,2002:o.BadRequest,2003:o.BadRequest,2010:o.BadRequest,2011:o.BadRequest,2012:o.BadRequest,2020:o.BadRequest,2022:o.BadRequest,2024:o.InvalidOrder,10001:o.BadRequest,10021:o.AccountSuspended,10022:o.BadRequest,20001:o.InsufficientFunds,20002:o.OrderNotFound,20003:o.ExchangeError,20004:o.ExchangeError,20005:o.ExchangeError,20006:o.ExchangeError,20007:o.ExchangeError,20008:o.InvalidOrder,20009:o.InvalidOrder,20010:o.OnMaintenance,20011:o.ExchangeError,20012:o.ExchangeError,20014:o.ExchangeError,20016:o.ExchangeError,20018:o.ExchangeError,20031:o.ExchangeError,20032:o.ExchangeError,20033:o.ExchangeError,20034:o.ExchangeError,20040:o.ExchangeError,20041:o.ExchangeError,20042:o.ExchangeError,20043:o.ExchangeError,20044:o.PermissionDenied,20045:o.InvalidOrder,20047:o.InvalidOrder,20048:o.InvalidOrder,20049:o.InvalidOrder,20080:o.ExchangeError,21001:o.ExchangeError,21003:o.AccountSuspended,21004:o.AccountSuspended,22004:o.ExchangeError,22008:o.ExchangeError},broad:{}},options:{defaultNetwork:"ERC20",defaultNetworks:{ETH:"ETH",USDT:"TRC20"},networks:{BTC:"btc",OMNI:"BTC",ETH:"eth",ERC20:"ETH",ETC:"ETC",BEP20:"BSC",TRC20:"TRX",NEAR:"NEAR",DGB:"DGB",AE:"AE",AR:"AR",ADA:"ADA",CHZ:"CHZ",ABBC:"ABBC",ALGO:"ALGO",APT:"APT",ATOM:"ATOM",AVAXC:"AVAC",AVAXX:"AVAX",BSV:"BCHSV",BEP2:"BNB",CELO:"CELO",CKB:"CKB",CTXC:"CTXC",DASH:"DASH",DCR:"DCR",DOGE:"doge",EGLD:"EGLD",EOS:"EOS",ETHW:"ETHW",EVER:"EVER",FET:"FET",FIL:"FIL",FLOW:"FLOW",GLMR:"GLMR",GRIN:"GRIN",HBAR:"HBAR",HIVE:"HIVE",HYDRA:"HYDRA",ICP:"ICP",ICX:"ICX",IOST:"IOST",IOTA:"IOTA",IOTX:"IOTX",KAVA:"KAVA",KLAY:"KIM",KOMODO:"KMD",KSM:"KSM",LSK:"LSK",LTC:"ltc",MINA:"MINA",MOVR:"MOVR",NANO:"NANO",NEO:"NEO",ONE:"ONE",ONT:"ONT",OPTIMISM:"OP",PLCU:"PLCU",MATIC:"POLYGON",QTUM:"QTUM",REI:"REI",OASIS:"ROSE",RVN:"RVN",SC:"SC",SCRT:"SCRT",SOL:"SOL",STEEM:"STEEM",THETA:"Theta",TRUE:"TRUE",VET:"VET",VSYS:"VSYS",WAVES:"WAVES",WAX:"WAX",XCH:"XCH",XEC:"XEC",NEM:"XEM",XLM:"XLM",XMR:"xmr",XRD:"XRD",XRP:"XRP",XTZ:"XTZ",XVG:"XVG",XYM:"XYM",ZEC:"ZEC",ZEN:"ZEN",ZIL:"ZIL"},accountsByType:{spot:"spot",funding:"wallet",swap:"derivatives",future:"derivatives"},withdraw:{includeFee:!1}},commonCurrencies:{AUTO:"Cube",BCC:"BCC",BDP:"BidiPass",BET:"DAO.Casino",BIT:"BitRewards",BOX:"BOX Token",CPT:"Cryptaur",GET:"Themis",GMT:"GMT Token",HSR:"HC",IQ:"IQ.Cash",LNC:"LinkerCoin",PLA:"PlayChip",PNT:"Penta",SBTC:"Super Bitcoin",STEPN:"GMT",STX:"STOX",TV:"Tokenville",XMT:"MTL",XPNT:"PNT"}})}nonce(){return this.milliseconds()}async fetchMarkets(e={}){const t=await this.publicGetPublicSymbol(e),s=[],i=Object.keys(t);for(let e=0;e<i.length;e++){const r=i[e];if(r.endsWith("_BQX"))continue;const o=this.safeValue(t,r),n=this.safeString(o,"type"),d=this.safeInteger(o,"expiry"),h="futures"===n,c="spot"===n,l=this.safeBool(o,"margin_trading",!1),u=c&&l,p=void 0!==d,f=h&&!p,m=!1,g=this.safeString2(o,"base_currency","underlying"),v=this.safeString(o,"quote_currency"),y=this.safeString(o,"fee_currency"),w=this.safeCurrencyCode(g),b=this.safeCurrencyCode(v),S=this.safeCurrencyCode(y);let k,O,T,P,I,x=w+"/"+b,A="spot";h&&(T=this.parseNumber("1"),k=y,O=this.safeCurrencyCode(k),P=void 0!==b&&b===O,I=!P,x=x+":"+O,p?(x=x+"-"+d,A="future"):A="swap");const M=this.safeString(o,"quantity_increment"),C=this.safeString(o,"tick_size"),E=this.parseNumber(M),_=this.parseNumber(C);s.push({id:r,symbol:x,base:w,quote:b,settle:O,baseId:g,quoteId:v,settleId:k,type:A,spot:c,margin:u,swap:f,future:p,option:m,active:!0,contract:h,linear:P,inverse:I,taker:this.safeNumber(o,"take_rate"),maker:this.safeNumber(o,"make_rate"),contractSize:T,expiry:d,expiryDatetime:void 0,strike:void 0,optionType:void 0,feeCurrency:S,precision:{amount:E,price:_},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(o,"max_initial_leverage",1)},amount:{min:E,max:void 0},price:{min:_,max:void 0},cost:{min:this.parseNumber(a.Y.stringMul(M,C)),max:void 0}},created:void 0,info:o})}return s}async fetchCurrencies(e={}){const t=await this.publicGetPublicCurrency(e),s={},i=Object.keys(t);for(let e=0;e<i.length;e++){const r=i[e],a=this.safeCurrencyCode(r),o=t[r],n=this.safeString(o,"full_name"),d=this.safeNumber(o,"precision_transfer"),h=this.safeBool(o,"payin_enabled",!1),c=this.safeBool(o,"payout_enabled",!1),l=this.safeBool(o,"transfer_enabled",!1),u=h&&c&&l,p=this.safeValue(o,"networks",[]),f={};let m,g,v;for(let e=0;e<p.length;e++){const t=p[e],s=this.safeString2(t,"protocol","network"),i=this.safeNetwork(s);m=this.safeNumber(t,"payout_fee");const r=this.safeNumber(t,"precision_payout"),a=this.safeBool(t,"payin_enabled",!1),o=this.safeBool(t,"payout_enabled",!1),n=a&&o;a&&!g?g=!0:a||(g=!1),o&&!v?v=!0:o||(v=!1),f[i]={info:t,id:s,network:i,fee:m,active:n,deposit:a,withdraw:o,precision:r,limits:{withdraw:{min:void 0,max:void 0}}}}const y=Object.keys(f).length;s[a]={info:o,code:a,id:r,precision:d,name:n,active:u,deposit:g,withdraw:v,networks:f,fee:y<=1?m:void 0,limits:{amount:{min:void 0,max:void 0}}}}return s}safeNetwork(e){return void 0===e?void 0:e.toUpperCase()}async createDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=this.safeStringUpper(t,"network");if(void 0!==i&&"USDT"===e){const e=this.safeValue(this.options,"networks"),r=this.safeString(e,i);void 0!==r&&(s.currency=r),t=this.omit(t,"network")}const r=await this.privatePostWalletCryptoAddress(this.extend(s,t)),a=this.safeString(r,"currency");return{currency:this.safeCurrencyCode(a),address:this.safeString(r,"address"),tag:this.safeString(r,"payment_id"),network:void 0,info:r}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=this.safeStringUpper(t,"network");if(void 0!==i&&"USDT"===e){const e=this.safeValue(this.options,"networks"),r=this.safeString(e,i);void 0!==r&&(s.currency=r),t=this.omit(t,"network")}const r=await this.privateGetWalletCryptoAddress(this.extend(s,t)),a=this.safeValue(r,0),o=this.safeString(a,"address"),n=this.safeString(a,"currency"),d=this.safeString(a,"payment_id"),h=this.safeCurrencyCode(n);return{info:r,address:o,tag:d,code:h,currency:h,network:void 0}}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.used=this.safeString(i,"reserved"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeStringLower(e,"type","spot");e=this.omit(e,["type"]);const s=this.safeValue(this.options,"accountsByType",{}),i=this.safeString(s,t,t);let r;if("wallet"===i)r=await this.privateGetWalletBalance(e);else if("spot"===i)r=await this.privateGetSpotBalance(e);else{if("derivatives"!==i){const e=Object.keys(s);throw new o.BadRequest(this.id+" fetchBalance() type parameter must be one of "+e.join(", "))}r=await this.privateGetFuturesBalance(e)}return this.parseBalance(r)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetPublicTickerSymbol(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==(e=this.marketSymbols(e))){const t=this.marketIds(e).join(",");s.symbols=t}const i=await this.publicGetPublicTicker(this.extend(s,t)),r={},a=Object.keys(i);for(let e=0;e<a.length;e++){const t=a[e],s=this.safeMarket(t),o=s.symbol,n=i[t];r[o]=this.parseTicker(n,s)}return this.filterByArrayTickers(r,"symbol",e)}parseTicker(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeSymbol(void 0,t),r=this.safeString(e,"volume"),a=this.safeString(e,"volume_quote"),o=this.safeString(e,"open"),n=this.safeString(e,"last");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:o,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:a,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let o;if(void 0!==s&&(a.limit=Math.min(s,1e3)),void 0!==t&&(a.from=t),void 0!==e?(r=this.market(e),a.symbol=r.id,o=await this.publicGetPublicTradesSymbol(this.extend(a,i))):o=await this.publicGetPublicTrades(this.extend(a,i)),void 0!==e)return this.parseTrades(o,r);let n=[];const d=Object.keys(o);for(let e=0;e<d.length;e++){const t=d[e],s=this.market(t),i=o[t],r=this.parseTrades(i,s);n=this.arrayConcat(n,r)}return n}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let n,d,h;if(void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==s&&(a.limit=s),void 0!==t&&(a.from=t),[n,i]=this.handleMarketTypeAndParams("fetchMyTrades",r,i),[d,i]=this.handleMarginModeAndParams("fetchMyTrades",i),i=this.omit(i,["marginMode","margin"]),void 0!==d)h=await this.privateGetMarginHistoryTrade(this.extend(a,i));else if("spot"===n)h=await this.privateGetSpotHistoryTrade(this.extend(a,i));else if("swap"===n)h=await this.privateGetFuturesHistoryTrade(this.extend(a,i));else{if("margin"!==n)throw new o.NotSupported(this.id+" fetchMyTrades() not support this market type");h=await this.privateGetMarginHistoryTrade(this.extend(a,i))}return this.parseTrades(h,r,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.timestamp),i=this.safeString(e,"symbol"),r=(t=this.safeMarket(i,t)).symbol;let a;const o=this.safeString(e,"fee"),n=this.safeValue(e,"taker");let d;if(d=void 0!==n?n?"taker":"maker":"taker",void 0!==o){const e=this.safeValue(t,"info",{}),s=this.safeString(e,"fee_currency");a={cost:o,currency:this.safeCurrencyCode(s)}}const h=this.safeString2(e,"clientOrderId","client_order_id"),c=this.safeString(e,"price"),l=this.safeString2(e,"quantity","qty"),u=this.safeString(e,"side"),p=this.safeString(e,"id");return this.safeTrade({info:e,id:p,order:h,timestamp:s,datetime:this.iso8601(s),symbol:r,type:void 0,side:u,takerOrMaker:d,price:c,amount:l,cost:void 0,fee:a},t)}async fetchTransactionsHelper(e,t,s,i,r){await this.loadMarkets();const a={types:e};let o;void 0!==t&&(o=this.currency(t),a.currencies=o.id),void 0!==s&&(a.from=this.iso8601(s)),void 0!==i&&(a.limit=i);const n=await this.privateGetWalletTransactions(this.extend(a,r));return this.parseTransactions(n,o,s,i,r)}parseTransactionStatus(e){return this.safeString({CREATED:"pending",PENDING:"pending",FAILED:"failed",ROLLED_BACK:"failed",SUCCESS:"ok"},e,e)}parseTransactionType(e){return this.safeString({DEPOSIT:"deposit",WITHDRAW:"withdrawal"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"operation_id","id"),i=this.parse8601(this.safeString(e,"created_at")),r=this.parse8601(this.safeString(e,"updated_at")),a=this.parseTransactionType(this.safeString(e,"type")),o=this.parseTransactionStatus(this.safeString(e,"status")),n=this.safeValue(e,"native",{}),d=this.safeString(n,"currency"),h=this.safeCurrencyCode(d),c=this.safeString(n,"hash"),l=this.safeString(n,"address"),u=l,p=this.safeString(n,"payment_id"),f=p,m=this.safeValue(n,"senders"),g=this.safeString(m,0),v=this.safeNumber(n,"amount"),y="OFFCHAIN"===this.safeString(e,"subtype"),w={currency:void 0,cost:void 0,rate:void 0},b=this.safeNumber(n,"fee");return void 0!==b&&(w.currency=h,w.cost=b),{info:e,id:s,txid:c,type:a,currency:h,network:void 0,amount:v,status:o,timestamp:i,datetime:this.iso8601(i),address:l,addressFrom:g,addressTo:u,tag:p,tagFrom:void 0,tagTo:f,updated:r,comment:void 0,internal:y,fee:w}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT,WITHDRAW",e,t,s,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("DEPOSIT",e,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactionsHelper("WITHDRAW",e,t,s,i)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};if(void 0!==e){const t=this.marketIds(e);i.symbols=t.join(",")}void 0!==t&&(i.depth=t);const r=await this.publicGetPublicOrderbook(this.extend(i,s)),a={},o=Object.keys(r);for(let e=0;e<o.length;e++){const t=o[e],s=r[t],i=this.safeSymbol(t),n=this.parse8601(this.safeString(s,"timestamp"));a[i]=this.parseOrderBook(r[t],i,n,"bid","ask")}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.depth=t);const r=await this.publicGetPublicOrderbookSymbol(this.extend(i,s)),a=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(r,e,a,"bid","ask")}parseTradingFee(e,t=void 0){const s=this.safeNumber(e,"take_rate"),i=this.safeNumber(e,"make_rate"),r=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(r,t),taker:s,maker:i,percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;if("spot"===s.type)r=await this.privateGetSpotFeeSymbol(this.extend(i,t));else{if("swap"!==s.type)throw new o.NotSupported(this.id+" fetchTradingFee() not support this market type");r=await this.privateGetFuturesFeeSymbol(this.extend(i,t))}return this.parseTradingFee(r,s)}async fetchTradingFees(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchTradingFees",void 0,e);let i;if("spot"===t)i=await this.privateGetSpotFee(s);else{if("swap"!==t)throw new o.NotSupported(this.id+" fetchTradingFees() not support this market type");i=await this.privateGetFuturesFee(s)}const r={};for(let e=0;e<i.length;e++){const t=this.parseTradingFee(i[e]);r[t.symbol]=t}return r}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1e3);const o=this.market(e);let n={symbol:o.id,period:this.safeString(this.timeframes,t,t)};void 0!==s&&(n.from=this.iso8601(s)),[n,r]=this.handleUntilOption("until",n,r),void 0!==i&&(n.limit=Math.min(i,1e3));const d=this.safeString(r,"price");let h;return r=this.omit(r,"price"),h="mark"===d?await this.publicGetPublicFuturesCandlesMarkPriceSymbol(this.extend(n,r)):"index"===d?await this.publicGetPublicFuturesCandlesIndexPriceSymbol(this.extend(n,r)):"premiumIndex"===d?await this.publicGetPublicFuturesCandlesPremiumIndexSymbol(this.extend(n,r)):await this.publicGetPublicCandlesSymbol(this.extend(n,r)),this.parseOHLCVs(h,o,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"max"),this.safeNumber(e,"min"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let n,d,h;if(void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.from=this.iso8601(t)),void 0!==s&&(a.limit=s),[n,i]=this.handleMarketTypeAndParams("fetchClosedOrders",r,i),[d,i]=this.handleMarginModeAndParams("fetchClosedOrders",i),i=this.omit(i,["marginMode","margin"]),void 0!==d)h=await this.privateGetMarginHistoryOrder(this.extend(a,i));else if("spot"===n)h=await this.privateGetSpotHistoryOrder(this.extend(a,i));else if("swap"===n)h=await this.privateGetFuturesHistoryOrder(this.extend(a,i));else{if("margin"!==n)throw new o.NotSupported(this.id+" fetchClosedOrders() not support this market type");h=await this.privateGetMarginHistoryOrder(this.extend(a,i))}const c=this.parseOrders(h,r,t,s);return this.filterByArray(c,"status",["closed","canceled"],!1)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={client_order_id:e};let a,n,d;if([a,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),[n,s]=this.handleMarginModeAndParams("fetchOrder",s),s=this.omit(s,["marginMode","margin"]),void 0!==n)d=await this.privateGetMarginHistoryOrder(this.extend(r,s));else if("spot"===a)d=await this.privateGetSpotHistoryOrder(this.extend(r,s));else if("swap"===a)d=await this.privateGetFuturesHistoryOrder(this.extend(r,s));else{if("margin"!==a)throw new o.NotSupported(this.id+" fetchOrder() not support this market type");d=await this.privateGetMarginHistoryOrder(this.extend(r,s))}const h=this.safeDict(d,0);return this.parseOrder(h,i)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const n={order_id:e};let d,h,c;if([d,r]=this.handleMarketTypeAndParams("fetchOrderTrades",a,r),[h,r]=this.handleMarginModeAndParams("fetchOrderTrades",r),r=this.omit(r,["marginMode","margin"]),void 0!==h)c=await this.privateGetMarginHistoryTrade(this.extend(n,r));else if("spot"===d)c=await this.privateGetSpotHistoryTrade(this.extend(n,r));else if("swap"===d)c=await this.privateGetFuturesHistoryTrade(this.extend(n,r));else{if("margin"!==d)throw new o.NotSupported(this.id+" fetchOrderTrades() not support this market type");c=await this.privateGetMarginHistoryTrade(this.extend(n,r))}return this.parseTrades(c,a,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let n,d,h;if(void 0!==e&&(r=this.market(e),a.symbol=r.id),[n,i]=this.handleMarketTypeAndParams("fetchOpenOrders",r,i),[d,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),i=this.omit(i,["marginMode","margin"]),void 0!==d)h=await this.privateGetMarginOrder(this.extend(a,i));else if("spot"===n)h=await this.privateGetSpotOrder(this.extend(a,i));else if("swap"===n)h=await this.privateGetFuturesOrder(this.extend(a,i));else{if("margin"!==n)throw new o.NotSupported(this.id+" fetchOpenOrders() not support this market type");h=await this.privateGetMarginOrder(this.extend(a,i))}return this.parseOrders(h,r,t,s)}async fetchOpenOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={client_order_id:e};let a,n,d;if([a,s]=this.handleMarketTypeAndParams("fetchOpenOrder",i,s),[n,s]=this.handleMarginModeAndParams("fetchOpenOrder",s),s=this.omit(s,["marginMode","margin"]),void 0!==n)d=await this.privateGetMarginOrderClientOrderId(this.extend(r,s));else if("spot"===a)d=await this.privateGetSpotOrderClientOrderId(this.extend(r,s));else if("swap"===a)d=await this.privateGetFuturesOrderClientOrderId(this.extend(r,s));else{if("margin"!==a)throw new o.NotSupported(this.id+" fetchOpenOrder() not support this market type");d=await this.privateGetMarginOrderClientOrderId(this.extend(r,s))}return this.parseOrder(d,i)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};let r,a,n;if(void 0!==e&&(s=this.market(e),i.symbol=s.id),[r,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[a,t]=this.handleMarginModeAndParams("cancelAllOrders",t),t=this.omit(t,["marginMode","margin"]),void 0!==a)n=await this.privateDeleteMarginOrder(this.extend(i,t));else if("spot"===r)n=await this.privateDeleteSpotOrder(this.extend(i,t));else if("swap"===r)n=await this.privateDeleteFuturesOrder(this.extend(i,t));else{if("margin"!==r)throw new o.NotSupported(this.id+" cancelAllOrders() not support this market type");n=await this.privateDeleteMarginOrder(this.extend(i,t))}return this.parseOrders(n,s)}async cancelOrder(e,t=void 0,s={}){let i;await this.loadMarkets();const r={client_order_id:e};let a,n,d;if(void 0!==t&&(i=this.market(t)),[a,s]=this.handleMarketTypeAndParams("cancelOrder",i,s),[n,s]=this.handleMarginModeAndParams("cancelOrder",s),s=this.omit(s,["marginMode","margin"]),void 0!==n)d=await this.privateDeleteMarginOrderClientOrderId(this.extend(r,s));else if("spot"===a)d=await this.privateDeleteSpotOrderClientOrderId(this.extend(r,s));else if("swap"===a)d=await this.privateDeleteFuturesOrderClientOrderId(this.extend(r,s));else{if("margin"!==a)throw new o.NotSupported(this.id+" cancelOrder() not support this market type");d=await this.privateDeleteMarginOrderClientOrderId(this.extend(r,s))}return this.parseOrder(d,i)}async editOrder(e,t,s,i,r=void 0,a=void 0,n={}){let d;await this.loadMarkets();const h={client_order_id:e,quantity:this.amountToPrecision(t,r)};if("limit"===s||"stopLimit"===s){if(void 0===a)throw new o.ExchangeError(this.id+" editOrder() limit order requires price");h.price=this.priceToPrecision(t,a)}let c,l,u;if(void 0!==t&&(d=this.market(t)),[c,n]=this.handleMarketTypeAndParams("editOrder",d,n),[l,n]=this.handleMarginModeAndParams("editOrder",n),n=this.omit(n,["marginMode","margin"]),void 0!==l)u=await this.privatePatchMarginOrderClientOrderId(this.extend(h,n));else if("spot"===c)u=await this.privatePatchSpotOrderClientOrderId(this.extend(h,n));else if("swap"===c)u=await this.privatePatchFuturesOrderClientOrderId(this.extend(h,n));else{if("margin"!==c)throw new o.NotSupported(this.id+" editOrder() not support this market type");u=await this.privatePatchMarginOrderClientOrderId(this.extend(h,n))}return this.parseOrder(u,d)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e);let n,d,h,c;return[d,a]=this.handleMarketTypeAndParams("createOrder",o,a),[h,a]=this.handleMarginModeAndParams("createOrder",a),[n,a]=this.createOrderRequest(o,d,t,s,i,r,h,a),c="swap"===d?await this.privatePostFuturesOrder(this.extend(n,a)):"margin"===d||void 0!==h?await this.privatePostMarginOrder(this.extend(n,a)):await this.privatePostSpotOrder(this.extend(n,a)),this.parseOrder(c,o)}createOrderRequest(e,t,s,i,r,a=void 0,n=void 0,d={}){const h="limit"===s,c=this.safeValue(d,"reduceOnly"),l=this.safeString(d,"timeInForce"),u=this.safeNumberN(d,["triggerPrice","stopPrice","stop_price"]),p=this.isPostOnly("market"===s,void 0,d),f={type:s,side:i,quantity:this.amountToPrecision(e.symbol,r),symbol:e.id};if(void 0!==c&&"swap"!==e.type&&"margin"!==e.type)throw new o.InvalidOrder(this.id+" createOrder() does not support reduce_only for "+e.type+" orders, reduce_only orders are supported for swap and margin markets only");if(!0===c&&(f.reduce_only=c),p&&(f.post_only=!0),void 0!==l&&(f.time_in_force=l),h||"stopLimit"===s||"takeProfitLimit"===s){if(void 0===a)throw new o.ExchangeError(this.id+" createOrder() requires a price argument for limit orders");f.price=this.priceToPrecision(e.symbol,a)}if("GTD"===l){if(void 0===this.safeString(d,"expire_time"))throw new o.ExchangeError(this.id+" createOrder() requires an expire_time parameter for a GTD order")}if(void 0!==u)f.stop_price=this.priceToPrecision(e.symbol,u),h?f.type="stopLimit":"market"===s&&(f.type="stopMarket");else if("stopLimit"===s||"stopMarket"===s||"takeProfitLimit"===s||"takeProfitMarket"===s)throw new o.ExchangeError(this.id+" createOrder() requires a stopPrice parameter for stop-loss and take-profit orders");return d=this.omit(d,["triggerPrice","timeInForce","stopPrice","stop_price","reduceOnly","postOnly"]),"swap"===t&&(void 0===n&&(n="cross"),f.margin_mode=n),[f,d]}parseOrderStatus(e){return this.safeString({new:"open",suspended:"open",partiallyFilled:"open",filled:"closed",canceled:"canceled",expired:"failed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"client_order_id"),i=this.safeString(e,"side"),r=this.safeString(e,"type"),a=this.safeString(e,"quantity"),o=this.safeString(e,"price"),n=this.safeString(e,"price_average"),d=this.safeString(e,"created_at"),h=this.parse8601(d),c=this.safeString(e,"updated_at");let l;c!==d&&(l=this.parse8601(c));const u=this.safeString(e,"quantity_cumulative"),p=this.parseOrderStatus(this.safeString(e,"status")),f=this.safeString(e,"symbol"),m=(t=this.safeMarket(f,t)).symbol,g=this.safeValue(e,"post_only"),v=this.safeString(e,"time_in_force"),y=this.safeValue(e,"trades"),w=this.safeString(e,"stop_price");return this.safeOrder({info:e,id:s,clientOrderId:s,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:l,lastUpdateTimestamp:l,symbol:m,price:o,amount:a,type:r,side:i,timeInForce:v,postOnly:g,reduceOnly:this.safeValue(e,"reduce_only"),filled:u,remaining:void 0,cost:void 0,status:p,average:n,trades:y,fee:void 0,stopPrice:w,triggerPrice:w,takeProfitPrice:void 0,stopLossPrice:void 0},t)}async fetchMarginModes(e=void 0,t={}){let s,i,r;if(await this.loadMarkets(),void 0!==e&&(e=this.marketSymbols(e),s=this.market(e[0])),[i,t]=this.handleMarketTypeAndParams("fetchMarginMode",s,t),"margin"===i)r=await this.privateGetMarginConfig(t);else{if("swap"!==i)throw new o.BadSymbol(this.id+" fetchMarginModes () supports swap contracts and margin only");r=await this.privateGetFuturesConfig(t)}const a=this.safeList(r,"config",[]);return this.parseMarginModes(a,e,"symbol")}parseMarginMode(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"margin_mode")}}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),n=this.currencyToPrecision(e,t),d=this.safeValue(this.options,"accountsByType",{});s=s.toLowerCase(),i=i.toLowerCase();const h=this.safeString(d,s,s),c=this.safeString(d,i,i);if(h===c)throw new o.BadRequest(this.id+" transfer() fromAccount and toAccount arguments cannot be the same account");const l={currency:a.id,amount:n,source:h,destination:c},u=await this.privatePostWalletTransfer(this.extend(l,r));return this.parseTransfer(u,a)}parseTransfer(e,t=void 0){return{id:this.safeString(e,0),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0,info:e}}async convertCurrencyNetwork(e,t,s,i,r){if(await this.loadMarkets(),"USDT"!==e)throw new o.ExchangeError(this.id+" convertCurrencyNetwork() only supports USDT currently");const a=this.safeValue(this.options,"networks",{});if(s=s.toUpperCase(),i=i.toUpperCase(),(s=this.safeString(a,s))===(i=this.safeString(a,i)))throw new o.BadRequest(this.id+" convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork");if(void 0===s||void 0===i){const e=Object.keys(a);throw new o.ArgumentsRequired(this.id+" convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "+e.join(", "))}const n={from_currency:s,to_currency:i,amount:this.currencyToPrecision(e,t)};return{info:await this.privatePostWalletConvert(this.extend(n,r))}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets(),this.checkAddress(s);const a=this.currency(e),o={currency:a.id,amount:t,address:s};void 0!==i&&(o.payment_id=i);const n=this.safeValue(this.options,"networks",{}),d=this.safeStringUpper(r,"network");if(void 0!==d&&"USDT"===e){const e=this.safeString(n,d);void 0!==e&&(o.network_code=e),r=this.omit(r,"network")}const h=this.safeValue(this.options,"withdraw",{});this.safeBool(h,"includeFee",!1)&&(o.include_fee=!0);const c=await this.privatePostWalletCryptoWithdraw(this.extend(o,r));return this.parseTransaction(c,a)}async fetchFundingRates(e=void 0,t={}){let s;await this.loadMarkets();const i={};if(void 0!==e){e=this.marketSymbols(e),s=this.market(e[0]);const t=this.marketIds(e);i.symbols=t.join(",")}let r;if([r,t]=this.handleMarketTypeAndParams("fetchFundingRates",s,t),"swap"!==r)throw new o.NotSupported(this.id+" fetchFundingRates() does not support "+r+" markets");const a=await this.publicGetPublicFuturesInfo(this.extend(i,t)),n=Object.keys(a),d={};for(let e=0;e<n.length;e++){const t=this.safeString(n,e),s=this.safeValue(a,t),i=this.market(t),r=i.symbol,o=this.parseFundingRate(s,i);d[r]=o}return this.filterByArray(d,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,1e3);let o={};[o,i]=this.handleUntilOption("until",o,i),void 0!==e&&(r=this.market(e),e=r.symbol,o.symbols=r.id),void 0!==t&&(o.from=t),void 0!==s&&(o.limit=s);const n=await this.publicGetPublicFuturesHistoryFunding(this.extend(o,i)),d=Object.keys(n),h=[];for(let e=0;e<d.length;e++){const t=d[e],s=this.safeMarket(t),i=n[t];for(let e=0;e<i.length;e++){const t=i[e],r=this.safeSymbol(s.symbol),a=this.safeNumber(t,"funding_rate"),o=this.safeString(t,"timestamp");h.push({info:t,symbol:r,fundingRate:a,timestamp:this.parse8601(o),datetime:o})}}const c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};let i,r,a;if([i,t]=this.handleMarketTypeAndParams("fetchPositions",void 0,t),"spot"===i&&(i="swap"),[r,t]=this.handleMarginModeAndParams("fetchPositions",t),t=this.omit(t,["marginMode","margin"]),void 0!==r)a=await this.privateGetMarginAccount(this.extend(s,t));else if("swap"===i)a=await this.privateGetFuturesAccount(this.extend(s,t));else{if("margin"!==i)throw new o.NotSupported(this.id+" fetchPositions() not support this market type");a=await this.privateGetMarginAccount(this.extend(s,t))}const n=[];for(let e=0;e<a.length;e++)n.push(this.parsePosition(a[e]));return n}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a,n;if([r,t]=this.handleMarketTypeAndParams("fetchPosition",void 0,t),[a,t]=this.handleMarginModeAndParams("fetchPosition",t),t=this.omit(t,["marginMode","margin"]),void 0!==a)n=await this.privateGetMarginAccountIsolatedSymbol(this.extend(i,t));else if("swap"===r)n=await this.privateGetFuturesAccountIsolatedSymbol(this.extend(i,t));else{if("margin"!==r)throw new o.NotSupported(this.id+" fetchPosition() not support this market type");n=await this.privateGetMarginAccountIsolatedSymbol(this.extend(i,t))}return this.parsePosition(n,s)}parsePosition(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeNumber(e,"leverage"),r=this.safeString(e,"updated_at"),a=this.safeValue(e,"positions",[]);let o,n,d;for(let e=0;e<a.length;e++){const t=a[e];o=this.safeNumber(t,"price_liquidation"),n=this.safeNumber(t,"price_entry"),d=this.safeNumber(t,"quantity")}const h=this.safeValue(e,"currencies",[]);let c;for(let e=0;e<h.length;e++){const t=h[e];c=this.safeNumber(t,"margin_balance")}const l=this.safeString(e,"symbol"),u=(t=this.safeMarket(l,t)).symbol;return this.safePosition({info:e,id:void 0,symbol:u,notional:void 0,marginMode:s,marginType:s,liquidationPrice:o,entryPrice:n,unrealizedPnl:void 0,percentage:void 0,contracts:d,contractSize:void 0,markPrice:void 0,lastPrice:void 0,side:void 0,hedged:void 0,timestamp:this.parse8601(r),datetime:r,lastUpdateTimestamp:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:c,initialMargin:void 0,initialMarginPercentage:void 0,leverage:i,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeNumber(e,"open_interest");return this.safeOpenInterest({symbol:t.symbol,openInterestAmount:void 0,openInterestValue:i,timestamp:this.parse8601(s),datetime:s,info:e},t)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new o.BadSymbol(this.id+" fetchOpenInterest() supports swap contracts only");const i={symbol:s.id},r=await this.publicGetPublicFuturesInfoSymbol(this.extend(i,t));return this.parseOpenInterest(r,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new o.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id},r=await this.publicGetPublicFuturesInfoSymbol(this.extend(i,t));return this.parseFundingRate(r,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"next_funding_time"),i=this.safeString(e,"timestamp");return{info:e,symbol:this.safeSymbol(void 0,t),markPrice:this.safeNumber(e,"mark_price"),indexPrice:this.safeNumber(e,"index_price"),interestRate:this.safeNumber(e,"interest_rate"),estimatedSettlePrice:void 0,timestamp:this.parse8601(i),datetime:i,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:this.parse8601(s),fundingDatetime:s,nextFundingRate:this.safeNumber(e,"indicative_funding_rate"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(i,"leverage");if(r.swap&&void 0===a)throw new o.ArgumentsRequired(this.id+" modifyMarginHelper() requires a leverage parameter for swap markets");const n=this.numberToString(t);t="0"!==n?this.amountToPrecision(e,n):"0";const d={symbol:r.id,margin_balance:t};let h,c,l;if(void 0!==a&&(d.leverage=a),[h,i]=this.handleMarketTypeAndParams("modifyMarginHelper",r,i),[c,i]=this.handleMarginModeAndParams("modifyMarginHelper",i),"swap"===h)l=await this.privatePutFuturesAccountIsolatedSymbol(this.extend(d,i));else{if("margin"!==h&&"spot"!==h&&"isolated"!==c)throw new o.NotSupported(this.id+" modifyMarginHelper() not support this market type");l=await this.privatePutMarginAccountIsolatedSymbol(this.extend(d,i))}return this.extend(this.parseMarginModification(l,r),{amount:this.parseNumber(t),type:s})}parseMarginModification(e,t=void 0){const s=this.safeValue(e,"currencies",[]),i=this.safeValue(s,0),r=this.safeString(e,"updated_at");return{info:e,symbol:t.symbol,type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:this.safeString(i,"code"),status:void 0,timestamp:this.parse8601(r),datetime:r}}async reduceMargin(e,t,s={}){if("0"!==this.numberToString(t))throw new o.BadRequest(this.id+" reduceMargin() on hitbtc requires the amount to be 0 and that will remove the entire margin amount");return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a;if([r,t]=this.handleMarginModeAndParams("fetchLeverage",t),t=this.omit(t,["marginMode","margin"]),void 0!==r)a=await this.privateGetMarginAccountIsolatedSymbol(this.extend(i,t));else if("spot"===s.type)a=await this.privateGetMarginAccountIsolatedSymbol(this.extend(i,t));else if("swap"===s.type)a=await this.privateGetFuturesAccountIsolatedSymbol(this.extend(i,t));else{if("margin"!==s.type)throw new o.NotSupported(this.id+" fetchLeverage() not support this market type");a=await this.privateGetMarginAccountIsolatedSymbol(this.extend(i,t))}return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"leverage");return{info:e,symbol:this.safeSymbol(s,t),marginMode:this.safeStringLower(e,"type"),longLeverage:i,shortLeverage:i}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(await this.loadMarkets(),void 0===s.margin_balance)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair");const i=this.market(t),r=this.safeNumber(s,"margin_balance"),a=this.safeInteger(i.limits.leverage,"max",50);if("swap"!==i.type)throw new o.BadSymbol(this.id+" setLeverage() supports swap contracts only");if(e<1||e>a)throw new o.BadRequest(this.id+" setLeverage() leverage should be between 1 and "+a.toString()+" for "+t);const n={symbol:i.id,leverage:e.toString(),margin_balance:this.amountToPrecision(t,r)};return await this.privatePutFuturesAccountIsolatedSymbol(this.extend(n,s))}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetPublicCurrency(t);return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networks",[]),i=this.depositWithdrawFee(e);for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"network"),a=this.networkIdToCode(r),o=this.safeNumber(t,"payout_fee"),n={fee:o,percentage:void 0===o&&void 0};!0===this.safeValue(t,"default")&&(i.withdraw=n),i.networks[a]={withdraw:n,deposit:{fee:void 0,percentage:void 0}}}return i}async closePosition(e,t=void 0,s={}){let i;await this.loadMarkets(),[i,s]=this.handleMarginModeAndParams("closePosition",s,"cross");const r=this.market(e),a={symbol:r.id,margin_mode:i},o=await this.privateDeleteFuturesPositionMarginModeSymbol(this.extend(a,s));return this.parseOrder(o,r)}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),r=this.safeBool(t,"margin",!1);let a;return[a,t]=super.handleMarginModeAndParams(e,t,s),void 0===a&&("margin"!==i&&!0!==r||(a="isolated")),[a,t]}handleErrors(e,t,s,i,r,a,n,d,h){const c=this.safeValue(n,"error"),l=this.safeString(c,"code");if(void 0!==l){const e=this.id+" "+a,t=this.safeString2(c,"message","description");throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new o.ExchangeError(e)}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),d=this.implodeParams(e,i);let h,c=this.urls.api[t]+"/"+d;const l=Object.keys(o).length;if(r={"Content-Type":"application/json"},"GET"===s?l&&(h="?"+this.urlencode(o),c+=h):a=this.json(i),"private"===t){this.checkRequiredCredentials();const e=this.nonce().toString(),t=[s,"/api/3/"+d];"GET"===s?void 0!==h&&t.push(h):t.push(a),t.push(e);const i=t.join(""),o=this.hmac(this.encode(i),this.encode(this.secret),n.s,"hex"),c=this.apiKey+":"+o+":"+e,l=this.stringToBase64(c);r.Authorization="HS256 "+l}return{url:c,method:s,body:a,headers:r}}}},3947:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(7996);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"hitbtc3",alias:!0})}}},4455:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1180),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"hollaex",name:"HollaEx",countries:["KR"],rateLimit:250,version:"v2",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createLimitBuyOrder:!0,createLimitSellOrder:!0,createMarketBuyOrder:!0,createMarketSellOrder:!0,createOrder:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:"emulated",fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","1h":"1h","4h":"4h","1d":"1d","1w":"1w"},urls:{logo:"https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg",test:{rest:"https://api.sandbox.hollaex.com"},api:{rest:"https://api.hollaex.com"},www:"https://hollaex.com",doc:"https://apidocs.hollaex.com",referral:"https://pro.hollaex.com/signup?affiliation_code=QSWA6G"},precisionMode:o.kb,requiredCredentials:{apiKey:!0,secret:!0},api:{public:{get:{health:1,constants:1,kit:1,tiers:1,ticker:1,tickers:1,orderbook:1,orderbooks:1,trades:1,chart:1,charts:1,minicharts:1,"oracle/prices":1,"quick-trade":1,"udf/config":1,"udf/history":1,"udf/symbols":1}},private:{get:{user:1,"user/balance":1,"user/deposits":1,"user/withdrawals":1,"user/withdrawal/fee":1,"user/trades":1,orders:1,order:1},post:{"user/withdrawal":1,order:1},delete:{"order/all":1,order:1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:.001,maker:.001}},exceptions:{broad:{"Invalid token":r.AuthenticationError,"Order not found":r.OrderNotFound,"Insufficient balance":r.InsufficientFunds,"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.":r.OrderImmediatelyFillable},exact:{400:r.BadRequest,403:r.AuthenticationError,404:r.BadRequest,405:r.BadRequest,410:r.BadRequest,429:r.BadRequest,500:r.NetworkError,503:r.NetworkError}},options:{"api-expires":this.parseToInt(this.timeout/1e3),networks:{BTC:"btc",ETH:"eth",ERC20:"eth",TRX:"trx",TRC20:"trx",XRP:"xrp",XLM:"xlm",BNB:"bnb",MATIC:"matic"}}})}async fetchMarkets(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"pairs",{}),i=Object.keys(s),r=[];for(let e=0;e<i.length;e++){const t=s[i[e]],a=this.safeString(t,"pair_base"),o=this.safeString(t,"pair_2"),n=this.commonCurrencyCode(a.toUpperCase()),d=this.commonCurrencyCode(o.toUpperCase());r.push({id:this.safeString(t,"name"),symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:this.safeValue(t,"active"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"increment_size"),price:this.safeNumber(t,"increment_price")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_size"),max:this.safeNumber(t,"max_size")},price:{min:this.safeNumber(t,"min_price"),max:this.safeNumber(t,"max_price")},cost:{min:void 0,max:void 0}},created:this.parse8601(this.safeString(t,"created_at")),info:t})}return r}async fetchCurrencies(e={}){const t=await this.publicGetConstants(e),s=this.safeValue(t,"coins",{}),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=s[i[e]],a=this.safeString(t,"symbol"),o=this.safeInteger(t,"id"),n=this.safeCurrencyCode(a),d=this.safeString(t,"fullname"),h=this.safeValue(t,"allow_deposit"),c=this.safeValue(t,"allow_withdrawal"),l=this.safeValue(t,"active")&&h&&c,u=this.safeNumber(t,"withdrawal_fee"),p=this.safeValue(t,"withdrawal_limits",[]);r[n]={id:a,numericId:o,code:n,info:t,name:d,active:l,deposit:h,withdraw:c,fee:u,precision:this.safeNumber(t,"increment_unit"),limits:{amount:{min:this.safeNumber(t,"min"),max:this.safeNumber(t,"max")},withdraw:{min:void 0,max:this.safeValue(p,0)}},networks:{}}}return r}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets();const i=await this.publicGetOrderbooks(s),r={},a=Object.keys(i);for(let e=0;e<a.length;e++){const t=a[e],s=i[t],o=this.safeSymbol(t,void 0,"-"),n=this.parse8601(this.safeString(s,"timestamp"));r[o]=this.parseOrderBook(i[t],o,n)}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id},a=await this.publicGetOrderbook(this.extend(r,s)),o=this.safeValue(a,i.id),n=this.parse8601(this.safeString(o,"timestamp"));return this.parseOrderBook(o,i.symbol,n)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTickers(e,t=void 0,s={}){const i={},r=Object.keys(e);for(let t=0;t<r.length;t++){const a=r[t],o=e[a],n=this.safeString(o,"symbol",a),d=this.safeMarket(n,void 0,"-");i[d.symbol]=this.extend(this.parseTicker(o,d),s)}return this.filterByArrayTickers(i,"symbol",t)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t,"-")).symbol,r=this.parse8601(this.safeString2(e,"time","timestamp")),a=this.safeString(e,"close");return this.safeTicker({symbol:i,info:e,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:a,last:this.safeString(e,"last",a),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,r.id,[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t,"-")).symbol,r=this.safeString(e,"timestamp"),a=this.parse8601(r),o=this.safeString(e,"side"),n=this.safeString(e,"order_id"),d=this.safeString(e,"price"),h=this.safeString(e,"size"),c=this.safeString(e,"fee");let l;return void 0!==c&&(l={cost:c,currency:t.quote}),this.safeTrade({info:e,id:void 0,timestamp:a,datetime:r,symbol:i,order:n,type:void 0,side:o,takerOrMaker:void 0,price:d,amount:h,cost:void 0,fee:l},t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetTiers(e),s=this.safeValue(t,"1",{}),i=this.safeValue(s,"fees",{}),r=this.safeValue(i,"maker",{}),o=this.safeValue(i,"taker",{}),n={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],s=this.market(t),d=this.safeString(r,s.id),h=this.safeString(o,s.id);n[t]={info:i,symbol:t,maker:this.parseNumber(a.Y.stringDiv(d,"100")),taker:this.parseNumber(a.Y.stringDiv(h,"100")),percentage:!0,tierBased:!0}}return n}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,resolution:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t);if(void 0===s){void 0===i&&(i=1e3);const e=this.seconds(),t=e-n*i;o.to=e,o.from=t}else if(void 0===i)o.from=this.parseToInt(s/1e3),o.to=this.seconds();else{const e=this.parseToInt(s/1e3);o.from=e,o.to=this.sum(e,n*i)}const d=await this.publicGetChart(this.extend(o,r));return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseBalance(e){const t=this.parse8601(this.safeString(e,"updated_at")),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=Object.keys(this.currencies_by_id);for(let t=0;t<i.length;t++){const r=i[t],a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(e,r+"_available"),o.total=this.safeString(e,r+"_balance"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUserBalance(e);return this.parseBalance(t)}async fetchOpenOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({open:!0},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({open:!1},i))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},a=await this.privateGetOrder(this.extend(i,s));if(void 0===a)throw new r.OrderNotFound(this.id+" fetchOrder() could not find order id "+e);return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==t&&(a.start_date=this.iso8601(t)),void 0!==s&&(a.limit=s);const o=await this.privateGetOrders(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseOrders(n,r,t,s)}parseOrderStatus(e){return this.safeString({new:"open",pfilled:"open",filled:"closed",canceled:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"-"),r=this.safeString(e,"id"),a=this.parse8601(this.safeString(e,"created_at")),o=this.safeString(e,"type"),n=this.safeString(e,"side"),d=this.safeString(e,"price"),h=this.safeString(e,"stop"),c=this.safeString(e,"size"),l=this.safeString(e,"filled"),u=this.parseOrderStatus(this.safeString(e,"status")),p=this.safeValue(e,"meta",{}),f=this.safeBool(p,"post_only",!1);return this.safeOrder({id:r,clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,status:u,symbol:i,type:o,timeInForce:void 0,postOnly:f,side:n,price:d,stopPrice:h,triggerPrice:h,amount:c,filled:l,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=parseFloat(this.amountToPrecision(e,i)),d={symbol:o.id,side:s,size:this.normalizeNumberIfNeeded(n),type:t},h=this.safeNumberN(a,["triggerPrice","stopPrice","stop"]),c=this.safeValue(a,"meta",{}),l=this.safeBool(c,"post_only",!1),u="market"===t,p=this.isPostOnly(u,l,a);if(!u){const t=parseFloat(this.priceToPrecision(e,r));d.price=this.normalizeNumberIfNeeded(t)}void 0!==h&&(d.stop=this.normalizeNumberIfNeeded(parseFloat(this.priceToPrecision(e,h)))),p&&(d.meta={post_only:!0}),a=this.omit(a,["postOnly","timeInForce","stopPrice","triggerPrice","stop"]);const f=await this.privatePostOrder(this.extend(d,a));return this.parseOrder(f,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={};let i;i=this.market(e),s.symbol=i.id;const a=await this.privateDeleteOrderAll(this.extend(s,t));return this.parseOrders(a,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==s&&(r.limit=s),void 0!==t&&(r.start_date=this.iso8601(t));const o=await this.privateGetUserTrades(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,a,t,s)}parseDepositAddress(e,t=void 0){let s,i=this.safeString(e,"address");if(void 0!==i){const e=i.split(":");i=this.safeString(e,0),s=this.safeString(e,1)}this.checkAddress(i);const r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a=this.safeString(e,"network");return{currency:t.code,address:i,tag:s,network:a,info:e}}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(t,"network");t=this.omit(t,"network");const i=await this.privateGetUser(t),r=this.safeValue(i,"wallet",[]),a=void 0===s?r:this.filterBy(r,"network",s);return this.parseDepositAddresses(a,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.limit=s),void 0!==t&&(r.start_date=this.iso8601(t));const o=await this.privateGetUserDeposits(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={transaction_id:e};let r;void 0!==t&&(r=this.currency(t),i.currency=r.id);const a=await this.privateGetUserWithdrawals(this.extend(i,s)),o=this.safeValue(a,"data",[]),n=this.safeDict(o,0,{});return this.parseTransaction(n,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.limit=s),void 0!==t&&(r.start_date=this.iso8601(t));const o=await this.privateGetUserWithdrawals(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"transaction_id"),r=this.parse8601(this.safeString(e,"created_at")),a=this.parse8601(this.safeString(e,"updated_at")),o=this.safeString(e,"type"),n=this.safeNumber(e,"amount");let d,h=this.safeString(e,"address");let c,l;if(void 0!==h){const e=h.split(":");h=this.safeString(e,0),c=this.safeString(e,1),d=h,l=c}const u=this.safeString(e,"currency");t=this.safeCurrency(u,t);let p=this.safeValue(e,"status");const f=this.safeValue(e,"dismissed"),m=this.safeValue(e,"rejected");p=p?"ok":f?"canceled":m?"failed":"pending";const g=this.safeString(e,"fee_coin"),v=this.safeCurrencyCode(g,t),y=this.safeNumber(e,"fee");let w;return void 0!==y&&(w={currency:v,cost:y}),{info:e,id:s,txid:i,timestamp:r,datetime:this.iso8601(r),network:void 0,addressFrom:undefined,address:h,addressTo:d,tagFrom:undefined,tag:c,tagTo:l,type:o,amount:n,currency:t.code,status:p,updated:a,comment:this.safeString(e,"message"),internal:void 0,fee:w}}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);void 0!==i&&(s+=":"+i);const n=this.safeString(a,"network");if(void 0===n)throw new r.ArgumentsRequired(this.id+" withdraw() requires a network parameter");a=this.omit(a,"network");const d={currency:o.id,amount:t,address:s,network:this.networkCodeToId(n,e)},h=await this.privatePostUserWithdrawal(this.extend(d,a));return this.parseTransaction(h,o)}parseDepositWithdrawFee(e,t=void 0){const s={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};this.safeValue(e,"allow_withdrawal")&&(s.withdraw={fee:this.safeNumber(e,"withdrawal_fee"),percentage:!1});const i=this.safeValue(e,"withdrawal_fees");if(void 0!==i){const e=Object.keys(i),t=e.length;for(let r=0;r<t;r++){const t=e[r],a=i[t],o=this.safeString(a,"symbol"),n=this.safeCurrencyCode(o),d=this.networkIdToCode(t,n).toUpperCase(),h=this.safeNumber(a,"value");s.networks[d]={deposit:void 0,withdraw:h}}}return s}async fetchDepositWithdrawFees(e=void 0,t={}){const s=await this.publicGetConstants(t),i=this.safeList(s,"coins");return this.parseDepositWithdrawFees(i,e,"symbol")}normalizeNumberIfNeeded(e){return this.isRoundNumber(e)&&(e=parseInt(e)),e}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e));e="/"+this.version+"/"+this.implodeParams(e,i),"GET"!==s&&"DELETE"!==s||Object.keys(o).length&&(e+="?"+this.urlencode(o));const d=this.urls.api.rest+e;if("private"===t){this.checkRequiredCredentials();const t=this.safeInteger2(this.options,"api-expires","expires",this.parseToInt(this.timeout/1e3)),i=this.sum(this.seconds(),t).toString();let d=s+e+i;r={"api-key":this.apiKey,"api-expires":i},"POST"===s&&(r["Content-type"]="application/json",Object.keys(o).length&&(d+=a=this.json(o)));const h=this.hmac(this.encode(d),this.encode(this.secret),n.s);r["api-signature"]=h}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(void 0!==o&&e>=400&&e<=503){const t=this.id+" "+a,s=this.safeString(o,"message");this.throwBroadlyMatchedException(this.exceptions.broad,s,t);const i=e.toString();this.throwExactlyMatchedException(this.exceptions.exact,i,t)}}}},9946:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8617),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"htx",name:"HTX",countries:["CN"],rateLimit:100,userAgent:this.userAgents.chrome100,certified:!0,version:"v1",hostname:"api.huobi.pro",pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:void 0,addMargin:void 0,borrowCrossMargin:!0,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!0,createDepositAddress:void 0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchCanceledOrders:void 0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!0,fetchL3OrderBook:void 0,fetchLastPrices:!0,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!1,fetchLeverageTiers:!0,fetchLiquidations:!0,fetchMarginAdjustmentHistory:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositions:!0,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!0,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!0,fetchTransactionFee:void 0,fetchTransactionFees:void 0,fetchTransactions:void 0,fetchTransfers:void 0,fetchWithdrawAddresses:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:void 0,reduceMargin:void 0,repayCrossMargin:!0,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!0,signIn:void 0,transfer:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",hostnames:{contract:"api.hbdm.com",spot:"api.huobi.pro",status:{spot:"status.huobigroup.com",future:{inverse:"status-dm.huobigroup.com",linear:"status-linear-swap.huobigroup.com"},swap:{inverse:"status-swap.huobigroup.com",linear:"status-linear-swap.huobigroup.com"}}},api:{status:"https://{hostname}",contract:"https://{hostname}",spot:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.com",referral:{url:"https://www.huobi.com/en-us/v/register/double-invite/?inviter_id=11343840&invite_code=6rmm2223",discount:.15},doc:["https://huobiapi.github.io/docs/spot/v1/en/","https://huobiapi.github.io/docs/dm/v1/en/","https://huobiapi.github.io/docs/coin_margined_swap/v1/en/","https://huobiapi.github.io/docs/usdt_swap/v1/en/","https://www.huobi.com/en-us/opend/newApiPages/"],fees:"https://www.huobi.com/about/fee/"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}},status:{public:{spot:{get:{"api/v2/summary.json":1}},future:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}},swap:{inverse:{get:{"api/v2/summary.json":1}},linear:{get:{"api/v2/summary.json":1}}}}},spot:{public:{get:{"v2/market-status":1,"v1/common/symbols":1,"v1/common/currencys":1,"v2/settings/common/currencies":1,"v2/reference/currencies":1,"v1/common/timestamp":1,"v1/common/exchange":1,"v1/settings/common/chains":1,"v1/settings/common/currencys":1,"v1/settings/common/symbols":1,"v2/settings/common/symbols":1,"v1/settings/common/market-symbols":1,"market/history/candles":1,"market/history/kline":1,"market/detail/merged":1,"market/tickers":1,"market/detail":1,"market/depth":1,"market/trade":1,"market/history/trade":1,"market/etp":1,"v2/etp/reference":1,"v2/etp/rebalance":1}},private:{get:{"v1/account/accounts":.2,"v1/account/accounts/{account-id}/balance":.2,"v2/account/valuation":1,"v2/account/asset-valuation":.2,"v1/account/history":4,"v2/account/ledger":1,"v2/point/account":5,"v2/account/deposit/address":1,"v2/account/withdraw/quota":1,"v2/account/withdraw/address":1,"v2/reference/currencies":1,"v1/query/deposit-withdraw":1,"v1/query/withdraw/client-order-id":1,"v2/user/api-key":1,"v2/user/uid":1,"v2/sub-user/user-list":1,"v2/sub-user/user-state":1,"v2/sub-user/account-list":1,"v2/sub-user/deposit-address":1,"v2/sub-user/query-deposit":1,"v1/subuser/aggregate-balance":10,"v1/account/accounts/{sub-uid}":1,"v1/order/openOrders":.4,"v1/order/orders/{order-id}":.4,"v1/order/orders/getClientOrder":.4,"v1/order/orders/{order-id}/matchresult":.4,"v1/order/orders/{order-id}/matchresults":.4,"v1/order/orders":.4,"v1/order/history":1,"v1/order/matchresults":1,"v2/reference/transact-fee-rate":1,"v2/algo-orders/opening":1,"v2/algo-orders/history":1,"v2/algo-orders/specific":1,"v1/margin/loan-info":1,"v1/margin/loan-orders":.2,"v1/margin/accounts/balance":.2,"v1/cross-margin/loan-info":1,"v1/cross-margin/loan-orders":1,"v1/cross-margin/accounts/balance":1,"v2/account/repayment":5,"v1/stable-coin/quote":1,"v1/stable_coin/exchange_rate":1,"v2/etp/transactions":5,"v2/etp/transaction":5,"v2/etp/limit":1},post:{"v1/account/transfer":1,"v1/futures/transfer":1,"v2/point/transfer":5,"v2/account/transfer":1,"v1/dw/withdraw/api/create":1,"v1/dw/withdraw-virtual/{withdraw-id}/cancel":1,"v2/sub-user/deduct-mode":1,"v2/sub-user/creation":1,"v2/sub-user/management":1,"v2/sub-user/tradable-market":1,"v2/sub-user/transferability":1,"v2/sub-user/api-key-generation":1,"v2/sub-user/api-key-modification":1,"v2/sub-user/api-key-deletion":1,"v1/subuser/transfer":10,"v1/trust/user/active/credit":10,"v1/order/orders/place":.2,"v1/order/batch-orders":.4,"v1/order/auto/place":.2,"v1/order/orders/{order-id}/submitcancel":.2,"v1/order/orders/submitCancelClientOrder":.2,"v1/order/orders/batchCancelOpenOrders":.4,"v1/order/orders/batchcancel":.4,"v2/algo-orders/cancel-all-after":1,"v2/algo-orders":1,"v2/algo-orders/cancellation":1,"v2/account/repayment":5,"v1/dw/transfer-in/margin":10,"v1/dw/transfer-out/margin":10,"v1/margin/orders":10,"v1/margin/orders/{order-id}/repay":10,"v1/cross-margin/transfer-in":1,"v1/cross-margin/transfer-out":1,"v1/cross-margin/orders":1,"v1/cross-margin/orders/{order-id}/repay":1,"v1/stable-coin/exchange":1,"v2/etp/creation":5,"v2/etp/redemption":5,"v2/etp/{transactId}/cancel":10,"v2/etp/batch-cancel":50}}},contract:{public:{get:{"api/v1/timestamp":1,"heartbeat/":1,"api/v1/contract_contract_info":1,"api/v1/contract_index":1,"api/v1/contract_query_elements":1,"api/v1/contract_price_limit":1,"api/v1/contract_open_interest":1,"api/v1/contract_delivery_price":1,"market/depth":1,"market/bbo":1,"market/history/kline":1,"index/market/history/mark_price_kline":1,"market/detail/merged":1,"market/detail/batch_merged":1,"v2/market/detail/batch_merged":1,"market/trade":1,"market/history/trade":1,"api/v1/contract_risk_info":1,"api/v1/contract_insurance_fund":1,"api/v1/contract_adjustfactor":1,"api/v1/contract_his_open_interest":1,"api/v1/contract_ladder_margin":1,"api/v1/contract_api_state":1,"api/v1/contract_elite_account_ratio":1,"api/v1/contract_elite_position_ratio":1,"api/v1/contract_liquidation_orders":1,"api/v1/contract_settlement_records":1,"index/market/history/index":1,"index/market/history/basis":1,"api/v1/contract_estimated_settlement_price":1,"api/v3/contract_liquidation_orders":1,"swap-api/v1/swap_contract_info":1,"swap-api/v1/swap_index":1,"swap-api/v1/swap_query_elements":1,"swap-api/v1/swap_price_limit":1,"swap-api/v1/swap_open_interest":1,"swap-ex/market/depth":1,"swap-ex/market/bbo":1,"swap-ex/market/history/kline":1,"index/market/history/swap_mark_price_kline":1,"swap-ex/market/detail/merged":1,"v2/swap-ex/market/detail/batch_merged":1,"index/market/history/swap_premium_index_kline":1,"swap-ex/market/detail/batch_merged":1,"swap-ex/market/trade":1,"swap-ex/market/history/trade":1,"swap-api/v1/swap_risk_info":1,"swap-api/v1/swap_insurance_fund":1,"swap-api/v1/swap_adjustfactor":1,"swap-api/v1/swap_his_open_interest":1,"swap-api/v1/swap_ladder_margin":1,"swap-api/v1/swap_api_state":1,"swap-api/v1/swap_elite_account_ratio":1,"swap-api/v1/swap_elite_position_ratio":1,"swap-api/v1/swap_estimated_settlement_price":1,"swap-api/v1/swap_liquidation_orders":1,"swap-api/v1/swap_settlement_records":1,"swap-api/v1/swap_funding_rate":1,"swap-api/v1/swap_batch_funding_rate":1,"swap-api/v1/swap_historical_funding_rate":1,"swap-api/v3/swap_liquidation_orders":1,"index/market/history/swap_estimated_rate_kline":1,"index/market/history/swap_basis":1,"linear-swap-api/v1/swap_contract_info":1,"linear-swap-api/v1/swap_index":1,"linear-swap-api/v1/swap_query_elements":1,"linear-swap-api/v1/swap_price_limit":1,"linear-swap-api/v1/swap_open_interest":1,"linear-swap-ex/market/depth":1,"linear-swap-ex/market/bbo":1,"linear-swap-ex/market/history/kline":1,"index/market/history/linear_swap_mark_price_kline":1,"linear-swap-ex/market/detail/merged":1,"linear-swap-ex/market/detail/batch_merged":1,"v2/linear-swap-ex/market/detail/batch_merged":1,"linear-swap-ex/market/trade":1,"linear-swap-ex/market/history/trade":1,"linear-swap-api/v1/swap_risk_info":1,"swap-api/v1/linear-swap-api/v1/swap_insurance_fund":1,"linear-swap-api/v1/swap_adjustfactor":1,"linear-swap-api/v1/swap_cross_adjustfactor":1,"linear-swap-api/v1/swap_his_open_interest":1,"linear-swap-api/v1/swap_ladder_margin":1,"linear-swap-api/v1/swap_cross_ladder_margin":1,"linear-swap-api/v1/swap_api_state":1,"linear-swap-api/v1/swap_cross_transfer_state":1,"linear-swap-api/v1/swap_cross_trade_state":1,"linear-swap-api/v1/swap_elite_account_ratio":1,"linear-swap-api/v1/swap_elite_position_ratio":1,"linear-swap-api/v1/swap_liquidation_orders":1,"linear-swap-api/v1/swap_settlement_records":1,"linear-swap-api/v1/swap_funding_rate":1,"linear-swap-api/v1/swap_batch_funding_rate":1,"linear-swap-api/v1/swap_historical_funding_rate":1,"linear-swap-api/v3/swap_liquidation_orders":1,"index/market/history/linear_swap_premium_index_kline":1,"index/market/history/linear_swap_estimated_rate_kline":1,"index/market/history/linear_swap_basis":1,"linear-swap-api/v1/swap_estimated_settlement_price":1}},private:{get:{"api/v1/contract_sub_auth_list":1,"api/v1/contract_api_trading_status":1,"swap-api/v1/swap_sub_auth_list":1,"swap-api/v1/swap_api_trading_status":1,"linear-swap-api/v1/swap_sub_auth_list":1,"linear-swap-api/v1/swap_api_trading_status":1,"linear-swap-api/v1/swap_cross_position_side":1,"linear-swap-api/v1/swap_position_side":1,"linear-swap-api/v3/unified_account_info":1,"linear-swap-api/v3/fix_position_margin_change_record":1,"linear-swap-api/v3/swap_unified_account_type":1,"linear-swap-api/v3/linear_swap_overview_account_info":1},post:{"api/v1/contract_balance_valuation":1,"api/v1/contract_account_info":1,"api/v1/contract_position_info":1,"api/v1/contract_sub_auth":1,"api/v1/contract_sub_account_list":1,"api/v1/contract_sub_account_info_list":1,"api/v1/contract_sub_account_info":1,"api/v1/contract_sub_position_info":1,"api/v1/contract_financial_record":1,"api/v1/contract_financial_record_exact":1,"api/v1/contract_user_settlement_records":1,"api/v1/contract_order_limit":1,"api/v1/contract_fee":1,"api/v1/contract_transfer_limit":1,"api/v1/contract_position_limit":1,"api/v1/contract_account_position_info":1,"api/v1/contract_master_sub_transfer":1,"api/v1/contract_master_sub_transfer_record":1,"api/v1/contract_available_level_rate":1,"api/v3/contract_financial_record":1,"api/v3/contract_financial_record_exact":1,"api/v1/contract-cancel-after":1,"api/v1/contract_order":1,"api/v1/contract_batchorder":1,"api/v1/contract_cancel":1,"api/v1/contract_cancelall":1,"api/v1/contract_switch_lever_rate":1,"api/v1/lightning_close_position":1,"api/v1/contract_order_info":1,"api/v1/contract_order_detail":1,"api/v1/contract_openorders":1,"api/v1/contract_hisorders":1,"api/v1/contract_hisorders_exact":1,"api/v1/contract_matchresults":1,"api/v1/contract_matchresults_exact":1,"api/v3/contract_hisorders":1,"api/v3/contract_hisorders_exact":1,"api/v3/contract_matchresults":1,"api/v3/contract_matchresults_exact":1,"api/v1/contract_trigger_order":1,"api/v1/contract_trigger_cancel":1,"api/v1/contract_trigger_cancelall":1,"api/v1/contract_trigger_openorders":1,"api/v1/contract_trigger_hisorders":1,"api/v1/contract_tpsl_order":1,"api/v1/contract_tpsl_cancel":1,"api/v1/contract_tpsl_cancelall":1,"api/v1/contract_tpsl_openorders":1,"api/v1/contract_tpsl_hisorders":1,"api/v1/contract_relation_tpsl_order":1,"api/v1/contract_track_order":1,"api/v1/contract_track_cancel":1,"api/v1/contract_track_cancelall":1,"api/v1/contract_track_openorders":1,"api/v1/contract_track_hisorders":1,"swap-api/v1/swap_balance_valuation":1,"swap-api/v1/swap_account_info":1,"swap-api/v1/swap_position_info":1,"swap-api/v1/swap_account_position_info":1,"swap-api/v1/swap_sub_auth":1,"swap-api/v1/swap_sub_account_list":1,"swap-api/v1/swap_sub_account_info_list":1,"swap-api/v1/swap_sub_account_info":1,"swap-api/v1/swap_sub_position_info":1,"swap-api/v1/swap_financial_record":1,"swap-api/v1/swap_financial_record_exact":1,"swap-api/v1/swap_user_settlement_records":1,"swap-api/v1/swap_available_level_rate":1,"swap-api/v1/swap_order_limit":1,"swap-api/v1/swap_fee":1,"swap-api/v1/swap_transfer_limit":1,"swap-api/v1/swap_position_limit":1,"swap-api/v1/swap_master_sub_transfer":1,"swap-api/v1/swap_master_sub_transfer_record":1,"swap-api/v3/swap_financial_record":1,"swap-api/v3/swap_financial_record_exact":1,"swap-api/v1/swap-cancel-after":1,"swap-api/v1/swap_order":1,"swap-api/v1/swap_batchorder":1,"swap-api/v1/swap_cancel":1,"swap-api/v1/swap_cancelall":1,"swap-api/v1/swap_lightning_close_position":1,"swap-api/v1/swap_switch_lever_rate":1,"swap-api/v1/swap_order_info":1,"swap-api/v1/swap_order_detail":1,"swap-api/v1/swap_openorders":1,"swap-api/v1/swap_hisorders":1,"swap-api/v1/swap_hisorders_exact":1,"swap-api/v1/swap_matchresults":1,"swap-api/v1/swap_matchresults_exact":1,"swap-api/v3/swap_matchresults":1,"swap-api/v3/swap_matchresults_exact":1,"swap-api/v3/swap_hisorders":1,"swap-api/v3/swap_hisorders_exact":1,"swap-api/v1/swap_trigger_order":1,"swap-api/v1/swap_trigger_cancel":1,"swap-api/v1/swap_trigger_cancelall":1,"swap-api/v1/swap_trigger_openorders":1,"swap-api/v1/swap_trigger_hisorders":1,"swap-api/v1/swap_tpsl_order":1,"swap-api/v1/swap_tpsl_cancel":1,"swap-api/v1/swap_tpsl_cancelall":1,"swap-api/v1/swap_tpsl_openorders":1,"swap-api/v1/swap_tpsl_hisorders":1,"swap-api/v1/swap_relation_tpsl_order":1,"swap-api/v1/swap_track_order":1,"swap-api/v1/swap_track_cancel":1,"swap-api/v1/swap_track_cancelall":1,"swap-api/v1/swap_track_openorders":1,"swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_lever_position_limit":1,"linear-swap-api/v1/swap_cross_lever_position_limit":1,"linear-swap-api/v1/swap_balance_valuation":1,"linear-swap-api/v1/swap_account_info":1,"linear-swap-api/v1/swap_cross_account_info":1,"linear-swap-api/v1/swap_position_info":1,"linear-swap-api/v1/swap_cross_position_info":1,"linear-swap-api/v1/swap_account_position_info":1,"linear-swap-api/v1/swap_cross_account_position_info":1,"linear-swap-api/v1/swap_sub_auth":1,"linear-swap-api/v1/swap_sub_account_list":1,"linear-swap-api/v1/swap_cross_sub_account_list":1,"linear-swap-api/v1/swap_sub_account_info_list":1,"linear-swap-api/v1/swap_cross_sub_account_info_list":1,"linear-swap-api/v1/swap_sub_account_info":1,"linear-swap-api/v1/swap_cross_sub_account_info":1,"linear-swap-api/v1/swap_sub_position_info":1,"linear-swap-api/v1/swap_cross_sub_position_info":1,"linear-swap-api/v1/swap_financial_record":1,"linear-swap-api/v1/swap_financial_record_exact":1,"linear-swap-api/v1/swap_user_settlement_records":1,"linear-swap-api/v1/swap_cross_user_settlement_records":1,"linear-swap-api/v1/swap_available_level_rate":1,"linear-swap-api/v1/swap_cross_available_level_rate":1,"linear-swap-api/v1/swap_order_limit":1,"linear-swap-api/v1/swap_fee":1,"linear-swap-api/v1/swap_transfer_limit":1,"linear-swap-api/v1/swap_cross_transfer_limit":1,"linear-swap-api/v1/swap_position_limit":1,"linear-swap-api/v1/swap_cross_position_limit":1,"linear-swap-api/v1/swap_master_sub_transfer":1,"linear-swap-api/v1/swap_master_sub_transfer_record":1,"linear-swap-api/v1/swap_transfer_inner":1,"linear-swap-api/v3/swap_financial_record":1,"linear-swap-api/v3/swap_financial_record_exact":1,"linear-swap-api/v1/swap_order":1,"linear-swap-api/v1/swap_cross_order":1,"linear-swap-api/v1/swap_batchorder":1,"linear-swap-api/v1/swap_cross_batchorder":1,"linear-swap-api/v1/swap_cancel":1,"linear-swap-api/v1/swap_cross_cancel":1,"linear-swap-api/v1/swap_cancelall":1,"linear-swap-api/v1/swap_cross_cancelall":1,"linear-swap-api/v1/swap_switch_lever_rate":1,"linear-swap-api/v1/swap_cross_switch_lever_rate":1,"linear-swap-api/v1/swap_lightning_close_position":1,"linear-swap-api/v1/swap_cross_lightning_close_position":1,"linear-swap-api/v1/swap_order_info":1,"linear-swap-api/v1/swap_cross_order_info":1,"linear-swap-api/v1/swap_order_detail":1,"linear-swap-api/v1/swap_cross_order_detail":1,"linear-swap-api/v1/swap_openorders":1,"linear-swap-api/v1/swap_cross_openorders":1,"linear-swap-api/v1/swap_hisorders":1,"linear-swap-api/v1/swap_cross_hisorders":1,"linear-swap-api/v1/swap_hisorders_exact":1,"linear-swap-api/v1/swap_cross_hisorders_exact":1,"linear-swap-api/v1/swap_matchresults":1,"linear-swap-api/v1/swap_cross_matchresults":1,"linear-swap-api/v1/swap_matchresults_exact":1,"linear-swap-api/v1/swap_cross_matchresults_exact":1,"linear-swap-api/v1/linear-cancel-after":1,"linear-swap-api/v1/swap_switch_position_mode":1,"linear-swap-api/v1/swap_cross_switch_position_mode":1,"linear-swap-api/v3/swap_matchresults":1,"linear-swap-api/v3/swap_cross_matchresults":1,"linear-swap-api/v3/swap_matchresults_exact":1,"linear-swap-api/v3/swap_cross_matchresults_exact":1,"linear-swap-api/v3/swap_hisorders":1,"linear-swap-api/v3/swap_cross_hisorders":1,"linear-swap-api/v3/swap_hisorders_exact":1,"linear-swap-api/v3/swap_cross_hisorders_exact":1,"linear-swap-api/v3/fix_position_margin_change":1,"linear-swap-api/v3/swap_switch_account_type":1,"linear-swap-api/v3/linear_swap_fee_switch":1,"linear-swap-api/v1/swap_trigger_order":1,"linear-swap-api/v1/swap_cross_trigger_order":1,"linear-swap-api/v1/swap_trigger_cancel":1,"linear-swap-api/v1/swap_cross_trigger_cancel":1,"linear-swap-api/v1/swap_trigger_cancelall":1,"linear-swap-api/v1/swap_cross_trigger_cancelall":1,"linear-swap-api/v1/swap_trigger_openorders":1,"linear-swap-api/v1/swap_cross_trigger_openorders":1,"linear-swap-api/v1/swap_trigger_hisorders":1,"linear-swap-api/v1/swap_cross_trigger_hisorders":1,"linear-swap-api/v1/swap_tpsl_order":1,"linear-swap-api/v1/swap_cross_tpsl_order":1,"linear-swap-api/v1/swap_tpsl_cancel":1,"linear-swap-api/v1/swap_cross_tpsl_cancel":1,"linear-swap-api/v1/swap_tpsl_cancelall":1,"linear-swap-api/v1/swap_cross_tpsl_cancelall":1,"linear-swap-api/v1/swap_tpsl_openorders":1,"linear-swap-api/v1/swap_cross_tpsl_openorders":1,"linear-swap-api/v1/swap_tpsl_hisorders":1,"linear-swap-api/v1/swap_cross_tpsl_hisorders":1,"linear-swap-api/v1/swap_relation_tpsl_order":1,"linear-swap-api/v1/swap_cross_relation_tpsl_order":1,"linear-swap-api/v1/swap_track_order":1,"linear-swap-api/v1/swap_cross_track_order":1,"linear-swap-api/v1/swap_track_cancel":1,"linear-swap-api/v1/swap_cross_track_cancel":1,"linear-swap-api/v1/swap_track_cancelall":1,"linear-swap-api/v1/swap_cross_track_cancelall":1,"linear-swap-api/v1/swap_track_openorders":1,"linear-swap-api/v1/swap_cross_track_openorders":1,"linear-swap-api/v1/swap_track_hisorders":1,"linear-swap-api/v1/swap_cross_track_hisorders":1}}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":r.OnMaintenance,maintain:r.OnMaintenance,"API key has no permission":r.PermissionDenied},exact:{403:r.AuthenticationError,1010:r.AccountNotEnabled,1003:r.AuthenticationError,1013:r.BadSymbol,1017:r.OrderNotFound,1034:r.InvalidOrder,1036:r.InvalidOrder,1039:r.InvalidOrder,1041:r.InvalidOrder,1047:r.InsufficientFunds,1048:r.InsufficientFunds,1051:r.InvalidOrder,1066:r.BadSymbol,1067:r.InvalidOrder,1094:r.InvalidOrder,1220:r.AccountNotEnabled,1303:r.BadRequest,1461:r.InvalidOrder,4007:r.BadRequest,"bad-request":r.BadRequest,"validation-format-error":r.BadRequest,"validation-constraints-required":r.BadRequest,"base-date-limit-error":r.BadRequest,"api-not-support-temp-addr":r.PermissionDenied,timeout:r.RequestTimeout,"gateway-internal-error":r.ExchangeNotAvailable,"account-frozen-balance-insufficient-error":r.InsufficientFunds,"invalid-amount":r.InvalidOrder,"order-limitorder-amount-min-error":r.InvalidOrder,"order-limitorder-amount-max-error":r.InvalidOrder,"order-marketorder-amount-min-error":r.InvalidOrder,"order-limitorder-price-min-error":r.InvalidOrder,"order-limitorder-price-max-error":r.InvalidOrder,"order-stop-order-hit-trigger":r.InvalidOrder,"order-value-min-error":r.InvalidOrder,"order-invalid-price":r.InvalidOrder,"order-holding-limit-failed":r.InvalidOrder,"order-orderprice-precision-error":r.InvalidOrder,"order-etp-nav-price-max-error":r.InvalidOrder,"order-orderstate-error":r.OrderNotFound,"order-queryorder-invalid":r.OrderNotFound,"order-update-error":r.ExchangeNotAvailable,"api-signature-check-failed":r.AuthenticationError,"api-signature-not-valid":r.AuthenticationError,"base-record-invalid":r.OrderNotFound,"base-symbol-trade-disabled":r.BadSymbol,"base-symbol-error":r.BadSymbol,"system-maintenance":r.OnMaintenance,"base-request-exceed-frequency-limit":r.RateLimitExceeded,"invalid symbol":r.BadSymbol,"symbol trade not open now":r.BadSymbol,"require-symbol":r.BadSymbol,"invalid-address":r.BadRequest,"base-currency-chain-error":r.BadRequest,"dw-insufficient-balance":r.InsufficientFunds,"base-withdraw-fee-error":r.BadRequest,"dw-withdraw-min-limit":r.BadRequest,"request limit":r.RateLimitExceeded}},precisionMode:o.kb,options:{fetchMarkets:{types:{spot:!0,linear:!0,inverse:!0}},fetchOHLCV:{useHistoricalEndpointForSpot:!0},withdraw:{includeFee:!1},defaultType:"spot",defaultSubType:"linear",defaultNetwork:"ERC20",defaultNetworks:{ETH:"ERC20",BTC:"BTC",USDT:"TRC20"},networks:{TRC20:"TRX",BTC:"BTC",ERC20:"ETH",SOL:"SOLANA",HRC20:"HECO",BEP20:"BSC",XMR:"XMR",LTC:"LTC",XRP:"XRP",XLM:"XLM",CRONOS:"CRO",CRO:"CRO",GLMR:"GLMR",POLYGON:"MATIC",MATIC:"MATIC",BTT:"BTT",CUBE:"CUBE",IOST:"IOST",NEO:"NEO",KLAY:"KLAY",EOS:"EOS",THETA:"THETA",NAS:"NAS",NULS:"NULS",QTUM:"QTUM",FTM:"FTM",CELO:"CELO",DOGE:"DOGE",DOGECHAIN:"DOGECHAIN",NEAR:"NEAR",STEP:"STEP",BITCI:"BITCI",CARDANO:"ADA",ADA:"ADA",ETC:"ETC",LUK:"LUK",MINEPLEX:"MINEPLEX",DASH:"DASH",ZEC:"ZEC",IOTA:"IOTA",NEON3:"NEON3",XEM:"XEM",HC:"HC",LSK:"LSK",DCR:"DCR",BTG:"BTG",STEEM:"STEEM",BTS:"BTS",ICX:"ICX",WAVES:"WAVES",CMT:"CMT",BTM:"BTM",VET:"VET",XZC:"XZC",ACT:"ACT",SMT:"SMT",BCD:"BCD",WAX:"WAX1",WICC:"WICC",ELF:"ELF",ZIL:"ZIL",ELA:"ELA",BCX:"BCX",SBTC:"SBTC",BIFI:"BIFI",CTXC:"CTXC",WAN:"WAN",POLYX:"POLYX",PAI:"PAI",WTC:"WTC",DGB:"DGB",XVG:"XVG",AAC:"AAC",AE:"AE",SEELE:"SEELE",BCV:"BCV",GRS:"GRS",ARDR:"ARDR",NANO:"NANO",ZEN:"ZEN",RBTC:"RBTC",BSV:"BSV",GAS:"GAS",XTZ:"XTZ",LAMB:"LAMB",CVNT1:"CVNT1",DOCK:"DOCK",SC:"SC",KMD:"KMD",ETN:"ETN",TOP:"TOP",IRIS:"IRIS",UGAS:"UGAS",TT:"TT",NEWTON:"NEWTON",VSYS:"VSYS",FSN:"FSN",BHD:"BHD",ONE:"ONE",EM:"EM",CKB:"CKB",EOSS:"EOSS",HIVE:"HIVE",RVN:"RVN",DOT:"DOT",KSM:"KSM",BAND:"BAND",OEP4:"OEP4",NBS:"NBS",FIS:"FIS",AR:"AR",HBAR:"HBAR",FIL:"FIL",MASS:"MASS",KAVA:"KAVA",XYM:"XYM",ENJ:"ENJ",CRUST:"CRUST",ICP:"ICP",CSPR:"CSPR",FLOW:"FLOW",IOTX:"IOTX",LAT:"LAT",APT:"APT",XCH:"XCH",MINA:"MINA",XEC:"ECASH",XPRT:"XPRT",CCA:"ACA",AOTI:"COTI",AKT:"AKT",ARS:"ARS",ASTR:"ASTR",AZERO:"AZERO",BLD:"BLD",BRISE:"BRISE",CORE:"CORE",DESO:"DESO",DFI:"DFI",EGLD:"EGLD",ERG:"ERG",ETHF:"ETHFAIR",ETHW:"ETHW",EVMOS:"EVMOS",FIO:"FIO",FLR:"FLR",FINSCHIA:"FINSCHIA",KMA:"KMA",KYVE:"KYVE",MEV:"MEV",MOVR:"MOVR",NODL:"NODL",OAS:"OAS",OSMO:"OSMO",PAYCOIN:"PAYCOIN",POKT:"POKT",PYG:"PYG",REI:"REI",SCRT:"SCRT",SDN:"SDN",SEI:"SEI",SGB:"SGB",SUI:"SUI",SXP:"SOLAR",SYS:"SYS",TENET:"TENET",TON:"TON",UNQ:"UNQ",UYU:"UYU",WEMIX:"WEMIX",XDC:"XDC",XPLA:"XPLA"},fetchOrdersByStatesMethod:"spot_private_get_v1_order_orders",createMarketBuyOrderRequiresPrice:!0,language:"en-US",broker:{id:"AA03022abc"},accountsByType:{spot:"pro",funding:"pro",future:"futures"},accountsById:{spot:"spot",margin:"margin",otc:"otc",point:"point","super-margin":"super-margin",investment:"investment",borrow:"borrow","grid-trading":"grid-trading","deposit-earning":"deposit-earning","otc-options":"otc-options"},typesByAccount:{pro:"spot",futures:"future"},spot:{stopOrderTypes:{"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0},limitOrderTypes:{limit:!0,"buy-limit":!0,"sell-limit":!0,ioc:!0,"buy-ioc":!0,"sell-ioc":!0,"limit-maker":!0,"buy-limit-maker":!0,"sell-limit-maker":!0,"stop-limit":!0,"buy-stop-limit":!0,"sell-stop-limit":!0,"limit-fok":!0,"buy-limit-fok":!0,"sell-limit-fok":!0,"stop-limit-fok":!0,"buy-stop-limit-fok":!0,"sell-stop-limit-fok":!0}}},commonCurrencies:{GET:"THEMIS",GTC:"GAMECOM",HIT:"HITCHAIN",PNT:"PENTA",SBTC:"SUPERBITCOIN",SOUL:"SOULSAVER",BIFI:"BITCOINFILE"}})}async fetchStatus(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);const s=this.handleOption("fetchStatus","enableForContracts",!1);let i,r,a,o;if("spot"!==t&&s){const s=this.safeString(e,"subType",this.options.defaultSubType);"swap"===t?"linear"===s?i=await this.statusPublicSwapLinearGetApiV2SummaryJson():"inverse"===s&&(i=await this.statusPublicSwapInverseGetApiV2SummaryJson()):"future"===t?"linear"===s?i=await this.statusPublicFutureLinearGetApiV2SummaryJson():"inverse"===s&&(i=await this.statusPublicFutureInverseGetApiV2SummaryJson()):"contract"===t&&(i=await this.contractPublicGetHeartbeat())}else"spot"===t&&(i=await this.statusPublicSpotGetApiV2SummaryJson());if("contract"===t){const e=this.safeString(i,"status");r=void 0===e?void 0:"ok"===e?"ok":"maintenance",a=this.safeString(i,"ts")}else{const e=this.safeValue(i,"status",{});r="none"===this.safeString(e,"indicator")?"ok":"maintenance";const t=this.safeValue(i,"page",{}),s=this.safeString(t,"updated_at");a=this.parse8601(s),o=this.safeString(t,"url")}return{status:r,updated:a,eta:void 0,url:o,info:i}}async fetchTime(e={}){const t=this.safeValue(this.options,"fetchTime",{}),s=this.safeString(this.options,"defaultType","spot");let i,r=this.safeString(t,"type",s);return r=this.safeString(e,"type",r),i="future"===r||"swap"===r?await this.contractPublicGetApiV1Timestamp(e):await this.spotPublicGetV1CommonTimestamp(e),this.safeInteger2(i,"data","ts")}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s,t),maker:this.safeNumber(e,"actualMakerRate"),taker:this.safeNumber(e,"actualTakerRate"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},r=await this.spotPrivateGetV2ReferenceTransactFeeRate(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{});return this.parseTradingFee(o,s)}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const r=e[i];s[r]=await this.fetchTradingLimitsById(this.marketId(r),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.spotPublicGetV1CommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){let t;[t,e]=this.handleOptionAndParams(e,"fetchMarkets","types",{});let s=[],i=[];const r=Object.keys(t);for(let s=0;s<r.length;s++){const a=r[s];this.safeBool(t,a)&&("spot"===a?i.push(this.fetchMarketsByTypeAndSubType("spot",void 0,e)):"linear"===a?i.push(this.fetchMarketsByTypeAndSubType(void 0,"linear",e)):"inverse"===a&&(i.push(this.fetchMarketsByTypeAndSubType("swap","inverse",e)),i.push(this.fetchMarketsByTypeAndSubType("future","inverse",e))))}i=await Promise.all(i);for(let e=0;e<i.length;e++)s=this.arrayConcat(s,i[e]);return s}async fetchMarketsByTypeAndSubType(e,t,s={}){const i={};let o;"spot"===e?o=await this.spotPublicGetV1CommonSymbols(this.extend(i,s)):"linear"===t?(i.business_type="all",o=await this.contractPublicGetLinearSwapApiV1SwapContractInfo(this.extend(i,s))):"inverse"===t&&("future"===e?o=await this.contractPublicGetApiV1ContractContractInfo(this.extend(i,s)):"swap"===e&&(o=await this.contractPublicGetSwapApiV1SwapContractInfo(this.extend(i,s))));const n=this.safeList(o,"data",[]);if(n.length<1)throw new r.OperationFailed(this.id+" fetchMarkets() returned an empty response: "+this.json(o));const d=[];for(let t=0;t<n.length;t++){const s=n[t];let i,r,o,h,c;const l="contract_code"in s,u=!l;let p,f,m=!1,g=!1;if(l){h=this.safeString(s,"contract_code"),c=h.toLowerCase();if(g=void 0!==this.safeString(s,"delivery_date"),m=!g,p=void 0!==this.safeString(s,"business_type"),f=!p,m){e="swap";const t=h.split("-");i=this.safeStringLower(s,"symbol"),r=this.safeStringLower(t,1),o=f?i:r}else if(g)if(e="future",i=this.safeStringLower(s,"symbol"),f)r="USD",o=i;else{const e=this.safeString(s,"pair").split("-");r=this.safeStringLower(e,1),o=r}}else e="spot",i=this.safeString(s,"base-currency"),r=this.safeString(s,"quote-currency"),h=i+r,c=h.toLowerCase();const v=this.safeCurrencyCode(i),y=this.safeCurrencyCode(r),w=this.safeCurrencyCode(o);let b,S=v+"/"+y;l&&(f?S+=":"+v:p&&(S+=":"+y),g&&(b=this.safeInteger(s,"delivery_time"),S+="-"+this.yymmdd(b)));const k=this.safeNumber(s,"contract_size");let O=this.safeNumber(s,"min-order-value");const T=this.safeNumber(s,"max-order-amt");let P,I,x,A,M,C,E=this.safeNumber(s,"min-order-amt");if(l&&(p?E=k:f&&(O=k)),u){P=this.parseNumber(this.parsePrecision(this.safeString(s,"price-precision"))),I=this.parseNumber(this.parsePrecision(this.safeString(s,"amount-precision"))),x=this.parseNumber(this.parsePrecision(this.safeString(s,"value-precision"))),A=this.parseNumber("0.002"),M=this.parseNumber("0.002");C="online"===this.safeString(s,"state")}else{P=this.safeNumber(s,"price_tick"),I=this.parseNumber("1"),A=this.parseNumber("0.0002"),M=this.parseNumber("0.0005");C=1===this.safeInteger(s,"contract_status")}const _=this.safeString(s,"leverage-ratio","1"),B=this.safeString(s,"super-margin-leverage-ratio","1"),N=a.Y.stringGt(_,"1")||a.Y.stringGt(B,"1");let R,L=this.safeString(s,"create_date");if(void 0!==L){const e=this.stringToCharsArray(L);L=e[0]+e[1]+e[2]+e[3]+"-"+e[4]+e[5]+"-"+e[6]+e[7]+" 00:00:00",R=this.parse8601(L)}d.push({id:h,lowercaseId:c,symbol:S,base:v,quote:y,settle:w,baseId:i,quoteId:r,settleId:o,type:e,spot:u,margin:u&&N,swap:m,future:g,option:!1,active:C,contract:l,linear:p,inverse:f,taker:M,maker:A,contractSize:k,expiry:b,expiryDatetime:this.iso8601(b),strike:void 0,optionType:void 0,precision:{amount:I,price:P,cost:x},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(_),superMax:this.parseNumber(B)},amount:{min:E,max:T},price:{min:void 0,max:void 0},cost:{min:O,max:void 0}},created:R,info:s})}return d}tryGetSymbolFromFutureMarkets(e){if(e in this.markets)return e;"futureMarketIdsForSymbols"in this.options||(this.options.futureMarketIdsForSymbols={});const t=this.safeDict(this.options,"futureMarketIdsForSymbols",{});if(e in t)return t[e];const s=this.filterBy(this.markets,"future",!0),i={this_week:"CW",next_week:"NW",quarter:"CQ",next_quarter:"NQ"};for(let t=0;t<s.length;t++){const r=s[t],a=this.safeValue(r,"info",{}),o=i[this.safeString(a,"contract_type")];if((r.linear?r.base+"-"+r.quote+"-"+o:r.base+"_"+o)===e){const t=r.symbol;return this.options.futureMarketIdsForSymbols[e]=t,t}}return this.options.futureMarketIdsForSymbols[e]=e,e}parseTicker(e,t=void 0){const s=this.safeString2(e,"symbol","contract_code");let i=this.safeSymbol(s,t);i=this.tryGetSymbolFromFutureMarkets(i);const r=this.safeInteger2(e,"ts","quoteTime");let a,o,n,d;"bid"in e&&(Array.isArray(e.bid)?(a=this.safeString(e.bid,0),o=this.safeString(e.bid,1)):(a=this.safeString(e,"bid"),o=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(n=this.safeString(e.ask,0),d=this.safeString(e.ask,1)):(n=this.safeString(e,"ask"),d=this.safeString(e,"askSize")));const h=this.safeString(e,"open"),c=this.safeString(e,"close"),l=this.safeString(e,"amount"),u=this.safeString(e,"vol");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:a,bidVolume:o,ask:n,askVolume:d,vwap:void 0,open:h,close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:l,quoteVolume:u,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={};let r;s.linear?(i.contract_code=s.id,r=await this.contractPublicGetLinearSwapExMarketDetailMerged(this.extend(i,t))):s.inverse?s.future?(i.symbol=s.id,r=await this.contractPublicGetMarketDetailMerged(this.extend(i,t))):s.swap&&(i.contract_code=s.id,r=await this.contractPublicGetSwapExMarketDetailMerged(this.extend(i,t))):(i.symbol=s.id,r=await this.spotPublicGetMarketDetailMerged(this.extend(i,t)));const a=this.safeValue(r,"tick",{}),o=this.parseTicker(a,s),n=this.safeInteger(r,"ts");return o.timestamp=n,o.datetime=this.iso8601(n),o}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeString(e,0);let i;void 0!==s&&(i=this.market(s));const a="subType"in t||"business_type"in t;let o,n;[o,t]=this.handleMarketTypeAndParams("fetchTickers",i,t),[n,t]=this.handleSubTypeAndParams("fetchTickers",i,t);const d={},h="future"===o,c="swap"===o,l="inverse"===n;let u;if(!("spot"===o)||a)if("linear"===n)d.business_type=h?"futures":c?"swap":"all",u=await this.contractPublicGetLinearSwapExMarketDetailBatchMerged(this.extend(d,t));else{if(!l)throw new r.NotSupported(this.id+' fetchTickers() you have to set params["subType"] to either "linear" or "inverse" for contracts');if(h)u=await this.contractPublicGetMarketDetailBatchMerged(this.extend(d,t));else{if(!c)throw new r.NotSupported(this.id+' fetchTickers() you have to set params["type"] to either "swap" or "future" for inverse contracts');u=await this.contractPublicGetSwapExMarketDetailBatchMerged(this.extend(d,t))}}else u=await this.spotPublicGetMarketTickers(this.extend(d,t));const p=this.safeList2(u,"data","ticks",[]),f=this.parseTickers(p,e,t);return this.filterByArrayTickers(f,"symbol",e)}async fetchLastPrices(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.getMarketFromSymbols(e);let i,a,o;if([a,t]=this.handleSubTypeAndParams("fetchLastPrices",s,t),[i,t]=this.handleMarketTypeAndParams("fetchLastPrices",s,t),"swap"!==i&&"future"!==i||"linear"!==a)if("swap"===i&&"inverse"===a)o=await this.contractPublicGetSwapExMarketTrade(t);else{if("future"!==i||"inverse"!==a)throw new r.NotSupported(this.id+" fetchLastPrices() does not support "+i+" markets yet");o=await this.contractPublicGetMarketTrade(t)}else o=await this.contractPublicGetLinearSwapExMarketTrade(t);const n=this.safeValue(o,"tick",{}),d=this.safeList(n,"data",[]);return this.parseLastPrices(d,e)}parseLastPrice(e,t=void 0){const s=this.safeString2(e,"symbol","contract_code");t=this.safeMarket(s,t);const i=this.safeNumber(e,"price"),r=this.safeString(e,"direction");return{symbol:t.symbol,timestamp:void 0,datetime:void 0,price:i,side:r,info:e}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),a={type:"step0"};let o;if(i.linear)a.contract_code=i.id,o=await this.contractPublicGetLinearSwapExMarketDepth(this.extend(a,s));else if(i.inverse)i.future?(a.symbol=i.id,o=await this.contractPublicGetMarketDepth(this.extend(a,s))):i.swap&&(a.contract_code=i.id,o=await this.contractPublicGetSwapExMarketDepth(this.extend(a,s)));else{if(void 0!==t){if(5!==t&&10!==t&&20!==t&&150!==t)throw new r.BadRequest(this.id+" fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150");150!==t&&(a.depth=t)}a.symbol=i.id,o=await this.spotPublicGetMarketDepth(this.extend(a,s))}if("tick"in o){if(!o.tick)throw new r.BadSymbol(this.id+" fetchOrderBook() returned empty response: "+this.json(o));const t=this.safeValue(o,"tick"),s=this.safeInteger(t,"ts",this.safeInteger(o,"ts")),i=this.parseOrderBook(t,e,s);return i.nonce=this.safeInteger(t,"version"),i}throw new r.ExchangeError(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(o))}parseTrade(e,t=void 0){const s=this.safeString2(e,"contract_code","symbol"),i=(t=this.safeMarket(s,t)).symbol;let r=this.safeInteger2(e,"ts","created-at");r=this.safeInteger2(e,"created_at","create_date",r);const o=this.safeString2(e,"order-id","order_id");let n=this.safeString(e,"direction"),d=this.safeString(e,"type");if(void 0!==d){const e=d.split("-");n=e[0],d=e[1]}const h=this.safeStringLower(e,"role"),c=this.safeString2(e,"price","trade_price");let l=this.safeString2(e,"filled-amount","amount");l=this.safeString(e,"trade_volume",l);const u=this.safeString(e,"trade_turnover");let p,f=this.safeString(e,"filled-fees");void 0===f&&(f=a.Y.stringNeg(this.safeString(e,"trade_fee")));const m=this.safeString2(e,"fee-currency","fee_asset");let g=this.safeCurrencyCode(m);const v=this.safeString(e,"filled-points");if(void 0!==v&&(void 0===f||a.Y.stringEquals(f,"0"))){const t=this.safeString(e,"fee-deduct-currency");void 0!==t&&(f=v,g=this.safeCurrencyCode(t))}void 0!==f&&(p={cost:f,currency:g});const y=this.safeStringN(e,["trade_id","trade-id","id"]);return this.safeTrade({id:y,info:e,order:o,timestamp:r,datetime:this.iso8601(r),symbol:i,type:d,side:n,takerOrMaker:h,price:c,amount:l,cost:u,fee:p},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){let o,n;if(void 0!==t&&(o=this.market(t)),[n,a]=this.handleMarketTypeAndParams("fetchOrderTrades",o,a),"spot"!==n)throw new r.NotSupported(this.id+" fetchOrderTrades() is only supported for spot markets");return await this.fetchSpotOrderTrades(e,t,s,i,a)}async fetchSpotOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={"order-id":e},o=await this.spotPrivateGetV1OrderOrdersOrderIdMatchresults(this.extend(a,r));return this.parseTrades(o.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a,o,n=!1;if([n,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),n)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchMyTrades",a,i);let d,h={};if("spot"===o)void 0!==e&&(a=this.market(e),h.symbol=a.id),void 0!==s&&(h.size=s),void 0!==t&&(h["start-time"]=t),[h,i]=this.handleUntilOption("end-time",h,i),d=await this.spotPrivateGetV1OrderMatchresults(this.extend(h,i));else{if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");if(h.contract=a.id,h.trade_type=0,void 0!==t&&(h.start_time=t),[h,i]=this.handleUntilOption("end_time",h,i),void 0!==s&&(h.page_size=s),a.linear){let e;[e,i]=this.handleMarginModeAndParams("fetchMyTrades",i),e=void 0===e?"cross":e,"isolated"===e?d=await this.contractPrivatePostLinearSwapApiV3SwapMatchresultsExact(this.extend(h,i)):"cross"===e&&(d=await this.contractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact(this.extend(h,i)))}else if(a.inverse)if("future"===o)h.symbol=a.settleId,d=await this.contractPrivatePostApiV3ContractMatchresultsExact(this.extend(h,i));else{if("swap"!==o)throw new r.NotSupported(this.id+" fetchMyTrades() does not support "+o+" markets");d=await this.contractPrivatePostSwapApiV3SwapMatchresultsExact(this.extend(h,i))}}let c=this.safeValue(d,"data");return Array.isArray(c)||(c=this.safeValue(c,"trades")),this.parseTrades(c,a,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const r=this.market(e),a={};let o;void 0!==s&&(a.size=Math.min(s,2e3)),r.future?r.inverse?(a.symbol=r.id,o=await this.contractPublicGetMarketHistoryTrade(this.extend(a,i))):r.linear&&(a.contract_code=r.id,o=await this.contractPublicGetLinearSwapExMarketHistoryTrade(this.extend(a,i))):r.swap?(a.contract_code=r.id,r.inverse?o=await this.contractPublicGetSwapExMarketHistoryTrade(this.extend(a,i)):r.linear&&(o=await this.contractPublicGetLinearSwapExMarketHistoryTrade(this.extend(a,i)))):(a.symbol=r.id,o=await this.spotPublicGetMarketHistoryTrade(this.extend(a,i)));const n=this.safeValue(o,"data",[]);let d=[];for(let e=0;e<n.length;e++){const t=this.safeValue(n[e],"data",[]);for(let e=0;e<t.length;e++){const s=this.parseTrade(t[e],r);d.push(s)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,r.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,a,1e3);const n=this.market(e),d={period:this.safeString(this.timeframes,t,t)},h=this.safeStringN(a,["priceType","price"]);let c;a=this.omit(a,["priceType","price"]),[c,a]=this.handleParamInteger(a,"until");const l=void 0!==c?this.parseToInt(c/1e3):void 0;if(n.contract&&(void 0!==i?d.size=Math.min(i,2e3):i=2e3,void 0===h)){const e=this.parseTimeframe(t);let r;if(void 0===s){const t=this.seconds();d.from=t-e*(i-1),r=t}else{const t=this.parseToInt(s/1e3);d.from=t,r=this.sum(t,e*(i-1))}d.to=void 0!==l?l:r}let u;if(n.future){if(n.inverse)if(d.symbol=n.id,"mark"===h)u=await this.contractPublicGetIndexMarketHistoryMarkPriceKline(this.extend(d,a));else if("index"===h)u=await this.contractPublicGetIndexMarketHistoryIndex(this.extend(d,a));else{if("premiumIndex"===h)throw new r.BadRequest(this.id+" "+n.type+" has no api endpoint for "+h+" kline data");u=await this.contractPublicGetMarketHistoryKline(this.extend(d,a))}else if(n.linear)if(d.contract_code=n.id,"mark"===h)u=await this.contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.extend(d,a));else{if("index"===h)throw new r.BadRequest(this.id+" "+n.type+" has no api endpoint for "+h+" kline data");u="premiumIndex"===h?await this.contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.extend(d,a)):await this.contractPublicGetLinearSwapExMarketHistoryKline(this.extend(d,a))}}else if(n.swap){if(d.contract_code=n.id,n.inverse)if("mark"===h)u=await this.contractPublicGetIndexMarketHistorySwapMarkPriceKline(this.extend(d,a));else{if("index"===h)throw new r.BadRequest(this.id+" "+n.type+" has no api endpoint for "+h+" kline data");u="premiumIndex"===h?await this.contractPublicGetIndexMarketHistorySwapPremiumIndexKline(this.extend(d,a)):await this.contractPublicGetSwapExMarketHistoryKline(this.extend(d,a))}else if(n.linear)if("mark"===h)u=await this.contractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.extend(d,a));else{if("index"===h)throw new r.BadRequest(this.id+" "+n.type+" has no api endpoint for "+h+" kline data");u="premiumIndex"===h?await this.contractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.extend(d,a)):await this.contractPublicGetLinearSwapExMarketHistoryKline(this.extend(d,a))}}else{let e;d.symbol=n.id,[e,a]=this.handleOptionAndParams(a,"fetchOHLCV","useHistoricalEndpointForSpot",!0),e?(void 0!==s&&(d.from=this.parseToInt(s/1e3)),void 0!==l&&(d.to=l),void 0!==i&&(d.size=Math.min(1e3,i)),u=await this.spotPublicGetMarketHistoryCandles(this.extend(d,a))):(void 0!==i&&(d.size=Math.min(i,2e3)),u=await this.spotPublicGetMarketHistoryKline(this.extend(d,a)))}const p=this.safeList(u,"data",[]);return this.parseOHLCVs(p,n,t,s,i)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1AccountAccounts(e),s=this.safeValue(t,"data");return this.parseAccounts(s)}parseAccount(e){const t=this.safeString(e,"type"),s=this.safeValue(this.options,"accountsById",{}),i=this.safeValue(s,t,t);return{info:e,id:this.safeString(e,"id"),type:i,code:void 0}}async fetchAccountIdByType(e,t=void 0,s=void 0,i={}){const r=await this.loadAccounts(),a=this.safeValue2(i,"accountId","account-id");if(void 0!==a)return a;"spot"===e&&("cross"===t?e="super-margin":"isolated"===t&&(e="margin"));const o=void 0===s?void 0:this.marketId(s);for(let t=0;t<r.length;t++){const s=r[t],i=this.safeValue(s,"info"),a=this.safeString(i,"subtype",void 0),n=this.safeString(s,"type");if("margin"===e){if(a===o)return this.safeString(s,"id")}else if(e===n)return this.safeString(s,"id")}const n=this.safeValue(r,0,{});return this.safeString(n,"id")}async fetchCurrencies(e={}){const t=await this.spotPublicGetV2ReferenceCurrencies(e),s=this.safeValue(t,"data",[]),i={};this.options.networkChainIdsByNames={},this.options.networkNamesByChainIds={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),o=this.safeCurrencyCode(r);this.options.networkChainIdsByNames[o]={};const n=this.safeValue(t,"chains",[]),d={},h="normal"===this.safeString(t,"instStatus");let c,l,u,p,f=!1,m=!1;for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"chain"),i=this.safeString2(t,"baseChain","displayName");this.options.networkChainIdsByNames[o][i]=s,this.options.networkNamesByChainIds[s]=i;const r=this.networkIdToCode(s);l=this.safeNumber(t,"minDepositAmt"),u=this.safeNumber(t,"minWithdrawAmt"),p=this.safeNumber(t,"maxWithdrawAmt");const h="allowed"===this.safeString(t,"withdrawStatus"),g="allowed"===this.safeString(t,"depositStatus");m=h||m,f=g||f;const v=h&&g,y=this.parsePrecision(this.safeString(t,"withdrawPrecision"));void 0!==y&&(c=void 0===c?y:a.Y.stringMin(y,c));const w=this.safeNumber(t,"transactFeeWithdraw");d[r]={info:t,id:s,network:r,limits:{deposit:{min:l,max:void 0},withdraw:{min:u,max:p}},active:v,deposit:g,withdraw:h,fee:w,precision:this.parseNumber(y)}}i[o]={info:t,code:o,id:r,active:h,deposit:f,withdraw:m,fee:void 0,name:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:u,max:p},deposit:{min:void 0,max:void 0}},precision:this.parseNumber(c),networks:d}}return i}networkIdToCode(e=void 0,t=void 0){if(0===Object.keys(this.options.networkNamesByChainIds).length)throw new r.ExchangeError(this.id+" networkIdToCode() - markets need to be loaded at first");const s=this.safeValue(this.options.networkNamesByChainIds,e,e);return super.networkIdToCode(s)}networkCodeToId(e,t=void 0){if(void 0===t)throw new r.ArgumentsRequired(this.id+" networkCodeToId() requires a currencyCode argument");if(0===Object.keys(this.options.networkChainIdsByNames).length)throw new r.ExchangeError(this.id+" networkCodeToId() - markets need to be loaded at first");const s=this.safeValue(this.options.networkChainIdsByNames,t,{});if(e in s)return s[e];{const t=super.networkCodeToId(e);return this.safeValue(s,t,t)}}async fetchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeValue(this.options,"fetchBalance",{}),i=this.safeValue2(e,"isUnifiedAccount","unified",!1);e=this.omit(e,["isUnifiedAccount","unified"]);const r={},a="spot"===t,o="future"===t,n=this.safeString2(this.options,"defaultSubType","subType","linear");let d=this.safeString2(s,"defaultSubType","subType",n);d=this.safeString2(e,"defaultSubType","subType",d);const h="inverse"===d,c="linear"===d;let l;[l,e]=this.handleMarginModeAndParams("fetchBalance",e),e=this.omit(e,["defaultSubType","subType"]);const u="isolated"===l,p="margin"===t||a&&("cross"===l||u);let f;if(a||p)if(p)f=u?await this.spotPrivateGetV1MarginAccountsBalance(this.extend(r,e)):await this.spotPrivateGetV1CrossMarginAccountsBalance(this.extend(r,e));else{await this.loadAccounts();const s=await this.fetchAccountIdByType(t,void 0,void 0,e);r["account-id"]=s,f=await this.spotPrivateGetV1AccountAccountsAccountIdBalance(this.extend(r,e))}else i?f=await this.contractPrivateGetLinearSwapApiV3UnifiedAccountInfo(this.extend(r,e)):c?f=u?await this.contractPrivatePostLinearSwapApiV1SwapAccountInfo(this.extend(r,e)):await this.contractPrivatePostLinearSwapApiV1SwapCrossAccountInfo(this.extend(r,e)):h&&(f=o?await this.contractPrivatePostApiV1ContractAccountInfo(this.extend(r,e)):await this.contractPrivatePostSwapApiV1SwapAccountInfo(this.extend(r,e)));let m={info:f};const g=this.safeValue(f,"data");if(a||p)if(u)for(let e=0;e<g.length;e++){const t=g[e],s=this.safeSymbol(this.safeString(t,"symbol")),i=this.safeValue(t,"list"),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"currency"),a=this.safeCurrencyCode(s);r[a]=this.parseMarginBalanceHelper(t,a,r)}m[s]=this.safeBalance(r)}else{const e=this.safeValue(g,"list",[]);for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"currency"),r=this.safeCurrencyCode(i);m[r]=this.parseMarginBalanceHelper(s,r,m)}m=this.safeBalance(m)}else if(i)for(let e=0;e<g.length;e++){const t=g[e],s=this.safeString(t,"margin_asset"),i=this.safeCurrencyCode(s);if(u){const e=this.safeValue(t,"isolated_swap",{});for(let t=0;t<e.length;t++){const s=e[t],r=this.safeString(s,"contract_code"),a={code:i,free:this.safeNumber(s,"margin_available")};m[this.safeSymbol(r)]=a,m=this.safeBalance(m)}}else{const e=this.account();e.free=this.safeString(t,"margin_static"),e.used=this.safeString(t,"margin_frozen"),m[i]=e,m=this.safeBalance(m)}}else if(c){const e=this.safeValue(g,0,{});if(u)for(let e=0;e<g.length;e++){const t=g[e],s=this.safeString2(t,"contract_code","margin_account"),i=this.safeMarket(s),r=this.safeString(t,"margin_asset"),a=this.safeCurrency(r),o=this.safeString(i,"settle",a.code);if(void 0!==o){const e=this.account();e.free=this.safeString(t,"margin_balance"),e.used=this.safeString(t,"margin_frozen");const s={};s[o]=e;m[i.symbol]=this.safeBalance(s)}}else{const t=this.account();t.free=this.safeString(e,"withdraw_available"),t.total=this.safeString(e,"margin_balance");const s=this.safeString2(e,"margin_asset","symbol");m[this.safeCurrencyCode(s)]=t,m=this.safeBalance(m)}}else if(h){for(let e=0;e<g.length;e++){const t=g[e],s=this.safeString(t,"symbol"),i=this.safeCurrencyCode(s),r=this.account();r.free=this.safeString(t,"margin_available"),r.used=this.safeString(t,"margin_frozen"),m[i]=r}m=this.safeBalance(m)}return m}async fetchOrder(e,t=void 0,s={}){let i,a;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),[a,s]=this.handleMarketTypeAndParams("fetchOrder",i,s);const o={};let n;if("spot"===a){void 0!==this.safeString(s,"clientOrderId")?n=await this.spotPrivateGetV1OrderOrdersGetClientOrder(this.extend(o,s)):(o["order-id"]=e,n=await this.spotPrivateGetV1OrderOrdersOrderId(this.extend(o,s)))}else{if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");const d=this.safeString2(s,"client_order_id","clientOrderId");if(void 0===d?o.order_id=e:(o.client_order_id=d,s=this.omit(s,["client_order_id","clientOrderId"])),o.contract_code=i.id,i.linear){let e;[e,s]=this.handleMarginModeAndParams("fetchOrder",s),e=void 0===e?"cross":e,"isolated"===e?n=await this.contractPrivatePostLinearSwapApiV1SwapOrderInfo(this.extend(o,s)):"cross"===e&&(n=await this.contractPrivatePostLinearSwapApiV1SwapCrossOrderInfo(this.extend(o,s)))}else if(i.inverse)if("future"===a)o.symbol=i.settleId,n=await this.contractPrivatePostApiV1ContractOrderInfo(this.extend(o,s));else{if("swap"!==a)throw new r.NotSupported(this.id+" fetchOrder() does not support "+a+" markets");n=await this.contractPrivatePostSwapApiV1SwapOrderInfo(this.extend(o,s))}}let d=this.safeValue(n,"data");return Array.isArray(d)&&(d=this.safeValue(d,0)),this.parseOrder(d)}parseMarginBalanceHelper(e,t,s){let i;return i=t in s?s[t]:this.account(),"trade"===e.type&&(i.free=this.safeString(e,"balance")),"frozen"===e.type&&(i.used=this.safeString(e,"balance")),i}async fetchSpotOrdersByStates(e,t=void 0,s=void 0,i=void 0,a={}){const o=this.safeString(this.options,"fetchOrdersByStatesMethod","spot_private_get_v1_order_orders");if("spot_private_get_v1_order_orders"===o&&void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");let n;await this.loadMarkets();let d,h={states:e};void 0!==t&&(n=this.market(t),h.symbol=n.id),void 0!==s&&(h["start-time"]=s,h["end-time"]=this.sum(s,1728e5)),[h,a]=this.handleUntilOption("end-time",h,a),void 0!==i&&(h.size=i),d="spot_private_get_v1_order_orders"===o?await this.spotPrivateGetV1OrderOrders(this.extend(h,a)):await this.spotPrivateGetV1OrderHistory(this.extend(h,a));const c=this.safeList(d,"data",[]);return this.parseOrders(c,n,s,i)}async fetchSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchClosedSpotOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchSpotOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchContractOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchContractOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);let o,n={trade_type:0,status:"0"};const d=this.safeBool2(i,"stop","trigger"),h=this.safeValue(i,"stopLossTakeProfit"),c=this.safeBool(i,"trailing",!1);if(i=this.omit(i,["stop","stopLossTakeProfit","trailing","trigger"]),d||h||c?(void 0!==s&&(n.page_size=s),n.contract_code=a.id,n.create_date=90):(void 0!==t&&(n.start_time=t),n.contract=a.id,n.type=1),[n,i]=this.handleUntilOption("end_time",n,i),a.linear){let e;[e,i]=this.handleMarginModeAndParams("fetchContractOrders",i),e=void 0===e?"cross":e,"isolated"===e?o=d?await this.contractPrivatePostLinearSwapApiV1SwapTriggerHisorders(this.extend(n,i)):h?await this.contractPrivatePostLinearSwapApiV1SwapTpslHisorders(this.extend(n,i)):c?await this.contractPrivatePostLinearSwapApiV1SwapTrackHisorders(this.extend(n,i)):await this.contractPrivatePostLinearSwapApiV3SwapHisorders(this.extend(n,i)):"cross"===e&&(o=d?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerHisorders(this.extend(n,i)):h?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslHisorders(this.extend(n,i)):c?await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackHisorders(this.extend(n,i)):await this.contractPrivatePostLinearSwapApiV3SwapCrossHisorders(this.extend(n,i)))}else a.inverse&&(a.swap?o=d?await this.contractPrivatePostSwapApiV1SwapTriggerHisorders(this.extend(n,i)):h?await this.contractPrivatePostSwapApiV1SwapTpslHisorders(this.extend(n,i)):c?await this.contractPrivatePostSwapApiV1SwapTrackHisorders(this.extend(n,i)):await this.contractPrivatePostSwapApiV3SwapHisorders(this.extend(n,i)):a.future&&(n.symbol=a.settleId,o=d?await this.contractPrivatePostApiV1ContractTriggerHisorders(this.extend(n,i)):h?await this.contractPrivatePostApiV1ContractTpslHisorders(this.extend(n,i)):c?await this.contractPrivatePostApiV1ContractTrackHisorders(this.extend(n,i)):await this.contractPrivatePostApiV3ContractHisorders(this.extend(n,i))));let l=this.safeValue(o,"data");return Array.isArray(l)||(l=this.safeValue(l,"orders",[])),this.parseOrders(l,a,t,s)}async fetchClosedContractOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchContractOrders(e,t,s,this.extend({status:"5,6,7"},i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o;await this.loadMarkets(),void 0!==e&&(a=this.market(e)),[o,i]=this.handleMarketTypeAndParams("fetchOrders",a,i);const n="swap"===o||"future"===o;if(n&&void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument for "+o+" orders");return n?await this.fetchContractOrders(e,t,s,i):await this.fetchSpotOrders(e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o=!1;return[o,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),o?await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i,100):(void 0!==e&&(r=this.market(e)),[a,i]=this.handleMarketTypeAndParams("fetchClosedOrders",r,i),"spot"===a?await this.fetchClosedSpotOrders(e,t,s,i):await this.fetchClosedContractOrders(e,t,s,i))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),void 0!==e&&(a=this.market(e));const o={};let n,d;if([n,i]=this.handleMarketTypeAndParams("fetchOpenOrders",a,i),"spot"===n){void 0!==e&&(o.symbol=a.id);let t=this.safeString(i,"account-id");if(void 0===t){await this.loadAccounts();for(let e=0;e<this.accounts.length;e++){const s=this.accounts[e];if("spot"===s.type&&(t=this.safeString(s,"id"),void 0!==t))break}}o["account-id"]=t,void 0!==s&&(o.size=s),i=this.omit(i,"account-id"),d=await this.spotPrivateGetV1OrderOpenOrders(this.extend(o,i))}else{if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");void 0!==s&&(o.page_size=s),o.contract_code=a.id;const t=this.safeBool2(i,"stop","trigger"),n=this.safeValue(i,"stopLossTakeProfit"),h=this.safeBool(i,"trailing",!1);if(i=this.omit(i,["stop","stopLossTakeProfit","trailing","trigger"]),a.linear){let e;[e,i]=this.handleMarginModeAndParams("fetchOpenOrders",i),e=void 0===e?"cross":e,"isolated"===e?d=t?await this.contractPrivatePostLinearSwapApiV1SwapTriggerOpenorders(this.extend(o,i)):n?await this.contractPrivatePostLinearSwapApiV1SwapTpslOpenorders(this.extend(o,i)):h?await this.contractPrivatePostLinearSwapApiV1SwapTrackOpenorders(this.extend(o,i)):await this.contractPrivatePostLinearSwapApiV1SwapOpenorders(this.extend(o,i)):"cross"===e&&(d=t?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerOpenorders(this.extend(o,i)):n?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslOpenorders(this.extend(o,i)):h?await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackOpenorders(this.extend(o,i)):await this.contractPrivatePostLinearSwapApiV1SwapCrossOpenorders(this.extend(o,i)))}else a.inverse&&(a.swap?d=t?await this.contractPrivatePostSwapApiV1SwapTriggerOpenorders(this.extend(o,i)):n?await this.contractPrivatePostSwapApiV1SwapTpslOpenorders(this.extend(o,i)):h?await this.contractPrivatePostSwapApiV1SwapTrackOpenorders(this.extend(o,i)):await this.contractPrivatePostSwapApiV1SwapOpenorders(this.extend(o,i)):a.future&&(o.symbol=a.settleId,d=t?await this.contractPrivatePostApiV1ContractTriggerOpenorders(this.extend(o,i)):n?await this.contractPrivatePostApiV1ContractTpslOpenorders(this.extend(o,i)):h?await this.contractPrivatePostApiV1ContractTrackOpenorders(this.extend(o,i)):await this.contractPrivatePostApiV1ContractOpenorders(this.extend(o,i))))}let h=this.safeValue(d,"data");return Array.isArray(h)||(h=this.safeValue(h,"orders",[])),this.parseOrders(h,a,t,s)}parseOrderStatus(e){return this.safeString({"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open",created:"open",1:"open",2:"open",3:"open",4:"open",5:"canceled",6:"closed",7:"canceled",11:"canceling"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"err_code","err-code");let i=this.parseOrderStatus(this.safeString2(e,"state","status"));void 0!==s&&(i="rejected");const r=this.safeStringN(e,["id","order_id_str","order-id"]);let a=this.safeString(e,"direction"),o=this.safeString(e,"order_price_type");if("type"in e){const t=e.type.split("-");a=t[0],o=t[1]}const n=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(n,t);const d=this.safeIntegerN(e,["created_at","created-at","create_date"]),h=this.safeString2(e,"client_order_id","client-order-id");let c,l;void 0!==o&&o.indexOf("market")>=0?c="sell"===a?this.safeString(e,"field-cash-amount"):this.safeString(e,"amount"):(l=this.safeString2(e,"volume","amount"),c=this.safeStringN(e,["filled-cash-amount","field-cash-amount","trade_turnover"]));const u=this.safeStringN(e,["filled-amount","field-amount","trade_volume"]),p=this.safeString2(e,"price","order_price");let f,m=this.safeString2(e,"filled-fees","field-fees");if(m=this.safeString(e,"fee",m),void 0!==m){let s;const i=this.safeString(e,"fee_asset");s=void 0!==i?this.safeCurrencyCode(i):"sell"===a?t.quote:t.base,f={cost:m,currency:s}}const g=this.safeString2(e,"stop-price","trigger_price"),v=this.safeString(e,"trade_avg_price"),y=this.safeValue(e,"trades"),w=this.safeInteger(e,"reduce_only");let b;return void 0!==w&&(b=0!==w),this.safeOrder({info:e,id:r,clientOrderId:h,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:t.symbol,type:o,timeInForce:void 0,postOnly:void 0,side:a,price:p,stopPrice:g,triggerPrice:g,average:v,cost:c,amount:l,filled:u,remaining:void 0,status:i,reduceOnly:b,fee:f,trades:y},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createTrailingPercentOrder(e,t,s,i,a=void 0,o=void 0,n=void 0,d={}){if(void 0===o)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingPercent argument");if(void 0===n)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingTriggerPrice argument");return d.trailingPercent=o,d.trailingTriggerPrice=n,await this.createOrder(e,t,s,i,a,d)}async createSpotOrderRequest(e,t,s,i,o=void 0,n={}){await this.loadMarkets(),await this.loadAccounts();const d=this.market(e);let h;[h,n]=this.handleMarginModeAndParams("createOrder",n);const c={"account-id":await this.fetchAccountIdByType(d.type,h,e),symbol:d.id};let l=t.replace("buy-","");l=l.replace("sell-","");const u=this.safeValue(this.options,d.type,{}),p=this.safeString2(n,"stopPrice","stop-price");if(void 0===p){if(l in this.safeValue(u,"stopOrderTypes",{}))throw new r.ArgumentsRequired(this.id+" createOrder() requires a stopPrice or a stop-price parameter for a stop order")}else{const i="sell"===s?"lte":"gte",a=this.safeString(n,"operator",i);if(c["stop-price"]=this.priceToPrecision(e,p),c.operator=a,"limit"===l||"limit-fok"===l)l="stop-"+l;else if("stop-limit"!==l&&"stop-limit-fok"!==l)throw new r.NotSupported(this.id+" createOrder() does not support "+t+" orders")}let f;[f,n]=this.handlePostOnly("market"===l,"limit-maker"===l,n),f&&(l="limit-maker");const m=this.safeString(n,"timeInForce","GTC");"FOK"===m?l+="-fok":"IOC"===m&&(l="ioc"),c.type=s+"-"+l;const g=this.safeString2(n,"clientOrderId","client-order-id");if(void 0===g){const e=this.safeValue(this.options,"broker",{}),t=this.safeString(e,"id");c["client-order-id"]=t+this.uuid()}else c["client-order-id"]=g;if("cross"===h?c.source="super-margin-api":"isolated"===h?c.source="margin-api":"c2c"===h&&(c.source="c2c-margin-api"),"market"===l&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.amountToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o);t=this.amountToPrecision(e,a.Y.stringMul(s,r))}}else t=this.amountToPrecision(e,i);c.amount=t}else c.amount=this.amountToPrecision(e,i);return l in this.safeValue(u,"limitOrderTypes",{})&&(c.price=this.priceToPrecision(e,o)),n=this.omit(n,["stopPrice","stop-price","clientOrderId","client-order-id","operator","timeInForce"]),this.extend(c,n)}createContractOrderRequest(e,t,s,i,r=void 0,o={}){const n={contract_code:this.market(e).id,volume:this.amountToPrecision(e,i),direction:s};let d;[d,o]=this.handlePostOnly("market"===t,"post_only"===t,o),d&&(t="post_only");const h=this.safeString(o,"timeInForce","GTC");"FOK"===h?t="fok":"IOC"===h&&(t="ioc");const c=this.safeNumber2(o,"stopPrice","trigger_price"),l=this.safeNumber2(o,"stopLossPrice","sl_trigger_price"),u=this.safeNumber2(o,"takeProfitPrice","tp_trigger_price"),p=this.safeString2(o,"trailingPercent","callback_rate"),f=this.safeNumber(o,"trailingTriggerPrice",r),m=void 0!==p,g=void 0!==l,v=void 0!==u;if(void 0!==c){const t=this.safeString2(o,"triggerType","trigger_type","le");n.trigger_type=t,n.trigger_price=this.priceToPrecision(e,c),void 0!==r&&(n.order_price=this.priceToPrecision(e,r))}else if(g||v)g?(n.sl_order_price_type=t,n.sl_trigger_price=this.priceToPrecision(e,l),void 0!==r&&(n.sl_order_price=this.priceToPrecision(e,r))):(n.tp_order_price_type=t,n.tp_trigger_price=this.priceToPrecision(e,u),void 0!==r&&(n.tp_order_price=this.priceToPrecision(e,r)));else if(m){const e=a.Y.stringDiv(p,"100");n.callback_rate=this.parseToNumeric(e),n.active_price=f,n.order_price_type=this.safeString(o,"order_price_type","formula_price")}else{const s=this.safeInteger2(o,"client_order_id","clientOrderId");void 0!==s&&(n.client_order_id=s,o=this.omit(o,["clientOrderId"])),"limit"!==t&&"ioc"!==t&&"fok"!==t&&"post_only"!==t||(n.price=this.priceToPrecision(e,r))}if(!g&&!v){this.safeValue2(o,"reduceOnly","reduce_only",!1)&&(n.reduce_only=1),n.lever_rate=this.safeIntegerN(o,["leverRate","lever_rate","leverage"],1),m||(n.order_price_type=t)}const y=this.safeValue(this.options,"broker",{}),w=this.safeString(y,"id");return n.channel_code=w,o=this.omit(o,["reduceOnly","stopPrice","stopLossPrice","takeProfitPrice","triggerType","leverRate","timeInForce","leverage","trailingPercent","trailingTriggerPrice"]),this.extend(n,o)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=this.safeNumber2(o,"stopPrice","trigger_price"),h=this.safeNumber2(o,"stopLossPrice","sl_trigger_price"),c=this.safeNumber2(o,"takeProfitPrice","tp_trigger_price"),l=void 0!==this.safeNumber(o,"trailingPercent"),u=void 0!==d,p=void 0!==h,f=void 0!==c;let m,g,v;if(n.spot){if(l)throw new r.NotSupported(this.id+" createOrder() does not support trailing orders for spot markets");const n=await this.createSpotOrderRequest(e,t,s,i,a,o);m=await this.spotPrivatePostV1OrderOrdersPlace(n)}else{let d=this.createContractOrderRequest(e,t,s,i,a,o);if(n.linear){let e;[e,d]=this.handleMarginModeAndParams("createOrder",d),e=void 0===e?"cross":e,"isolated"===e?m=u?await this.contractPrivatePostLinearSwapApiV1SwapTriggerOrder(d):p||f?await this.contractPrivatePostLinearSwapApiV1SwapTpslOrder(d):l?await this.contractPrivatePostLinearSwapApiV1SwapTrackOrder(d):await this.contractPrivatePostLinearSwapApiV1SwapOrder(d):"cross"===e&&(m=u?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerOrder(d):p||f?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslOrder(d):l?await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackOrder(d):await this.contractPrivatePostLinearSwapApiV1SwapCrossOrder(d))}else if(n.inverse){if(void 0===this.safeString(o,"offset"))throw new r.ArgumentsRequired(this.id+' createOrder () requires an extra parameter params["offset"] to be set to "open" or "close" when placing orders in inverse markets');n.swap?m=u?await this.contractPrivatePostSwapApiV1SwapTriggerOrder(d):p||f?await this.contractPrivatePostSwapApiV1SwapTpslOrder(d):l?await this.contractPrivatePostSwapApiV1SwapTrackOrder(d):await this.contractPrivatePostSwapApiV1SwapOrder(d):n.future&&(m=u?await this.contractPrivatePostApiV1ContractTriggerOrder(d):p||f?await this.contractPrivatePostApiV1ContractTpslOrder(d):l?await this.contractPrivatePostApiV1ContractTrackOrder(d):await this.contractPrivatePostApiV1ContractOrder(d))}}return n.spot?this.safeOrder({info:m,id:this.safeString(m,"data"),timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:void 0,symbol:void 0,type:t,side:s,price:a,amount:i,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0},n):(p?(g=this.safeValue(m,"data",{}),v=this.safeValue(g,"sl_order",{})):f?(g=this.safeValue(m,"data",{}),v=this.safeValue(g,"tp_order",{})):v=this.safeValue(m,"data",{}),this.parseOrder(v,n))}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i,a,o;for(let t=0;t<e.length;t++){const n=e[t],d=this.safeString(n,"symbol");if(void 0===i)i=d;else if(i!==d)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const h=this.safeString(n,"type"),c=this.safeString(n,"side"),l=this.safeValue(n,"amount"),u=this.safeValue(n,"price"),p=this.safeValue(n,"params",{}),f=this.handleMarginModeAndParams("createOrders",p)[0];if(void 0!==f)if(void 0===o)o=f;else if(o!==f)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same margin mode (isolated or cross)");let m;a=this.market(i),m=a.spot?await this.createSpotOrderRequest(d,h,c,l,u,p):this.createContractOrderRequest(d,h,c,l,u,p),m=this.omit(m,"marginMode"),s.push(m)}const n={};let d,h;if(a.spot?d=await this.privatePostOrderBatchOrders(s):(n.orders_data=s,a.linear?(o=void 0===o?"cross":o,"isolated"===o?d=await this.contractPrivatePostLinearSwapApiV1SwapBatchorder(n):"cross"===o&&(d=await this.contractPrivatePostLinearSwapApiV1SwapCrossBatchorder(n))):a.inverse&&(a.swap?d=await this.contractPrivatePostSwapApiV1SwapBatchorder(n):a.future&&(d=await this.contractPrivatePostApiV1ContractBatchorder(n)))),a.spot)h=this.safeValue(d,"data",[]);else{const e=this.safeValue(d,"data",{}),t=this.safeValue(e,"success",[]),s=this.safeValue(e,"errors",[]);h=this.arrayConcat(t,s)}return this.parseOrders(h,a)}async cancelOrder(e,t=void 0,s={}){let i,a;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),[a,s]=this.handleMarketTypeAndParams("cancelOrder",i,s);const o={};let n;if("spot"===a){const t=this.safeString2(s,"client-order-id","clientOrderId");void 0===t?(o["order-id"]=e,n=await this.spotPrivatePostV1OrderOrdersOrderIdSubmitcancel(this.extend(o,s))):(o["client-order-id"]=t,s=this.omit(s,["client-order-id","clientOrderId"]),n=await this.spotPrivatePostV1OrderOrdersSubmitCancelClientOrder(this.extend(o,s)))}else{if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const d=this.safeString2(s,"client_order_id","clientOrderId");void 0===d?o.order_id=e:(o.client_order_id=d,s=this.omit(s,["client_order_id","clientOrderId"])),i.future?o.symbol=i.settleId:o.contract_code=i.id;const h=this.safeBool2(s,"stop","trigger"),c=this.safeValue(s,"stopLossTakeProfit"),l=this.safeBool(s,"trailing",!1);if(s=this.omit(s,["stop","stopLossTakeProfit","trailing","trigger"]),i.linear){let e;[e,s]=this.handleMarginModeAndParams("cancelOrder",s),e=void 0===e?"cross":e,"isolated"===e?n=h?await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostLinearSwapApiV1SwapTpslCancel(this.extend(o,s)):l?await this.contractPrivatePostLinearSwapApiV1SwapTrackCancel(this.extend(o,s)):await this.contractPrivatePostLinearSwapApiV1SwapCancel(this.extend(o,s)):"cross"===e&&(n=h?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.extend(o,s)):l?await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackCancel(this.extend(o,s)):await this.contractPrivatePostLinearSwapApiV1SwapCrossCancel(this.extend(o,s)))}else{if(!i.inverse)throw new r.NotSupported(this.id+" cancelOrder() does not support "+a+" markets");i.swap?n=h?await this.contractPrivatePostSwapApiV1SwapTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostSwapApiV1SwapTpslCancel(this.extend(o,s)):l?await this.contractPrivatePostSwapApiV1SwapTrackCancel(this.extend(o,s)):await this.contractPrivatePostSwapApiV1SwapCancel(this.extend(o,s)):i.future&&(n=h?await this.contractPrivatePostApiV1ContractTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostApiV1ContractTpslCancel(this.extend(o,s)):l?await this.contractPrivatePostApiV1ContractTrackCancel(this.extend(o,s)):await this.contractPrivatePostApiV1ContractCancel(this.extend(o,s)))}}return this.extend(this.parseOrder(n,i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){let i,a;await this.loadMarkets(),void 0!==t&&(i=this.market(t)),[a,s]=this.handleMarketTypeAndParams("cancelOrders",i,s);const o={};let n;if("spot"===a){let t=this.safeValue2(s,"client-order-id","clientOrderId");t=this.safeValue2(s,"client-order-ids","clientOrderIds",t),void 0===t?o["order-ids"]="string"==typeof t?[e]:e:(o["client-order-ids"]="string"==typeof t?[t]:t,s=this.omit(s,["client-order-id","client-order-ids","clientOrderId","clientOrderIds"])),n=await this.spotPrivatePostV1OrderOrdersBatchcancel(this.extend(o,s))}else{if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");let d=this.safeString2(s,"client_order_id","clientOrderId");d=this.safeString2(s,"client_order_ids","clientOrderIds",d),void 0===d?o.order_id=e.join(","):(o.client_order_id=d,s=this.omit(s,["client_order_id","client_order_ids","clientOrderId","clientOrderIds"])),i.future?o.symbol=i.settleId:o.contract_code=i.id;const h=this.safeBool2(s,"stop","trigger"),c=this.safeValue(s,"stopLossTakeProfit");if(s=this.omit(s,["stop","stopLossTakeProfit","trigger"]),i.linear){let e;[e,s]=this.handleMarginModeAndParams("cancelOrders",s),e=void 0===e?"cross":e,"isolated"===e?n=h?await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostLinearSwapApiV1SwapTpslCancel(this.extend(o,s)):await this.contractPrivatePostLinearSwapApiV1SwapCancel(this.extend(o,s)):"cross"===e&&(n=h?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.extend(o,s)):await this.contractPrivatePostLinearSwapApiV1SwapCrossCancel(this.extend(o,s)))}else{if(!i.inverse)throw new r.NotSupported(this.id+" cancelOrders() does not support "+a+" markets");i.swap?n=h?await this.contractPrivatePostSwapApiV1SwapTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostSwapApiV1SwapTpslCancel(this.extend(o,s)):await this.contractPrivatePostSwapApiV1SwapCancel(this.extend(o,s)):i.future&&(n=h?await this.contractPrivatePostApiV1ContractTriggerCancel(this.extend(o,s)):c?await this.contractPrivatePostApiV1ContractTpslCancel(this.extend(o,s)):await this.contractPrivatePostApiV1ContractCancel(this.extend(o,s)))}}const d=this.safeDict(n,"data");return this.parseCancelOrders(d)}parseCancelOrders(e){const t=this.safeString(e,"successes");let s;s=void 0!==t?t.split(","):this.safeList(e,"success",[]);const i=this.safeList2(e,"errors","failed",[]),r=[];for(let e=0;e<s.length;e++){const t=s[e];r.push(this.safeOrder({info:t,id:t,status:"canceled"}))}for(let e=0;e<i.length;e++){const t=i[e];r.push(this.safeOrder({info:t,id:this.safeString2(t,"order-id","order_id"),status:"failed",clientOrderId:this.safeString(t,"client-order-id")}))}return r}async cancelAllOrders(e=void 0,t={}){let s,i;await this.loadMarkets(),void 0!==e&&(s=this.market(e)),[i,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const a={};let o;if("spot"===i){void 0!==e&&(a.symbol=s.id),o=await this.spotPrivatePostV1OrderOrdersBatchCancelOpenOrders(this.extend(a,t));const i=this.safeDict(o,"data");return[this.safeOrder({info:i})]}{if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");s.future&&(a.symbol=s.settleId),a.contract_code=s.id;const n=this.safeBool2(t,"stop","trigger"),d=this.safeValue(t,"stopLossTakeProfit"),h=this.safeBool(t,"trailing",!1);if(t=this.omit(t,["stop","stopLossTakeProfit","trailing","trigger"]),s.linear){let e;[e,t]=this.handleMarginModeAndParams("cancelAllOrders",t),e=void 0===e?"cross":e,"isolated"===e?o=n?await this.contractPrivatePostLinearSwapApiV1SwapTriggerCancelall(this.extend(a,t)):d?await this.contractPrivatePostLinearSwapApiV1SwapTpslCancelall(this.extend(a,t)):h?await this.contractPrivatePostLinearSwapApiV1SwapTrackCancelall(this.extend(a,t)):await this.contractPrivatePostLinearSwapApiV1SwapCancelall(this.extend(a,t)):"cross"===e&&(o=n?await this.contractPrivatePostLinearSwapApiV1SwapCrossTriggerCancelall(this.extend(a,t)):d?await this.contractPrivatePostLinearSwapApiV1SwapCrossTpslCancelall(this.extend(a,t)):h?await this.contractPrivatePostLinearSwapApiV1SwapCrossTrackCancelall(this.extend(a,t)):await this.contractPrivatePostLinearSwapApiV1SwapCrossCancelall(this.extend(a,t)))}else{if(!s.inverse)throw new r.NotSupported(this.id+" cancelAllOrders() does not support "+i+" markets");s.swap?o=n?await this.contractPrivatePostSwapApiV1SwapTriggerCancelall(this.extend(a,t)):d?await this.contractPrivatePostSwapApiV1SwapTpslCancelall(this.extend(a,t)):h?await this.contractPrivatePostSwapApiV1SwapTrackCancelall(this.extend(a,t)):await this.contractPrivatePostSwapApiV1SwapCancelall(this.extend(a,t)):s.future&&(o=n?await this.contractPrivatePostApiV1ContractTriggerCancelall(this.extend(a,t)):d?await this.contractPrivatePostApiV1ContractTpslCancelall(this.extend(a,t)):h?await this.contractPrivatePostApiV1ContractTrackCancelall(this.extend(a,t)):await this.contractPrivatePostApiV1ContractCancelall(this.extend(a,t)))}const c=this.safeDict(o,"data");return this.parseCancelOrders(c)}}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={timeout:e>0?this.parseToInt(e/1e3):0};return await this.v2PrivatePostAlgoOrdersCancelAllAfter(this.extend(s,t))}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a=this.safeCurrencyCode(r,t),o=this.safeString(e,"note"),n=this.safeString(e,"chain");return this.checkAddress(s),{currency:a,address:s,tag:i,network:this.networkIdToCode(n),note:o,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.spotPrivateGetV2AccountDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.parseDepositAddresses(a,[s.code],!1);return this.indexBy(o,"network")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),[i,r]=this.handleNetworkCodeAndParams(t),a=await this.fetchDepositAddressesByNetwork(e,r);return a[this.selectNetworkCodeFromUnifiedNetworks(s.code,i,a)]}async fetchWithdrawAddresses(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.currency(e),a={currency:r.id},o=await this.spotPrivateGetV2AccountWithdrawAddress(this.extend(a,i)),n=this.safeValue(o,"data",[]),d=this.parseDepositAddresses(n,[r.code],!1),h=[];for(let e=0;e<d.length;e++){const i=d[e],r=void 0===t||i.note===t,a=void 0===s||i.network===s;r&&a&&h.push(i)}return h}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;(void 0===s||s>100)&&(s=100),await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={type:"deposit",direct:"next",from:0};void 0!==r&&(a.currency=r.id),void 0!==s&&(a.size=s);const o=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(a,i));return this.parseTransactions(o.data,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;(void 0===s||s>100)&&(s=100),await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={type:"withdraw",direct:"next",from:0};void 0!==r&&(a.currency=r.id),void 0!==s&&(a.size=s);const o=await this.spotPrivateGetV1QueryDepositWithdraw(this.extend(a,i));return this.parseTransactions(o.data,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let r=this.safeString(e,"type");"withdraw"===r&&(r="withdrawal");let o=this.safeString(e,"fee");void 0!==o&&(o=a.Y.stringAbs(o));const n=this.safeString(e,"chain");let d=this.safeString(e,"tx-hash");"ETH"===n&&d.indexOf("0x")<0&&(d="0x"+d);const h="FAST"===this.safeString(e,"sub-type");return{info:e,id:this.safeString2(e,"id","data"),txid:d,timestamp:s,datetime:this.iso8601(s),network:this.networkIdToCode(n),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:r,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),comment:void 0,internal:h,fee:{currency:i,cost:this.parseNumber(o),rate:void 0}}}parseTransactionStatus(e){return this.safeString({unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"},e,e)}async withdraw(e,t,s,i=void 0,o={}){[i,o]=this.handleWithdrawTagAndParams(i,o),await this.loadMarkets(),this.checkAddress(s);const n=this.currency(e),d={address:s,currency:n.id.toLowerCase()};let h;void 0!==i&&(d["addr-tag"]=i),[h,o]=this.handleNetworkCodeAndParams(o),void 0!==h&&(d.chain=this.networkCodeToId(h,e)),t=parseFloat(this.currencyToPrecision(e,t,h));const c=this.safeValue(this.options,"withdraw",{});if(this.safeBool(c,"includeFee",!1)){let s=this.safeNumber(o,"fee");if(void 0===s){const e=await this.fetchCurrencies();this.currencies=this.deepExtend(this.currencies,e);const t=this.safeValue(n.networks,h,{});if(s=this.safeNumber(t,"fee"),void 0===s)throw new r.ArgumentsRequired(this.id+' withdraw() function can not find withdraw fee for chosen network. You need to re-load markets with "exchange.loadMarkets(true)", or provide the "fee" parameter')}const i=this.currencyToPrecision(e,s,h);o=this.omit(o,"fee");const c=this.numberToString(t),l=a.Y.stringSub(c,i),u=parseFloat(l);d.fee=parseFloat(i),t=parseFloat(this.currencyToPrecision(e,u,h))}d.amount=t;const l=await this.spotPrivatePostV1DwWithdrawApiCreate(this.extend(d,o));return this.parseTransaction(l,n)}parseTransfer(e,t=void 0){return{info:e,id:this.safeString(e,"data"),timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n={currency:o.id,amount:parseFloat(this.currencyToPrecision(e,t))};let d;[d,a]=this.handleSubTypeAndParams("transfer",void 0,a);let h=this.convertTypeToAccount(s),c=this.convertTypeToAccount(i);const l="cross"===c,u="cross"===h,p=this.inArray(c,this.ids),f=this.inArray(h,this.ids),m="pro"===h,g="pro"===c;if(m&&g)throw new r.BadRequest(this.id+" transfer () cannot make a transfer between "+s+" and "+i);let v;if("futures"===h||"futures"===c){let e=h+"-to-"+c;e=this.safeString(a,"type",e),n.type=e,v=await this.spotPrivatePostV1FuturesTransfer(this.extend(n,a))}else if(m&&l)v=await this.privatePostCrossMarginTransferIn(this.extend(n,a));else if(u&&g)v=await this.privatePostCrossMarginTransferOut(this.extend(n,a));else if(m&&p)n.symbol=c,v=await this.privatePostDwTransferInMargin(this.extend(n,a));else if(f&&g)n.symbol=h,v=await this.privatePostDwTransferOutMargin(this.extend(n,a));else{if("linear"===d){"swap"===h||"linear-swap"===s?h="linear-swap":c="linear-swap";let e=this.safeString(a,"symbol");a=this.omit(a,"symbol"),void 0!==e?(e=this.marketId(e),n["margin-account"]=e):n["margin-account"]="USDT"}n.from=m?"spot":h,n.to=g?"spot":c,v=await this.v2PrivatePostAccountTransfer(this.extend(n,a))}return this.parseTransfer(v,o)}async fetchIsolatedBorrowRates(e={}){await this.loadMarkets();const t=await this.spotPrivateGetV1MarginLoanInfo(e),s=this.safeValue(t,"data",[]);return this.parseIsolatedBorrowRates(s)}parseIsolatedBorrowRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeValue(e,"currencies",[]),a=this.safeValue(r,0),o=this.safeValue(r,1),n=this.safeString(a,"currency"),d=this.safeString(o,"currency");return{symbol:i,base:this.safeCurrencyCode(n),baseRate:this.safeNumber(a,"actual-rate"),quote:this.safeCurrencyCode(d),quoteRate:this.safeNumber(o,"actual-rate"),period:864e5,timestamp:void 0,datetime:void 0,info:e}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallCursor("fetchFundingRateHistory",e,t,s,i,"page_index","current_page",1,50);await this.loadMarkets();const o=this.market(e),n={contract_code:o.id};let d;if(o.inverse)d=await this.contractPublicGetSwapApiV1SwapHistoricalFundingRate(this.extend(n,i));else{if(!o.linear)throw new r.NotSupported(this.id+" fetchFundingRateHistory() supports inverse and linear swaps only");d=await this.contractPublicGetLinearSwapApiV1SwapHistoricalFundingRate(this.extend(n,i))}const h=this.safeValue(d,"data"),c=this.safeValue(h,"current_page"),l=this.safeValue(h,"data",[]),u=[];for(let e=0;e<l.length;e++){const t=l[e];t.current_page=c;const s=this.safeString(t,"contract_code"),i=this.safeSymbol(s),r=this.safeInteger(t,"funding_time");u.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"funding_rate"),timestamp:r,datetime:this.iso8601(r)})}const p=this.sortBy(u,"timestamp");return this.filterBySymbolSinceLimit(p,o.symbol,t,s)}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"estimated_rate"),i=this.safeInteger(e,"funding_time"),r=this.safeInteger(e,"next_funding_time"),a=this.safeString(e,"contract_code");return{info:e,symbol:this.safeSymbol(a,t),markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:s,nextFundingTimestamp:r,nextFundingDatetime:this.iso8601(r),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={contract_code:s.id};let a;if(s.inverse)a=await this.contractPublicGetSwapApiV1SwapFundingRate(this.extend(i,t));else{if(!s.linear)throw new r.NotSupported(this.id+" fetchFundingRate() supports inverse and linear swaps only");a=await this.contractPublicGetLinearSwapApiV1SwapFundingRate(this.extend(i,t))}const o=this.safeValue(a,"data",{});return this.parseFundingRate(o,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.safeValue(this.options,"fetchFundingRates",{}),i=this.safeString(this.options,"defaultSubType","inverse");let a=this.safeString(s,"subType",i);a=this.safeString(t,"subType",a);const o={};let n;if(t=this.omit(t,"subType"),"linear"===a)n=await this.contractPublicGetLinearSwapApiV1SwapBatchFundingRate(this.extend(o,t));else{if("inverse"!==a)throw new r.NotSupported(this.id+" fetchFundingRates() not support this market type");n=await this.contractPublicGetSwapApiV1SwapBatchFundingRate(this.extend(o,t))}const d=this.safeValue(n,"data",[]),h=this.parseFundingRates(d);return this.filterByArray(h,"symbol",e)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),[a,r]=this.handleMarginModeAndParams("fetchBorrowInterest",r),a=void 0===a?"cross":a;const o={};let n,d;if(void 0!==s&&(o["start-date"]=this.yyyymmdd(s)),void 0!==i&&(o.size=i),"isolated"===a)void 0!==t&&(n=this.market(t),o.symbol=n.id),d=await this.privateGetMarginLoanOrders(this.extend(o,r));else{if(void 0!==e){const t=this.currency(e);o.currency=t.id}d=await this.privateGetCrossMarginLoanOrders(this.extend(o,r))}const h=this.safeValue(d,"data"),c=this.parseBorrowInterests(h,n);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=void 0===s?"cross":"isolated";t=this.safeMarket(s);const r=this.safeString(t,"symbol"),a=this.safeInteger(e,"accrued-at");return{account:"isolated"===i?r:"cross",symbol:r,marginMode:i,currency:this.safeCurrencyCode(this.safeString(e,"currency")),interest:this.safeNumber(e,"interest-amount"),interestRate:this.safeNumber(e,"interest-rate"),amountBorrowed:this.safeNumber(e,"loan-amount"),timestamp:a,datetime:this.iso8601(a),info:e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/";const d=this.omit(i,this.extractParams(e));if("string"==typeof t){if("public"===t||"private"===t?o+=this.version:"v2Public"!==t&&"v2Private"!==t||(o+="v2"),o+="/"+this.implodeParams(e,i),"private"===t||"v2Private"===t){this.checkRequiredCredentials();const e=this.ymdhms(this.milliseconds(),"T");let t={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:e};"POST"!==s&&(t=this.extend(t,d));const i=this.keysort(t);let h=this.urlencode(i);const c=[s,this.hostname,o,h].join("\n"),l=this.hmac(this.encode(c),this.encode(this.secret),n.s,"base64");h+="&"+this.urlencode({Signature:l}),o+="?"+h,"POST"===s?(a=this.json(d),r={"Content-Type":"application/json"}):r={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(d).length&&(o+="?"+this.urlencode(d));o=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+o}else{const h=this.safeString(t,0),c=this.safeString(t,1),l=this.safeString(t,2),u=this.safeString(t,3);let p,f=this.safeValue(this.urls.hostnames,h);if("string"!=typeof f&&(f=this.safeValue(f,l),"string"!=typeof f&&void 0!==u&&(f=this.safeValue(f,u))),p=f,o+=this.implodeParams(e,i),"public"===c)Object.keys(d).length&&(o+="?"+this.urlencode(d));else if("private"===c){if(this.checkRequiredCredentials(),"POST"===s){const t=this.safeValue(this.options,"broker",{}),s=this.safeString(t,"id","AA03022abc");if(-1===e.indexOf("cancel")&&e.endsWith("order")){void 0===this.safeString(i,"channel_code")&&(i.channel_code=s)}else if(e.endsWith("orders/place")){void 0===this.safeString(i,"client-order-id")&&(i["client-order-id"]=s+this.uuid())}}const t=this.ymdhms(this.milliseconds(),"T");let h={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:t};"POST"!==s&&(h=this.extend(h,d)),h=this.keysort(h);let c=this.urlencode(h);const l=[s,p,o,c].join("\n"),u=this.hmac(this.encode(l),this.encode(this.secret),n.s,"base64");c+="&"+this.urlencode({Signature:u}),o+="?"+c,"POST"===s?(2===(a=this.json(d)).length&&(a="{}"),r={"Content-Type":"application/json"}):r={"Content-Type":"application/x-www-form-urlencoded"}}o=this.implodeParams(this.urls.api[h],{hostname:p})+o}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n){if("status"in n){if("error"===this.safeString(n,"status")){const e=this.safeString2(n,"err-code","err_code"),t=this.id+" "+o;this.throwBroadlyMatchedException(this.exceptions.broad,o,t),this.throwExactlyMatchedException(this.exceptions.exact,e,t);const s=this.safeString2(n,"err-msg","err_msg");throw this.throwExactlyMatchedException(this.exceptions.exact,s,t),new r.ExchangeError(t)}}if("code"in n){const e=this.id+" "+o,t=this.safeString(n,"code");this.throwExactlyMatchedException(this.exceptions.exact,t,e)}}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),[a,o]=this.handleMarketTypeAndParams("fetchFundingHistory",r,i),n={type:"30,31"};let d;if(void 0!==t&&(n.start_date=t),"swap"===a)if(n.contract=r.id,r.linear){let e;[e,i]=this.handleMarginModeAndParams("fetchFundingHistory",i),e=void 0===e?"cross":e,n.mar_acct="isolated"===e?r.id:r.quoteId,d=await this.contractPrivatePostLinearSwapApiV3SwapFinancialRecordExact(this.extend(n,o))}else d=await this.contractPrivatePostSwapApiV3SwapFinancialRecordExact(this.extend(n,o));else n.symbol=r.id,d=await this.contractPrivatePostApiV3ContractFinancialRecordExact(this.extend(n,o));const h=this.safeList(d,"data",[]);return this.parseIncomes(h,r,t,s)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),[a,o]=this.handleMarketTypeAndParams("setLeverage",i,s),n={lever_rate:e};let d;if("future"===a&&i.inverse?n.symbol=i.settleId:n.contract_code=i.id,i.linear){let e;if([e,s]=this.handleMarginModeAndParams("setLeverage",s),e=void 0===e?"cross":e,"isolated"===e)d=await this.contractPrivatePostLinearSwapApiV1SwapSwitchLeverRate(this.extend(n,o));else{if("cross"!==e)throw new r.NotSupported(this.id+" setLeverage() not support this market type");d=await this.contractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate(this.extend(n,o))}}else if("future"===a)d=await this.contractPrivatePostApiV1ContractSwitchLeverRate(this.extend(n,o));else{if("swap"!==a)throw new r.NotSupported(this.id+" setLeverage() not support this market type");d=await this.contractPrivatePostSwapApiV1SwapSwitchLeverRate(this.extend(n,o))}return d}parseIncome(e,t=void 0){const s=this.safeString(e,"contract_code"),i=this.safeSymbol(s,t),r=this.safeNumber(e,"amount"),a=this.safeInteger(e,"ts"),o=this.safeString(e,"id"),n=this.safeString2(e,"symbol","asset");return{info:e,symbol:i,code:this.safeCurrencyCode(n),timestamp:a,datetime:this.iso8601(a),id:o,amount:r}}parsePosition(e,t=void 0){const s=(t=this.safeMarket(this.safeString(e,"contract_code"))).symbol,i=this.safeString(e,"volume"),r=this.safeValue(t,"contractSize"),o=this.numberToString(r),n=this.safeNumber(e,"cost_open"),d=this.safeString(e,"position_margin"),h="buy"===this.safeString(e,"direction")?"long":"short",c=this.safeNumber(e,"profit_unreal");let l=this.safeString(e,"margin_mode");const u=this.safeString(e,"lever_rate"),p=a.Y.stringMul(this.safeString(e,"profit_rate"),"100"),f=this.safeString(e,"last_price"),m=a.Y.stringMul(i,o);let g;t.linear?g=a.Y.stringMul(m,f):(g=a.Y.stringDiv(m,f),l="cross");const v=a.Y.stringDiv(d,g),y=this.safeString(e,"margin_balance"),w=this.safeNumber(e,"liquidation_price"),b=this.safeString(e,"adjust_factor"),S=a.Y.stringDiv(b,u),k=a.Y.stringMul(S,g),O=a.Y.stringDiv(k,y);return this.safePosition({info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:r,entryPrice:n,collateral:this.parseNumber(y),side:h,unrealizedProfit:c,leverage:this.parseNumber(u),percentage:this.parseNumber(p),marginMode:l,notional:this.parseNumber(g),markPrice:void 0,lastPrice:void 0,liquidationPrice:w,initialMargin:this.parseNumber(d),initialMarginPercentage:this.parseNumber(v),maintenanceMargin:this.parseNumber(k),maintenanceMarginPercentage:this.parseNumber(S),marginRatio:this.parseNumber(O),timestamp:void 0,datetime:void 0,hedged:void 0,lastUpdateTimestamp:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchPositions(e=void 0,t={}){let s,i,a,o,n;if(await this.loadMarkets(),void 0!==(e=this.marketSymbols(e))){if(e.length>0){const t=this.safeString(e,0);s=this.market(t)}}if([i,t]=this.handleMarginModeAndParams("fetchPositions",t,"cross"),[a,t]=this.handleSubTypeAndParams("fetchPositions",s,t,"linear"),[o,t]=this.handleMarketTypeAndParams("fetchPositions",s,t),"spot"===o&&(o="future"),"linear"===a)if("isolated"===i)n=await this.contractPrivatePostLinearSwapApiV1SwapPositionInfo(t);else{if("cross"!==i)throw new r.NotSupported(this.id+" fetchPositions() not support this market type");n=await this.contractPrivatePostLinearSwapApiV1SwapCrossPositionInfo(t)}else if("future"===o)n=await this.contractPrivatePostApiV1ContractPositionInfo(t);else{if("swap"!==o)throw new r.NotSupported(this.id+" fetchPositions() not support this market type");n=await this.contractPrivatePostSwapApiV1SwapPositionInfo(t)}const d=this.safeValue(n,"data",[]),h=this.safeInteger(n,"ts"),c=[];for(let e=0;e<d.length;e++){const t=d[e],s=this.parsePosition(t);c.push(this.extend(s,{timestamp:h,datetime:this.iso8601(h)}))}return this.filterByArrayPositions(c,"symbol",e,!1)}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e);let i;[i,t]=this.handleMarginModeAndParams("fetchPosition",t),i=void 0===i?"cross":i;const[a,o]=this.handleMarketTypeAndParams("fetchPosition",s,t),n={};let d;if(s.future&&s.inverse?n.symbol=s.settleId:("cross"===i&&(n.margin_account="USDT"),n.contract_code=s.id),s.linear)if("isolated"===i)d=await this.contractPrivatePostLinearSwapApiV1SwapAccountPositionInfo(this.extend(n,o));else{if("cross"!==i)throw new r.NotSupported(this.id+" fetchPosition() not support this market type");d=await this.contractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo(this.extend(n,o))}else if("future"===a)d=await this.contractPrivatePostApiV1ContractAccountPositionInfo(this.extend(n,o));else{if("swap"!==a)throw new r.NotSupported(this.id+" setLeverage() not support this market type");d=await this.contractPrivatePostSwapApiV1SwapAccountPositionInfo(this.extend(n,o))}const h=this.safeValue(d,"data");let c;c="cross"===i?h:this.safeValue(h,0);const l=this.omit(c,["positions"]),u=this.safeValue(c,"positions");let p;if(s.future&&s.inverse)for(let e=0;e<u.length;e++){const t=u[e];if(t.contract_code===s.id){p=t;break}}else p=this.safeValue(u,0);const f=this.safeInteger(d,"ts"),m=this.parsePosition(this.extend(p,l));return m.timestamp=f,m.datetime=this.iso8601(f),m}parseLedgerEntryType(e){return this.safeString({trade:"trade",etf:"trade","transact-fee":"fee","fee-deduction":"fee",transfer:"transfer",credit:"credit",liquidation:"trade",interest:"credit",deposit:"deposit",withdraw:"withdrawal","withdraw-fee":"fee",exchange:"exchange","other-types":"transfer",rebate:"rebate"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"transactId"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i,t),a=this.safeNumber(e,"transactAmt"),o=this.safeString(e,"transferType"),n=this.parseLedgerEntryType(o),d=this.safeString(e,"direction"),h=this.safeInteger(e,"transactTime"),c=this.iso8601(h),l=this.safeString(e,"accountId");return{id:s,direction:d,account:l,referenceId:s,referenceAccount:l,type:n,currency:r,amount:a,timestamp:h,datetime:c,before:void 0,after:void 0,status:void 0,fee:void 0,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i,500);let a,o={accountId:await this.fetchAccountIdByType("spot",void 0,void 0,i)};void 0!==e&&(a=this.currency(e),o.currency=a.id),void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.spotPrivateGetV2AccountLedger(this.extend(o,i)),d=this.safeValue(n,"data",[]);return this.parseLedger(d,a,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(t),i=this.safeList(s,"data");return this.parseLeverageTiers(i,e,"contract_code")}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=this.market(e);if(!t.contract)throw new r.BadRequest(this.id+" fetchMarketLeverageTiers() symbol supports contract markets only");s.contract_code=t.id}const i=await this.contractPublicGetLinearSwapApiV1SwapAdjustfactor(this.extend(s,t)),a=this.safeValue(i,"data"),o=this.parseLeverageTiers(a,[e],"contract_code");return this.safeValue(o,e)}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let r=0;r<e.length;r++){const o=e[r],n=this.safeValue(o,"list",[]),d=[],h=this.safeString(o,"trade_partition"),c=this.safeString(o,s),l=this.safeSymbol(c);if(this.inArray(l,t)){for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"lever_rate"),i=this.safeValue(t,"ladders",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"adjust_factor");d.push({tier:this.safeInteger(t,"ladder"),currency:this.safeCurrencyCode(h),minNotional:this.safeNumber(t,"min_size"),maxNotional:this.safeNumber(t,"max_size"),maintenanceMarginRate:this.parseNumber(a.Y.stringDiv(r,s)),maxLeverage:this.parseNumber(s),info:t})}}i[l]=d}}return i}async fetchOpenInterestHistory(e,t="1h",s=void 0,i=void 0,a={}){if("1h"!==t&&"4h"!==t&&"12h"!==t&&"1d"!==t)throw new r.BadRequest(this.id+" fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe");await this.loadMarkets();const o=this.market(e),n=this.safeInteger2(a,"amount_type","amountType",2),d={period:{"1h":"60min","4h":"4hour","12h":"12hour","1d":"1day"}[t],amount_type:n};let h;void 0!==i&&(d.size=i),o.future?(d.contract_type=this.safeString(o.info,"contract_type"),d.symbol=o.baseId,h=await this.contractPublicGetApiV1ContractHisOpenInterest(this.extend(d,a))):o.linear?(d.contract_type="swap",d.contract_code=o.id,d.contract_code=o.id,h=await this.contractPublicGetLinearSwapApiV1SwapHisOpenInterest(this.extend(d,a))):(d.contract_code=o.id,h=await this.contractPublicGetSwapApiV1SwapHisOpenInterest(this.extend(d,a)));const c=this.safeValue(h,"data"),l=this.safeList(c,"tick");return this.parseOpenInterests(l,o,s,i)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");if(s.option)throw new r.NotSupported(this.id+" fetchOpenInterest() does not currently support option markets");const i={contract_code:s.id};let a;s.future?(i.contract_type=this.safeString(s.info,"contract_type"),i.symbol=s.baseId,a=await this.contractPublicGetApiV1ContractOpenInterest(this.extend(i,t))):s.linear?(i.contract_type="swap",a=await this.contractPublicGetLinearSwapApiV1SwapOpenInterest(this.extend(i,t))):a=await this.contractPublicGetSwapApiV1SwapOpenInterest(this.extend(i,t));const o=this.safeValue(a,"data",[]),n=this.parseOpenInterest(o[0],s),d=this.safeInteger(a,"ts");return n.timestamp=d,n.datetime=this.iso8601(d),n}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeNumber(e,"volume"),r=this.safeNumber(e,"value");return this.safeOpenInterest({symbol:this.safeString(t,"symbol"),baseVolume:i,quoteVolume:r,openInterestAmount:i,openInterestValue:r,timestamp:s,datetime:this.iso8601(s),info:e},t)}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=this.market(e),o={currency:r.id,amount:this.currencyToPrecision(t,s),symbol:a.id},n=await this.privatePostMarginOrders(this.extend(o,i)),d=this.parseMarginLoan(n,r);return this.extend(d,{amount:s,symbol:e})}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={currency:i.id,amount:this.currencyToPrecision(e,t)},a=await this.privatePostCrossMarginOrders(this.extend(r,s)),o=this.parseMarginLoan(a,i);return this.extend(o,{amount:t})}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.currency(t),a=await this.fetchAccountIdByType("spot","isolated",e,i),o={currency:r.id,amount:this.currencyToPrecision(t,s),accountId:a},n=await this.v2PrivatePostAccountRepayment(this.extend(o,i)),d=this.safeValue(n,"Data",[]),h=this.safeValue(d,0),c=this.parseMarginLoan(h,r);return this.extend(c,{amount:s,symbol:e})}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r=await this.fetchAccountIdByType("spot","cross",void 0,s),a={currency:i.id,amount:this.currencyToPrecision(e,t),accountId:r},o=await this.v2PrivatePostAccountRepayment(this.extend(a,s)),n=this.safeValue(o,"Data",[]),d=this.safeValue(n,0),h=this.parseMarginLoan(d,i);return this.extend(h,{amount:t})}parseMarginLoan(e,t=void 0){const s=this.safeInteger(e,"repayTime");return{id:this.safeString2(e,"repayId","data"),currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchSettlementHistory() requires a symbol argument");const a=this.safeInteger(i,"until");i=this.omit(i,["until"]);const o=this.market(e),n={};let d;o.future?n.symbol=o.baseId:n.contract_code=o.id,void 0!==t&&(n.start_at=t),void 0!==s&&(n.page_size=s),void 0!==a&&(n.end_at=a),d=o.swap?o.linear?await this.contractPublicGetLinearSwapApiV1SwapSettlementRecords(this.extend(n,i)):await this.contractPublicGetSwapApiV1SwapSettlementRecords(this.extend(n,i)):await this.contractPublicGetApiV1ContractSettlementRecords(this.extend(n,i));const h=this.safeValue(d,"data"),c=this.safeValue(h,"settlement_record"),l=this.parseSettlements(c,o);return this.sortBy(l,"timestamp")}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPublicGetV2ReferenceCurrencies(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e,"currency")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"chains",[]);let i=this.depositWithdrawFee(e);for(let e=0;e<s.length;e++){const r=s[e],a=this.safeString(r,"chain"),o=this.safeString(r,"withdrawFeeType"),n=this.networkIdToCode(a);let d,h;"fixed"===o?(d=this.safeNumber(r,"transactFeeWithdraw"),h={fee:d,percentage:!1}):(d=this.safeNumber(r,"transactFeeRateWithdraw"),h={fee:d,percentage:!0}),i.networks[n]={withdraw:h,deposit:{fee:void 0,percentage:void 0}},i=this.assignDefaultDepositWithdrawFees(i,t)}return i}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeValue(r,"list");if(void 0!==a){const e=this.safeInteger(r,"settlement_time"),i={timestamp:e,datetime:this.iso8601(e)};for(let e=0;e<a.length;e++){const r=a[e],o=this.parseSettlement(r,t);s.push(this.extend(o,i))}}else s.push(this.parseSettlement(e[i],t))}return s}parseSettlement(e,t){const s=this.safeInteger(e,"settlement_time"),i=this.safeString(e,"contract_code");return{info:e,symbol:this.safeSymbol(i,t),price:this.safeNumber(e,"settlement_price"),timestamp:s,datetime:this.iso8601(s)}}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e);let o,n={trade_type:this.safeInteger(i,"trade_type",0)};if(void 0!==t&&(n.start_time=t),[n,i]=this.handleUntilOption("end_time",n,i),a.swap)n.contract=a.id,o=a.linear?await this.contractPublicGetLinearSwapApiV3SwapLiquidationOrders(this.extend(n,i)):await this.contractPublicGetSwapApiV3SwapLiquidationOrders(this.extend(n,i));else{if(!a.future)throw new r.NotSupported(this.id+" fetchLiquidations() does not support "+a.type+" orders");n.symbol=a.id,o=await this.contractPublicGetApiV3ContractLiquidationOrders(this.extend(n,i))}const d=this.safeList(o,"data",[]);return this.parseLiquidations(d,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeString(e,"contract_code"),i=this.safeInteger(e,"created_at");return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.safeNumber(e,"volume"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"price"),baseValue:this.safeNumber(e,"amount"),quoteValue:this.safeNumber(e,"trade_turnover"),timestamp:i,datetime:this.iso8601(i)})}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),a=this.safeString(s,"clientOrderId");if(!i.contract)throw new r.BadRequest(this.id+" closePosition() symbol supports contract markets only");this.checkRequiredArgument("closePosition",t,"side");const o={contract_code:i.id,direction:t};if(void 0!==a&&(o.client_order_id=a),i.inverse){const t=this.safeString2(s,"volume","amount");if(void 0===t)throw new r.ArgumentsRequired(this.id+' closePosition () requires an extra argument params["amount"] for inverse markets');o.volume=this.amountToPrecision(e,t)}let n;if(s=this.omit(s,["clientOrderId","volume","amount"]),i.inverse)n=i.swap?await this.contractPrivatePostSwapApiV1SwapLightningClosePosition(this.extend(o,s)):await this.contractPrivatePostApiV1LightningClosePosition(this.extend(o,s));else{let e;[e,s]=this.handleMarginModeAndParams("closePosition",s,"cross"),n="cross"===e?await this.contractPrivatePostLinearSwapApiV1SwapCrossLightningClosePosition(this.extend(o,s)):await this.contractPrivatePostLinearSwapApiV1SwapLightningClosePosition(this.extend(o,s))}return this.parseOrder(n,i)}async setPositionMode(e,t=void 0,s={}){await this.loadMarkets();const i=e?"dual_side":"single_side";let a,o;void 0!==t&&(a=this.market(t)),[o,s]=this.handleMarginModeAndParams("setPositionMode",s,"cross");const n={position_mode:i};let d;if(void 0!==a&&a.inverse)throw new r.BadRequest(this.id+" setPositionMode can only be used for linear markets");if("isolated"===o){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setPositionMode requires a symbol argument for isolated margin mode");n.margin_account=a.id,d=await this.contractPrivatePostLinearSwapApiV1SwapSwitchPositionMode(this.extend(n,s))}else n.margin_account="USDT",d=await this.contractPrivatePostLinearSwapApiV1SwapCrossSwitchPositionMode(this.extend(n,s));return d}}},63:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(9946);class r extends i.A{describe(){return this.deepExtend(super.describe(),{id:"huobi",alias:!0})}}},1325:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(2394),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"huobijp",name:"Huobi Japan",countries:["JP"],rateLimit:100,userAgent:this.userAgents.chrome39,certified:!1,version:"v1",hostname:"api-cloud.bittrade.co.jp",pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingLimits:!0,fetchWithdrawals:!0,withdraw:!0},timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","4h":"4hour","1d":"1day","1w":"1week","1M":"1mon","1y":"1year"},urls:{logo:"https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg",api:{market:"https://{hostname}",public:"https://{hostname}",private:"https://{hostname}",v2Public:"https://{hostname}",v2Private:"https://{hostname}"},www:"https://www.huobi.co.jp",referral:"https://www.huobi.co.jp/register/?invite_code=znnq3",doc:"https://api-doc.huobi.co.jp",fees:"https://www.huobi.co.jp/support/fee"},api:{v2Public:{get:{"reference/currencies":1,"market-status":1}},v2Private:{get:{"account/ledger":1,"account/withdraw/quota":1,"account/withdraw/address":1,"account/deposit/address":1,"account/repayment":5,"reference/transact-fee-rate":1,"account/asset-valuation":.2,"point/account":5,"sub-user/user-list":1,"sub-user/user-state":1,"sub-user/account-list":1,"sub-user/deposit-address":1,"sub-user/query-deposit":1,"user/api-key":1,"user/uid":1,"algo-orders/opening":1,"algo-orders/history":1,"algo-orders/specific":1,"c2c/offers":1,"c2c/offer":1,"c2c/transactions":1,"c2c/repayment":1,"c2c/account":1,"etp/reference":1,"etp/transactions":5,"etp/transaction":5,"etp/rebalance":1,"etp/limit":1},post:{"account/transfer":1,"account/repayment":5,"point/transfer":5,"sub-user/management":1,"sub-user/creation":1,"sub-user/tradable-market":1,"sub-user/transferability":1,"sub-user/api-key-generation":1,"sub-user/api-key-modification":1,"sub-user/api-key-deletion":1,"sub-user/deduct-mode":1,"algo-orders":1,"algo-orders/cancel-all-after":1,"algo-orders/cancellation":1,"c2c/offer":1,"c2c/cancellation":1,"c2c/cancel-all":1,"c2c/repayment":1,"c2c/transfer":1,"etp/creation":5,"etp/redemption":5,"etp/{transactId}/cancel":10,"etp/batch-cancel":50}},market:{get:{"history/kline":1,"detail/merged":1,depth:1,trade:1,"history/trade":1,detail:1,tickers:1,etp:1}},public:{get:{"common/symbols":1,"common/currencys":1,"common/timestamp":1,"common/exchange":1,"settings/currencys":1}},private:{get:{"account/accounts":.2,"account/accounts/{id}/balance":.2,"account/accounts/{sub-uid}":1,"account/history":4,"cross-margin/loan-info":1,"margin/loan-info":1,"fee/fee-rate/get":1,"order/openOrders":.4,"order/orders":.4,"order/orders/{id}":.4,"order/orders/{id}/matchresults":.4,"order/orders/getClientOrder":.4,"order/history":1,"order/matchresults":1,"query/deposit-withdraw":1,"margin/loan-orders":.2,"margin/accounts/balance":.2,"cross-margin/loan-orders":1,"cross-margin/accounts/balance":1,"points/actions":1,"points/orders":1,"subuser/aggregate-balance":10,"stable-coin/exchange_rate":1,"stable-coin/quote":1},post:{"account/transfer":1,"futures/transfer":1,"order/batch-orders":.4,"order/orders/place":.2,"order/orders/submitCancelClientOrder":.2,"order/orders/batchCancelOpenOrders":.4,"order/orders/{id}/submitcancel":.2,"order/orders/batchcancel":.4,"dw/withdraw/api/create":1,"dw/withdraw-virtual/{id}/cancel":1,"dw/transfer-in/margin":10,"dw/transfer-out/margin":10,"margin/orders":10,"margin/orders/{id}/repay":10,"cross-margin/transfer-in":1,"cross-margin/transfer-out":1,"cross-margin/orders":1,"cross-margin/orders/{id}/repay":1,"stable-coin/exchange":1,"subuser/transfer":10}}},fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},precisionMode:o.kb,exceptions:{broad:{"contract is restricted of closing positions on API.  Please contact customer service":r.OnMaintenance,maintain:r.OnMaintenance},exact:{"bad-request":r.BadRequest,"base-date-limit-error":r.BadRequest,"api-not-support-temp-addr":r.PermissionDenied,timeout:r.RequestTimeout,"gateway-internal-error":r.ExchangeNotAvailable,"account-frozen-balance-insufficient-error":r.InsufficientFunds,"invalid-amount":r.InvalidOrder,"order-limitorder-amount-min-error":r.InvalidOrder,"order-limitorder-amount-max-error":r.InvalidOrder,"order-marketorder-amount-min-error":r.InvalidOrder,"order-limitorder-price-min-error":r.InvalidOrder,"order-limitorder-price-max-error":r.InvalidOrder,"order-holding-limit-failed":r.InvalidOrder,"order-orderprice-precision-error":r.InvalidOrder,"order-etp-nav-price-max-error":r.InvalidOrder,"order-orderstate-error":r.OrderNotFound,"order-queryorder-invalid":r.OrderNotFound,"order-update-error":r.ExchangeNotAvailable,"api-signature-check-failed":r.AuthenticationError,"api-signature-not-valid":r.AuthenticationError,"base-record-invalid":r.OrderNotFound,"base-symbol-trade-disabled":r.BadSymbol,"base-symbol-error":r.BadSymbol,"system-maintenance":r.OnMaintenance,"invalid symbol":r.BadSymbol,"symbol trade not open now":r.BadSymbol,"invalid-address":r.BadRequest,"base-currency-chain-error":r.BadRequest,"dw-insufficient-balance":r.InsufficientFunds}},options:{defaultNetwork:"ERC20",networks:{ETH:"erc20",TRX:"trc20",HRC20:"hrc20",HECO:"hrc20",HT:"hrc20",ALGO:"algo",OMNI:""},fetchOrdersByStatesMethod:"private_get_order_orders",fetchOpenOrdersMethod:"fetch_open_orders_v1",createMarketBuyOrderRequiresPrice:!0,fetchMarketsMethod:"publicGetCommonSymbols",fetchBalanceMethod:"privateGetAccountAccountsIdBalance",createOrderMethod:"privatePostOrderOrdersPlace",language:"en-US",broker:{id:"AA03022abc"}},commonCurrencies:{GET:"Themis",GTC:"Game.com",HIT:"HitChain",PNT:"Penta",SBTC:"Super Bitcoin",BIFI:"Bitcoin File"}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchTradingLimits(e=void 0,t={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const s={};for(let i=0;i<e.length;i++){const r=e[i];s[r]=await this.fetchTradingLimitsById(this.marketId(r),t)}return s}async fetchTradingLimitsById(e,t={}){const s={symbol:e},i=await this.publicGetCommonExchange(this.extend(s,t));return this.parseTradingLimits(this.safeValue(i,"data",{}))}parseTradingLimits(e,t=void 0,s={}){return{info:e,limits:{amount:{min:this.safeNumber(e,"limit-order-must-greater-than"),max:this.safeNumber(e,"limit-order-must-less-than")}}}}costToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.cost,this.precisionMode)}async fetchMarkets(e={}){const t=this.options.fetchMarketsMethod,s=await this[t](e),i=this.safeValue(s,"data",[]);if(i.length<1)throw new r.NetworkError(this.id+" fetchMarkets() returned empty response: "+this.json(i));const o=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"base-currency"),r=this.safeString(t,"quote-currency"),n=this.safeCurrencyCode(s),d=this.safeCurrencyCode(r),h=this.safeString(t,"state"),c=this.safeString(t,"leverage-ratio","1"),l=this.safeString(t,"super-margin-leverage-ratio","1"),u=a.Y.stringGt(c,"1")||a.Y.stringGt(l,"1"),p="OMG"===n?this.parseNumber("0"):this.parseNumber("0.002");o.push({id:s+r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:s,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:u,swap:!1,future:!1,option:!1,active:"online"===h,contract:!1,linear:void 0,inverse:void 0,taker:p,maker:p,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(t,"price-precision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(t,"amount-precision"))),cost:this.parseNumber(this.parsePrecision(this.safeString(t,"value-precision")))},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(c),superMax:this.parseNumber(l)},amount:{min:this.safeNumber(t,"min-order-amt"),max:this.safeNumber(t,"max-order-amt")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"min-order-value"),max:void 0}},created:void 0,info:t})}return o}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeInteger(e,"ts");let r,a,o,n;"bid"in e&&(Array.isArray(e.bid)?(r=this.safeString(e.bid,0),a=this.safeString(e.bid,1)):(r=this.safeString(e,"bid"),a=this.safeString(e,"bidSize"))),"ask"in e&&(Array.isArray(e.ask)?(o=this.safeString(e.ask,0),n=this.safeString(e.ask,1)):(o=this.safeString(e,"ask"),n=this.safeString(e,"askSize")));const d=this.safeString(e,"open"),h=this.safeString(e,"close"),c=this.safeString(e,"amount"),l=this.safeString(e,"vol");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:r,bidVolume:a,ask:o,askVolume:n,vwap:void 0,open:d,close:h,last:h,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:l,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id,type:"step0"},a=await this.marketGetDepth(this.extend(i,s));if("tick"in a){if(!a.tick)throw new r.BadSymbol(this.id+" fetchOrderBook() returned empty response: "+this.json(a));const t=this.safeValue(a,"tick"),s=this.safeInteger(t,"ts",this.safeInteger(a,"ts")),i=this.parseOrderBook(t,e,s);return i.nonce=this.safeInteger(t,"version"),i}throw new r.ExchangeError(this.id+" fetchOrderBook() returned unrecognized response: "+this.json(a))}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.marketGetDetailMerged(this.extend(i,t)),a=this.parseTicker(r.tick,s),o=this.safeInteger(r,"ts");return a.timestamp=o,a.datetime=this.iso8601(o),a}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.marketGetTickers(t),i=this.safeValue(s,"data",[]),r=this.safeInteger(s,"ts"),a={};for(let e=0;e<i.length;e++){const t=this.safeString(i[e],"symbol"),s=this.safeMarket(t),o=s.symbol,n=this.parseTicker(i[e],s);n.timestamp=r,n.datetime=this.iso8601(r),a[o]=n}return this.filterByArrayTickers(a,"symbol",e)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeInteger2(e,"ts","created-at"),o=this.safeString(e,"order-id");let n=this.safeString(e,"direction"),d=this.safeString(e,"type");if(void 0!==d){const e=d.split("-");n=e[0],d=e[1]}const h=this.safeString(e,"role"),c=this.safeString(e,"price"),l=this.safeString2(e,"filled-amount","amount"),u=a.Y.stringMul(c,l);let p,f=this.safeString(e,"filled-fees"),m=this.safeCurrencyCode(this.safeString(e,"fee-currency"));const g=this.safeString(e,"filled-points");void 0!==g&&(void 0===f||a.Y.stringEq(f,"0.0"))&&(f=g,m=this.safeCurrencyCode(this.safeString(e,"fee-deduct-currency"))),void 0!==f&&(p={cost:f,currency:m});const v=this.safeString2(e,"trade-id","tradeId"),y=this.safeString(e,"id",v);return this.safeTrade({info:e,id:y,symbol:i,order:o,timestamp:r,datetime:this.iso8601(r),type:d,side:n,takerOrMaker:h,price:c,amount:l,cost:u,fee:p})}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={id:e},o=await this.privateGetOrderOrdersIdMatchresults(this.extend(a,r));return this.parseTrades(o.data,void 0,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==s&&(a.size=s),void 0!==t&&(a["start-time"]=t);const o=await this.privateGetOrderMatchresults(this.extend(a,i));return this.parseTrades(o.data,r,t,s)}async fetchTrades(e,t=void 0,s=1e3,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.size=Math.min(s,2e3));const o=await this.marketGetHistoryTrade(this.extend(a,i)),n=this.safeValue(o,"data",[]);let d=[];for(let e=0;e<n.length;e++){const t=this.safeValue(n[e],"data",[]);for(let e=0;e<t.length;e++){const s=this.parseTrade(t[e],r);d.push(s)}}return d=this.sortBy(d,"timestamp"),this.filterBySymbolSinceLimit(d,r.symbol,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"id"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"amount")]}async fetchOHLCV(e,t="1m",s=void 0,i=1e3,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,period:this.safeString(this.timeframes,t,t)};void 0!==i&&(o.size=Math.min(i,2e3));const n=await this.marketGetHistoryKline(this.extend(o,r)),d=this.safeList(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}async fetchAccounts(e={}){await this.loadMarkets();return(await this.privateGetAccountAccounts(e)).data}async fetchCurrencies(e={}){const t={language:this.options.language},s=await this.publicGetSettingsCurrencys(this.extend(t,e)),i=this.safeValue(s,"data",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeValue(t,"name"),a=this.safeCurrencyCode(s),o=this.safeValue(t,"deposit-enabled"),n=this.safeValue(t,"withdraw-enabled"),d=this.safeValue(t,"country-disabled"),h=this.safeBool(t,"visible",!1),c=this.safeString(t,"state"),l=h&&o&&n&&"online"===c&&!d,u=this.safeString(t,"display-name"),p=this.parseNumber(this.parsePrecision(this.safeString(t,"withdraw-precision")));r[a]={id:s,code:a,type:"crypto",name:u,active:l,deposit:o,withdraw:n,fee:void 0,precision:p,limits:{amount:{min:p,max:void 0},deposit:{min:this.safeNumber(t,"deposit-min-amount"),max:void 0},withdraw:{min:this.safeNumber(t,"withdraw-min-amount"),max:void 0}},info:t}}return r}parseBalance(e){const t=this.safeValue(e.data,"list",[]),s={info:e};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r);let o;o=a in s?s[a]:this.account(),"trade"===i.type&&(o.free=this.safeString(i,"balance")),"frozen"===i.type&&(o.used=this.safeString(i,"balance")),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets(),await this.loadAccounts();const t=this.options.fetchBalanceMethod,s={id:this.accounts[0].id},i=await this[t](this.extend(s,e));return this.parseBalance(i)}async fetchOrdersByStates(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={states:e};let o;void 0!==t&&(o=this.market(t),a.symbol=o.id);const n=this.safeString(this.options,"fetchOrdersByStatesMethod","private_get_order_orders"),d=await this[n](this.extend(a,r));return this.parseOrders(d.data,o,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrderOrdersId(this.extend(i,s)),a=this.safeDict(r,"data");return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeString(this.options,"fetchOpenOrdersMethod","fetch_open_orders_v1");return await this[r](e,t,s,i)}async fetchOpenOrdersV1(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrdersV1() requires a symbol argument");return await this.fetchOrdersByStates("pre-submitted,submitted,partial-filled",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStates("filled,partial-canceled,canceled",e,t,s,i)}async fetchOpenOrdersV2(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id);let o=this.safeString(i,"account-id");if(void 0===o){await this.loadAccounts();for(let e=0;e<this.accounts.length;e++){const t=this.accounts[e];if("spot"===t.type&&(o=this.safeString(t,"id"),void 0!==o))break}}r["account-id"]=o,void 0!==s&&(r.size=s);const n=this.omit(i,"account-id"),d=await this.privateGetOrderOpenOrders(this.extend(r,n)),h=this.safeList(d,"data",[]);return this.parseOrders(h,a,t,s)}parseOrderStatus(e){return this.safeString({"partial-filled":"open","partial-canceled":"canceled",filled:"closed",canceled:"canceled",submitted:"open"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id");let i,r,a;if("type"in e){const t=e.type.split("-");i=t[0],r=t[1],a=this.parseOrderStatus(this.safeString(e,"state"))}const o=this.safeString(e,"symbol");t=this.safeMarket(o,t);const n=this.safeInteger(e,"created-at"),d=this.safeString(e,"client-order-id"),h=this.safeString(e,"amount"),c=this.safeString2(e,"filled-amount","field-amount"),l=this.safeString(e,"price"),u=this.safeString2(e,"filled-cash-amount","field-cash-amount"),p=this.safeString2(e,"filled-fees","field-fees");let f;if(void 0!==p){f={cost:p,currency:"sell"===i?t.quote:t.base}}return this.safeOrder({info:e,id:s,clientOrderId:d,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,symbol:t.symbol,type:r,timeInForce:void 0,postOnly:void 0,side:i,price:l,stopPrice:void 0,triggerPrice:void 0,average:void 0,cost:u,amount:h,filled:c,remaining:void 0,status:a,fee:f,trades:void 0},t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets(),await this.loadAccounts();const d=this.market(e),h={"account-id":this.accounts[0].id,symbol:d.id,type:s+"-"+t},c=this.safeString2(n,"clientOrderId","client-order-id");if(void 0===c){const e=this.safeValue(this.options,"broker",{}),t=this.safeString(e,"id");h["client-order-id"]=t+this.uuid()}else h["client-order-id"]=c;if(n=this.omit(n,["clientOrderId","client-order-id"]),"market"===t&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.amountToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o);t=this.amountToPrecision(e,a.Y.stringMul(s,r))}}else t=this.amountToPrecision(e,i);h.amount=t}else h.amount=this.amountToPrecision(e,i);"limit"!==t&&"ioc"!==t&&"limit-maker"!==t&&"stop-limit"!==t&&"stop-limit-fok"!==t||(h.price=this.priceToPrecision(e,o));const l=this.options.createOrderMethod,u=await this[l](this.extend(h,n)),p=this.safeString(u,"data");return this.safeOrder({info:u,id:p,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:void 0,symbol:e,type:t,side:s,price:o,amount:i,filled:void 0,remaining:void 0,cost:void 0,trades:void 0,fee:void 0,clientOrderId:void 0,average:void 0},d)}async cancelOrder(e,t=void 0,s={}){const i=await this.privatePostOrderOrdersIdSubmitcancel({id:e});return this.extend(this.parseOrder(i),{id:e,status:"canceled"})}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"clientOrderIds","client-order-ids");s=this.omit(s,["clientOrderIds","client-order-ids"]);const r={};void 0===i?r["order-ids"]=e:r["client-order-ids"]=i;const a=await this.privatePostOrderOrdersBatchcancel(this.extend(r,s));return this.parseCancelOrders(a)}parseCancelOrders(e){const t=this.safeString(e,"successes");let s;s=void 0!==t?t.split(","):this.safeList(e,"success",[]);const i=this.safeList2(e,"errors","failed",[]),r=[];for(let e=0;e<s.length;e++){const t=s[e];r.push(this.safeOrder({info:t,id:t,status:"canceled"}))}for(let e=0;e<i.length;e++){const t=i[e];r.push(this.safeOrder({info:t,id:this.safeString2(t,"order-id","order_id"),status:"failed",clientOrderId:this.safeString(t,"client-order-id")}))}return r}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;void 0!==e&&(i=this.market(e),s.symbol=i.id);const r=await this.privatePostOrderOrdersBatchCancelOpenOrders(this.extend(s,t)),a=this.safeDict(r,"data",{});return[this.safeOrder({info:a})]}currencyToPrecision(e,t,s=void 0){return this.decimalToPrecision(t,0,this.currencies[e].precision,this.precisionMode)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"addressTag"),r=this.safeString(e,"currency");t=this.safeCurrency(r,t);const a=this.safeCurrencyCode(r,t),o=this.safeString(e,"chain"),n=this.safeValue(t,"networks",{}),d=this.indexBy(n,"id"),h=this.safeValue(d,o,o),c=this.safeString(h,"network");return this.checkAddress(s),{currency:a,address:s,tag:i,network:c,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;(void 0===s||s>100)&&(s=100),await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={type:"deposit",from:0};void 0!==r&&(a.currency=r.id),void 0!==s&&(a.size=s);const o=await this.privateGetQueryDepositWithdraw(this.extend(a,i));return this.parseTransactions(o.data,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;(void 0===s||s>100)&&(s=100),await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a={type:"withdraw",from:0};void 0!==r&&(a.currency=r.id),void 0!==s&&(a.size=s);const o=await this.privateGetQueryDepositWithdraw(this.extend(a,i));return this.parseTransactions(o.data,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeInteger(e,"created-at"),i=this.safeCurrencyCode(this.safeString(e,"currency"));let r=this.safeString(e,"type");"withdraw"===r&&(r="withdrawal");let o=this.safeString(e,"fee");return void 0!==o&&(o=a.Y.stringAbs(o)),{info:e,id:this.safeString2(e,"id","data"),txid:this.safeString(e,"tx-hash"),timestamp:s,datetime:this.iso8601(s),network:this.safeStringUpper(e,"chain"),address:this.safeString(e,"address"),addressTo:void 0,addressFrom:void 0,tag:this.safeString(e,"address-tag"),tagTo:void 0,tagFrom:void 0,type:r,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"state")),updated:this.safeInteger(e,"updated-at"),comment:void 0,internal:void 0,fee:{currency:i,cost:this.parseNumber(o),rate:void 0}}}parseTransactionStatus(e){return this.safeString({unknown:"failed",confirming:"pending",confirmed:"ok",safe:"ok",orphan:"failed",submitted:"pending",canceled:"canceled",reexamine:"pending",reject:"failed",pass:"pending","wallet-reject":"failed","confirm-error":"failed",repealed:"failed","wallet-transfer":"pending","pre-transfer":"pending"},e,e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets(),this.checkAddress(s);const a=this.currency(e),o={address:s,amount:t,currency:a.id.toLowerCase()};void 0!==i&&(o["addr-tag"]=i);const n=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeStringLower(n,d,d),void 0!==d&&(o.chain="erc20"===d?a.id+d:d+a.id,r=this.omit(r,"network"));const h=await this.privatePostDwWithdrawApiCreate(this.extend(o,r));return this.parseTransaction(h,a)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/";"market"===t?o+=t:"public"===t||"private"===t?o+=this.version:"v2Public"!==t&&"v2Private"!==t||(o+="v2"),o+="/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if("private"===t||"v2Private"===t){this.checkRequiredCredentials();const e=this.ymdhms(this.milliseconds(),"T");let t={SignatureMethod:"HmacSHA256",SignatureVersion:"2",AccessKeyId:this.apiKey,Timestamp:e};"POST"!==s&&(t=this.extend(t,d));const i=this.keysort(t);let h=this.urlencode(i);const c=[s,this.hostname,o,h].join("\n"),l=this.hmac(this.encode(c),this.encode(this.secret),n.s,"base64");h+="&"+this.urlencode({Signature:l}),o+="?"+h,"POST"===s?(a=this.json(d),r={"Content-Type":"application/json"}):r={"Content-Type":"application/x-www-form-urlencoded"}}else Object.keys(i).length&&(o+="?"+this.urlencode(i));return o=this.implodeParams(this.urls.api[t],{hostname:this.hostname})+o,{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&"status"in n){if("error"===this.safeString(n,"status")){const e=this.safeString(n,"err-code"),t=this.id+" "+o;this.throwBroadlyMatchedException(this.exceptions.broad,o,t),this.throwExactlyMatchedException(this.exceptions.exact,e,t);const s=this.safeString(n,"err-msg");throw this.throwExactlyMatchedException(this.exceptions.exact,s,t),new r.ExchangeError(t)}}}}},1936:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(9023),r=s(2079),a=s(5147),o=s(1579),n=s(8432),d=s(987),h=s(8283);class c extends i.A{describe(){return this.deepExtend(super.describe(),{id:"hyperliquid",name:"Hyperliquid",countries:[],version:"v1",rateLimit:50,certified:!1,pro:!0,dex:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,borrowCrossMargin:!1,borrowIsolatedMargin:!1,cancelAllOrders:!1,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!0,closeAllPositions:!1,closePosition:!1,createMarketBuyOrderWithCost:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!0,editOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDeposits:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchLiquidations:!1,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:"emulated",fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!0,repayCrossMargin:!1,repayIsolatedMargin:!1,sandbox:!0,setLeverage:!0,setMarginMode:!0,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1m"},hostname:"hyperliquid.xyz",urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/b371bc6c-4a8c-489f-87f4-20a913dd8d4b",api:{public:"https://api.{hostname}",private:"https://api.{hostname}"},test:{public:"https://api.hyperliquid-testnet.xyz",private:"https://api.hyperliquid-testnet.xyz"},www:"https://hyperliquid.xyz",doc:"https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api",fees:"https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees",referral:"https://app.hyperliquid.xyz/"},api:{public:{post:{info:1}},private:{post:{exchange:1}}},fees:{swap:{taker:this.parseNumber("0.00035"),maker:this.parseNumber("0.0001")},spot:{taker:this.parseNumber("0.00035"),maker:this.parseNumber("0.0001")}},requiredCredentials:{apiKey:!1,secret:!1,walletAddress:!0,privateKey:!0},exceptions:{exact:{},broad:{"Price must be divisible by tick size.":r.InvalidOrder,"Order must have minimum value of $10":r.InvalidOrder,"Insufficient margin to place order.":r.InvalidOrder,"Reduce only order would increase position.":r.InvalidOrder,"Post only order would have immediately matched,":r.InvalidOrder,"Order could not immediately match against any resting orders.":r.InvalidOrder,"Invalid TP/SL price.":r.InvalidOrder,"No liquidity available for market order.":r.InvalidOrder,"Order was never placed, already canceled, or filled.":r.OrderNotFound,"User or API Wallet ":r.InvalidOrder}},precisionMode:o.kb,commonCurrencies:{},options:{defaultType:"swap",sandboxMode:!1,defaultSlippage:.05,zeroAddress:"0x0000000000000000000000000000000000000000"}})}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}async fetchCurrencies(e={}){const t=await this.publicPostInfo(this.extend({type:"meta"},e)),s=this.safeList(t,"universe",[]),i={};for(let e=0;e<s.length;e++){const t=this.safeDict(s,e,{}),r=e,a=this.safeString(t,"name"),o=this.safeCurrencyCode(a);i[o]={id:r,name:a,code:o,precision:void 0,info:t,active:void 0,deposit:void 0,withdraw:void 0,networks:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return i}async fetchMarkets(e={}){const t=[this.fetchSwapMarkets(e),this.fetchSpotMarkets(e)],s=await Promise.all(t),i=s[0],r=s[1];return this.arrayConcat(i,r)}async fetchSwapMarkets(e={}){const t=await this.publicPostInfo(this.extend({type:"metaAndAssetCtxs"},e)),s=this.safeDict(t,0,{}),i=this.safeList(s,"universe",[]),r=this.safeDict(t,1,{}),a=[];for(let e=0;e<i.length;e++){const t=this.extend(this.safeDict(i,e,{}),this.safeDict(r,e,{}));t.baseId=e,a.push(t)}return this.parseMarkets(a)}async fetchSpotMarkets(e={}){const t=await this.publicPostInfo(this.extend({type:"spotMetaAndAssetCtxs"},e)),s=this.safeDict(t,0,{}),i=this.safeList(t,1,[]),r=this.safeList2(s,"universe","spot_infos",[]),a=this.safeList2(s,"tokens","token_infos",[]),o=[];for(let e=0;e<r.length;e++){const t=this.safeDict(r,e,{}),s=this.safeDict(i,e,{}),n=this.safeString(t,"name"),d=this.safeDict(this.fees,"spot",{}),h=this.safeNumber(d,"taker"),c=this.safeNumber(d,"maker"),l=this.safeList(t,"tokens",[]),u=this.safeInteger(l,0),p=this.safeInteger(l,1),f=this.safeDict(a,u,{}),m=this.safeDict(a,p,{}),g=this.safeString(f,"name"),v=this.safeString(m,"name"),y=this.safeCurrencyCode(g),w=this.safeCurrencyCode(v),b=y+"/"+w,S=this.safeDict(f,"spec",f),k=this.parseNumber(this.parsePrecision(this.safeString(S,"szDecimals"))),O=this.numberToString(e+1e4);o.push(this.safeMarketStructure({id:n,symbol:b,base:y,quote:w,settle:void 0,baseId:O,quoteId:v,settleId:void 0,type:"spot",spot:!0,subType:void 0,margin:void 0,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:h,maker:c,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:k,price:5},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:this.extend(s,t)}))}return o}parseMarket(e){const t="USDC",s=this.safeString(e,"name"),i=this.safeCurrencyCode(t),r=this.safeString(e,"baseId"),a="USDC",o=this.safeCurrencyCode(a);let n=s+"/"+i;n=n+":"+o;const d=this.safeDict(this.fees,"swap",{});return{id:r,symbol:n,base:s,quote:i,settle:o,baseId:r,quoteId:t,settleId:a,type:"swap",spot:!1,margin:void 0,swap:true,future:!1,option:!1,active:!0,contract:true,linear:!0,inverse:!1,taker:this.safeNumber(d,"taker"),maker:this.safeNumber(d,"maker"),contractSize:this.parseNumber("1"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"szDecimals"))),price:5},limits:{leverage:{min:void 0,max:this.safeInteger(e,"maxLeverage")},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchBalance(e={}){let t,s;[t,e]=this.handlePublicAddress("fetchBalance",e),[s,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const i={type:"spot"===s?"spotClearinghouseState":"clearinghouseState",user:t},r=await this.publicPostInfo(this.extend(i,e)),a=this.safeList(r,"balances");if(void 0!==a){const e={info:r};for(let t=0;t<a.length;t++){const s=a[t],i=this.safeCurrencyCode(this.safeString(s,"coin")),r=this.account(),o=this.safeString(s,"total"),n=this.safeString(s,"hold");r.total=o,r.free=n,e[i]=r}return this.safeBalance(e)}const o=this.safeDict(r,"marginSummary",{}),n={info:r,USDC:{total:this.safeFloat(o,"accountValue"),used:this.safeFloat(o,"totalMarginUsed")}},d=this.safeInteger(r,"time");return n.timestamp=d,n.datetime=this.iso8601(d),this.safeBalance(n)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={type:"l2Book",coin:i.swap?i.base:i.id},a=await this.publicPostInfo(this.extend(r,s)),o=this.safeList(a,"levels",[]),n={bids:this.safeList(o,0,[]),asks:this.safeList(o,1,[])},d=this.safeInteger(a,"time");return this.parseOrderBook(n,i.symbol,d,"bids","asks","px","sz")}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.fetchMarkets(t),i={};for(let e=0;e<s.length;e++){const t=s[e],r=t.info,a=this.parseTicker(r,t);i[this.safeString(a,"symbol")]=a}return this.filterByArrayTickers(i,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeList(e,"impactPxs");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,previousClose:this.safeNumber(e,"prevDayPx"),close:this.safeNumber(e,"midPx"),bid:this.safeNumber(s,0),ask:this.safeNumber(s,1),quoteVolume:this.safeNumber(e,"dayNtlVlm"),info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeInteger(r,"until",this.milliseconds());void 0===s&&(s=0),r=this.omit(r,["until"]);const n={type:"candleSnapshot",req:{coin:a.swap?a.base:a.id,interval:t,startTime:s,endTime:o}},d=await this.publicPostInfo(this.extend(n,r));return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async fetchTrades(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handlePublicAddress("fetchTrades",i),await this.loadMarkets();const a=this.safeMarket(e),o={user:r};void 0!==t?(o.type="userFillsByTime",o.startTime=t):o.type="userFills";const n=this.safeInteger(i,"until");i=this.omit(i,"until"),void 0!==n&&(o.endTime=n);const d=await this.publicPostInfo(this.extend(o,i));return this.parseTrades(d,a,t,s)}amountToPrecision(e,t){return this.market(e).spot?super.amountToPrecision(e,t):this.decimalToPrecision(t,o.D_,this.markets[e].precision.amount,this.precisionMode)}priceToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,o.D_,s.precision.price,o.v,this.paddingMode);return this.decimalToPrecision(i,o.D_,6,o.fv,this.paddingMode)}hashMessage(e){return"0x"+this.hash(e,n.lY,"hex")}signHash(e,t){const s=(0,h.h1)(e.slice(-64),t.slice(-64),d.bI,void 0);return{r:"0x"+s.r,s:"0x"+s.s,v:this.sum(27,s.v)}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}constructPhantomAgent(e,t=!0){return{source:t?"b":"a",connectionId:e}}actionHash(e,t,s){const i=this.packb(e);let r=this.binaryToBase16(i);return r+="00000"+this.intToBase16(s),void 0===t?r+="00":(r+="01",r+=t),this.hash(this.base16ToBinary(r),n.lY,"binary")}signL1Action(e,t,s=void 0){const i=this.actionHash(e,s,t),r=this.safeBool(this.options,"sandboxMode",!1),a=this.constructPhantomAgent(i,r),o={chainId:1337,name:"Exchange",verifyingContract:this.safeString(this.options,"zeroAddress"),version:"1"},n=this.ethEncodeStructuredData(o,{Agent:[{name:"source",type:"string"},{name:"connectionId",type:"bytes32"}]},a);return this.signMessage(n,this.privateKey)}signUserSignedAction(e,t){const s={chainId:421614,name:"HyperliquidSignTransaction",verifyingContract:this.safeString(this.options,"zeroAddress"),version:"1"},i=this.ethEncodeStructuredData(s,e,t);return this.signMessage(i,this.privateKey)}buildTransferSig(e){return this.signUserSignedAction({"HyperliquidTransaction:UsdSend":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]},e)}buildWithdrawSig(e){return this.signUserSignedAction({"HyperliquidTransaction:Withdraw":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]},e)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const[o,n]=this.parseCreateOrderArgs(e,t,s,i,r,a);return(await this.createOrders([o],n))[0]}async createOrders(e,t={}){await this.loadMarkets();const s=this.createOrdersRequest(e,t),i=await this.privatePostExchange(s),r=this.safeDict(i,"response",{}),a=this.safeDict(r,"data",{}),o=this.safeList(a,"statuses",[]);return this.parseOrders(o,void 0)}createOrdersRequest(e,t={}){this.checkRequiredCredentials();let s=this.safeString(this.options,"defaultSlippage");s=this.safeString(t,"slippage",s);let i=!1;for(let t=0;t<e.length;t++){const s=e[t],r=this.safeDict(s,"params",{});void 0!==this.safeString2(r,"clientOrderId","client_id")&&(i=!0)}if(i)for(let t=0;t<e.length;t++){const s=e[t],i=this.safeDict(s,"params",{});if(void 0===this.safeString2(i,"clientOrderId","client_id"))throw new r.ArgumentsRequired(this.id+" createOrders() all orders must have clientOrderId if at least one has a clientOrderId")}t=this.omit(t,["slippage","clientOrderId","client_id","slippage","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice","timeInForce"]);const o=this.milliseconds(),n=[];for(let t=0;t<e.length;t++){const i=e[t],o=this.safeString(i,"symbol"),d=this.market(o),h=d.symbol,c="MARKET"===this.safeStringUpper(i,"type"),l="BUY"===this.safeStringUpper(i,"side"),u=this.safeString(i,"amount"),p=this.safeString(i,"price");let f=this.safeDict(i,"params",{});const m=this.safeString2(f,"clientOrderId","client_id"),g=this.safeString(f,"slippage",s);let v=c?"ioc":"gtc";this.safeBool(f,"postOnly",!1)&&(v="alo");let y=this.safeStringLower(f,"timeInForce",v);y=this.capitalize(y);let w=this.safeString2(f,"triggerPrice","stopPrice");const b=this.safeString(f,"stopLossPrice",w),S=this.safeString(f,"takeProfitPrice"),k=b||S;let O;if(c){if(void 0===p)throw new r.ArgumentsRequired(this.id+"  market orders require price to calculate the max slippage price. Default slippage can be set in options (default is 5%).");O=l?a.Y.stringMul(p,a.Y.stringAdd("1",g)):a.Y.stringMul(p,a.Y.stringSub("1",g)),O=this.priceToPrecision(h,O)}else O=this.priceToPrecision(h,p);const T=this.amountToPrecision(h,u),P=this.safeBool(f,"reduceOnly",!1),I={};if(k){let e=!1;void 0!==S?(w=this.priceToPrecision(h,S),e=!0):w=this.priceToPrecision(h,b),I.trigger={isMarket:c,triggerPx:w,tpsl:e?"tp":"sl"}}else I.limit={tif:y};f=this.omit(f,["clientOrderId","slippage","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice","timeInForce","client_id","reduceOnly","postOnly"]);const x={a:this.parseToInt(d.baseId),b:l,p:O,s:T,r:P,t:I};void 0!==m&&(x.c=m),n.push(x)}const d=this.formatVaultAddress(this.safeString(t,"vaultAddress")),h={type:"order",orders:n,grouping:"na"};void 0===d&&(h.brokerCode=1);const c={action:h,nonce:o,signature:this.signL1Action(h,o,d)};return void 0!==d&&(t=this.omit(t,"vaultAddress"),c.vaultAddress=d),c}async cancelOrder(e,t=void 0,s={}){const i=await this.cancelOrders([e],t,s);return this.safeDict(i,0)}async cancelOrders(e,t=void 0,s={}){if(this.checkRequiredCredentials(),void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t);let a=this.safeValue2(s,"clientOrderId","client_id");s=this.omit(s,["clientOrderId","client_id"]);const o=this.milliseconds(),n={nonce:o},d=[],h={type:"",cancels:[]},c=this.parseToNumeric(i.baseId);if(void 0!==a){Array.isArray(a)||(a=[a]),h.type="cancelByCloid";for(let e=0;e<a.length;e++)d.push({asset:c,cloid:a[e]})}else{h.type="cancel";for(let t=0;t<e.length;t++)d.push({a:c,o:this.parseToNumeric(e[t])})}h.cancels=d;const l=this.formatVaultAddress(this.safeString(s,"vaultAddress")),u=this.signL1Action(h,o,l);n.action=h,n.signature=u,void 0!==l&&(s=this.omit(s,"vaultAddress"),n.vaultAddress=l);const p=await this.privatePostExchange(n),f=this.safeDict(p,"response"),m=this.safeDict(f,"data"),g=this.safeList(m,"statuses"),v=[];for(let e=0;e<g.length;e++){const t=g[e];v.push(this.safeOrder({info:t,status:t}))}return v}async cancelOrdersForSymbols(e,t={}){this.checkRequiredCredentials(),await this.loadMarkets();const s=this.milliseconds(),i={nonce:s},a=[],o={type:"",cancels:[]};let n=!1;for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"clientOrderId");void 0!==i&&(n=!0);const o=this.safeString(s,"id"),d=this.safeString(s,"symbol");if(void 0===d)throw new r.ArgumentsRequired(this.id+" cancelOrdersForSymbols() requires a symbol argument in each order");if(void 0!==o&&n)throw new r.BadRequest(this.id+" cancelOrdersForSymbols() all orders must have either id or clientOrderId");const h=n?"asset":"a",c=n?"cloid":"o",l=this.market(d),u={};u[h]=this.parseToNumeric(l.baseId),u[c]=n?i:this.parseToNumeric(o),a.push(u)}o.type=n?"cancelByCloid":"cancel",o.cancels=a;const d=this.formatVaultAddress(this.safeString(t,"vaultAddress")),h=this.signL1Action(o,s,d);i.action=o,i.signature=h,void 0!==d&&(t=this.omit(t,"vaultAddress"),i.vaultAddress=d);return await this.privatePostExchange(i)}async cancelAllOrdersAfter(e,t={}){this.checkRequiredCredentials(),await this.loadMarkets(),t=this.omit(t,["clientOrderId","client_id"]);const s=this.milliseconds(),i={nonce:s},r={type:"scheduleCancel",time:s+e},a=this.formatVaultAddress(this.safeString(t,"vaultAddress")),o=this.signL1Action(r,s,a);i.action=r,i.signature=o,void 0!==a&&(t=this.omit(t,"vaultAddress"),i.vaultAddress=a);return await this.privatePostExchange(i)}editOrderRequest(e,t,s,i,o=void 0,n=void 0,d={}){if(this.checkRequiredCredentials(),void 0===e)throw new r.ArgumentsRequired(this.id+" editOrder() requires an id argument");const h=this.market(t),c="MARKET"===(s=s.toUpperCase()),l="BUY"===(i=i.toUpperCase()),u=this.safeString(this.options,"defaultSlippage"),p=this.safeString(d,"slippage",u);let f=c?"ioc":"gtc";this.safeBool(d,"postOnly",!1)&&(f="alo");let m=this.safeStringLower(d,"timeInForce",f);m=this.capitalize(m);const g=this.safeString2(d,"clientOrderId","client_id");let v=this.safeString2(d,"triggerPrice","stopPrice");const y=this.safeString(d,"stopLossPrice",v),w=this.safeString(d,"takeProfitPrice"),b=y||w;d=this.omit(d,["slippage","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice","clientOrderId","client_id"]);let S=n.toString();S=c?l?a.Y.stringMul(n.toString(),a.Y.stringAdd("1",p)):a.Y.stringMul(n.toString(),a.Y.stringSub("1",p)):this.priceToPrecision(t,n.toString());const k=this.amountToPrecision(t,o),O=this.safeBool(d,"reduceOnly",!1),T={};if(b){let e=!1;void 0!==w?(v=this.priceToPrecision(t,w),e=!0):v=this.priceToPrecision(t,y),T.trigger={isMarket:c,triggerPx:v,tpsl:e?"tp":"sl"}}else T.limit={tif:m};void 0===v&&(v="0");const P=this.milliseconds(),I={a:this.parseToInt(h.baseId),b:l,p:S,s:k,r:O,t:T};void 0!==g&&(I.c=g);const x={type:"batchModify",modifies:[{oid:this.parseToInt(e),order:I}]},A=this.formatVaultAddress(this.safeString(d,"vaultAddress")),M={action:x,nonce:P,signature:this.signL1Action(x,P,A)};return void 0!==A&&(d=this.omit(d,"vaultAddress"),M.vaultAddress=A),M}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editOrderRequest(e,t,s,i,r,a,o),h=await this.privatePostExchange(d),c=this.safeDict(h,"response",{}),l=this.safeDict(c,"data",{}),u=this.safeList(l,"statuses",[]),p=this.safeDict(u,0,{});return this.parseOrder(p,n)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={type:"fundingHistory",coin:r.base};a.startTime=void 0!==t?t:this.milliseconds()-36e7;const o=this.safeInteger(i,"until");i=this.omit(i,"until"),void 0!==o&&(a.endTime=o);const n=await this.publicPostInfo(this.extend(a,i)),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeInteger(t,"time");d.push({info:t,symbol:this.safeSymbol(void 0,r),fundingRate:this.safeNumber(t,"fundingRate"),timestamp:s,datetime:this.iso8601(s)})}const h=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(h,e,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a;[r,i]=this.handlePublicAddress("fetchOpenOrders",i),[a,i]=this.handleOptionAndParams(i,"fetchOpenOrders","method","frontendOpenOrders"),await this.loadMarkets();const o=this.safeMarket(e),n={type:a,user:r},d=await this.publicPostInfo(this.extend(n,i));return this.parseOrders(d,o,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handlePublicAddress("fetchClosedOrders",i),await this.loadMarkets();const a=this.safeMarket(e),o={type:"historicalOrders",user:r},n=await this.publicPostInfo(this.extend(o,i));return this.parseOrders(n,a,t,s)}async fetchOrder(e,t=void 0,s={}){let i;[i,s]=this.handlePublicAddress("fetchOrder",s),await this.loadMarkets();const r=this.safeMarket(t),a={type:"orderStatus",oid:e.length>=34?e:this.parseToNumeric(e),user:i},o=await this.publicPostInfo(this.extend(a,s)),n=this.safeDict(o,"order");return this.parseOrder(n,r)}parseOrder(e,t=void 0){let s=this.safeDictN(e,["order","resting","filled"]);void 0===s&&(s=e);const i=this.safeString(s,"coin");let r;void 0!==i&&(r=i.indexOf("/")>-1?i:i+"/USDC:USDC");const a=(t=void 0===this.safeString(s,"id")?this.safeMarket(r,void 0):this.safeMarket(r,t)).symbol,o=this.safeInteger2(e,"timestamp","statusTimestamp"),n=this.safeString(e,"status");let d=this.safeString(s,"side");return void 0!==d&&(d="A"===d?"sell":"buy"),this.safeOrder({info:e,id:this.safeString(s,"oid"),clientOrderId:this.safeString(s,"cloid"),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,lastUpdateTimestamp:void 0,symbol:a,type:this.parseOrderType(this.safeStringLower(s,"orderType")),timeInForce:this.safeStringUpper(s,"tif"),postOnly:void 0,reduceOnly:this.safeBool(s,"reduceOnly"),side:d,price:this.safeNumber(s,"limitPx"),triggerPrice:this.safeBool(s,"isTrigger")?this.safeNumber(s,"triggerPx"):void 0,amount:this.safeNumber2(s,"sz","totalSz"),cost:void 0,average:this.safeNumber(s,"avgPx"),filled:void 0,remaining:void 0,status:this.parseOrderStatus(n),fee:void 0,trades:void 0},t)}parseOrderStatus(e){return this.safeString({triggered:"open",filled:"closed"},e,e)}parseOrderType(e){return this.safeString({"stop limit":"limit","stop market":"market"},e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handlePublicAddress("fetchMyTrades",i),await this.loadMarkets();const a=this.safeMarket(e),o={user:r};void 0!==t?(o.type="userFillsByTime",o.startTime=t):o.type="userFills";const n=this.safeInteger(i,"until");i=this.omit(i,"until"),void 0!==n&&(o.endTime=n);const d=await this.publicPostInfo(this.extend(o,i));return this.parseTrades(d,a,t,s)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"px"),r=this.safeString(e,"sz"),a=this.safeString(e,"coin")+"/USDC:USDC",o=(t=this.safeMarket(a,void 0)).symbol,n=this.safeString(e,"tid");let d=this.safeString(e,"side");void 0!==d&&(d="A"===d?"sell":"buy");const h=this.safeString(e,"fee");return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:o,id:n,order:this.safeString(e,"oid"),type:void 0,side:d,takerOrMaker:void 0,price:i,amount:r,cost:void 0,fee:{cost:h,currency:"USDC"}},t)}async fetchPosition(e,t={}){const s=await this.fetchPositions([e],t);return this.safeDict(s,0,{})}async fetchPositions(e=void 0,t={}){let s;await this.loadMarkets(),[s,t]=this.handlePublicAddress("fetchPositions",t),e=this.marketSymbols(e);const i={type:"clearinghouseState",user:s},r=await this.publicPostInfo(this.extend(i,t)),a=this.safeList(r,"assetPositions",[]),o=[];for(let e=0;e<a.length;e++)o.push(this.parsePosition(a[e],void 0));return this.filterByArrayPositions(o,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeDict(e,"position",{}),i=this.safeString(s,"coin")+"/USDC:USDC",r=this.safeMarket(i,void 0).symbol,a=this.safeDict(s,"leverage",{}),o="isolated"===this.safeString(a,"type"),n=this.safeNumber(a,"rawUsd");let d;void 0!==n&&(d=n>0?"short":"long");const h=this.safeNumber(s,"unrealizedPnl"),c=this.safeNumber(s,"marginUsed"),l=h/c*100;return this.safePosition({info:e,id:void 0,symbol:r,timestamp:void 0,datetime:void 0,isolated:o,hedged:void 0,side:d,contracts:this.safeNumber(s,"szi"),contractSize:void 0,entryPrice:this.safeNumber(s,"entryPx"),markPrice:void 0,notional:this.safeNumber(s,"positionValue"),leverage:this.safeNumber(a,"value"),collateral:void 0,initialMargin:c,maintenanceMargin:void 0,initialMarginPercentage:void 0,maintenanceMarginPercentage:void 0,unrealizedPnl:h,liquidationPrice:this.safeNumber(s,"liquidationPx"),marginMode:void 0,percentage:l})}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=this.safeInteger(s,"leverage");if(void 0===a)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter");const o=this.parseToInt(i.baseId),n="cross"===e,d=this.milliseconds();s=this.omit(s,["leverage"]);const h={type:"updateLeverage",asset:o,isCross:n,leverage:a};let c=this.safeString(s,"vaultAddress");void 0!==c&&(s=this.omit(s,"vaultAddress"),c.startsWith("0x")&&(c=c.replace("0x","")));const l={action:h,nonce:d,signature:this.signL1Action(h,d,c)};void 0!==c&&(l.vaultAddress=c);return await this.privatePostExchange(l)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a="cross"===this.safeString(s,"marginMode","cross"),o=this.parseToInt(i.baseId),n=this.milliseconds();s=this.omit(s,"marginMode");const d={type:"updateLeverage",asset:o,isCross:a,leverage:e},h=this.formatVaultAddress(this.safeString(s,"vaultAddress")),c={action:d,nonce:n,signature:this.signL1Action(d,n,h)};void 0!==h&&(s=this.omit(s,"vaultAddress"),c.vaultAddress=h);return await this.privatePostExchange(c)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),o=this.parseToInt(r.baseId);let n=this.parseToInt(a.Y.stringMul(this.amountToPrecision(e,t),"1000000"));"reduce"===s&&(n=-n);const d=this.milliseconds(),h={type:"updateIsolatedMargin",asset:o,isBuy:!0,ntli:n},c=this.formatVaultAddress(this.safeString(i,"vaultAddress")),l={action:h,nonce:d,signature:this.signL1Action(h,d,c)};void 0!==c&&(i=this.omit(i,"vaultAddress"),l.vaultAddress=c);const u=await this.privatePostExchange(l);return this.extend(this.parseMarginModification(u,r),{code:this.safeString(u,"status")})}parseMarginModification(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),type:void 0,marginMode:"isolated",amount:void 0,total:void 0,code:this.safeString(t,"settle"),status:void 0,timestamp:void 0,datetime:void 0}}async transfer(e,t,s,i,a={}){this.checkRequiredCredentials(),await this.loadMarkets();const o=this.safeBool(this.options,"sandboxMode"),n=this.milliseconds();if(this.inArray(s,["spot","swap","perp"])){if(!this.inArray(i,["spot","swap","perp"]))throw new r.NotSupported(this.id+"transfer() only support spot <> swap transfer");const e=this.formatVaultAddress(this.safeString(a,"vaultAddress"));a=this.omit(a,"vaultAddress");const s={type:"spotUser",classTransfer:{usdc:t,toPerp:"perp"===i||"swap"===i}},o={action:s,nonce:n,signature:this.signL1Action(s,n,e)};void 0!==e&&(o.vaultAddress=e);return await this.privatePostExchange(o)}if(this.checkAddress(i),void 0!==e&&"USDC"!==(e=e.toUpperCase()))throw new r.NotSupported(this.id+"transfer() only support USDC");const d={hyperliquidChain:o?"Testnet":"Mainnet",destination:i,amount:this.numberToString(t),time:n},h=this.buildTransferSig(d),c={action:{hyperliquidChain:d.hyperliquidChain,signatureChainId:"0x66eee",destination:i,amount:t.toString(),time:n,type:"usdSend"},nonce:n,signature:h};return await this.privatePostExchange(c)}async withdraw(e,t,s,i=void 0,a={}){if(this.checkRequiredCredentials(),await this.loadMarkets(),this.checkAddress(s),void 0!==e&&"USDC"!==(e=e.toUpperCase()))throw new r.NotSupported(this.id+"withdraw() only support USDC");const o=this.safeBool(this.options,"sandboxMode",!1),n=this.milliseconds(),d={hyperliquidChain:o?"Testnet":"Mainnet",destination:s,amount:t.toString(),time:n},h=this.buildWithdrawSig(d),c={action:{hyperliquidChain:d.hyperliquidChain,signatureChainId:"0x66eee",destination:s,amount:t.toString(),time:n,type:"withdraw3"},nonce:n,signature:h},l=await this.privatePostExchange(c);return this.parseTransaction(l)}parseTransaction(e,t=void 0){return{info:e,id:void 0,txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:void 0,currency:void 0,status:this.safeString(e,"status"),updated:void 0,comment:void 0,internal:void 0,fee:void 0}}async fetchTradingFee(e,t={}){let s;await this.loadMarkets(),[s,t]=this.handlePublicAddress("fetchTradingFee",t);const i=this.market(e),r={type:"userFees",user:s},a=await this.publicPostInfo(this.extend(r,t)),o={userCrossRate:this.safeString(a,"userCrossRate"),userAddRate:this.safeString(a,"userAddRate")};return this.parseTradingFee(o,i)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.safeNumber(e,"userAddRate"),taker:this.safeNumber(e,"userCrossRate"),percentage:void 0,tierBased:void 0}}formatVaultAddress(e=void 0){if(void 0!==e)return e.startsWith("0x")?e.replace("0x",""):e}handlePublicAddress(e,t){let s;[s,t]=this.handleOptionAndParams(t,e,"user");let i=s;if([i,t]=this.handleOptionAndParams(t,e,"address",s),void 0!==i&&""!==i)return[i,t];if(void 0!==this.walletAddress&&""!==this.walletAddress)return[this.walletAddress,t];throw new r.ArgumentsRequired(this.id+" "+e+"() requires a user parameter inside 'params' or the wallet address set")}coinToMarketId(e){return e.indexOf("/")>-1?e:e+"/USDC:USDC"}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;let c;if("err"===this.safeString(n,"status",""))c=this.safeString(n,"response");else{const e=this.safeDict(n,"response",{}),t=this.safeDict(e,"data",{}),s=this.safeList(t,"statuses",[]),i=this.safeDict(s,0);c=this.safeString(i,"error")}const l=this.id+" "+o,u=void 0!==c&&""!==c;if(u&&(this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwBroadlyMatchedException(this.exceptions.broad,c,l)),u)throw new r.ExchangeError(l)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.implodeHostname(this.urls.api[t])+"/"+e;return"POST"===s&&(r={"Content-Type":"application/json"},a=this.json(i)),{url:o,method:s,body:a,headers:r}}parseCreateOrderArgs(e,t,s,i,r=void 0,a={}){const o=this.market(e),n=this.safeString(a,"vaultAddress");a=this.omit(a,"vaultAddress");const d={symbol:e=o.symbol,type:t,side:s,amount:i,price:r,params:a},h={};return void 0!==n&&(h.vaultAddress=n),[d,h]}}},636:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(5893),r=s(1579),a=s(2079),o=s(5147),n=s(4852),d=s(8432),h=s(987),c=s(8283);class l extends i.A{describe(){return this.deepExtend(super.describe(),{id:"idex",name:"IDEX",countries:["US"],rateLimit:1e3,version:"v3",pro:!0,dex:!0,certified:!1,requiresWeb3:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","6h":"6h","1d":"1d"},urls:{test:{MATIC:"https://api-sandbox-matic.idex.io"},logo:"https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg",api:{MATIC:"https://api-matic.idex.io"},www:"https://idex.io",doc:["https://api-docs-v3.idex.io/"]},api:{public:{get:{ping:1,time:1,exchange:1,assets:1,markets:1,tickers:1,candles:1,trades:1,orderbook:1}},private:{get:{user:1,wallets:1,balances:1,orders:.1,fills:.1,deposits:1,withdrawals:1,wsToken:1},post:{wallets:1,orders:.1,"orders/test":.1,withdrawals:1},delete:{orders:.1}}},options:{defaultTimeInForce:"gtc",defaultSelfTradePrevention:"cn",network:"MATIC"},exceptions:{exact:{INVALID_ORDER_QUANTITY:a.InvalidOrder,INSUFFICIENT_FUNDS:a.InsufficientFunds,SERVICE_UNAVAILABLE:a.ExchangeNotAvailable,EXCEEDED_RATE_LIMIT:a.DDoSProtection,INVALID_PARAMETER:a.BadRequest,WALLET_NOT_ASSOCIATED:a.InvalidAddress,INVALID_WALLET_SIGNATURE:a.AuthenticationError}},requiredCredentials:{walletAddress:!0,privateKey:!0,apiKey:!0,secret:!0},precisionMode:r.kb,paddingMode:r.ex,commonCurrencies:{}})}priceToPrecision(e,t){const s=this.market(e),i=this.safeValue(s,"info",{}),a=this.safeInteger(i,"quoteAssetPrecision");return t=this.decimalToPrecision(t,r.D_,s.precision.price,this.precisionMode),this.decimalToPrecision(t,r.R3,a,r.fv,r.ex)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=await this.publicGetExchange(),i=this.safeNumber(s,"makerFeeRate"),r=this.safeNumber(s,"takerFeeRate"),a=this.safeString(s,"makerTradeMinimum"),n=this.safeString(s,"takerTradeMinimum"),d=this.parseNumber(o.Y.stringMin(a,n)),h=[];for(let e=0;e<t.length;e++){const s=t[e],a=this.safeString(s,"market"),o=this.safeString(s,"baseAsset"),n=this.safeString(s,"quoteAsset"),c=this.safeCurrencyCode(o),l=this.safeCurrencyCode(n),u=this.parseNumber(this.parsePrecision(this.safeString(s,"baseAssetPrecision"))),p=this.parseNumber(this.parsePrecision(this.safeString(s,"quoteAssetPrecision"))),f=this.safeString(s,"status");let m;"ETH"===l&&(m=d),h.push({id:a,symbol:c+"/"+l,base:c,quote:l,settle:void 0,baseId:o,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"inactive"!==f,contract:!1,linear:void 0,inverse:void 0,taker:r,maker:i,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:u,price:this.safeNumber(s,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:u,max:void 0},price:{min:p,max:void 0},cost:{min:m,max:void 0}},created:void 0,info:s})}return h}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.publicGetTickers(this.extend(i,t)),a=this.safeDict(r,0);return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t);return this.parseTickers(s,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=(t=this.safeMarket(s,t,"-")).symbol,r=this.safeInteger(e,"time"),a=this.safeString(e,"close");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:a,last:a,previousClose:void 0,change:void 0,percentage:this.safeString(e,"percentChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume"),info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,interval:t};void 0!==s&&(o.start=s),void 0!==i&&(o.limit=Math.min(i,1e3));const n=await this.publicGetCandles(this.extend(o,r));return Array.isArray(n)?this.parseOHLCVs(n,a,t,s,i):[]}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==t&&(a.start=t),void 0!==s&&(a.limit=Math.min(s,1e3));const o=await this.publicGetTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"fillId"),i=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeString(e,"quoteQuantity"),o=this.safeInteger(e,"time"),n=this.safeString(e,"market"),d=this.safeSymbol(n,t,"-"),h="buy"===this.safeString(e,"makerSide")?"sell":"buy",c=this.safeString(e,"side",h),l=this.safeString(e,"liquidity","taker"),u=this.safeString(e,"fee");let p;if(void 0!==u){const t=this.safeString(e,"feeAsset");p={cost:u,currency:this.safeCurrencyCode(t)}}const f=this.safeString(e,"orderId");return this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:d,id:s,order:f,type:"limit",side:c,takerOrMaker:l,price:i,amount:r,cost:a,fee:p},t)}async fetchTradingFees(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t={nonce:this.uuidv1()};let s;s=await this.privateGetUser(this.extend(t,e));const i=this.safeNumber(s,"makerFeeRate"),r=this.safeNumber(s,"takerFeeRate"),a={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e];a[t]={info:s,symbol:t,maker:i,taker:r,percentage:!0,tierBased:!1}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={market:this.market(e).id,level:2};void 0!==t&&(i.limit=t);const r=await this.publicGetOrderbook(this.extend(i,s));return{symbol:e,timestamp:void 0,datetime:void 0,nonce:this.safeInteger(r,"sequence"),bids:this.parseSide(r,"bids"),asks:this.parseSide(r,"asks")}}parseSide(e,t){const s=this.safeValue(e,t,[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeNumber(t,0),a=this.safeNumber(t,1),o=this.safeInteger(t,2);i.push([r,a,o])}const r="bids"===t;return this.sortBy(i,0,r)}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"name"),a=this.safeString(i,"symbol"),o=this.safeCurrencyCode(a),n=this.parseNumber(this.parsePrecision(this.safeString(i,"exchangeDecimals")));s[o]={id:a,code:o,info:i,type:void 0,name:r,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:n,limits:{amount:{min:n,max:void 0},withdraw:{min:n,max:void 0}}}}return s}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"quantity"),o.free=this.safeString(i,"availableForTrade"),o.used=this.safeString(i,"locked"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t={nonce:this.uuidv1(),wallet:this.walletAddress},s=this.extend(t,e);if(void 0===s.wallet)throw new a.BadRequest(this.id+' fetchBalance() wallet is undefined, set this.walletAddress or "address" in params');let i;try{i=await this.privateGetBalances(s)}catch(e){if(!(e instanceof a.InvalidAddress))throw e;{const e=s.wallet;await this.associateWallet(e),i=await this.privateGetBalances(s)}}return this.parseBalance(i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;this.checkRequiredCredentials(),await this.loadMarkets();const o={nonce:this.uuidv1(),wallet:this.walletAddress};void 0!==e&&(r=this.market(e),o.market=r.id),void 0!==t&&(o.start=t),void 0!==s&&(o.limit=s);const n=this.extend(o,i);if(void 0===n.wallet)throw new a.BadRequest(this.id+' fetchMyTrades() walletAddress is undefined, set this.walletAddress or "address" in params');let d;try{d=await this.privateGetFills(n)}catch(e){if(!(e instanceof a.InvalidAddress))throw e;{const e=n.wallet;await this.associateWallet(e),d=await this.privateGetFills(n)}}return this.parseTrades(d,r,t,s)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e};return await this.fetchOrdersHelper(t,void 0,void 0,this.extend(i,s))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersHelper(e,t,s,this.extend({closed:!1},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersHelper(e,t,s,this.extend({closed:!0},i))}async fetchOrdersHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={nonce:this.uuidv1(),wallet:this.walletAddress};let a;void 0!==e&&(a=this.market(e),r.market=a.id),void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s);const o=await this.privateGetOrders(this.extend(r,i));return Array.isArray(o)?this.parseOrders(o,a,t,s):this.parseOrder(o,a)}parseOrderStatus(e){return this.safeString({active:"open",partiallyFilled:"open",rejected:"canceled",filled:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"fills",[]),r=this.safeString(e,"orderId"),a=this.safeString(e,"clientOrderId"),o=this.safeString(e,"market"),n=this.safeString(e,"side"),d=this.safeSymbol(o,t,"-"),h=this.safeString(e,"type"),c=this.safeString(e,"originalQuantity"),l=this.safeString(e,"executedQuantity"),u=this.safeString(e,"avgExecutionPrice"),p=this.safeString(e,"price"),f=this.safeString(e,"status"),m=this.safeStringUpper(e,"timeInForce"),g=this.parseOrderStatus(f);return this.safeOrder({info:e,id:r,clientOrderId:a,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:d,type:h,timeInForce:m,postOnly:void 0,side:n,price:p,stopPrice:void 0,triggerPrice:void 0,amount:c,cost:void 0,average:u,filled:l,remaining:void 0,status:g,fee:void 0,trades:i},t)}async associateWallet(e,t={}){const s=this.uuidv1(),i=this.remove0xPrefix(e),r=[this.base16ToBinary(s),this.base16ToBinary(i)],a=this.binaryConcatArray(r),o=this.hash(a,d.lY,"hex"),n={parameters:{nonce:s,wallet:e},signature:this.signMessageString(o,this.privateKey)};return await this.privatePostWallets(n)}async createOrder(e,t,s,i,r=void 0,o={}){this.checkRequiredCredentials(),await this.loadMarkets();const n=this.safeBool(o,"test",!1);o=this.omit(o,"test");const h=this.market(e),c=this.uuidv1();let l;const u={stopLoss:3,stopLossLimit:4,takeProfit:5,takeProfitLimit:6};let p;if("stopLossLimit"===t||"takeProfitLimit"===t||"stopPrice"in o){if(!("stopPrice"in o))throw new a.BadRequest(this.id+" createOrder() stopPrice is a required parameter for "+t+"orders");p=this.priceToPrecision(e,o.stopPrice)}const f={limit:1,limitMaker:2};let m;const g=t.toLowerCase().indexOf("limit")>=0;if(t in f)l=f[t],m=this.priceToPrecision(e,r);else if(t in u)l=u[t],m=this.priceToPrecision(e,r);else{if("market"!==t)throw new a.BadRequest(this.id+" "+t+" is not a valid order type");l=0}let v=0;if("quoteOrderQuantity"in o){if("market"!==t)throw new a.NotSupported(this.id+" createOrder() quoteOrderQuantity is not supported for "+t+" orders, only supported for market orders");v=1,i=this.safeNumber(o,"quoteOrderQuantity")}const y="buy"===s?0:1,w=this.remove0xPrefix(this.walletAddress),b=this.safeString(this.options,"network","ETH"),S=this.getSupportedMapping(b,{ETH:1,BSC:2,MATIC:4}),k=this.amountToPrecision(e,i),O={gtc:0,ioc:2,fok:3},T=this.safeString(this.options,"defaultTimeInForce","gtc"),P=this.safeString(o,"timeInForce",T);let I;if(!(P in O)){const e=Object.keys(O).join(", ");throw new a.BadRequest(this.id+" "+P+" is not a valid timeInForce, please choose one of "+e)}I=O[P];const x={dc:0,co:1,cn:2,cb:3},A=this.safeString(this.options,"defaultSelfTradePrevention","cn"),M=this.safeString(o,"selfTradePrevention",A);let C;if(!(M in x)){const e=Object.keys(x).join(", ");throw new a.BadRequest(this.id+" "+M+" is not a valid selfTradePrevention, please choose one of "+e)}C=x[M];const E=[this.numberToBE(S,1),this.base16ToBinary(c),this.base16ToBinary(w),this.encode(h.id),this.numberToBE(l,1),this.numberToBE(y,1),this.encode(k),this.numberToBE(v,1)];if(g){const e=this.encode(m);E.push(e)}if(t in u){const e=this.encode(p||m);E.push(e)}const _=this.safeString(o,"clientOrderId");void 0!==_&&E.push(this.encode(_));const B=[this.numberToBE(I,1),this.numberToBE(C,1),this.numberToBE(0,8)],N=this.arrayConcat(E,B),R=this.binaryConcatArray(N),L=this.hash(R,d.lY,"hex"),V=this.signMessageString(L,this.privateKey),D={parameters:{nonce:c,market:h.id,side:s,type:t,wallet:this.walletAddress,selfTradePrevention:M},signature:V};let q;return"market"!==t&&(D.parameters.timeInForce=P),g&&(D.parameters.price=m),t in u&&(D.parameters.stopPrice=p||m),0===v?D.parameters.quantity=k:D.parameters.quoteOrderQuantity=k,void 0!==_&&(D.parameters.clientOrderId=_),q=n?await this.privatePostOrdersTest(D):await this.privatePostOrders(D),this.parseOrder(q,h)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkRequiredCredentials(),await this.loadMarkets();const a=this.uuidv1(),o=this.currencyToPrecision(e,t),n=this.currency(e),h=this.remove0xPrefix(this.walletAddress),c=[this.base16ToBinary(a),this.base16ToBinary(h),this.encode(n.id),this.encode(o),this.numberToBE(1,1)],l=this.binaryConcatArray(c),u=this.hash(l,d.lY,"hex"),p=this.signMessageString(u,this.privateKey),f={parameters:{nonce:a,wallet:s,asset:n.id,quantity:o},signature:p},m=await this.privatePostWithdrawals(f);return this.parseTransaction(m,n)}async cancelAllOrders(e=void 0,t={}){let s;this.checkRequiredCredentials(),await this.loadMarkets(),void 0!==e&&(s=this.market(e));const i=this.uuidv1(),r={parameters:{nonce:i,wallet:this.walletAddress}},a=this.remove0xPrefix(this.walletAddress),o=[this.base16ToBinary(i),this.base16ToBinary(a)];void 0!==s&&(o.push(this.encode(s.id)),r.parameters.market=s.id);const n=this.binaryConcatArray(o),h=this.hash(n,d.lY,"hex"),c=this.signMessageString(h,this.privateKey);r.signature=c;const l=await this.privateDeleteOrders(this.extend(r,t));return this.parseOrders(l,s)}async cancelOrder(e,t=void 0,s={}){let i;this.checkRequiredCredentials(),await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r=this.uuidv1(),a=this.remove0xPrefix(this.walletAddress),o=[this.base16ToBinary(r),this.base16ToBinary(a),this.encode(e)],n=this.binaryConcatArray(o),h=this.hash(n,d.lY,"hex"),c=this.signMessageString(h,this.privateKey),l={parameters:{nonce:r,wallet:this.walletAddress,orderId:e},signature:c},u=await this.privateDeleteOrders(this.extend(l,s)),p=this.safeDict(u,0);return this.parseOrder(p,i)}handleErrors(e,t,s,i,r,o,n,d,h){const c=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==c)throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),new a.ExchangeError(this.id+" "+l)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={nonce:this.uuidv1(),wallet:this.walletAddress,depositId:e},r=await this.privateGetDeposits(this.extend(i,s));return this.parseTransaction(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetDeposits"},i),await this.fetchTransactionsHelper(e,t,s,i)}async fetchStatus(e={}){return{status:"ok",updated:void 0,eta:void 0,url:void 0,info:await this.publicGetPing(e)}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={nonce:this.uuidv1(),wallet:this.walletAddress,withdrawalId:e},r=await this.privateGetWithdrawals(this.extend(i,s));return this.parseTransaction(r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return i=this.extend({method:"privateGetWithdrawals"},i),await this.fetchTransactionsHelper(e,t,s,i)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={nonce:this.uuidv1(),wallet:this.walletAddress};let o;void 0!==e&&(o=this.currency(e),r.asset=o.id),void 0!==t&&(r.start=t),void 0!==s&&(r.limit=s);const n=i.method;let d;if(i=this.omit(i,"method"),"privateGetDeposits"===n)d=await this.privateGetDeposits(this.extend(r,i));else{if("privateGetWithdrawals"!==n)throw new a.NotSupported(this.id+" fetchTransactionsHelper() not support this method");d=await this.privateGetWithdrawals(this.extend(r,i))}return this.parseTransactions(d,o,t,s)}parseTransactionStatus(e){return this.safeString({mined:"ok"},e,e)}parseTransaction(e,t=void 0){let s;"depositId"in e?s="deposit":("withdrawId"in e||"withdrawalId"in e)&&(s="withdrawal");let i=this.safeString2(e,"depositId","withdrawId");i=this.safeString(e,"withdrawalId",i);const r=this.safeCurrencyCode(this.safeString(e,"asset"),t),a=this.safeNumber(e,"quantity"),o=this.safeString(e,"txId"),n=this.safeInteger2(e,"txTime","time");let d;"fee"in e&&(d={cost:this.safeNumber(e,"fee"),currency:"ETH"});const h=this.safeString(e,"txStatus"),c=this.parseTransactionStatus(h),l=this.safeInteger(e,"confirmationTime");return{info:e,id:i,txid:o,timestamp:n,datetime:this.iso8601(n),network:void 0,address:void 0,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:s,amount:a,currency:r,status:c,updated:l,comment:void 0,internal:void 0,fee:d}}calculateRateLimiterCost(e,t,s,i,r={}){const a=void 0!==this.apiKey,o=void 0!==this.secret,n=void 0!==this.walletAddress,d=void 0!==this.privateKey,h=this.safeValue(r,"cost",1);return a&&o&&n&&d?h/2:h}async fetchDepositAddress(e=void 0,t={}){const s={};s.nonce=this.uuidv1();const i=await this.privateGetWallets(this.extend(s,t));return this.parseDepositAddress(i)}parseDepositAddress(e,t=void 0){const s=e.length,i=this.safeDict(e,s-1),r=this.safeString(i,"address");return this.checkAddress(r),{info:e,currency:void 0,address:r,tag:void 0,network:"MATIC"}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeString(this.options,"network","ETH"),d=this.safeString(this.options,"version","v1");let h=this.urls.api[o]+"/"+d+"/"+e;let c;if(Object.keys(i).length>0&&("GET"===s?(c=this.urlencode(i),h=h+"?"+c):a=this.json(i)),r={"Content-Type":"application/json"},void 0!==this.apiKey&&(r["IDEX-API-Key"]=this.apiKey),"private"===t){let e;e="GET"===s?c:a,r["IDEX-HMAC-Signature"]=this.hmac(this.encode(e),this.encode(this.secret),n.s,"hex")}return{url:h,method:s,body:a,headers:r}}remove0xPrefix(e){return"0x"===e.slice(0,2)?e.slice(2):e}hashMessage(e){const t=this.base16ToBinary(this.remove0xPrefix(e)),s=this.encode("Ethereum Signed Message:\n"+t.byteLength);return"0x"+this.hash(this.binaryConcat(s,t),d.lY,"hex")}signHash(e,t){const s=(0,c.h1)(e.slice(-64),t.slice(-64),h.bI,void 0);return{r:"0x"+s.r,s:"0x"+s.s,v:27+s.v}}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}signMessageString(e,t){const s=this.signMessage(e,t);return s.r+this.remove0xPrefix(s.s)+this.binaryToBase16(this.numberToBE(s.v,1))}}},4162:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(359),r=s(5147),a=s(1579),o=s(4852),n=s(2079);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"independentreserve",name:"Independent Reserve",countries:["AU","NZ"],rateLimit:1e3,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg",api:{public:"https://api.independentreserve.com/Public",private:"https://api.independentreserve.com/Private"},www:"https://www.independentreserve.com",doc:"https://www.independentreserve.com/API"},api:{public:{get:["GetValidPrimaryCurrencyCodes","GetValidSecondaryCurrencyCodes","GetValidLimitOrderTypes","GetValidMarketOrderTypes","GetValidOrderTypes","GetValidTransactionTypes","GetMarketSummary","GetOrderBook","GetAllOrders","GetTradeHistorySummary","GetRecentTrades","GetFxRates","GetOrderMinimumVolumes","GetCryptoWithdrawalFees"]},private:{post:["GetOpenOrders","GetClosedOrders","GetClosedFilledOrders","GetOrderDetails","GetAccounts","GetTransactions","GetFiatBankAccounts","GetDigitalCurrencyDepositAddress","GetDigitalCurrencyDepositAddresses","GetTrades","GetBrokerageFees","GetDigitalCurrencyWithdrawal","PlaceLimitOrder","PlaceMarketOrder","CancelOrder","SynchDigitalCurrencyDepositAddressWithBlockchain","RequestFiatWithdrawal","WithdrawFiatCurrency","WithdrawDigitalCurrency"]}},fees:{trading:{taker:this.parseNumber("0.005"),maker:this.parseNumber("0.005"),percentage:!0,tierBased:!1}},commonCurrencies:{PLA:"PlayChip"},precisionMode:a.kb})}async fetchMarkets(e={}){const t=await this.publicGetGetValidPrimaryCurrencyCodes(e),s=await this.publicGetGetValidSecondaryCurrencyCodes(e),i=await this.publicGetGetOrderMinimumVolumes(e),r=[];for(let e=0;e<t.length;e++){const a=t[e],o=this.safeCurrencyCode(a),n=this.safeNumber(i,a);for(let e=0;e<s.length;e++){const t=s[e],i=this.safeCurrencyCode(t),d=a+"/"+t;r.push({id:d,symbol:o+"/"+i,base:o,quote:i,settle:void 0,baseId:a,quoteId:t,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:void 0},limits:{leverage:{min:void 0,max:void 0},amount:{min:n,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:d})}}return r}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"CurrencyCode"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"AvailableBalance"),o.total=this.safeString(i,"TotalBalance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccounts(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={primaryCurrencyCode:i.baseId,secondaryCurrencyCode:i.quoteId},a=await this.publicGetGetOrderBook(this.extend(r,s)),o=this.parse8601(this.safeString(a,"CreatedTimestampUtc"));return this.parseOrderBook(a,i.symbol,o,"BuyOrders","SellOrders","Price","Volume")}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),i=this.safeString(e,"PrimaryCurrencyCode"),r=this.safeString(e,"SecondaryCurrencyCode");let a;void 0!==i&&void 0!==r&&(a=i+"/"+r);const o=(t=this.safeMarket(a,t,"/")).symbol,n=this.safeString(e,"LastPrice");return this.safeTicker({symbol:o,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"DayHighestPrice"),low:this.safeString(e,"DayLowestPrice"),bid:this.safeString(e,"CurrentHighestBidPrice"),bidVolume:void 0,ask:this.safeString(e,"CurrentLowestOfferPrice"),askVolume:void 0,vwap:void 0,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"DayAvgPrice"),baseVolume:this.safeString(e,"DayVolumeXbtInSecondaryCurrrency"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={primaryCurrencyCode:s.baseId,secondaryCurrencyCode:s.quoteId},r=await this.publicGetGetMarketSummary(this.extend(i,t));return this.parseTicker(r,s)}parseOrder(e,t=void 0){let s;const i=this.safeString(e,"PrimaryCurrencyCode"),a=this.safeString(e,"SecondaryCurrencyCode");let o,n;void 0!==i&&void 0!==a?(o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(a),s=o+"/"+n):void 0!==t&&(s=t.symbol,o=t.base,n=t.quote);let d,h=this.safeString2(e,"Type","OrderType");void 0!==h&&(h.indexOf("Bid")>=0?d="buy":h.indexOf("Offer")>=0&&(d="sell"),h.indexOf("Market")>=0?h="market":h.indexOf("Limit")>=0&&(h="limit"));const c=this.parse8601(this.safeString(e,"CreatedTimestampUtc")),l=this.safeString(e,"VolumeFilled"),u=this.safeString(e,"FeePercent");let p;return void 0!==u&&void 0!==l&&(p=r.Y.stringMul(u,l)),this.safeOrder({info:e,id:this.safeString(e,"OrderGuid"),clientOrderId:void 0,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:s,type:h,timeInForce:void 0,postOnly:void 0,side:d,price:this.safeString(e,"Price"),stopPrice:void 0,triggerPrice:void 0,cost:this.safeString(e,"Value"),average:this.safeString(e,"AvgPrice"),amount:this.safeString2(e,"VolumeOrdered","Volume"),filled:l,remaining:this.safeString(e,"Outstanding"),status:this.parseOrderStatus(this.safeString(e,"Status")),fee:{rate:u,cost:p,currency:o},trades:void 0},t)}parseOrderStatus(e){return this.safeString({Open:"open",PartiallyFilled:"open",Filled:"closed",PartiallyFilledAndCancelled:"canceled",Cancelled:"canceled",PartiallyFilledAndExpired:"canceled",Expired:"canceled"},e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostGetOrderDetails(this.extend({orderGuid:e},s));let r;return void 0!==t&&(r=this.market(t)),this.parseOrder(i,r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.ordered({});let a;void 0!==e&&(a=this.market(e),r.primaryCurrencyCode=a.baseId,r.secondaryCurrencyCode=a.quoteId),void 0===s&&(s=50),r.pageIndex=1,r.pageSize=s;const o=await this.privatePostGetOpenOrders(this.extend(r,i)),n=this.safeList(o,"Data",[]);return this.parseOrders(n,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.ordered({});let a;void 0!==e&&(a=this.market(e),r.primaryCurrencyCode=a.baseId,r.secondaryCurrencyCode=a.quoteId),void 0===s&&(s=50),r.pageIndex=1,r.pageSize=s;const o=await this.privatePostGetClosedOrders(this.extend(r,i)),n=this.safeList(o,"Data",[]);return this.parseOrders(n,a,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=50,i={}){await this.loadMarkets();const r=this.safeInteger(i,"pageIndex",1);void 0===s&&(s=50);const a=this.ordered({pageIndex:r,pageSize:s}),o=await this.privatePostGetTrades(this.extend(a,i));let n;return void 0!==e&&(n=this.market(e)),this.parseTrades(o.Data,n,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(e.TradeTimestampUtc),i=this.safeString(e,"TradeGuid"),a=this.safeString(e,"OrderGuid"),o=this.safeString2(e,"Price","SecondaryCurrencyTradePrice"),n=this.safeString2(e,"VolumeTraded","PrimaryCurrencyAmount"),d=this.parseNumber(o),h=this.parseNumber(n),c=this.parseNumber(r.Y.stringMul(o,n)),l=this.safeString(e,"PrimaryCurrencyCode"),u=this.safeString(e,"SecondaryCurrencyCode");let p;void 0!==l&&void 0!==u&&(p=l+"/"+u);const f=this.safeSymbol(p,t,"/");let m=this.safeString(e,"OrderType");return void 0!==m&&(m.indexOf("Bid")>=0?m="buy":m.indexOf("Offer")>=0&&(m="sell")),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:f,order:a,type:void 0,side:m,takerOrMaker:void 0,price:d,amount:h,cost:c,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={primaryCurrencyCode:r.baseId,secondaryCurrencyCode:r.quoteId,numberOfRecentTradesToRetrieve:50},o=await this.publicGetGetRecentTrades(this.extend(a,i));return this.parseTrades(o.Trades,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privatePostGetBrokerageFees(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"CurrencyCode"),a=this.safeCurrencyCode(r),o=this.safeNumber(i,"Fee");s[a]={info:i,fee:o}}const i={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],r=this.market(t),a=this.safeValue(s,r.base,{});i[t]={info:this.safeValue(a,"info"),symbol:t,maker:this.safeNumber(a,"fee"),taker:this.safeNumber(a,"fee"),percentage:!0,tierBased:!0}}return i}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e);let n=this.capitalize(t);n+="sell"===s?"Offer":"Bid";const d=this.ordered({primaryCurrencyCode:o.baseId,secondaryCurrencyCode:o.quoteId,orderType:n});let h;return d.volume=i,"limit"===t?(d.price=r,h=await this.privatePostPlaceLimitOrder(this.extend(d,a))):h=await this.privatePostPlaceMarketOrder(this.extend(d,a)),this.safeOrder({info:h,id:h.OrderGuid},o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderGuid:e},r=await this.privatePostCancelOrder(this.extend(i,s));return this.parseOrder(r)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={primaryCurrencyCode:this.currency(e).id},i=await this.privatePostGetDigitalCurrencyDepositAddress(this.extend(s,t));return this.parseDepositAddress(i)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"DepositAddress");return this.checkAddress(s),{info:e,currency:this.safeString(t,"code"),address:s,tag:this.safeString(e,"Tag"),network:void 0}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={primaryCurrencyCode:a.id,withdrawalAddress:s,amount:this.currencyToPrecision(e,t)};let d;if(void 0!==i&&(o.destinationTag=i),[d,r]=this.handleNetworkCodeAndParams(r),void 0!==d)throw new n.BadRequest(this.id+' withdraw () does not accept params["networkCode"]');const h=await this.privatePostWithdrawDigitalCurrency(this.extend(o,r));return this.parseTransaction(h,a)}parseTransaction(e,t=void 0){const s=this.safeDict(e,"Amount"),i=this.safeDict(e,"Destination"),r=this.safeString(e,"PrimaryCurrencyCode"),a=this.safeString(e,"CreatedTimestampUtc"),o=this.safeString(i,"Address"),n=this.safeString(i,"Tag"),d=this.safeCurrencyCode(r,t);return{info:e,id:this.safeString(e,"TransactionGuid"),txid:void 0,type:"withdraw",currency:d,network:void 0,amount:this.safeNumber(s,"Total"),status:this.safeString(e,"Status"),timestamp:this.parse8601(a),datetime:a,address:o,addressFrom:void 0,addressTo:o,tag:n,tagFrom:void 0,tagTo:n,updated:void 0,comment:void 0,fee:{currency:d,cost:this.safeNumber(s,"Fee"),rate:void 0},internal:!1}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n=this.urls.api[t]+"/"+e;if("public"===t)Object.keys(i).length&&(n+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const e=this.nonce(),t=[n,"apiKey="+this.apiKey,"nonce="+e.toString()],s=Object.keys(i);for(let e=0;e<s.length;e++){const r=s[e],a=i[r].toString();t.push(r+"="+a)}const d=t.join(","),h=this.hmac(this.encode(d),this.encode(this.secret),o.s),c=this.ordered({});c.apiKey=this.apiKey,c.nonce=e,c.signature=h.toUpperCase();for(let e=0;e<s.length;e++){const t=s[e];c[t]=i[t]}a=this.json(c),r={"Content-Type":"application/json"}}return{url:n,method:s,body:a,headers:r}}}},7325:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4558),r=s(2079),a=s(1579),o=s(5147),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"indodax",name:"INDODAX",countries:["ID"],rateLimit:100,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!1,fetchDepositAddress:"emulated",fetchDepositAddresses:!0,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransactionFees:!1,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},version:"2.0",urls:{logo:"https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg",api:{public:"https://indodax.com",private:"https://indodax.com/tapi"},www:"https://www.indodax.com",doc:"https://github.com/btcid/indodax-official-api-docs",referral:"https://indodax.com/ref/testbitcoincoid/1"},api:{public:{get:{"api/server_time":5,"api/pairs":5,"api/price_increments":5,"api/summaries":5,"api/ticker/{pair}":5,"api/ticker_all":5,"api/trades/{pair}":5,"api/depth/{pair}":5,"tradingview/history_v2":5}},private:{post:{getInfo:4,transHistory:4,trade:1,tradeHistory:4,openOrders:4,orderHistory:4,getOrder:4,cancelOrder:4,withdrawFee:4,withdrawCoin:4,listDownline:4,checkDownline:4,createVoucher:4}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:.003}},exceptions:{exact:{invalid_pair:r.BadSymbol,"Insufficient balance.":r.InsufficientFunds,"invalid order.":r.OrderNotFound,"Invalid credentials. API not found or session has expired.":r.AuthenticationError,"Invalid credentials. Bad sign.":r.AuthenticationError},broad:{"Minimum price":r.InvalidOrder,"Minimum order":r.InvalidOrder}},options:{recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,networks:{XLM:"Stellar Token",BSC:"bep20",TRC20:"trc20",MATIC:"polygon"},timeframes:{"1m":"1","15m":"15","30m":"30","1h":"60","4h":"240","1d":"1D","3d":"3D","1w":"1W"}},commonCurrencies:{STR:"XLM",BCHABC:"BCH",BCHSV:"BSV",DRK:"DASH",NEM:"XEM"},precisionMode:a.kb})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetApiServerTime(e);return this.safeInteger(t,"server_time")}async fetchMarkets(e={}){const t=await this.publicGetApiPairs(e),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"ticker_id"),a=this.safeString(i,"traded_currency"),o=this.safeString(i,"base_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeInteger(i,"is_maintenance");s.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!h,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(i,"trade_fee_percent"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,percentage:!0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber(this.parsePrecision(this.safeString(i,"price_round"))),cost:this.parseNumber(this.parsePrecision(this.safeString(i,"volume_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,"trade_min_traded_currency"),max:void 0},price:{min:this.safeNumber(i,"trade_min_base_currency"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:i})}return s}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"balance",{}),i=this.safeValue(t,"balance_hold",{}),r=this.safeTimestamp(t,"server_time"),a={info:e,timestamp:r,datetime:this.iso8601(r)},o=Object.keys(s);for(let e=0;e<o.length;e++){const t=o[e],r=this.safeCurrencyCode(t),n=this.account();n.free=this.safeString(s,t),n.used=this.safeString(i,t),a[r]=n}return this.safeBalance(a)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.base+i.quote},a=await this.publicGetApiDepthPair(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"buy","sell")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"server_time"),r="vol_"+t.baseId.toLowerCase(),a="vol_"+t.quoteId.toLowerCase(),o=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,r),quoteVolume:this.safeString(e,a),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.base+s.quote},r=await this.publicGetApiTickerPair(this.extend(i,t)),a=this.safeDict(r,"ticker",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetApiTickerAll(t),i=this.safeDict(s,"tickers",{});return this.parseTickers(i,e)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"date");return this.safeTrade({id:this.safeString(e,"tid"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),type:void 0,side:this.safeString(e,"type"),order:void 0,takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.base+r.quote},o=await this.publicGetApiTradesPair(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"Time"),this.safeNumber(e,"Open"),this.safeNumber(e,"High"),this.safeNumber(e,"Low"),this.safeNumber(e,"Close"),this.safeNumber(e,"Volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.options.timeframes,n=this.safeString(o,t,t),d=this.seconds(),h=this.safeInteger(r,"until",d);r=this.omit(r,["until"]);const c={to:h,tf:n,symbol:a.base+a.quote};if(void 0===i&&(i=1e3),void 0!==s)c.from=Math.floor(s/1e3);else{const e=this.parseTimeframe(t);c.from=d-i*e-1}const l=await this.publicGetTradingviewHistoryV2(this.extend(c,r));return this.parseOHLCVs(l,a,t,s,i)}parseOrderStatus(e){return this.safeString({open:"open",filled:"closed",cancelled:"canceled"},e,e)}parseOrder(e,t=void 0){let s;"type"in e&&(s=e.type);const i=this.parseOrderStatus(this.safeString(e,"status","open"));let r,a;const o=this.safeString(e,"price");let n,d;const h=this.safeString(e,"pair");if(void 0!==(t=this.safeMarket(h,t))){r=t.symbol;let s=t.quoteId,i=t.baseId;"idr"===t.quoteId&&"order_rp"in e&&(s="rp"),"idr"===t.baseId&&"remain_rp"in e&&(i="rp"),a=this.safeString(e,"order_"+s),a||(n=this.safeString(e,"order_"+i),d=this.safeString(e,"remain_"+i))}const c=this.safeInteger(e,"submit_time"),l=this.safeString(e,"order_id");return this.safeOrder({info:e,id:l,clientOrderId:this.safeString(e,"client_order_id"),timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,symbol:r,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:o,stopPrice:void 0,triggerPrice:void 0,cost:a,average:void 0,amount:n,filled:void 0,remaining:d,status:i,fee:undefined,trades:void 0})}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={pair:i.id,order_id:e},o=await this.privatePostGetOrder(this.extend(a,s)),n=o.return,d=this.parseOrder(this.extend({id:e},n.order),i);return d.info=o,d}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.pair=r.id);const o=(await this.privatePostOpenOrders(this.extend(a,i))).return.orders;if(!o)return[];if(void 0!==e)return this.parseOrders(o,r,t,s);const n=Object.keys(o);let d=[];for(let e=0;e<n.length;e++){const i=n[e],a=o[i];r=this.safeMarket(i);const h=this.parseOrders(a,r,t,s);d=this.arrayConcat(d,h)}return d}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchClosedOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id},n=await this.privatePostOrderHistory(this.extend(o,i));let d=this.parseOrders(n.return.orders,a);return d=this.filterBy(d,"status","closed"),this.filterBySymbolSinceLimit(d,e,t,s)}async createOrder(e,t,s,i,a=void 0,n={}){await this.loadMarkets();const d=this.market(e),h={pair:d.id,type:s,price:a};let c=!1,l=!1;if("market"===t)if("buy"===s){let t;const s=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==s)t=this.costToPrecision(e,s);else{if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price).");const s=this.numberToString(i),n=this.numberToString(a),d=o.Y.stringMul(s,n);t=this.costToPrecision(e,d)}h[d.quoteId]=t}else l=!0;else"limit"===t&&(c=!0,l=!0);if(c){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument for a "+t+" order");h.price=a}l&&(h[d.baseId]=this.amountToPrecision(e,i));const u=await this.privatePostTrade(this.extend(h,n)),p=this.safeValue(u,"return",{}),f=this.safeString(p,"order_id");return this.safeOrder({info:u,id:f},d)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const i=this.safeValue(s,"side");if(void 0===i)throw new r.ArgumentsRequired(this.id+' cancelOrder() requires an extra "side" param');await this.loadMarkets();const a={order_id:e,pair:this.market(t).id,type:i},o=await this.privatePostCancelOrder(this.extend(a,s)),n=this.safeDict(o,"return");return this.parseOrder(n)}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.privatePostWithdrawFee(this.extend(i,t)),a=this.safeValue(r,"return",{}),o=this.safeString(a,"currency");return{info:r,rate:this.safeNumber(a,"withdraw_fee"),currency:this.safeCurrencyCode(o,s)}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};if(void 0!==t){const e=this.iso8601(t).slice(0,10);r.start=e,r.end=this.iso8601(this.milliseconds()).slice(0,10)}const a=await this.privatePostTransHistory(this.extend(r,i)),o=this.safeValue(a,"return",{}),n=this.safeValue(o,"withdraw",{}),d=this.safeValue(o,"deposit",{});let h,c=[];if(void 0===e){let e=Object.keys(n);for(let t=0;t<e.length;t++){const s=e[t];c=this.arrayConcat(c,n[s])}e=Object.keys(d);for(let t=0;t<e.length;t++){const s=e[t];c=this.arrayConcat(c,d[s])}}else{h=this.currency(e);const t=this.safeValue(n,h.id,[]),s=this.safeValue(d,h.id,[]);c=this.arrayConcat(t,s)}return this.parseTransactions(c,h,t,s)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o=this.milliseconds(),n={currency:a.id,withdraw_amount:t,withdraw_address:s,request_id:o.toString()};i&&(n.withdraw_memo=i);const d=await this.privatePostWithdrawCoin(this.extend(n,r));return this.parseTransaction(d,a)}parseTransaction(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeTimestamp2(e,"success_time","submit_time"),r=this.safeString(e,"deposit_id"),a=this.safeNumber(e,"fee");let o;return void 0!==a&&(o={currency:this.safeCurrencyCode(void 0,t),cost:a,rate:void 0}),{id:this.safeString2(e,"withdraw_id","deposit_id"),txid:this.safeString2(e,"txid","tx"),timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:void 0,address:this.safeString(e,"withdraw_address"),addressTo:void 0,amount:this.safeNumberN(e,["amount","withdraw_amount","deposit_amount"]),type:void 0===r?"withdraw":"deposit",currency:this.safeCurrencyCode(void 0,t),status:this.parseTransactionStatus(s),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"withdraw_memo"),internal:void 0,fee:o,info:e}}parseTransactionStatus(e){return this.safeString({success:"ok"},e,e)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostGetInfo(t),i=this.safeDict(s,"return"),r=this.safeDict(i,"address",{}),a=this.safeDict(i,"network",{}),o=Object.keys(r),n={info:i};for(let t=0;t<o.length;t++){const s=o[t],i=this.safeCurrencyCode(s),d=this.safeString(r,s);if(void 0!==d&&(void 0===e||this.inArray(i,e))){let e;if(this.checkAddress(d),s in a){const t=this.safeString(a,s);if(t.indexOf(",")>=0){e=[];const s=t.split(",");for(let t=0;t<s.length;t++)e.push(this.networkIdToCode(s[t]).toUpperCase())}else e=this.networkIdToCode(t).toUpperCase()}n[i]={info:{},currency:i,address:d,network:e,tag:void 0}}}return n}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t];if("public"===t){const t=this.omit(i,this.extractParams(e));o+="/"+this.implodeParams(e,i),Object.keys(t).length&&(o+="?"+this.urlencodeWithArrayRepeat(t))}else this.checkRequiredCredentials(),a=this.urlencode(this.extend({method:e,timestamp:this.nonce(),recvWindow:this.options.recvWindow},i)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),n.Zf)};return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(Array.isArray(n))return;const c=this.safeValue(n,"error","");if(!("success"in n)&&""===c)return;if(1===this.safeInteger(n,"success",0)){if("return"in n)return;throw new r.ExchangeError(this.id+": malformed response: "+this.json(n))}const l=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwBroadlyMatchedException(this.exceptions.broad,c,l),new r.ExchangeError(l)}}},8042:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(2459),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(7481);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"kraken",name:"Kraken",countries:["US"],version:"0",rateLimit:1e3,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTrailingAmountOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLedgerEntry:!0,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderTrades:"emulated",fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"4h":240,"1d":1440,"1w":10080,"2w":21600},urls:{logo:"https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg",api:{public:"https://api.kraken.com",private:"https://api.kraken.com",zendesk:"https://kraken.zendesk.com/api/v2/help_center/en-us/articles"},www:"https://www.kraken.com",doc:"https://docs.kraken.com/rest/",fees:"https://www.kraken.com/en-us/features/fee-schedule"},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0026"),maker:this.parseNumber("0.0016"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0026")],[this.parseNumber("50000"),this.parseNumber("0.0024")],[this.parseNumber("100000"),this.parseNumber("0.0022")],[this.parseNumber("250000"),this.parseNumber("0.0020")],[this.parseNumber("500000"),this.parseNumber("0.0018")],[this.parseNumber("1000000"),this.parseNumber("0.0016")],[this.parseNumber("2500000"),this.parseNumber("0.0014")],[this.parseNumber("5000000"),this.parseNumber("0.0012")],[this.parseNumber("10000000"),this.parseNumber("0.0001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0016")],[this.parseNumber("50000"),this.parseNumber("0.0014")],[this.parseNumber("100000"),this.parseNumber("0.0012")],[this.parseNumber("250000"),this.parseNumber("0.0010")],[this.parseNumber("500000"),this.parseNumber("0.0008")],[this.parseNumber("1000000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0004")],[this.parseNumber("5000000"),this.parseNumber("0.0002")],[this.parseNumber("10000000"),this.parseNumber("0.0")]]}}},handleContentTypeApplicationZip:!0,api:{zendesk:{get:["360000292886","201893608"]},public:{get:{Assets:1,AssetPairs:1,Depth:1.2,OHLC:1.2,Spread:1,SystemStatus:1,Ticker:1,Time:1,Trades:1.2}},private:{post:{AddOrder:0,AddOrderBatch:0,AddExport:3,Balance:3,CancelAll:3,CancelAllOrdersAfter:3,CancelOrder:0,CancelOrderBatch:0,ClosedOrders:3,DepositAddresses:3,DepositMethods:3,DepositStatus:3,EditOrder:0,ExportStatus:3,GetWebSocketsToken:3,Ledgers:6,OpenOrders:3,OpenPositions:3,QueryLedgers:3,QueryOrders:3,QueryTrades:3,RetrieveExport:3,RemoveExport:3,BalanceEx:3,TradeBalance:3,TradesHistory:6,TradeVolume:3,Withdraw:3,WithdrawCancel:3,WithdrawInfo:3,WithdrawMethods:3,WithdrawAddresses:3,WithdrawStatus:3,WalletTransfer:3,CreateSubaccount:3,AccountTransfer:3,"Earn/Allocate":3,"Earn/Deallocate":3,"Earn/AllocateStatus":3,"Earn/DeallocateStatus":3,"Earn/Strategies":3,"Earn/Allocations":3}}},commonCurrencies:{LUNA:"LUNC",LUNA2:"LUNA",REPV2:"REP",REP:"REPV1",UST:"USTC",XBT:"BTC","XBT.M":"BTC.M",XDG:"DOGE"},options:{marketsByAltname:{},delistedMarketsById:{},inactiveCurrencies:["CAD","USD","JPY","GBP"],networks:{ETH:"ERC20",TRX:"TRC20"},depositMethods:{"1INCH":"1inch (1INCH)",AAVE:"Aave",ADA:"ADA",ALGO:"Algorand",ANKR:"ANKR (ANKR)",ANT:"Aragon (ANT)",ATOM:"Cosmos",AXS:"Axie Infinity Shards (AXS)",BADGER:"Bager DAO (BADGER)",BAL:"Balancer (BAL)",BAND:"Band Protocol (BAND)",BAT:"BAT",BCH:"Bitcoin Cash",BNC:"Bifrost (BNC)",BNT:"Bancor (BNT)",BTC:"Bitcoin",CHZ:"Chiliz (CHZ)",COMP:"Compound (COMP)",CQT:"\tCovalent Query Token (CQT)",CRV:"Curve DAO Token (CRV)",CTSI:"Cartesi (CTSI)",DAI:"Dai",DASH:"Dash",DOGE:"Dogecoin",DOT:"Polkadot",DYDX:"dYdX (DYDX)",ENJ:"Enjin Coin (ENJ)",EOS:"EOS",ETC:"Ether Classic (Hex)",ETH:"Ether (Hex)",EWT:"Energy Web Token",FEE:"Kraken Fee Credit",FIL:"Filecoin",FLOW:"Flow",GHST:"Aavegotchi (GHST)",GNO:"GNO",GRT:"GRT",ICX:"Icon",INJ:"Injective Protocol (INJ)",KAR:"Karura (KAR)",KAVA:"Kava",KEEP:"Keep Token (KEEP)",KNC:"Kyber Network (KNC)",KSM:"Kusama",LINK:"Link",LPT:"Livepeer Token (LPT)",LRC:"Loopring (LRC)",LSK:"Lisk",LTC:"Litecoin",MANA:"MANA",MATIC:"Polygon (MATIC)",MINA:"Mina",MIR:"Mirror Protocol (MIR)",MKR:"Maker (MKR)",MLN:"MLN",MOVR:"Moonriver (MOVR)",NANO:"NANO",OCEAN:"OCEAN",OGN:"Origin Protocol (OGN)",OMG:"OMG",OXT:"Orchid (OXT)",OXY:"Oxygen (OXY)",PAXG:"PAX (Gold)",PERP:"Perpetual Protocol (PERP)",PHA:"Phala (PHA)",QTUM:"QTUM",RARI:"Rarible (RARI)",RAY:"Raydium (RAY)",REN:"Ren Protocol (REN)",REP:"REPv2",REPV1:"REP",SAND:"The Sandbox (SAND)",SC:"Siacoin",SDN:"Shiden (SDN)",SOL:"Solana",SNX:"Synthetix  Network (SNX)",SRM:"Serum",STORJ:"Storj (STORJ)",SUSHI:"Sushiswap (SUSHI)",TBTC:"tBTC",TRX:"Tron",UNI:"UNI",USDC:"USDC",USDT:"Tether USD (ERC20)","USDT-TRC20":"Tether USD (TRC20)",WAVES:"Waves",WBTC:"Wrapped Bitcoin (WBTC)",XLM:"Stellar XLM",XMR:"Monero",XRP:"Ripple XRP",XTZ:"XTZ",YFI:"YFI",ZEC:"Zcash (Transparent)",ZRX:"0x (ZRX)"},withdrawMethods:{Lightning:"Lightning",Bitcoin:"BTC",Ripple:"XRP",Litecoin:"LTC",Dogecoin:"DOGE",Stellar:"XLM",Ethereum:"ERC20","Arbitrum One":"Arbitrum",Polygon:"MATIC","Arbitrum Nova":"Arbitrum",Optimism:"Optimism","zkSync Era":"zkSync","Ethereum Classic":"ETC",Zcash:"ZEC",Monero:"XMR",Tron:"TRC20",Solana:"SOL",EOS:"EOS","Bitcoin Cash":"BCH",Cardano:"ADA",Qtum:"QTUM",Tezos:"XTZ",Cosmos:"ATOM",Nano:"NANO",Siacoin:"SC",Lisk:"LSK",Waves:"WAVES",ICON:"ICX",Algorand:"ALGO","Polygon - USDC.e":"MATIC","Arbitrum One - USDC.e":"Arbitrum",Polkadot:"DOT",Kava:"KAVA",Filecoin:"FIL",Kusama:"KSM",Flow:"FLOW","Energy Web":"EW",Mina:"MINA",Centrifuge:"CFG",Karura:"KAR",Moonriver:"MOVR",Shiden:"SDN",Khala:"PHA","Bifrost Kusama":"BNC",Songbird:"SGB","Terra classic":"LUNC",KILT:"KILT",Basilisk:"BSX",Flare:"FLR","Avalanche C-Chain":"AVAX",Kintsugi:"KINT",Altair:"AIR",Moonbeam:"GLMR",Acala:"ACA",Astar:"ASTR",Akash:"AKT",Robonomics:"XRT",Fantom:"FTM",Elrond:"EGLD",THORchain:"RUNE",Secret:"SCRT",Near:"NEAR","Internet Computer Protocol":"ICP",Picasso:"PICA","Crust Shadow":"CSM",Integritee:"TEER","Parallel Finance":"PARA",HydraDX:"HDX",Interlay:"INTR","Fetch.ai":"FET",NYM:"NYM","Terra 2.0":"LUNA2",Juno:"JUNO",Nodle:"NODL",Stacks:"STX","Ethereum PoW":"ETHW",Aptos:"APT",Sui:"SUI",Genshiro:"GENS",Aventus:"AVT",Sei:"SEI",OriginTrail:"OTP",Celestia:"TIA"}},precisionMode:o.kb,exceptions:{"EQuery:Invalid asset pair":r.BadSymbol,"EAPI:Invalid key":r.AuthenticationError,"EFunding:Unknown withdraw key":r.InvalidAddress,"EFunding:Invalid amount":r.InsufficientFunds,"EService:Unavailable":r.ExchangeNotAvailable,"EDatabase:Internal error":r.ExchangeNotAvailable,"EService:Busy":r.ExchangeNotAvailable,"EQuery:Unknown asset":r.BadSymbol,"EAPI:Rate limit exceeded":r.DDoSProtection,"EOrder:Rate limit exceeded":r.DDoSProtection,"EGeneral:Internal error":r.ExchangeNotAvailable,"EGeneral:Temporary lockout":r.DDoSProtection,"EGeneral:Permission denied":r.PermissionDenied,"EOrder:Unknown order":r.InvalidOrder,"EOrder:Order minimum not met":r.InvalidOrder,"EGeneral:Invalid arguments":r.BadRequest,"ESession:Invalid session":r.AuthenticationError,"EAPI:Invalid nonce":r.InvalidNonce,"EFunding:No funding method":r.BadRequest,"EFunding:Unknown asset":r.BadSymbol,"EService:Market in post_only mode":r.OnMaintenance,"EGeneral:Too many requests":r.DDoSProtection,"ETrade:User Locked":r.AccountSuspended}})}feeToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.amount,this.precisionMode)}async fetchMarkets(e={}){const t=await this.publicGetAssetPairs(e),s=this.safeValue(t,"result",{}),i=Object.keys(s);let r=[];for(let e=0;e<i.length;e++){const t=i[e],o=s[t],n=this.safeString(o,"base"),d=this.safeString(o,"quote"),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=t.indexOf(".d")>=0,u=this.safeString(o,"altname"),p=this.safeValue(o,"fees_maker",[]),f=this.safeValue(p,0,[]),m=this.safeString(f,1);let g;void 0!==m&&(g=this.parseNumber(a.Y.stringDiv(m,"100")));const v=this.safeValue(o,"fees",[]),y=this.safeValue(v,0,[]),w=this.safeString(y,1);let b;void 0!==w&&(b=this.parseNumber(a.Y.stringDiv(w,"100")));const S=this.safeValue(o,"leverage_buy",[]),k=S.length,O=this.parseNumber(this.parsePrecision(this.safeString(o,"pair_decimals"))),T="online"===this.safeString(o,"status");r.push({id:t,wsId:this.safeString(o,"wsname"),symbol:l?u:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,darkpool:l,altname:o.altname,type:"spot",spot:!0,margin:k>0,swap:!1,future:!1,option:!1,active:T,contract:!1,linear:void 0,inverse:void 0,taker:b,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"lot_decimals"))),price:O},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(S,k-1,1)},amount:{min:this.safeNumber(o,"ordermin"),max:void 0},price:{min:O,max:void 0},cost:{min:this.safeNumber(o,"costmin"),max:void 0}},created:void 0,info:o})}return r=this.appendInactiveMarkets(r),this.options.marketsByAltname=this.indexBy(r,"altname"),r}safeCurrency(e,t=void 0){return void 0!==e&&e.length>3&&(0!==e.indexOf("X")&&0!==e.indexOf("Z")||e.indexOf(".")>0||(e=e.slice(1))),super.safeCurrency(e,t)}appendInactiveMarkets(e){const t={amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-8")},s={darkpool:!1,info:void 0,maker:void 0,taker:void 0,active:!1,precision:t,limits:{amount:{min:t.amount,max:void 0},price:{min:t.price,max:void 0},cost:{min:void 0,max:void 0}}},i=[];for(let t=0;t<i.length;t++)e.push(this.extend(s,i[t]));return e}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e),s=this.safeDict(t,"result");return{status:"online"===this.safeString(s,"status")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"result",{}),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],a=s[t],o=this.safeCurrencyCode(t),n=this.parseNumber(this.parsePrecision(this.safeString(a,"decimals"))),d="enabled"===this.safeString(a,"status");r[o]={id:t,code:o,info:a,name:this.safeString(a,"altname"),active:d,deposit:void 0,withdraw:void 0,fee:void 0,precision:n,limits:{amount:{min:n,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}return r}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id,"fee-info":!0},r=await this.privatePostTradeVolume(this.extend(i,t)),a=this.safeValue(r,"result",{});return this.parseTradingFee(a,s)}parseTradingFee(e,t){const s=this.safeValue(e,"fees_maker",{}),i=this.safeValue(e,"fees",{}),r=this.safeValue(s,t.id,{}),o=this.safeValue(i,t.id,{});return{info:e,symbol:t.symbol,maker:this.parseNumber(a.Y.stringDiv(this.safeString(r,"fee"),"100")),taker:this.parseNumber(a.Y.stringDiv(this.safeString(o,"fee"),"100")),percentage:!0,tierBased:!0}}parseBidAsk(e,t=0,s=1,i=2){return[this.safeNumber(e,t),this.safeNumber(e,s),this.safeInteger(e,2)]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);if(i.darkpool)throw new r.ExchangeError(this.id+" fetchOrderBook() does not provide an order book for darkpool symbol "+e);const a={pair:i.id};void 0!==t&&(a.count=t);const o=await this.publicGetDepth(this.extend(a,s)),n=this.safeValue(o,"result",{});let d=this.safeValue(n,i.id);const h=this.safeValue(i,"info",{}),c=this.safeValue(h,"wsname");return void 0!==c&&(d=this.safeValue(n,c,d)),this.parseOrderBook(d,e)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeValue(e,"v",[]),r=this.safeString(i,1),o=this.safeValue(e,"p",[]),n=this.safeString(o,1),d=a.Y.stringMul(r,n),h=this.safeValue(e,"c",[]),c=this.safeString(h,0),l=this.safeValue(e,"h",[]),u=this.safeValue(e,"l",[]),p=this.safeValue(e,"b",[]),f=this.safeValue(e,"a",[]);return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(l,1),low:this.safeString(u,1),bid:this.safeString(p,0),bidVolume:void 0,ask:this.safeString(f,0),askVolume:void 0,vwap:n,open:this.safeString(e,"o"),close:c,last:c,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){e=this.marketSymbols(e);const t=[];for(let s=0;s<e.length;s++){const i=e[s],r=this.markets[i];r.active&&!r.darkpool&&t.push(r.id)}s.pair=t.join(",")}const i=(await this.publicGetTicker(this.extend(s,t))).result,r=Object.keys(i),a={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeMarket(t),o=s.symbol,n=i[t];a[o]=this.parseTicker(n,s)}return this.filterByArrayTickers(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();if(e.indexOf(".d")>=0)throw new r.ExchangeError(this.id+" fetchTicker() does not provide a ticker for darkpool symbol "+e);const s=this.market(e),i={pair:s.id},a=(await this.publicGetTicker(this.extend(i,t))).result[s.id];return this.parseTicker(a,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,720);const o=this.market(e),n=this.safeInteger(this.timeframes,t),d={pair:o.id};if(d.interval=void 0!==n?n:t,void 0!==s){const e=this.parseToInt(s/1e3),t=60*n;d.since=this.numberToString(e-t)}const h=await this.publicGetOHLC(this.extend(d,r)),c=this.safeValue(h,"result",{}),l=this.safeList(c,o.id,[]);return this.parseOHLCVs(l,o,t,s,i)}parseLedgerEntryType(e){return this.safeString({trade:"trade",withdrawal:"transaction",deposit:"transaction",transfer:"transfer",margin:"margin"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id");let i;const r=this.safeString(e,"refid"),o=this.parseLedgerEntryType(this.safeString(e,"type")),n=this.safeCurrencyCode(this.safeString(e,"asset"),t);let d=this.safeString(e,"amount");a.Y.stringLt(d,"0")?(i="out",d=a.Y.stringAbs(d)):i="in";const h=this.safeIntegerProduct(e,"time",1e3);return{info:e,id:s,direction:i,account:undefined,referenceId:r,referenceAccount:undefined,type:o,currency:n,amount:this.parseNumber(d),before:void 0,after:this.safeNumber(e,"balance"),status:"ok",timestamp:h,datetime:this.iso8601(h),fee:{cost:this.safeNumber(e,"fee"),currency:n}}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let o;void 0!==e&&(o=this.currency(e),r.asset=o.id),void 0!==t&&(r.start=this.parseToInt(t/1e3));const n=this.safeStringN(i,["until","till"]);if(void 0!==n){i=this.omit(i,["until","till"]);const e=a.Y.stringDiv(n,"1000");r.end=this.parseToInt(a.Y.stringAdd(e,"1"))}const d=await this.privatePostLedgers(this.extend(r,i)),h=this.safeValue(d,"result",{}),c=this.safeValue(h,"ledger",{}),l=Object.keys(c),u=[];for(let e=0;e<l.length;e++){const t=l[e],s=c[t];s.id=t,u.push(s)}return this.parseLedger(u,o,t,s)}async fetchLedgerEntriesByIds(e,t=void 0,s={}){await this.loadMarkets(),e=e.join(",");const i=this.extend({id:e},s),r=(await this.privatePostQueryLedgers(i)).result,a=Object.keys(r),o=[];for(let e=0;e<a.length;e++){const t=a[e],s=r[t];s.id=t,o.push(s)}return this.parseLedger(o)}async fetchLedgerEntry(e,t=void 0,s={}){return(await this.fetchLedgerEntriesByIds([e],t,s))[0]}parseTrade(e,t=void 0){let s,i,r,a,o,n,d,h,c;if(Array.isArray(e)){s=this.safeTimestamp(e,2),i="s"===e[3]?"sell":"buy",r="l"===e[4]?"limit":"market",a=this.safeString(e,0),o=this.safeString(e,1);e.length>6&&(n=this.safeString(e,6))}else if("string"==typeof e)n=e;else if("ordertxid"in e){const c=this.safeString(e,"pair"),l=this.findMarketByAltnameOrId(c);if(void 0!==l?t=l:void 0!==c&&(t=this.getDelistedMarketById(c)),d=this.safeString(e,"ordertxid"),n=this.safeString2(e,"id","postxid"),s=this.safeTimestamp(e,"time"),i=this.safeString(e,"type"),r=this.safeString(e,"ordertype"),a=this.safeString(e,"price"),o=this.safeString(e,"vol"),"fee"in e){let s;void 0!==t&&(s=t.quote),h={cost:this.safeString(e,"fee"),currency:s}}}void 0!==t&&(c=t.symbol);const l=this.safeString(e,"cost"),u=this.safeBool(e,"maker");let p;return void 0!==u&&(p=u?"maker":"taker"),this.safeTrade({id:n,order:d,info:e,timestamp:s,datetime:this.iso8601(s),symbol:c,type:r,side:i,takerOrMaker:p,price:a,amount:o,cost:l,fee:h},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a=r.id,o={pair:a};void 0!==t&&(o.since=this.numberToString(this.parseToInt(t/1e3))),void 0!==s&&(o.count=s);const n=(await this.publicGetTrades(this.extend(o,i))).result,d=n[a],h=d.length;if(h<=0)return[];const c=d[h-1],l=this.safeString(n,"last");return c.push(l),d[h-1]=c,this.parseTrades(d,r,t,s)}parseBalance(e){const t=this.safeValue(e,"result",{}),s={info:e,timestamp:void 0,datetime:void 0},i=Object.keys(t);for(let e=0;e<i.length;e++){const r=i[e],a=this.safeCurrencyCode(r),o=this.safeValue(t,r,{}),n=this.account();n.used=this.safeString(o,"hold_trade"),n.total=this.safeString(o,"balance"),s[a]=n}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostBalanceEx(e);return this.parseBalance(t)}async createMarketOrderWithCost(e,t,s,i={}){return await this.loadMarkets(),i.cost=s,await this.createOrder(e,"market",t,s,void 0,i)}async createMarketBuyOrderWithCost(e,t,s={}){return await this.loadMarkets(),await this.createMarketOrderWithCost(e,"buy",t,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o={pair:this.market(e).id,type:s,ordertype:t,volume:this.amountToPrecision(e,i)},n=this.orderRequest("createOrder",e,t,o,i,r,a),d=await this.privatePostAddOrder(this.extend(n[0],n[1])),h=this.safeDict(d,"result");return this.parseOrder(h)}findMarketByAltnameOrId(e){const t=this.safeValue(this.options,"marketsByAltname",{});return e in t?t[e]:this.safeMarket(e)}getDelistedMarketById(e){if(void 0===e)return e;let t=this.safeValue(this.options.delistedMarketsById,e);if(void 0!==t)return t;let s=3,i=3,r=6;8===e.length?(s=4,i=4,r=8):7===e.length&&(s=4,i=4,r=7);const a=e.slice(0,s),o=e.slice(i,r),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);return t={symbol:n+"/"+d,base:n,quote:d,baseId:a,quoteId:o},this.options.delistedMarketsById[e]=t,t}parseOrderStatus(e){return this.safeString({pending:"open",open:"open",closed:"closed",canceled:"canceled",expired:"expired"},e,e)}parseOrderType(e){return this.safeString({"take-profit":"market","stop-loss-limit":"limit","stop-loss":"market","take-profit-limit":"limit","trailing-stop-limit":"limit"},e,e)}parseOrder(e,t=void 0){const s=this.safeDict(e,"descr",{}),i=this.safeDict(e,"descr");let r,o,n,d,h,c,l;if(r=void 0!==i?this.safeString(i,"order"):this.safeString(e,"descr"),void 0!==r){const e=r.split(" ");o=this.safeString(e,0),c=this.safeString(e,1),d=this.safeString(e,2),n=this.safeString(e,4),"stop"===n?(l=this.safeString(e,6),h=this.safeString(e,9)):"limit"===n&&(h=this.safeString(e,5))}o=this.safeString(s,"type",o),n=this.safeString(s,"ordertype",n),d=this.safeString(s,"pair",d);const u=this.findMarketByAltnameOrId(d);let p;void 0!==u?t=u:void 0!==d&&(t=this.getDelistedMarketById(d));const f=this.safeTimestamp(e,"opentm");c=this.safeString(e,"vol",c);const m=this.safeString(e,"vol_exec");let g;h=this.safeString(s,"price",h),void 0!==h&&h.endsWith("%")&&(h=void 0),(void 0===h||a.Y.stringEquals(h,"0"))&&(h=this.safeString(s,"price2")),(void 0===h||a.Y.stringEquals(h,"0"))&&(h=this.safeString(e,"price",h));const v=this.safeString(e,"oflags",""),y=v.indexOf("post")>-1,w=this.safeNumber(e,"price");if(void 0!==t&&(p=t.symbol,"fee"in e)){g={cost:this.safeString(e,"fee"),rate:void 0},v.indexOf("fciq")>=0?g.currency=t.quote:v.indexOf("fcib")>=0&&(g.currency=t.base)}const b=this.parseOrderStatus(this.safeString(e,"status"));let S=this.safeString2(e,"id","txid");if(void 0===S||S.startsWith("[")){const t=this.safeList(e,"txid");S=this.safeString(t,0)}const k=this.safeString2(e,"userref","newuserref"),O=this.safeValue(e,"trades",[]),T=[];for(let e=0;e<O.length;e++){const t=O[e];"string"==typeof t?T.push(this.safeTrade({id:t,orderId:S,symbol:p,info:{}})):T.push(t)}let P,I;return l=this.omitZero(this.safeString(e,"stopprice",l)),n.startsWith("take-profit")?(I=this.safeString(s,"price"),h=this.omitZero(this.safeString(s,"price2"))):n.startsWith("stop-loss")&&(P=this.safeString(s,"price"),h=this.omitZero(this.safeString(s,"price2"))),this.safeOrder({id:S,clientOrderId:k,info:e,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,status:b,symbol:p,type:this.parseOrderType(n),timeInForce:void 0,postOnly:y,side:o,price:h,stopPrice:l,triggerPrice:l,takeProfitPrice:I,stopLossPrice:P,cost:void 0,amount:c,filled:m,average:w,remaining:void 0,reduceOnly:this.safeBool2(e,"reduceOnly","reduce_only"),fee:g,trades:T},t)}orderRequest(e,t,s,i,r,a=void 0,o={}){const n=this.safeString2(o,"userref","clientOrderId");o=this.omit(o,["userref","clientOrderId"]),void 0!==n&&(i.userref=n);const d=this.safeString(o,"stopLossPrice"),h=this.safeString(o,"takeProfitPrice"),c=void 0!==d,l=void 0!==h,u=c||l,p=this.safeString(o,"trailingAmount"),f=this.safeString(o,"trailingLimitAmount"),m=void 0!==p,g=s.endsWith("limit"),v="market"===s,y=this.safeString(o,"cost"),w=this.safeString(o,"oflags");o=this.omit(o,["cost","oflags"]);const b=void 0!==w&&w.indexOf("viqc")>-1;if(v&&(void 0!==y||b)){i.volume=void 0===y&&void 0!==r?this.costToPrecision(t,this.numberToString(r)):this.costToPrecision(t,y);const e=void 0!==w?w+",viqc":"viqc";i.oflags=e}else g&&!m&&(i.price=this.priceToPrecision(t,a));const S=this.safeBool2(o,"reduceOnly","reduce_only");if(u)c?(i.price=this.priceToPrecision(t,d),i.ordertype=g?"stop-loss-limit":"stop-loss"):l&&(i.price=this.priceToPrecision(t,h),i.ordertype=g?"take-profit-limit":"take-profit"),g&&(i.price2=this.priceToPrecision(t,a));else if(m){const e=this.safeString(o,"trigger","last"),t="+"+p;if(i.trigger=e,g||void 0!==f){const e=this.safeString(o,"offset","-")+this.numberToString(f);i.price=t,i.price2=e,i.ordertype="trailing-stop-limit"}else i.price=t,i.ordertype="trailing-stop"}S&&(i.reduce_only="createOrderWs"===e||"true");let k=this.safeDict(o,"close");if(void 0!==k){k=this.extend({},k);const e=this.safeValue(k,"price");void 0!==e&&(k.price=this.priceToPrecision(t,e));const s=this.safeValue(k,"price2");void 0!==s&&(k.price2=this.priceToPrecision(t,s)),i.close=k}const O=this.safeString2(o,"timeInForce","timeinforce");void 0!==O&&(i.timeinforce=O);const T="market"===s;let P;if([P,o]=this.handlePostOnly(T,!1,o),P){const e=void 0!==w?w+",post":"post";i.oflags=e}return void 0===w||"oflags"in i||(i.oflags=w),[i,o=this.omit(o,["timeInForce","reduceOnly","stopLossPrice","takeProfitPrice","trailingAmount","trailingLimitAmount","offset"])]}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);if(!d.spot)throw new r.NotSupported(this.id+" editOrder() does not support "+d.type+" orders, only spot orders are accepted");const h={txid:e,pair:d.id};void 0!==a&&(h.volume=this.amountToPrecision(t,a));const c=this.orderRequest("editOrder",t,s,h,a,o,n),l=await this.privatePostEditOrder(this.extend(c[0],c[1])),u=this.safeDict(l,"result",{});return this.parseOrder(u,d)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue2(s,"userref","clientOrderId"),a={trades:!0,txid:e};let o=s;void 0!==i&&(a.userref=i,o=this.omit(s,["userref","clientOrderId"]));const n=await this.privatePostQueryOrders(this.extend(a,o)),d=this.safeValue(n,"result",[]);if(!(e in d))throw new r.OrderNotFound(this.id+" fetchOrder() could not find order id "+e);return this.parseOrder(this.extend({id:e},d[e]))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){const o=this.safeValue(a,"trades"),n=[];if(void 0===o)throw new r.ArgumentsRequired(this.id+" fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)");for(let e=0;e<o.length;e++){const t=o[e];"string"==typeof t?n.push(t):n.push(t.id)}await this.loadMarkets(),void 0!==t&&(t=this.symbol(t));const d=this.safeValue(this.options,"fetchOrderTrades",{}),h=this.safeInteger(d,"batchSize",20),c=n.length;let l=this.parseToInt(c/h);l=this.sum(l,1);let u=[];for(let e=0;e<l;e++){const r=[];for(let t=0;t<h;t++){const s=this.sum(e*h,t);s<c&&r.push(n[s])}const a={txid:r.join(",")},o=await this.privatePostQueryTrades(a),d=this.safeValue(o,"result"),l=Object.keys(d);for(let e=0;e<l.length;e++)d[l[e]].id=l[e];const p=this.parseTrades(d,void 0,s,i),f=this.filterBySymbol(p,t);u=this.arrayConcat(u,f)}return u}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostQueryOrders(this.extend({trades:!0,txid:e.join(",")},s)),r=this.safeValue(i,"result",{}),a=[],o=Object.keys(r);for(let e=0;e<o.length;e++){const t=o[e],s=r[t],i=this.parseOrder(this.extend({id:t},s));a.push(i)}return a}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==t&&(r.start=this.parseToInt(t/1e3));const o=this.safeStringN(i,["until","till"]);if(void 0!==o){i=this.omit(i,["until","till"]);const e=a.Y.stringDiv(o,"1000");r.end=this.parseToInt(a.Y.stringAdd(e,"1"))}const n=(await this.privatePostTradesHistory(this.extend(r,i))).result.trades,d=Object.keys(n);for(let e=0;e<d.length;e++)n[d[e]].id=d[e];let h;return void 0!==e&&(h=this.market(e)),this.parseTrades(n,h,t,s)}async cancelOrder(e,t=void 0,s={}){let i;await this.loadMarkets();const a={txid:this.safeValue2(s,"userref","clientOrderId",e)};s=this.omit(s,["userref","clientOrderId"]);try{i=await this.privatePostCancelOrder(this.extend(a,s))}catch(e){if(this.last_http_response&&this.last_http_response.indexOf("EOrder:Unknown order")>=0)throw new r.OrderNotFound(this.id+" cancelOrder() error "+this.last_http_response);throw e}return this.safeOrder({info:i})}async cancelOrders(e,t=void 0,s={}){const i={orders:e},r=await this.privatePostCancelOrderBatch(this.extend(i,s));return[this.safeOrder({info:r})]}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostCancelAll(t);return[this.safeOrder({info:s})]}async cancelAllOrdersAfter(e,t={}){if(e>864e5)throw new r.BadRequest(this.id+"cancelAllOrdersAfter timeout should be less than 86400000 milliseconds");await this.loadMarkets();const s={timeout:e>0?this.parseToInt(e/1e3):0};return await this.privatePostCancelAllOrdersAfter(this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==t&&(r.start=this.parseToInt(t/1e3));let a=i;const o=this.safeValue2(i,"userref","clientOrderId");void 0!==o&&(r.userref=o,a=this.omit(i,["userref","clientOrderId"]));const n=await this.privatePostOpenOrders(this.extend(r,a));let d;void 0!==e&&(d=this.market(e));const h=this.safeDict(n,"result",{}),c=this.safeDict(h,"open",{});return this.parseOrders(c,d,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r={};void 0!==t&&(r.start=this.parseToInt(t/1e3));let a=i;const o=this.safeValue2(i,"userref","clientOrderId");void 0!==o&&(r.userref=o,a=this.omit(i,["userref","clientOrderId"])),[r,i]=this.handleUntilOption("end",r,i);const n=await this.privatePostClosedOrders(this.extend(r,a));let d;void 0!==e&&(d=this.market(e));const h=this.safeDict(n,"result",{}),c=this.safeDict(h,"closed",{});return this.parseOrders(c,d,t,s)}parseTransactionStatus(e){return this.safeString({Initial:"pending",Pending:"pending",Success:"ok",Settled:"pending",Failure:"failed",Partial:"ok"},e,e)}parseNetwork(e){const t=this.safeValue(this.options,"withdrawMethods",{});return this.safeString(t,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"refid"),i=this.safeString(e,"txid"),r=this.safeTimestamp(e,"time"),a=this.safeString(e,"asset"),o=this.safeCurrencyCode(a,t),n=this.safeString(e,"info"),d=this.safeNumber(e,"amount");let h=this.parseTransactionStatus(this.safeString(e,"status"));const c=this.safeString(e,"status-prop");("on-hold"===c||"cancel-pending"===c||"onhold"===c)&&(h="pending");const l=this.safeString(e,"type");let u=this.safeNumber(e,"fee");return void 0===u&&"deposit"===l&&(u=0),{info:e,id:s,currency:o,amount:d,network:this.parseNetwork(this.safeString(e,"network")),address:n,addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:h,type:l,updated:void 0,txid:i,timestamp:r,datetime:this.iso8601(r),comment:void 0,internal:void 0,fee:{currency:o,cost:u}}}parseTransactionsByType(e,t,s=void 0,i=void 0,r=void 0){const a=[];for(let s=0;s<t.length;s++){const i=this.parseTransaction(this.extend({type:e},t[s]));a.push(i)}return this.filterByCurrencySinceLimit(a,s,i,r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};if(void 0!==e){const t=this.currency(e);r.asset=t.id}if(void 0!==t){const e=this.numberToString(t);r.start=a.Y.stringDiv(e,"1000")}const o=this.safeStringN(i,["until","till"]);if(void 0!==o){i=this.omit(i,["until","till"]);const e=a.Y.stringDiv(o,"1000");r.end=a.Y.stringAdd(e,"1")}const n=await this.privatePostDepositStatus(this.extend(r,i));return this.parseTransactionsByType("deposit",n.result,e,t,s)}async fetchTime(e={}){const t=await this.publicGetTime(e),s=this.safeValue(t,"result",{});return this.safeTimestamp(s,"unixtime")}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return i.cursor=!0,await this.fetchPaginatedCallCursor("fetchWithdrawals",e,t,s,i,"next_cursor","cursor");const o={};if(void 0!==e){const t=this.currency(e);o.asset=t.id}if(void 0!==t){const e=this.numberToString(t);o.start=a.Y.stringDiv(e,"1000")}const n=this.safeStringN(i,["until","till"]);if(void 0!==n){i=this.omit(i,["until","till"]);const e=a.Y.stringDiv(n,"1000");o.end=a.Y.stringAdd(e,"1")}const d=await this.privatePostWithdrawStatus(this.extend(o,i));let h;const c=this.safeValue(d,"result");return h=Array.isArray(c)?c:this.addPaginationCursorToResult(c),this.parseTransactionsByType("withdrawal",h,e,t,s)}addPaginationCursorToResult(e){const t=this.safeString(e,"next_cursor"),s=this.safeValue(e,"withdrawals"),i=s.length;if(void 0!==t&&i>0){const e=s[i-1];e.next_cursor=t,s[i-1]=e}return s}async createDepositAddress(e,t={}){return await this.fetchDepositAddress(e,this.extend({new:"true"},t))}async fetchDepositMethods(e,t={}){await this.loadMarkets();const s={asset:this.currency(e).id},i=await this.privatePostDepositMethods(this.extend(s,t));return this.safeValue(i,"result")}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i=this.safeStringUpper(t,"network");const a=this.safeValue(this.options,"networks",{});i=this.safeString(a,i,i),t=this.omit(t,"network"),"USDT"===e&&"TRC20"===i&&(e=e+"-"+i);const o=this.safeValue(this.options,"depositMethods",{}),n=this.safeString(o,e);let d=this.safeString(t,"method",n);if(void 0===d){const t=await this.fetchDepositMethods(e);if(void 0!==i)for(let e=0;e<t.length;e++){const s=this.safeString(t[e],"method");if(s.indexOf(i)>=0){d=s;break}}if(void 0===d){const e=this.safeValue(t,0,{});d=this.safeString(e,"method")}}const h={asset:s.id,method:d},c=await this.privatePostDepositAddresses(this.extend(h,t)),l=this.safeValue(c,"result",[]),u=this.safeValue(l,0,{});if(void 0===u)throw new r.InvalidAddress(this.id+" privatePostDepositAddresses() returned no addresses for "+e);return this.parseDepositAddress(u,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"tag"),r=(t=this.safeCurrency(void 0,t)).code;return this.checkAddress(s),{currency:r,address:s,tag:i,network:void 0,info:e}}async withdraw(e,t,s,i=void 0,a={}){if([i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),"key"in a){await this.loadMarkets();const i=this.currency(e),r={asset:i.id,amount:t,address:s},o=await this.privatePostWithdraw(this.extend(r,a)),n=this.safeDict(o,"result",{});return this.parseTransaction(n,i)}throw new r.ExchangeError(this.id+" withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)")}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostOpenPositions(this.extend({docalcs:"true",consolidation:"market"},t));e=this.marketSymbols(e);const i=this.safeList(s,"result"),r=this.parsePositions(i,e);return this.filterByArrayPositions(r,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"pair"),i="buy"===this.safeString(e,"type")?"long":"short";return this.safePosition({info:e,id:void 0,symbol:this.safeSymbol(s,t),notional:void 0,marginMode:void 0,liquidationPrice:void 0,entryPrice:void 0,unrealizedPnl:this.safeNumber(e,"net"),realizedPnl:void 0,percentage:void 0,contracts:this.safeNumber(e,"vol"),contractSize:void 0,markPrice:void 0,lastPrice:void 0,side:i,hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:this.safeNumber(e,"margin"),initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}parseAccountType(e){return this.safeString({spot:"Spot Wallet",swap:"Futures Wallet",future:"Futures Wallet"},e,e)}async transferOut(e,t,s={}){return await this.transfer(e,t,"spot","swap",s)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e);s=this.parseAccountType(s),i=this.parseAccountType(i);const n={amount:this.currencyToPrecision(e,t),from:s,to:i,asset:o.id};if("Spot Wallet"!==s)throw new r.BadRequest(this.id+" transfer cannot transfer from "+s+" to "+i+". Use krakenfutures instead to transfer from the futures account.");const d=await this.privatePostWalletTransfer(this.extend(n,a)),h=this.parseTransfer(d,o);return this.extend(h,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.safeValue(e,"result",{});return{info:e,id:this.safeString(s,"refid"),timestamp:void 0,datetime:void 0,currency:this.safeString(t,"code"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:"sucess"}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o="/"+this.version+"/"+t+"/"+e;if("public"===t)Object.keys(i).length&&(o+="?"+this.urlencodeNested(i));else if("private"===t){const t="CancelOrderBatch"===e;this.checkRequiredCredentials();const s=this.nonce().toString();a=t?this.json(this.extend({nonce:s},i)):this.urlencodeNested(this.extend({nonce:s},i));const h=this.encode(s+a),c=this.hash(h,n.s,"binary"),l=this.encode(o),u=this.binaryConcat(l,c),p=this.base64ToBinary(this.secret),f=this.hmac(u,p,d.Zf,"base64");(r={"API-Key":this.apiKey,"API-Sign":f})["Content-Type"]=t?"application/json":"application/x-www-form-urlencoded"}else o="/"+e;return o=this.urls.api[t]+o,{url:o,method:s,body:a,headers:r}}nonce(){return this.milliseconds()}handleErrors(e,t,s,i,a,o,n,d,h){if(520===e)throw new r.ExchangeNotAvailable(this.id+" "+e.toString()+" "+t);if(o.indexOf("Invalid order")>=0)throw new r.InvalidOrder(this.id+" "+o);if(o.indexOf("Invalid nonce")>=0)throw new r.InvalidNonce(this.id+" "+o);if(o.indexOf("Insufficient funds")>=0)throw new r.InsufficientFunds(this.id+" "+o);if(o.indexOf("Cancel pending")>=0)throw new r.CancelPending(this.id+" "+o);if(o.indexOf("Invalid arguments:volume")>=0)throw new r.InvalidOrder(this.id+" "+o);if(o.indexOf("Invalid arguments:viqc")>=0)throw new r.InvalidOrder(this.id+" "+o);if(o.indexOf("Rate limit exceeded")>=0)throw new r.RateLimitExceeded(this.id+" "+o);if(void 0!==n&&"{"===o[0]&&"string"!=typeof n&&"error"in n){if(n.error.length){const e=this.id+" "+o;for(let t=0;t<n.error.length;t++){const s=n.error[t];this.throwExactlyMatchedException(this.exceptions,s,e)}throw new r.ExchangeError(e)}}}}},2300:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(1359),r=s(1579),a=s(2079),o=s(5147),n=s(4852),d=s(7481);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"krakenfutures",name:"Kraken Futures",countries:["US"],version:"v3",userAgent:void 0,rateLimit:600,pro:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,createMarketOrder:!1,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:void 0,fetchFundingRate:"emulated",fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchIsolatedPositions:!1,fetchLeverage:!0,fetchLeverages:!0,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrders:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchTickers:!0,fetchTrades:!0,sandbox:!0,setLeverage:!0,setMarginMode:!1,transfer:!0},urls:{test:{public:"https://demo-futures.kraken.com/derivatives/api/",private:"https://demo-futures.kraken.com/derivatives/api/",charts:"https://demo-futures.kraken.com/api/charts/",history:"https://demo-futures.kraken.com/api/history/",www:"https://demo-futures.kraken.com"},logo:"https://user-images.githubusercontent.com/24300605/81436764-b22fd580-9172-11ea-9703-742783e6376d.jpg",api:{charts:"https://futures.kraken.com/api/charts/",history:"https://futures.kraken.com/api/history/",feeschedules:"https://futures.kraken.com/api/feeschedules/",public:"https://futures.kraken.com/derivatives/api/",private:"https://futures.kraken.com/derivatives/api/"},www:"https://futures.kraken.com/",doc:["https://docs.futures.kraken.com/#introduction"],fees:"https://support.kraken.com/hc/en-us/articles/360022835771-Transaction-fees-and-rebates-for-Kraken-Futures",referral:void 0},api:{public:{get:["feeschedules","instruments","orderbook","tickers","history","historicalfundingrates"]},private:{get:["feeschedules/volumes","openpositions","notifications","accounts","openorders","recentorders","fills","transfers","leveragepreferences","pnlpreferences","assignmentprogram/current","assignmentprogram/history"],post:["sendorder","editorder","cancelorder","transfer","batchorder","cancelallorders","cancelallordersafter","withdrawal","assignmentprogram/add","assignmentprogram/delete"],put:["leveragepreferences","pnlpreferences"]},charts:{get:["{price_type}/{symbol}/{interval}"]},history:{get:["orders","executions","triggers","accountlogcsv","account-log","market/{symbol}/orders","market/{symbol}/executions"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0005")],[this.parseNumber("100000"),this.parseNumber("0.0004")],[this.parseNumber("1000000"),this.parseNumber("0.0003")],[this.parseNumber("5000000"),this.parseNumber("0.00025")],[this.parseNumber("10000000"),this.parseNumber("0.0002")],[this.parseNumber("20000000"),this.parseNumber("0.00015")],[this.parseNumber("50000000"),this.parseNumber("0.000125")],[this.parseNumber("100000000"),this.parseNumber("0.0001")]],maker:[[this.parseNumber("0"),this.parseNumber("0.0002")],[this.parseNumber("100000"),this.parseNumber("0.0015")],[this.parseNumber("1000000"),this.parseNumber("0.000125")],[this.parseNumber("5000000"),this.parseNumber("0.0001")],[this.parseNumber("10000000"),this.parseNumber("0.000075")],[this.parseNumber("20000000"),this.parseNumber("0.00005")],[this.parseNumber("50000000"),this.parseNumber("0.000025")],[this.parseNumber("100000000"),this.parseNumber("0")]]}}},exceptions:{exact:{apiLimitExceeded:a.RateLimitExceeded,marketUnavailable:a.ContractUnavailable,requiredArgumentMissing:a.BadRequest,unavailable:a.ExchangeNotAvailable,authenticationError:a.AuthenticationError,accountInactive:a.ExchangeError,invalidAccount:a.BadRequest,invalidAmount:a.BadRequest,insufficientFunds:a.InsufficientFunds,"Bad Request":a.BadRequest,Unavailable:a.InsufficientFunds,invalidUnit:a.BadRequest,"Json Parse Error":a.ExchangeError,nonceBelowThreshold:a.InvalidNonce,nonceDuplicate:a.InvalidNonce,notFound:a.BadRequest,"Server Error":a.ExchangeError,unknownError:a.ExchangeError},broad:{invalidArgument:a.BadRequest,nonceBelowThreshold:a.InvalidNonce,nonceDuplicate:a.InvalidNonce}},precisionMode:r.kb,options:{access:{history:{GET:{orders:"private",executions:"private",triggers:"private",accountlogcsv:"private"}}},settlementCurrencies:{flex:["USDT","BTC","USD","GBP","EUR","USDC"]},symbol:{quoteIds:["USD","XBT"],reversed:!1},versions:{public:{GET:{historicalfundingrates:"v4"}},charts:{GET:{"{price_type}/{symbol}/{interval}":"v1"}},history:{GET:{orders:"v2",executions:"v2",triggers:"v2",accountlogcsv:"v2"}}},fetchTrades:{method:"historyGetMarketSymbolExecutions"}},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w"}})}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e),s=this.safeValue(t,"instruments",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"type");let o;const n=a.indexOf(" index")>=0;let d,h,c;if(n)o="index";else{d=a.indexOf("_vanilla")>=0,h=!d;const e=this.safeString(t,"lastTradingTime");o=void 0===e?"swap":"future",c=this.parse8601(e)}const l="swap"===o,u="future"===o;let p=r;const f=r.split("_"),m=this.safeString(f,1),g=m.slice(0,m.length-3),v="usd",y=this.safeCurrencyCode(g),w=this.safeCurrencyCode(v);let b,S;const k=this.safeString(t,"contractValueTradePrecision"),O=this.parseNumber(this.integerPrecisionToAmount(k)),T=this.safeNumber(t,"tickSize"),P=l||u||n;if(l||u){"futures_inverse"===this.safeString(t,"type")?(b=y,S=g,h=!0):(b=w,S=v,h=!1),d=!h,p=y+"/"+w+":"+b,u&&(p=p+"-"+this.yymmdd(c))}i.push({id:r,symbol:p,base:y,quote:w,settle:b,baseId:g,quoteId:v,settleId:S,type:o,spot:!1,margin:!1,swap:l,future:u,option:!1,index:n,active:void 0,contract:P,linear:d,inverse:h,contractSize:this.safeNumber(t,"contractSize"),maintenanceMarginRate:void 0,expiry:c,expiryDatetime:this.iso8601(c),strike:void 0,optionType:void 0,precision:{amount:O,price:T},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:this.parse8601(this.safeString(t,"openingDate")),info:t})}const r=this.options.settlementCurrencies.flex,a=[];for(let e=0;e<r.length;e++){const t=r[e];a.push({id:t.toLowerCase(),numericId:void 0,code:t,precision:void 0})}return this.currencies=this.deepExtend(a,this.currencies),i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id},r=await this.publicGetOrderbook(this.extend(i,s)),a=this.parse8601(r.serverTime);return this.parseOrderBook(r.orderBook,e,a)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeList(s,"tickers");return this.parseTickers(i,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.parse8601(this.safeString(e,"lastTime")),a=this.safeString(e,"open24h"),n=this.safeString(e,"last"),d=o.Y.stringSub(n,a),h=o.Y.stringMul(o.Y.stringDiv(d,a),"100"),c=o.Y.stringDiv(o.Y.stringAdd(a,n),"2"),l=this.safeString(e,"vol24h");let u,p;return this.safeBool(t,"index",!1)||(t.linear?u=l:t.inverse&&(p=l)),this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bidSize"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"askSize"),vwap:void 0,open:a,close:n,last:n,previousClose:void 0,change:d,percentage:h,average:c,baseVolume:u,quoteVolume:p,info:e})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,5e3);const n={symbol:a.id,price_type:this.safeString(r,"price","trade"),interval:this.timeframes[t]};if(r=this.omit(r,"price"),void 0!==s){const e=this.parseTimeframe(t);n.from=this.parseToInt(s/1e3),void 0===i&&(i=5e3),i=Math.min(i,5e3);const r=this.sum(n.from,i*e-1),a=this.seconds();n.to=Math.min(r,a)}else if(void 0!==i){i=Math.min(i,5e3);const e=this.parseTimeframe(t);n.to=this.seconds(),n.from=this.parseToInt(n.to-e*i)}const d=await this.chartsGetPriceTypeSymbolInterval(this.extend(n,r)),h=this.safeList(d,"candles");return this.parseOHLCVs(h,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"time"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchTrades",e,t,s,i);const a=this.market(e);let o,n,d={symbol:a.id};[o,i]=this.handleOptionAndParams(i,"fetchTrades","method","historyGetMarketSymbolExecutions");if("historyGetMarketSymbolExecutions"===o){[d,i]=this.handleUntilOption("before",d,i),void 0!==t&&(d.since=t,d.sort="asc"),void 0!==s&&(d.count=s);const e=await this.historyGetMarketSymbolExecutions(this.extend(d,i)),r=this.safeList(e,"elements",[]);n=[];const a=r.length;for(let e=0;e<a;e++){const t=r[a-1-e],s=this.safeDict(t,"event",{}),i=this.safeDict(s,"Execution",{}),o=this.safeDict(i,"execution",{});n.push(o)}}else{[d,i]=this.handleUntilOption("lastTime",d,i);const e=await this.publicGetHistory(this.extend(d,i));n=this.safeList(e,"history",[])}return this.parseTrades(n,a,t,s)}parseTrade(e,t=void 0){let s=this.parse8601(this.safeString2(e,"time","fillTime"));const i=this.safeString(e,"price"),r=this.safeStringN(e,["size","amount","quantity"],"0.0");let a=this.safeString2(e,"uid","fill_id");void 0===a&&(a=this.safeString(e,"executionId"));let n,d=this.safeString(e,"order_id"),h=this.safeString(e,"symbol"),c=this.safeString(e,"side");const l=this.safeValue(e,"orderPriorEdit"),u=this.safeValue(e,"orderPriorExecution");let p;void 0!==u?(d=this.safeString(u,"orderId"),h=this.safeString(u,"symbol"),c=this.safeString(u,"side"),n=this.safeString(u,"type")):void 0!==l&&(d=this.safeString(l,"orderId"),h=this.safeString(l,"symbol"),c=this.safeString(l,"type"),n=this.safeString(l,"type")),void 0!==n&&(n=this.parseOrderType(n)),t=this.safeMarket(h,t);const f=this.safeBool(t,"linear");if(void 0!==r&&void 0!==i&&void 0!==t){p=f?o.Y.stringMul(r,i):o.Y.stringDiv(r,i);const e=this.safeString(t,"contractSize");p=o.Y.stringMul(p,e)}let m;const g=this.safeString(e,"fillType");void 0!==g&&(g.indexOf("taker")>=0?m="taker":g.indexOf("maker")>=0&&(m="maker"));if("takerOrder"in e){s=this.safeInteger(e,"timestamp");const t=this.safeDict(e,"takerOrder",{});void 0!==t&&(c=this.safeStringLower(t,"direction"),m="taker")}return this.safeTrade({info:e,id:a,symbol:this.safeString(t,"symbol"),timestamp:s,datetime:this.iso8601(s),order:d,type:n,side:c,takerOrMaker:m,price:i,amount:f?r:void 0,cost:p,fee:void 0})}createOrderRequest(e,t,s,i,r=void 0,a={}){const o=this.market(e);e=o.symbol,t=this.safeString(a,"orderType",t);const n=this.safeString(a,"timeInForce");let d=!1;[d,a]=this.handlePostOnly("market"===t,"post"===t,a),d?t="post":"ioc"===n?t="ioc":"limit"===t?t="lmt":"market"===t&&(t="mkt");const h={symbol:o.id,side:s,size:this.amountToPrecision(e,i)},c=this.safeString2(a,"clientOrderId","cliOrdId");void 0!==c&&(h.cliOrdId=c);const l=this.safeString2(a,"triggerPrice","stopPrice"),u=void 0!==l,p=this.safeString(a,"stopLossPrice"),f=this.safeString(a,"takeProfitPrice"),m=void 0!==p,g=void 0!==f,v=m||g,y=this.safeString(a,"triggerSignal","last");let w=this.safeValue(a,"reduceOnly");return(v||u)&&(h.triggerSignal=y),u?(t="stp",h.stopPrice=this.priceToPrecision(e,l)):v&&(w=!0,m?(t="stp",h.stopPrice=this.priceToPrecision(e,p)):g&&(t="take_profit",h.stopPrice=this.priceToPrecision(e,f))),w&&(h.reduceOnly=!0),h.orderType=t,void 0!==r&&(h.limitPrice=this.priceToPrecision(e,r)),a=this.omit(a,["clientOrderId","timeInForce","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(h,a)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.createOrderRequest(e,t,s,i,r,a),d=await this.privatePostSendorder(n),h=this.safeValue(d,"sendStatus"),c=this.safeString(h,"status");return this.verifyOrderActionSuccess(c,"createOrder",["filled"]),this.parseOrder(h,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"symbol"),o=this.safeString(r,"type"),n=this.safeString(r,"side"),d=this.safeValue(r,"amount"),h=this.safeValue(r,"price"),c=this.safeValue(r,"params",{}),l=this.extend(c,t);"order_tag"in l||(l.order_tag=this.sum(i,1).toString()),l.order="send";const u=this.createOrderRequest(a,o,n,d,h,l);s.push(u)}const i={batchOrder:s},r=await this.privatePostBatchorder(this.extend(i,t)),a=this.safeList(r,"batchStatus",[]);return this.parseOrders(a)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n={orderId:e};void 0!==r&&(n.size=r),void 0!==a&&(n.limitPrice=a);const d=await this.privatePostEditorder(this.extend(n,o)),h=this.safeString(d.editStatus,"status");this.verifyOrderActionSuccess(h,"editOrder",["filled"]);const c=this.parseOrder(d.editStatus);return c.info=d,c}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostCancelorder(this.extend({order_id:e},s)),r=this.safeString(this.safeValue(i,"cancelStatus",{}),"status");this.verifyOrderActionSuccess(r,"cancelOrder");let a={};return"cancelStatus"in i&&(a=this.parseOrder(i.cancelStatus)),this.extend({info:i},a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=[],r=this.safeValue(s,"clientOrderIds",[]);if(r.length>0)for(let e=0;e<r.length;e++)i.push({order:"cancel",cliOrdId:r[e]});else for(let t=0;t<e.length;t++)i.push({order:"cancel",order_id:e[t]});const a={batchOrder:i},o=await this.privatePostBatchorder(this.extend(a,s)),n=this.safeList(o,"batchStatus",[]);return this.parseOrders(n)}async cancelAllOrders(e=void 0,t={}){const s={};void 0!==e&&(s.symbol=this.marketId(e));const i=await this.privatePostCancelallorders(this.extend(s,t)),r=this.safeDict(i,"cancelStatus"),a=this.safeList(r,"orderEvents",[]),o=[];for(let e=0;e<a.length;e++){const e=this.safeDict(a,0),t=this.safeDict(e,"order",{});o.push(t)}return this.parseOrders(o)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={timeout:e>0?this.parseToInt(e/1e3):0};return await this.privatePostCancelallordersafter(this.extend(s,t))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privateGetOpenorders(i),o=this.safeList(a,"openOrders",[]);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==s&&(a.count=s),void 0!==t&&(a.from=t);const o=await this.historyGetOrders(this.extend(a,i)),n=this.safeList(o,"elements",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeDict(t,"event",{}),i=this.safeDict(s,"OrderPlaced");if(void 0!==i){const e=this.safeDict(i,"order",{});"0"!==this.safeString(e,"filled")&&(e.status="closed",d.push(e))}}return this.parseOrders(d,r,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==s&&(a.count=s),void 0!==t&&(a.from=t);const o=await this.historyGetOrders(this.extend(a,i)),n=this.safeList(o,"elements",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeDict(t,"event",{}),i=this.safeDict(s,"OrderPlaced");if(void 0!==i){const e=this.safeDict(i,"order",{});"0"===this.safeString(e,"filled")&&(e.status="canceled",d.push(e))}const r=this.safeDict(s,"OrderCancelled");if(void 0!==r){const e=this.safeDict(r,"order",{});e.status="canceled",d.push(e)}const a=this.safeDict(s,"OrderRejected");if(void 0!==a){const e=this.safeDict(a,"order",{});e.status="rejected",d.push(e)}}return this.parseOrders(d,r,t,s)}parseOrderType(e){return this.safeString({lmt:"limit",mkt:"market",post:"limit",ioc:"market"},e,e)}verifyOrderActionSuccess(e,t,s=[]){const i={invalidOrderType:a.InvalidOrder,invalidSide:a.InvalidOrder,invalidSize:a.InvalidOrder,invalidPrice:a.InvalidOrder,insufficientAvailableFunds:a.InsufficientFunds,selfFill:a.ExchangeError,tooManySmallOrders:a.ExchangeError,maxPositionViolation:a.BadRequest,marketSuspended:a.ExchangeNotAvailable,marketInactive:a.ExchangeNotAvailable,clientOrderIdAlreadyExist:a.DuplicateOrderId,clientOrderIdTooLong:a.BadRequest,outsidePriceCollar:a.InvalidOrder,postWouldExecute:a.OrderImmediatelyFillable,iocWouldNotExecute:a.OrderNotFillable,wouldNotReducePosition:a.ExchangeError,orderForEditNotFound:a.OrderNotFound,orderForEditNotAStop:a.InvalidOrder,filled:a.OrderNotFound,notFound:a.OrderNotFound};if(e in i&&!this.inArray(e,s))throw new i[e](this.id+": "+t+" failed due to "+e)}parseOrderStatus(e){return this.safeString({placed:"open",cancelled:"canceled",invalidOrderType:"rejected",invalidSide:"rejected",invalidSize:"rejected",invalidPrice:"rejected",insufficientAvailableFunds:"rejected",selfFill:"rejected",tooManySmallOrders:"rejected",maxPositionViolation:"rejected",marketSuspended:"rejected",marketInactive:"rejected",clientOrderIdAlreadyExist:"rejected",clientOrderIdTooLong:"rejected",outsidePriceCollar:"rejected",postWouldExecute:"rejected",iocWouldNotExecute:"rejected",wouldNotReducePosition:"rejected",edited:"open",orderForEditNotFound:"rejected",orderForEditNotAStop:"rejected",filled:"closed",notFound:"rejected",untouched:"open",partiallyFilled:"open"},e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"orderEvents",[]),i=this.safeString(e,"status"),r=s.length;if("orderEvents"in e&&void 0!==i&&0===r)return this.safeOrder({info:e,status:"rejected"});let a,n,d,h=!1,c=!1,l=[];if(r){const t=[];for(let e=0;e<s.length;e++){const i=s[e];"EXECUTION"===this.safeString(i,"type")&&t.push(i);const r=this.safeValue(i,"orderTrigger");if(void 0===a)if(a=this.safeValue2(i,"new","order",r),void 0!==a)h=!1,c=!0;else if(!c){const e=this.safeValue(i,"orderPriorExecution");a=this.safeValue2(i,"orderPriorExecution","orderPriorEdit"),d=this.safeString(e,"limitPrice"),void 0!==a&&(h=!0)}}l=this.parseTrades(t),n=this.safeString(e,"status")}void 0===a&&(a=e),void 0===n&&(n=this.safeString(a,"status"));let u=this.parseOrderStatus(n),p=this.inArray(u,["canceled","rejected","closed"]);const f=this.safeString(a,"symbol");t=this.safeMarket(f,t);const m=this.parse8601(this.safeString2(a,"timestamp","receivedTime")),g=this.parse8601(this.safeString(a,"lastUpdateTime"));void 0===d&&(d=this.safeString(a,"limitPrice"));let v,y=this.safeString(a,"quantity"),w=this.safeString2(a,"filledSize","filled","0.0"),b=this.safeString(a,"unfilledSize"),S="0.0";if(l.length>0){let e="0.0";for(let t=0;t<l.length;t++){const s=l[t],i=this.safeString(s,"amount"),r=this.safeString(s,"price");S=o.Y.stringAdd(S,i),e=o.Y.stringAdd(e,o.Y.stringMul(i,r))}v=o.Y.stringDiv(e,S),void 0!==y&&!p&&h&&o.Y.stringGe(S,y)&&(u="closed",p=!0),w=h?o.Y.stringAdd(w,S):o.Y.stringMax(w,S)}let k;if(void 0===b&&(h?void 0!==y&&(b=o.Y.stringSub(y,S)):b=y),void 0!==y||h||void 0===b||(y=o.Y.stringAdd(w,b)),void 0!==w&&void 0!==t){const e=void 0!==v?v:d;void 0!==e&&(k=t.linear?o.Y.stringMul(w,e):o.Y.stringDiv(w,e))}let O=this.safeString2(e,"order_id","orderId");void 0===O&&(O=this.safeString2(a,"orderId","uid"));const T=this.safeStringLower2(a,"type","orderType");let P="gtc";return"ioc"!==T&&"market"!==this.parseOrderType(T)||(P="ioc"),this.safeOrder({info:e,id:O,clientOrderId:this.safeStringN(a,["clientOrderId","clientId","cliOrdId"]),timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:void 0,lastUpdateTimestamp:g,symbol:this.safeString(t,"symbol"),type:this.parseOrderType(T),timeInForce:P,postOnly:"post"===T,reduceOnly:this.safeBool2(a,"reduceOnly","reduce_only"),side:this.safeString(a,"side"),price:d,stopPrice:this.safeString(a,"triggerPrice"),triggerPrice:this.safeString(a,"triggerPrice"),amount:y,cost:k,average:v,filled:w,remaining:b,status:u,fee:void 0,fees:void 0,trades:l})}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a=await this.privateGetFills(i);return this.parseTrades(a.fills,r,t,s)}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString2(e,"type","account"),s=this.safeString(e,"symbol");e=this.omit(e,["type","account","symbol"]);const i=await this.privateGetAccounts(e),r=this.safeString(i,"serverTime");if("marginAccount"===t||"margin"===t){if(void 0===s)throw new a.ArgumentsRequired(this.id+" fetchBalance requires symbol argument for margin accounts");t=s}void 0===t&&(t=void 0===s?"flex":s);const o=this.parseAccount(t),n=this.safeValue(i,"accounts"),d=this.safeValue(n,o);if(void 0===d)throw t=void 0===t?"":t,s=void 0===s?"":s,new a.BadRequest(this.id+" fetchBalance has no account for "+t);const h=this.parseBalance(d);return h.info=i,h.timestamp=this.parse8601(r),h.datetime=r,h}parseBalance(e){const t=this.safeString2(e,"accountType","type"),s="multiCollateralMarginAccount"===t,i="cashAccount"===t,r=this.safeValue2(e,"balances","currencies",{}),a={},o=Object.keys(r);for(let t=0;t<o.length;t++){const n=o[t],d=r[n],h=this.safeCurrencyCode(n);if(h.split("_").length>1)continue;const c=this.account();if(s)c.total=this.safeString(d,"quantity"),c.free=this.safeString(d,"available");else if(i)c.used="0.0",c.total=d;else{const t=this.safeValue(e,"auxiliary");c.free=this.safeString(t,"af"),c.total=this.safeString(t,"pv")}a[h]=c}return this.safeBalance(a)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();const s=this.marketIds(e),i=await this.publicGetTickers(t),r=this.safeValue(i,"tickers"),a=[];for(let e=0;e<r.length;e++){const t=r[e],i=this.safeValue(t,"symbol");if(void 0!==s&&!this.inArray(i,s))continue;const o=this.safeMarket(i),n=this.parseFundingRate(t,o);a.push(n)}return this.indexBy(a,"symbol")}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.symbol(s),r=this.parse8601(this.safeString(e,"lastTime")),a=this.safeNumber(e,"indexPrice"),n=this.safeString(e,"markPrice"),d=this.parseNumber(n),h=this.safeString(e,"fundingRate"),c=o.Y.stringDiv(o.Y.stringMul(h,"8"),n),l=this.parseNumber(c),u=this.safeString(e,"fundingRatePrediction"),p=o.Y.stringDiv(o.Y.stringMul(u,"8"),n),f=this.parseNumber(p);return{info:e,symbol:i,markPrice:d,indexPrice:a,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:r,datetime:this.iso8601(r),fundingRate:l,fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:f,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new a.BadRequest(this.id+" fetchFundingRateHistory() supports swap contracts only");const o={symbol:r.id.toUpperCase()},n=await this.publicGetHistoricalfundingrates(this.extend(o,i)),d=this.safeValue(n,"rates"),h=[];for(let t=0;t<d.length;t++){const s=d[t],i=this.safeString(s,"timestamp");h.push({info:s,symbol:e,fundingRate:this.safeNumber(s,"relativeFundingRate"),timestamp:this.parse8601(i),datetime:i})}const c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetOpenpositions({}),i=this.parsePositions(s);return this.filterByArrayPositions(i,"symbol",e,!1)}parsePositions(e,t=void 0,s={}){const i=[],r=this.safeValue(e,"openPositions");for(let e=0;e<r.length;e++){const t=this.parsePosition(r[e]);i.push(t)}return i}parsePosition(e,t=void 0){const s=this.safeNumber(e,"maxFixedLeverage");let i="cross";void 0!==s&&(i="isolated");const r=this.safeString(e,"fillTime"),a=this.safeString(e,"symbol");return{info:e,symbol:(t=this.safeMarket(a,t)).symbol,timestamp:this.parse8601(r),datetime:r,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.safeNumber(e,"price"),notional:void 0,leverage:s,unrealizedPnl:void 0,contracts:this.safeNumber(e,"size"),contractSize:this.safeNumber(t,"contractSize"),marginRatio:void 0,liquidationPrice:void 0,markPrice:void 0,collateral:void 0,marginType:i,side:this.safeString(e,"side"),percentage:void 0}}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetInstruments(t),i=this.safeList(s,"instruments");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeValue(e,"marginLevels"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=[];for(let e=0;e<s.length;e++){const i=s[e],a=this.safeString(i,"initialMargin"),n=this.safeNumber(i,"contracts");if(0!==e){r[r.length-1].notionalCap=n}r.push({tier:this.sum(e,1),currency:t.quote,notionalFloor:n,notionalCap:void 0,maintenanceMarginRate:this.safeNumber(i,"maintenanceMargin"),maxLeverage:this.parseNumber(o.Y.stringDiv("1",a)),info:i})}return r}parseTransfer(e,t=void 0){const s=this.safeString(e,"serverTime");return{info:e,id:void 0,timestamp:this.parse8601(s),datetime:s,currency:this.safeString(t,"code"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.safeString(e,"result")}}parseAccount(e){const t={main:"cash",funding:"cash",future:"cash",futures:"cash",cashAccount:"cash",multiCollateralMarginAccount:"flex",multiCollateral:"flex",multiCollateralMargin:"flex"};if(e in t)return t[e];if(e in this.markets){const t=this.market(e),s=t.id.split("_");return t.inverse?"fi_"+this.safeString(s,1):"fv_"+this.safeString(s,1)}return e}async transferOut(e,t,s={}){return await this.transfer(e,t,"future","spot",s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const o=this.currency(e);if("spot"===s)throw new a.BadRequest(this.id+" transfer does not yet support transfers from spot");const n={amount:t};let d;if("spot"===i){if("cash"!==this.parseAccount(s))throw new a.BadRequest(this.id+" transfer cannot transfer from "+s+" to "+i);n.currency=o.id,d=await this.privatePostWithdrawal(this.extend(n,r))}else n.fromAccount=this.parseAccount(s),n.toAccount=this.parseAccount(i),n.unit=o.id,d=await this.privatePostTransfer(this.extend(n,r));const h=this.parseTransfer(d,o);return this.extend(h,{amount:t,fromAccount:s,toAccount:i})}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");await this.loadMarkets();const i={maxLeverage:e,symbol:this.marketId(t).toUpperCase()};return await this.privatePutLeveragepreferences(this.extend(i,s))}async fetchLeverages(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetLeveragepreferences(t),i=this.safeList(s,"leveragePreferences",[]);return this.parseLeverages(i,e,"symbol")}async fetchLeverage(e,t={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchLeverage() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i={symbol:this.marketId(e).toUpperCase()},r=await this.privateGetLeveragepreferences(this.extend(i,t)),o=this.safeList(r,"leveragePreferences",[]),n=this.safeDict(o,0,{});return this.parseLeverage(n,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"maxLeverage");return{info:e,symbol:this.safeSymbol(s,t),marginMode:void 0,longLeverage:i,shortLeverage:i}}handleErrors(e,t,s,i,r,o,n,d,h){if(void 0===n)return;if(429===e)throw new a.DDoSProtection(this.id+" "+o);const c=this.safeValue(n,"errors"),l=this.safeValue(c,0),u=this.safeString(l,"message"),p=this.safeString(n,"error",u);if(void 0===p)return;const f=this.id+" "+o;if(this.throwExactlyMatchedException(this.exceptions.exact,p,f),this.throwBroadlyMatchedException(this.exceptions.broad,p,f),400===e)throw new a.BadRequest(f);throw new a.ExchangeError(f)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeValue(this.options.versions,t,{}),h=this.safeValue(o,s,{}),c=this.safeString(h,e,this.version),l=this.safeString(i,"version",c);i=this.omit(i,"version");const u=this.safeValue(this.options.access,t,{}),p=this.safeValue(u,s,{}),f=this.safeString(p,e,"public"),m=l+"/"+this.implodeParams(e,i);i=this.omit(i,this.extractParams(e));let g=m,v="";"batchorder"===e?(v="json="+this.json(i),a=v):Object.keys(i).length&&(v=this.urlencode(i),g+="?"+v);const y=this.urls.api[t]+g;if("private"===t||"private"===f){this.checkRequiredCredentials();let e=v+"/api/";"private"!==t&&(e+=t+"/"),e+=m;const s=this.hash(this.encode(e),n.s,"binary"),i=this.base64ToBinary(this.secret),a=this.hmac(s,i,d.Zf,"base64");r={"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json",APIKey:this.apiKey,Authent:a}}return{url:y,method:s,body:a,headers:r}}}},1397:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3548),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"kucoin",name:"KuCoin",countries:["SC"],rateLimit:10,version:"v2",certified:!0,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,borrowCrossMargin:!0,borrowIsolatedMargin:!0,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!0,fetchBorrowRateHistory:!0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!0,fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrdersByStatus:!0,fetchOrderTrades:!0,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositionsHistory:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactionFee:!0,fetchTransfers:!1,fetchWithdrawals:!0,repayCrossMargin:!0,repayIsolatedMargin:!0,setLeverage:!0,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",referral:"https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",api:{public:"https://api.kucoin.com",private:"https://api.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com",webExchange:"https://kucoin.com/_api",broker:"https://api-broker.kucoin.com",earn:"https://api.kucoin.com"},www:"https://www.kucoin.com",doc:["https://docs.kucoin.com"]},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{public:{get:{currencies:4.5,"currencies/{currency}":4.5,symbols:6,"market/orderbook/level1":3,"market/allTickers":22.5,"market/stats":22.5,markets:4.5,"market/orderbook/level{level}_{limit}":6,"market/orderbook/level2_20":3,"market/orderbook/level2_100":6,"market/histories":4.5,"market/candles":4.5,prices:4.5,timestamp:4.5,status:4.5,"mark-price/{symbol}/current":3,"mark-price/all-symbols":3,"margin/config":25},post:{"bullet-public":15}},private:{get:{"user-info":30,accounts:7.5,"accounts/{accountId}":7.5,"accounts/ledgers":3,"hf/accounts/ledgers":2,"hf/margin/account/ledgers":2,"transaction-history":3,"sub/user":30,"sub-accounts/{subUserId}":22.5,"sub-accounts":30,"sub/api-key":30,"margin/account":40,"margin/accounts":15,"isolated/accounts":15,"deposit-addresses":7.5,deposits:7.5,"hist-deposits":7.5,withdrawals:30,"hist-withdrawals":30,"withdrawals/quotas":30,"accounts/transferable":30,"transfer-list":30,"base-fee":3,"trade-fees":3,"market/orderbook/level{level}":3,"market/orderbook/level2":3,"market/orderbook/level3":3,"hf/orders/active":2,"hf/orders/active/symbols":2,"hf/margin/order/active/symbols":2,"hf/orders/done":2,"hf/orders/{orderId}":2,"hf/orders/client-order/{clientOid}":2,"hf/orders/dead-cancel-all/query":2,"hf/fills":2,orders:2,"limit/orders":3,"orders/{orderId}":2,"order/client-order/{clientOid}":3,fills:10,"limit/fills":20,"stop-order":8,"stop-order/{orderId}":3,"stop-order/queryOrderByClientOid":3,"oco/order/{orderId}":2,"oco/order/details/{orderId}":2,"oco/client-order/{clientOid}":2,"oco/orders":2,"hf/margin/orders/active":4,"hf/margin/orders/done":10,"hf/margin/orders/{orderId}":4,"hf/margin/orders/client-order/{clientOid}":5,"hf/margin/fills":5,"etf/info":25,"margin/currencies":20,"risk/limit/strategy":20,"isolated/symbols":20,"margin/symbols":5,"isolated/account/{symbol}":50,"margin/borrow":15,"margin/repay":15,"margin/interest":20,"project/list":10,"project/marketInterestRate":7.5,"redeem/orders":10,"purchase/orders":10,"broker/api/rebase/download":3,"migrate/user/account/status":3,"affiliate/inviter/statistics":30},post:{"sub/user/created":22.5,"sub/api-key":30,"sub/api-key/update":45,"deposit-addresses":30,withdrawals:7.5,"accounts/universal-transfer":6,"accounts/sub-transfer":45,"accounts/inner-transfer":15,"transfer-out":30,"transfer-in":30,"hf/orders":1,"hf/orders/test":1,"hf/orders/sync":1,"hf/orders/multi":1,"hf/orders/multi/sync":1,"hf/orders/alter":3,"hf/orders/dead-cancel-all":2,orders:2,"orders/test":2,"orders/multi":3,"stop-order":2,"oco/order":2,"hf/margin/order":5,"hf/margin/order/test":5,"margin/order":5,"margin/order/test":5,"margin/borrow":15,"margin/repay":10,purchase:15,redeem:15,"lend/purchase/update":10,"bullet-private":10,"position/update-user-leverage":5},delete:{"sub/api-key":45,"withdrawals/{withdrawalId}":30,"hf/orders/{orderId}":1,"hf/orders/sync/{orderId}":1,"hf/orders/client-order/{clientOid}":1,"hf/orders/sync/client-order/{clientOid}":1,"hf/orders/cancel/{orderId}":2,"hf/orders":2,"hf/orders/cancelAll":30,"orders/{orderId}":3,"order/client-order/{clientOid}":5,orders:20,"stop-order/{orderId}":3,"stop-order/cancelOrderByClientOid":5,"stop-order/cancel":3,"oco/order/{orderId}":3,"oco/client-order/{clientOid}":3,"oco/orders":3,"hf/margin/orders/{orderId}":5,"hf/margin/orders/client-order/{clientOid}":5,"hf/margin/orders":10}},futuresPublic:{get:{"contracts/active":4.5,"contracts/{symbol}":4.5,ticker:3,"level2/snapshot":4.5,"level2/depth20":7.5,"level2/depth100":15,"trade/history":7.5,"kline/query":4.5,"interest/query":7.5,"index/query":3,"mark-price/{symbol}/current":4.5,"premium/query":4.5,"trade-statistics":4.5,"funding-rate/{symbol}/current":3,"contract/funding-rates":7.5,timestamp:3,status:6,"level2/message/query":1.3953},post:{"bullet-public":15}},futuresPrivate:{get:{"transaction-history":3,"account-overview":7.5,"account-overview-all":9,"transfer-list":30,orders:3,stopOrders:9,recentDoneOrders:7.5,"orders/{orderId}":7.5,"orders/byClientOid":7.5,fills:7.5,recentFills:4.5,openOrderStatistics:15,position:3,positions:3,"margin/maxWithdrawMargin":15,"contracts/risk-limit/{symbol}":7.5,"funding-history":7.5},post:{"transfer-out":30,"transfer-in":30,orders:3,"orders/test":3,"orders/multi":4.5,"position/margin/auto-deposit-status":6,"margin/withdrawMargin":15,"position/margin/deposit-margin":6,"position/risk-limit-level/change":6,"bullet-private":15},delete:{"orders/{orderId}":1.5,"orders/client-order/{clientOid}":1.5,orders:45,stopOrders:22.5}},webExchange:{get:{"currency/currency/chain-info":1}},broker:{get:{"broker/nd/info":2,"broker/nd/account":2,"broker/nd/account/apikey":2,"broker/nd/rebase/download":3,"asset/ndbroker/deposit/list":1,"broker/nd/transfer/detail":1,"broker/nd/deposit/detail":1,"broker/nd/withdraw/detail":1},post:{"broker/nd/transfer":1,"broker/nd/account":3,"broker/nd/account/apikey":3,"broker/nd/account/update-apikey":3},delete:{"broker/nd/account/apikey":3}},earn:{get:{"otc-loan/loan":1,"otc-loan/accounts":1,"earn/redeem-preview":7.5,"earn/saving/products":7.5,"earn/hold-assets":7.5,"earn/promotion/products":7.5,"earn/kcs-staking/products":7.5,"earn/staking/products":7.5,"earn/eth-staking/products":7.5},post:{"earn/orders":7.5},delete:{"earn/orders":7.5}}},timeframes:{"1m":"1min","3m":"3min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","6h":"6hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},precisionMode:o.kb,exceptions:{exact:{"order not exist":r.OrderNotFound,"order not exist.":r.OrderNotFound,order_not_exist:r.OrderNotFound,order_not_exist_or_not_allow_to_cancel:r.InvalidOrder,"Order size below the minimum requirement.":r.InvalidOrder,"The withdrawal amount is below the minimum requirement.":r.ExchangeError,"Unsuccessful! Exceeded the max. funds out-transfer limit":r.InsufficientFunds,"The amount increment is invalid.":r.BadRequest,"The quantity is below the minimum requirement.":r.InvalidOrder,400:r.BadRequest,401:r.AuthenticationError,403:r.NotSupported,404:r.NotSupported,405:r.NotSupported,415:r.NotSupported,429:r.RateLimitExceeded,500:r.ExchangeNotAvailable,503:r.ExchangeNotAvailable,101030:r.PermissionDenied,103e3:r.InvalidOrder,130101:r.BadRequest,130102:r.ExchangeError,130103:r.OrderNotFound,130104:r.ExchangeError,130105:r.InsufficientFunds,130106:r.NotSupported,130107:r.ExchangeError,130108:r.OrderNotFound,130201:r.PermissionDenied,130202:r.ExchangeError,130203:r.InsufficientFunds,130204:r.BadRequest,130301:r.InsufficientFunds,130302:r.PermissionDenied,130303:r.NotSupported,130304:r.NotSupported,130305:r.NotSupported,130306:r.NotSupported,130307:r.NotSupported,130308:r.InvalidOrder,130309:r.InvalidOrder,130310:r.ExchangeError,130311:r.InvalidOrder,130312:r.InvalidOrder,130313:r.InvalidOrder,130314:r.InvalidOrder,130315:r.NotSupported,126e3:r.ExchangeError,126001:r.NotSupported,126002:r.ExchangeError,126003:r.InvalidOrder,126004:r.ExchangeError,126005:r.PermissionDenied,126006:r.ExchangeError,126007:r.ExchangeError,126009:r.ExchangeError,126010:r.ExchangeError,126011:r.ExchangeError,126013:r.InsufficientFunds,126015:r.ExchangeError,126021:r.NotSupported,126022:r.InvalidOrder,126027:r.InvalidOrder,126028:r.InvalidOrder,126029:r.InvalidOrder,126030:r.InvalidOrder,126033:r.InvalidOrder,126034:r.InvalidOrder,126036:r.InvalidOrder,126037:r.ExchangeError,126038:r.ExchangeError,126039:r.ExchangeError,126041:r.ExchangeError,126042:r.ExchangeError,126043:r.OrderNotFound,126044:r.InvalidOrder,126045:r.NotSupported,126046:r.NotSupported,126047:r.PermissionDenied,126048:r.PermissionDenied,135005:r.ExchangeError,135018:r.ExchangeError,200004:r.InsufficientFunds,210014:r.InvalidOrder,210021:r.InsufficientFunds,230003:r.InsufficientFunds,26e4:r.InvalidAddress,260100:r.InsufficientFunds,3e5:r.InvalidOrder,4e5:r.BadSymbol,400001:r.AuthenticationError,400002:r.InvalidNonce,400003:r.AuthenticationError,400004:r.AuthenticationError,400005:r.AuthenticationError,400006:r.AuthenticationError,400007:r.AuthenticationError,400008:r.NotSupported,400100:r.InsufficientFunds,400200:r.InvalidOrder,400350:r.InvalidOrder,400370:r.InvalidOrder,400400:r.BadRequest,400401:r.AuthenticationError,400500:r.InvalidOrder,400600:r.BadSymbol,400760:r.InvalidOrder,401e3:r.BadRequest,408e3:r.BadRequest,411100:r.AccountSuspended,415e3:r.BadRequest,400303:r.PermissionDenied,5e5:r.ExchangeNotAvailable,260220:r.InvalidAddress,900014:r.BadRequest},broad:{"Exceeded the access frequency":r.RateLimitExceeded,"require more permission":r.PermissionDenied}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.001")],[this.parseNumber("200"),this.parseNumber("0.0009")],[this.parseNumber("500"),this.parseNumber("0.0008")],[this.parseNumber("1000"),this.parseNumber("0.0007")],[this.parseNumber("2000"),this.parseNumber("0.0007")],[this.parseNumber("4000"),this.parseNumber("0.0006")],[this.parseNumber("8000"),this.parseNumber("0.0005")],[this.parseNumber("15000"),this.parseNumber("0.00045")],[this.parseNumber("25000"),this.parseNumber("0.0004")],[this.parseNumber("40000"),this.parseNumber("0.00035")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.00025")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("50"),this.parseNumber("0.0009")],[this.parseNumber("200"),this.parseNumber("0.0007")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0003")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.00005")],[this.parseNumber("25000"),this.parseNumber("-0.00005")],[this.parseNumber("40000"),this.parseNumber("-0.00005")],[this.parseNumber("60000"),this.parseNumber("-0.00005")],[this.parseNumber("80000"),this.parseNumber("-0.00005")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{BIFI:"BIFIF",VAI:"VAIOT",WAX:"WAXP",ALT:"APTOSLAUNCHTOKEN",KALT:"ALT"},options:{version:"v1",symbolSeparator:"-",fetchMyTradesMethod:"private_get_fills",fetchCurrencies:{webApiEnable:!0,webApiRetries:1,webApiMuteFailure:!0},fetchMarkets:{fetchTickersFees:!0},withdraw:{includeFee:!1},versions:{public:{GET:{currencies:"v3","currencies/{currency}":"v3",symbols:"v2","mark-price/all-symbols":"v3"}},private:{GET:{"user-info":"v2","hf/margin/account/ledgers":"v3","sub/user":"v2","sub-accounts":"v2","margin/accounts":"v3","isolated/accounts":"v3","deposit-addresses":"v1","market/orderbook/level2":"v3","market/orderbook/level3":"v3","market/orderbook/level{level}":"v3","oco/order/{orderId}":"v3","oco/order/details/{orderId}":"v3","oco/client-order/{clientOid}":"v3","oco/orders":"v3","hf/margin/orders/active":"v3","hf/margin/order/active/symbols":"v3","hf/margin/orders/done":"v3","hf/margin/orders/{orderId}":"v3","hf/margin/orders/client-order/{clientOid}":"v3","hf/margin/fills":"v3","etf/info":"v3","margin/currencies":"v3","margin/borrow":"v3","margin/repay":"v3","margin/interest":"v3","project/list":"v3","project/marketInterestRate":"v3","redeem/orders":"v3","purchase/orders":"v3","migrate/user/account/status":"v3","margin/symbols":"v3","affiliate/inviter/statistics":"v2","asset/ndbroker/deposit/list":"v1"},POST:{"sub/user/created":"v2","accounts/universal-transfer":"v3","accounts/sub-transfer":"v2","accounts/inner-transfer":"v2","transfer-out":"v3","oco/order":"v3","hf/margin/order":"v3","hf/margin/order/test":"v3","margin/borrow":"v3","margin/repay":"v3",purchase:"v3",redeem:"v3","lend/purchase/update":"v3","position/update-user-leverage":"v3"},DELETE:{"hf/margin/orders/{orderId}":"v3","hf/margin/orders/client-order/{clientOid}":"v3","hf/margin/orders":"v3","oco/order/{orderId}":"v3","oco/client-order/{clientOid}":"v3","oco/orders":"v3"}},futuresPrivate:{POST:{"transfer-out":"v3"}}},partner:{spot:{id:"ccxt",key:"9e58cc35-5b5e-4133-92ec-166e3f077cb8"},future:{id:"ccxtfutures",key:"1b327198-f30c-4f14-a0ac-918871282f15"}},accountsByType:{spot:"trade",margin:"margin",cross:"margin",isolated:"isolated",main:"main",funding:"main",future:"contract",swap:"contract",mining:"pool",hf:"trade_hf"},networks:{BTC:"btc",BTCNATIVESEGWIT:"bech32",ERC20:"eth",TRC20:"trx",HRC20:"heco",MATIC:"matic",KCC:"kcc",SOL:"sol",ALGO:"algo",EOS:"eos",BEP20:"bsc",BEP2:"bnb",ARBONE:"arbitrum",AVAXX:"avax",AVAXC:"avaxc",TLOS:"tlos",CFX:"cfx",ACA:"aca",OPTIMISM:"optimism",ONT:"ont",GLMR:"glmr",CSPR:"cspr",KLAY:"klay",XRD:"xrd",RVN:"rvn",NEAR:"near",APT:"aptos",ETHW:"ethw",TON:"ton",BCH:"bch",BSV:"bchsv",BCHA:"bchabc",OSMO:"osmo",NANO:"nano",XLM:"xlm",VET:"vet",IOST:"iost",ZIL:"zil",XRP:"xrp",TOMO:"tomo",XMR:"xmr",COTI:"coti",XTZ:"xtz",ADA:"ada",WAX:"waxp",THETA:"theta",ONE:"one",IOTEX:"iotx",NULS:"nuls",KSM:"ksm",LTC:"ltc",WAVES:"waves",DOT:"dot",STEEM:"steem",QTUM:"qtum",DOGE:"doge",FIL:"fil",XYM:"xym",FLUX:"flux",ATOM:"atom",XDC:"xdc",KDA:"kda",ICP:"icp",CELO:"celo",LSK:"lsk",VSYS:"vsys",KAR:"kar",XCH:"xch",FLOW:"flow",BAND:"band",EGLD:"egld",HBAR:"hbar",XPR:"xpr",AR:"ar",FTM:"ftm",KAVA:"kava",KMA:"kma",XEC:"xec",IOTA:"iota",HNT:"hnt",ASTR:"astr",PDEX:"pdex",METIS:"metis",ZEC:"zec",POKT:"pokt",OASYS:"oas",OASIS:"oasis",ETC:"etc",AKT:"akt",FSN:"fsn",SCRT:"scrt",CFG:"cfg",ICX:"icx",KMD:"kmd",NEM:"NEM",STX:"stx",DGB:"dgb",DCR:"dcr",CKB:"ckb",ELA:"ela",HYDRA:"hydra",BTM:"btm",KARDIA:"kai",SXP:"sxp",NEBL:"nebl",ZEN:"zen",SDN:"sdn",LTO:"lto",WEMIX:"wemix",EVER:"ever",BNC:"bnc",BNCDOT:"bncdot",AION:"aion",GRIN:"grin",LOKI:"loki",QKC:"qkc",TT:"TT",PIVX:"pivx",SERO:"sero",METER:"meter",STATEMINE:"statemine",DVPN:"dvpn",XPRT:"xprt",MOVR:"movr",ERGO:"ergo",ABBC:"abbc",DIVI:"divi",PURA:"pura",DFI:"dfi",NEON3:"neon3",DOCK:"dock",TRUE:"true",CS:"cs",ORAI:"orai"},marginModes:{cross:"MARGIN_TRADE",isolated:"MARGIN_ISOLATED_TRADE",spot:"TRADE"}}})}nonce(){return this.milliseconds()}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchStatus(e={}){const t=await this.publicGetStatus(e),s=this.safeDict(t,"data",{});return{status:"open"===this.safeString(s,"status")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){let t;[t,e]=this.handleOptionAndParams(e,"fetchMarkets","fetchTickersFees",!0);const s=[];s.push(this.publicGetSymbols(e));const i=this.checkRequiredCredentials(!1);i&&(s.push(this.privateGetMarginSymbols(e)),s.push(this.privateGetIsolatedSymbols(e))),t&&s.push(this.publicGetMarketAllTickers(e));const r=await Promise.all(s),o=this.safeList(r[0],"data"),n=i?this.safeDict(r[1],"data",{}):{},d=this.safeList(n,"items",[]),h=this.indexBy(d,"symbol"),c=i?r[2]:{},l=this.safeList(c,"data",[]),u=this.indexBy(l,"symbol"),p=i?3:1,f=this.safeDict(r,p,{}),m=this.safeList(this.safeDict(f,"data",{}),"ticker",[]),g=this.indexBy(m,"symbol"),v=[];for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"symbol"),[i,r]=s.split("-"),n=this.safeCurrencyCode(i),d=this.safeCurrencyCode(r),c=this.safeDict(g,s,{}),l=this.safeString(c,"makerFeeRate"),p=this.safeString(c,"takerFeeRate"),f=this.safeString(c,"makerCoefficient"),m=this.safeString(c,"takerCoefficient"),y=s in h,w=s in u,b=this.safeBool(t,"isMarginEnabled",!1)||y||w;v.push({id:s,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:b,marginMode:{cross:y,isolated:w},swap:!1,future:!1,option:!1,active:this.safeBool(t,"enableTrading"),contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(a.Y.stringMul(p,m)),maker:this.parseNumber(a.Y.stringMul(l,f)),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"baseIncrement"),price:this.safeNumber(t,"priceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"baseMinSize"),max:this.safeNumber(t,"baseMaxSize")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"quoteMinSize"),max:this.safeNumber(t,"quoteMaxSize")}},created:void 0,info:t})}return v}async loadMigrationStatus(e=!1){if(!("hfMigrated"in this.options)||void 0===this.options.hfMigrated||e){const e=await this.privateGetMigrateUserAccountStatus(),t=this.safeDict(e,"data",{}),s=this.safeInteger(t,"status");this.options.hfMigrated=2===s}}async handleHfAndParams(e={}){await this.loadMigrationStatus();const t=this.safeBool(this.options,"hfMigrated");let s;void 0!==t&&(s=!!t);return[this.safeBool(e,"hf",s),e=this.omit(e,"hf")]}async fetchCurrencies(e={}){const t=[];t.push(this.publicGetCurrencies(e)),t.push(this.fetchWebEndpoint("fetchCurrencies","webExchangeGetCurrencyCurrencyChainInfo",!0));const s=await Promise.all(t),i=this.safeDict(s,0,{}),r=this.safeList(i,"data",[]),a=this.safeDict(s,1,{}),o=this.safeList(a,"data",[]),n=this.groupBy(o,"currency"),d={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"currency"),i=this.safeString(t,"fullName"),a=this.safeCurrencyCode(s);let o,h;const c={},l=this.safeList(t,"chains",[]),u=this.indexBy(this.safeList(n,s,[]),"chain"),p=this.safeString(t,"precision"),f=this.parseNumber(this.parsePrecision(p)),m=l.length;m||(o=!1,h=!1);for(let e=0;e<m;e++){const t=l[e],s=this.safeString(t,"chainId"),i=this.networkIdToCode(s),r=this.safeBool(t,"isWithdrawEnabled",!1);o=void 0===o?r:o||r;const a=this.safeBool(t,"isDepositEnabled",!1);h=void 0===h?a:h||a;const n=this.safeDict(u,s,{});c[i]={info:t,id:s,name:this.safeString(t,"chainName"),code:i,active:r&&a,fee:this.safeNumber(t,"withdrawalMinFee"),deposit:a,withdraw:r,precision:this.parseNumber(this.parsePrecision(this.safeString(n,"walletPrecision"))),limits:{withdraw:{min:this.safeNumber(t,"withdrawalMinSize"),max:void 0},deposit:{min:this.safeNumber(t,"depositMinSize"),max:void 0}}}}const g="2"===p&&0===m;d[a]={id:s,name:i,code:a,type:g?"fiat":"crypto",precision:f,info:t,active:h||o,deposit:h,withdraw:o,fee:void 0,limits:this.limits,networks:c}}return d}async fetchAccounts(e={}){const t=await this.privateGetAccounts(e),s=this.safeList(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"id"),a=this.safeString(t,"currency"),o=this.safeCurrencyCode(a),n=this.safeString(t,"type");i.push({id:r,type:n,currency:o,code:o,info:t})}return i}async fetchTransactionFee(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id};let i;[i,t]=this.handleNetworkCodeAndParams(t),void 0!==i&&(s.chain=this.networkCodeToId(i).toLowerCase());const r=await this.privateGetWithdrawalsQuotas(this.extend(s,t)),a=this.safeDict(r,"data",{}),o={};return o[e]=this.safeNumber(a,"withdrawMinFee"),{info:r,withdraw:o,deposit:{}}}async fetchDepositWithdrawFee(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};let r;[r,t]=this.handleNetworkCodeAndParams(t),void 0!==r&&(i.chain=this.networkCodeToId(r).toLowerCase());const a=await this.privateGetWithdrawalsQuotas(this.extend(i,t)),o=this.safeDict(a,"data");return this.parseDepositWithdrawFee(o,s)}parseDepositWithdrawFee(e,t=void 0){const s={info:e,withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}};let i;if(this.safeBool(e,"isWithdrawEnabled",!0)){s.withdraw.percentage=!1;const r=this.safeList(e,"chains",[]);for(let e=0;e<r.length;e++){const o=r[e],n=this.safeString(o,"chainId"),d=this.networkIdToCode(n,this.safeString(t,"code")),h=this.safeString(o,"withdrawalMinFee");(void 0===i||a.Y.stringLt(h,i))&&(i=h),s.networks[d]={withdraw:this.parseNumber(h),deposit:{fee:void 0,percentage:void 0}}}s.withdraw.fee=this.parseNumber(i)}return s}isFuturesMethod(e,t){const s=this.safeString2(this.options,e,"defaultType","trade"),i=this.safeString(t,"type",s),a=this.safeDict(this.options,"accountsByType"),o=this.safeString(a,i);if(void 0===o){const e=Object.keys(a);throw new r.ExchangeError(this.id+" isFuturesMethod() type must be one of "+e.join(", "))}return t=this.omit(t,"type"),"contract"===o||"future"===o||"futures"===o}parseTicker(e,t=void 0){let s=this.safeString(e,"changeRate");void 0!==s&&(s=a.Y.stringMul(s,"100"));let i=this.safeString2(e,"last","lastTradedPrice");i=this.safeString(e,"price",i);const r=this.safeString(e,"symbol"),o=(t=this.safeMarket(r,t,"-")).symbol,n=this.safeString(e,"vol"),d=this.safeString(e,"volValue"),h=this.safeInteger2(e,"time","datetime");return this.safeTicker({symbol:o,timestamp:h,datetime:this.iso8601(h),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString2(e,"buy","bestBid"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString2(e,"sell","bestAsk"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:this.safeString(e,"changePrice"),percentage:s,average:this.safeString(e,"averagePrice"),baseVolume:n,quoteVolume:d,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketAllTickers(t),i=this.safeDict(s,"data",{}),r=this.safeList(i,"ticker",[]),a=this.safeInteger(i,"time"),o={};for(let e=0;e<r.length;e++){r[e].time=a;const t=this.parseTicker(r[e]),s=this.safeString(t,"symbol");void 0!==s&&(o[s]=t)}return this.filterByArrayTickers(o,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetMarketStats(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,1500);const o=this.market(e),n={symbol:o.id,type:this.safeString(this.timeframes,t,t)},d=1e3*this.parseTimeframe(t);let h=this.milliseconds();void 0!==s?(n.startAt=this.parseToInt(Math.floor(s/1e3)),void 0===i&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",1500)),h=this.sum(s,i*d)):void 0!==i&&(s=h-i*d,n.startAt=this.parseToInt(Math.floor(s/1e3))),n.endAt=this.parseToInt(Math.floor(h/1e3));const c=await this.publicGetMarketCandles(this.extend(n,r)),l=this.safeList(c,"data",[]);return this.parseOHLCVs(l,o,t,s,i)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};let r;[r,t]=this.handleNetworkCodeAndParams(t),void 0!==r&&(i.chain=this.networkCodeToId(r).toLowerCase());const a=await this.privatePostDepositAddresses(this.extend(i,t)),o=this.safeDict(a,"data",{});return this.parseDepositAddress(o,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id};let a;[a,t]=this.handleNetworkCodeAndParams(t),void 0!==a&&(i.chain=this.networkCodeToId(a).toLowerCase());const o=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v1";const n=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=o;const d=this.safeValue(n,"data");if(void 0===d)throw new r.ExchangeError(this.id+" fetchDepositAddress() returned an empty response, you might try to run createDepositAddress() first and try again");return this.parseDepositAddress(d,s)}parseDepositAddress(e,t=void 0){let s,i=this.safeString(e,"address");return void 0!==i&&(i=i.replace("bitcoincash:","")),void 0!==t&&(s=this.safeCurrencyCode(t.id),"NIM"!==s&&this.checkAddress(i)),{info:e,currency:s,address:i,tag:this.safeString(e,"memo"),network:this.networkIdToCode(this.safeString(e,"chain"))}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=this.options.versions.private.GET["deposit-addresses"];this.options.versions.private.GET["deposit-addresses"]="v2";const a=await this.privateGetDepositAddresses(this.extend(i,t));this.options.versions.private.GET["deposit-addresses"]=r;const o=this.safeList(a,"data",[]),n=this.parseDepositAddresses(o,[s.code],!1,{currency:s.code});return this.indexBy(n,"network")}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),a=this.safeInteger(s,"level",2),o={symbol:i.id};let n;if(this.checkRequiredCredentials(!1)&&void 0===t)n=await this.privateGetMarketOrderbookLevel2(this.extend(o,s));else{if(2===a){if(o.level=a,void 0!==t){if(20!==t&&100!==t)throw new r.ExchangeError(this.id+" fetchOrderBook() limit argument must be 20 or 100");o.limit=t}o.limit=t||100}n=await this.publicGetMarketOrderbookLevelLevelLimit(this.extend(o,s))}const d=this.safeDict(n,"data",{}),h=this.safeInteger(d,"time"),c=this.parseOrderBook(d,i.symbol,h,"bids","asks",a-2,a-1);return c.nonce=this.safeInteger(d,"sequence"),c}handleTriggerPrices(e){const t=this.safeValue2(e,"triggerPrice","stopPrice"),s=this.safeValue(e,"stopLossPrice"),i=this.safeValue(e,"takeProfitPrice"),a=void 0!==i;if(void 0!==s&&a||t&&s||t&&a)throw new r.ExchangeError(this.id+" createOrder() - you should use either triggerPrice or stopLossPrice or takeProfitPrice");return[t,s,i]}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"test",!1);let d;a=this.omit(a,"test"),[d,a]=await this.handleHfAndParams(a);const[h,c,l]=this.handleTriggerPrices(a),u=this.safeString(a,"tradeType"),p=h||c||l,f=this.handleMarginModeAndParams("createOrder",a),m=this.safeString(f,0),g="MARGIN_TRADE"===u||void 0!==m,v=this.createOrderRequest(e,t,s,i,r,a);let y;y=n?g?await this.privatePostMarginOrderTest(v):d?await this.privatePostHfOrdersTest(v):await this.privatePostOrdersTest(v):p?await this.privatePostStopOrder(v):g?await this.privatePostMarginOrder(v):d?await this.privatePostHfOrders(v):await this.privatePostOrders(v);const w=this.safeDict(y,"data",{});return this.parseOrder(w,o)}async createMarketOrderWithCost(e,t,s,i={}){return await this.loadMarkets(),i.cost=s,await this.createOrder(e,"market",t,s,void 0,i)}async createMarketBuyOrderWithCost(e,t,s={}){return await this.loadMarkets(),await this.createMarketOrderWithCost(e,"buy",t,s)}async createMarketSellOrderWithCost(e,t,s={}){return await this.loadMarkets(),await this.createMarketOrderWithCost(e,"sell",t,s)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i;for(let t=0;t<e.length;t++){const a=e[t],o=this.safeString(a,"symbol");if(void 0===i)i=o;else if(i!==o)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const n=this.safeString(a,"type");if("limit"!==n)throw new r.BadRequest(this.id+" createOrders() only supports limit orders");const d=this.safeString(a,"side"),h=this.safeValue(a,"amount"),c=this.safeValue(a,"price"),l=this.safeValue(a,"params",{}),u=this.createOrderRequest(o,n,d,h,c,l);s.push(u)}const a={symbol:this.market(i).id,orderList:s};let o,n;[o,t]=await this.handleHfAndParams(t),n=o?await this.privatePostHfOrdersMulti(this.extend(a,t)):await this.privatePostOrdersMulti(this.extend(a,t));let d=this.safeDict(n,"data",{});return d=this.safeList(d,"data",[]),this.parseOrders(d)}marketOrderAmountToPrecision(e,t){const s=this.market(e),i=this.decimalToPrecision(t,o.R3,s.info.quoteIncrement,this.precisionMode,this.paddingMode);if("0"===i)throw new r.InvalidOrder(this.id+" amount of "+s.symbol+" must be greater than minimum amount precision of "+this.numberToString(s.precision.amount));return i}createOrderRequest(e,t,s,i,a=void 0,o={}){const n=this.market(e),d=this.safeString2(o,"clientOid","clientOrderId",this.uuid());o=this.omit(o,["clientOid","clientOrderId"]);const h={clientOid:d,side:s,symbol:n.id,type:t},c=this.safeNumber2(o,"cost","funds");let l,u,p;[p,o]=this.handleMarginModeAndParams("createOrder",o),"market"===t?void 0!==c?(o=this.omit(o,["cost","funds"]),u=this.marketOrderAmountToPrecision(e,c),h.funds=u):(l=this.amountToPrecision(e,i),h.size=this.amountToPrecision(e,i)):(l=this.amountToPrecision(e,i),h.size=l,h.price=this.priceToPrecision(e,a));const f=this.safeString(o,"tradeType"),[m,g,v]=this.handleTriggerPrices(o),y=m||g||v,w="MARGIN_TRADE"===f||void 0!==p;if(o=this.omit(o,["stopLossPrice","takeProfitPrice","triggerPrice","stopPrice"]),y){if(m?h.stopPrice=this.priceToPrecision(e,m):(g||v)&&(g?(h.stop="buy"===s?"entry":"loss",h.stopPrice=this.priceToPrecision(e,g)):(h.stop="buy"===s?"loss":"entry",h.stopPrice=this.priceToPrecision(e,v))),"isolated"===p)throw new r.BadRequest(this.id+" createOrder does not support isolated margin for stop orders");"cross"===p&&(h.tradeType=this.options.marginModes[p])}else w&&"isolated"===p&&(h.marginModel="isolated");let b;return[b,o]=this.handlePostOnly("market"===t,!1,o),b&&(h.postOnly=!0),this.extend(h,o)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={symbol:n.id},h=this.safeString2(o,"clientOid","clientOrderId");void 0!==h?d.clientOid=h:d.orderId=e,void 0!==r&&(d.newSize=this.amountToPrecision(t,r)),void 0!==a&&(d.newPrice=this.priceToPrecision(t,a));const c=await this.privatePostHfOrdersAlter(this.extend(d,o)),l=this.safeDict(c,"data",{});return this.parseOrder(l,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},a=this.safeString2(s,"clientOid","clientOrderId"),o=this.safeBool2(s,"stop","trigger",!1);let n,d;if([n,s]=await this.handleHfAndParams(s),n){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol parameter for hf orders");const e=this.market(t);i.symbol=e.id}if(s=this.omit(s,["clientOid","clientOrderId","stop","trigger"]),void 0!==a)return i.clientOid=a,d=o?await this.privateDeleteStopOrderCancelOrderByClientOid(this.extend(i,s)):n?await this.privateDeleteHfOrdersClientOrderClientOid(this.extend(i,s)):await this.privateDeleteOrderClientOrderClientOid(this.extend(i,s)),d=this.safeDict(d,"data"),this.parseOrder(d);{if(i.orderId=e,o)d=await this.privateDeleteStopOrderOrderId(this.extend(i,s));else{if(n)return d=await this.privateDeleteHfOrdersOrderId(this.extend(i,s)),d=this.safeDict(d,"data"),this.parseOrder(d);d=await this.privateDeleteOrdersOrderId(this.extend(i,s))}const t=this.safeDict(d,"data"),r=this.safeList(t,"cancelledOrderIds",[]),a=this.safeString(r,0);return this.safeOrder({info:t,id:a})}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={},i=this.safeBool(t,"stop",!1);let a;[a,t]=await this.handleHfAndParams(t),t=this.omit(t,"stop");const[o,n]=this.handleMarginModeAndParams("cancelAllOrders",t);if(void 0!==e&&(s.symbol=this.marketId(e)),void 0!==o&&(s.tradeType=this.options.marginModes[o],"isolated"===o&&i))throw new r.BadRequest(this.id+" cancelAllOrders does not support isolated margin for stop orders");let d;return d=i?await this.privateDeleteStopOrderCancel(this.extend(s,n)):a?void 0===e?await this.privateDeleteHfOrdersCancelAll(this.extend(s,n)):await this.privateDeleteHfOrders(this.extend(s,n)):await this.privateDeleteOrders(this.extend(s,n)),d}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();let o=e.toLowerCase();const n=this.safeInteger(a,"until"),d=this.safeBool2(a,"stop","trigger",!1);let h;if([h,a]=await this.handleHfAndParams(a),h&&void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrdersByStatus() requires a symbol parameter for hf orders");a=this.omit(a,["stop","trigger","till","until"]);const[c,l]=this.handleMarginModeAndParams("fetchOrdersByStatus",a);"open"===o?o="active":"closed"===o&&(o="done");const u={status:o};let p,f;void 0!==t&&(p=this.market(t),u.symbol=p.id),void 0!==s&&(u.startAt=s),void 0!==i&&(u.pageSize=i),n&&(u.endAt=n),u.tradeType=this.safeString(this.options.marginModes,c,"TRADE"),d?f=await this.privateGetStopOrder(this.extend(u,l)):h?"active"===o?f=await this.privateGetHfOrdersActive(this.extend(u,l)):"done"===o&&(f=await this.privateGetHfOrdersDone(this.extend(u,l))):f=await this.privateGetOrders(this.extend(u,l));const m=this.safeList(f,"data");if(void 0!==m)return this.parseOrders(m,p,s,i);const g=this.safeDict(f,"data",{}),v=this.safeList(g,"items",[]);return this.parseOrders(v,p,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r?await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i):await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r?await this.fetchPaginatedCallDynamic("fetchOpenOrders",e,t,s,i):await this.fetchOrdersByStatus("active",e,t,s,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},a=this.safeString2(s,"clientOid","clientOrderId"),o=this.safeBool2(s,"stop","trigger",!1);let n,d,h;if([n,s]=await this.handleHfAndParams(s),void 0!==t&&(d=this.market(t)),n){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol parameter for hf orders");i.symbol=d.id}if(s=this.omit(s,["stop","clientOid","clientOrderId","trigger"]),void 0!==a)i.clientOid=a,o?(void 0!==t&&(i.symbol=d.id),h=await this.privateGetStopOrderQueryOrderByClientOid(this.extend(i,s))):h=n?await this.privateGetHfOrdersClientOrderClientOid(this.extend(i,s)):await this.privateGetOrderClientOrderClientOid(this.extend(i,s));else{if(void 0===e)throw new r.InvalidOrder(this.id+" fetchOrder() requires an order id");i.orderId=e,h=o?await this.privateGetStopOrderOrderId(this.extend(i,s)):n?await this.privateGetHfOrdersOrderId(this.extend(i,s)):await this.privateGetOrdersOrderId(this.extend(i,s))}let c=this.safeDict(h,"data",{});return Array.isArray(c)&&(c=this.safeValue(c,0)),this.parseOrder(c,d)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeInteger(e,"createdAt"),r=this.safeString(e,"feeCurrency"),a=this.safeBool(e,"cancelExist",!1),o=void 0!==this.safeString(e,"stop"),n=this.safeBool(e,"stopTriggered",!1),d=this.safeBool2(e,"isActive","active"),h=this.safeString(e,"status");let c;void 0!==d&&(c=!0===d?"open":"closed"),o&&("NEW"===h?c="open":d||n||(c="cancelled")),a&&(c="canceled"),"fail"===h&&(c="rejected");const l=this.safeNumber(e,"stopPrice");return this.safeOrder({info:e,id:this.safeStringN(e,["id","orderId","newOrderId","cancelledOrderId"]),clientOrderId:this.safeString(e,"clientOid"),symbol:this.safeSymbol(s,t,"-"),type:this.safeString(e,"type"),timeInForce:this.safeString(e,"timeInForce"),postOnly:this.safeBool(e,"postOnly"),side:this.safeString(e,"side"),amount:this.safeString(e,"size"),price:this.safeString(e,"price"),stopPrice:l,triggerPrice:l,cost:this.safeString(e,"dealFunds"),filled:this.safeString(e,"dealSize"),remaining:void 0,timestamp:i,datetime:this.iso8601(i),fee:{currency:this.safeCurrencyCode(r),cost:this.safeNumber(e,"fee")},status:c,lastTradeTimestamp:void 0,average:void 0,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a={orderId:e};return await this.fetchMyTrades(t,s,i,this.extend(a,r))}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);let o,n,d={};if([o,i]=await this.handleHfAndParams(i),o&&void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol parameter for hf orders");void 0!==e&&(n=this.market(e),d.symbol=n.id),void 0!==s&&(d.pageSize=s);const h=this.options.fetchMyTradesMethod;let c,l=!1;if([d,i]=this.handleUntilOption("endAt",d,i),o)c=await this.privateGetHfFills(this.extend(d,i));else if("private_get_fills"===h)void 0!==t&&(d.startAt=t),c=await this.privateGetFills(this.extend(d,i));else{if("private_get_limit_fills"!==h)throw new r.ExchangeError(this.id+" fetchMyTradesMethod() invalid method");l=!0,c=await this.privateGetLimitFills(this.extend(d,i))}const u=this.safeDict(c,"data",{});let p;return p=l?u:this.safeList(u,"items",[]),this.parseTrades(p,n,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetMarketHistories(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),r=this.safeString(e,"orderId"),a=this.safeString(e,"liquidity");let o=this.safeInteger(e,"time");void 0!==o?o=this.parseToInt(o/1e6):(o=this.safeInteger(e,"createdAt"),"dealValue"in e&&void 0!==o&&(o*=1e3));const n=this.safeString2(e,"price","dealPrice"),d=this.safeString2(e,"size","amount"),h=this.safeString(e,"side");let c;const l=this.safeString(e,"fee");if(void 0!==l){const s=this.safeString(e,"feeCurrency");let i=this.safeCurrencyCode(s);void 0===i&&(i="sell"===h?t.quote:t.base),c={cost:l,currency:i,rate:this.safeString(e,"feeRate")}}let u=this.safeString(e,"type");"match"===u&&(u=void 0);const p=this.safeString2(e,"funds","dealValue");return this.safeTrade({info:e,id:i,order:r,timestamp:o,datetime:this.iso8601(o),symbol:t.symbol,type:u,takerOrMaker:a,side:h,price:n,amount:d,cost:p,fee:c},t)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},r=await this.privateGetTradeFees(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0),n=this.safeString(o,"symbol");return{info:r,symbol:this.safeSymbol(n,s),maker:this.safeNumber(o,"makerFeeRate"),taker:this.safeNumber(o,"takerFeeRate"),percentage:!0,tierBased:!0}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets(),this.checkAddress(s);const a=this.currency(e),o={currency:a.id,address:s};let n,d;void 0!==i&&(o.memo=i),[n,r]=this.handleNetworkCodeAndParams(r),void 0!==n&&(o.chain=this.networkCodeToId(n).toLowerCase()),await this.loadCurrencyPrecision(a,n),o.amount=this.currencyToPrecision(e,t,n),[d,r]=this.handleOptionAndParams(r,"withdraw","includeFee",!1),d&&(o.feeDeductType="INTERNAL");const h=await this.privatePostWithdrawals(this.extend(o,r)),c=this.safeDict(h,"data",{});return this.parseTransaction(c,a)}async loadCurrencyPrecision(e,t=void 0){if(void 0!==t){const s=e.networks,i=this.safeDict(s,t);if(void 0!==this.safeNumber(i,"precision"))return;const r={currency:e.id,chain:this.networkCodeToId(t).toLowerCase()},a=await this.privateGetWithdrawalsQuotas(r),o=this.safeDict(a,"data",{}),n=this.parseNumber(this.parsePrecision(this.safeString(o,"precision"))),d=e.code;this.currencies[d].networks[t].precision=n}}parseTransactionStatus(e){return this.safeString({SUCCESS:"ok",PROCESSING:"pending",WALLET_PROCESSING:"pending",FAILURE:"failed"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeCurrencyCode(s,t);let r=this.safeString(e,"address");const o=this.safeString(e,"amount");let n=this.safeString(e,"walletTxId");if(void 0!==n){const e=n.split("@");e.length>1&&void 0===r&&e[1].length>1&&(r=e[1]),n=e[0]}let d=void 0===n?"withdrawal":"deposit";const h=this.safeString(e,"status");let c;const l=this.safeString(e,"fee");if(void 0!==l){let e;void 0!==o&&(e=a.Y.stringDiv(l,o)),c={cost:this.parseNumber(l),rate:this.parseNumber(e),currency:i}}let u=this.safeInteger2(e,"createdAt","createAt"),p=this.safeInteger(e,"updatedAt");!("createdAt"in e)&&(d="address"in e?"withdrawal":"deposit",void 0!==u&&(u*=1e3),void 0!==p&&(p*=1e3));const f=this.safeBool(e,"isInner"),m=this.safeString(e,"memo");return{info:e,id:this.safeString2(e,"id","withdrawalId"),timestamp:u,datetime:this.iso8601(u),network:this.networkIdToCode(this.safeString(e,"chain")),address:r,addressTo:r,addressFrom:void 0,tag:m,tagTo:m,tagFrom:void 0,currency:i,amount:this.parseNumber(o),txid:n,type:d,status:this.parseTransactionStatus(h),comment:this.safeString(e,"remark"),internal:f,fee:c,updated:p}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchDeposits",e,t,s,i);let a,o,n={};void 0!==e&&(a=this.currency(e),n.currency=a.id),void 0!==s&&(n.pageSize=s),[n,i]=this.handleUntilOption("endAt",n,i),void 0!==t&&t<1550448e6?(n.startAt=this.parseToInt(t/1e3),o=await this.privateGetHistDeposits(this.extend(n,i))):(void 0!==t&&(n.startAt=t),o=await this.privateGetDeposits(this.extend(n,i)));const d=this.safeDict(o,"data",{}),h=this.safeList(d,"items",[]);return this.parseTransactions(h,a,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchWithdrawals",e,t,s,i);let a,o,n={};void 0!==e&&(a=this.currency(e),n.currency=a.id),void 0!==s&&(n.pageSize=s),[n,i]=this.handleUntilOption("endAt",n,i),void 0!==t&&t<1550448e6?(n.startAt=this.parseToInt(t/1e3),o=await this.privateGetHistWithdrawals(this.extend(n,i))):(void 0!==t&&(n.startAt=t),o=await this.privateGetWithdrawals(this.extend(n,i)));const d=this.safeDict(o,"data",{}),h=this.safeList(d,"items",[]);return this.parseTransactions(h,a,t,s,{type:"withdrawal"})}parseBalanceHelper(e){const t=this.account();t.used=this.safeString2(e,"holdBalance","hold"),t.free=this.safeString2(e,"availableBalance","available"),t.total=this.safeString2(e,"totalBalance","total");const s=this.safeString(e,"liability"),i=this.safeString(e,"interest");return t.debt=a.Y.stringAdd(s,i),t}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"code");let s;void 0!==t&&(s=this.currency(t));const i=this.safeString2(this.options,"fetchBalance","defaultType","spot"),r=this.safeString(e,"type",i),a=this.safeDict(this.options,"accountsByType");let o,n=this.safeString(a,r,r);e=this.omit(e,"type"),[o,e]=await this.handleHfAndParams(e),o&&(n="trade_hf");const[d,h]=this.handleMarginModeAndParams("fetchBalance",e);let c;const l={},u="isolated"===d||"isolated"===n,p="cross"===d||"margin"===n;let f;u?(void 0!==s&&(l.balanceCurrency=s.id),c=await this.privateGetIsolatedAccounts(this.extend(l,h))):p?c=await this.privateGetMarginAccount(this.extend(l,h)):(void 0!==s&&(l.currency=s.id),l.type=n,c=await this.privateGetAccounts(this.extend(l,h)));const m={info:c,timestamp:void 0,datetime:void 0};if(u){f=this.safeDict(c,"data",{});const e=this.safeValue(f,"assets",f);for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"symbol"),r=this.safeSymbol(i,void 0,"_"),a=this.safeDict(s,"baseAsset",{}),o=this.safeDict(s,"quoteAsset",{}),n=this.safeCurrencyCode(this.safeString(a,"currency")),d=this.safeCurrencyCode(this.safeString(o,"currency")),h={};h[n]=this.parseBalanceHelper(a),h[d]=this.parseBalanceHelper(o),m[r]=this.safeBalance(h)}}else if(p){f=this.safeDict(c,"data",{});const e=this.safeList(f,"accounts",[]);for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"currency");m[this.safeCurrencyCode(i)]=this.parseBalanceHelper(s)}}else{f=this.safeList(c,"data",[]);for(let e=0;e<f.length;e++){const t=f[e];if(this.safeString(t,"type")===n){const e=this.safeString(t,"currency"),s=this.safeCurrencyCode(e),i=this.account();i.total=this.safeString(t,"balance"),i.free=this.safeString(t,"available"),i.used=this.safeString(t,"holds"),m[s]=i}}}return u?m:this.safeBalance(m)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n=this.currencyToPrecision(e,t);let d=this.convertTypeToAccount(s),h=this.convertTypeToAccount(i);const c=this.inArray(d,this.ids),l=this.inArray(h,this.ids);if("contract"===d){if("main"!==h)throw new r.ExchangeError(this.id+" transfer() only supports transferring from futures account to main account");const e={currency:o.id,amount:n};"bizNo"in a||(e.bizNo=this.uuid22());const t=await this.futuresPrivatePostTransferOut(this.extend(e,a)),s=this.safeDict(t,"data");return this.parseTransfer(s,o)}{const e={currency:o.id,amount:n};(c||l)&&(this.inArray(d,this.ids)&&(e.fromTag=d,d="isolated"),this.inArray(h,this.ids)&&(e.toTag=h,h="isolated")),e.from=d,e.to=h,"clientOid"in a||(e.clientOid=this.uuid());const t=await this.privatePostAccountsInnerTransfer(this.extend(e,a)),s=this.safeDict(t,"data");return this.parseTransfer(s,o)}}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"createdAt"),i=this.safeString(e,"currency"),r=this.safeString(e,"status"),a=this.safeStringLower(e,"payAccountType"),o=this.safeStringLower(e,"recAccountType"),n=this.safeDict(this.options,"accountsByType"),d=this.safeString(n,a,a),h=this.safeString(n,o,o);return{id:this.safeString2(e,"applyId","orderId"),currency:this.safeCurrencyCode(i,t),timestamp:s,datetime:this.iso8601(s),amount:this.safeNumber(e,"amount"),fromAccount:d,toAccount:h,status:this.parseTransferStatus(r),info:e}}parseTransferStatus(e){return this.safeString({PROCESSING:"pending"},e,e)}parseLedgerEntryType(e){return this.safeString({"Assets Transferred in After Upgrading":"transfer",Deposit:"transaction",Withdrawal:"transaction",Transfer:"transfer",Trade_Exchange:"trade","KuCoin Bonus":"bonus","Referral Bonus":"referral",Rewards:"bonus","Airdrop/Fork":"airdrop","Other rewards":"bonus","Fee Rebate":"rebate","Buy Crypto":"trade","Sell Crypto":"sell","Public Offering Purchase":"trade","Refunded Fees":"fee","KCS Pay Fees":"fee","Margin Trade":"trade",Loans:"Loans","Instant Exchange":"trade","Sub-account transfer":"transfer","Liquidation Fees":"fee"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i,t),a=this.safeNumber(e,"amount"),o=this.safeString(e,"bizType"),n=this.parseLedgerEntryType(o),d=this.safeString(e,"direction"),h=this.safeInteger(e,"createdAt"),c=this.iso8601(h),l=this.safeString(e,"accountType"),u=this.safeString(e,"context");let p,f;if(void 0!==u&&""!==u)try{const e=JSON.parse(u),t=this.safeString(e,"orderId"),s=this.safeString(e,"tradeId");p=void 0!==s?s:t}catch(e){p=u}const m=this.safeString(e,"fee");let g;return"0"!==m&&(g=r,f={cost:this.parseNumber(m),currency:g}),{id:s,direction:d,account:l,referenceId:p,referenceAccount:l,type:n,currency:r,amount:a,timestamp:h,datetime:c,before:void 0,after:undefined,status:void 0,fee:f,info:e}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.loadAccounts();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),[r,i]=await this.handleHfAndParams(i),a)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i);let o,n,d,h={};void 0!==t&&(h.startAt=t),void 0!==e&&(o=this.currency(e),h.currency=o.id),[h,i]=this.handleUntilOption("endAt",h,i),[n,i]=this.handleMarginModeAndParams("fetchLedger",i),d=r?void 0!==n?await this.privateGetHfMarginAccountLedgers(this.extend(h,i)):await this.privateGetHfAccountsLedgers(this.extend(h,i)):await this.privateGetAccountsLedgers(this.extend(h,i));const c=this.safeList(d,"data");if(void 0!==c)return this.parseLedger(c,o,t,s);const l=this.safeDict(d,"data"),u=this.safeList(l,"items",[]);return this.parseLedger(u,o,t,s)}calculateRateLimiterCost(e,t,s,i,r={}){const a=this.safeDict(this.options,"versions",{}),o=this.safeDict(a,e,{}),n=this.safeDict(o,t,{}),d=this.safeString(n,s,this.options.version),h=this.safeString(i,"version",d);return"v3"===h&&"v3"in r?r.v3:"v2"===h&&"v2"in r?r.v2:"v1"===h&&"v1"in r?r.v1:this.safeValue(r,"cost",1)}parseBorrowRateHistory(e,t,s,i){const r=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.parseBorrowRate(s);r.push(i)}const a=this.sortBy(r,"timestamp");return this.filterByCurrencySinceLimit(a,t,s,i)}parseBorrowRate(e,t=void 0){const s=this.safeString2(e,"createdAt","timestamp"),i=this.parseToInt(s.slice(0,13)),r=this.safeString(e,"currency");return{currency:this.safeCurrencyCode(r,t),rate:this.safeNumber2(e,"dailyIntRate","dayRatio"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),[a,r]=this.handleMarginModeAndParams("fetchBorrowInterest",r),void 0===a&&(a="cross");const o={};let n;if(void 0!==e){const t=this.currency(e);o.quoteCurrency=t.id}n="isolated"===a?await this.privateGetIsolatedAccounts(this.extend(o,r)):await this.privateGetMarginAccounts(this.extend(o,r));const d=this.safeDict(n,"data",{}),h="isolated"===a?this.safeList(d,"assets",[]):this.safeList(d,"accounts",[]);return this.parseBorrowInterests(h,void 0)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"symbol"),i=void 0===s?"cross":"isolated";t=this.safeMarket(s,t);const r=this.safeString(t,"symbol"),a=this.safeInteger(e,"createdAt"),o=this.safeDict(e,"baseAsset",{});let n,d,h;return"isolated"===i?(n=this.safeNumber(o,"liability"),d=this.safeNumber(o,"interest"),h=this.safeString(o,"currency")):(n=this.safeNumber(e,"liability"),d=this.safeNumber(e,"accruedInterest"),h=this.safeString(e,"currency")),{symbol:r,marginMode:i,currency:this.safeCurrencyCode(h),interest:d,interestRate:this.safeNumber(e,"dailyIntRate"),amountBorrowed:n,timestamp:a,datetime:this.iso8601(a),info:e}}async fetchBorrowRateHistories(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.handleMarginModeAndParams("fetchBorrowRateHistories",i);let a={isIsolated:"isolated"===this.safeString(r,0,"cross")};void 0!==t&&(a.startTime=t),[a,i]=this.handleUntilOption("endTime",a,i),void 0!==s&&(a.pageSize=s);const o=await this.privateGetMarginInterest(this.extend(a,i)),n=this.safeDict(o,"data"),d=this.safeList(n,"items",[]);return this.parseBorrowRateHistories(d,e,t,s)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.handleMarginModeAndParams("fetchBorrowRateHistories",i);let a={isIsolated:"isolated"===this.safeString(r,0,"cross"),currency:this.currency(e).id};void 0!==t&&(a.startTime=t),[a,i]=this.handleUntilOption("endTime",a,i),void 0!==s&&(a.pageSize=s);const o=await this.privateGetMarginInterest(this.extend(a,i)),n=this.safeDict(o,"data"),d=this.safeList(n,"items",[]);return this.parseBorrowRateHistory(d,e,t,s)}parseBorrowRateHistories(e,t,s,i){const r={};for(let s=0;s<e.length;s++){const i=e[s],a=this.safeCurrencyCode(this.safeString(i,"currency"));if(void 0===t||this.inArray(a,t)){a in r||(r[a]=[]);const e=this.parseBorrowRate(i);r[a].push(e)}}const a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e];r[t]=this.filterByCurrencySinceLimit(r[t],t,s,i)}return r}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={currency:i.id,size:this.currencyToPrecision(e,t),timeInForce:"FOK"},a=await this.privatePostMarginBorrow(this.extend(r,s)),o=this.safeDict(a,"data",{});return this.parseMarginLoan(o,i)}async borrowIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o={currency:a.id,size:this.currencyToPrecision(t,s),symbol:r.id,timeInForce:"FOK",isIsolated:!0},n=await this.privatePostMarginBorrow(this.extend(o,i)),d=this.safeDict(n,"data",{});return this.parseMarginLoan(d,a)}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={currency:i.id,size:this.currencyToPrecision(e,t)},a=await this.privatePostMarginRepay(this.extend(r,s)),o=this.safeDict(a,"data",{});return this.parseMarginLoan(o,i)}async repayIsolatedMargin(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.currency(t),o={currency:a.id,size:this.currencyToPrecision(t,s),symbol:r.id,isIsolated:!0},n=await this.privatePostMarginRepay(this.extend(o,i)),d=this.safeDict(n,"data",{});return this.parseMarginLoan(d,a)}parseMarginLoan(e,t=void 0){const s=this.milliseconds(),i=this.safeString(e,"currency");return{id:this.safeString(e,"orderNo"),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"actualSize"),symbol:void 0,timestamp:s,datetime:this.iso8601(s),info:e}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCurrencies(t),i=this.safeList(s,"data",[]);return this.parseDepositWithdrawFees(i,e,"currency")}async setLeverage(e,t=void 0,s={}){let i,a,o;if(await this.loadMarkets(),[a,s]=this.handleMarketTypeAndParams("setLeverage",void 0,s),(void 0!==t||"spot"!==a)&&(i=this.market(t),i.contract))throw new r.NotSupported(this.id+" setLeverage currently supports only spot margin");if([o,s]=this.handleMarginModeAndParams("setLeverage",s),void 0===o)throw new r.ArgumentsRequired(this.id+" setLeverage requires a marginMode parameter");const n={};if("isolated"===o&&void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage requires a symbol parameter for isolated margin");return void 0!==t&&(n.symbol=i.id),n.leverage=e.toString(),n.isIsolated="isolated"===o,await this.privatePostPositionUpdateUserLeverage(this.extend(n,s))}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeDict(this.options,"versions",{}),d=this.safeDict(o,t,{}),h=this.safeDict(d,s,{}),c=this.safeString(h,e,this.options.version),l=this.safeString(i,"version",c);i=this.omit(i,"version");let u="/api/"+l+"/"+this.implodeParams(e,i);"webExchange"===t&&(u="/"+this.implodeParams(e,i)),"earn"===t&&(u="/api/v1/"+this.implodeParams(e,i));const p=this.omit(i,this.extractParams(e));let f="";r=void 0!==r?r:{};let m=this.urls.api[t];this.isEmpty(p)||("GET"===s||"DELETE"===s?u+="?"+this.rawencode(p):(f=a=this.json(p),r["Content-Type"]="application/json")),m+=u;const g="futuresPrivate"===t,v="broker"===t;if("private"===t||g||v||"earn"===t){this.checkRequiredCredentials();const e=this.nonce().toString();r=this.extend({"KC-API-KEY-VERSION":"2","KC-API-KEY":this.apiKey,"KC-API-TIMESTAMP":e},r);if("2"===this.safeString(r,"KC-API-KEY-VERSION")){const e=this.hmac(this.encode(this.password),this.encode(this.secret),n.s,"base64");r["KC-API-PASSPHRASE"]=e}else r["KC-API-PASSPHRASE"]=this.password;const t=e+s+u+f,i=this.hmac(this.encode(t),this.encode(this.secret),n.s,"base64");r["KC-API-SIGN"]=i;let a=this.safeDict(this.options,"partner",{});a=g?this.safeValue(a,"future",a):this.safeValue(a,"spot",a);const o=this.safeString(a,"id"),d=this.safeString2(a,"secret","key");if(void 0!==o&&void 0!==d){const t=e+o+this.apiKey,s=this.hmac(this.encode(t),this.encode(d),n.s,"base64");r["KC-API-PARTNER-SIGN"]=s,r["KC-API-PARTNER"]=o,r["KC-API-PARTNER-VERIFY"]="true"}if(v){const e=this.safeString(a,"name");void 0!==e&&(r["KC-BROKER-NAME"]=e)}}return{url:m,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return void this.throwBroadlyMatchedException(this.exceptions.broad,o,o);const c=this.safeString(n,"code"),l=this.safeString2(n,"msg","data",""),u=this.id+" "+l;if(this.throwExactlyMatchedException(this.exceptions.exact,l,u),this.throwExactlyMatchedException(this.exceptions.exact,c,u),this.throwBroadlyMatchedException(this.exceptions.broad,o,u),"200000"!==c&&"200"!==c)throw new r.ExchangeError(u)}}},6217:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2079),r=s(5147),a=s(1579),o=s(3942);class n extends o.A{describe(){return this.deepExtend(super.describe(),{id:"kucoinfutures",name:"KuCoin Futures",countries:["SC"],rateLimit:75,version:"v1",certified:!0,pro:!0,comment:"Platform 2.0",quoteJsonNumbers:!1,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!0,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!0,closePositions:!1,createDepositAddress:!0,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTriggerOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!0,fetchLedger:!0,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTransactionFee:!1,fetchWithdrawals:!0,setLeverage:!1,setMarginMode:!1,transfer:!0,withdraw:void 0},urls:{logo:"https://user-images.githubusercontent.com/1294454/147508995-9e35030a-d046-43a1-a006-6fabd981b554.jpg",doc:["https://docs.kucoin.com/futures","https://docs.kucoin.com"],www:"https://futures.kucoin.com/",referral:"https://futures.kucoin.com/?rcode=E5wkqe",api:{public:"https://openapi-v2.kucoin.com",private:"https://openapi-v2.kucoin.com",futuresPrivate:"https://api-futures.kucoin.com",futuresPublic:"https://api-futures.kucoin.com",webExchange:"https://futures.kucoin.com/_api/web-front"}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},api:{futuresPublic:{get:{"contracts/active":1,"contracts/{symbol}":1,"contracts/risk-limit/{symbol}":1,ticker:1,allTickers:1,"level2/snapshot":1.33,"level2/depth{limit}":1,"level2/message/query":1,"level3/message/query":1,"level3/snapshot":1,"trade/history":1,"interest/query":1,"index/query":1,"mark-price/{symbol}/current":1,"premium/query":1,"funding-rate/{symbol}/current":1,timestamp:1,status:1,"kline/query":1},post:{"bullet-public":1}},futuresPrivate:{get:{"account-overview":1.33,"transaction-history":4.44,"deposit-address":1,"deposit-list":1,"withdrawals/quotas":1,"withdrawal-list":1,"transfer-list":1,orders:1.33,stopOrders:1,recentDoneOrders:1,"orders/{orderId}":1,"orders/byClientOid":1,fills:4.44,recentFills:4.44,openOrderStatistics:1,position:1,positions:4.44,"funding-history":4.44,"sub/api-key":1,"trade-statistics":1,"trade-fees":1,"history-positions":1,getMaxOpenSize:1},post:{withdrawals:1,"transfer-out":1,"transfer-in":1,orders:1.33,"orders/test":1.33,"position/margin/auto-deposit-status":1,"position/margin/deposit-margin":1,"position/risk-limit-level/change":1,"bullet-private":1,"sub/api-key":1,"sub/api-key/update":1},delete:{"withdrawals/{withdrawalId}":1,"cancel/transfer-out":1,"orders/{orderId}":1,orders:4.44,stopOrders:1,"sub/api-key":1,"orders/client-order/{clientOid}":1}},webExchange:{get:{"contract/{symbol}/funding-rates":1}}},precisionMode:a.kb,exceptions:{exact:{400:i.BadRequest,401:i.AuthenticationError,403:i.NotSupported,404:i.NotSupported,405:i.NotSupported,415:i.BadRequest,429:i.RateLimitExceeded,500:i.ExchangeNotAvailable,503:i.ExchangeNotAvailable,100001:i.InvalidOrder,100004:i.BadRequest,101030:i.PermissionDenied,200004:i.InsufficientFunds,230003:i.InsufficientFunds,260100:i.InsufficientFunds,300003:i.InsufficientFunds,300012:i.InvalidOrder,400001:i.AuthenticationError,400002:i.InvalidNonce,400003:i.AuthenticationError,400004:i.AuthenticationError,400005:i.AuthenticationError,400006:i.AuthenticationError,400007:i.AuthenticationError,404e3:i.NotSupported,400100:i.BadRequest,411100:i.AccountSuspended,5e5:i.ExchangeNotAvailable},broad:{"Position does not exist":i.OrderNotFound}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0006"),maker:this.parseNumber("0.0002"),tiers:{taker:[[this.parseNumber("0"),this.parseNumber("0.0006")],[this.parseNumber("50"),this.parseNumber("0.0006")],[this.parseNumber("200"),this.parseNumber("0.0006")],[this.parseNumber("500"),this.parseNumber("0.0005")],[this.parseNumber("1000"),this.parseNumber("0.0004")],[this.parseNumber("2000"),this.parseNumber("0.0004")],[this.parseNumber("4000"),this.parseNumber("0.00038")],[this.parseNumber("8000"),this.parseNumber("0.00035")],[this.parseNumber("15000"),this.parseNumber("0.00032")],[this.parseNumber("25000"),this.parseNumber("0.0003")],[this.parseNumber("40000"),this.parseNumber("0.0003")],[this.parseNumber("60000"),this.parseNumber("0.0003")],[this.parseNumber("80000"),this.parseNumber("0.0003")]],maker:[[this.parseNumber("0"),this.parseNumber("0.02")],[this.parseNumber("50"),this.parseNumber("0.015")],[this.parseNumber("200"),this.parseNumber("0.01")],[this.parseNumber("500"),this.parseNumber("0.01")],[this.parseNumber("1000"),this.parseNumber("0.01")],[this.parseNumber("2000"),this.parseNumber("0")],[this.parseNumber("4000"),this.parseNumber("0")],[this.parseNumber("8000"),this.parseNumber("0")],[this.parseNumber("15000"),this.parseNumber("-0.003")],[this.parseNumber("25000"),this.parseNumber("-0.006")],[this.parseNumber("40000"),this.parseNumber("-0.009")],[this.parseNumber("60000"),this.parseNumber("-0.012")],[this.parseNumber("80000"),this.parseNumber("-0.015")]]}},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{HOT:"HOTNOW",EDGE:"DADI",WAX:"WAXP",TRY:"Trias",VAI:"VAIOT",XBT:"BTC"},timeframes:{"1m":1,"3m":void 0,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":240,"6h":void 0,"8h":480,"12h":720,"1d":1440,"1w":10080},options:{version:"v1",symbolSeparator:"-",defaultType:"swap",code:"USDT",marginModes:{},marginTypes:{},versions:{futuresPrivate:{GET:{getMaxOpenSize:"v2"},POST:{"transfer-out":"v2"}},futuresPublic:{GET:{"level3/snapshot":"v2"}}},networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"}}})}async fetchStatus(e={}){const t=await this.futuresPublicGetStatus(e),s=this.safeValue(t,"data",{});return{status:"open"===this.safeString(s,"status")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.futuresPublicGetContractsActive(e),s=[],i=this.safeValue(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],a=this.safeString(t,"symbol"),o=this.safeInteger(t,"expireDate"),n=!!o,d=!n,h=this.safeString(t,"baseCurrency"),c=this.safeString(t,"quoteCurrency"),l=this.safeString(t,"settleCurrency"),u=this.safeCurrencyCode(h),p=this.safeCurrencyCode(c),f=this.safeCurrencyCode(l);let m=u+"/"+p+":"+f,g="swap";n&&(m=m+"-"+this.yymmdd(o,""),g="future");const v=this.safeValue(t,"isInverse"),y=this.safeString(t,"status"),w=this.safeString(t,"multiplier"),b=this.safeNumber(t,"tickSize"),S=this.safeNumber(t,"lotSize");let k=S;void 0===k&&(k=this.safeNumber(t,"baseMinSize"));let O=this.safeNumber(t,"maxOrderQty");void 0===O&&(O=this.safeNumber(t,"baseMaxSize"));let T=this.safeNumber(t,"maxPrice");if(void 0===T){const e=this.safeString(t,"baseMinSize"),s=this.safeString(t,"quoteMaxSize");T=this.parseNumber(r.Y.stringDiv(s,e))}s.push({id:a,symbol:m,base:u,quote:p,settle:f,baseId:h,quoteId:c,settleId:l,type:g,spot:!1,margin:!1,swap:d,future:n,option:!1,active:"Open"===y,contract:!0,linear:!v,inverse:v,taker:this.safeNumber(t,"takerFeeRate"),maker:this.safeNumber(t,"makerFeeRate"),contractSize:this.parseNumber(r.Y.stringAbs(w)),expiry:o,expiryDatetime:this.iso8601(o),strike:void 0,optionType:void 0,precision:{amount:S,price:b},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(t,"maxLeverage")},amount:{min:k,max:O},price:{min:b,max:T},cost:{min:this.safeNumber(t,"quoteMinSize"),max:this.safeNumber(t,"quoteMaxSize")}},created:this.safeInteger(t,"firstOpenDate"),info:t})}return s}async fetchTime(e={}){const t=await this.futuresPublicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,200);const o=this.market(e),n=o.id,d=this.safeInteger(this.timeframes,t),h={symbol:n};h.granularity=void 0!==d?d:t;const c=1e3*this.parseTimeframe(t);let l=this.milliseconds();void 0!==s?(h.from=s,void 0===i&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),l=this.sum(s,i*c)):void 0!==i&&(s=l-i*c,h.from=s),h.to=l;const u=await this.futuresPublicGetKlineQuery(this.extend(h,r)),p=this.safeList(u,"data",[]);return this.parseOHLCVs(p,o,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e).id,i={currency:s},r=await this.futuresPrivateGetDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data",{}),o=this.safeString(a,"address");return"NIM"!==s&&this.checkAddress(o),{info:r,currency:s,address:o,tag:this.safeString(a,"memo"),network:this.safeString(a,"chain")}}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const r=this.safeNumber(s,"level");if(2!==r&&void 0!==r)throw new i.BadRequest(this.id+" fetchOrderBook() can only return level 2");const a=this.market(e),o={symbol:a.id};if(void 0!==t){if(20!==t&&100!==t)throw new i.BadRequest(this.id+" fetchOrderBook() limit argument must be 20 or 100");o.limit=t}else o.limit=20;const n=await this.futuresPublicGetLevel2DepthLimit(this.extend(o,s)),d=this.safeValue(n,"data",{}),h=this.parseToInt(this.safeInteger(d,"ts")/1e6),c=this.parseOrderBook(d,a.symbol,h,"bids","asks",0,1);return c.nonce=this.safeInteger(d,"sequence"),c}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.futuresPublicGetTicker(this.extend(i,t));return this.parseTicker(r.data,s)}async fetchTickers(e=void 0,t={}){let s,i;await this.loadMarkets(),e=this.marketSymbols(e),[s,t]=this.handleOptionAndParams(t,"fetchTickers","method","futuresPublicGetContractsActive"),i="futuresPublicGetAllTickers"===s?await this.futuresPublicGetAllTickers(t):await this.futuresPublicGetContractsActive(t);const r=this.safeList(i,"data"),a=this.parseTickers(r,e);return this.filterByArrayTickers(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"price","lastTradePrice"),r=this.safeIntegerProduct(e,"ts",1e-6);return this.safeTicker({symbol:t.symbol,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:this.safeString(e,"priceChg"),percentage:this.safeString(e,"priceChgPct"),average:void 0,baseVolume:this.safeString(e,"volumeOf24h"),quoteVolume:this.safeString(e,"turnoverOf24h"),info:e},t)}async fetchBidsAsks(e=void 0,t={}){return await this.fetchTickers(e,this.extend({method:"futuresPublicGetAllTickers"},t))}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,r={}){if(void 0===e)throw new i.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const a={symbol:this.market(e).id};void 0!==t&&(a.startAt=t),void 0!==s&&(a.maxCount=s);const o=await this.futuresPrivateGetFundingHistory(this.extend(a,r)),n=this.safeValue(o,"data"),d=this.safeValue(n,"dataList",[]),h=[];for(let t=0;t<d.length;t++){const s=d[t],i=this.safeInteger(s,"timePoint");h.push({info:s,symbol:e,code:this.safeCurrencyCode(this.safeString(s,"settleCurrency")),timestamp:i,datetime:this.iso8601(i),id:this.safeNumber(s,"id"),amount:this.safeNumber(s,"funding"),fundingRate:this.safeNumber(s,"fundingRate"),markPrice:this.safeNumber(s,"markPrice"),positionQty:this.safeNumber(s,"positionQty"),positionCost:this.safeNumber(s,"positionCost")})}return h}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.futuresPrivateGetPosition(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.futuresPrivateGetPositions(t),i=this.safeList(s,"data");return this.parsePositions(i,e)}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),void 0===s&&(s=200);const r={limit:s};void 0!==t&&(r.from=t);const a=this.safeInteger(i,"until");void 0!==a&&(i=this.omit(i,"until"),r.to=a);const o=await this.futuresPrivateGetHistoryPositions(this.extend(r,i)),n=this.safeDict(o,"data"),d=this.safeList(n,"items",[]);return this.parsePositions(d,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"currentTimestamp"),a=this.safeString(e,"currentQty");let o;const n=this.safeStringLower(e,"type");void 0!==a?r.Y.stringGt(a,"0")?o="long":r.Y.stringLt(a,"0")&&(o="short"):void 0!==n&&(o=n.indexOf("long")>-1?"long":"short");const d=r.Y.stringAbs(this.safeString(e,"posCost")),h=this.safeString(e,"posInit"),c=r.Y.stringDiv(h,d),l=this.safeString(e,"unrealisedPnl"),u=this.safeValue(e,"crossMode");let p;return void 0!==u&&(p=u?"cross":"isolated"),this.safePosition({info:e,id:this.safeString2(e,"id","positionId"),symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),lastUpdateTimestamp:this.safeInteger(e,"closeTime"),initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(c),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber2(e,"avgEntryPrice","openPrice"),notional:this.parseNumber(d),leverage:this.safeNumber2(e,"realLeverage","leverage"),unrealizedPnl:this.parseNumber(l),contracts:this.parseNumber(r.Y.stringAbs(a)),contractSize:this.safeValue(t,"contractSize"),realizedPnl:this.safeNumber2(e,"realisedPnl","pnl"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,collateral:this.safeNumber(e,"maintMargin"),marginMode:p,side:o,percentage:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.safeBool(a,"test",!1);a=this.omit(a,"test");const d=this.createContractOrderRequest(e,t,s,i,r,a);let h;h=n?await this.futuresPrivatePostOrdersTest(d):await this.futuresPrivatePostOrders(d);const c=this.safeDict(h,"data",{});return this.parseOrder(c,o)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.market(r),o=this.safeString(i,"type"),n=this.safeString(i,"side"),d=this.safeValue(i,"amount"),h=this.safeValue(i,"price"),c=this.safeValue(i,"params",{}),l=this.createContractOrderRequest(a.id,o,n,d,h,c);s.push(l)}const i=await this.futuresPrivatePostOrdersMulti(s),r=this.safeList(i,"data",[]);return this.parseOrders(r)}createContractOrderRequest(e,t,s,r,a=void 0,o={}){const n=this.market(e),d=this.safeString2(o,"clientOid","clientOrderId",this.uuid());if(o=this.omit(o,["clientOid","clientOrderId"]),r<1)throw new i.InvalidOrder(this.id+" createOrder() minimum contract order amount is 1");const h=parseInt(this.amountToPrecision(e,r)),c={clientOid:d,side:s,symbol:n.id,type:t,size:h,leverage:1},[l,u,p]=this.handleTriggerPrices(o),f=this.safeString(o,"triggerPriceType","mark"),m=this.safeString({mark:"MP",last:"TP",index:"IP"},f,f);o=this.omit(o,["stopLossPrice","takeProfitPrice","triggerPrice","stopPrice"]),l?(c.stop="buy"===s?"up":"down",c.stopPrice=this.priceToPrecision(e,l),c.stopPriceType=m):(u||p)&&(u?(c.stop="buy"===s?"up":"down",c.stopPrice=this.priceToPrecision(e,u)):(c.stop="buy"===s?"down":"up",c.stopPrice=this.priceToPrecision(e,p)),c.reduceOnly=!0,c.stopPriceType=m);const g=t.toUpperCase(),v=this.safeStringUpper(o,"timeInForce");if("LIMIT"===g){if(void 0===a)throw new i.ArgumentsRequired(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,a),void 0!==v&&(c.timeInForce=v)}let y;[y,o]=this.handlePostOnly("market"===t,!1,o),y&&(c.postOnly=!0);const w=this.safeValue(o,"hidden");if(y&&void 0!==w)throw new i.BadRequest(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(o,"iceberg")){if(void 0===this.safeValue(o,"visibleSize"))throw new i.ArgumentsRequired(this.id+" createOrder() requires a visibleSize parameter for iceberg orders")}return o=this.omit(o,["timeInForce","stopPrice","triggerPrice","stopLossPrice","takeProfitPrice"]),this.extend(c,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const r=this.safeString2(s,"clientOid","clientOrderId");s=this.omit(s,["clientOrderId"]);const a={};let o;if(void 0!==r){if(void 0===t)throw new i.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument when cancelling by clientOrderId");const e=this.market(t);a.symbol=e.id,a.clientOid=r,o=await this.futuresPrivateDeleteOrdersClientOrderClientOid(this.extend(a,s))}else a.orderId=e,o=await this.futuresPrivateDeleteOrdersOrderId(this.extend(a,s));return this.safeValue(o,"data")}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};void 0!==e&&(s.symbol=this.marketId(e));const i=this.safeValue2(t,"stop","trigger");let r;return t=this.omit(t,["stop","trigger"]),r=i?await this.futuresPrivateDeleteStopOrders(this.extend(s,t)):await this.futuresPrivateDeleteOrders(this.extend(s,t)),this.safeValue(r,"data")}async addMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),r=this.uuid(),a={symbol:i.id,margin:this.amountToPrecision(e,t),bizNo:r},o=await this.futuresPrivatePostPositionMarginDepositMargin(this.extend(a,s)),n=this.safeValue(o,"data");return this.extend(this.parseMarginModification(n,i),{amount:this.amountToPrecision(e,t),direction:"in"})}parseMarginModification(e,t=void 0){const s=this.safeString(e,"id");t=this.safeMarket(s,t);const i=this.safeString(e,"settleCurrency"),r=this.safeValue(e,"crossMode")?"cross":"isolated",a=this.safeString(t,"symbol"),o=this.safeInteger(e,"currentTimestamp");return{info:e,symbol:this.safeSymbol(a,t),type:void 0,marginMode:r,amount:void 0,total:void 0,code:this.safeCurrencyCode(i),status:void 0,timestamp:o,datetime:this.iso8601(o)}}async fetchOrdersByStatus(e,t=void 0,s=void 0,r=void 0,a={}){await this.loadMarkets();let o=!1;if([o,a]=this.handleOptionAndParams(a,"fetchOrdersByStatus","paginate"),o)return await this.fetchPaginatedCallDynamic("fetchOrdersByStatus",t,s,r,a);const n=this.safeBool2(a,"stop","trigger"),d=this.safeInteger(a,"until");a=this.omit(a,["stop","until","trigger"]),"closed"===e?e="done":"open"===e&&(e="active");const h={};if(n){if("active"!==e)throw new i.BadRequest(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders")}else h.status=e;let c,l;void 0!==t&&(c=this.market(t),h.symbol=c.id),void 0!==s&&(h.startAt=s),void 0!==d&&(h.endAt=d),l=n?await this.futuresPrivateGetStopOrders(this.extend(h,a)):await this.futuresPrivateGetOrders(this.extend(h,a));const u=this.safeValue(l,"data",{}),p=this.safeList(u,"items",[]);return this.parseOrders(p,c,s,r)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r?await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i):await this.fetchOrdersByStatus("done",e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;return[r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r?await this.fetchPaginatedCallDynamic("fetchOpenOrders",e,t,s,i):await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const r={};let a;if(void 0===e){const e=this.safeString2(s,"clientOid","clientOrderId");if(void 0===e)throw new i.InvalidOrder(this.id+" fetchOrder() requires parameter id or params.clientOid");r.clientOid=e,s=this.omit(s,["clientOid","clientOrderId"]),a=await this.futuresPrivateGetOrdersByClientOid(this.extend(r,s))}else r.orderId=e,a=await this.futuresPrivateGetOrdersOrderId(this.extend(r,s));const o=void 0!==t?this.market(t):void 0,n=this.safeDict(a,"data");return this.parseOrder(n,o)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,a=this.safeString2(e,"id","orderId"),o=this.safeString(e,"type"),n=this.safeInteger(e,"createdAt"),d=this.iso8601(n),h=this.safeString(e,"price"),c=this.safeString(e,"side"),l=this.safeString(e,"feeCurrency"),u=this.safeCurrencyCode(l),p=this.safeNumber(e,"fee"),f=this.safeString(e,"size"),m=this.safeString(e,"filledSize"),g=this.safeString(e,"filledValue");let v;if(r.Y.stringGt(m,"0")){const e=this.safeString(t,"contractSize");v=t.linear?r.Y.stringDiv(g,r.Y.stringMul(e,m)):r.Y.stringDiv(r.Y.stringMul(e,m),g)}const y=this.safeValue(e,"isActive");let w,b;void 0!==y&&(w=y?"open":"closed"),w=this.safeBool(e,"cancelExist",!1)?"canceled":w,void 0!==p&&(b={currency:u,cost:p});const S=this.safeString(e,"clientOid"),k=this.safeString(e,"timeInForce"),O=this.safeNumber(e,"stopPrice"),T=this.safeValue(e,"postOnly"),P=this.safeValue(e,"reduceOnly"),I=this.safeInteger(e,"updatedAt");return this.safeOrder({id:a,clientOrderId:S,symbol:i,type:o,timeInForce:k,postOnly:T,reduceOnly:P,side:c,amount:f,price:h,stopPrice:O,triggerPrice:O,cost:g,filled:m,remaining:void 0,timestamp:n,datetime:d,fee:b,status:w,info:e,lastTradeTimestamp:void 0,lastUpdateTimestamp:I,average:v,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.futuresPublicGetFundingRateSymbolCurrent(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timePoint");return{info:a,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(a,"value"),fundingTimestamp:o,fundingDatetime:this.iso8601(o),nextFundingRate:this.safeNumber(a,"predictedValue"),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),r=this.safeCurrencyCode(i),a=this.account();return a.free=this.safeString(s,"availableBalance"),a.total=this.safeString(s,"accountEquity"),t[r]=a,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();let t=this.safeString(this.options,"code");const s=this.safeValue(this.options,"fetchBalance",{});t=this.safeString(s,"code",t);const i=this.safeString(e,"code",t),r={currency:this.currency(i).id},a=await this.futuresPrivateGetAccountOverview(this.extend(r,e));return this.parseBalance(a)}async transfer(e,t,s,r,a={}){if("main"!==r&&"funding"!==r||"futures"!==s&&"future"!==s&&"contract"!==s)throw new i.BadRequest(this.id+" transfer() only supports transfers from contract(future) account to main(funding) account");await this.loadMarkets();const o=this.currency(e),n=this.currencyToPrecision(e,t),d={currency:this.safeString(o,"id"),amount:n},h=await this.futuresPrivatePostTransferOut(this.extend(d,a)),c=this.safeValue(h,"data");return this.extend(this.parseTransfer(c,o),{amount:this.parseNumber(n),fromAccount:"future",toAccount:"spot"})}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"updatedAt");return{id:this.safeString(e,"applyId"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:this.safeString(e,"status"),info:e}}parseTransferStatus(e){return this.safeString({PROCESSING:"pending"},e,e)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);let a,o={};void 0!==e&&(a=this.market(e),o.symbol=a.id),void 0!==t&&(o.startAt=t),[o,i]=this.handleUntilOption("endAt",o,i);const n=await this.futuresPrivateGetFills(this.extend(o,i)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"items",[]);return this.parseTrades(h,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.futuresPublicGetTradeHistory(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString2(e,"tradeId","id"),a=this.safeString(e,"orderId"),o=this.safeString(e,"liquidity");let n=this.safeInteger(e,"ts");void 0!==n?n=this.parseToInt(n/1e6):(n=this.safeInteger(e,"createdAt"),"dealValue"in e&&void 0!==n&&(n*=1e3));const d=this.safeString2(e,"price","dealPrice"),h=this.safeString2(e,"size","amount"),c=this.safeString(e,"side");let l;const u=this.safeString(e,"fee");if(void 0!==u){const s=this.safeString(e,"feeCurrency");let i=this.safeCurrencyCode(s);void 0===i&&(i="sell"===c?t.quote:t.base),l={cost:u,currency:i,rate:this.safeString(e,"feeRate")}}let p=this.safeString2(e,"type","orderType");"match"===p&&(p=void 0);let f=this.safeString2(e,"funds","value");if(void 0===f){const e=this.safeString(t,"contractSize"),s=r.Y.stringMul(d,h);f=r.Y.stringMul(s,e)}return this.safeTrade({info:e,id:i,order:a,timestamp:n,datetime:this.iso8601(n),symbol:t.symbol,type:p,takerOrMaker:o,side:c,price:d,amount:h,cost:f,fee:l},t)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.pageSize=s),void 0!==t&&(r.startAt=t);const o=(await this.futuresPrivateGetDepositList(this.extend(r,i))).data.items;return this.parseTransactions(o,a,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.pageSize=s),void 0!==t&&(r.startAt=t);const o=(await this.futuresPrivateGetWithdrawalList(this.extend(r,i))).data.items;return this.parseTransactions(o,a,t,s,{type:"withdrawal"})}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new i.BadRequest(this.id+" fetchMarketLeverageTiers() supports contract markets only");const r={symbol:s.id},a=await this.futuresPublicGetContractsRiskLimitSymbol(this.extend(r,t)),o=this.safeValue(a,"data");return this.parseMarketLeverageTiers(o,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const r=e[i];s.push({tier:this.safeNumber(r,"level"),currency:t.base,minNotional:this.safeNumber(r,"minRiskLimit"),maxNotional:this.safeNumber(r,"maxRiskLimit"),maintenanceMarginRate:this.safeNumber(r,"maintainMargin"),maxLeverage:this.safeNumber(r,"maxLeverage"),info:r})}return s}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,r={}){if(void 0===e)throw new i.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id,from:0,to:this.milliseconds()},n=this.safeInteger(r,"until");r=this.omit(r,["until"]),void 0!==t&&(o.from=t,void 0===n&&(o.to=t+288e7)),void 0!==n&&(o.to=n,void 0===t&&(o.to=n-288e7));const d=await this.futuresPublicGetContractFundingRates(this.extend(o,r)),h=this.safeValue(d,"data");return this.parseFundingRateHistories(h,a,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeInteger(e,"timepoint"),i=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(i,t),fundingRate:this.safeNumber(e,"fundingRate"),timestamp:s,datetime:this.iso8601(s)}}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let r=this.safeString(s,"clientOrderId");const a=this.safeBool(s,"test",!1);s=this.omit(s,["test","clientOrderId"]),void 0===r&&(r=this.numberToString(this.nonce()));const o={symbol:i.id,closeOrder:!0,clientOid:r,type:"market"};let n;return n=a?await this.futuresPrivatePostOrdersTest(this.extend(o,s)):await this.futuresPrivatePostOrders(this.extend(o,s)),this.parseOrder(n,i)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbols:s.id},r=await this.privateGetTradeFees(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0),n=this.safeString(o,"symbol");return{info:r,symbol:this.safeSymbol(n,s),maker:this.safeNumber(o,"makerFeeRate"),taker:this.safeNumber(o,"takerFeeRate"),percentage:!0,tierBased:!0}}}},5193:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(6944),r=s(2079),a=s(1579),o=s(4852),n=s(7481),d=s(5147);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"kuna",name:"Kuna",countries:["UA"],rateLimit:1e3,version:"v4",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createOrder:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchIsolatedPositions:!1,fetchL3OrderBook:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:"emulated",fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawAddresses:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!0},timeframes:void 0,urls:{extension:".json",referral:"https://kuna.io?r=kunaid-gvfihe8az7o4",logo:"https://user-images.githubusercontent.com/51840849/87153927-f0578b80-c2c0-11ea-84b6-74612568e9e1.jpg",api:{xreserve:"https://api.xreserve.fund",v3:"https://api.kuna.io",v4:"https://api.kuna.io",public:"https://kuna.io",private:"https://kuna.io"},www:"https://kuna.io",doc:"https://kuna.io/documents/api",fees:"https://kuna.io/documents/api"},api:{xreserve:{get:{nonce:1,fee:1,"delegated-transactions":1},post:{"delegate-transfer":1}},v4:{private:{get:{"private/me":1,"private/getBalance":1,"order/private/active":1,"order/private/history":1,"order/private/{id}/trades":1,"order/private/details/{id}":1,"trade/private/history":1,"transaction/private/{hash}":1,"deposit/private/preRequest":1,"deposit/private/crypto/address":1,"deposit/private/crypto/getMerchantAddress":1,"deposit/private/history":1,"deposit/private/details/{depositId}":1,"withdraw/private/preRequest":1,"withdraw/private/history":1,"withdraw/private/details/{withdrawId}":1,"kuna-code/{id}":1,"kuna-code/{code}/check":1,"kuna-code/issued-by-me":1,"kuna-code/redeemed-by-me":1},post:{"order/private/create":1,"order/private/cancel":1,"order/private/cancel/multi":1,"deposit/private/crypto/generateAddress":1,"deposit/private/crypto/generateMerchantAddress":1,"withdraw/private/create":1,"kuna-code":1},put:{"kuna-code/redeem":1}},public:{get:{"public/timestamp":1,"public/fees":1,"public/currencies?type={type}":1,"public/currencies":1,"markets/public/getAll":1,"markets/public/tickers?pairs={pairs}":1,"order/public/book/{pairs}":1,"trade/public/book/{pairs}":1}}},v3:{public:{get:{timestamp:1,currencies:1,markets:1,tickers:1,k:1,trades_history:1,fees:1,"exchange-rates":1,"exchange-rates/currency":1,"book/market":1,"kuna_codes/code/check":1,landing_page_statistic:1,"translations/locale":1,"trades/market/hist":1},post:{http_test:1,deposit_channels:1,withdraw_channels:1,subscription_plans:1,send_to:1,confirm_token:1,kunaid:1,"withdraw/prerequest":1,"deposit/prerequest":1,"deposit/exchange-rates":1}},sign:{get:{"reset_password/token":1},post:{"signup/google":1,"signup/resend_confirmation":1,signup:1,signin:1,"signin/two_factor":1,"signin/resend_confirm_device":1,"signin/confirm_device":1,reset_password:1,"cool-signin":1},put:{"reset_password/token":1,"signup/code/confirm":1}},private:{post:{"auth/w/order/submit":1,"auth/r/orders":1,"auth/r/orders/market":1,"auth/r/orders/markets":1,"auth/api_tokens/delete":1,"auth/api_tokens/create":1,"auth/api_tokens":1,"auth/signin_history/uniq":1,"auth/signin_history":1,"auth/disable_withdraw_confirmation":1,"auth/change_password":1,"auth/deposit_address":1,"auth/announcements/accept":1,"auth/announcements/unaccepted":1,"auth/otp/deactivate":1,"auth/otp/activate":1,"auth/otp/secret":1,"auth/r/order/market/:order_id/trades":1,"auth/r/orders/market/hist":1,"auth/r/orders/hist":1,"auth/r/orders/hist/markets":1,"auth/r/orders/details":1,"auth/assets-history":1,"auth/assets-history/withdraws":1,"auth/assets-history/deposits":1,"auth/r/wallets":1,"auth/markets/favorites":1,"auth/markets/favorites/list":1,"auth/me/update":1,"auth/me":1,"auth/fund_sources":1,"auth/fund_sources/list":1,"auth/withdraw/resend_confirmation":1,"auth/withdraw":1,"auth/withdraw/details":1,"auth/withdraw/info":1,"auth/payment_addresses":1,"auth/deposit/prerequest":1,"auth/deposit/exchange-rates":1,"auth/deposit":1,"auth/deposit/details":1,"auth/deposit/info":1,"auth/kuna_codes/count":1,"auth/kuna_codes/details":1,"auth/kuna_codes/edit":1,"auth/kuna_codes/send-pdf":1,"auth/kuna_codes":1,"auth/kuna_codes/redeemed-by-me":1,"auth/kuna_codes/issued-by-me":1,"auth/payment_requests/invoice":1,"auth/payment_requests/type":1,"auth/referral_program/weekly_earnings":1,"auth/referral_program/stats":1,"auth/merchant/payout_services":1,"auth/merchant/withdraw":1,"auth/merchant/payment_services":1,"auth/merchant/deposit":1,"auth/verification/auth_token":1,"auth/kunaid_purchase/create":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/subscriptions/reactivate":1,"auth/subscriptions/cancel":1,"auth/subscriptions/prolong":1,"auth/subscriptions/create":1,"auth/subscriptions/list":1,"auth/kuna_ids/list":1,"order/cancel/multi":1,"order/cancel":1},put:{"auth/fund_sources/id":1,"auth/kuna_codes/redeem":1},delete:{"auth/markets/favorites":1,"auth/fund_sources":1,"auth/devices":1,"auth/devices/list":1,"auth/sessions/list":1,"auth/sessions":1}}},public:{get:["depth","k_with_pending_trades","k","markets","order_book","order_book/{market}","tickers","tickers/{market}","timestamp","trades","trades/{market}"]},private:{get:["members/me","deposits","deposit","deposit_address","orders","order","trades/my","withdraws","withdraw"],post:["orders","orders/multi","orders/clear","order/delete","withdraw"]}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.0025"),maker:this.parseNumber("0.0025")},funding:{withdraw:{UAH:"1%",BTC:.001,BCH:.001,ETH:.01,WAVES:.01,GOL:0,GBG:0},deposit:{}}},commonCurrencies:{PLA:"Plair"},precisionMode:a.kb,exceptions:{ARGUMENT_VALIDATION_ERROR:r.BadRequest,PAYMENT_METHOD_NOT_SUPPORTED:r.BadRequest,NOT_FOUND:r.OrderNotFound,"INVALID:ORDER_SIZE":r.InvalidOrder,WrongRequestException:r.BadRequest,INSUFFICIENT_FUNDS:r.InsufficientFunds,2002:r.InsufficientFunds,2003:r.OrderNotFound},options:{}})}async fetchTime(e={}){const t=await this.v4PublicGetPublicTimestamp(e),s=this.safeValue(t,"data",{});return this.safeInteger(s,"timestamp_miliseconds")}async fetchCurrencies(e={}){const t=await this.v4PublicGetPublicCurrencies(e),s=this.safeValue(t,"data",[]);return this.parseCurrencies(s)}parseCurrencies(e,t={}){e=this.toArray(e);const s={};for(let t=0;t<e.length;t++){const i=this.parseCurrency(e[t]);s[i.code]=i}return s}parseCurrency(e){const t=this.safeString(e,"code"),s=this.safeString(e,"precision"),i=this.safeString(e,"tradePrecision");return{info:e,id:t,code:this.safeCurrencyCode(t),type:void 0,margin:void 0,name:this.safeString(e,"name"),active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:d.Y.stringMin(s,i),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}async fetchMarkets(e={}){const t=await this.v4PublicGetMarketsPublicGetAll(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"pair"),a=this.safeValue(t,"baseAsset"),o=this.safeValue(t,"quoteAsset"),n=this.safeString(a,"code"),d=this.safeString(o,"code"),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=this.safeString(a,"precision"),u=this.safeString(o,"precision");i.push({id:r,symbol:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(l)),price:this.parseNumber(this.parsePrecision(u))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pairs:i.id};void 0!==t&&(r.level=t);const a=await this.v4PublicGetOrderPublicBookPairs(this.extend(r,s)),o=this.safeDict(a,"data",{});return this.parseOrderBook(o,i.symbol,void 0,"bids","asks",0,1)}parseTicker(e,t=void 0){const s=this.safeString(e,"pair");return this.safeTicker({info:e,symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bestBidPrice"),ask:this.safeString(e,"bestAskPrice"),vwap:void 0,open:this.safeString(e,"open"),close:void 0,last:void 0,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"percentagePriceChange"),average:void 0,baseVolume:this.safeString(e,"baseVolume"),quoteVolume:this.safeString(e,"quoteVolume")},t)}async fetchTickers(e=void 0,t={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTickers () requires a symbols argument");e=this.marketSymbols(e);const s={pairs:this.marketIds(e).join(",")},i=await this.v4PublicGetMarketsPublicTickersPairsPairs(this.extend(s,t)),a=this.safeList(i,"data",[]);return this.parseTickers(a,e,t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pairs:s.id},r=await this.v4PublicGetMarketsPublicTickersPairsPairs(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeDict(a,0);return this.parseTicker(o,s)}async fetchL3OrderBook(e,t=void 0,s={}){return await this.fetchOrderBook(e,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pairs:r.id};void 0!==s&&(a.limit=s);const o=await this.v4PublicGetTradePublicBookPairs(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"createdAt"),i=this.safeString(e,"pair"),r=this.safeValue(e,"isMaker");let a=this.safeStringLower(e,"side");if(void 0===a){a=this.safeValue(e,"isBuyer")?"buy":"sell"}return this.safeTrade({info:e,id:this.safeString(e,"id"),symbol:this.safeSymbol(i,t),timestamp:this.parse8601(s),datetime:s,type:void 0,side:a,order:this.safeString(e,"orderId"),takerOrMaker:r?"taker":"maker",price:this.safeString2(e,"matchPrice","price"),amount:this.safeString2(e,"matchQuantity","quantity"),cost:this.safeString(e,"quoteQuantity"),fee:{cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))}},t)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"balance"),o.used=this.safeString(i,"lockBalance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v4PrivateGetPrivateGetBalance(e),s=this.safeValue(t,"data",[]);return this.parseBalance(s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=this.safeString2(o,"triggerPrice","stopPrice");o=this.omit(o,["triggerPrice","stopPrice"]);const h=this.capitalize(t),c={pair:n.id,orderSide:"buy"===s?"Bid":"Ask",quantity:this.numberToString(i),type:h};if("Limit"===h&&(c.price=this.priceToPrecision(n.symbol,a)),void 0!==d){if("Market"===h)throw new r.BadRequest(this.id+" createOrder () cannot place trigger market orders, or trigger limit");c.stopPrice=this.priceToPrecision(n.symbol,d),"TakeProfitLimit"!==h&&(c.type="StopLossLimit")}const l=await this.v4PrivatePostOrderPrivateCreate(this.extend(c,o)),u=this.safeDict(l,"data",{});return this.parseOrder(u,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.v4PrivatePostOrderPrivateCancel(this.extend(i,s)),a=this.safeValue(r,"data",{});let o;void 0!==t&&(o=this.market(t));const n=this.parseOrder(a,o);return n.id=e,n}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={orderIds:e},r=await this.v4PrivatePostOrderPrivateCancelMulti(this.extend(i,s)),a=this.safeList(r,"data",[]);return this.parseOrders(a)}parseOrderStatus(e){return this.safeString({Canceled:"canceled",Closed:"filled",Pending:"open",Open:"open",done:"closed",wait:"open",cancel:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"pair"),i=this.safeString(e,"createdAt"),r=this.safeString(e,"stopPrice");let a=this.safeString(e,"side");"Bid"===a?a="buy":"Ask"===a&&(a="sell");const o=this.safeValue(e,"trades",[]);return this.safeOrder({info:e,id:this.safeString2(e,"id","orderId"),clientOrderId:void 0,symbol:this.safeSymbol(s,t),timestamp:this.parse8601(i),datetime:i,lastTradeTimestamp:this.parse8601(this.safeString(e,"updatedAt")),status:this.parseOrderStatus(this.safeString(e,"status")),type:this.safeStringLower(e,"type"),timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"price"),stopPrice:r,triggerPrice:r,amount:this.safeString(e,"quantity"),filled:this.safeString(e,"executedQuantity"),remaining:void 0,trades:this.parseTrades(o),cost:this.safeString(e,"cost"),average:void 0,fee:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e,withTrades:!0},r=await this.v4PrivateGetOrderPrivateDetailsId(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeInteger(i,"until");let a;i=this.omit(i,["until"]);const o={};void 0!==e&&(a=this.market(e),o.pairs=a.id),void 0!==t&&(o.start=this.iso8601(t)),void 0!==s&&(o.limit=s),void 0!==r&&(o.end=this.iso8601(r));const n=await this.v4PrivateGetOrderPrivateActive(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseOrders(d,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){if(await this.loadMarkets(),"open"===e)return this.fetchOpenOrders(t,s,i,r);const a=this.safeInteger(r,"until");let o;r=this.omit(r,["until"]);const n={status:this.capitalize(e)};void 0!==t&&(o=this.market(t),n.pairs=o.id),void 0!==s&&(n.start=this.iso8601(s)),void 0!==i&&(n.limit=i),void 0!==a&&(n.end=this.iso8601(a));const d=await this.v4PrivateGetOrderPrivateHistory(n),h=this.safeList(d,"data",[]);return this.parseOrders(h,o,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.pair=r.id);const o=await this.v4PrivateGetTradePrivateHistory(this.extend(a,i)),n=this.safeList(o,"data");return this.parseTrades(n,r,t,s)}async withdraw(e,t,s,i=void 0,a={}){this.checkAddress(s);let o=this.safeString2(a,"chain","network");a=this.omit(a,["chain","network"]),await this.loadMarkets();const n=this.currency(e);if(void 0===o){if(n.code.indexOf("USD")>0)throw new r.ArgumentsRequired(this.id+' withdraw () requires an extra parameter params["network"] to withdraw '+n.code);o=n.id.toUpperCase()}const d={currency:this.networkCodeToId(o),amount:t,address:s,paymentMethod:o};void 0!==i&&(d.paymentId=i);const h=await this.v4PrivatePostWithdrawPrivateCreate(this.extend(d,a)),c=this.safeDict(h,"data",{});return this.parseTransaction(c,n)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeInteger(i,"until");let a;i=this.omit(i,"until"),void 0!==e&&(a=this.currency(e));const o={};void 0!==e&&(o.currency=e),void 0!==t&&(o.dateFrom=this.iso8601(t)),void 0!==s&&(o.take=s),void 0!==r&&(o.dateTo=this.iso8601(r));const n=await this.v4PrivateGetWithdrawPrivateHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={withdrawId:e},r=await this.v4PrivateGetWithdrawPrivateDetailsWithdrawId(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseTransaction(a)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={source:s.id},r=await this.v4PrivatePostDepositPrivateCryptoGenerateAddress(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseDepositAddress(a,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={source:s.id.toUpperCase()},r=await this.v4PrivateGetDepositPrivateCryptoAddress(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"source");return{info:this.safeString(e,""),currency:this.safeCurrencyCode(s,t),network:void 0,address:this.safeString(e,"address"),tag:void 0}}parseTransactionStatus(e){return this.safeString({Created:"pending",Canceled:"canceled",PartiallyProcessed:"pending",Processing:"pending",Processed:"ok",WaitForConfirmation:"pending",Pending:"pending",AmlChecking:"pending"},e,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeInteger(i,"until");let a;i=this.omit(i,"until"),void 0!==e&&(a=this.currency(e));const o={};void 0!==e&&(o.currency=e),void 0!==t&&(o.dateFrom=this.iso8601(t)),void 0!==s&&(o.take=s),void 0!==r&&(o.dateTo=this.iso8601(r));const n=await this.v4PrivateGetDepositPrivateHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a)}async fetchDeposit(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.currency(t));const r={depositId:e},a=await this.v4PrivateGetDepositPrivateDetailsDepositId(this.extend(r,s)),o=this.safeDict(a,"data",{});return this.parseTransaction(o,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"createdAt"),i=this.safeString(e,"asset"),r=this.safeCurrencyCode(i,t),a=this.safeString(e,"paymentCode"),o=this.safeStringLower(e,"type"),n=this.safeString(e,"address"),d="deposit"===o?o:"withdrawal";return{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"txId"),currency:r,timestamp:this.parse8601(s),datetime:s,network:this.networkIdToCode(a),addressFrom:void 0,address:n,addressTo:n,amount:this.safeNumber(e,"amount"),type:d,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.parse8601(this.safeString(e,"updatedAt")),tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"memo"),internal:void 0,fee:{cost:this.safeNumber(e,"fee"),currency:r}}}nonce(){return this.milliseconds()}encodeParams(e){if("orders"in e){const t=e.orders;let s=this.urlencode(this.keysort(this.omit(e,"orders")));for(let e=0;e<t.length;e++){const i=t[e],r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];s+="&orders%5B%5D%5B"+t+"%5D="+i[t].toString()}}return s}return this.urlencode(this.keysort(e))}sign(e,t="public",s="GET",i={},a=void 0,d=void 0){let h;if(Array.isArray(t)){const o="GET"===s,c=this.safeString(t,0),l=this.safeString(t,1);if("v3"===c){if(h=this.urls.api[c]+"/"+c+"/"+this.implodeParams(e,i),"public"===l)o?Object.keys(i).length&&(h+="?"+this.urlencode(i)):"POST"!==s&&"PUT"!==s||(a={"Content-Type":"application/json"},d=this.json(i));else if("private"===l)throw new r.NotSupported(this.id+" private v3 API is not supported yet")}else if("v4"===c){const t=this.extractParams(e);let s="/"+c+"/"+this.implodeParams(e,i);if(i=this.omit(i,t),o){Object.keys(i).length>0&&(s+="?"+this.urlencode(i))}if("private"===l){const e=this.nonce().toString();let t=s+e;o?t+=this.json({}):(t+=this.json(i),d=i),a={"Content-Type":"application/json",accept:"application/json",nonce:e,"public-key":this.apiKey,signature:this.hmac(this.encode(t),this.encode(this.secret),n.qt,"hex")};"pro"===this.safeString(this.options,"account")&&(a.account="pro")}h=this.urls.api[c]+s}}else{let r="/api/"+this.version+"/"+this.implodeParams(e,i);"extension"in this.urls&&(r+=this.urls.extension);const n=this.omit(i,this.extractParams(e));if(h=this.urls.api[t]+r,"public"===t)Object.keys(n).length&&(h+="?"+this.urlencode(n));else{this.checkRequiredCredentials();const e=this.nonce().toString(),t=s+"|"+r+"|"+this.encodeParams(this.extend({access_key:this.apiKey,tonce:e},i)),c=n+"&signature="+this.hmac(this.encode(t),this.encode(this.secret),o.s);"GET"===s?h+="?"+c:(d=c,a={"Content-Type":"application/x-www-form-urlencoded"})}}return void 0!==d&&(d=JSON.stringify(d)),{url:h,method:s,body:d,headers:a}}handleErrors(e,t,s,i,a,o,n,d,h){const c=this.safeValue(n,"errors");if(!(void 0===n&&void 0===c||void 0===c&&400!==e)){let e=this.safeValue(c,0);void 0===e&&(e=this.safeValue(n,"error"));const t=this.safeString(e,"code"),s=this.id+" "+this.json(n);throw this.throwExactlyMatchedException(this.exceptions,t,s),new r.ExchangeError(s)}}}},8146:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(121),r=s(2079),a=s(1579),o=s(7481);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"latoken",name:"Latoken",countries:["KY"],version:"v2",rateLimit:1e3,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createPostOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFees:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!0,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg",api:{rest:"https://api.latoken.com"},www:"https://latoken.com",doc:["https://api.latoken.com"],fees:"https://latoken.com/fees",referral:"https://latoken.com/invite?r=mvgp2djk"},api:{public:{get:{"book/{currency}/{quote}":1,"chart/week":1,"chart/week/{currency}/{quote}":1,currency:1,"currency/available":1,"currency/quotes":1,"currency/{currency}":1,pair:1,"pair/available":1,ticker:1,"ticker/{base}/{quote}":1,time:1,"trade/history/{currency}/{quote}":1,"trade/fee/{currency}/{quote}":1,"trade/feeLevels":1,"transaction/bindings":1}},private:{get:{"auth/account":1,"auth/account/currency/{currency}/{type}":1,"auth/order":1,"auth/order/getOrder/{id}":1,"auth/order/pair/{currency}/{quote}":1,"auth/order/pair/{currency}/{quote}/active":1,"auth/stopOrder":1,"auth/stopOrder/getOrder/{id}":1,"auth/stopOrder/pair/{currency}/{quote}":1,"auth/stopOrder/pair/{currency}/{quote}/active":1,"auth/trade":1,"auth/trade/pair/{currency}/{quote}":1,"auth/trade/fee/{currency}/{quote}":1,"auth/transaction":1,"auth/transaction/bindings":1,"auth/transaction/bindings/{currency}":1,"auth/transaction/{id}":1,"auth/transfer":1},post:{"auth/order/cancel":1,"auth/order/cancelAll":1,"auth/order/cancelAll/{currency}/{quote}":1,"auth/order/place":1,"auth/spot/deposit":1,"auth/spot/withdraw":1,"auth/stopOrder/cancel":1,"auth/stopOrder/cancelAll":1,"auth/stopOrder/cancelAll/{currency}/{quote}":1,"auth/stopOrder/place":1,"auth/transaction/depositAddress":1,"auth/transaction/withdraw":1,"auth/transaction/withdraw/cancel":1,"auth/transaction/withdraw/confirm":1,"auth/transaction/withdraw/resendCode":1,"auth/transfer/email":1,"auth/transfer/id":1,"auth/transfer/phone":1}}},precisionMode:a.kb,fees:{trading:{feeSide:"get",tierBased:!1,percentage:!0,maker:this.parseNumber("0.0049"),taker:this.parseNumber("0.0049")}},commonCurrencies:{BUX:"Buxcoin",CBT:"Community Business Token",CTC:"CyberTronchain",DMD:"Diamond Coin",FREN:"Frenchie",GDX:"GoldenX",GEC:"Geco One",GEM:"NFTmall",GMT:"GMT Token",IMC:"IMCoin",MT:"Monarch",TPAY:"Tetra Pay",TRADE:"Smart Trade Coin",TSL:"Treasure SL",UNO:"Unobtanium",WAR:"Warrior Token"},exceptions:{exact:{INTERNAL_ERROR:r.ExchangeError,SERVICE_UNAVAILABLE:r.ExchangeNotAvailable,NOT_AUTHORIZED:r.AuthenticationError,FORBIDDEN:r.PermissionDenied,BAD_REQUEST:r.BadRequest,NOT_FOUND:r.ExchangeError,ACCESS_DENIED:r.PermissionDenied,REQUEST_REJECTED:r.ExchangeError,HTTP_MEDIA_TYPE_NOT_SUPPORTED:r.BadRequest,MEDIA_TYPE_NOT_ACCEPTABLE:r.BadRequest,METHOD_ARGUMENT_NOT_VALID:r.BadRequest,VALIDATION_ERROR:r.BadRequest,ACCOUNT_EXPIRED:r.AccountSuspended,BAD_CREDENTIALS:r.AuthenticationError,COOKIE_THEFT:r.AuthenticationError,CREDENTIALS_EXPIRED:r.AccountSuspended,INSUFFICIENT_AUTHENTICATION:r.AuthenticationError,UNKNOWN_LOCATION:r.AuthenticationError,TOO_MANY_REQUESTS:r.RateLimitExceeded,INSUFFICIENT_FUNDS:r.InsufficientFunds,ORDER_VALIDATION:r.InvalidOrder,BAD_TICKS:r.InvalidOrder},broad:{"invalid API key, signature or digest":r.AuthenticationError,"The API key was revoked":r.AuthenticationError,"request expired or bad":r.InvalidNonce,"For input string":r.BadRequest,"Unable to resolve currency by tag":r.BadSymbol,"Can't find currency with tag":r.BadSymbol,"Unable to place order because pair is in inactive state":r.BadSymbol,"API keys are not available for":r.AccountSuspended}},options:{defaultType:"spot",types:{wallet:"ACCOUNT_TYPE_WALLET",funding:"ACCOUNT_TYPE_WALLET",spot:"ACCOUNT_TYPE_SPOT"},accounts:{ACCOUNT_TYPE_WALLET:"wallet",ACCOUNT_TYPE_SPOT:"spot"},fetchTradingFee:{method:"fetchPrivateTradingFee"}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.fetchCurrenciesFromCache(e),s=await this.publicGetPair(e);this.safeValue(this.options,"adjustForTimeDifference",!0)&&await this.loadTimeDifference();const i=this.indexBy(t,"id"),r=[];for(let e=0;e<s.length;e++){const t=s[e],a=this.safeString(t,"id"),o=this.safeString(t,"baseCurrency"),n=this.safeString(t,"quoteCurrency"),d=this.safeValue(i,o),h=this.safeValue(i,n);if(void 0!==d&&void 0!==h){const e=this.safeCurrencyCode(this.safeString(d,"tag")),s=this.safeCurrencyCode(this.safeString(h,"tag")),i=s.toLowerCase(),c=this.capitalize(i),l=this.safeString(t,"status");r.push({id:a,symbol:e+"/"+s,base:e,quote:s,settle:void 0,baseId:o,quoteId:n,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"PAIR_STATUS_ACTIVE"===l,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"quantityTick"),price:this.safeNumber(t,"priceTick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minOrderQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"minOrderCost"+c),max:this.safeNumber(t,"maxOrderCost"+c)}},created:this.safeInteger(t,"created"),info:t})}}return r}async fetchCurrenciesFromCache(e={}){const t=this.safeValue(this.options,"fetchCurrencies",{}),s=this.safeInteger(t,"timestamp"),i=this.safeInteger(t,"expires",1e3),r=this.milliseconds();if(void 0===s||r-s>i){const s=await this.publicGetCurrency(e);this.options.fetchCurrencies=this.extend(t,{response:s,timestamp:r})}return this.safeValue(this.options.fetchCurrencies,"response")}async fetchCurrencies(e={}){const t=await this.fetchCurrenciesFromCache(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"id"),a=this.safeString(i,"tag"),o=this.safeCurrencyCode(a),n=this.safeNumber(i,"fee");let d;d="CURRENCY_TYPE_ALTERNATIVE"===this.safeString(i,"type")?"other":"crypto";const h="CURRENCY_STATUS_ACTIVE"===this.safeString(i,"status"),c=this.safeString(i,"name");s[o]={id:r,code:o,info:i,name:c,type:d,active:h,deposit:void 0,withdraw:void 0,fee:n,precision:this.parseNumber(this.parsePrecision(this.safeString(i,"decimals"))),limits:{amount:{min:this.safeNumber(i,"minTransferAmount"),max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}return s}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAuthAccount(e),s={info:t,timestamp:void 0,datetime:void 0};let i;const r=this.safeString2(this.options,"fetchBalance","defaultType","spot"),a=this.safeString(e,"type",r),o=this.safeValue(this.options,"types",{}),n=this.safeString(o,a,a),d=this.groupBy(t,"type"),h=this.safeValue(d,n,[]);for(let e=0;e<h.length;e++){const t=h[e],r=this.safeString(t,"currency"),a=this.safeInteger(t,"timestamp");void 0!==a&&(i=void 0===i?a:Math.max(i,a));const o=this.safeCurrencyCode(r),n=this.account();n.free=this.safeString(t,"available"),n.used=this.safeString(t,"blocked"),s[o]=n}return s.timestamp=i,s.datetime=this.iso8601(i),this.safeBalance(s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={currency:i.baseId,quote:i.quoteId};void 0!==t&&(r.limit=t);const a=await this.publicGetBookCurrencyQuote(this.extend(r,s));return this.parseOrderBook(a,e,void 0,"bid","ask","price","quantity")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"lastPrice"),r=this.safeIntegerOmitZero(e,"updateTimestamp");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:r,datetime:this.iso8601(r),low:void 0,high:void 0,bid:this.safeString(e,"bestBid"),bidVolume:this.safeString(e,"bestBidQuantity"),ask:this.safeString(e,"bestAsk"),askVolume:this.safeString(e,"bestAskQuantity"),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change24h"),average:void 0,baseVolume:this.safeString(e,"amount24h"),quoteVolume:this.safeString(e,"volume24h"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={base:s.baseId,quote:s.quoteId},r=await this.publicGetTickerBaseQuote(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTicker(t);return this.parseTickers(s,e)}parseTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"price"),r=this.safeString(e,"quantity"),a=this.safeString(e,"cost"),o=this.safeValue(e,"makerBuyer");let n=this.safeString(e,"direction");void 0===n?n=o?"sell":"buy":"TRADE_DIRECTION_BUY"===n?n="buy":"TRADE_DIRECTION_SELL"===n&&(n="sell");const d=o&&"buy"===n?"maker":"taker",h=this.safeString(e,"baseCurrency"),c=this.safeString(e,"quoteCurrency"),l=this.safeCurrencyCode(h),u=this.safeCurrencyCode(c),p=l+"/"+u;p in this.markets&&(t=this.market(p));const f=this.safeString(e,"id"),m=this.safeString(e,"order"),g=this.safeString(e,"fee");let v;return void 0!==g&&(v={cost:g,currency:u}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:p,id:f,order:m,type:undefined,takerOrMaker:d,side:n,price:i,amount:r,cost:a,fee:v},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={currency:r.baseId,quote:r.quoteId};void 0!==s&&(a.limit=Math.min(s,100));const o=await this.publicGetTradeHistoryCurrencyQuote(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchTradingFee(e,t={}){const s=this.safeValue(this.options,"fetchTradingFee",{}),i=this.safeString(s,"method","fetchPrivateTradingFee"),a=this.safeString(t,"method",i);if(t=this.omit(t,"method"),"fetchPrivateTradingFee"===a)return await this.fetchPrivateTradingFee(e,t);if("fetchPublicTradingFee"===a)return await this.fetchPublicTradingFee(e,t);throw new r.NotSupported(this.id+" not support this method")}async fetchPublicTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},r=await this.publicGetTradeFeeCurrencyQuote(this.extend(i,t));return{info:r,symbol:s.symbol,maker:this.safeNumber(r,"makerFee"),taker:this.safeNumber(r,"takerFee"),percentage:void 0,tierBased:void 0}}async fetchPrivateTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.baseId,quote:s.quoteId},r=await this.privateGetAuthTradeFeeCurrencyQuote(this.extend(i,t));return{info:r,symbol:s.symbol,maker:this.safeNumber(r,"makerFee"),taker:this.safeNumber(r,"takerFee"),percentage:void 0,tierBased:void 0}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o;return void 0!==s&&(r.limit=s),void 0!==e?(a=this.market(e),r.currency=a.baseId,r.quote=a.quoteId,o=await this.privateGetAuthTradePairCurrencyQuote(this.extend(r,i))):o=await this.privateGetAuthTrade(this.extend(r,i)),this.parseTrades(o,a,t,s)}parseOrderStatus(e){return this.safeString({ORDER_STATUS_PLACED:"open",ORDER_STATUS_CLOSED:"closed",ORDER_STATUS_CANCELLED:"canceled"},e,e)}parseOrderType(e){return this.safeString({ORDER_TYPE_MARKET:"market",ORDER_TYPE_LIMIT:"limit"},e,e)}parseTimeInForce(e){return this.safeString({ORDER_CONDITION_GOOD_TILL_CANCELLED:"GTC",ORDER_CONDITION_IMMEDIATE_OR_CANCEL:"IOC",ORDER_CONDITION_FILL_OR_KILL:"FOK"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"baseCurrency"),a=this.safeString(e,"quoteCurrency"),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a);let d;void 0!==o&&void 0!==n&&(d=o+"/"+n,d in this.markets&&(t=this.market(d)));const h=this.safeString(e,"side");let c;if(void 0!==h){const e=h.split("_"),t=e.length;c=this.safeStringLower(e,t-1)}const l=this.parseOrderType(this.safeString(e,"type")),u=this.safeString(e,"price"),p=this.safeString(e,"quantity"),f=this.safeString(e,"filled"),m=this.safeString(e,"cost");let g=this.parseOrderStatus(this.safeString(e,"status"));const v=this.safeString(e,"message");void 0!==v&&(v.indexOf("cancel")>=0?g="canceled":v.indexOf("accept")>=0&&(g="open"));const y=this.safeString(e,"clientOrderId"),w=this.parseTimeInForce(this.safeString(e,"condition")),b=this.safeString(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:y,info:e,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:g,symbol:d,type:l,timeInForce:w,postOnly:void 0,side:c,price:u,stopPrice:b,triggerPrice:b,cost:m,amount:p,filled:f,average:void 0,remaining:void 0,fee:void 0,trades:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");let a;await this.loadMarkets();const o=this.safeValue2(i,"trigger","stop");i=this.omit(i,"stop");const n=this.market(e),d={currency:n.baseId,quote:n.quoteId};return a=o?await this.privateGetAuthStopOrderPairCurrencyQuoteActive(this.extend(d,i)):await this.privateGetAuthOrderPairCurrencyQuoteActive(this.extend(d,i)),this.parseOrders(a,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;const o=this.safeValue2(i,"trigger","stop");let n;return i=this.omit(i,["stop","trigger"]),void 0!==s&&(r.limit=s),void 0!==e?(a=this.market(e),r.currency=a.baseId,r.quote=a.quoteId,n=o?await this.privateGetAuthStopOrderPairCurrencyQuote(this.extend(r,i)):await this.privateGetAuthOrderPairCurrencyQuote(this.extend(r,i))):n=o?await this.privateGetAuthStopOrder(this.extend(r,i)):await this.privateGetAuthOrder(this.extend(r,i)),this.parseOrders(n,a,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=this.safeValue2(s,"trigger","stop");let a;return s=this.omit(s,["stop","trigger"]),a=r?await this.privateGetAuthStopOrderGetOrderId(this.extend(i,s)):await this.privateGetAuthOrderGetOrderId(this.extend(i,s)),this.parseOrder(a)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=t.toUpperCase(),d={baseCurrency:o.baseId,quoteCurrency:o.quoteId,side:s.toUpperCase(),condition:"GTC",type:n,clientOrderId:this.uuid(),quantity:this.amountToPrecision(e,i),timestamp:this.seconds()};"LIMIT"===n&&(d.price=this.priceToPrecision(e,r));const h=this.safeString2(a,"triggerPrice","stopPrice");let c;return a=this.omit(a,["triggerPrice","stopPrice"]),void 0!==h?(d.stopPrice=this.priceToPrecision(e,h),c=await this.privatePostAuthStopOrderPlace(this.extend(d,a))):c=await this.privatePostAuthOrderPlace(this.extend(d,a)),this.parseOrder(c,o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=this.safeValue2(s,"trigger","stop");let a;return s=this.omit(s,["stop","trigger"]),a=r?await this.privatePostAuthStopOrderCancel(this.extend(i,s)):await this.privatePostAuthOrderCancel(this.extend(i,s)),this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;const r=this.safeValue2(t,"trigger","stop");let a;return t=this.omit(t,["stop","trigger"]),void 0!==e?(i=this.market(e),s.currency=i.baseId,s.quote=i.quoteId,a=r?await this.privatePostAuthStopOrderCancelAllCurrencyQuote(this.extend(s,t)):await this.privatePostAuthOrderCancelAllCurrencyQuote(this.extend(s,t))):a=r?await this.privatePostAuthStopOrderCancelAll(this.extend(s,t)):await this.privatePostAuthOrderCancelAll(this.extend(s,t)),[this.safeOrder({info:a})]}async fetchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.privateGetAuthTransaction(this.extend({},i));let a;void 0!==e&&(a=this.currency(e));const o=this.safeList(r,"content",[]);return this.parseTransactions(o,a,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r,t),o=this.parseTransactionStatus(this.safeString(e,"status")),n=this.safeNumber(e,"amount"),d=this.safeString(e,"senderAddress"),h=this.safeString(e,"recipientAddress"),c=this.safeString(e,"transactionHash"),l=this.safeString(e,"memo"),u={currency:void 0,cost:void 0,rate:void 0},p=this.safeNumber(e,"transactionFee");void 0!==p&&(u.cost=p,u.currency=a);const f=this.parseTransactionType(this.safeString(e,"type"));return{info:e,id:s,txid:c,timestamp:i,datetime:this.iso8601(i),network:void 0,addressFrom:d,addressTo:h,address:h,tagFrom:void 0,tagTo:l,tag:l,type:f,amount:n,currency:a,status:o,updated:void 0,comment:void 0,internal:void 0,fee:u}}parseTransactionStatus(e){return this.safeString({TRANSACTION_STATUS_CONFIRMED:"ok",TRANSACTION_STATUS_EXECUTED:"ok",TRANSACTION_STATUS_CHECKING:"pending",TRANSACTION_STATUS_CANCELLED:"canceled"},e,e)}parseTransactionType(e){return this.safeString({TRANSACTION_TYPE_DEPOSIT:"deposit",TRANSACTION_TYPE_WITHDRAWAL:"withdrawal"},e,e)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.currency(e),a=await this.privateGetAuthTransfer(i),o=this.safeList(a,"content",[]);return this.parseTransfers(o,r,t,s)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a={currency:this.currency(e).id,recipient:i,value:this.currencyToPrecision(e,t)};let o;return o=i.indexOf("@")>=0?await this.privatePostAuthTransferEmail(this.extend(a,r)):36===i.length?await this.privatePostAuthTransferId(this.extend(a,r)):await this.privatePostAuthTransferPhone(this.extend(a,r)),this.parseTransfer(o)}parseTransfer(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),r=this.safeString(e,"status");return{info:e,id:this.safeString(e,"id"),timestamp:this.safeInteger(e,"timestamp"),datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"transferringFunds"),fromAccount:this.safeString(e,"fromAccount"),toAccount:this.safeString(e,"toAccount"),status:this.parseTransferStatus(r)}}parseTransferStatus(e){return this.safeString({TRANSFER_STATUS_COMPLETED:"ok",TRANSFER_STATUS_PENDING:"pending",TRANSFER_STATUS_REJECTED:"failed",TRANSFER_STATUS_UNVERIFIED:"pending",TRANSFER_STATUS_CANCELLED:"canceled"},e,e)}sign(e,t="public",s="GET",i=void 0,r=void 0,a=void 0){const n="/"+this.version+"/"+this.implodeParams(e,i);let d=n;const h=this.omit(i,this.extractParams(e)),c=this.urlencode(h);if("GET"===s&&Object.keys(h).length&&(d+="?"+c),"private"===t){this.checkRequiredCredentials();const e=s+n+c,t=this.hmac(this.encode(e),this.encode(this.secret),o.Zf);r={"X-LA-APIKEY":this.apiKey,"X-LA-SIGNATURE":t,"X-LA-DIGEST":"HMAC-SHA512"},"POST"===s&&(r["Content-Type"]="application/json",a=this.json(h))}return{url:this.urls.api.rest+d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeString(n,"message"),l=this.id+" "+o;void 0!==c&&(this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwBroadlyMatchedException(this.exceptions.broad,c,l));const u=this.safeValue(n,"error"),p=this.safeString(u,"message");if(void 0!==u||void 0!==p)throw this.throwExactlyMatchedException(this.exceptions.exact,u,l),this.throwBroadlyMatchedException(this.exceptions.broad,o,l),new r.ExchangeError(l)}}},3144:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(575),r=s(2079),a=s(1579),o=s(5147),n=s(4035),d=s(4852),h=s(5354);class c extends i.A{describe(){return this.deepExtend(super.describe(),{id:"lbank",name:"LBank",countries:["CN"],version:"v2",rateLimit:20,pro:!0,has:{CORS:!1,spot:!0,margin:!1,swap:void 0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFees:!0,fetchTransactionFees:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"1m":"minute1","5m":"minute5","15m":"minute15","30m":"minute30","1h":"hour1","2h":"hour2","4h":"hour4","6h":"hour6","8h":"hour8","12h":"hour12","1d":"day1","1w":"week1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",api:{rest:"https://api.lbank.info",contract:"https://lbkperp.lbank.com"},api2:"https://api.lbkex.com",www:"https://www.lbank.com",doc:"https://www.lbank.com/en-US/docs/index.html",fees:"https://support.lbank.site/hc/en-gb/articles/900000535703-Trading-Fees-From-14-00-on-April-7-2020-UTC-8-",referral:"https://www.lbank.com/login/?icode=7QCY"},api:{spot:{public:{get:{currencyPairs:2.5,accuracy:2.5,usdToCny:2.5,withdrawConfigs:2.5,timestamp:2.5,"ticker/24hr":2.5,ticker:2.5,depth:2.5,incrDepth:2.5,trades:2.5,kline:2.5,"supplement/system_ping":2.5,"supplement/incrDepth":2.5,"supplement/trades":2.5,"supplement/ticker/price":2.5,"supplement/ticker/bookTicker":2.5},post:{"supplement/system_status":2.5}},private:{post:{user_info:2.5,"subscribe/get_key":2.5,"subscribe/refresh_key":2.5,"subscribe/destroy_key":2.5,get_deposit_address:2.5,deposit_history:2.5,create_order:1,batch_create_order:1,cancel_order:1,cancel_clientOrders:1,orders_info:2.5,orders_info_history:2.5,order_transaction_detail:2.5,transaction_history:2.5,orders_info_no_deal:2.5,withdraw:2.5,withdrawCancel:2.5,withdraws:2.5,"supplement/user_info":2.5,"supplement/withdraw":2.5,"supplement/deposit_history":2.5,"supplement/withdraws":2.5,"supplement/get_deposit_address":2.5,"supplement/asset_detail":2.5,"supplement/customer_trade_fee":2.5,"supplement/api_Restrictions":2.5,"supplement/system_ping":2.5,"supplement/create_order_test":1,"supplement/create_order":1,"supplement/cancel_order":1,"supplement/cancel_order_by_symbol":1,"supplement/orders_info":2.5,"supplement/orders_info_no_deal":2.5,"supplement/orders_info_history":2.5,"supplement/user_info_account":2.5,"supplement/transaction_history":2.5}}},contract:{public:{get:{"cfd/openApi/v1/pub/getTime":2.5,"cfd/openApi/v1/pub/instrument":2.5,"cfd/openApi/v1/pub/marketData":2.5,"cfd/openApi/v1/pub/marketOrder":2.5}}}},fees:{trading:{maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")},funding:{withdraw:{}}},commonCurrencies:{VET_ERC20:"VEN",PNT:"Penta"},precisionMode:a.kb,options:{cacheSecretAsPem:!0,createMarketBuyOrderRequiresPrice:!0,fetchTrades:{method:"spotPublicGetTrades"},fetchTransactionFees:{method:"fetchPrivateTransactionFees"},fetchDepositWithdrawFees:{method:"fetchPrivateDepositWithdrawFees"},fetchDepositAddress:{method:"fetchDepositAddressDefault"},createOrder:{method:"spotPrivatePostSupplementCreateOrder"},fetchOrder:{method:"fetchOrderSupplement"},fetchBalance:{method:"spotPrivatePostSupplementUserInfo"},networks:{ERC20:"erc20",ETH:"erc20",TRC20:"trc20",TRX:"trc20",OMNI:"omni",ASA:"asa",BEP20:"bep20(bsc)",BSC:"bep20(bsc)",HT:"heco",BNB:"bep2",BTC:"btc",DOGE:"dogecoin",MATIC:"matic",POLYGON:"matic",OEC:"oec",BTCTRON:"btctron",XRP:"xrp"},"inverse-networks":{erc20:"ERC20",trc20:"TRC20",omni:"OMNI",asa:"ASA","bep20(bsc)":"BSC",bep20:"BSC",heco:"HT",bep2:"BNB",btc:"BTC",dogecoin:"DOGE",matic:"MATIC",oec:"OEC",btctron:"BTCTRON",xrp:"XRP"},defaultNetworks:{USDT:"TRC20"}}})}async fetchTime(e={}){let t,s;return[t,e]=this.handleMarketTypeAndParams("fetchTime",void 0,e),s="swap"===t?await this.contractPublicGetCfdOpenApiV1PubGetTime(e):await this.spotPublicGetTimestamp(e),this.safeInteger(s,"data")}async fetchMarkets(e={}){const t=[this.fetchSpotMarkets(e),this.fetchSwapMarkets(e)],s=await Promise.all(t);return this.arrayConcat(s[0],s[1])}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetAccuracy(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=r.split("_"),o=a[0],n=a[1],d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n),c=d+"/"+h;i.push({id:r,symbol:c,base:d,quote:h,baseId:o,quoteId:n,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"quantityAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"priceAccuracy")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minTranQua"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}async fetchSwapMarkets(e={}){const t=await this.contractPublicGetCfdOpenApiV1PubInstrument(this.extend({productGroup:"SwapU"},e)),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"baseCurrency"),o=this.safeString(t,"clearCurrency"),n=o,d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(o),l=d+"/"+h+":"+c;i.push({id:r,symbol:l,base:d,quote:h,settle:c,baseId:a,quoteId:n,settleId:o,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:!0,contract:!0,linear:!0,inverse:void 0,contractSize:this.safeNumber(t,"volumeMultiple"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"volumeTick"),price:this.safeNumber(t,"priceTick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"minOrderVolume"),max:this.safeNumber(t,"maxOrderVolume")},price:{min:this.safeNumber(t,"priceLimitLowerValue"),max:this.safeNumber(t,"priceLimitUpperValue")},cost:{min:this.safeNumber(t,"minOrderCost"),max:void 0}},created:void 0,info:t})}return i}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeValue(e,"ticker",{}),o=(t=this.safeMarket(i,t)).contract?e:a;return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString2(o,"high","highestPrice"),low:this.safeString2(o,"low","lowestPrice"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(o,"openPrice"),close:void 0,last:this.safeString2(o,"latest","lastPrice"),previousClose:void 0,change:void 0,percentage:this.safeString(o,"change"),average:void 0,baseVolume:this.safeString2(o,"vol","volume"),quoteVolume:this.safeString(o,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);if(s.swap){const e=await this.fetchTickers([s.symbol],t);return this.safeValue(e,s.symbol)}const i={symbol:s.id},r=await this.spotPublicGetTicker24hr(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){let s;if(await this.loadMarkets(),void 0!==e){(e=this.marketSymbols(e)).length>0&&(s=this.market(e[0]))}const i={};let r,a;[r,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),"swap"===r?(i.productGroup="SwapU",a=await this.contractPublicGetCfdOpenApiV1PubMarketData(this.extend(i,t))):(i.symbol="all",a=await this.spotPublicGetTicker24hr(this.extend(i,t)));const o=this.safeList(a,"data",[]);return this.parseTickers(o,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);void 0===t&&(t=60);const r={symbol:i.id};let a,o;[a,s]=this.handleMarketTypeAndParams("fetchOrderBook",i,s),"swap"===a?(r.depth=t,o=await this.contractPublicGetCfdOpenApiV1PubMarketOrder(this.extend(r,s))):(r.size=t,o=await this.spotPublicGetDepth(this.extend(r,s)));const n=this.safeValue(o,"data",{}),d=this.milliseconds();return i.swap?this.parseOrderBook(n,i.symbol,d,"bids","asks","price","volume"):this.parseOrderBook(n,i.symbol,d)}parseTrade(e,t=void 0){let s=this.safeInteger2(e,"date_ms","time");void 0===s&&(s=this.safeInteger(e,"dealTime"));let i=this.safeString2(e,"amount","qty");void 0===i&&(i=this.safeString(e,"dealQuantity"));let r=this.safeString(e,"price");void 0===r&&(r=this.safeString(e,"dealPrice"));let a=this.safeString(e,"quoteQty");void 0===a&&(a=this.safeString(e,"dealVolumePrice"));let o,n,d=this.safeString2(e,"tradeType","type");if(void 0!==d){const e=d.split("_");d=this.safeString(e,0);const t=this.safeString(e,1);o="limit",n="taker",void 0!==t&&("market"===t?o="market":"maker"===t&&(n="maker"))}let h=this.safeString2(e,"tid","id");void 0===h&&(h=this.safeString(e,"txUuid"));const c=this.safeString(e,"orderUuid"),l=this.safeSymbol(void 0,t);let u;const p=this.safeString(e,"tradeFee");return void 0!==p&&(u={cost:p,currency:"buy"===d?t.base:t.quote,rate:this.safeString(e,"tradeFeeRate")}),this.safeTrade({timestamp:s,datetime:this.iso8601(s),symbol:l,id:h,order:c,type:o,takerOrMaker:n,side:d,price:r,amount:i,cost:a,fee:u,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==t&&(a.time=t),a.size=void 0!==s?Math.min(s,600):600;const o=this.safeValue(this.options,"fetchTrades",{}),n=this.safeString(o,"method","spotPublicGetTrades"),d=this.safeString(i,"method",n);let h;i=this.omit(i,"method"),h="spotPublicGetSupplementTrades"===d?await this.spotPublicGetSupplementTrades(this.extend(a,i)):await this.spotPublicGetTrades(this.extend(a,i));const c=this.safeList(h,"data",[]);return this.parseTrades(c,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);if(i=void 0===i?100:Math.min(i,2e3),void 0===s){const e=this.parseTimeframe(t);s=this.milliseconds()-1e3*e*i}const o={symbol:a.id,type:this.safeString(this.timeframes,t,t),time:this.parseToInt(s/1e3),size:i},n=await this.spotPublicGetKline(this.extend(o,r)),d=this.safeValue(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}parseBalance(e){const t=this.safeInteger(e,"ts"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeValue(e,"data");if(void 0!==this.safeValue(i,"toBtc")){const e=this.safeValue(i,"freeze",{}),t=this.safeValue(i,"free",{}),r=Object.keys(t);for(let i=0;i<r.length;i++){const a=r[i],o=this.safeCurrencyCode(a),n=this.account();n.used=this.safeString(e,a),n.free=this.safeString(t,a),s[o]=n}return this.safeBalance(s)}const r=this.safeValue(i,"balances");if(void 0!==r){for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"asset"),a=this.safeCurrencyCode(i),o=this.account();o.free=this.safeString(t,"free"),o.used=this.safeString(t,"locked"),s[a]=o}return this.safeBalance(s)}if(!0===Array.isArray(i)){for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"usableAmt"),o.used=this.safeString(t,"freezeAmt"),s[a]=o}return this.safeBalance(s)}}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeValue(this.options,"fetchBalance",{}),s=this.safeString(t,"method","spotPrivatePostSupplementUserInfo"),i=this.safeString(e,"method",s);let r;return r="spotPrivatePostSupplementUserInfoAccount"===i?await this.spotPrivatePostSupplementUserInfoAccount():"spotPrivatePostUserInfo"===i?await this.spotPrivatePostUserInfo():await this.spotPrivatePostSupplementUserInfo(),this.parseBalance(r)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,symbol:this.safeSymbol(s),maker:this.safeNumber(e,"makerCommission"),taker:this.safeNumber(e,"takerCommission"),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){const s=this.market(e),i=await this.fetchTradingFees(this.extend(t,{category:s.id}));return this.safeDict(i,e)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.spotPrivatePostSupplementCustomerTradeFee(this.extend({},e)),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=this.parseTradingFee(s[e]);i[t.symbol]=t}return i}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,a=void 0,n={}){await this.loadMarkets();const d=this.market(e),h=this.safeString2(n,"custom_id","clientOrderId"),c=this.safeBool(n,"postOnly",!1),l=this.safeStringUpper(n,"timeInForce");n=this.omit(n,["custom_id","clientOrderId","timeInForce","postOnly"]);const u={symbol:d.id},p="IOC"===l,f="FOK"===l,m=c||"PO"===l;if("market"===t&&(p||f||m))throw new r.InvalidOrder(this.id+" createOrder () does not allow market FOK, IOC, or postOnly orders. Only limit IOC, FOK, and postOnly orders are allowed");if("limit"===t)u.type=s,u.price=this.priceToPrecision(e,a),u.amount=this.amountToPrecision(e,i),p?u.type=s+"_ioc":f?u.type=s+"_fok":m&&(u.type=s+"_maker");else if("market"===t)if("sell"===s)u.type=s+"_market",u.amount=this.amountToPrecision(e,i);else if("buy"===s){let t;u.type=s+"_market";let d=!0;[d,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const h=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==h)t=this.costToPrecision(e,h);else if(d){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const s=this.numberToString(i),r=this.numberToString(a),n=o.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);u.price=t}void 0!==h&&(u.custom_id=h);const g=this.safeValue(this.options,"createOrder",{}),v=this.safeString(g,"method","spotPrivatePostSupplementCreateOrder"),y=this.safeString(n,"method",v);let w;n=this.omit(n,"method"),w="spotPrivatePostCreateOrder"===y?await this.spotPrivatePostCreateOrder(this.extend(u,n)):await this.spotPrivatePostSupplementCreateOrder(this.extend(u,n));const b=this.safeValue(w,"data",{});return this.safeOrder({id:this.safeString(b,"order_id"),info:b},d)}parseOrderStatus(e){return this.safeString({"-1":"canceled",0:"open",1:"open",2:"closed",3:"canceled",4:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"orderId","order_id"),i=this.safeString2(e,"clientOrderId","custom_id"),r=this.safeInteger2(e,"time","create_time"),a=this.safeString(e,"status"),o=this.safeString(e,"symbol");let n;t=this.safeMarket(o,t);let d=!1,h="limit";const c=this.safeString2(e,"type","tradeType"),l=c.split("_"),u=this.safeString(l,0),p=this.safeString(l,1);"market"===p&&(h="market"),"maker"===p&&(d=!0,n="PO"),"ioc"===p&&(n="IOC"),"fok"===p&&(n="FOK");const f=this.safeString(e,"price"),m=this.safeString(e,"cummulativeQuoteQty");let g;"buy_market"!==c&&(g=this.safeString2(e,"origQty","amount"));const v=this.safeString2(e,"executedQty","deal_amount");return this.safeOrder({id:s,clientOrderId:i,datetime:this.iso8601(r),timestamp:r,lastTradeTimestamp:void 0,status:this.parseOrderStatus(a),symbol:t.symbol,type:h,timeInForce:n,postOnly:d,side:u,price:f,stopPrice:void 0,triggerPrice:void 0,cost:m,amount:g,filled:v,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();let i=this.safeString(s,"method");if(void 0===i){const e=this.safeValue(this.options,"fetchOrder",{});i=this.safeString(e,"method","fetchOrderSupplement")}return"fetchOrderSupplement"===i?await this.fetchOrderSupplement(e,t,s):await this.fetchOrderDefault(e,t,s)}async fetchOrderSupplement(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(t).id,orderId:e},a=await this.spotPrivatePostSupplementOrdersInfo(this.extend(i,s)),o=this.safeDict(a,"data",{});return this.parseOrder(o)}async fetchOrderDefault(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(t).id,order_id:e},a=await this.spotPrivatePostOrdersInfo(this.extend(i,s)),o=this.safeValue(a,"data",[]);if(1===o.length)return this.parseOrder(o[0]);throw new r.BadRequest(this.id+" fetchOrder() can only fetch one order at a time")}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e);t=this.safeValue(i,"start_date",t),i=this.omit(i,"start_date");const o={symbol:a.id};void 0!==s&&(o.size=s),void 0!==t&&(o.start_date=this.ymd(t,"-"),o.end_date=this.ymd(t+864e5,"-"));const n=await this.spotPrivatePostTransactionHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);void 0===s&&(s=100);const o={symbol:a.id,current_page:1,page_length:s},n=await this.spotPrivatePostSupplementOrdersInfoHistory(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"orders",[]);return this.parseOrders(h,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);void 0===s&&(s=100);const o={symbol:a.id,current_page:1,page_length:s},n=await this.spotPrivatePostSupplementOrdersInfoNoDeal(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"orders",[]);return this.parseOrders(h,a,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.safeString2(s,"origClientOrderId","clientOrderId");s=this.omit(s,["origClientOrderId","clientOrderId"]);const a={symbol:this.market(t).id,orderId:e};void 0!==i&&(a.origClientOrderId=i);const o=await this.spotPrivatePostSupplementCancelOrder(this.extend(a,s)),n=this.safeDict(o,"data",{});return this.parseOrder(n)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={symbol:this.market(e).id},i=await this.spotPrivatePostSupplementCancelOrderBySymbol(this.extend(s,t)),a=this.safeList(i,"data",[]);return this.parseOrders(a)}getNetworkCodeForCurrency(e,t){const s=this.safeValue(this.options,"defaultNetworks"),i=this.safeStringUpper(s,e),r=this.safeValue(this.options,"networks",{});let a=this.safeStringUpper(t,"network",i);return a=this.safeString(r,a,a),a}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeValue(this.options,"fetchDepositAddress",{}),i=this.safeString(s,"method","fetchDepositAddressDefault"),r=this.safeString(t,"method",i);let a;return t=this.omit(t,"method"),a="fetchDepositAddressSupplement"===r?await this.fetchDepositAddressSupplement(e,t):await this.fetchDepositAddressDefault(e,t),a}async fetchDepositAddressDefault(e,t={}){await this.loadMarkets();const s={assetCode:this.currency(e).id},i=this.getNetworkCodeForCurrency(e,t);void 0!==i&&(s.netWork=i,t=this.omit(t,"network"));const r=await this.spotPrivatePostGetDepositAddress(this.extend(s,t)),a=this.safeValue(r,"data"),o=this.safeString(a,"address"),n=this.safeString(a,"memo"),d=this.safeString(a,"netWork"),h=this.safeValue(this.options,"inverse-networks",{});return{currency:e,address:o,tag:n,network:this.safeStringUpper(h,d,d),info:r}}async fetchDepositAddressSupplement(e,t={}){await this.loadMarkets();const s={coin:this.currency(e).id},i=this.safeValue(this.options,"networks");let r=this.safeStringUpper(t,"network");r=this.safeString(i,r,r),void 0!==r&&(s.networkName=r,t=this.omit(t,"network"));const a=await this.spotPrivatePostSupplementGetDepositAddress(this.extend(s,t)),o=this.safeValue(a,"data"),n=this.safeString(o,"address"),d=this.safeString(o,"memo"),h=this.safeValue(this.options,"inverse-networks",{});return{currency:e,address:n,tag:d,network:this.safeStringUpper(h,r,r),info:a}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.safeString(r,"fee");r=this.omit(r,"fee"),this.checkRequiredArgument("withdraw",a,"fee");const o={address:s,coin:this.currency(e).id,amount:t,fee:a};void 0!==i&&(o.memo=i);const n=this.safeStringUpper2(r,"network","networkName");r=this.omit(r,["network","networkName"]);const d=this.safeValue(this.options,"networks"),h=this.safeString(d,n,n);void 0!==h&&(o.networkName=h);const c=await this.spotPrivatePostSupplementWithdraw(this.extend(o,r)),l=this.safeValue(c,"data",{});return{info:l,id:this.safeString(l,"withdrawId")}}parseTransactionStatus(e,t){return this.safeString(this.safeValue({deposit:{1:"pending",2:"ok",3:"failed",4:"canceled",5:"transfer"},withdrawal:{1:"pending",2:"canceled",3:"failed",4:"ok"}},t,{}),e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id");let i;i=void 0===s?"deposit":"withdrawal";const r=this.safeString(e,"txId"),a=this.safeInteger2(e,"insertTime","applyTime"),o=this.safeValue(this.options,"inverse-networks",{}),n=this.safeString(e,"networkName"),d=this.safeString(o,n,n),h=this.safeString(e,"address");let c,l;"deposit"===i?c=h:l=h;const u=this.safeNumber(e,"amount"),p=this.safeString2(e,"coin","coid"),f=this.safeCurrencyCode(p,t),m=this.parseTransactionStatus(this.safeString(e,"status"),i);let g;const v=this.safeNumber(e,"fee");return void 0!==v&&(g={cost:v,currency:f}),{info:e,id:s,txid:r,timestamp:a,datetime:this.iso8601(a),network:d,address:h,addressTo:l,addressFrom:c,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:u,currency:f,status:m,updated:void 0,comment:void 0,internal:"transfer"===m,fee:g}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t);const o=await this.spotPrivatePostSupplementDepositHistory(this.extend(r,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"depositOrders",[]);return this.parseTransactions(d,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t);const o=await this.spotPrivatePostSupplementWithdraws(this.extend(r,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"withdraws",[]);return this.parseTransactions(d,a,t,s)}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();let s;if(!0===this.checkRequiredCredentials(!1)){const e=this.safeValue(this.options,"fetchTransactionFees",{}),i=this.safeString(e,"method","fetchPrivateTransactionFees"),r=this.safeString(t,"method",i);t=this.omit(t,"method"),s="fetchPublicTransactionFees"===r?await this.fetchPublicTransactionFees(t):await this.fetchPrivateTransactionFees(t)}else s=await this.fetchPublicTransactionFees(t);return s}async fetchPrivateTransactionFees(e={}){await this.loadMarkets();const t=await this.spotPrivatePostSupplementUserInfo(),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"coin"),a=this.safeCurrencyCode(r),o=this.safeValue(t,"networkList",[]);i[a]={};for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"name"),r=this.safeString(this.options["inverse-networks"],s,s),n=this.safeNumber(t,"withdrawFee");void 0!==n&&(i[a][r]=n)}}return{withdraw:i,deposit:{},info:t}}async fetchPublicTransactionFees(e={}){await this.loadMarkets();const t=this.safeString2(e,"coin","assetCode");e=this.omit(e,["coin","assetCode"]);const s={};if(void 0!==t){const e=this.currency(t);s.assetCode=e.id}const i=await this.spotPublicGetWithdrawConfigs(this.extend(s,e)),r=this.safeValue(i,"data",[]),a={};for(let e=0;e<r.length;e++){const t=r[e];if("true"===this.safeValue(t,"canWithDraw")){const e=this.safeString(t,"assetCode"),s=this.safeCurrencyCode(e),i=this.safeString(t,"chain");let r=this.safeString(this.options["inverse-networks"],i,i);void 0===r&&(r=s);const o=this.safeString(t,"fee");void 0===a[s]&&(a[s]={}),a[s][r]=this.parseNumber(o)}}return{withdraw:a,deposit:{},info:i}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();if(!0===this.checkRequiredCredentials(!1)){const s=this.safeValue(this.options,"fetchDepositWithdrawFees",{}),i=this.safeString(s,"method","fetchPrivateDepositWithdrawFees"),r=this.safeString(t,"method",i);t=this.omit(t,"method"),"fetchPublicDepositWithdrawFees"===r?await this.fetchPublicDepositWithdrawFees(e,t):await this.fetchPrivateDepositWithdrawFees(e,t)}else await this.fetchPublicDepositWithdrawFees(e,t)}async fetchPrivateDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivatePostSupplementUserInfo(t),i=this.safeList(s,"data",[]);return this.parseDepositWithdrawFees(i,e,"coin")}async fetchPublicDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPublicGetWithdrawConfigs(this.extend({},t)),i=this.safeValue(s,"data",[]);return this.parsePublicDepositWithdrawFees(i,e)}parsePublicDepositWithdrawFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const r=e[i];if(!0===this.safeValue(r,"canWithDraw")){const e=this.safeString(r,"assetCode"),i=this.safeCurrencyCode(e);if(void 0===t||this.inArray(i,t)){const e=this.safeNumber(r,"fee");if(void 0!==e){void 0===this.safeValue(s,i)?s[i]=this.depositWithdrawFee([r]):s[i].info.push(r);const t=this.safeString(r,"chain"),a=this.safeString(this.options["inverse-networks"],t,t);void 0!==a?s[i].networks[a]={withdraw:{fee:e,percentage:void 0},deposit:{fee:void 0,percentage:void 0}}:s[i].withdraw={fee:e,percentage:void 0}}}}}return s}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee(e),i=this.safeValue(e,"networkList",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"name"),a=this.safeStringUpper(this.options["inverse-networks"],r,r),o=this.safeNumber(t,"withdrawFee"),n=this.safeValue(t,"isDefault");void 0!==o&&(n&&(s.withdraw={fee:o,percentage:void 0}),s.networks[a]={withdraw:{fee:o,percentage:void 0},deposit:{fee:void 0,percentage:void 0}})}return s}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.omit(i,this.extractParams(e)),c=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);if("spot"===t[0]?c+=".do":c=this.urls.api.contract+"/"+this.implodeParams(e,i),"public"===t[1])Object.keys(o).length&&(c+="?"+this.urlencode(this.keysort(o)));else{this.checkRequiredCredentials();const e=this.milliseconds().toString(),t=this.uuid22()+this.uuid16();let s;o=this.extend({api_key:this.apiKey},o),s=this.secret.length>32?"RSA":"HmacSHA256";const i=this.rawencode(this.keysort(this.extend({echostr:t,signature_method:s,timestamp:e},o))),c=this.encode(i),l=this.hash(c,n.F).toUpperCase();let u;if("RSA"===s){let e;this.safeBool(this.options,"cacheSecretAsPem",!0)?(e=this.safeValue(this.options,"pem"),void 0===e&&(e=this.convertSecretToPem(this.encode(this.secret)),this.options.pem=e)):e=this.convertSecretToPem(this.encode(this.secret)),u=(0,h.n)(l,e,d.s)}else"HmacSHA256"===s&&(u=this.hmac(this.encode(l),this.encode(this.secret),d.s));o.sign=u,a=this.urlencode(this.keysort(o)),r={"Content-Type":"application/x-www-form-urlencoded",timestamp:e,signature_method:s,echostr:t}}return{url:c,method:s,body:a,headers:r}}convertSecretToPem(e){const t=e.length-0;let s=this.parseToInt(t/64);s=this.sum(s,1);let i="-----BEGIN PRIVATE KEY-----\n";for(let e=0;e<s;e++){const t=64*e,s=this.sum(t,64);i+=this.secret.slice(t,s)+"\n"}return i+"-----END PRIVATE KEY-----"}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeValue(n,"result");if("false"===c||!c){const e=this.safeString(n,"error_code"),t=this.safeString({1e4:"Internal error",10001:"The required parameters can not be empty",10002:"Validation failed",10003:"Invalid parameter",10004:"Request too frequent",10005:"Secret key does not exist",10006:"User does not exist",10007:"Invalid signature",10008:"Invalid Trading Pair",10009:"Price and/or Amount are required for limit order",10010:"Price and/or Amount must be less than minimum requirement",10013:"The amount is too small",10014:"Insufficient amount of money in the account",10015:"Invalid order type",10016:"Insufficient account balance",10017:"Server Error",10018:"Page size should be between 1 and 50",10019:"Cancel NO more than 3 orders in one request",10020:"Volume < 0.001",10021:"Price < 0.01",10022:"Invalid authorization",10023:"Market Order is not supported yet",10024:"User cannot trade on this pair",10025:"Order has been filled",10026:"Order has been cancelld",10027:"Order is cancelling",10028:"Wrong query time",10029:"from is not in the query time",10030:"from do not match the transaction type of inqury",10031:"echostr length must be valid and length must be from 30 to 40",10033:"Failed to create order",10036:"customID duplicated",10100:"Has no privilege to withdraw",10101:"Invalid fee rate to withdraw",10102:"Too little to withdraw",10103:"Exceed daily limitation of withdraw",10104:"Cancel was rejected",10105:"Request has been cancelled",10106:"None trade time",10107:"Start price exception",10108:"can not create order",10109:"wallet address is not mapping",10110:"transfer fee is not mapping",10111:"mount > 0",10112:"fee is too lower",10113:"transfer fee is 0",10600:"intercepted by replay attacks filter, check timestamp",10601:"Interface closed unavailable",10701:"invalid asset code",10702:"not allowed deposit"},e,this.json(n));throw new(this.safeValue({10001:r.BadRequest,10002:r.AuthenticationError,10003:r.BadRequest,10004:r.RateLimitExceeded,10005:r.AuthenticationError,10006:r.AuthenticationError,10007:r.AuthenticationError,10008:r.BadSymbol,10009:r.InvalidOrder,10010:r.InvalidOrder,10013:r.InvalidOrder,10014:r.InsufficientFunds,10015:r.InvalidOrder,10016:r.InsufficientFunds,10017:r.ExchangeError,10018:r.BadRequest,10019:r.BadRequest,10020:r.BadRequest,10021:r.InvalidOrder,10022:r.PermissionDenied,10023:r.InvalidOrder,10024:r.PermissionDenied,10025:r.InvalidOrder,10026:r.InvalidOrder,10027:r.InvalidOrder,10028:r.BadRequest,10029:r.BadRequest,10030:r.BadRequest,10031:r.InvalidNonce,10033:r.ExchangeError,10036:r.DuplicateOrderId,10100:r.PermissionDenied,10101:r.BadRequest,10102:r.InsufficientFunds,10103:r.ExchangeError,10104:r.ExchangeError,10105:r.ExchangeError,10106:r.BadRequest,10107:r.BadRequest,10108:r.ExchangeError,10109:r.InvalidAddress,10110:r.ExchangeError,10111:r.BadRequest,10112:r.BadRequest,10113:r.BadRequest,10600:r.BadRequest,10601:r.ExchangeError,10701:r.BadSymbol,10702:r.PermissionDenied},e,r.ExchangeError))(t)}}}},9248:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7533),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"luno",name:"luno",countries:["GB","SG","ZA"],rateLimit:200,version:"1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},urls:{referral:"https://www.luno.com/invite/44893A",logo:"https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg",api:{public:"https://api.luno.com/api",private:"https://api.luno.com/api",exchange:"https://api.luno.com/api/exchange",exchangePrivate:"https://api.luno.com/api/exchange"},www:"https://www.luno.com",doc:["https://www.luno.com/en/api","https://npmjs.org/package/bitx","https://github.com/bausmeier/node-bitx"]},api:{exchange:{get:{markets:1}},exchangePrivate:{get:{candles:1}},public:{get:{orderbook:1,orderbook_top:1,ticker:1,tickers:1,trades:1}},private:{get:{"accounts/{id}/pending":1,"accounts/{id}/transactions":1,balance:1,beneficiaries:1,fee_info:1,funding_address:1,listorders:1,listtrades:1,send_fee:1,"orders/{id}":1,withdrawals:1,"withdrawals/{id}":1,transfers:1},post:{accounts:1,"address/validate":1,postorder:1,marketorder:1,stoporder:1,funding_address:1,withdrawals:1,send:1,"oauth2/grant":1,beneficiaries:1},put:{"accounts/{id}/name":1},delete:{"withdrawals/{id}":1,"beneficiaries/{id}":1}}},timeframes:{"1m":60,"5m":300,"15m":900,"30m":1800,"1h":3600,"3h":10800,"4h":14400,"1d":86400,"3d":259200,"1w":604800},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},precisionMode:o.kb})}async fetchMarkets(e={}){const t=await this.exchangeGetMarkets(e),s=[],i=this.safeValue(t,"markets",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"market_id"),a=this.safeString(t,"base_currency"),o=this.safeString(t,"counter_currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeString(t,"trading_status");s.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"ACTIVE"===h,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"volume_scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"price_scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"min_volume"),max:this.safeNumber(t,"max_volume")},price:{min:this.safeNumber(t,"min_price"),max:this.safeNumber(t,"max_price")},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return s}async fetchAccounts(e={}){const t=await this.privateGetBalance(e),s=this.safeValue(t,"balance",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"account_id"),a=this.safeString(t,"asset"),o=this.safeCurrencyCode(a);i.push({id:r,type:void 0,currency:o,info:t})}return i}parseBalance(e){const t=this.safeValue(e,"balance",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"asset"),o=this.safeCurrencyCode(r),n=this.safeString(i,"reserved"),d=this.safeString(i,"unconfirmed"),h=this.safeString(i,"balance"),c=a.Y.stringAdd(n,d),l=a.Y.stringAdd(h,d);if(o in s)s[o].used=a.Y.stringAdd(s[o].used,c),s[o].total=a.Y.stringAdd(s[o].total,l);else{const e=this.account();e.used=c,e.total=l,s[o]=e}}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id};let a;a=void 0!==t&&t<=100?await this.publicGetOrderbookTop(this.extend(r,s)):await this.publicGetOrderbook(this.extend(r,s));const o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","volume")}parseOrderStatus(e){return this.safeString({PENDING:"open"},e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"creation_timestamp");let i,r=this.parseOrderStatus(this.safeString(e,"state"));const a=this.safeString(e,"type");"ASK"===a||"SELL"===a?i="sell":"BID"!==a&&"BUY"!==a||(i="buy");const o=this.safeString(e,"pair");t=this.safeMarket(o,t);const n=this.safeString(e,"limit_price"),d=this.safeString(e,"limit_volume"),h=this.safeNumber(e,"fee_counter"),c=this.safeNumber(e,"fee_base"),l=this.safeString(e,"base"),u=this.safeString(e,"counter");let p;void 0!==h?p={cost:h,currency:t.quote}:void 0!==c&&(p={cost:c,currency:t.base});const f=this.safeString(e,"order_id");return this.safeOrder({id:f,clientOrderId:void 0,datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,status:r,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:i,price:n,stopPrice:void 0,triggerPrice:void 0,amount:d,filled:l,cost:u,remaining:void 0,trades:void 0,fee:p,info:e,average:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrdersId(this.extend(i,s));return this.parseOrder(r)}async fetchOrdersByState(e=void 0,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==e&&(a.state=e),void 0!==t&&(o=this.market(t),a.pair=o.id);const n=await this.privateGetListorders(this.extend(a,r)),d=this.safeList(n,"orders",[]);return this.parseOrders(d,o,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(void 0,e,t,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("PENDING",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState("COMPLETE",e,t,s,i)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"pair"),r=this.safeSymbol(i,t),a=this.safeString(e,"last_trade");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"rolling_24_hour_volume"),quoteVolume:void 0,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetTickers(t),i=this.indexBy(s.tickers,"pair"),r=Object.keys(i),a={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeMarket(t),o=s.symbol,n=i[t];a[o]=this.parseTicker(n,s)}return this.filterByArrayTickers(a,"symbol",e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"sequence");let r,o;if(void 0!==s){const t=this.safeString(e,"type");"ASK"===t||"SELL"===t?o="sell":"BID"!==t&&"BUY"!==t||(o="buy"),r="sell"===o&&e.is_buy?"maker":"buy"!==o||e.is_buy?"taker":"maker"}else o=e.is_buy?"buy":"sell";const n=this.safeString(e,"fee_base"),d=this.safeString(e,"fee_counter");let h,c;void 0!==n?a.Y.stringEquals(n,"0.0")||(h=t.base,c=n):void 0!==d&&(a.Y.stringEquals(d,"0.0")||(h=t.quote,c=d));const l=this.safeInteger(e,"timestamp");return this.safeTrade({info:e,id:i,timestamp:l,datetime:this.iso8601(l),symbol:t.symbol,order:s,type:void 0,side:o,takerOrMaker:r,price:this.safeString(e,"price"),amount:this.safeString2(e,"volume","base"),cost:this.safeString(e,"counter"),fee:{cost:c,currency:h}},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==t&&(a.since=t);const o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,"trades",[]);return this.parseTrades(n,r,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={duration:this.safeValue(this.timeframes,t,t),pair:a.id};if(void 0!==s)o.since=this.parseToInt(s);else{const e=1e6*this.parseTimeframe(t);o.since=this.milliseconds()-e}const n=await this.exchangePrivateGetCandles(this.extend(o,r)),d=this.safeList(n,"candles",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id};void 0!==t&&(o.since=t),void 0!==s&&(o.limit=s);const n=await this.privateGetListtrades(this.extend(o,i)),d=this.safeList(n,"trades",[]);return this.parseTrades(d,a,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s={pair:this.market(e).id},i=await this.privateGetFeeInfo(this.extend(s,t));return{info:i,symbol:e,maker:this.safeNumber(i,"maker_fee"),taker:this.safeNumber(i,"taker_fee"),percentage:void 0,tierBased:void 0}}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={pair:o.id};let d;return"market"===t?(n.type=s.toUpperCase(),"buy"===s?n.counter_volume=this.amountToPrecision(o.symbol,i):n.base_volume=this.amountToPrecision(o.symbol,i),d=await this.privatePostMarketorder(this.extend(n,a))):(n.volume=this.amountToPrecision(o.symbol,i),n.price=this.priceToPrecision(o.symbol,r),n.type="buy"===s?"BID":"ASK",d=await this.privatePostPostorder(this.extend(n,a))),this.safeOrder({info:d,id:d.order_id},o)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privatePostStoporder(this.extend(i,s));return this.safeOrder({info:r})}async fetchLedgerByEntries(e=void 0,t=void 0,s=void 0,i={}){void 0===t&&(t=-1),void 0===s&&(s=1);const r={min_row:t,max_row:this.sum(t,s)};return await this.fetchLedger(e,undefined,s,this.extend(r,i))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),await this.loadAccounts();let o=this.safeString(i,"id"),n=this.safeValue(i,"min_row"),d=this.safeValue(i,"max_row");if(void 0===o){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchLedger() requires a currency code argument if no account id specified in params");a=this.currency(e);const t=this.indexBy(this.accounts,"currency"),s=this.safeValue(t,e);if(void 0===s)throw new r.ExchangeError(this.id+" fetchLedger() could not find account id for "+e);o=s.id}if(void 0===n&&void 0===d)d=0,n=-1e3;else if(void 0===n||void 0===d)throw new r.ExchangeError(this.id+" fetchLedger() require both params 'max_row' and 'min_row' or neither to be defined");if(void 0!==s&&d-n>s&&(d<=0?n=d-s:n>0&&(d=n+s)),d-n>1e3)throw new r.ExchangeError(this.id+" fetchLedger() requires the params 'max_row' - 'min_row' <= 1000");const h={id:o,min_row:n,max_row:d},c=await this.privateGetAccountsIdTransactions(this.extend(i,h)),l=this.safeValue(c,"transactions",[]);return this.parseLedger(l,a,t,s)}parseLedgerComment(e){const t=e.split(" ");let s;const i=this.safeString(t,0),r=this.safeString(t,2),a=this.safeString(t,3);let o=this.safeString({Withdrawal:"fee",Trading:"fee",Payment:"transaction",Sent:"transaction",Deposit:"transaction",Received:"transaction",Released:"released",Reserved:"reserved",Sold:"trade",Bought:"trade",Failure:"failed"},i,void 0);return void 0===o&&"fee"===r&&(o="fee"),"reserved"===o&&"order"===a&&(s=this.safeString(t,4)),{type:o,referenceId:s}}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"row_index"),i=this.safeString(e,"account_id"),r=this.safeInteger(e,"timestamp"),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.safeString(e,"available_delta"),h=this.safeString(e,"balance_delta"),c=this.safeString(e,"balance"),l=this.safeString(e,"description");let u=c,p="0.0";const f=this.parseLedgerComment(l),m=f.type,g=f.referenceId;let v,y;return a.Y.stringEquals(h,"0.0")?a.Y.stringLt(d,"0.0")?(y="pending",p=a.Y.stringAbs(d)):a.Y.stringGt(d,"0.0")&&(y="canceled",p=a.Y.stringAbs(d)):(u=a.Y.stringSub(c,h),y="ok",p=a.Y.stringAbs(h)),a.Y.stringGt(h,"0")||a.Y.stringGt(d,"0")?v="in":(a.Y.stringLt(h,"0")||a.Y.stringLt(d,"0"))&&(v="out"),{id:s,direction:v,account:i,referenceId:g,referenceAccount:void 0,type:m,currency:n,amount:this.parseNumber(p),timestamp:r,datetime:this.iso8601(r),before:this.parseNumber(u),after:this.parseNumber(c),status:y,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const n=this.omit(i,this.extractParams(e));if(Object.keys(n).length&&(o+="?"+this.urlencode(n)),"private"===t||"exchangePrivate"===t){this.checkRequiredCredentials();r={Authorization:"Basic "+this.stringToBase64(this.apiKey+":"+this.secret)}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(void 0!==this.safeValue(n,"error"))throw new r.ExchangeError(this.id+" "+this.json(n))}}},1850:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(3893),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"lykke",name:"Lykke",countries:["UK"],version:"2",rateLimit:200,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createOrder:!0,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!1,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:void 0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:"emulated",fetchWithdrawals:!1,setLeverage:!1,setMarginMode:!1,withdraw:!0},requiredCredentials:{apiKey:!0,secret:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg",api:{public:"https://hft-apiv2.lykke.com/api",private:"https://hft-apiv2.lykke.com/api"},www:"https://www.lykke.com",doc:["https://hft-apiv2.lykke.com/swagger/ui/index.html","https://lykkecity.github.io/Trading-API"],fees:"https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-"},api:{public:{get:{assetpairs:2.5,"assetpairs/{id}":2.5,assets:2.5,"assets/{id}":2.5,isalive:2.5,orderbooks:2.5,tickers:2.5,prices:2.5,"trades/public/{assetPairId}":2.5}},private:{get:{balance:2.5,trades:2.5,"trades/order/{orderId}":2.5,"orders/active":1,"orders/closed":1,"orders/{orderId}":1,operations:2.5,"operations/deposits/addresses":2.5,"operations/deposits/addresses/{assetId}":2.5},post:{"orders/limit":1,"orders/market":1,"orders/bulk":1,"operations/withdrawals":2.5,"operations/deposits/addresses":2.5},delete:{orders:1,"orders/{orderId}":1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:0,taker:0}},precisionMode:o.kb,exceptions:{exact:{1001:r.ExchangeError,1100:r.ExchangeError,1101:r.ExchangeError,2e3:r.BadRequest,2001:r.InsufficientFunds,2202:r.DuplicateOrderId,2003:r.ExchangeError,2004:r.NotSupported,2005:r.ExchangeError,2006:r.InsufficientFunds,2007:r.InsufficientFunds,2008:r.InsufficientFunds,2009:r.ExchangeError,2010:r.InsufficientFunds,2011:r.InvalidOrder,2012:r.InvalidOrder,2013:r.InvalidOrder,2014:r.InvalidOrder,2015:r.InvalidOrder,2016:r.InvalidOrder,2017:r.InvalidOrder,2018:r.InvalidOrder,2019:r.InvalidOrder,2020:r.InvalidOrder,2021:r.InvalidOrder,2022:r.InvalidOrder,2023:r.ExchangeError},broad:{}},commonCurrencies:{}})}async fetchCurrencies(e={}){const t=await this.publicGetAssets(e),s=this.safeValue(t,"payload",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"assetId"),a=this.safeString(t,"symbol"),o=this.safeString(t,"name"),n="erc20Token"===this.safeString(t,"type")?"crypto":"other",d=this.safeValue(t,"blockchainDepositEnabled"),h=this.safeValue(t,"blockchainWithdrawal"),c=!this.safeValue(t,"isDisabled");i[a]={id:r,code:a,info:t,type:n,name:o,active:c,deposit:d,withdraw:h,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(t,"accuracy"))),limits:{withdraw:{min:this.safeValue(t,"cashoutMinimalAmount"),max:void 0},amount:{min:this.safeValue(t,"lowVolumeAmount"),max:void 0}},networks:{}}}return i}async fetchMarkets(e={}){const t=await this.publicGetAssetpairs(e),s=this.safeValue(t,"payload",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"assetPairId"),a=this.safeString(t,"name"),o=this.safeString(t,"baseAssetId"),n=this.safeString(t,"quoteAssetId"),[d,h]=a.split("/"),c=this.safeCurrencyCode(d),l=this.safeCurrencyCode(h),u=c+"/"+l;i.push({id:r,symbol:u,base:c,quote:l,baseId:o,quoteId:n,settle:void 0,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,contract:!1,active:!0,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"baseAssetAccuracy"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"priceAccuracy")))},limits:{amount:{min:this.safeNumber(t,"minVolume"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"minOppositeVolume"),max:void 0},leverage:{min:void 0,max:void 0}},created:void 0,info:t})}return i}parseTicker(e,t=void 0){const s=void 0,i=this.safeString(e,"assetPairId");t=this.safeMarket(i,t);const r=this.safeString(e,"lastPrice");return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volumeBase"),quoteVolume:this.safeString(e,"volumeQuote"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={assetPairIds:s.id};let r;r="publicGetPrices"===this.safeString(this.options,"fetchTickerMethod","publicGetTickers")?await this.publicGetPrices(this.extend(i,t)):await this.publicGetTickers(this.extend(i,t));const a=this.safeValue(r,"payload",[]);return this.parseTicker(this.safeValue(a,0,{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeValue(s,"payload",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={assetPairId:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetOrderbooks(this.extend(r,s)),o=this.safeValue(a,"payload",[]),n=this.safeValue(o,0,{}),d=this.safeInteger(n,"timestamp");return this.parseOrderBook(n,i.symbol,d,"bids","asks","p","v")}parseTrade(e,t=void 0){const s=this.safeString(e,"assetPairId"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"id","id"),a=this.safeString(e,"orderId"),o=this.safeInteger(e,"timestamp"),n=this.safeString2(e,"price","price");let d=this.safeString2(e,"volume","amount");void 0===d&&(d=this.safeString2(e,"baseVolume","amount"));const h=this.safeStringLower(e,"side");return this.safeTrade({id:r,info:e,timestamp:o,datetime:this.iso8601(o),symbol:i,type:void 0,order:a,side:h,takerOrMaker:void 0,price:n,amount:d,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={assetPairId:r.id};void 0!==s&&(a.take=s);const o=await this.publicGetTradesPublicAssetPairId(this.extend(a,i)),n=this.safeValue(o,"payload",[]);return this.parseTrades(n,r,t,s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"assetId"),a=this.safeCurrencyCode(r),o=this.account(),n=this.safeString(i,"available"),d=this.safeString(i,"reserved");o.free=n,o.used=d,t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e),s=this.safeValue(t,"payload",[]);return this.parseBalance(s)}parseOrderStatus(e){return this.safeString({Open:"open",Pending:"open",InOrderBook:"open",Processing:"open",Matched:"closed",Cancelled:"canceled",Rejected:"rejected",Replaced:"canceled",Placed:"open"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.parseOrderStatus(this.safeString(e,"status")),r=this.safeString(e,"assetPairId"),a=this.safeSymbol(r,t),o=this.safeStringLower(e,"type"),n=this.safeInteger(e,"lastTradeTimestamp"),d=this.safeInteger(e,"timestamp"),h=this.safeString(e,"price"),c=this.safeStringLower(e,"side"),l=this.safeString(e,"volume"),u=this.safeString(e,"remainingVolume"),p=this.safeString(e,"filledVolume"),f=this.safeString(e,"cost");return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:n,symbol:a,type:o,timeInForce:void 0,postOnly:void 0,side:c,price:h,stopPrice:void 0,triggerPrice:void 0,amount:l,cost:f,average:void 0,filled:p,remaining:u,status:i,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={assetPairId:o.id,side:this.capitalize(s),volume:parseFloat(this.amountToPrecision(o.symbol,i))};let d;"limit"===t&&(n.price=parseFloat(this.priceToPrecision(o.symbol,r))),d="Market"===this.capitalize(t)?await this.privatePostOrdersMarket(this.extend(n,a)):await this.privatePostOrdersLimit(this.extend(n,a));const h=this.safeValue(d,"payload"),c=this.safeString(h,"orderId");return"market"===t&&(r=this.safeNumber(h,"price")),this.safeOrder({id:c,info:d,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:o.symbol,type:t,side:s,price:r,amount:i,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0},o)}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},r=await this.privateDeleteOrdersOrderId(this.extend(i,s));return this.safeOrder({info:r})}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i;void 0!==e&&(i=this.market(e),s.assetPairId=i.id);const r=await this.privateDeleteOrders(this.extend(s,t));return[this.safeOrder({info:r})]}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.privateGetOrdersOrderId(this.extend(i,s)),a=this.safeValue(r,"payload");return this.parseOrder(a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==s&&(a.take=s);const o=await this.privateGetOrdersActive(this.extend(a,i)),n=this.safeValue(o,"payload");return this.parseOrders(n,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==s&&(a.take=s);const o=await this.privateGetOrdersClosed(this.extend(a,i)),n=this.safeValue(o,"payload");return this.parseOrders(n,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==s&&(r.take=s),void 0!==e&&(a=this.market(e),r.assetPairId=a.id),void 0!==t&&(r.from=t);const o=await this.privateGetTrades(this.extend(r,i)),n=this.safeValue(o,"payload");return this.parseTrades(n,a,t,s)}parseBidAsk(e,t=0,s=1,i=2){const r=this.safeString(e,t),o=a.Y.stringAbs(this.safeString(e,s));return[this.parseNumber(r),this.parseNumber(o)]}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={assetId:this.safeString(s,"id")},r=await this.privateGetOperationsDepositsAddressesAssetId(this.extend(i,t)),a=this.safeString(r,"baseAddress"),o=this.safeString(r,"addressExtension");return this.checkAddress(a),{currency:e,address:a,tag:o,network:void 0,info:r}}parseTransaction(e,t=void 0){let s,i,r,a,o,n,d;if("string"==typeof e)s=e;else{s=this.safeString(e,"operationId"),i=this.safeString(e,"assetId"),r=this.safeCurrencyCode(i,t),a=this.safeNumber(e,"totalVolume"),n=this.safeString(e,"type"),d=this.safeInteger(e,"timestamp");o={currency:r,cost:this.safeNumber(e,"fee")}}return{info:e,id:s,txid:void 0,timestamp:d,datetime:this.iso8601(d),network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,type:n,amount:a,currency:r,status:void 0,updated:void 0,internal:void 0,comment:void 0,fee:o}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==s&&(r.take=s);const a=await this.privateGetOperations(this.extend(r,i)),o=this.safeValue(a,"payload",[]);let n;return void 0!==e&&(n=this.currency(e)),this.parseTransactions(o,n,t,s)}async withdraw(e,t,s,i=void 0,r={}){await this.loadMarkets(),this.checkAddress(s);const a=this.currency(e),o={assetId:a.id,volume:parseFloat(this.currencyToPrecision(e,t)),destinationAddress:s};void 0!==i&&(o.destinationAddressExtension=i);const n=await this.privatePostOperationsWithdrawals(this.extend(o,r));return this.parseTransaction(n,a)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/"+this.implodeParams(e,i);const n=this.omit(i,this.extractParams(e));return r={Accept:"application/json","Content-Type":"application/json"},"public"===t?Object.keys(n).length&&(o+="?"+this.urlencode(n)):"private"===t&&("GET"!==s&&"DELETE"!==s||Object.keys(n).length&&(o+="?"+this.urlencode(n)),this.checkRequiredCredentials(),r.Authorization="Bearer "+this.apiKey,"POST"===s&&Object.keys(i).length&&(a=this.json(i)),"operations/withdrawals"===e&&(r["X-Request-ID"]=this.uuid())),{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeValue(n,"error",{}),l=this.safeString(c,"code");if(void 0!==l&&"0"!==l){const e=this.id+" "+o,t=this.safeString(c,"message");throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,t,e),new r.ExchangeError(e)}}}},6419:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(6928),r=s(2079),a=s(1579),o=s(7481),n=s(5147);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"mercado",name:"Mercado Bitcoin",countries:["BR"],rateLimit:1e3,version:"v3",has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:"emulated",fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,withdraw:!0},timeframes:{"15m":"15m","1h":"1h","3h":"3h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",api:{public:"https://www.mercadobitcoin.net/api",private:"https://www.mercadobitcoin.net/tapi",v4Public:"https://www.mercadobitcoin.com.br/v4",v4PublicNet:"https://api.mercadobitcoin.net/api/v4"},www:"https://www.mercadobitcoin.com.br",doc:["https://www.mercadobitcoin.com.br/api-doc","https://www.mercadobitcoin.com.br/trade-api"]},api:{public:{get:["coins","{coin}/orderbook/","{coin}/ticker/","{coin}/trades/","{coin}/trades/{from}/","{coin}/trades/{from}/{to}","{coin}/day-summary/{year}/{month}/{day}/"]},private:{post:["cancel_order","get_account_info","get_order","get_withdrawal","list_system_messages","list_orders","list_orderbook","place_buy_order","place_sell_order","place_market_buy_order","place_market_sell_order","withdraw_coin"]},v4Public:{get:["{coin}/candle/"]},v4PublicNet:{get:["candles"]}},fees:{trading:{maker:.003,taker:.007}},options:{limits:{BTC:.001,BCH:.001,ETH:.01,LTC:.01,XRP:.1}},precisionMode:a.kb})}async fetchMarkets(e={}){const t=await this.publicGetCoins(e),s=[],i=this.safeValue(this.options,"limits",{});for(let e=0;e<t.length;e++){const r=t[e],a=r,o="BRL",n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=d+n;s.push({id:h,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-5")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,a),max:void 0},price:{min:this.parseNumber("1e-5"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:r})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={coin:i.base},a=await this.publicGetCoinOrderbook(this.extend(r,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"date"),r=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"vol"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={coin:s.base},r=await this.publicGetCoinTicker(this.extend(i,t)),a=this.safeValue(r,"ticker",{});return this.parseTicker(a,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp2(e,"date","executed_timestamp");t=this.safeMarket(void 0,t);const i=this.safeString2(e,"tid","operation_id"),r=this.safeString(e,"type"),a=this.safeString(e,"price"),o=this.safeString2(e,"amount","quantity"),n=this.safeString(e,"fee_rate");let d;return void 0!==n&&(d={cost:n,currency:void 0}),this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:void 0,type:undefined,side:r,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:d},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);let a="publicGetCoinTrades";const o={coin:r.base};void 0!==t&&(a+="From",o.from=this.parseToInt(t/1e3));void 0!==this.safeInteger(i,"to")&&(a+="To");const n=await this[a](this.extend(o,i));return this.parseTrades(n,r,t,s)}parseBalance(e){const t=this.safeValue(e,"response_data",{}),s=this.safeValue(t,"balance",{}),i={info:e},r=Object.keys(s);for(let e=0;e<r.length;e++){const t=r[e],a=this.safeCurrencyCode(t);if(t in s){const e=this.safeValue(s,t,{}),r=this.account();r.free=this.safeString(e,"available"),r.total=this.safeString(e,"total"),i[a]=r}}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetAccountInfo(e);return this.parseBalance(t)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const d=this.market(e),h={coin_pair:d.id};let c=this.capitalize(s)+"Order";if("limit"===t)c="privatePostPlace"+c,h.limit_price=this.priceToPrecision(d.symbol,a),h.quantity=this.amountToPrecision(d.symbol,i);else if(c="privatePostPlaceMarket"+c,"buy"===s){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount");const e=this.numberToString(i),t=this.numberToString(a),s=this.parseToNumeric(n.Y.stringMul(e,t));h.cost=this.priceToPrecision(d.symbol,s)}else h.quantity=this.amountToPrecision(d.symbol,i);const l=await this[c](this.extend(h,o));return this.safeOrder({info:l,id:l.response_data.order.order_id.toString()},d)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={coin_pair:i.id,order_id:e},o=await this.privatePostCancelOrder(this.extend(a,s)),n=this.safeValue(o,"response_data",{}),d=this.safeDict(n,"order",{});return this.parseOrder(d,i)}parseOrderStatus(e){return this.safeString({2:"open",3:"canceled",4:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"order_type");let r;"order_type"in e&&(r="1"===i?"buy":"sell");const a=this.parseOrderStatus(this.safeString(e,"status")),o=this.safeString(e,"coin_pair");t=this.safeMarket(o,t);const n=this.safeTimestamp(e,"created_timestamp"),d={cost:this.safeString(e,"fee"),currency:t.quote},h=this.safeString(e,"limit_price"),c=this.safeString(e,"executed_price_avg"),l=this.safeString(e,"quantity"),u=this.safeString(e,"executed_quantity"),p=this.safeTimestamp(e,"updated_timestamp"),f=this.safeValue(e,"operations",[]);return this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:p,symbol:t.symbol,type:"limit",timeInForce:void 0,postOnly:void 0,side:r,price:h,stopPrice:void 0,triggerPrice:void 0,cost:void 0,average:c,amount:l,filled:u,remaining:void 0,status:a,fee:d,trades:f},t)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={coin_pair:i.id,order_id:parseInt(e)},o=await this.privatePostGetOrder(this.extend(a,s)),n=this.safeValue(o,"response_data",{}),d=this.safeDict(n,"order");return this.parseOrder(d,i)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={coin:o.id,quantity:t.toFixed(10),address:s};if("BRL"===e){if(!("account_ref"in a))throw new r.ArgumentsRequired(this.id+" withdraw() requires account_ref parameter to withdraw "+e)}else if("LTC"!==e){if(!("tx_fee"in a))throw new r.ArgumentsRequired(this.id+" withdraw() requires tx_fee parameter to withdraw "+e);if("XRP"===e)if(void 0===i){if(!("destination_tag"in a))throw new r.ArgumentsRequired(this.id+" withdraw() requires a tag argument or destination_tag parameter to withdraw "+e)}else n.destination_tag=i}const d=await this.privatePostWithdrawCoin(this.extend(n,a)),h=this.safeValue(d,"response_data",{}),c=this.safeDict(h,"withdrawal");return this.parseTransaction(c,o)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:void 0,info:e}}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="15m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={resolution:this.safeString(this.timeframes,t,t),symbol:a.base+"-"+a.quote};void 0===i&&(i=100),void 0!==s?(o.from=this.parseToInt(s/1e3),o.to=this.sum(o.from,i*this.parseTimeframe(t))):(o.to=this.seconds(),o.from=o.to-i*this.parseTimeframe(t));const n=await this.v4PublicNetGetCandles(this.extend(o,r)),d=this.convertTradingViewToOHLCV(n,"t","o","h","l","c","v");return this.parseOHLCVs(d,a,t,s,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id},n=await this.privatePostListOrders(this.extend(o,i)),d=this.safeValue(n,"response_data",{}),h=this.safeList(d,"orders",[]);return this.parseOrders(h,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id,status_list:"[2]"},n=await this.privatePostListOrders(this.extend(o,i)),d=this.safeValue(n,"response_data",{}),h=this.safeList(d,"orders",[]);return this.parseOrders(h,a,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={coin_pair:a.id,has_fills:!0},n=await this.privatePostListOrders(this.extend(o,i)),d=this.safeValue(n,"response_data",{}),h=this.safeValue(d,"orders",[]),c=this.parseOrders(h,a,t,s),l=this.ordersToTrades(c);return this.filterBySymbolSinceLimit(l,a.symbol,t,s)}ordersToTrades(e){const t=[];for(let s=0;s<e.length;s++){const i=this.safeValue(e[s],"trades",[]);for(let e=0;e<i.length;e++)t.push(i[e])}return t}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n=this.urls.api[t]+"/";const d=this.omit(i,this.extractParams(e));if("public"===t||"v4Public"===t||"v4PublicNet"===t)n+=this.implodeParams(e,i),Object.keys(d).length&&(n+="?"+this.urlencode(d));else{this.checkRequiredCredentials(),n+=this.version+"/";const t=this.nonce();a=this.urlencode(this.extend({tapi_method:e,tapi_nonce:t},i));const s="/tapi/"+this.version+"/?"+a;r={"Content-Type":"application/x-www-form-urlencoded","TAPI-ID":this.apiKey,"TAPI-MAC":this.hmac(this.encode(s),this.encode(this.secret),o.Zf)}}return{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(void 0!==this.safeValue(n,"error_message"))throw new r.ExchangeError(this.id+" "+this.json(n))}}},2403:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9174),r=s(2079),a=s(1579),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"mexc",name:"MEXC Global",countries:["SC"],rateLimit:50,version:"v3",certified:!0,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:void 0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,deposit:void 0,editOrder:void 0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowRateHistory:void 0,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:void 0,fetchDepositAddress:!0,fetchDepositAddresses:void 0,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:void 0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL2OrderBook:!0,fetchLedger:void 0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverages:!1,fetchLeverageTiers:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:void 0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:void 0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositionMode:!0,fetchPositions:!0,fetchPositionsHistory:!0,fetchPositionsRisk:void 0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:void 0,fetchTradingFees:!0,fetchTradingLimits:void 0,fetchTransactionFee:"emulated",fetchTransactionFees:!0,fetchTransactions:void 0,fetchTransfer:!0,fetchTransfers:!0,fetchWithdrawal:void 0,fetchWithdrawals:!0,reduceMargin:!0,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!0,setMarginMode:void 0,setPositionMode:!0,signIn:void 0,transfer:void 0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",api:{spot:{public:"https://api.mexc.com",private:"https://api.mexc.com"},spot2:{public:"https://www.mexc.com/open/api/v2",private:"https://www.mexc.com/open/api/v2"},contract:{public:"https://contract.mexc.com/api/v1/contract",private:"https://contract.mexc.com/api/v1/private"},broker:{private:"https://api.mexc.com/api/v3/broker"}},www:"https://www.mexc.com/",doc:["https://mexcdevelop.github.io/apidocs/"],fees:["https://www.mexc.com/fee"],referral:"https://www.mexc.com/register?inviteCode=mexc-1FQ1GNu1"},api:{spot:{public:{get:{ping:1,time:1,exchangeInfo:10,depth:1,trades:5,historicalTrades:1,aggTrades:1,klines:1,avgPrice:1,"ticker/24hr":1,"ticker/price":1,"ticker/bookTicker":1,"etf/info":1}},private:{get:{order:2,openOrders:3,allOrders:10,account:10,myTrades:10,"sub-account/list":1,"sub-account/apiKey":1,"capital/config/getall":10,"capital/deposit/hisrec":1,"capital/withdraw/history":1,"capital/withdraw/address":10,"capital/deposit/address":10,"capital/transfer":1,"capital/transfer/tranId":1,"capital/transfer/internal":1,"capital/sub-account/universalTransfer":1,"capital/convert":1,"capital/convert/list":1,"margin/loan":1,"margin/allOrders":1,"margin/myTrades":1,"margin/openOrders":1,"margin/maxTransferable":1,"margin/priceIndex":1,"margin/order":1,"margin/isolated/account":1,"margin/maxBorrowable":1,"margin/repay":1,"margin/isolated/pair":1,"margin/forceLiquidationRec":1,"margin/isolatedMarginData":1,"margin/isolatedMarginTier":1,"rebate/taxQuery":1,"rebate/detail":1,"rebate/detail/kickback":1,"rebate/referCode":1,"rebate/affiliate/commission":1,"rebate/affiliate/withdraw":1,"rebate/affiliate/commission/detail":1,"mxDeduct/enable":1,userDataStream:1},post:{order:1,"order/test":1,"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"sub-account/futures":1,"sub-account/margin":1,batchOrders:10,"capital/withdraw/apply":1,"capital/withdraw":1,"capital/transfer":1,"capital/transfer/internal":1,"capital/deposit/address":1,"capital/sub-account/universalTransfer":1,"capital/convert":10,"mxDeduct/enable":1,userDataStream:1},put:{userDataStream:1},delete:{order:1,openOrders:1,"sub-account/apiKey":1,"margin/order":1,"margin/openOrders":1,userDataStream:1,"capital/withdraw":1}}},contract:{public:{get:{ping:2,detail:100,support_currencies:2,"depth/{symbol}":2,"depth_commits/{symbol}/{limit}":2,"index_price/{symbol}":2,"fair_price/{symbol}":2,"funding_rate/{symbol}":2,"kline/{symbol}":2,"kline/index_price/{symbol}":2,"kline/fair_price/{symbol}":2,"deals/{symbol}":2,ticker:2,risk_reverse:2,"risk_reverse/history":2,"funding_rate/history":2}},private:{get:{"account/assets":2,"account/asset/{currency}":2,"account/transfer_record":2,"position/list/history_positions":2,"position/open_positions":2,"position/funding_records":2,"position/position_mode":2,"order/list/open_orders/{symbol}":2,"order/list/history_orders":2,"order/external/{symbol}/{external_oid}":2,"order/get/{order_id}":2,"order/batch_query":8,"order/deal_details/{order_id}":2,"order/list/order_deals":2,"planorder/list/orders":2,"stoporder/list/orders":2,"stoporder/order_details/{stop_order_id}":2,"account/risk_limit":2,"account/tiered_fee_rate":2,"position/leverage":2},post:{"position/change_margin":2,"position/change_leverage":2,"position/change_position_mode":2,"order/submit":2,"order/submit_batch":40,"order/cancel":2,"order/cancel_with_external":2,"order/cancel_all":2,"account/change_risk_level":2,"planorder/place":2,"planorder/cancel":2,"planorder/cancel_all":2,"stoporder/cancel":2,"stoporder/cancel_all":2,"stoporder/change_price":2,"stoporder/change_plan_price":2}}},spot2:{public:{get:{"market/symbols":1,"market/coin/list":2,"common/timestamp":1,"common/ping":2,"market/ticker":1,"market/depth":1,"market/deals":1,"market/kline":1,"market/api_default_symbols":2}},private:{get:{"account/info":1,"order/open_orders":1,"order/list":1,"order/query":1,"order/deals":1,"order/deal_detail":1,"asset/deposit/address/list":2,"asset/deposit/list":2,"asset/address/list":2,"asset/withdraw/list":2,"asset/internal/transfer/record":10,"account/balance":10,"asset/internal/transfer/info":10,"market/api_symbols":2},post:{"order/place":1,"order/place_batch":1,"order/advanced/place_batch":1,"asset/withdraw":2,"asset/internal/transfer":10},delete:{"order/cancel":1,"order/cancel_by_symbol":1,"asset/withdraw":2}}},broker:{private:{get:{"sub-account/universalTransfer":1,"sub-account/list":1,"sub-account/apiKey":1,"capital/deposit/subAddress":1,"capital/deposit/subHisrec":1,"capital/deposit/subHisrec/getall":1},post:{"sub-account/virtualSubAccount":1,"sub-account/apiKey":1,"capital/deposit/subAddress":1,"capital/withdraw/apply":1,"sub-account/universalTransfer":1,"sub-account/futures":1},delete:{"sub-account/apiKey":1}}}},precisionMode:a.kb,timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","8h":"8h","1d":"1d","1w":"1w","1M":"1M"},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},options:{createMarketBuyOrderRequiresPrice:!0,unavailableContracts:{"BTC/USDT:USDT":!0,"LTC/USDT:USDT":!0,"ETH/USDT:USDT":!0},fetchMarkets:{types:{spot:!0,swap:{linear:!0,inverse:!1}}},timeframes:{spot:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"60m","4h":"4h","1d":"1d","1M":"1M"},swap:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"}},defaultType:"spot",defaultNetwork:"ETH",defaultNetworks:{ETH:"ETH",USDT:"ERC20",USDC:"ERC20",BTC:"BTC",LTC:"LTC"},networks:{ABBC:"ABBC",ACA:"ACALA",ADA:"Cardano(ADA)",AE:"AE",ALGO:"Algorand(ALGO)",ALPH:"Alephium(ALPH)",AME:"AME",AOK:"AOK",APT:"APTOS(APT)",AR:"AR",ARB:"Arbitrum One(ARB)",ARBNOVA:"ARBNOVA",ARBONE:"ArbitrumOne(ARB)",ARK:"ARK",ASTR:"ASTAR",ATOM:"Cosmos(ATOM)",AVAXC:"Avalanche C Chain(AVAX CCHAIN)",AVAXX:"Avalanche X Chain(AVAX XCHAIN)",AZERO:"Aleph Zero(AZERO)",BCH:"Bitcoin Cash(BCH)",BDX:"BDX",BEAM:"BEAM",BEP2:"BNB Beacon Chain(BEP2)",BEP20:"BNB Smart Chain(BEP20)",BITCI:"BITCI",BNC:"BNC",BNCDOT:"BNCPOLKA",BOBA:"BOBA",BSC:"BEP20(BSC)",BSV:"Bitcoin SV(BSV)",BTC:"Bitcoin(BTC)",BTM:"BTM2",CELO:"CELO",CFX:"CFX",CHZ:"Chiliz Legacy Chain(CHZ)",CHZ2:"Chiliz Chain(CHZ2)",CKB:"CKB",CLORE:"Clore.ai(CLORE)",CRC20:"CRONOS",CSPR:"CSPR",DASH:"DASH",DC:"Dogechain(DC)",DCR:"DCR",DNX:"Dynex(DNX)",DOGE:"Dogecoin(DOGE)",DOT:"Polkadot(DOT)",DYM:"Dymension(DYM)",EDG:"EDG",EGLD:"EGLD",EOS:"EOS",ERC20:"Ethereum(ERC20)",ETC:"Ethereum Classic(ETC)",ETHF:"ETF",ETHW:"ETHW",EVER:"EVER",FET:"FET",FIL:"FIL",FIO:"FIO",FLOW:"FLOW",FSN:"FSN",FTM:"Fantom(FTM)",FUSE:"FUSE",GLMR:"GLMR",GRIN:"GRIN",HBAR:"Hedera(HBAR)",HIVE:"HIVE",HRC20:"HECO",HYDRA:"HYDRA",ICP:"Internet Computer(ICP)",INDEX:"Index Chain",IOST:"IOST",IOTA:"IOTA",IOTX:"IOTX",IRIS:"IRIS",KAR:"KAR",KAS:"Kaspa(KAS)",KAVA:"KAVA",KDA:"KDA",KILT:"KILT",KLAY:"Klaytn(KLAY)",KMA:"KMA",KSM:"KSM",LAT:"LAT",LAVA:"Elysium(LAVA)",LTC:"Litecoin(LTC)",LUNA:"Terra(LUNA)",MASS:"MASS",MATIC:"Polygon(MATIC)",MCOIN:"Mcoin Network",METIS:"METIS",MINA:"MINA",MNT:"Mantle(MNT)",MOVR:"MOVR",MTRG:"Meter(MTRG)",NAS:"NAS",NEAR:"NEAR Protocol(NEAR)",NEBL:"NEBL",NEM:"NEM",NEO:"NEO",NEO3:"NEO3",NEOXA:"Neoxa Network",NULS:"NULS",OASIS:"ROSE",OASYS:"OASYS",OKC:"OKT",OMN:"Omega Network(OMN)",OMNI:"OMNI",ONE:"ONE",ONT:"ONT",OPTIMISM:"Optimism(OP)",OSMO:"OSMO",PLCU:"PLCU",POKT:"POKT",QKC:"QKC",QTUM:"QTUM",RAP20:"RAP20 (Rangers Mainnet)",REI:"REI",RSK:"RBTC",RVN:"Ravencoin(RVN)",SATOX:"Satoxcoin(SATOX)",SC:"SC",SCRT:"SCRT",SDN:"SDN",SGB:"SGB",SOL:"Solana(SOL)",STAR:"STAR",STARK:"Starknet(STARK)",STEEM:"STEEM",SYS:"SYS",TAO:"Bittensor(TAO)",TIA:"Celestia(TIA)",TOMO:"TOMO",TON:"Toncoin(TON)",TRC10:"TRC10",TRC20:"Tron(TRC20)",UGAS:"UGAS(Ultrain)",VET:"VeChain(VET)",VEX:"Vexanium(VEX)",VSYS:"VSYS",WAVES:"WAVES",WAX:"WAX",WEMIX:"WEMIX",XCH:"Chia(XCH)",XDC:"XDC",XEC:"XEC",XLM:"Stellar(XLM)",XMR:"Monero(XMR)",XNA:"Neurai(XNA)",XPR:"XPR Network",XRD:"XRD",XRP:"Ripple(XRP)",XTZ:"XTZ",XVG:"XVG",XYM:"XYM",ZEC:"ZEC",ZEN:"ZEN",ZIL:"Zilliqa(ZIL)",ZTG:"ZTG"},networksById:{"BNB Smart Chain(BEP20-RACAV1)":"BSC","BNB Smart Chain(BEP20-RACAV2)":"BSC","BNB Smart Chain(BEP20)":"BSC"},recvWindow:5e3,maxTimeTillEnd:7775999999,broker:"CCXT"},commonCurrencies:{BEYONDPROTOCOL:"BEYOND",BIFI:"BIFIF",BYN:"BEYONDFI",COFI:"COFIX",DFI:"DFISTARTER",DFT:"DFUTURE",DRK:"DRK",EGC:"EGORASCREDIT",FLUX1:"FLUX",FLUX:"FLUX1",FREE:"FREEROSSDAO",GAS:"GASDAO",GASNEO:"GAS",GMT:"GMTTOKEN",STEPN:"GMT",HERO:"STEPHERO",MIMO:"MIMOSA",PROS:"PROSFINANCE",SIN:"SINCITYTOKEN",SOUL:"SOULSWAP"},exceptions:{exact:{"-1128":r.BadRequest,"-2011":r.BadRequest,"-1121":r.BadSymbol,10101:r.InsufficientFunds,2009:r.InvalidOrder,2011:r.BadRequest,30004:r.InsufficientFunds,33333:r.BadRequest,44444:r.BadRequest,1002:r.InvalidOrder,30019:r.BadRequest,30005:r.InvalidOrder,2003:r.InvalidOrder,2005:r.InsufficientFunds,400:r.BadRequest,600:r.BadRequest,70011:r.PermissionDenied,88004:r.InsufficientFunds,88009:r.ExchangeError,88013:r.InvalidOrder,88015:r.InsufficientFunds,700003:r.InvalidNonce,26:r.ExchangeError,602:r.AuthenticationError,10001:r.AuthenticationError,10007:r.BadSymbol,10015:r.BadRequest,10072:r.BadRequest,10073:r.BadRequest,10095:r.InvalidOrder,10096:r.InvalidOrder,10097:r.InvalidOrder,10098:r.InvalidOrder,10099:r.BadRequest,10100:r.BadRequest,10102:r.InvalidOrder,10103:r.ExchangeError,10200:r.BadRequest,10201:r.BadRequest,10202:r.BadRequest,10206:r.BadRequest,10211:r.BadRequest,10212:r.BadRequest,10216:r.ExchangeError,10219:r.ExchangeError,10222:r.BadRequest,10232:r.BadRequest,10259:r.ExchangeError,10265:r.ExchangeError,10268:r.BadRequest,20001:r.ExchangeError,20002:r.ExchangeError,22222:r.BadRequest,3e4:r.ExchangeError,30001:r.InvalidOrder,30002:r.InvalidOrder,30003:r.InvalidOrder,30010:r.InvalidOrder,30014:r.InvalidOrder,30016:r.InvalidOrder,30018:r.AccountSuspended,30020:r.AuthenticationError,30021:r.BadRequest,30025:r.InvalidOrder,30026:r.BadRequest,30027:r.InvalidOrder,30028:r.InvalidOrder,30029:r.InvalidOrder,30032:r.InvalidOrder,30041:r.InvalidOrder,60005:r.ExchangeError,700001:r.AuthenticationError,700002:r.AuthenticationError,700004:r.BadRequest,700005:r.InvalidNonce,700006:r.BadRequest,700007:r.AuthenticationError,700008:r.BadRequest,700013:r.AuthenticationError,730001:r.BadRequest,730002:r.BadRequest,73e4:r.ExchangeError,730003:r.ExchangeError,730100:r.ExchangeError,730600:r.BadRequest,730601:r.BadRequest,730602:r.BadRequest,730700:r.BadRequest,730701:r.BadRequest,730702:r.BadRequest,730703:r.BadRequest,730704:r.BadRequest,730705:r.BadRequest,730706:r.BadRequest,730707:r.BadRequest,730101:r.BadRequest,140001:r.BadRequest,140002:r.AuthenticationError},broad:{"Order quantity error, please try to modify.":r.BadRequest,"Combination of optional parameters invalid":r.BadRequest,"api market order is disabled":r.BadRequest,"Contract not allow place order!":r.InvalidOrder,Oversold:r.InsufficientFunds,"Insufficient position":r.InsufficientFunds,"Insufficient balance!":r.InsufficientFunds,"Bid price is great than max allow price":r.InvalidOrder,"Invalid symbol.":r.BadSymbol,"Param error!":r.BadRequest,maintenance:r.OnMaintenance}}})}async fetchStatus(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchStatus",void 0,e);let i,r,a;if("spot"===t){i=await this.spotPublicGetPing(s);r=Object.keys(i).length?this.json(i):"ok"}else"swap"===t&&(i=await this.contractPublicGetPing(s),r=this.safeValue(i,"success")?"ok":this.json(i),a=this.safeInteger(i,"data"));return{status:r,updated:a,url:void 0,eta:void 0,info:i}}async fetchTime(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchTime",void 0,e);let i;return"spot"===t?(i=await this.spotPublicGetTime(s),this.safeInteger(i,"serverTime")):"swap"===t?(i=await this.contractPublicGetPing(s),this.safeInteger(i,"data")):void 0}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.spotPrivateGetCapitalConfigGetall(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"coin"),a=this.safeCurrencyCode(r),n=this.safeString(i,"name");let d,h,c,l=!1,u=!1,p=!1;const f={},m=this.safeValue(i,"networkList",[]);for(let e=0;e<m.length;e++){const t=m[e],s=this.safeString2(t,"network","netWork"),i=this.networkIdToCode(s),r=this.safeBool(t,"depositEnable",!1),a=this.safeBool(t,"withdrawEnable",!1),n=r&&a;l=n||l;const g=this.safeString(t,"withdrawMin"),v=this.safeString(t,"withdrawMax");h=void 0===h?g:h,c=void 0===c?v:c;const y=this.safeNumber(t,"withdrawFee");d=void 0===d?y:d,o.Y.stringGt(h,g)&&(h=g),o.Y.stringLt(c,v)&&(c=v),r&&(u=!0),a&&(p=!0),f[i]={info:t,id:s,network:i,active:n,deposit:r,withdraw:a,fee:y,precision:void 0,limits:{withdraw:{min:g,max:v}}}}const g=Object.keys(f).length;if(1===g||"NONE"in f){const e=this.safeValue2(f,"NONE",g-1);void 0!==e&&(d=e.fee)}s[a]={info:i,id:r,code:a,name:n,active:l,deposit:u,withdraw:p,fee:d,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:h,max:c}},networks:f}}return s}async fetchMarkets(e={}){const t=await this.fetchSpotMarkets(e),s=await this.fetchSwapMarkets(e);return this.arrayConcat(t,s)}async fetchSpotMarkets(e={}){const t=await this.spotPublicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"baseAsset"),o=this.safeString(t,"quoteAsset"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.safeString(t,"status"),c=this.safeValue(t,"isSpotTradingAllowed");let l=!1;"1"===h&&c&&(l=!0);const u=this.safeValue(t,"isMarginTradingAllowed"),p=this.safeNumber(t,"makerCommission"),f=this.safeNumber(t,"takerCommission"),m=this.safeNumber(t,"maxQuoteAmount");i.push({id:r,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:u,swap:!1,future:!1,option:!1,active:l,contract:!1,linear:void 0,inverse:void 0,taker:f,maker:p,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(t,"baseSizePrecision"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(t,"quoteAmountPrecision"),max:m}},created:void 0,info:t})}return i}async fetchSwapMarkets(e={}){const t=await this.contractPublicGetDetail(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeString(t,"baseCoin"),o=this.safeString(t,"quoteCoin"),n=this.safeString(t,"settleCoin"),d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(o),c=this.safeCurrencyCode(n),l=this.safeString(t,"state");i.push({id:r,symbol:d+"/"+h+":"+c,base:d,quote:h,settle:c,baseId:a,quoteId:o,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:"0"===l,contract:!0,linear:!0,inverse:!1,taker:this.safeNumber(t,"takerFeeRate"),maker:this.safeNumber(t,"makerFeeRate"),contractSize:this.safeNumber(t,"contractSize"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(t,"volUnit"),price:this.safeNumber(t,"priceUnit")},limits:{leverage:{min:this.safeNumber(t,"minLeverage"),max:this.safeNumber(t,"maxLeverage")},amount:{min:this.safeNumber(t,"minVol"),max:this.safeNumber(t,"maxVol")},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t})}return i}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let a;if(void 0!==t&&(r.limit=t),i.spot){const t=await this.spotPublicGetDepth(this.extend(r,s)),i=this.safeInteger(t,"timestamp");a=this.parseOrderBook(t,e,i),a.nonce=this.safeInteger(t,"lastUpdateId")}else if(i.swap){const t=await this.contractPublicGetDepthSymbol(this.extend(r,s)),i=this.safeValue(t,"data"),o=this.safeInteger(i,"timestamp");a=this.parseOrderBook(i,e,o),a.nonce=this.safeInteger(i,"version")}return a}parseBidAsk(e,t=0,s=1,i=2){const r=this.safeNumber(e,t),a=this.safeNumber(e,s),o=this.safeNumber(e,2);return void 0!==o?[r,a,o]:[r,a]}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id};let n;if(void 0!==s&&(o.limit=s),a.spot){const e=this.safeIntegerN(i,["endTime","until"]);if(void 0!==t&&(o.startTime=t,void 0===e))throw new r.ArgumentsRequired(this.id+" fetchTrades() requires an until parameter when since is provided");if(void 0!==e){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchTrades() requires a since parameter when until is provided");o.endTime=e}let s=this.safeString(this.options,"fetchTradesMethod","spotPublicGetAggTrades");if(s=this.safeString(i,"method",s),i=this.omit(i,["method"]),"spotPublicGetAggTrades"===s)n=await this.spotPublicGetAggTrades(this.extend(o,i));else if("spotPublicGetHistoricalTrades"===s)n=await this.spotPublicGetHistoricalTrades(this.extend(o,i));else{if("spotPublicGetTrades"!==s)throw new r.NotSupported(this.id+" fetchTrades() not support this method");n=await this.spotPublicGetTrades(this.extend(o,i))}}else if(a.swap){const e=await this.contractPublicGetDealsSymbol(this.extend(o,i));n=this.safeValue(e,"data")}return this.parseTrades(n,a,t,s)}parseTrade(e,t=void 0){let s,i,r,a,o;const n=void 0;let d,h,c,l,u;if("v"in e)i=this.safeInteger(e,"t"),a=(t=this.safeMarket(void 0,t)).symbol,c=this.safeString(e,"p"),l=this.safeString(e,"v"),d=this.parseOrderSide(this.safeString(e,"T")),h="taker";else{const n=this.safeString(e,"symbol");if(a=(t=this.safeMarket(n,t)).symbol,s=this.safeString2(e,"id","a"),c=this.safeString2(e,"price","p"),r=this.safeString(e,"orderId"),"positionMode"in e)i=this.safeInteger(e,"timestamp"),l=this.safeString(e,"vol"),d=this.parseOrderSide(this.safeString(e,"side")),o={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))},h=this.safeValue(e,"taker")?"taker":"maker";else{i=this.safeInteger2(e,"time","T"),l=this.safeString2(e,"qty","q"),u=this.safeString(e,"quoteQty");const t=this.safeValue(e,"isBuyer"),s=this.safeValue(e,"isMaker"),r=this.safeValue2(e,"isBuyerMaker","m");void 0!==s&&(h=s?"maker":"taker"),void 0!==t&&(d=t?"buy":"sell"),void 0!==r&&(d=r?"sell":"buy",h="taker");const a=this.safeString(e,"commissionAsset");void 0!==a&&(o={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(a)})}}return void 0===s&&(s=this.syntheticTradeId(t,i,d,l,c,n,h)),this.safeTrade({id:s,order:r,timestamp:i,datetime:this.iso8601(i),symbol:a,type:n,side:d,takerOrMaker:h,price:c,amount:l,cost:u,fee:o,info:e},t)}syntheticTradeId(e=void 0,t=void 0,s=void 0,i=void 0,r=void 0,a=void 0,o=void 0){let n="";return void 0!==t&&(n=this.numberToString(t)+"-"+this.safeString(e,"id","_"),void 0!==s&&(n+="-"+s),void 0!==i&&(n+="-"+this.numberToString(i)),void 0!==r&&(n+="-"+this.numberToString(r)),void 0!==o&&(n+="-"+o),void 0!==a&&(n+="-"+a)),n}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=o.spot?1e3:2e3;let d=!1;if([d,a]=this.handleOptionAndParams(a,"fetchOHLCV","paginate",!1),d)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,a,n);const h=this.safeValue(this.options,"timeframes",{}),c=this.safeValue(h,o.type,{}),l=this.safeString(c,t),u=1e3*this.parseTimeframe(t),p={symbol:o.id,interval:l};let f;if(o.spot){const e=this.safeIntegerN(a,["until","endTime"]);if(void 0!==s&&(p.startTime=s,void 0===e)){const e=this.sum(s,n*u),t=this.milliseconds();p.endTime=Math.min(e,t)}void 0!==i&&(p.limit=i),void 0!==e&&(a=this.omit(a,["until"]),p.endTime=e);f=await this.spotPublicGetKlines(this.extend(p,a))}else if(o.swap){const e=this.safeIntegerProductN(a,["until","endTime"],.001);void 0!==s&&(p.start=this.parseToInt(s/1e3)),void 0!==e&&(a=this.omit(a,["until"]),p.end=e);const t=this.safeString(a,"price","default");let i;if(a=this.omit(a,"price"),"default"===t)i=await this.contractPublicGetKlineSymbol(this.extend(p,a));else if("index"===t)i=await this.contractPublicGetKlineIndexPriceSymbol(this.extend(p,a));else{if("mark"!==t)throw new r.NotSupported(this.id+" fetchOHLCV() not support this price type, [default, index, mark]");i=await this.contractPublicGetKlineFairPriceSymbol(this.extend(p,a))}const o=this.safeValue(i,"data");f=this.convertTradingViewToOHLCV(o,"time","open","high","low","close","vol")}return this.parseOHLCVs(f,o,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};let i,r=!1;if(void 0!==e){r=1===e.length;const t=this.safeString(e,0);i=this.market(t)}const[a,o]=this.handleMarketTypeAndParams("fetchTickers",i,t);let n;if(r&&(s.symbol=i.id),"spot"===a)n=await this.spotPublicGetTicker24hr(this.extend(s,o));else if("swap"===a){const e=await this.contractPublicGetTicker(this.extend(s,o));n=this.safeValue(e,"data",[])}return r&&(n=[n]),this.parseTickers(n,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),[i,r]=this.handleMarketTypeAndParams("fetchTicker",s,t);let a;const o={symbol:s.id};if("spot"===i)a=await this.spotPublicGetTicker24hr(this.extend(o,r));else if("swap"===i){const e=await this.contractPublicGetTicker(this.extend(o,r));a=this.safeValue(e,"data",{})}return this.parseTicker(a,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol");let i,r,a,n,d,h,c,l,u,p,f,m,g;t=this.safeMarket(s,t);return this.safeValue(t,"swap")||"timestamp"in e?(i=this.safeInteger(e,"timestamp"),r=this.safeString(e,"bid1"),a=this.safeString(e,"ask1"),h=this.safeString(e,"volume24"),c=this.safeString(e,"amount24"),u=this.safeString(e,"high24Price"),p=this.safeString(e,"lower24Price"),m=this.safeString(e,"riseFallValue"),f=this.safeString(e,"riseFallRate"),f=o.Y.stringMul(f,"100")):(i=this.safeInteger(e,"closeTime"),r=this.safeString(e,"bidPrice"),a=this.safeString(e,"askPrice"),n=this.safeString(e,"bidQty"),d=this.safeString(e,"askQty"),o.Y.stringEq(n,"0")&&(n=void 0),o.Y.stringEq(d,"0")&&(d=void 0),h=this.safeString(e,"volume"),c=this.safeString(e,"quoteVolume"),l=this.safeString(e,"openPrice"),u=this.safeString(e,"highPrice"),p=this.safeString(e,"lowPrice"),g=this.safeString(e,"prevClosePrice"),m=this.safeString(e,"priceChange"),f=this.safeString(e,"priceChangePercent"),f=o.Y.stringMul(f,"100")),this.safeTicker({symbol:t.symbol,timestamp:i,datetime:this.iso8601(i),open:l,high:u,low:p,close:this.safeString(e,"lastPrice"),bid:r,bidVolume:n,ask:a,askVolume:d,vwap:void 0,previousClose:g,change:m,percentage:f,average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchBidsAsks(e=void 0,t={}){let s;await this.loadMarkets();let i=!1;if(void 0!==e){i=1===e.length,s=this.market(e[0])}const[a,o]=this.handleMarketTypeAndParams("fetchBidsAsks",s,t);let n;if("spot"===a)n=await this.spotPublicGetTickerBookTicker(o);else if("swap"===a)throw new r.NotSupported(this.id+" fetchBidsAsks() is not available for "+a+" markets");return i&&(n=[n]),this.parseTickers(n,e)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),[n,d]=this.handleMarginModeAndParams("createOrder",a);return o.spot?await this.createSpotOrder(o,t,s,i,r,n,d):await this.createSwapOrder(o,t,s,i,r,n,d)}createSpotOrderRequest(e,t,s,i,a=void 0,n=void 0,d={}){const h=e.symbol,c=s.toUpperCase(),l={symbol:e.id,side:c,type:t.toUpperCase()};if("BUY"===c&&"market"===t){let e=!0;[e,d]=this.handleOptionAndParams(d,"createOrder","createMarketBuyOrderRequiresPrice",!0);const t=this.safeNumber2(d,"cost","quoteOrderQty");if(d=this.omit(d,"cost"),void 0!==t)i=t;else if(e){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const e=this.numberToString(i),t=this.numberToString(a);i=o.Y.stringMul(e,t)}}l.quoteOrderQty=this.costToPrecision(h,i)}else l.quantity=this.amountToPrecision(h,i);void 0!==a&&(l.price=this.priceToPrecision(h,a));const u=this.safeString(d,"clientOrderId");if(void 0!==u&&(l.newClientOrderId=u,d=this.omit(d,["type","clientOrderId"])),void 0!==n&&"isolated"!==n)throw new r.BadRequest(this.id+" createOrder() does not support marginMode "+n+" for spot-margin trading");let p;return[p,d]=this.handlePostOnly("market"===t,"LIMIT_MAKER"===t,d),p&&(l.type="LIMIT_MAKER"),this.extend(l,d)}async createSpotOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.createSpotOrderRequest(e,t,s,i,r,a,o),d=await this.spotPrivatePostOrder(this.extend(n,o)),h=this.parseOrder(d,e);return h.side=s,h.type=t,h.price=r,h.amount=i,h}async createSwapOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=e.symbol,h=this.safeValue(this.options,"unavailableContracts",{});if(this.safeBool(h,d,!1))throw new r.NotSupported(this.id+" createSwapOrder() does not support yet this symbol:"+d);let c,l;if(void 0!==o)if("cross"===o)c=2;else{if("isolated"!==o)throw new r.ArgumentsRequired(this.id+' createSwapOrder() marginMode parameter should be either "cross" or "isolated"');c=1}else c=this.safeInteger(n,"openType",2);if("limit"!==t&&"market"!==t&&1!==t&&2!==t&&3!==t&&4!==t&&5!==t&&6!==t)throw new r.InvalidOrder(this.id+" createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price");[l,n]=this.handlePostOnly("market"===t,2===t,n),l?t=2:"limit"===t?t=1:"market"===t&&(t=6);const u={symbol:e.id,vol:parseFloat(this.amountToPrecision(d,i)),type:t,openType:c};if(5!==t&&6!==t&&"market"!==t&&(u.price=parseFloat(this.priceToPrecision(d,a))),1===c){if(void 0===this.safeInteger(n,"leverage"))throw new r.ArgumentsRequired(this.id+" createSwapOrder() requires a leverage parameter for isolated margin orders")}const p=this.safeBool(n,"reduceOnly",!1);u.side=p?"buy"===s?2:4:"buy"===s?1:3;const f=this.safeString2(n,"clientOrderId","externalOid");void 0!==f&&(u.externalOid=f);const m=this.safeNumber2(n,"triggerPrice","stopPrice");let g;n=this.omit(n,["clientOrderId","externalOid","postOnly","stopPrice","triggerPrice"]),m?(u.triggerPrice=this.priceToPrecision(d,m),u.triggerType=this.safeInteger(n,"triggerType",1),u.executeCycle=this.safeInteger(n,"executeCycle",1),u.trend=this.safeInteger(n,"trend",1),u.orderType=this.safeInteger(n,"orderType",1),g=await this.contractPrivatePostPlanorderPlace(this.extend(u,n))):g=await this.contractPrivatePostOrderSubmit(this.extend(u,n));const v=this.safeString(g,"data");return this.safeOrder({id:v},e)}async createOrders(e,t={}){await this.loadMarkets();const s=[];let i;for(let a=0;a<e.length;a++){const o=e[a],n=this.safeString(o,"symbol"),d=this.market(n);if(!d.spot)throw new r.NotSupported(this.id+" createOrders() is only supported for spot markets");if(void 0===i)i=n;else if(i!==n)throw new r.BadRequest(this.id+" createOrders() requires all orders to have the same symbol");const h=this.safeString(o,"type"),c=this.safeString(o,"side"),l=this.safeValue(o,"amount"),u=this.safeValue(o,"price"),p=this.safeValue(o,"params",{});let f;[f,t]=this.handleMarginModeAndParams("createOrder",t);const m=this.createSpotOrderRequest(d,h,c,l,u,f,p);s.push(m)}const a={batchOrders:this.json(s)},o=await this.spotPrivatePostBatchOrders(a);return this.parseOrders(o)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id};let o;if(i.spot){const t=this.safeString(s,"clientOrderId");void 0!==t?(s=this.omit(s,"clientOrderId"),a.origClientOrderId=t):a.orderId=e;const[i,n]=this.handleMarginModeAndParams("fetchOrder",s);if(void 0!==i){if("isolated"!==i)throw new r.BadRequest(this.id+" fetchOrder() does not support marginMode "+i+" for spot-margin trading");o=await this.spotPrivateGetMarginOrder(this.extend(a,n))}else o=await this.spotPrivateGetOrder(this.extend(a,n))}else if(i.swap){a.order_id=e;const t=await this.contractPrivateGetOrderGetOrderId(this.extend(a,s));o=this.safeValue(t,"data")}return this.parseOrder(o,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;void 0!==e&&(o=this.market(e),a.symbol=o.id);const[n,d]=this.handleMarketTypeAndParams("fetchOrders",o,i);if("spot"===n){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument for spot market");const[n,d]=this.handleMarginModeAndParams("fetchOrders",i);let h;if(void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s),void 0!==n){if("isolated"!==n)throw new r.BadRequest(this.id+" fetchOrders() does not support marginMode "+n+" for spot-margin trading");h=await this.spotPrivateGetMarginAllOrders(this.extend(a,d))}else h=await this.spotPrivateGetAllOrders(this.extend(a,d));return this.parseOrders(h,o,t,s)}{if(void 0!==t){a.start_time=t;void 0===this.safeInteger(i,"end_time")&&(a.end_time=this.sum(t,this.options.maxTimeTillEnd))}void 0!==s&&(a.page_size=s);let e=this.safeString(this.options,"fetchOrders","contractPrivateGetOrderListHistoryOrders");e=this.safeString(d,"method",e);let r=[],n=[];if("contractPrivateGetOrderListHistoryOrders"===e){const e=await this.contractPrivateGetOrderListHistoryOrders(this.extend(a,d));r=this.safeValue(e,"data")}else{const e=await this.contractPrivateGetPlanorderListOrders(this.extend(a,d));n=this.safeValue(e,"data")}const h=this.arrayConcat(n,r);return this.parseOrders(h,o,t,s,i)}}async fetchOrdersByIds(e,t=void 0,s={}){await this.loadMarkets();const i={};let a;void 0!==t&&(a=this.market(t),i.symbol=a.id);const[o,n]=this.handleMarketTypeAndParams("fetchOrdersByIds",a,s);if("spot"===o)throw new r.BadRequest(this.id+" fetchOrdersByIds() is not supported for "+o);{i.order_ids=e.join(",");const t=await this.contractPrivateGetOrderBatchQuery(this.extend(i,n)),s=this.safeList(t,"data");return this.parseOrders(s,a)}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o,n;if(void 0!==e&&(o=this.market(e)),[n,i]=this.handleMarketTypeAndParams("fetchOpenOrders",o,i),"spot"===n){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument for spot market");a.symbol=o.id;const[n,d]=this.handleMarginModeAndParams("fetchOpenOrders",i);let h;if(void 0!==n){if("isolated"!==n)throw new r.BadRequest(this.id+" fetchOpenOrders() does not support marginMode "+n+" for spot-margin trading");h=await this.spotPrivateGetMarginOpenOrders(this.extend(a,d))}else h=await this.spotPrivateGetOpenOrders(this.extend(a,d));return this.parseOrders(h,o,t,s)}return await this.fetchOrdersByState(2,e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(3,e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByState(4,e,t,s,i)}async fetchOrdersByState(e,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();const o={};let n;void 0!==t&&(n=this.market(t));const[d]=this.handleMarketTypeAndParams("fetchOrdersByState",n,a);if("spot"===d)throw new r.NotSupported(this.id+" fetchOrdersByState() is not supported for "+d);return o.states=e,await this.fetchOrders(t,s,i,this.extend(o,a))}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={};let a,o;void 0!==t&&(a=this.market(t),i.symbol=a.id),[o,s]=this.handleMarketTypeAndParams("cancelOrder",a,s);const[n,d]=this.handleMarginModeAndParams("cancelOrder",s);let h;if("spot"===o){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const i={symbol:a.id},o=this.safeString(s,"clientOrderId");if(void 0!==o?(s=this.omit(d,"clientOrderId"),i.origClientOrderId=o):i.orderId=e,void 0!==n){if("isolated"!==n)throw new r.BadRequest(this.id+" cancelOrder() does not support marginMode "+n+" for spot-margin trading");h=await this.spotPrivateDeleteMarginOrder(this.extend(i,d))}else h=await this.spotPrivateDeleteOrder(this.extend(i,d))}else{let t,s=this.safeString(this.options,"cancelOrder","contractPrivatePostOrderCancel");if(s=this.safeString(d,"method",s),"contractPrivatePostOrderCancel"===s)t=await this.contractPrivatePostOrderCancel([e]);else{if("contractPrivatePostPlanorderCancel"!==s)throw new r.NotSupported(this.id+" cancelOrder() not support this method");t=await this.contractPrivatePostPlanorderCancel([e])}h=this.safeValue(t,"data");const i=this.safeValue(h,0),a=this.safeValue(i,"errorMsg","");if("success"!==a)throw new r.InvalidOrder(this.id+" cancelOrder() the order with id "+e+" cannot be cancelled: "+a)}return this.parseOrder(h,a)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=void 0!==t?this.market(t):void 0,[a]=this.handleMarketTypeAndParams("cancelOrders",i,s);if("spot"===a)throw new r.BadRequest(this.id+" cancelOrders() is not supported for "+a);{const t=await this.contractPrivatePostOrderCancel(e),s=this.safeList(t,"data");return this.parseOrders(s,i)}}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=void 0!==e?this.market(e):void 0,i={};let a;[a,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const[o,n]=this.handleMarginModeAndParams("cancelAllOrders",t);if("spot"===a){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument on spot");let t;if(i.symbol=s.id,void 0!==o){if("isolated"!==o)throw new r.BadRequest(this.id+" cancelAllOrders() does not support marginMode "+o+" for spot-margin trading");t=await this.spotPrivateDeleteMarginOpenOrders(this.extend(i,n))}else t=await this.spotPrivateDeleteOpenOrders(this.extend(i,n));return this.parseOrders(t,s)}{void 0!==e&&(i.symbol=s.id);let t,r=this.safeString(this.options,"cancelAllOrders","contractPrivatePostOrderCancelAll");r=this.safeString(n,"method",r),"contractPrivatePostOrderCancelAll"===r?t=await this.contractPrivatePostOrderCancelAll(this.extend(i,n)):"contractPrivatePostPlanorderCancelAll"===r&&(t=await this.contractPrivatePostPlanorderCancelAll(this.extend(i,n)));const a=this.safeList(t,"data",[]);return this.parseOrders(a,s)}}parseOrder(e,t=void 0){if(void 0!==this.safeInteger(e,"code"))return this.safeOrder({info:e,status:"rejected",clientOrderId:this.safeString(e,"newClientOrderId")});let s;s="string"==typeof e?e:this.safeString2(e,"orderId","id");const i=this.safeString(e,"symbol");t=this.safeMarket(i,t);const r=this.safeIntegerN(e,["time","createTime","transactTime"]);let a;const n=this.safeString(e,"feeCurrency");if(void 0!==n){const t=this.safeString(e,"takerFee"),s=this.safeString(e,"makerFee"),i=o.Y.stringAdd(t,s);a={currency:n,cost:this.parseNumber(i)}}return this.safeOrder({id:s,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:this.parseOrderStatus(this.safeString2(e,"status","state")),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"type")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.parseOrderSide(this.safeString(e,"side")),price:this.safeNumber(e,"price"),stopPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),triggerPrice:this.safeNumber2(e,"stopPrice","triggerPrice"),average:this.safeNumber(e,"dealAvgPrice"),amount:this.safeNumber2(e,"origQty","vol"),cost:this.safeNumber(e,"cummulativeQuoteQty"),filled:this.safeNumber2(e,"executedQty","dealVol"),remaining:void 0,fee:a,trades:void 0,info:e},t)}parseOrderSide(e){return this.safeString({BUY:"buy",SELL:"sell",1:"buy",2:"sell"},e,e)}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit",LIMIT_MAKER:"limit"},e,e)}parseOrderStatus(e){return this.safeString({NEW:"open",FILLED:"closed",CANCELED:"canceled",PARTIALLY_FILLED:"open",PARTIALLY_CANCELED:"canceled",2:"open",3:"closed",4:"canceled"},e,e)}parseOrderTimeInForce(e){return this.safeString({GTC:"GTC",FOK:"FOK",IOC:"IOC"},e,e)}async fetchAccountHelper(e,t){if("spot"===e)return await this.spotPrivateGetAccount(t);if("swap"===e){const e=await this.contractPrivateGetAccountAssets(t);return this.safeValue(e,"data")}}async fetchAccounts(e={}){const[t,s]=this.handleMarketTypeAndParams("fetchAccounts",void 0,e);await this.loadMarkets();const i=await this.fetchAccountHelper(t,s),r=this.safeValue(i,"balances",[]),a=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString2(t,"asset","currency"),i=this.safeCurrencyCode(s);a.push({id:this.safeString(t,"id"),type:this.safeString(t,"type"),code:i,info:t})}return a}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.fetchAccountHelper("spot",e);let s=this.safeString(t,"makerCommission"),i=this.safeString(t,"takerCommission");s=o.Y.stringDiv(s,"1000"),i=o.Y.stringDiv(i,"1000");const r={};for(let e=0;e<this.symbols.length;e++){const a=this.symbols[e];r[a]={symbol:a,maker:this.parseNumber(s),taker:this.parseNumber(i),percentage:!0,tierBased:!1,info:t}}return r}customParseBalance(e,t){let s;s="margin"===t?this.safeValue(e,"assets",[]):"swap"===t?this.safeValue(e,"data",[]):this.safeValue(e,"balances",[]);const i={info:e};if("margin"===t){for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"symbol"),a=this.safeSymbol(r,void 0),o=this.safeValue(t,"baseAsset",{}),n=this.safeValue(t,"quoteAsset",{}),d=this.safeCurrencyCode(this.safeString(o,"asset")),h=this.safeCurrencyCode(this.safeString(n,"asset")),c={};c[d]=this.parseBalanceHelper(o),c[h]=this.parseBalanceHelper(n),i[a]=this.safeBalance(c)}return i}if("swap"===t){for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"availableBalance"),o.used=this.safeString(t,"frozenBalance"),i[a]=o}return this.safeBalance(i)}for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"free"),o.used=this.safeString(t,"locked"),i[a]=o}return this.safeBalance(i)}parseBalanceHelper(e){const t=this.account();t.used=this.safeString(e,"locked"),t.free=this.safeString(e,"free"),t.total=this.safeString(e,"totalAsset");const s=this.safeString(e,"borrowed"),i=this.safeString(e,"interest");return t.debt=o.Y.stringAdd(s,i),t}async fetchBalance(e={}){let t;await this.loadMarkets();const s={};[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const i=this.safeString(e,"marginMode"),a=this.safeBool(e,"margin",!1);let o;if(e=this.omit(e,["margin","marginMode"]),void 0!==i||a||"margin"===t){let i;const r=this.safeString(e,"symbol");if(void 0===r){const t=this.safeValue(e,"symbols");void 0!==t&&(i=this.marketIds(t).join(","))}else{i=this.market(r).id}this.checkRequiredArgument("fetchBalance",i,"symbol or symbols"),t="margin",s.symbols=i,e=this.omit(e,["symbol","symbols"]),o=await this.spotPrivateGetMarginIsolatedAccount(this.extend(s,e))}else if("spot"===t)o=await this.spotPrivateGetAccount(this.extend(s,e));else{if("swap"!==t)throw new r.NotSupported(this.id+" fetchBalance() not support this method");o=await this.contractPrivateGetAccountAssets(this.extend(s,e))}return this.customParseBalance(o,t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),[o,n]=this.handleMarketTypeAndParams("fetchMyTrades",a,i),d={symbol:a.id};let h;if("spot"===o)void 0!==t&&(d.start_time=t),void 0!==s&&(d.limit=s),h=await this.spotPrivateGetMyTrades(this.extend(d,n));else{if(void 0!==t){d.start_time=t;void 0===this.safeInteger(i,"end_time")&&(d.end_time=this.sum(t,this.options.maxTimeTillEnd))}void 0!==s&&(d.page_size=s);const e=await this.contractPrivateGetOrderListOrderDeals(this.extend(d,n));h=this.safeValue(e,"data")}return this.parseTrades(h,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();const o={};let n;void 0!==t&&(n=this.market(t));const[d,h]=this.handleMarketTypeAndParams("fetchOrderTrades",n,a);let c;if("spot"===d){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrderTrades() requires a symbol argument");o.symbol=n.id,o.orderId=e,c=await this.spotPrivateGetMyTrades(this.extend(o,h))}else{o.order_id=e;const t=await this.contractPrivateGetOrderDealDetailsOrderId(this.extend(o,h));c=this.safeValue(t,"data")}return this.parseTrades(c,n,s,i,h)}async modifyMarginHelper(e,t,s,i={}){const a=this.safeInteger(i,"positionId");if(void 0===a)throw new r.ArgumentsRequired(this.id+" modifyMarginHelper() requires a positionId parameter");await this.loadMarkets();const o={positionId:a,amount:t,type:s};return await this.contractPrivatePostPositionChangeMargin(this.extend(o,i))}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e},a=this.safeInteger(s,"positionId");if(void 0===a){const e=this.safeNumber(s,"openType"),a=this.safeNumber(s,"positionType"),o=void 0!==t?this.market(t):void 0;if(void 0===e||void 0===a||void 0===o)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions");i.openType=e,i.symbol=o.id,i.positionType=a}else i.positionId=a;return await this.contractPrivatePostPositionChangeLeverage(this.extend(i,s))}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==s&&(a.page_size=s);const o=await this.contractPrivateGetPositionFundingRecords(this.extend(a,i)),n=this.safeValue(o,"data",{}),d=this.safeValue(n,"resultList",[]),h=[];for(let t=0;t<d.length;t++){const s=d[t],i=this.safeInteger(s,"settleTime");h.push({info:s,symbol:e,code:void 0,timestamp:i,datetime:this.iso8601(i),id:this.safeNumber(s,"id"),amount:this.safeNumber(s,"funding")})}return h}parseFundingRate(e,t=void 0){const s=this.safeNumber(e,"fundingRate"),i=this.safeInteger(e,"nextSettleTime"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t),o=this.safeInteger(e,"timestamp");return{info:e,symbol:a,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:o,datetime:this.iso8601(o),fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.contractPublicGetFundingRateSymbol(this.extend(i,t)),a=this.safeValue(r,"data",{});return this.parseFundingRate(a,s)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==s&&(o.page_size=s);const n=await this.contractPublicGetFundingRateHistory(this.extend(o,i)),d=this.safeValue(n,"data"),h=this.safeValue(d,"resultList",[]),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeInteger(t,"settleTime");c.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:r,datetime:this.iso8601(r)})}const l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,a.symbol,t,s)}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,"swap",!0,!0);const s=await this.contractPublicGetDetail(t),i=this.safeList(s,"data");return this.parseLeverageTiers(i,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){let s=this.safeString(e,"maintenanceMarginRate"),i=this.safeString(e,"initialMarginRate");const r=this.safeString(e,"maxVol"),a=this.safeString(e,"riskIncrVol"),n=this.safeString(e,"riskIncrMmr"),d=this.safeString(e,"riskIncrImr");let h="0";const c=[],l=this.safeString(e,"quoteCoin");if("0"===a)return[{tier:0,currency:this.safeCurrencyCode(l),minNotional:void 0,maxNotional:void 0,maintenanceMarginRate:void 0,maxLeverage:this.safeNumber(e,"maxLeverage"),info:e}];for(;o.Y.stringLt(h,r);){const t=o.Y.stringAdd(h,a);c.push({tier:this.parseNumber(o.Y.stringDiv(t,a)),currency:this.safeCurrencyCode(l),minNotional:this.parseNumber(h),maxNotional:this.parseNumber(t),maintenanceMarginRate:this.parseNumber(s),maxLeverage:this.parseNumber(o.Y.stringDiv("1",i)),info:e}),i=o.Y.stringAdd(i,d),s=o.Y.stringAdd(s,n),h=t}return c}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"coin"),r=this.safeString(e,"network");return this.checkAddress(s),{currency:this.safeCurrencyCode(i,t),address:s,tag:this.safeString(e,"memo"),network:this.networkIdToCode(r),info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s={coin:this.currency(e).id},i=this.safeString(t,"network");let r;void 0!==i&&(r=this.networkCodeToId(i,e)),void 0!==r&&(s.network=r),t=this.omit(t,"network");const a=await this.spotPrivateGetCapitalDepositAddress(this.extend(s,t)),o=this.parseDepositAddresses(a,void 0,!1);return this.indexBy(o,"network")}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={coin:s.id},a=this.safeString(t,"network");if(void 0===a)throw new r.ArgumentsRequired(this.id+" createDepositAddress requires a `network` parameter");const o=this.networkCodeToId(a,e);void 0!==o&&(i.network=o),t=this.omit(t,"network");const n=await this.spotPrivatePostCapitalDepositAddress(this.extend(i,t));return this.parseDepositAddress(n,s)}async fetchDepositAddress(e,t={}){const s=this.safeString(t,"network");t=this.omit(t,["network"]);const i=await this.fetchDepositAddressesByNetwork(e,t);let a;if(void 0!==s)a=this.safeDict(i,this.networkIdToCode(s,e));else{const t=this.safeDict(this.options,"defaultNetworks"),s=this.safeString(t,e);if(void 0!==s)a=this.safeDict(i,s);else{const e=Object.keys(i),t=this.safeString(e,0);a=this.safeDict(i,t)}}if(void 0===a)throw new r.InvalidAddress(this.id+" fetchDepositAddress() cannot find a deposit address for "+e+", and network"+s+"consider creating one using .createDepositAddress() method or in MEXC website");return a}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e){o=this.currency(e),a.coin=o.id;const t=this.safeString(i,"network");void 0!==t&&(i=this.omit(i,"network"),a.coin+="-"+t)}if(void 0!==t&&(a.startTime=t),void 0!==s){if(s>1e3)throw new r.ExchangeError("This exchange supports a maximum limit of 1000");a.limit=s}const n=await this.spotPrivateGetCapitalDepositHisrec(this.extend(a,i));return this.parseTransactions(n,o,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e&&(o=this.currency(e),a.coin=o.id),void 0!==t&&(a.startTime=t),void 0!==s){if(s>1e3)throw new r.ExchangeError("This exchange supports a maximum limit of 1000");a.limit=s}const n=await this.spotPrivateGetCapitalWithdrawHistory(this.extend(a,i));return this.parseTransactions(n,o,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=void 0===s?"deposit":"withdrawal",r=this.safeInteger2(e,"insertTime","applyTime");let a;const n=this.safeString(e,"coin");let d;void 0!==n&&(a=n.split("-")[0]);const h=this.safeString(e,"network");void 0!==h&&(d=this.networkIdToCode(h));const c=this.safeCurrencyCode(a,t),l=this.parseTransactionStatusByType(this.safeString(e,"status"),i);let u=this.safeString(e,"amount");const p=this.safeString(e,"address"),f=this.safeString(e,"txId");let m;const g=this.safeString(e,"transactionFee");return void 0!==g&&(m={cost:this.parseNumber(g),currency:c}),"withdrawal"===i&&(u=o.Y.stringSub(u,g)),{info:e,id:s,txid:f,timestamp:r,datetime:this.iso8601(r),network:d,address:p,addressTo:p,addressFrom:void 0,tag:this.safeString(e,"memo"),tagTo:void 0,tagFrom:void 0,type:i,amount:this.parseNumber(u),currency:c,status:l,updated:void 0,comment:void 0,internal:void 0,fee:m}}parseTransactionStatusByType(e,t=void 0){const s=this.safeValue({deposit:{1:"failed",2:"pending",3:"pending",4:"pending",5:"ok",6:"pending",7:"failed"},withdrawal:{1:"pending",2:"pending",3:"pending",4:"pending",5:"pending",6:"pending",7:"ok",8:"failed",9:"canceled",10:"pending"}},t,{});return this.safeString(s,e,e)}async fetchPosition(e,t={}){await this.loadMarkets();const s={symbol:this.market(e).id},i=await this.fetchPositions(void 0,this.extend(s,t));return this.safeValue(i,0)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.contractPrivateGetPositionOpenPositions(t),i=this.safeList(s,"data",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=(t=this.safeMarket(this.safeString(e,"symbol"),t)).symbol,i=this.safeString(e,"holdVol"),r=this.safeNumber(e,"openAvgPrice"),a=this.safeString(e,"im"),o="1"===this.safeString(e,"positionType")?"long":"short",n="1"===this.safeString(e,"margin_mode")?"isolated":"cross",d=this.safeNumber(e,"leverage"),h=this.safeNumber(e,"liquidatePrice"),c=this.safeInteger(e,"updateTime");return this.safePosition({info:e,id:void 0,symbol:s,contracts:this.parseNumber(i),contractSize:void 0,entryPrice:r,collateral:void 0,side:o,unrealizedProfit:void 0,leverage:this.parseNumber(d),percentage:void 0,marginMode:n,notional:void 0,markPrice:void 0,lastPrice:void 0,liquidationPrice:h,initialMargin:this.parseNumber(a),initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,marginRatio:void 0,timestamp:c,datetime:this.iso8601(c),hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0,lastUpdateTimestamp:void 0})}async fetchTransfer(e,t=void 0,s={}){const[i,a]=this.handleMarketTypeAndParams("fetchTransfer",void 0,s);if(await this.loadMarkets(),"spot"===i){const t={transact_id:e},s=await this.spot2PrivateGetAssetInternalTransferInfo(this.extend(t,a)),i=this.safeDict(s,"data",{});return this.parseTransfer(i)}if("swap"===i)throw new r.BadRequest(this.id+" fetchTransfer() is not supported for "+i)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const[a,o]=this.handleMarketTypeAndParams("fetchTransfers",void 0,i);await this.loadMarkets();const n={};let d,h;if(void 0!==e&&(d=this.currency(e),n.currency=d.id),"spot"===a){if(void 0!==t&&(n.start_time=t),void 0!==s){if(s>50)throw new r.ExchangeError("This exchange supports a maximum limit of 50");n["page-size"]=s}const e=await this.spot2PrivateGetAssetInternalTransferRecord(this.extend(n,o)),i=this.safeValue(e,"data",{});h=this.safeValue(i,"result_list",[])}else if("swap"===a){void 0!==s&&(n.page_size=s);const e=await this.contractPrivateGetAccountTransferRecord(this.extend(n,o)),t=this.safeValue(e,"data");h=this.safeValue(t,"resultList")}return this.parseTransfers(h,d,t,s)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e),n={spot:"SPOT",swap:"FUTURES",margin:"ISOLATED_MARGIN"},d=this.safeString(n,s),h=this.safeString(n,i);if(void 0===d){const e=Object.keys(n);throw new r.ExchangeError(this.id+" fromAccount must be one of "+e.join(", "))}if(void 0===h){const e=Object.keys(n);throw new r.ExchangeError(this.id+" toAccount must be one of "+e.join(", "))}const c={asset:o.id,amount:t,fromAccountType:d,toAccountType:h};if("ISOLATED_MARGIN"===d||"ISOLATED_MARGIN"===h){const e=this.safeString(a,"symbol");if(a=this.omit(a,"symbol"),void 0===e)throw new r.ArgumentsRequired(this.id+" transfer() requires a symbol argument for isolated margin");const t=this.market(e);c.symbol=t.id}const l=await this.spotPrivatePostCapitalTransfer(this.extend(c,a)),u=this.parseTransfer(l,o);return this.extend(u,{amount:t,fromAccount:s,toAccount:i})}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeStringN(e,["transact_id","txid","tranId"]),r=this.safeInteger(e,"createTime"),a=void 0!==r?this.iso8601(r):void 0,o=this.safeString(e,"type");let n,d;return void 0!==o?(n="IN"===o?"MAIN":"CONTRACT",d="IN"===o?"CONTRACT":"MAIN"):(n=this.safeString(e,"from"),d=this.safeString(e,"to")),{info:e,id:i,timestamp:r,datetime:a,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:this.parseAccountId(n),toAccount:this.parseAccountId(d),status:this.parseTransferStatus(this.safeString2(e,"transact_state","state"))}}parseAccountId(e){return this.safeString({MAIN:"spot",CONTRACT:"swap"},e,e)}parseTransferStatus(e){return this.safeString({SUCCESS:"ok",FAILED:"failed",WAIT:"pending"},e,e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r);const a=this.safeDict(this.options,"networks",{});let o=this.safeString2(r,"network","netWork");o=this.safeString(a,o,o),o=this.networkIdToCode(o),this.checkAddress(s),await this.loadMarkets();const n=this.currency(e),d={coin:n.id,address:s,amount:t};void 0!==i&&(d.memo=i),void 0!==o&&(d.netWork=o,r=this.omit(r,["network","netWork"]));const h=await this.spotPrivatePostCapitalWithdraw(this.extend(d,r));return this.parseTransaction(h,n)}async setPositionMode(e,t=void 0,s={}){const i={positionMode:e?1:2};return await this.contractPrivatePostPositionChangePositionMode(this.extend(i,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.contractPrivateGetPositionPositionMode(t);return{info:s,hedged:1===this.safeInteger(s,"data")}}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseTransactionFees(s,e)}parseTransactionFees(e,t=void 0){const s={};for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"coin"),o=this.safeCurrency(a),n=this.safeString(o,"code");(void 0===t||this.inArray(n,t))&&(s[n]=this.parseTransactionFee(r,o))}return{withdraw:s,deposit:{},info:e}}parseTransactionFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"network"),a=this.safeString(this.options.networks,r,r),o=this.safeNumber(t,"withdrawFee");i[a]=o}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.spotPrivateGetCapitalConfigGetall(t);return this.parseDepositWithdrawFees(s,e,"coin")}parseDepositWithdrawFee(e,t=void 0){const s=this.safeValue(e,"networkList",[]),i=this.depositWithdrawFee(e);for(let e=0;e<s.length;e++){const r=s[e],a=this.safeString(r,"network"),o=this.networkIdToCode(a,this.safeString(t,"code"));i.networks[o]={withdraw:{fee:this.safeNumber(r,"withdrawFee"),percentage:void 0},deposit:{fee:void 0,percentage:void 0}}}return this.assignDefaultDepositWithdrawFees(i)}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.contractPrivateGetPositionLeverage(this.extend(i,t)),a=this.safeList(r,"data",[]);return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){let s,i,r;for(let t=0;t<e.length;t++){const a=e[t],o=this.safeInteger(a,"openType"),n=this.safeInteger(a,"positionType");1===n?i=this.safeInteger(a,"leverage"):2===n&&(r=this.safeInteger(a,"leverage")),s=1===o?"isolated":"cross"}return{info:e,symbol:t.symbol,marginMode:s,longLeverage:i,shortLeverage:r}}handleMarginModeAndParams(e,t={},s=void 0){const i=this.safeString(this.options,"defaultType"),r=this.safeBool(t,"margin",!1);let a;return[a,t]=super.handleMarginModeAndParams(e,t,s),"margin"!==i&&!0!==r||(a="isolated"),[a,t]}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};if(void 0!==e){if(1===e.length){const t=this.market(e[0]);r.symbol=t.id}}void 0!==s&&(r.page_size=s);const a=await this.contractPrivateGetPositionListHistoryPositions(this.extend(r,i)),o=this.safeList(a,"data"),n=this.parsePositions(o,e,i);return this.filterBySinceLimit(n,t,s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeString(t,0),d=this.safeString(t,1);let h;if([e,i]=this.resolvePath(e,i),"spot"===o||"broker"===o){h="broker"===o?this.urls.api[o][d]+"/"+e:this.urls.api[o][d]+"/api/"+this.version+"/"+e;let t="";if("private"===d&&(i.timestamp=this.milliseconds(),i.recvWindow=this.safeInteger(this.options,"recvWindow",5e3)),Object.keys(i).length&&(t=this.urlencode(i),h+="?"+t),"private"===d){this.checkRequiredCredentials();h+="&signature="+this.hmac(this.encode(t),this.encode(this.secret),n.s),r={"X-MEXC-APIKEY":this.apiKey,source:this.safeString(this.options,"broker","CCXT")}}"POST"!==s&&"PUT"!==s&&"DELETE"!==s||(r["Content-Type"]="application/json")}else if("contract"===o||"spot2"===o)if(h=this.urls.api[o][d]+"/"+this.implodeParams(e,i),i=this.omit(i,this.extractParams(e)),"public"===d)Object.keys(i).length&&(h+="?"+this.urlencode(i));else{this.checkRequiredCredentials();const e=this.milliseconds().toString();let t="";r={ApiKey:this.apiKey,"Request-Time":e,"Content-Type":"application/json",source:this.safeString(this.options,"broker","CCXT")},"POST"===s?(t=this.json(i),a=t):(i=this.keysort(i),Object.keys(i).length&&(t+=this.urlencode(i),h+="?"+t)),t=this.apiKey+e+t;const o=this.hmac(this.encode(t),this.encode(this.secret),n.s);r.Signature=o}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(!0===this.safeBool(n,"success",!1))return;const c=this.safeString(n,"code",void 0);if(void 0!==c&&"200"!==c&&"0"!==c){const e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}}},4460:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(3414),r=s(2079),a=s(1579),o=s(5147),n=s(4852),d=s(8995);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"ndax",name:"NDAX",countries:["CA"],rateLimit:1e3,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2419200","4M":"9676800"},urls:{logo:"https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",test:{public:"https://ndaxmarginstaging.cdnhop.net:8443/AP",private:"https://ndaxmarginstaging.cdnhop.net:8443/AP"},api:{public:"https://api.ndax.io:8443/AP",private:"https://api.ndax.io:8443/AP"},www:"https://ndax.io",doc:["https://apidoc.ndax.io/"],fees:"https://ndax.io/fees",referral:"https://one.ndax.io/bfQiSL"},api:{public:{get:{Activate2FA:1,Authenticate2FA:1,AuthenticateUser:1,GetL2Snapshot:1,GetLevel1:1,GetValidate2FARequiredEndpoints:1,LogOut:1,GetTickerHistory:1,GetProduct:1,GetProducts:1,GetInstrument:1,GetInstruments:1,Ping:1,trades:1,GetLastTrades:1,SubscribeLevel1:1,SubscribeLevel2:1,SubscribeTicker:1,SubscribeTrades:1,SubscribeBlockTrades:1,UnsubscribeBlockTrades:1,UnsubscribeLevel1:1,UnsubscribeLevel2:1,UnsubscribeTicker:1,UnsubscribeTrades:1,Authenticate:1}},private:{get:{GetUserAccountInfos:1,GetUserAccounts:1,GetUserAffiliateCount:1,GetUserAffiliateTag:1,GetUserConfig:1,GetAllUnredactedUserConfigsForUser:1,GetUnredactedUserConfigByKey:1,GetUserDevices:1,GetUserReportTickets:1,GetUserReportWriterResultRecords:1,GetAccountInfo:1,GetAccountPositions:1,GetAllAccountConfigs:1,GetTreasuryProductsForAccount:1,GetAccountTrades:1,GetAccountTransactions:1,GetOpenTradeReports:1,GetAllOpenTradeReports:1,GetTradesHistory:1,GetOpenOrders:1,GetOpenQuotes:1,GetOrderFee:1,GetOrderHistory:1,GetOrdersHistory:1,GetOrderStatus:1,GetOmsFeeTiers:1,GetAccountDepositTransactions:1,GetAccountWithdrawTransactions:1,GetAllDepositRequestInfoTemplates:1,GetDepositInfo:1,GetDepositRequestInfoTemplate:1,GetDeposits:1,GetDepositTicket:1,GetDepositTickets:1,GetOMSWithdrawFees:1,GetWithdrawFee:1,GetWithdraws:1,GetWithdrawTemplate:1,GetWithdrawTemplateTypes:1,GetWithdrawTicket:1,GetWithdrawTickets:1},post:{AddUserAffiliateTag:1,CancelUserReport:1,RegisterNewDevice:1,SubscribeAccountEvents:1,UpdateUserAffiliateTag:1,GenerateTradeActivityReport:1,GenerateTransactionActivityReport:1,GenerateTreasuryActivityReport:1,ScheduleTradeActivityReport:1,ScheduleTransactionActivityReport:1,ScheduleTreasuryActivityReport:1,CancelAllOrders:1,CancelOrder:1,CancelQuote:1,CancelReplaceOrder:1,CreateQuote:1,ModifyOrder:1,SendOrder:1,SubmitBlockTrade:1,UpdateQuote:1,CancelWithdraw:1,CreateDepositTicket:1,CreateWithdrawTicket:1,SubmitDepositTicketComment:1,SubmitWithdrawTicketComment:1,GetOrderHistoryByOrderId:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0,login:!0,password:!0},precisionMode:a.kb,exceptions:{exact:{Not_Enough_Funds:r.InsufficientFunds,"Server Error":r.ExchangeError,"Resource Not Found":r.OrderNotFound},broad:{"Invalid InstrumentId":r.BadSymbol,"This endpoint requires 2FACode along with the payload":r.AuthenticationError}},options:{omsId:1,orderTypes:{Market:1,Limit:2,StopMarket:3,StopLimit:4,TrailingStopMarket:5,TrailingStopLimit:6,BlockTrade:7,1:1,2:2,3:3,4:4,5:5,6:6,7:7}}})}async signIn(e={}){if(this.checkRequiredCredentials(),void 0===this.login||void 0===this.password)throw new r.AuthenticationError(this.id+" signIn() requires exchange.login, exchange.password");let t={grant_type:"client_credentials"};const s=await this.publicGetAuthenticate(this.extend(t,e));let i=this.safeString(s,"SessionToken");if(void 0!==i)return this.options.sessionToken=i,s;const a=this.safeString(s,"Pending2FaToken");if(void 0!==a){if(void 0===this.twofa)throw new r.AuthenticationError(this.id+" signIn() requires exchange.twofa credentials");this.options.pending2faToken=a,t={Code:(0,d.O)(this.twofa)};const s=await this.publicGetAuthenticate2FA(this.extend(t,e));return i=this.safeString(s,"SessionToken"),this.options.sessionToken=i,s}return s}async fetchCurrencies(e={}){const t={omsId:this.safeInteger(this.options,"omsId",1)},s=await this.publicGetGetProducts(this.extend(t,e)),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"ProductId"),a=this.safeString(t,"ProductFullName"),o=this.safeString(t,"ProductType");let n="NationalCurrency"===o?"fiat":"crypto";"Unknown"===o&&(n="other");const d=this.safeCurrencyCode(this.safeString(t,"Product")),h=!this.safeValue(t,"IsDisabled");i[d]={id:r,name:a,code:d,type:n,precision:this.safeNumber(t,"TickSize"),info:t,active:h,deposit:void 0,withdraw:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}return i}async fetchMarkets(e={}){const t={omsId:this.safeInteger(this.options,"omsId",1)},s=await this.publicGetGetInstruments(this.extend(t,e));return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"InstrumentId"),s=this.safeString(e,"Product1"),i=this.safeString(e,"Product2"),r=this.safeCurrencyCode(this.safeString(e,"Product1Symbol")),a=this.safeCurrencyCode(this.safeString(e,"Product2Symbol")),o=this.safeString(e,"SessionStatus"),n=this.safeValue(e,"IsDisable");return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"Running"===o&&!n,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"QuantityIncrement"),price:this.safeNumber(e,"PriceIncrement")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"MinimumQuantity"),max:void 0},price:{min:this.safeNumber(e,"MinimumPrice"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}parseOrderBook(e,t,s=void 0,i="bids",r="asks",a=6,o=8,n=2){let d;const h={symbol:t,bids:[],asks:[],timestamp:void 0,datetime:void 0,nonce:void 0};for(let t=0;t<e.length;t++){const n=e[t];if(void 0===s)s=this.safeInteger(n,2);else{const e=this.safeInteger(n,2);s=Math.max(s,e)}if(void 0===d)d=this.safeInteger(n,0);else{const e=this.safeInteger(n,0);d=Math.max(d,e)}const c=this.parseBidAsk(n,a,o);h[this.safeInteger(n,9)?r:i].push(c)}return h.bids=this.sortBy(h.bids,0,!0),h.asks=this.sortBy(h.asks,0),h.timestamp=s,h.datetime=this.iso8601(s),h.nonce=d,h}async fetchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();t=void 0===t?100:t;const r={omsId:i,InstrumentId:this.market(e).id,Depth:t},a=await this.publicGetGetL2Snapshot(this.extend(r,s));return this.parseOrderBook(a,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"TimeStamp"),i=this.safeString(e,"InstrumentId");t=this.safeMarket(i,t);const r=this.safeSymbol(i,t),a=this.safeString(e,"LastTradedPx"),o=this.safeString(e,"Rolling24HrPxChangePercent"),n=this.safeString(e,"Rolling24HrPxChange"),d=this.safeString(e,"SessionOpen"),h=this.safeString(e,"Rolling24HrVolume"),c=this.safeString(e,"Rolling24HrNotional");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"SessionHigh"),low:this.safeString(e,"SessionLow"),bid:this.safeString(e,"BestBid"),bidVolume:void 0,ask:this.safeString(e,"BestOffer"),askVolume:void 0,vwap:void 0,open:d,close:a,last:a,previousClose:void 0,change:n,percentage:o,average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),r={omsId:s,InstrumentId:i.id},a=await this.publicGetGetLevel1(this.extend(r,t));return this.parseTicker(a,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,3),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const o=this.market(e),n={omsId:a,InstrumentId:o.id,Interval:this.safeString(this.timeframes,t,t)},d=this.parseTimeframe(t),h=this.milliseconds();void 0===s?void 0!==i&&(n.FromDate=this.ymdhms(h-d*i*1e3),n.ToDate=this.ymdhms(h)):(n.FromDate=this.ymdhms(s),n.ToDate=void 0===i?this.ymdhms(h):this.ymdhms(this.sum(s,d*i*1e3)));const c=await this.publicGetGetTickerHistory(this.extend(n,r));return this.parseOHLCVs(c,o,t,s,i)}parseTrade(e,t=void 0){let s,i,r,a,o,n,d,h,c,l,u;if(Array.isArray(e)){s=this.safeString(e,3),i=this.safeString(e,2),a=this.safeInteger(e,6),o=this.safeString(e,0),n=this.safeString(e,1);d=this.safeValue(e,8)?"sell":"buy",h=this.safeString(e,4)}else{a=this.safeInteger2(e,"TradeTimeMS","ReceiveTime"),o=this.safeString(e,"TradeId"),h=this.safeString2(e,"OrderId","OrigOrderId"),n=this.safeString2(e,"InstrumentId","Instrument"),s=this.safeString(e,"Price"),i=this.safeString(e,"Quantity"),r=this.safeString2(e,"Value","GrossValueExecuted"),c=this.safeStringLower(e,"MakerTaker"),d=this.safeStringLower(e,"Side"),u=this.safeStringLower(e,"OrderType");const t=this.safeString(e,"Fee");if(void 0!==t){const s=this.safeString(e,"FeeProductId");l={cost:t,currency:this.safeCurrencyCode(s)}}}const p=this.safeSymbol(n,t);return this.safeTrade({info:e,id:o,symbol:p,timestamp:a,datetime:this.iso8601(a),order:h,type:u,side:d,takerOrMaker:c,price:s,amount:i,cost:r,fee:l},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e),o={omsId:r,InstrumentId:a.id};void 0!==s&&(o.Count=s);const n=await this.publicGetGetLastTrades(this.extend(o,i));return this.parseTrades(n,a,t,s)}async fetchAccounts(e={}){if(!this.login)throw new r.AuthenticationError(this.id+" fetchAccounts() requires exchange.login email credential");const t=this.safeInteger(this.options,"omsId",1);this.checkRequiredCredentials();const s={omsId:t,UserId:this.uid,UserName:this.login},i=await this.privateGetGetUserAccounts(this.extend(s,e)),a=[];for(let e=0;e<i.length;e++){const t=this.safeString(i,e);a.push({id:t,type:void 0,currency:void 0,info:t})}return a}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"ProductId");if(r in this.currencies_by_id){const e=this.safeCurrencyCode(r),s=this.account();s.total=this.safeString(i,"Amount"),s.used=this.safeString(i,"Hold"),t[e]=s}}return this.safeBalance(t)}async fetchBalance(e={}){const t=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const s=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),i=this.safeInteger2(e,"accountId","AccountId",s);e=this.omit(e,["accountId","AccountId"]);const r={omsId:t,AccountId:i},a=await this.privateGetGetAccountPositions(this.extend(r,e));return this.parseBalance(a)}parseLedgerEntryType(e){return this.safeString({Trade:"trade",Deposit:"transaction",Withdraw:"transaction",Transfer:"transfer",OrderHold:"trade",WithdrawHold:"transaction",DepositHold:"transaction",MarginHold:"trade",ManualHold:"trade",ManualEntry:"trade",MarginAcquisition:"trade",MarginRelinquish:"trade",MarginQuoteHold:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"ProductId"),i=this.safeString(e,"CR"),r=this.safeString(e,"DR");let a,n,d;o.Y.stringLt(i,"0")?(a=i,n="in"):o.Y.stringLt(r,"0")&&(a=r,n="out");const h=this.safeString(e,"Balance");"out"===n?d=o.Y.stringAdd(h,a):"in"===n&&(d=o.Y.stringMax("0",o.Y.stringSub(h,a)));const c=this.safeInteger(e,"TimeStamp");return{info:e,id:this.safeString(e,"TransactionId"),direction:n,account:this.safeString(e,"AccountId"),referenceId:this.safeString(e,"ReferenceId"),referenceAccount:this.safeString(e,"Counterparty"),type:this.parseLedgerEntryType(this.safeString(e,"ReferenceType")),currency:this.safeCurrencyCode(s,t),amount:this.parseNumber(a),before:this.parseNumber(d),after:this.parseNumber(h),status:"ok",timestamp:c,datetime:this.iso8601(c),fee:void 0}}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);i=this.omit(i,["accountId","AccountId"]);const n={omsId:r,AccountId:o};void 0!==s&&(n.Depth=s);const d=await this.privateGetGetAccountTransactions(this.extend(n,i));let h;return void 0!==e&&(h=this.currency(e)),this.parseLedger(d,h,t,s)}parseOrderStatus(e){return this.safeString({Accepted:"open",Rejected:"rejected",Working:"open",Canceled:"canceled",Expired:"expired",FullyExecuted:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"ReceiveTime"),i=this.safeString(e,"Instrument");return this.safeOrder({id:this.safeString2(e,"ReplacementOrderId","OrderId"),clientOrderId:this.safeString2(e,"ReplacementClOrdId","ClientOrderId"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"LastUpdatedTime"),status:this.parseOrderStatus(this.safeString(e,"OrderState")),symbol:this.safeSymbol(i,t),type:this.safeStringLower(e,"OrderType"),timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"Side"),price:this.safeString(e,"Price"),stopPrice:this.parseNumber(this.omitZero(this.safeString(e,"StopPrice"))),cost:this.safeString(e,"GrossValueExecuted"),amount:this.safeString(e,"OrigQuantity"),filled:this.safeString(e,"QuantityExecuted"),average:this.safeString(e,"AvgPrice"),remaining:void 0,fee:void 0,trades:void 0},t)}async createOrder(e,t,s,i,r=void 0,a={}){const o=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const n=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),d=this.safeInteger2(a,"accountId","AccountId",n),h=this.safeInteger2(a,"ClientOrderId","clientOrderId");let c=this.safeInteger(this.options.orderTypes,this.capitalize(t));const l=this.safeString(a,"triggerPrice");void 0!==l&&("market"===t?c=3:"limit"===t&&(c=4)),a=this.omit(a,["accountId","AccountId","clientOrderId","ClientOrderId","triggerPrice"]);const u=this.market(e),p="buy"===s?0:1,f={InstrumentId:parseInt(u.id),omsId:o,AccountId:d,TimeInForce:1,Side:p,Quantity:parseFloat(this.amountToPrecision(e,i)),OrderType:c};void 0!==r&&(f.LimitPrice=parseFloat(this.priceToPrecision(e,r))),void 0!==h&&(f.ClientOrderId=h),void 0!==l&&(f.StopPrice=l);const m=await this.privatePostSendOrder(this.extend(f,a));return this.parseOrder(m,u)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){const n=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const d=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),h=this.safeInteger2(o,"accountId","AccountId",d),c=this.safeInteger2(o,"ClientOrderId","clientOrderId");o=this.omit(o,["accountId","AccountId","clientOrderId","ClientOrderId"]);const l=this.market(t),u="buy"===i?0:1,p={OrderIdToReplace:parseInt(e),InstrumentId:parseInt(l.id),omsId:n,AccountId:h,TimeInForce:1,Side:u,Quantity:parseFloat(this.amountToPrecision(t,r)),OrderType:this.safeInteger(this.options.orderTypes,this.capitalize(s))};void 0!==a&&(p.LimitPrice=parseFloat(this.priceToPrecision(t,a))),void 0!==c&&(p.ClientOrderId=c);const f=await this.privatePostCancelReplaceOrder(this.extend(p,o));return this.parseOrder(f,l)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);i=this.omit(i,["accountId","AccountId"]);const n={omsId:r,AccountId:o};let d;void 0!==e&&(d=this.market(e),n.InstrumentId=d.id),void 0!==t&&(n.StartTimeStamp=this.parseToInt(t/1e3)),void 0!==s&&(n.Depth=s);const h=await this.privateGetGetTradesHistory(this.extend(n,i));return this.parseTrades(h,d,t,s)}async cancelAllOrders(e=void 0,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),r=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const a={omsId:s,AccountId:r};if(void 0!==e){const t=this.market(e);a.IntrumentId=t.id}const o=await this.privatePostCancelAllOrders(this.extend(a,t));return[this.safeOrder({info:o})]}async cancelOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);let r;await this.loadMarkets(),await this.loadAccounts(),void 0!==t&&(r=this.market(t));const a={omsId:i},o=this.safeInteger2(s,"clientOrderId","ClOrderId");void 0!==o?a.ClOrderId=o:a.OrderId=parseInt(e),s=this.omit(s,["clientOrderId","ClOrderId"]);const n=await this.privatePostCancelOrder(this.extend(a,s)),d=this.parseOrder(n,r);return this.extend(d,{id:e,clientOrderId:o})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);let n;i=this.omit(i,["accountId","AccountId"]),void 0!==e&&(n=this.market(e));const d={omsId:r,AccountId:o},h=await this.privateGetGetOpenOrders(this.extend(d,i));return this.parseOrders(h,n,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);i=this.omit(i,["accountId","AccountId"]);const n={omsId:r,AccountId:o};let d;void 0!==e&&(d=this.market(e),n.InstrumentId=d.id),void 0!==t&&(n.StartTimeStamp=this.parseToInt(t/1e3)),void 0!==s&&(n.Depth=s);const h=await this.privateGetGetOrdersHistory(this.extend(n,i));return this.parseOrders(h,d,t,s)}async fetchOrder(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const r=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),a=this.safeInteger2(s,"accountId","AccountId",r);let o;s=this.omit(s,["accountId","AccountId"]),void 0!==t&&(o=this.market(t));const n={omsId:i,AccountId:a,OrderId:parseInt(e)},d=await this.privateGetGetOrderStatus(this.extend(n,s));return this.parseOrder(d,o)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);let o;await this.loadMarkets(),await this.loadAccounts(),void 0!==t&&(o=this.market(t));const n={OMSId:this.parseToInt(a),OrderId:parseInt(e)},d=await this.privatePostGetOrderHistoryByOrderId(this.extend(n,r)),h=this.groupBy(d,"ChangeReason"),c=this.safeList(h,"Trade",[]);return this.parseTrades(c,o,s,i)}async fetchDepositAddress(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const i=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),r=this.safeInteger2(t,"accountId","AccountId",i);t=this.omit(t,["accountId","AccountId"]);const a=this.currency(e),o={omsId:s,AccountId:r,ProductId:a.id,GenerateNewKey:!1},n=await this.privateGetGetDepositInfo(this.extend(o,t));return this.parseDepositAddress(n,a)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"DepositInfo"),i=JSON.parse(s),r=i.length,a=this.safeString(i,r-1).split("?memo="),o=this.safeString(a,0),n=this.safeString(a,1);let d;return void 0!==t&&(d=t.code),this.checkAddress(o),{currency:d,address:o,tag:n,network:void 0,info:e}}async createDepositAddress(e,t={}){return await this.fetchDepositAddress(e,this.extend({GenerateNewKey:!0},t))}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);let n;i=this.omit(i,["accountId","AccountId"]),void 0!==e&&(n=this.currency(e));const d={omsId:r,AccountId:o},h=await this.privateGetGetDeposits(this.extend(d,i));return"string"==typeof h?this.parseTransactions(JSON.parse(h),n,t,s):this.parseTransactions(h,n,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const a=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),o=this.safeInteger2(i,"accountId","AccountId",a);let n;i=this.omit(i,["accountId","AccountId"]),void 0!==e&&(n=this.currency(e));const d={omsId:r,AccountId:o},h=await this.privateGetGetWithdraws(this.extend(d,i));return this.parseTransactions(h,n,t,s)}parseTransactionStatusByType(e,t=void 0){const s=this.safeValue({deposit:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Confirmed:"pending",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected"},withdrawal:{New:"pending",AdminProcessing:"pending",Accepted:"pending",Rejected:"rejected",SystemProcessing:"pending",FullyProcessed:"ok",Failed:"failed",Pending:"pending",Pending2Fa:"pending",AutoAccepted:"pending",Delayed:"pending",UserCanceled:"canceled",AdminCanceled:"canceled",AmlProcessing:"pending",AmlAccepted:"pending",AmlRejected:"rejected",AmlFailed:"failed",LimitsAccepted:"pending",LimitsRejected:"rejected",Submitted:"pending",Confirmed:"pending",ManuallyConfirmed:"pending",Confirmed2Fa:"pending"}},t,{});return this.safeString(s,e,e)}parseTransaction(e,t=void 0){let s;const i=this.safeString(e,"ProductId"),r=this.safeCurrencyCode(i,t);let a;"DepositId"in e?(s=this.safeString(e,"DepositId"),a="deposit"):"WithdrawId"in e&&(s=this.safeString(e,"WithdrawId"),a="withdrawal");const o=this.parseJson(this.safeValue2(e,"TemplateForm","DepositInfo"));let n=this.safeInteger(e,"LastUpdateTimeStamp");void 0!==o&&(n=this.safeInteger(o,"LastUpdated",n));const d=this.safeString2(o,"ExternalAddress","ToAddress"),h=this.safeInteger(o,"TimeSubmitted"),c=this.safeNumber(e,"FeeAmount"),l=this.safeString(e,"TicketStatus");let u;return void 0!==c&&(u={currency:r,cost:c}),{info:e,id:s,txid:this.safeString2(o,"TxId","TXId"),timestamp:h,datetime:this.iso8601(h),address:d,addressTo:d,addressFrom:this.safeString(o,"FromAddress"),tag:void 0,tagTo:void 0,tagFrom:void 0,type:a,amount:this.safeNumber(e,"Amount"),currency:r,status:this.parseTransactionStatusByType(l,a),updated:n,fee:u,internal:void 0,comment:void 0,network:void 0}}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a);if(void 0===this.safeString(this.options,"sessionToken"))throw new r.AuthenticationError(this.id+" call signIn() method to obtain a session token");if(void 0===this.twofa)throw new r.AuthenticationError(this.id+" withdraw() requires exchange.twofa credentials");this.checkAddress(s);const o=this.safeInteger(this.options,"omsId",1);await this.loadMarkets(),await this.loadAccounts();const n=this.safeInteger2(this.options,"accountId","AccountId",parseInt(this.accounts[0].id)),h=this.safeInteger2(a,"accountId","AccountId",n);a=this.omit(a,["accountId","AccountId"]);const c=this.currency(e),l={omsId:o,AccountId:h,ProductId:c.id},u=await this.privateGetGetWithdrawTemplateTypes(l),p=this.safeValue(u,"TemplateTypes",[]),f=this.safeValue(p,0);if(void 0===f)throw new r.ExchangeError(this.id+" withdraw() could not find a withdraw template type for "+c.code);const m=this.safeString(f,"TemplateName"),g={omsId:o,AccountId:h,ProductId:c.id,TemplateType:m,AccountProviderId:f.AccountProviderId},v=await this.privateGetGetWithdrawTemplate(g),y=this.safeString(v,"Template");if(void 0===y)throw new r.ExchangeError(this.id+" withdraw() could not find a withdraw template for "+c.code);const w=JSON.parse(y);w.ExternalAddress=s,void 0!==i&&"Memo"in w&&(w.Memo=i);const b={omsId:o,AccountId:h,ProductId:c.id,TemplateForm:this.json(w),TemplateType:m},S={TfaType:"Google",TFaCode:(0,d.O)(this.twofa),Payload:this.json(b)},k=await this.privatePostCreateWithdrawTicket(this.deepExtend(S,a));return this.parseTransaction(k,c)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/"+this.implodeParams(e,i),d=this.omit(i,this.extractParams(e));if("public"===t){if("Authenticate"===e){const e=this.login+":"+this.password;r={Authorization:"Basic "+this.stringToBase64(e)}}else if("Authenticate2FA"===e){const e=this.safeString(this.options,"pending2faToken");void 0!==e&&(r={Pending2FaToken:e},d=this.omit(d,"pending2faToken"))}Object.keys(d).length&&(o+="?"+this.urlencode(d))}else if("private"===t){this.checkRequiredCredentials();const e=this.safeString(this.options,"sessionToken");if(void 0===e){const e=this.nonce().toString(),t=e+this.uid+this.apiKey,s=this.hmac(this.encode(t),this.encode(this.secret),n.s);r={Nonce:e,APIKey:this.apiKey,Signature:s,UserId:this.uid}}else r={APToken:e};"POST"===s?(r["Content-Type"]="application/json",a=this.json(d)):Object.keys(d).length&&(o+="?"+this.urlencode(d))}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(404===e)throw new r.AuthenticationError(this.id+" "+o);if(void 0===n)return;const c=this.safeString(n,"errormsg");if(void 0!==c&&""!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,o,e),new r.ExchangeError(e)}}}},8473:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(1426),r=s(2079),a=s(5147),o=s(1579),n=s(4852),d=s(4035);class h extends i.A{describe(){return this.deepExtend(super.describe(),{id:"novadax",name:"NovaDAX",countries:["BR"],rateLimit:10,version:"v1",has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:"emulated",fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"ONE_MIN","5m":"FIVE_MIN","15m":"FIFTEEN_MIN","30m":"HALF_HOU","1h":"ONE_HOU","1d":"ONE_DAY","1w":"ONE_WEE","1M":"ONE_MON"},urls:{logo:"https://user-images.githubusercontent.com/1294454/92337550-2b085500-f0b3-11ea-98e7-5794fb07dd3b.jpg",api:{public:"https://api.novadax.com",private:"https://api.novadax.com"},www:"https://www.novadax.com.br",doc:["https://doc.novadax.com/pt-BR/"],fees:"https://www.novadax.com.br/fees-and-limits",referral:"https://www.novadax.com.br/?s=ccxt"},api:{public:{get:{"common/symbol":1,"common/symbols":1,"common/timestamp":1,"market/tickers":5,"market/ticker":1,"market/depth":1,"market/trades":5,"market/kline/history":5}},private:{get:{"orders/get":1,"orders/list":10,"orders/fill":3,"orders/fills":10,"account/getBalance":1,"account/subs":1,"account/subs/balance":1,"account/subs/transfer/record":10,"wallet/query/deposit-withdraw":3},post:{"orders/create":5,"orders/batch-create":50,"orders/cancel":1,"orders/batch-cancel":10,"orders/cancel-by-symbol":10,"account/subs/transfer":5,"wallet/withdraw/coin":3,"account/withdraw/coin":3}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.005"),maker:this.parseNumber("0.0025")}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:o.kb,exceptions:{exact:{A99999:r.ExchangeError,A10001:r.BadRequest,A10002:r.ExchangeError,A10003:r.AuthenticationError,A10004:r.RateLimitExceeded,A10005:r.PermissionDenied,A10006:r.AccountSuspended,A10007:r.AccountNotEnabled,A10011:r.BadSymbol,A10012:r.BadSymbol,A10013:r.OnMaintenance,A30001:r.OrderNotFound,A30002:r.InvalidOrder,A30003:r.InvalidOrder,A30004:r.InvalidOrder,A30005:r.InvalidOrder,A30006:r.InvalidOrder,A30007:r.InsufficientFunds,A30008:r.InvalidOrder,A30009:r.InvalidOrder,A30010:r.CancelPending,A30011:r.InvalidOrder,A30012:r.InvalidOrder,A40004:r.InsufficientFunds},broad:{}},options:{fetchOHLCV:{volume:"amount"},transfer:{fillResponseFromRequest:!0}}})}async fetchTime(e={}){const t=await this.publicGetCommonTimestamp(e);return this.safeInteger(t,"data")}async fetchMarkets(e={}){const t=await this.publicGetCommonSymbols(e),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"baseCurrency"),s=this.safeString(e,"quoteCurrency"),i=this.safeString(e,"symbol"),r=this.safeCurrencyCode(t),a=this.safeCurrencyCode(s);return{id:i,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:t,quoteId:s,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"ONLINE"===this.safeString(e,"status"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amountPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"pricePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minOrderAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"minOrderValue"),max:void 0}},created:void 0,info:e}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t,"_"),a=this.safeString(e,"open24h"),o=this.safeString(e,"lastPrice"),n=this.safeString(e,"baseVolume24h"),d=this.safeString(e,"quoteVolume24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:a,close:o,last:o,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:d,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetMarketTicker(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(t),i=this.safeValue(s,"data",[]),r={};for(let e=0;e<i.length;e++){const t=this.parseTicker(i[e]);r[t.symbol]=t}return this.filterByArrayTickers(r,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit=t);const a=await this.publicGetMarketDepth(this.extend(r,s)),o=this.safeValue(a,"data",{}),n=this.safeInteger(o,"timestamp");return this.parseOrderBook(o,i.symbol,n,"bids","asks")}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"orderId"),r=this.safeInteger(e,"timestamp"),a=this.safeStringLower(e,"side"),o=this.safeString(e,"price"),n=this.safeString(e,"amount"),d=this.safeString(e,"symbol"),h=this.safeSymbol(d,t,"_"),c=this.safeStringLower(e,"role");let l;if(void 0!==this.safeString(e,"fee")){const t=this.safeString(e,"feeCurrency"),s=this.safeCurrencyCode(t);l={cost:this.safeString(e,"feeAmount"),currency:s}}return this.safeTrade({id:s,order:i,timestamp:r,datetime:this.iso8601(r),symbol:h,type:void 0,side:a,price:o,amount:n,cost:void 0,takerOrMaker:c,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetMarketTrades(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,unit:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t),d=this.seconds();if(void 0===i&&(i=3e3),void 0===s)o.from=d-i*n,o.to=d;else{const e=this.parseToInt(s/1e3);o.from=e,o.to=this.sum(e,i*n)}const h=await this.publicGetMarketKlineHistory(this.extend(o,r)),c=this.safeList(h,"data",[]);return this.parseOHLCVs(c,a,t,s,i)}parseOHLCV(e,t=void 0){const s=this.safeValue(this.options,"fetchOHLCV",{}),i=this.safeString(s,"volume","amount");return[this.safeTimestamp(e,"score"),this.safeNumber(e,"openPrice"),this.safeNumber(e,"highPrice"),this.safeNumber(e,"lowPrice"),this.safeNumber(e,"closePrice"),this.safeNumber(e,i)]}parseBalance(e){const t=this.safeValue(e,"data",[]),s={info:e,timestamp:void 0,datetime:void 0};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.free=this.safeString(i,"available"),o.used=this.safeString(i,"hold"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountGetBalance(e);return this.parseBalance(t)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e);let h=t.toUpperCase();const c=s.toUpperCase(),l={symbol:d.id,side:c},u=this.safeValue2(n,"triggerPrice","stopPrice");if(void 0===u){if("STOP_LIMIT"===h||"STOP_MARKET"===h)throw new r.ArgumentsRequired(this.id+" createOrder() requires a stopPrice parameter for "+h+" orders")}else{"LIMIT"===h?h="STOP_LIMIT":"MARKET"===h&&(h="STOP_MARKET");const t="BUY"===c?"LTE":"GTE";l.operator=this.safeString(n,"operator",t),l.stopPrice=this.priceToPrecision(e,u),n=this.omit(n,["triggerPrice","stopPrice"])}if("LIMIT"===h||"STOP_LIMIT"===h)l.price=this.priceToPrecision(e,o),l.amount=this.amountToPrecision(e,i);else if("MARKET"===h||"STOP_MARKET"===h)if("SELL"===c)l.amount=this.amountToPrecision(e,i);else if("BUY"===c){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber2(n,"cost","value");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);l.value=t}l.type=h;const p=await this.privatePostOrdersCreate(this.extend(l,n)),f=this.safeDict(p,"data",{});return this.parseOrder(f,d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privatePostOrdersCancel(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.privateGetOrdersGet(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==s&&(r.limit=s),void 0!==t&&(r.fromTimestamp=t);const o=await this.privateGetOrdersList(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseOrders(n,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"SUBMITTED,PROCESSING,PARTIAL_FILLED,CANCELING"},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({status:"FILLED,CANCELED,REJECTED"},i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={id:e},o=await this.privateGetOrdersFill(this.extend(a,r));let n;void 0!==t&&(n=this.market(t));const d=this.safeValue(o,"data",[]);return this.parseTrades(d,n,s,i)}parseOrderStatus(e){return this.safeString({SUBMITTED:"open",PROCESSING:"open",PARTIAL_FILLED:"open",CANCELING:"open",FILLED:"closed",CANCELED:"canceled",REJECTED:"rejected"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"amount"),r=this.safeString(e,"price"),a=this.safeString2(e,"filledValue","value"),o=this.safeStringLower(e,"type"),n=this.safeStringLower(e,"side"),d=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeInteger(e,"timestamp"),c=this.safeString(e,"averagePrice"),l=this.safeString(e,"filledAmount");let u;const p=this.safeNumber(e,"filledFee");void 0!==p&&(u={cost:p,currency:void 0});const f=this.safeString(e,"symbol"),m=this.safeSymbol(f,t,"_"),g=this.safeNumber(e,"stopPrice");return this.safeOrder({id:s,clientOrderId:void 0,info:e,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,symbol:m,type:o,timeInForce:void 0,postOnly:void 0,side:n,price:r,stopPrice:g,triggerPrice:g,amount:i,cost:a,average:c,filled:l,remaining:void 0,status:d,fee:u,trades:void 0},t)}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e);if("main"!==s&&"main"!==i)throw new r.ExchangeError(this.id+" transfer() supports transfers between main account and subaccounts only");const n="main"===s?"master-transfer-in":"master-transfer-out",d={transferAmount:this.currencyToPrecision(e,t),currency:o.id,subId:"master-transfer-in"===n?i:s,transferType:n},h=await this.privatePostAccountSubsTransfer(this.extend(d,a)),c=this.parseTransfer(h,o),l=this.safeValue(this.options,"transfer",{});return this.safeBool(l,"fillResponseFromRequest",!0)&&(c.fromAccount=s,c.toAccount=i,c.amount=t),c}parseTransfer(e,t=void 0){const s=this.safeString(e,"data"),i=this.safeString(e,"message");return{info:e,id:s,amount:void 0,currency:this.safeCurrencyCode(void 0,t),fromAccount:void 0,toAccount:void 0,timestamp:void 0,datetime:void 0,status:i}}parseTransferStatus(e){return this.safeString({SUCCESS:"pending"},e,"failed")}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o={code:a.id,amount:this.currencyToPrecision(e,t),wallet:s};void 0!==i&&(o.tag=i);const n=await this.privatePostAccountWithdrawCoin(this.extend(o,r));return this.parseTransaction(n,a)}async fetchAccounts(e={}){const t=await this.privateGetAccountSubs(e),s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"subId"),a=this.safeString(t,"subAccount");i.push({id:r,type:a,currency:void 0,info:t})}return i}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({type:"coin_in"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({type:"coin_out"},i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.size=s);const o=await this.privateGetWalletQueryDepositWithdraw(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,a,t,s)}parseTransactionStatus(e){const t=e.split(" ");e=this.safeString(t,1,e);return this.safeString({Pending:"pending",confirming:"pending",SUCCESS:"ok",FAIL:"failed"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString2(e,"id","data");let i=this.safeString(e,"type");"COIN_IN"===i?i="deposit":"COIN_OUT"===i&&(i="withdraw");const r=this.safeNumber(e,"amount"),a=this.safeString(e,"address"),o=this.safeString(e,"addressTag"),n=this.safeString(e,"txHash"),d=this.safeInteger(e,"createdAt"),h=this.safeInteger(e,"updatedAt"),c=this.safeString(e,"currency"),l=this.safeCurrencyCode(c,t),u=this.parseTransactionStatus(this.safeString(e,"state"));return{info:e,id:s,currency:l,amount:r,network:this.safeString(e,"chain"),address:a,addressTo:a,addressFrom:void 0,tag:o,tagTo:o,tagFrom:void 0,status:u,type:i,updated:h,txid:n,timestamp:d,datetime:this.iso8601(d),comment:void 0,internal:void 0,fee:{currency:void 0,cost:void 0,rate:void 0}}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==s&&(r.limit=s),void 0!==t&&(r.fromTimestamp=t);const o=await this.privateGetOrdersFills(this.extend(r,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,a,t,s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o="/"+this.version+"/"+this.implodeParams(e,i);let h=this.urls.api[t]+o;const c=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(c).length&&(h+="?"+this.urlencode(c));else if("private"===t){this.checkRequiredCredentials();const e=this.milliseconds().toString();let t;r={"X-Nova-Access-Key":this.apiKey,"X-Nova-Timestamp":e},"POST"===s?(a=this.json(c),t=this.hash(this.encode(a),d.F),r["Content-Type"]="application/json"):(Object.keys(c).length&&(h+="?"+this.urlencode(c)),t=this.urlencode(this.keysort(c)));const i=s+"\n"+o+"\n"+t+"\n"+e;r["X-Nova-Signature"]=this.hmac(this.encode(i),this.encode(this.secret),n.s)}return{url:h,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code");if("A10000"!==c){const e=this.safeString(n,"message"),t=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,t),this.throwBroadlyMatchedException(this.exceptions.broad,e,t),new r.ExchangeError(t)}}}},3805:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7774),r=s(2079),a=s(1579),o=s(4852),n=s(5354);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"oceanex",name:"OceanEx",countries:["BS"],version:"v1",rateLimit:3e3,urls:{logo:"https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",api:{rest:"https://api.oceanex.pro"},www:"https://www.oceanex.pro.com",doc:"https://api.oceanex.pro/doc/v1",referral:"https://oceanex.pro/signup?referral=VE24QX"},has:{CORS:void 0,spot:!0,margin:!1,swap:void 0,future:void 0,option:void 0,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createMarketOrder:!0,createOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarkets:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:void 0},timeframes:{"1m":"1","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"1440","3d":"4320","1w":"10080"},api:{public:{get:["markets","tickers/{pair}","tickers_multi","order_book","order_book/multi","fees/trading","trades","timestamp"],post:["k"]},private:{get:["key","members/me","orders","orders/filter"],post:["orders","orders/multi","order/delete","order/delete/multi","orders/clear"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.001"),taker:this.parseNumber("0.001")}},commonCurrencies:{PLA:"Plair"},precisionMode:a.kb,exceptions:{codes:{"-1":r.BadRequest,"-2":r.BadRequest,1001:r.BadRequest,1004:r.ArgumentsRequired,1006:r.AuthenticationError,1008:r.AuthenticationError,1010:r.AuthenticationError,1011:r.PermissionDenied,2001:r.AuthenticationError,2002:r.InvalidOrder,2004:r.OrderNotFound,9003:r.PermissionDenied},exact:{"market does not have a valid value":r.BadRequest,"side does not have a valid value":r.BadRequest,"Account::AccountError: Cannot lock funds":r.InsufficientFunds,"The account does not exist":r.AuthenticationError}}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(this.extend({show_details:!0},e)),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeValue(e,"id"),s=this.safeValue(e,"name");let[i,r]=s.split("/");const a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r);i=i.toLowerCase(),r=r.toLowerCase();return{id:t,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"price_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"minimum_trading_amount"),max:void 0}},created:void 0,info:e}}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTickersPair(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),void 0===(e=this.marketSymbols(e))&&(e=this.symbols);const s={markets:this.marketIds(e)},i=await this.publicGetTickersMulti(this.extend(s,t)),r=this.safeValue(i,"data",[]),a={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"market"),i=this.safeMarket(s);a[i.symbol]=this.parseTicker(t,i)}return this.filterByArrayTickers(a,"symbol",e)}parseTicker(e,t=void 0){const s=this.safeValue(e,"ticker",{}),i=this.safeTimestamp(e,"at"),r=this.safeSymbol(void 0,t);return this.safeTicker({symbol:r,timestamp:i,datetime:this.iso8601(i),high:this.safeString(s,"high"),low:this.safeString(s,"low"),bid:this.safeString(s,"buy"),bidVolume:void 0,ask:this.safeString(s,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(s,"last"),last:this.safeString(s,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(s,"volume"),quoteVolume:void 0,info:s},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={market:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetOrderBook(this.extend(i,s)),a=this.safeValue(r,"data",{}),o=this.safeTimestamp(a,"timestamp");return this.parseOrderBook(a,e,o)}async fetchOrderBooks(e=void 0,t=void 0,s={}){await this.loadMarkets(),void 0===e&&(e=this.symbols);const i={markets:this.marketIds(e)};void 0!==t&&(i.limit=t);const r=await this.publicGetOrderBookMulti(this.extend(i,s)),a=this.safeValue(r,"data",[]),o={};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"market"),i=this.safeSymbol(s),r=this.safeTimestamp(t,"timestamp");o[i]=this.parseOrderBook(t,i,r)}return o}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market:r.id};void 0!==s&&(a.limit=Math.min(s,1e3));const o=await this.publicGetTrades(this.extend(a,i)),n=this.safeList(o,"data");return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){let s=this.safeValue(e,"side");"bid"===s?s="buy":"ask"===s&&(s="sell");const i=this.safeValue(e,"market"),r=this.safeSymbol(i,t);let a=this.safeTimestamp(e,"created_on");void 0===a&&(a=this.parse8601(this.safeString(e,"created_at")));const o=this.safeString(e,"price"),n=this.safeString(e,"volume");return this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:r,id:this.safeString(e,"id"),order:void 0,type:"limit",takerOrMaker:void 0,side:s,price:o,amount:n,cost:void 0,fee:void 0},t)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeTimestamp(t,"data")}async fetchTradingFees(e={}){const t=await this.publicGetFeesTrading(e),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeValue(t,"ask_fee",{}),a=this.safeValue(t,"bid_fee",{}),o=this.safeString(t,"market"),n=this.safeSymbol(o);i[n]={info:t,symbol:n,maker:this.safeNumber(r,"value"),taker:this.safeNumber(a,"value"),percentage:!0}}return i}async fetchKey(e={}){const t=await this.privateGetKey(e);return this.safeValue(t,"data")}parseBalance(e){const t=this.safeValue(e,"data"),s=this.safeValue(t,"accounts",[]),i={info:e};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeValue(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"balance"),o.used=this.safeString(t,"locked"),i[a]=o}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetMembersMe(e);return this.parseBalance(t)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={market:o.id,side:s,ord_type:t,volume:this.amountToPrecision(e,i)};"limit"===t&&(n.price=this.priceToPrecision(e,r));const d=await this.privatePostOrders(this.extend(n,a)),h=this.safeDict(d,"data");return this.parseOrder(h,o)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const a={ids:[e]},o=await this.privateGetOrders(this.extend(a,s)),n=this.safeValue(o,"data"),d=n.length;if(void 0===n)throw new r.OrderNotFound(this.id+" could not found matching order");if(Array.isArray(e)){return this.parseOrders(n,i)[0]}if(0===d)throw new r.OrderNotFound(this.id+" could not found matching order");return this.parseOrder(n[0],i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({states:["wait"]},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({states:["done","cancel"]},i))}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o=this.safeValue(i,"states",["wait","done","cancel"]),n=this.omit(i,"states"),d={market:a.id,states:o,need_price:"True"};void 0!==s&&(d.limit=s);const h=await this.privateGetOrdersFilter(this.extend(d,n)),c=this.safeValue(h,"data",[]);let l=[];for(let e=0;e<c.length;e++){const i=this.safeValue(c[e],"orders",[]),r=this.parseOrderStatus(this.safeValue(c[e],"state")),o=this.parseOrders(i,a,t,s,{status:r});l=this.arrayConcat(l,o)}return l}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,period:this.safeString(this.timeframes,t,t)};void 0!==s&&(o.timestamp=s),void 0!==i&&(o.limit=Math.min(i,1e4));const n=await this.publicPostK(this.extend(o,r)),d=this.safeList(n,"data",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeValue(e,"state")),i=this.safeString2(e,"market","market_id"),r=this.safeSymbol(i,t);let a=this.safeTimestamp(e,"created_on");void 0===a&&(a=this.parse8601(this.safeString(e,"created_at")));const o=this.safeString(e,"price"),n=this.safeString(e,"avg_price"),d=this.safeString(e,"volume"),h=this.safeString(e,"remaining_volume"),c=this.safeString(e,"executed_volume");return this.safeOrder({info:e,id:this.safeString(e,"id"),clientOrderId:void 0,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:r,type:this.safeValue(e,"ord_type"),timeInForce:void 0,postOnly:void 0,side:this.safeValue(e,"side"),price:o,stopPrice:void 0,triggerPrice:void 0,average:n,amount:d,remaining:h,filled:c,status:s,cost:void 0,trades:void 0,fee:void 0},t)}parseOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled"},e,e)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDelete(this.extend({id:e},s)),r=this.safeDict(i,"data");return this.parseOrder(r)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=await this.privatePostOrderDeleteMulti(this.extend({ids:e},s)),r=this.safeList(i,"data");return this.parseOrders(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=await this.privatePostOrdersClear(t),i=this.safeList(s,"data");return this.parseOrders(i)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let d=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const h=this.omit(i,this.extractParams(e));if("public"===t)if("tickers_multi"===e||"order_book/multi"===e){let e="?";const t=this.safeValue(i,"markets");for(let s=0;s<t.length;s++)e+="markets[]="+t[s]+"&";const s=this.safeValue(i,"limit");void 0!==s&&(e+="limit="+s),d+=e}else Object.keys(h).length&&(d+="?"+this.urlencode(h));else if("private"===t){this.checkRequiredCredentials();const e={uid:this.apiKey,data:h};d+="?user_jwt="+(0,n.a)(e,this.encode(this.secret),o.s,!0)}return{url:d,method:s,body:a,headers:{"Content-Type":"application/json"}}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code"),l=this.safeString(n,"message");if(void 0!==c&&"0"!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.codes,c,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),new r.ExchangeError(e)}}}},7915:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9886),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"okcoin",name:"OKCoin",countries:["CN","US"],version:"v5",rateLimit:20,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!0,option:void 0,cancelOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRates:!1,fetchBorrowRatesPerSymbol:!1,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchLedger:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:void 0,fetchOrderTrades:!0,fetchPosition:!1,fetchPositions:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTransactions:void 0,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setMargin:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W","1M":"1M","3M":"3M"},hostname:"okcoin.com",urls:{logo:"https://user-images.githubusercontent.com/51840849/87295551-102fbf00-c50e-11ea-90a9-462eebba5829.jpg",api:{rest:"https://www.{hostname}"},www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513",test:{rest:"https://testnet.okex.com"}},api:{public:{get:{"market/tickers":1,"market/ticker":1,"market/books":.5,"market/candles":.5,"market/history-candles":.5,"market/trades":.2,"market/history-trades":2,"market/platform-24-volume":10,"market/open-oracle":50,"market/exchange-rate":20,"public/instruments":1,"public/time":2}},private:{get:{"trade/order":1/3,"trade/orders-pending":1/3,"trade/orders-history":.5,"trade/orders-history-archive":.5,"trade/fills":1/3,"trade/fills-history":2.2,"trade/fills-archive":2,"trade/order-algo":1,"trade/orders-algo-pending":1,"trade/orders-algo-history":1,"otc/rfq/trade":4,"otc/rfq/history":4,"account/balance":2,"account/bills":5/3,"account/bills-archive":5/3,"account/config":4,"account/max-size":4,"account/max-avail-size":4,"account/trade-fee":4,"account/max-withdrawal":4,"asset/currencies":5/3,"asset/balances":5/3,"asset/asset-valuation":10,"asset/transfer-state":10,"asset/bills":5/3,"asset/deposit-lightning":5,"asset/deposit-address":5/3,"asset/deposit-history":5/3,"asset/withdrawal-history":5/3,"asset/deposit-withdraw-status":20,"fiat/deposit-history":5/3,"fiat-withdraw-history":5/3,"fiat-channel":5/3,"users/subaccount/list":10,"users/subaccount/apiKey":10,"account/subaccount/balances":10,"asset/subaccount/balances":10,"asset/subaccount/bills":10},post:{"trade/order":1/3,"trade/batch-orders":1/15,"trade/cancel-order":1/3,"trade/cancel-batch-orders":1/15,"trade/amend-order":1/3,"trade/amend-batch-orders":1/150,"trade/order-algo":1,"trade/cancel-algos":1,"trade/cancel-advance-algos":1,"otc/rfq/quote":4,"otc/rfq/trade":4,"asset/transfer":4,"asset/withdrawal":4,"asset/withdrawal-lightning":4,"asset/withdrawal-cancel":4,"fiat/deposit":5/3,"fiat/cancel-deposit":5/3,"fiat/withdrawal":5/3,"fiat/cancel-withdrawal":5/3,"asset/subaccount/transfer":10}}},fees:{trading:{taker:.002,maker:.001},spot:{taker:.0015,maker:.001}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:r.ExchangeError,2:r.ExchangeError,5e4:r.BadRequest,50001:r.OnMaintenance,50002:r.BadRequest,50004:r.RequestTimeout,50005:r.ExchangeNotAvailable,50006:r.BadRequest,50007:r.AccountSuspended,50008:r.AuthenticationError,50009:r.AccountSuspended,50010:r.ExchangeError,50011:r.RateLimitExceeded,50012:r.ExchangeError,50013:r.ExchangeNotAvailable,50014:r.BadRequest,50015:r.ExchangeError,50016:r.ExchangeError,50017:r.ExchangeError,50018:r.ExchangeError,50019:r.ExchangeError,50020:r.ExchangeError,50021:r.ExchangeError,50022:r.ExchangeError,50023:r.ExchangeError,50024:r.BadRequest,50025:r.ExchangeError,50026:r.ExchangeNotAvailable,50027:r.PermissionDenied,50028:r.ExchangeError,50029:r.ExchangeError,50030:r.PermissionDenied,50032:r.AccountSuspended,50033:r.AccountSuspended,50035:r.BadRequest,50036:r.BadRequest,50037:r.BadRequest,50038:r.ExchangeError,50039:r.ExchangeError,50041:r.ExchangeError,50044:r.BadRequest,50100:r.ExchangeError,50101:r.AuthenticationError,50102:r.InvalidNonce,50103:r.AuthenticationError,50104:r.AuthenticationError,50105:r.AuthenticationError,50106:r.AuthenticationError,50107:r.AuthenticationError,50108:r.ExchangeError,50109:r.ExchangeError,50110:r.PermissionDenied,50111:r.AuthenticationError,50112:r.AuthenticationError,50113:r.AuthenticationError,50114:r.AuthenticationError,50115:r.BadRequest,51e3:r.BadRequest,51001:r.BadSymbol,51002:r.BadSymbol,51003:r.BadRequest,51004:r.InvalidOrder,51005:r.InvalidOrder,51006:r.InvalidOrder,51007:r.InvalidOrder,51008:r.InsufficientFunds,51009:r.AccountSuspended,51010:r.AccountNotEnabled,51011:r.InvalidOrder,51012:r.BadSymbol,51014:r.BadSymbol,51015:r.BadSymbol,51016:r.InvalidOrder,51017:r.ExchangeError,51018:r.ExchangeError,51019:r.ExchangeError,51020:r.InvalidOrder,51023:r.ExchangeError,51024:r.AccountSuspended,51025:r.ExchangeError,51026:r.BadSymbol,51030:r.InvalidOrder,51031:r.InvalidOrder,51032:r.InvalidOrder,51033:r.InvalidOrder,51037:r.InvalidOrder,51038:r.InvalidOrder,51044:r.InvalidOrder,51046:r.InvalidOrder,51047:r.InvalidOrder,51048:r.InvalidOrder,51049:r.InvalidOrder,51050:r.InvalidOrder,51051:r.InvalidOrder,51052:r.InvalidOrder,51053:r.InvalidOrder,51054:r.BadRequest,51056:r.InvalidOrder,51058:r.InvalidOrder,51059:r.InvalidOrder,51100:r.InvalidOrder,51102:r.InvalidOrder,51103:r.InvalidOrder,51108:r.InvalidOrder,51109:r.InvalidOrder,51110:r.InvalidOrder,51111:r.BadRequest,51112:r.InvalidOrder,51113:r.RateLimitExceeded,51115:r.InvalidOrder,51116:r.InvalidOrder,51117:r.InvalidOrder,51118:r.InvalidOrder,51119:r.InsufficientFunds,51120:r.InvalidOrder,51121:r.InvalidOrder,51122:r.InvalidOrder,51124:r.InvalidOrder,51125:r.InvalidOrder,51126:r.InvalidOrder,51127:r.InsufficientFunds,51128:r.InvalidOrder,51129:r.InvalidOrder,51130:r.BadSymbol,51131:r.InsufficientFunds,51132:r.InvalidOrder,51133:r.InvalidOrder,51134:r.InvalidOrder,51135:r.InvalidOrder,51136:r.InvalidOrder,51137:r.InvalidOrder,51138:r.InvalidOrder,51139:r.InvalidOrder,51156:r.BadRequest,51159:r.BadRequest,51162:r.InvalidOrder,51163:r.InvalidOrder,51166:r.InvalidOrder,51174:r.InvalidOrder,51201:r.InvalidOrder,51202:r.InvalidOrder,51203:r.InvalidOrder,51204:r.InvalidOrder,51205:r.InvalidOrder,51250:r.InvalidOrder,51251:r.InvalidOrder,51252:r.InvalidOrder,51253:r.InvalidOrder,51254:r.InvalidOrder,51255:r.InvalidOrder,51256:r.InvalidOrder,51257:r.InvalidOrder,51258:r.InvalidOrder,51259:r.InvalidOrder,51260:r.InvalidOrder,51261:r.InvalidOrder,51262:r.InvalidOrder,51263:r.InvalidOrder,51264:r.InvalidOrder,51265:r.InvalidOrder,51267:r.InvalidOrder,51268:r.InvalidOrder,51269:r.InvalidOrder,51270:r.InvalidOrder,51271:r.InvalidOrder,51272:r.InvalidOrder,51273:r.InvalidOrder,51274:r.InvalidOrder,51275:r.InvalidOrder,51276:r.InvalidOrder,51277:r.InvalidOrder,51278:r.InvalidOrder,51279:r.InvalidOrder,51280:r.InvalidOrder,51321:r.InvalidOrder,51322:r.InvalidOrder,51323:r.BadRequest,51324:r.BadRequest,51325:r.InvalidOrder,51327:r.InvalidOrder,51328:r.InvalidOrder,51329:r.InvalidOrder,51330:r.InvalidOrder,51400:r.OrderNotFound,51401:r.OrderNotFound,51402:r.OrderNotFound,51403:r.InvalidOrder,51404:r.InvalidOrder,51405:r.ExchangeError,51406:r.ExchangeError,51407:r.BadRequest,51408:r.ExchangeError,51409:r.ExchangeError,51410:r.CancelPending,51500:r.ExchangeError,51501:r.ExchangeError,51502:r.InsufficientFunds,51503:r.ExchangeError,51506:r.ExchangeError,51508:r.ExchangeError,51509:r.ExchangeError,51510:r.ExchangeError,51511:r.ExchangeError,51600:r.ExchangeError,51601:r.ExchangeError,51602:r.ExchangeError,51603:r.OrderNotFound,51732:r.AuthenticationError,51733:r.AuthenticationError,51734:r.AuthenticationError,51735:r.ExchangeError,51736:r.InsufficientFunds,52e3:r.ExchangeError,54e3:r.ExchangeError,54001:r.ExchangeError,58e3:r.ExchangeError,58001:r.AuthenticationError,58002:r.PermissionDenied,58003:r.ExchangeError,58004:r.AccountSuspended,58005:r.ExchangeError,58006:r.ExchangeError,58007:r.ExchangeError,58100:r.ExchangeError,58101:r.AccountSuspended,58102:r.RateLimitExceeded,58103:r.ExchangeError,58104:r.ExchangeError,58105:r.ExchangeError,58106:r.ExchangeError,58107:r.ExchangeError,58108:r.ExchangeError,58109:r.ExchangeError,58110:r.ExchangeError,58111:r.ExchangeError,58112:r.ExchangeError,58114:r.ExchangeError,58115:r.ExchangeError,58116:r.ExchangeError,58117:r.ExchangeError,58125:r.BadRequest,58126:r.BadRequest,58127:r.BadRequest,58128:r.BadRequest,58200:r.ExchangeError,58201:r.ExchangeError,58202:r.ExchangeError,58203:r.InvalidAddress,58204:r.AccountSuspended,58205:r.ExchangeError,58206:r.ExchangeError,58207:r.InvalidAddress,58208:r.ExchangeError,58209:r.ExchangeError,58210:r.ExchangeError,58211:r.ExchangeError,58212:r.ExchangeError,58213:r.AuthenticationError,58221:r.BadRequest,58222:r.BadRequest,58224:r.BadRequest,58227:r.BadRequest,58228:r.BadRequest,58229:r.InsufficientFunds,58300:r.ExchangeError,58350:r.InsufficientFunds,59e3:r.ExchangeError,59001:r.ExchangeError,59100:r.ExchangeError,59101:r.ExchangeError,59102:r.ExchangeError,59103:r.InsufficientFunds,59104:r.ExchangeError,59105:r.ExchangeError,59106:r.ExchangeError,59107:r.ExchangeError,59108:r.InsufficientFunds,59109:r.ExchangeError,59128:r.InvalidOrder,59200:r.InsufficientFunds,59201:r.InsufficientFunds,59216:r.BadRequest,59300:r.ExchangeError,59301:r.ExchangeError,59313:r.ExchangeError,59401:r.ExchangeError,59500:r.ExchangeError,59501:r.ExchangeError,59502:r.ExchangeError,59503:r.ExchangeError,59504:r.ExchangeError,59505:r.ExchangeError,59506:r.ExchangeError,59507:r.ExchangeError,59508:r.AccountSuspended,60001:r.AuthenticationError,60002:r.AuthenticationError,60003:r.AuthenticationError,60004:r.AuthenticationError,60005:r.AuthenticationError,60006:r.InvalidNonce,60007:r.AuthenticationError,60008:r.AuthenticationError,60009:r.AuthenticationError,60010:r.AuthenticationError,60011:r.AuthenticationError,60012:r.BadRequest,60013:r.BadRequest,60014:r.RateLimitExceeded,60015:r.NetworkError,60016:r.ExchangeNotAvailable,60017:r.BadRequest,60018:r.BadRequest,60019:r.BadRequest,63999:r.ExchangeError,70010:r.BadRequest,70013:r.BadRequest,70016:r.BadRequest},broad:{"Internal Server Error":r.ExchangeNotAvailable,"server error":r.ExchangeNotAvailable}},precisionMode:o.kb,options:{fetchOHLCV:{type:"Candles"},createMarketBuyOrderRequiresPrice:!0,fetchMarkets:["spot"],defaultType:"spot",accountsByType:{classic:"1",spot:"1",funding:"6",main:"6",unified:"18"},accountsById:{1:"spot",6:"funding",18:"unified"},auth:{time:"public",currencies:"private",instruments:"public",rate:"public","{instrument_id}/constituents":"public"},warnOnFetchCurrenciesWithoutAuthorization:!1,defaultNetwork:"ERC20",networks:{ERC20:"Ethereum",BTC:"Bitcoin",OMNI:"Omni",TRC20:"TRON"}},commonCurrencies:{AE:"AET",BOX:"DefiBox",HOT:"Hydro Protocol",HSR:"HC",MAG:"Maggie",SBTC:"Super Bitcoin",TRADE:"Unitrade",YOYO:"YOYOW",WIN:"WinToken"}})}async fetchTime(e={}){const t=await this.publicGetPublicTime(e);return this.parse8601(this.safeString(t,"iso"))}async fetchMarkets(e={}){const t=await this.publicGetPublicInstruments(this.extend({instType:"SPOT"},e)),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"instId");let s=this.safeStringLower(e,"instType");"futures"===s&&(s="future");const i="spot"===s,r="swap"===s||"future"===s||"option"===s,o=this.safeString(e,"baseCcy"),n=this.safeString(e,"quoteCcy"),d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n),c=d+"/"+h,l=this.safeString(e,"tickSz"),u=this.safeValue2(this.fees,s,"trading",{});let p=this.safeString(e,"lever","1");p=a.Y.stringMax(p,"1");const f=this.safeNumber(e,"maxMktSz");return this.extend(u,{id:t,symbol:c,base:d,quote:h,settle:void 0,baseId:o,quoteId:n,settleId:void 0,type:s,spot:i,margin:i&&a.Y.stringGt(p,"1"),swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:r?this.safeNumber(e,"ctVal"):void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,created:this.safeInteger(e,"listTime"),precision:{amount:this.safeNumber(e,"lotSz"),price:this.parseNumber(l)},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(p)},amount:{min:this.safeNumber(e,"minSz"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:r?void 0:f}},info:e})}async fetchCurrencies(e={}){if(this.checkRequiredCredentials(!1)){const t=await this.privateGetAssetCurrencies(e),s=this.safeValue(t,"data",[]),i={},r=this.groupBy(s,"ccy"),o=Object.keys(r);for(let e=0;e<o.length;e++){const t=o[e],s=this.safeCurrency(t).code,n=r[t],d={};let h,c=!1,l=!1,u=!1;for(let e=0;e<n.length;e++){const t=n[e],s=this.safeValue(t,"canDep");l=s||l;const i=this.safeValue(t,"canWd");u=i||u;const r=this.safeValue(t,"canInternal"),o=!!(s&&i&&r);c=o||c;const p=this.safeString(t,"chain");if(void 0!==p&&p.indexOf("-")>=0){const e=p.split("-"),r=this.safeString(e,1,p),n=this.networkIdToCode(r),c=this.parsePrecision(this.safeString(t,"wdTickSz"));h=void 0===h?c:a.Y.stringMin(h,c),d[n]={id:p,network:n,active:o,deposit:s,withdraw:i,fee:this.safeNumber(t,"minFee"),precision:this.parseNumber(c),limits:{withdraw:{min:this.safeNumber(t,"minWd"),max:this.safeNumber(t,"maxWd")}},info:t}}}const p=this.safeValue(n,0);i[s]={info:n,code:s,id:t,name:this.safeString(p,"name"),active:c,deposit:l,withdraw:u,fee:void 0,precision:this.parseNumber(h),limits:{amount:{min:void 0,max:void 0}},networks:d}}return i}if(this.options.warnOnFetchCurrenciesWithoutAuthorization)throw new r.ExchangeError(this.id+' fetchCurrencies() is a private API endpoint that requires authentication with API keys. Set the API keys on the exchange instance or exchange.options["warnOnFetchCurrenciesWithoutAuthorization"] = false to suppress this warning message.')}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={instId:this.market(e).id};void 0!==(t=void 0===t?20:t)&&(i.sz=t);const r=await this.publicGetMarketBooks(this.extend(i,s)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{}),n=this.safeInteger(o,"ts");return this.parseOrderBook(o,e,n)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,a=this.safeString(e,"last"),o=this.safeString(e,"open24h"),n=this.safeBool(t,"spot",!1)?this.safeString(e,"volCcy24h"):void 0,d=this.safeString(e,"vol24h"),h=this.safeString(e,"high24h"),c=this.safeString(e,"low24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:h,low:c,bid:this.safeString(e,"bidPx"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPx"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:o,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},r=await this.publicGetMarketTicker(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){e=this.marketSymbols(e);const s=await this.publicGetMarketTickers(this.extend({instType:"SPOT"},t)),i=this.safeList(s,"data",[]);return this.parseTickers(i,e,t)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,o=this.safeInteger(e,"ts"),n=this.safeString2(e,"fillPx","px"),d=this.safeString2(e,"fillSz","sz"),h=this.safeString(e,"side"),c=this.safeString(e,"ordId"),l=this.safeString(e,"fee");let u;if(void 0!==l){const t=a.Y.stringNeg(l),s=this.safeString(e,"feeCcy");u={cost:t,currency:this.safeCurrencyCode(s)}}let p=this.safeString(e,"execType");return"T"===p?p="taker":"M"===p&&(p="maker"),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:r,id:s,order:c,type:void 0,takerOrMaker:p,side:h,price:n,amount:d,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);(void 0===s||s>100)&&(s=100);const a={instId:r.id};let o,n;[o,i]=this.handleOptionAndParams(i,"fetchTrades","method","publicGetMarketTrades"),n="publicGetMarketTrades"===o?await this.publicGetMarketTrades(this.extend(a,i)):await this.publicGetMarketHistoryTrades(this.extend(a,i));const d=this.safeList(n,"data",[]);return this.parseTrades(d,r,t,s)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.parseTimeframe(t),n=this.safeValue(this.options,"fetchOHLCV",{});let d=this.safeString(this.timeframes,t,t);const h=this.safeString(n,"timezone","UTC");"UTC"===h&&o>=21600&&(d+=h.toLowerCase());const c={instId:a.id,bar:d};let l,u;void 0!==i&&(c.limit=i),[l,r]=this.handleOptionAndParams(r,"fetchOHLCV","method","publicGetMarketCandles"),u="publicGetMarketCandles"===l?await this.publicGetMarketCandles(this.extend(c,r)):await this.publicGetMarketHistoryCandles(this.extend(c,r));const p=this.safeList(u,"data",[]);return this.parseOHLCVs(p,a,t,s,i)}parseAccountBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"balance"),o.used=this.safeString(i,"hold"),o.free=this.safeString(i,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let r;return r="funding"===t?await this.privateGetAssetBalances(this.extend(i,s)):await this.privateGetAccountBalance(this.extend(i,s)),"funding"===t?this.parseFundingBalance(r):this.parseTradingBalance(r)}parseTradingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]),i=this.safeValue(s,0,{}),r=this.safeInteger(i,"uTime"),a=this.safeValue(i,"details",[]);for(let e=0;e<a.length;e++){const s=a[e],i=this.safeString(s,"ccy"),r=this.safeCurrencyCode(i),o=this.account(),n=this.safeString(s,"eq"),d=this.safeString(s,"availEq");void 0===n||void 0===d?(o.free=this.safeString(s,"availBal"),o.used=this.safeString(s,"frozenBal")):(o.total=n,o.free=d),t[r]=o}return t.timestamp=r,t.datetime=this.iso8601(r),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeValue(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"bal"),o.free=this.safeString(i,"availBal"),o.used=this.safeString(i,"frozenBal"),t[a]=o}return this.safeBalance(t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return s.createMarketBuyOrderRequiresPrice=!1,s.tgtCcy="quote_ccy",await this.createOrder(e,"market","buy",t,void 0,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);let d=this.createOrderRequest(e,t,s,i,a,o),h=this.safeString(this.options,"createOrder","privatePostTradeBatchOrders");const c=this.safeString(d,"ordType");let l;if("trigger"!==c&&"conditional"!==c&&"oco"!==t&&"move_order_stop"!==t&&"iceberg"!==t&&"twap"!==t||(h="privatePostTradeOrderAlgo"),"privatePostTradeBatchOrders"===h&&(d=[d]),"privatePostTradeOrder"===h)l=await this.privatePostTradeOrder(d);else if("privatePostTradeOrderAlgo"===h)l=await this.privatePostTradeOrderAlgo(d);else{if("privatePostTradeBatchOrders"!==h)throw new r.ExchangeError(this.id+' createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder or privatePostTradeOrderAlgo');l=await this.privatePostTradeBatchOrders(d)}const u=this.safeValue(l,"data",[]),p=this.safeValue(u,0),f=this.parseOrder(p,n);return f.type=t,f.side=s,f}createOrderRequest(e,t,s,i,o=void 0,n={}){const d=this.market(e),h={instId:d.id,side:s,ordType:t},c=this.safeValueN(n,["triggerPrice","stopPrice","triggerPx"]),l=this.safeString(n,"timeInForce","GTC"),u=this.safeValue2(n,"takeProfitPrice","tpTriggerPx"),p=this.safeValue(n,"tpOrdPx",o),f=this.safeString(n,"tpTriggerPxType","last"),m=this.safeValue2(n,"stopLossPrice","slTriggerPx"),g=this.safeValue(n,"slOrdPx",o),v=this.safeString(n,"slTriggerPxType","last"),y=this.safeString2(n,"clOrdId","clientOrderId"),w=this.safeValue(n,"stopLoss"),b=void 0!==w,S=this.safeValue(n,"takeProfit"),k=void 0!==S,O=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let T=this.safeString2(n,"marginMode","tdMode"),P=!1;if(void 0!==T&&"cash"!==T?P=!0:(T=O,P=this.safeBool(n,"margin",!1)),P){const e="buy"===s?d.quote:d.base,t=this.safeString(n,"ccy",e);h.ccy=this.safeCurrencyCode(t)}const I=P?T:"cash";h.tdMode=I;const x="market"===t;let A=!1;[A,n]=this.handlePostOnly(x,"post_only"===t,n),n=this.omit(n,["currency","ccy","marginMode","timeInForce","stopPrice","triggerPrice","clientOrderId","stopLossPrice","takeProfitPrice","slOrdPx","tpOrdPx","margin","stopLoss","takeProfit"]);const M="IOC"===l||"ioc"===t,C="FOK"===l||"fok"===t,E=void 0!==c||"trigger"===t,_=void 0!==m||void 0!==u||"conditional"===t,B=x&&M||"optimal_limit_ioc"===t,N=this.safeString(this.options,"tgtCcy","base_ccy"),R=this.safeString(n,"tgtCcy",N);if(P||(h.tgtCcy=R),x||B)if(h.ordType="market","buy"===s)if("quote_ccy"===R){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber2(n,"cost","sz");if(n=this.omit(n,["cost","sz"]),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);h.sz=t}else h.sz=this.amountToPrecision(e,i);else h.sz=this.amountToPrecision(e,i);else h.sz=this.amountToPrecision(e,i),E||_||(h.px=this.priceToPrecision(e,o));if(A)h.ordType="post_only";else if(M&&!B)h.ordType="ioc";else if(C)h.ordType="fok";else if(b||k){if(b){const t=this.safeValueN(w,["triggerPrice","stopPrice","slTriggerPx"]);if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["stopLoss"]["triggerPrice"], or params["stopLoss"]["stopPrice"], or params["stopLoss"]["slTriggerPx"] for a stop loss order');h.slTriggerPx=this.priceToPrecision(e,t);const s=this.safeValueN(w,["price","stopLossPrice","slOrdPx"]),i=this.safeString(w,"type");if(void 0!==i){const t="limit"===i;if(!t&&!("market"===i))throw new r.InvalidOrder(this.id+' createOrder() params["stopLoss"]["type"] must be either "limit" or "market"');if(t){if(void 0===s)throw new r.InvalidOrder(this.id+' createOrder() requires a limit price in params["stopLoss"]["price"] or params["stopLoss"]["slOrdPx"] for a stop loss limit order');h.slOrdPx=this.priceToPrecision(e,s)}else"market"===i&&(h.slOrdPx="-1")}else h.slOrdPx=void 0!==s?this.priceToPrecision(e,s):"-1";const a=this.safeString2(w,"triggerPriceType","slTriggerPxType","last");if(void 0!==a){if("last"!==a&&"index"!==a&&"mark"!==a)throw new r.InvalidOrder(this.id+' createOrder() stop loss trigger price type must be one of "last", "index" or "mark"');h.slTriggerPxType=a}}if(k){const t=this.safeValueN(S,["triggerPrice","stopPrice","tpTriggerPx"]);if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["takeProfit"]["triggerPrice"], or params["takeProfit"]["stopPrice"], or params["takeProfit"]["tpTriggerPx"] for a take profit order');h.tpTriggerPx=this.priceToPrecision(e,t);const s=this.safeValueN(S,["price","takeProfitPrice","tpOrdPx"]),i=this.safeString(S,"type");if(void 0!==i){const t="limit"===i;if(!t&&!("market"===i))throw new r.InvalidOrder(this.id+' createOrder() params["takeProfit"]["type"] must be either "limit" or "market"');if(t){if(void 0===s)throw new r.InvalidOrder(this.id+' createOrder() requires a limit price in params["takeProfit"]["price"] or params["takeProfit"]["tpOrdPx"] for a take profit limit order');h.tpOrdPx=this.priceToPrecision(e,s)}else"market"===i&&(h.tpOrdPx="-1")}else h.tpOrdPx=void 0!==s?this.priceToPrecision(e,s):"-1";const a=this.safeString2(S,"triggerPriceType","tpTriggerPxType","last");if(void 0!==a){if("last"!==a&&"index"!==a&&"mark"!==a)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "last", "index" or "mark"');h.tpTriggerPxType=a}}}else if(E)h.ordType="trigger",h.triggerPx=this.priceToPrecision(e,c),h.orderPx=x?"-1":this.priceToPrecision(e,o);else if(_){h.ordType="conditional";void 0!==u&&void 0!==m&&(h.ordType="oco"),void 0!==u&&(h.tpTriggerPx=this.priceToPrecision(e,u),h.tpOrdPx=void 0===p?"-1":this.priceToPrecision(e,p),h.tpTriggerPxType=f),void 0!==m&&(h.slTriggerPx=this.priceToPrecision(e,m),h.slOrdPx=void 0===g?"-1":this.priceToPrecision(e,g),h.slTriggerPxType=v)}if(void 0===y){const e=this.safeString(this.options,"brokerId");void 0!==e&&(h.clOrdId=e+this.uuid16(),h.tag=e)}else h.clOrdId=y,n=this.omit(n,["clOrdId","clientOrderId"]);return this.extend(h,n)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.safeValue2(s,"stop","trigger"),a=this.safeValue(s,"advanced");if(i||a){const i=await this.cancelOrders([e],t,s);return this.safeValue(i,0)}const o=this.market(t),n={instId:o.id},d=this.safeString2(s,"clOrdId","clientOrderId");void 0!==d?n.clOrdId=d:n.ordId=e.toString();const h=this.omit(s,["clOrdId","clientOrderId"]),c=await this.privatePostTradeCancelOrder(this.extend(n,h)),l=this.safeValue(c,"data",[]),u=this.safeDict(l,0);return this.parseOrder(u,o)}parseIds(e){return"string"==typeof e?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.safeValue2(s,"stop","trigger"),a=this.safeValue(s,"advanced");s=this.omit(s,["stop","trigger","advanced"]);const o=this.market(t),n=[],d=this.parseIds(this.safeValue2(s,"clOrdId","clientOrderId")),h=this.parseIds(this.safeValue(s,"algoId"));if(void 0===d){if(e=this.parseIds(e),void 0!==h)for(let e=0;e<h.length;e++)n.push({algoId:h[e],instId:o.id});for(let t=0;t<e.length;t++)i||a?n.push({algoId:e[t],instId:o.id}):n.push({ordId:e[t],instId:o.id})}else for(let e=0;e<d.length;e++)n.push({instId:o.id,clOrdId:d[e]});let c;c=i?await this.privatePostTradeCancelAlgos(n):a?await this.privatePostTradeCancelAdvanceAlgos(n):await this.privatePostTradeCancelBatchOrders(n);const l=this.safeList(c,"data",[]);return this.parseOrders(l,o,void 0,void 0,s)}parseOrderStatus(e){return this.safeString({canceled:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString2(e,"algoId","ordId"),i=this.safeInteger(e,"cTime"),r=this.safeInteger(e,"uTime"),o=this.safeInteger(e,"fillTime"),n=this.safeString(e,"side");let d,h,c=this.safeString(e,"ordType");"post_only"===c?(d=!0,c="limit"):"fok"===c?(h="FOK",c="limit"):"ioc"===c&&(h="IOC",c="limit");const l=this.safeString(e,"instId");t=this.safeMarket(l,t);const u=this.safeSymbol(l,t,"-"),p=this.safeString(e,"accFillSz"),f=this.safeString2(e,"px","ordPx"),m=this.safeString(e,"avgPx"),g=this.parseOrderStatus(this.safeString(e,"state")),v=this.safeString(e,"fee");let y,w;const b=this.safeString(this.options,"tgtCcy","base_ccy"),S=this.safeString(e,"tgtCcy",b);let k;if("buy"===n&&"market"===c&&"quote_ccy"===S?w=this.safeString(e,"sz"):y=this.safeString(e,"sz"),void 0!==v){const t=a.Y.stringNeg(v),s=this.safeString(e,"feeCcy"),i=this.safeCurrencyCode(s);k={cost:this.parseNumber(t),currency:i}}let O=this.safeString(e,"clOrdId");void 0!==O&&O.length<1&&(O=void 0);const T=this.safeNumber2(e,"slTriggerPx","slOrdPx"),P=this.safeNumber2(e,"tpTriggerPx","tpOrdPx"),I=this.safeNumberN(e,["triggerPx","moveTriggerPx"]),x=this.safeString(e,"reduceOnly");let A=!1;return void 0!==A&&(A="true"===x),this.safeOrder({info:e,id:s,clientOrderId:O,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:o,lastUpdateTimestamp:r,symbol:u,type:c,timeInForce:h,postOnly:d,side:n,price:f,stopLossPrice:T,takeProfitPrice:P,stopPrice:I,triggerPrice:I,average:m,cost:w,amount:y,filled:p,remaining:void 0,status:g,fee:k,trades:void 0,reduceOnly:A},t)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i={instId:this.market(t).id},a=this.safeString2(s,"clOrdId","clientOrderId"),o=this.safeValue2(s,"stop","trigger");o?void 0!==a?i.algoClOrdId=a:i.algoId=e:void 0!==a?i.clOrdId=a:i.ordId=e;const n=this.omit(s,["clientOrderId","stop","trigger"]);let d;d=o?await this.privateGetTradeOrderAlgo(this.extend(i,n)):await this.privateGetTradeOrder(this.extend(i,n));const h=this.safeValue(d,"data",[]),c=this.safeDict(h,0);return this.parseOrder(c)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.instId=a.id),void 0!==s&&(r.limit=s);const o=this.safeString(i,"ordType"),n=this.safeValue(i,"stop")||void 0!==this.safeString(i,"ordType");let d;n&&void 0===o&&(r.ordType="trigger"),i=this.omit(i,["stop"]),d=n?await this.privateGetTradeOrdersAlgoPending(this.extend(r,i)):await this.privateGetTradeOrdersPending(this.extend(r,i));const h=this.safeList(d,"data",[]);return this.parseOrders(h,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={instType:"SPOT"};let a;void 0!==e&&(a=this.market(e),r.instId=a.id);const o=this.safeString(i,"ordType"),n=this.safeValue(i,"stop")||void 0!==this.safeString(i,"ordType");let d;if(n&&void 0===o&&(r.ordType="trigger"),i=this.omit(i,["stop"]),n)d=await this.privateGetTradeOrdersAlgoHistory(this.extend(r,i));else{let e;[e,i]=this.handleOptionAndParams(i,"fetchClosedOrders","method","privateGetTradeOrdersHistory"),d="privateGetTradeOrdersHistory"===e?await this.privateGetTradeOrdersHistory(this.extend(r,i)):await this.privateGetTradeOrdersHistoryArchive(this.extend(r,i))}const h=this.safeList(d,"data",[]);return this.parseOrders(h,a,t,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addr");let i=this.safeStringN(e,["tag","pmtId","memo"]);if(void 0===i){const t=this.safeValue(e,"addrEx",{});i=this.safeString(t,"comment")}const r=this.safeString(e,"ccy"),a=(t=this.safeCurrency(r,t)).code,o=this.safeString(e,"chain").replace(r+"-",""),n=this.networkIdToCode(o);return this.checkAddress(s),{currency:a,address:s,tag:i,network:n,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.safeString(this.options,"defaultNetwork","ERC20"),i=this.safeString(t,"network",s),a=this.networkIdToCode(i);t=this.omit(t,"network");const o=await this.fetchDepositAddressesByNetwork(e,t),n=this.safeValue(o,a);if(void 0===n)throw new r.InvalidAddress(this.id+" fetchDepositAddress() cannot find "+a+" deposit address for "+e);return n}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={ccy:s.id},r=await this.privateGetAssetDepositAddress(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.filterBy(a,"selected",!0),n=this.parseDepositAddresses(o,[s.code],!1);return this.indexBy(n,"network")}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={ccy:a.id,amt:this.currencyToPrecision(e,t),type:"0",from:n,to:d};"master"===n?(h.type="1",h.subAcct=d,h.from=this.safeString(r,"from","6"),h.to=this.safeString(r,"to","6")):"master"===d&&(h.type="2",h.subAcct=n,h.from=this.safeString(r,"from","6"),h.to=this.safeString(r,"to","6"));const c=await this.privatePostAssetTransfer(this.extend(h,r)),l=this.safeValue(c,"data",[]),u=this.safeDict(l,0,{});return this.parseTransfer(u,a)}parseTransfer(e,t=void 0){const s=this.safeString2(e,"transId","billId"),i=this.safeString(e,"ccy"),r=this.safeCurrencyCode(i,t);let o=this.safeNumber(e,"amt");const n=this.safeString(e,"from"),d=this.safeString(e,"to"),h=this.safeValue(this.options,"accountsById",{}),c=this.safeInteger(e,"ts",this.milliseconds()),l=this.safeString(e,"sz");return void 0!==l&&(o=this.parseNumber(a.Y.stringAbs(l))),{info:e,id:s,timestamp:c,datetime:this.iso8601(c),currency:r,amount:o,fromAccount:this.safeString(h,n),toAccount:this.safeString(h,d),status:this.parseTransferStatus(this.safeString(e,"state"))}}parseTransferStatus(e){return this.safeString({success:"ok"},e,e)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);void 0!==i&&i.length>0&&(s=s+":"+i);const n={ccy:o.id,toAddr:s,dest:"4",amt:this.numberToString(t)};let d=this.safeString(a,"network");if(void 0!==d){const e=this.safeValue(this.options,"networks",{});d=this.safeString(e,d.toUpperCase(),d),n.chain=o.id+"-"+d,a=this.omit(a,"network")}let h=this.safeString(a,"fee");if(void 0===h){const e=this.safeValue(o.networks,this.networkIdToCode(d),{});if(h=this.safeString(e,"fee"),void 0===h)throw new r.ArgumentsRequired(this.id+' withdraw() requires a "fee" string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKX are fee-free, please set "0". Withdrawing to external digital asset address requires network transaction fee.')}n.fee=this.numberToString(h);const c=await this.privatePostAssetWithdrawal(this.extend(n,a)),l=this.safeValue(c,"data",[]),u=this.safeDict(l,0);return this.parseTransaction(u,o)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a={};void 0!==e&&(r=this.currency(e),a.ccy=r.id),void 0!==t&&(a.before=Math.max(t-1,0)),void 0!==s&&(a.limit=s),[a,i]=this.handleUntilOption("after",a,i);const o=await this.privateGetAssetDepositHistory(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,r,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a={};void 0!==e&&(r=this.currency(e),a.ccy=r.id),void 0!==t&&(a.before=Math.max(t-1,0)),void 0!==s&&(a.limit=s),[a,i]=this.handleUntilOption("after",a,i);const o=await this.privateGetAssetWithdrawalHistory(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTransactions(n,r,t,s,i)}parseTransactionStatus(e){return this.safeString({"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending"},e,e)}parseTransaction(e,t=void 0){let s,i;const r=this.safeString(e,"wdId"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),n=o;let d=this.safeString2(e,"tag","memo");d=this.safeString2(e,"pmtId",d),void 0!==r?(s="withdrawal",i=r):(i=this.safeString(e,"depId"),s="deposit");const h=this.safeString(e,"ccy"),c=this.safeCurrencyCode(h),l=this.safeNumber(e,"amt"),u=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"txId"),f=this.safeInteger(e,"ts");let m;return m="deposit"===s?0:this.safeNumber(e,"fee"),{info:e,id:i,currency:c,amount:l,network:void 0,addressFrom:a,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:u,type:s,updated:void 0,txid:p,timestamp:f,datetime:this.iso8601(f),comment:void 0,internal:void 0,fee:{currency:c,cost:m}}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={instType:"SPOT"};let a,o,n;void 0!==s&&s>100&&(s=100),void 0!==e&&(a=this.market(e),r.instId=a.id),[o,i]=this.handleOptionAndParams(i,"fetchMyTrades","method","privateGetTradeFillsHistory"),n="privateGetTradeFillsHistory"===o?await this.privateGetTradeFillsHistory(this.extend(r,i)):await this.privateGetTradeFills(this.extend(r,i));const d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a={order_id:e};return await this.fetchMyTrades(t,s,i,this.extend(a,r))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),[r,i]=this.handleOptionAndParams(i,"fetchLedger","method","privateGetAccountBills");let a,o,n={};void 0!==s&&(n.limit=s),void 0!==e&&(a=this.currency(e),n.ccy=a.id),[n,i]=this.handleUntilOption("end",n,i),o="privateGetAccountBillsArchive"===r?await this.privateGetAccountBillsArchive(this.extend(n,i)):"privateGetAssetBills"===r?await this.privateGetAssetBills(this.extend(n,i)):await this.privateGetAccountBills(this.extend(n,i));const d=this.safeValue(o,"data",[]);return this.parseLedger(d,a,t,s)}parseLedgerEntryType(e){return this.safeString({1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=this.safeString(e,"ordId"),r=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"ccy"),t),n=this.safeString(e,"balChg"),d=this.parseNumber(n),h=this.safeInteger(e,"ts"),c=this.safeString(e,"fee");let l;void 0!==c&&(l={cost:this.parseNumber(a.Y.stringNeg(c)),currency:o});const u=this.safeString(e,"bal"),p=this.parseNumber(u),f=this.safeString(e,"instId"),m=this.safeSymbol(f,void 0,"-");return{id:s,info:e,timestamp:h,datetime:this.iso8601(h),account:undefined,referenceId:i,referenceAccount:undefined,type:r,currency:o,symbol:m,amount:d,before:undefined,after:p,status:"ok",fee:l}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=Array.isArray(i),d="/api/"+this.version+"/"+this.implodeParams(e,i),h=this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+d;if("public"===t)Object.keys(h).length&&(c+="?"+this.urlencode(h));else if("private"===t){this.checkRequiredCredentials();const e=this.iso8601(this.milliseconds());r={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":e};let t=e+s+d;if("GET"===s){if(Object.keys(h).length){const e="?"+this.urlencode(h);c+=e,t+=e}}else(o||Object.keys(h).length)&&(t+=a=this.json(h)),r["Content-Type"]="application/json";const i=this.hmac(this.encode(t),this.encode(this.secret),n.s,"base64");r["OK-ACCESS-SIGN"]=i}return{url:c,method:s,body:a,headers:r}}parseBalanceByType(e,t){return"funding"===e?this.parseFundingBalance(t):this.parseTradingBalance(t)}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeString(n,"code");if("0"!==c){const e=this.id+" "+o,t=this.safeValue(n,"data",[]);for(let s=0;s<t.length;s++){const i=t[s],r=this.safeString(i,"sCode"),a=this.safeString(i,"sMsg");this.throwExactlyMatchedException(this.exceptions.exact,r,e),this.throwBroadlyMatchedException(this.exceptions.broad,a,e)}throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}}},3660:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5531),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"okx",name:"OKX",countries:["CN","US"],version:"v5",rateLimit:103,pro:!0,certified:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!0,option:!0,addMargin:!0,cancelAllOrders:!1,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!0,closeAllPositions:!1,closePosition:!0,createConvertTrade:!0,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketSellOrderWithCost:!0,createOrder:!0,createOrders:!0,createOrderWithTakeProfitAndStopLoss:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopLossOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,createTakeProfitOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,editOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:void 0,fetchBorrowInterest:!0,fetchBorrowRateHistories:!0,fetchBorrowRateHistory:!0,fetchCanceledOrders:!0,fetchClosedOrder:void 0,fetchClosedOrders:!0,fetchConvertCurrencies:!0,fetchConvertQuote:!0,fetchConvertTrade:!0,fetchConvertTradeHistory:!0,fetchCrossBorrowRate:!0,fetchCrossBorrowRates:!0,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchGreeks:!0,fetchIndexOHLCV:!0,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:void 0,fetchLeverage:!0,fetchLeverageTiers:!1,fetchMarginAdjustmentHistory:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!0,fetchMySettlementHistory:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!0,fetchOpenOrder:void 0,fetchOpenOrders:!0,fetchOption:!0,fetchOptionChain:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!0,fetchPermissions:void 0,fetchPosition:!0,fetchPositionHistory:"emulated",fetchPositions:!0,fetchPositionsForSymbol:!0,fetchPositionsHistory:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!0,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!0,fetchTransfers:!0,fetchUnderlyingAssets:!0,fetchVolatilityHistory:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayCrossMargin:!0,sandbox:!0,setLeverage:!0,setMargin:!1,setMarginMode:!0,setPositionMode:!0,signIn:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","2h":"2H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W","1M":"1M","3M":"3M"},hostname:"www.okx.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",api:{rest:"https://{hostname}"},www:"https://www.okx.com",doc:"https://www.okx.com/docs-v5/en/",fees:"https://www.okx.com/pages/products/fees.html",referral:{url:"https://www.okx.com/join/CCXT2023",discount:.2},test:{rest:"https://{hostname}"}},api:{public:{get:{"market/books-full":2,"market/tickers":1,"market/ticker":1,"market/index-tickers":1,"market/books":.5,"market/books-lite":5/3,"market/candles":.5,"market/history-candles":1,"market/index-candles":1,"market/history-index-candles":2,"market/mark-price-candles":1,"market/history-mark-price-candles":2,"market/trades":.2,"market/history-trades":2,"market/option/instrument-family-trades":1,"market/platform-24-volume":10,"market/open-oracle":50,"market/exchange-rate":20,"market/index-components":1,"public/economic-calendar":50,"market/block-tickers":1,"market/block-ticker":1,"public/block-trades":1,"public/instruments":1,"public/delivery-exercise-history":.5,"public/open-interest":1,"public/funding-rate":1,"public/funding-rate-history":1,"public/price-limit":1,"public/opt-summary":1,"public/estimated-price":2,"public/discount-rate-interest-free-quota":10,"public/time":2,"public/mark-price":2,"public/position-tiers":2,"public/interest-rate-loan-quota":10,"public/vip-interest-rate-loan-quota":10,"public/underlying":1,"public/insurance-fund":2,"public/convert-contract-coin":2,"public/option-trades":1,"public/instrument-tick-bands":4,"rubik/stat/trading-data/support-coin":4,"rubik/stat/taker-volume":4,"rubik/stat/margin/loan-ratio":4,"rubik/stat/contracts/long-short-account-ratio":4,"rubik/stat/contracts/open-interest-volume":4,"rubik/stat/option/open-interest-volume":4,"rubik/stat/option/open-interest-volume-ratio":4,"rubik/stat/option/open-interest-volume-expiry":4,"rubik/stat/option/open-interest-volume-strike":4,"rubik/stat/option/taker-block-volume":4,"system/status":50,"sprd/spreads":1,"sprd/books":.5,"sprd/ticker":1,"sprd/public-trades":.2,"market/sprd-ticker":2,"market/sprd-candles":2,"market/sprd-history-candles":2,"tradingBot/grid/ai-param":1,"tradingBot/grid/min-investment":1,"tradingBot/public/rsi-back-testing":1,"asset/exchange-list":5/3,"finance/staking-defi/eth/apy-history":5/3,"finance/savings/lending-rate-summary":5/3,"finance/savings/lending-rate-history":5/3,"finance/fixed-loan/lending-offers":10/3,"finance/fixed-loan/lending-apy-history":10/3,"finance/fixed-loan/pending-lending-volume":10/3,"finance/sfp/dcd/products":2/3,"copytrading/public-lead-traders":4,"copytrading/public-weekly-pnl":4,"copytrading/public-stats":4,"copytrading/public-preference-currency":4,"copytrading/public-current-subpositions":4,"copytrading/public-subpositions-history":4}},private:{get:{"rfq/counterparties":4,"rfq/maker-instrument-settings":4,"rfq/mmp-config":4,"rfq/rfqs":10,"rfq/quotes":10,"rfq/trades":4,"rfq/public-trades":4,"sprd/order":1/3,"sprd/orders-pending":1/3,"sprd/orders-history":.5,"sprd/orders-history-archive":.5,"sprd/trades":1/3,"trade/order":1/3,"trade/orders-pending":1/3,"trade/orders-history":.5,"trade/orders-history-archive":1,"trade/fills":1/3,"trade/fills-history":2.2,"trade/fills-archive":2,"trade/order-algo":1,"trade/orders-algo-pending":1,"trade/orders-algo-history":1,"trade/easy-convert-currency-list":20,"trade/easy-convert-history":20,"trade/one-click-repay-currency-list":20,"trade/one-click-repay-history":20,"trade/account-rate-limit":1,"asset/currencies":5/3,"asset/balances":5/3,"asset/non-tradable-assets":5/3,"asset/asset-valuation":10,"asset/transfer-state":10,"asset/bills":5/3,"asset/deposit-lightning":5,"asset/deposit-address":5/3,"asset/deposit-history":5/3,"asset/withdrawal-history":5/3,"asset/deposit-withdraw-status":20,"asset/convert/currencies":5/3,"asset/convert/currency-pair":5/3,"asset/convert/history":5/3,"asset/monthly-statement":2,"account/balance":2,"account/positions":2,"account/positions-history":100,"account/account-position-risk":2,"account/bills":5/3,"account/bills-archive":5/3,"account/config":4,"account/max-size":1,"account/max-avail-size":1,"account/leverage-info":1,"account/adjust-leverage-info":4,"account/max-loan":1,"account/trade-fee":4,"account/interest-accrued":4,"account/interest-rate":4,"account/max-withdrawal":1,"account/risk-state":2,"account/quick-margin-borrow-repay-history":4,"account/borrow-repay-history":4,"account/vip-interest-accrued":4,"account/vip-interest-deducted":4,"account/vip-loan-order-list":4,"account/vip-loan-order-detail":4,"account/interest-limits":4,"account/greeks":2,"account/position-tiers":2,"account/mmp-config":4,"account/fixed-loan/borrowing-limit":4,"account/fixed-loan/borrowing-quote":5,"account/fixed-loan/borrowing-orders-list":5,"users/subaccount/list":10,"account/subaccount/balances":10/3,"asset/subaccount/balances":10/3,"account/subaccount/max-withdrawal":1,"asset/subaccount/bills":5/3,"asset/subaccount/managed-subaccount-bills":5/3,"users/entrust-subaccount-list":10,"account/subaccount/interest-limits":4,"tradingBot/grid/orders-algo-pending":1,"tradingBot/grid/orders-algo-history":1,"tradingBot/grid/orders-algo-details":1,"tradingBot/grid/sub-orders":1,"tradingBot/grid/positions":1,"tradingBot/grid/ai-param":1,"tradingBot/signal/signals":1,"tradingBot/signal/orders-algo-details":1,"tradingBot/signal/orders-algo-history":1,"tradingBot/signal/positions":1,"tradingBot/signal/positions-history":1,"tradingBot/signal/sub-orders":1,"tradingBot/signal/event-history":1,"tradingBot/recurring/orders-algo-pending":1,"tradingBot/recurring/orders-algo-history":1,"tradingBot/recurring/orders-algo-details":1,"tradingBot/recurring/sub-orders":1,"finance/savings/balance":5/3,"finance/savings/lending-history":5/3,"finance/staking-defi/offers":10/3,"finance/staking-defi/orders-active":10/3,"finance/staking-defi/orders-history":10/3,"finance/staking-defi/eth/balance":5/3,"finance/staking-defi/eth/purchase-redeem-history":5/3,"copytrading/current-subpositions":1,"copytrading/subpositions-history":1,"copytrading/instruments":4,"copytrading/profit-sharing-details":4,"copytrading/total-profit-sharing":4,"copytrading/unrealized-profit-sharing-details":4,"copytrading/copy-settings":4,"copytrading/batch-leverage-info":4,"copytrading/current-lead-traders":4,"copytrading/lead-traders-history":4,"broker/nd/info":10,"broker/nd/subaccount-info":10,"broker/nd/subaccount/apikey":10,"asset/broker/nd/subaccount-deposit-address":5/3,"asset/broker/nd/subaccount-deposit-history":4,"asset/broker/nd/subaccount-withdrawal-history":4,"broker/nd/rebate-daily":100,"broker/nd/rebate-per-orders":300,"finance/sfp/dcd/order":2,"finance/sfp/dcd/orders":2,"broker/fd/rebate-per-orders":300,"broker/fd/if-rebate":5,"affiliate/invitee/detail":1,"users/partner/if-rebate":1},post:{"rfq/create-rfq":4,"rfq/cancel-rfq":4,"rfq/cancel-batch-rfqs":10,"rfq/cancel-all-rfqs":10,"rfq/execute-quote":15,"rfq/maker-instrument-settings":4,"rfq/mmp-reset":4,"rfq/mmp-config":100,"rfq/create-quote":.4,"rfq/cancel-quote":.4,"rfq/cancel-batch-quotes":10,"rfq/cancel-all-quotes":10,"sprd/order":1,"sprd/cancel-order":1,"sprd/mass-cancel":1,"sprd/amend-order":1,"sprd/cancel-all-after":10,"trade/order":1/3,"trade/batch-orders":1/15,"trade/cancel-order":1/3,"trade/cancel-batch-orders":1/15,"trade/amend-order":1/3,"trade/amend-batch-orders":1/150,"trade/close-position":1,"trade/fills-archive":172800,"trade/order-algo":1,"trade/cancel-algos":1,"trade/amend-algos":1,"trade/cancel-advance-algos":1,"trade/easy-convert":20,"trade/one-click-repay":20,"trade/mass-cancel":4,"trade/cancel-all-after":10,"asset/transfer":10,"asset/withdrawal":5/3,"asset/withdrawal-lightning":5,"asset/cancel-withdrawal":5/3,"asset/convert-dust-assets":10,"asset/convert/estimate-quote":1,"asset/convert/trade":1,"asset/monthly-statement":1,"account/set-position-mode":4,"account/set-leverage":1,"account/position/margin-balance":1,"account/set-greeks":4,"account/set-isolated-mode":4,"account/quick-margin-borrow-repay":4,"account/borrow-repay":5/3,"account/simulated_margin":10,"account/position-builder":10,"account/set-riskOffset-type":2,"account/activate-option":4,"account/set-auto-loan":4,"account/set-account-level":4,"account/mmp-reset":4,"account/mmp-config":100,"account/fixed-loan/borrowing-order":5,"account/fixed-loan/amend-borrowing-order":5,"account/fixed-loan/manual-reborrow":5,"account/fixed-loan/repay-borrowing-order":5,"users/subaccount/modify-apikey":10,"asset/subaccount/transfer":10,"users/subaccount/set-transfer-out":10,"account/subaccount/set-loan-allocation":4,"tradingBot/grid/order-algo":1,"tradingBot/grid/amend-order-algo":1,"tradingBot/grid/stop-order-algo":1,"tradingBot/grid/close-position":1,"tradingBot/grid/cancel-close-order":1,"tradingBot/grid/order-instant-trigger":1,"tradingBot/grid/withdraw-income":1,"tradingBot/grid/compute-margin-balance":1,"tradingBot/grid/margin-balance":1,"tradingBot/grid/min-investment":1,"tradingBot/grid/adjust-investment":1,"tradingBot/signal/create-signal":1,"tradingBot/signal/order-algo":1,"tradingBot/signal/stop-order-algo":1,"tradingBot/signal/margin-balance":1,"tradingBot/signal/amendTPSL":1,"tradingBot/signal/set-instruments":1,"tradingBot/signal/close-position":1,"tradingBot/signal/sub-order":1,"tradingBot/signal/cancel-sub-order":1,"tradingBot/recurring/order-algo":1,"tradingBot/recurring/amend-order-algo":1,"tradingBot/recurring/stop-order-algo":1,"finance/savings/purchase-redempt":5/3,"finance/savings/set-lending-rate":5/3,"finance/staking-defi/purchase":3,"finance/staking-defi/redeem":3,"finance/staking-defi/cancel":3,"finance/staking-defi/eth/purchase":5,"finance/staking-defi/eth/redeem":5,"copytrading/algo-order":1,"copytrading/close-subposition":1,"copytrading/set-instruments":4,"copytrading/first-copy-settings":4,"copytrading/amend-copy-settings":4,"copytrading/stop-copy-trading":4,"copytrading/batch-set-leverage":4,"broker/nd/create-subaccount":.25,"broker/nd/delete-subaccount":1,"broker/nd/subaccount/apikey":.25,"broker/nd/subaccount/modify-apikey":1,"broker/nd/subaccount/delete-apikey":1,"broker/nd/set-subaccount-level":4,"broker/nd/set-subaccount-fee-rate":4,"broker/nd/set-subaccount-assets":.25,"asset/broker/nd/subaccount-deposit-address":1,"asset/broker/nd/modify-subaccount-deposit-address":5/3,"broker/nd/rebate-per-orders":36e3,"finance/sfp/dcd/quote":10,"finance/sfp/dcd/order":10,"broker/nd/report-subaccount-ip":.25,"broker/fd/rebate-per-orders":36e3}}},fees:{trading:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},spot:{taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.0010")},future:{taker:this.parseNumber("0.0005"),maker:this.parseNumber("0.0002")},swap:{taker:this.parseNumber("0.00050"),maker:this.parseNumber("0.00020")}},requiredCredentials:{apiKey:!0,secret:!0,password:!0},exceptions:{exact:{1:r.ExchangeError,2:r.ExchangeError,5e4:r.BadRequest,50001:r.OnMaintenance,50002:r.BadRequest,50004:r.RequestTimeout,50005:r.ExchangeNotAvailable,50006:r.BadRequest,50007:r.AccountSuspended,50008:r.AuthenticationError,50009:r.AccountSuspended,50010:r.ExchangeError,50011:r.RateLimitExceeded,50012:r.ExchangeError,50013:r.ExchangeNotAvailable,50014:r.BadRequest,50015:r.ExchangeError,50016:r.ExchangeError,50017:r.ExchangeError,50018:r.ExchangeError,50019:r.ExchangeError,50020:r.ExchangeError,50021:r.ExchangeError,50022:r.ExchangeError,50023:r.ExchangeError,50024:r.BadRequest,50025:r.ExchangeError,50026:r.ExchangeNotAvailable,50027:r.PermissionDenied,50028:r.ExchangeError,50044:r.BadRequest,50061:r.ExchangeError,50062:r.ExchangeError,50100:r.ExchangeError,50101:r.AuthenticationError,50102:r.InvalidNonce,50103:r.AuthenticationError,50104:r.AuthenticationError,50105:r.AuthenticationError,50106:r.AuthenticationError,50107:r.AuthenticationError,50108:r.ExchangeError,50109:r.ExchangeError,50110:r.PermissionDenied,50111:r.AuthenticationError,50112:r.AuthenticationError,50113:r.AuthenticationError,50114:r.AuthenticationError,50115:r.BadRequest,51e3:r.BadRequest,51001:r.BadSymbol,51002:r.BadSymbol,51003:r.BadRequest,51004:r.InvalidOrder,51005:r.InvalidOrder,51006:r.InvalidOrder,51007:r.InvalidOrder,51008:r.InsufficientFunds,51009:r.AccountSuspended,51010:r.AccountNotEnabled,51011:r.InvalidOrder,51012:r.BadSymbol,51014:r.BadSymbol,51015:r.BadSymbol,51016:r.InvalidOrder,51017:r.ExchangeError,51018:r.ExchangeError,51019:r.ExchangeError,51020:r.InvalidOrder,51021:r.ContractUnavailable,51022:r.ContractUnavailable,51023:r.ExchangeError,51024:r.AccountSuspended,51025:r.ExchangeError,51026:r.BadSymbol,51027:r.ContractUnavailable,51028:r.ContractUnavailable,51029:r.ContractUnavailable,51030:r.ContractUnavailable,51031:r.InvalidOrder,51046:r.InvalidOrder,51047:r.InvalidOrder,51072:r.InvalidOrder,51073:r.InvalidOrder,51074:r.InvalidOrder,51090:r.InvalidOrder,51091:r.InvalidOrder,51092:r.InvalidOrder,51093:r.InvalidOrder,51094:r.InvalidOrder,51095:r.InvalidOrder,51096:r.InvalidOrder,51098:r.InvalidOrder,51099:r.InvalidOrder,51100:r.InvalidOrder,51101:r.InvalidOrder,51102:r.InvalidOrder,51103:r.InvalidOrder,51104:r.InvalidOrder,51105:r.InvalidOrder,51106:r.InvalidOrder,51107:r.InvalidOrder,51108:r.InvalidOrder,51109:r.InvalidOrder,51110:r.InvalidOrder,51111:r.BadRequest,51112:r.InvalidOrder,51113:r.RateLimitExceeded,51115:r.InvalidOrder,51116:r.InvalidOrder,51117:r.InvalidOrder,51118:r.InvalidOrder,51119:r.InsufficientFunds,51120:r.InvalidOrder,51121:r.InvalidOrder,51122:r.InvalidOrder,51124:r.InvalidOrder,51125:r.InvalidOrder,51126:r.InvalidOrder,51127:r.InsufficientFunds,51128:r.InvalidOrder,51129:r.InvalidOrder,51130:r.BadSymbol,51131:r.InsufficientFunds,51132:r.InvalidOrder,51133:r.InvalidOrder,51134:r.InvalidOrder,51135:r.InvalidOrder,51136:r.InvalidOrder,51137:r.InvalidOrder,51138:r.InvalidOrder,51139:r.InvalidOrder,51156:r.BadRequest,51159:r.BadRequest,51162:r.InvalidOrder,51163:r.InvalidOrder,51166:r.InvalidOrder,51174:r.InvalidOrder,51185:r.InvalidOrder,51201:r.InvalidOrder,51202:r.InvalidOrder,51203:r.InvalidOrder,51204:r.InvalidOrder,51205:r.InvalidOrder,51250:r.InvalidOrder,51251:r.InvalidOrder,51252:r.InvalidOrder,51253:r.InvalidOrder,51254:r.InvalidOrder,51255:r.InvalidOrder,51256:r.InvalidOrder,51257:r.InvalidOrder,51258:r.InvalidOrder,51259:r.InvalidOrder,51260:r.InvalidOrder,51261:r.InvalidOrder,51262:r.InvalidOrder,51263:r.InvalidOrder,51264:r.InvalidOrder,51265:r.InvalidOrder,51267:r.InvalidOrder,51268:r.InvalidOrder,51269:r.InvalidOrder,51270:r.InvalidOrder,51271:r.InvalidOrder,51272:r.InvalidOrder,51273:r.InvalidOrder,51274:r.InvalidOrder,51275:r.InvalidOrder,51276:r.InvalidOrder,51277:r.InvalidOrder,51278:r.InvalidOrder,51279:r.InvalidOrder,51280:r.InvalidOrder,51321:r.InvalidOrder,51322:r.InvalidOrder,51323:r.BadRequest,51324:r.BadRequest,51325:r.InvalidOrder,51327:r.InvalidOrder,51328:r.InvalidOrder,51329:r.InvalidOrder,51330:r.InvalidOrder,51400:r.OrderNotFound,51401:r.OrderNotFound,51402:r.OrderNotFound,51403:r.InvalidOrder,51404:r.InvalidOrder,51405:r.ExchangeError,51406:r.ExchangeError,51407:r.BadRequest,51408:r.ExchangeError,51409:r.ExchangeError,51410:r.CancelPending,51500:r.ExchangeError,51501:r.ExchangeError,51502:r.InsufficientFunds,51503:r.ExchangeError,51506:r.ExchangeError,51508:r.ExchangeError,51509:r.ExchangeError,51510:r.ExchangeError,51511:r.ExchangeError,51600:r.ExchangeError,51601:r.ExchangeError,51602:r.ExchangeError,51603:r.OrderNotFound,51732:r.AuthenticationError,51733:r.AuthenticationError,51734:r.AuthenticationError,51735:r.ExchangeError,51736:r.InsufficientFunds,52e3:r.ExchangeError,54e3:r.ExchangeError,54001:r.ExchangeError,55100:r.InvalidOrder,55101:r.InvalidOrder,55102:r.InvalidOrder,55103:r.InvalidOrder,55104:r.InvalidOrder,55111:r.InvalidOrder,55112:r.InvalidOrder,55113:r.InvalidOrder,58e3:r.ExchangeError,58001:r.AuthenticationError,58002:r.PermissionDenied,58003:r.ExchangeError,58004:r.AccountSuspended,58005:r.ExchangeError,58006:r.ExchangeError,58007:r.ExchangeError,58100:r.ExchangeError,58101:r.AccountSuspended,58102:r.RateLimitExceeded,58103:r.ExchangeError,58104:r.ExchangeError,58105:r.ExchangeError,58106:r.ExchangeError,58107:r.ExchangeError,58108:r.ExchangeError,58109:r.ExchangeError,58110:r.ExchangeError,58111:r.ExchangeError,58112:r.ExchangeError,58114:r.ExchangeError,58115:r.ExchangeError,58116:r.ExchangeError,58117:r.ExchangeError,58125:r.BadRequest,58126:r.BadRequest,58127:r.BadRequest,58128:r.BadRequest,58200:r.ExchangeError,58201:r.ExchangeError,58202:r.ExchangeError,58203:r.InvalidAddress,58204:r.AccountSuspended,58205:r.ExchangeError,58206:r.ExchangeError,58207:r.InvalidAddress,58208:r.ExchangeError,58209:r.ExchangeError,58210:r.ExchangeError,58211:r.ExchangeError,58212:r.ExchangeError,58213:r.AuthenticationError,58221:r.BadRequest,58222:r.BadRequest,58224:r.BadRequest,58227:r.BadRequest,58228:r.BadRequest,58229:r.InsufficientFunds,58300:r.ExchangeError,58350:r.InsufficientFunds,59e3:r.ExchangeError,59001:r.ExchangeError,59100:r.ExchangeError,59101:r.ExchangeError,59102:r.ExchangeError,59103:r.InsufficientFunds,59104:r.ExchangeError,59105:r.ExchangeError,59106:r.ExchangeError,59107:r.ExchangeError,59108:r.InsufficientFunds,59109:r.ExchangeError,59128:r.InvalidOrder,59200:r.InsufficientFunds,59201:r.InsufficientFunds,59216:r.BadRequest,59260:r.PermissionDenied,59262:r.PermissionDenied,59300:r.ExchangeError,59301:r.ExchangeError,59313:r.ExchangeError,59401:r.ExchangeError,59500:r.ExchangeError,59501:r.ExchangeError,59502:r.ExchangeError,59503:r.ExchangeError,59504:r.ExchangeError,59505:r.ExchangeError,59506:r.ExchangeError,59507:r.ExchangeError,59508:r.AccountSuspended,59642:r.BadRequest,59643:r.ExchangeError,60001:r.AuthenticationError,60002:r.AuthenticationError,60003:r.AuthenticationError,60004:r.AuthenticationError,60005:r.AuthenticationError,60006:r.InvalidNonce,60007:r.AuthenticationError,60008:r.AuthenticationError,60009:r.AuthenticationError,60010:r.AuthenticationError,60011:r.AuthenticationError,60012:r.BadRequest,60013:r.BadRequest,60014:r.RateLimitExceeded,60015:r.NetworkError,60016:r.ExchangeNotAvailable,60017:r.BadRequest,60018:r.BadRequest,60019:r.BadRequest,60020:r.ExchangeError,60021:r.AccountNotEnabled,60022:r.AuthenticationError,60023:r.DDoSProtection,60024:r.AuthenticationError,60025:r.ExchangeError,60026:r.AuthenticationError,60027:r.ArgumentsRequired,60028:r.NotSupported,60029:r.AccountNotEnabled,60030:r.AccountNotEnabled,60031:r.AuthenticationError,60032:r.AuthenticationError,63999:r.ExchangeError,64e3:r.BadRequest,64001:r.BadRequest,64002:r.BadRequest,64003:r.AccountNotEnabled,70010:r.BadRequest,70013:r.BadRequest,70016:r.BadRequest,1009:r.BadRequest,4001:r.AuthenticationError,4002:r.BadRequest,4003:r.RateLimitExceeded,4004:r.NetworkError,4005:r.ExchangeNotAvailable,4006:r.BadRequest,4007:r.AuthenticationError,4008:r.RateLimitExceeded},broad:{"Internal Server Error":r.ExchangeNotAvailable,"server error":r.ExchangeNotAvailable}},httpExceptions:{429:r.ExchangeNotAvailable},precisionMode:o.kb,options:{sandboxMode:!1,defaultNetwork:"ERC20",defaultNetworks:{ETH:"ERC20",BTC:"BTC",USDT:"TRC20"},networks:{BTC:"Bitcoin",BTCLN:"Lightning",BEP20:"BSC",ERC20:"ERC20",TRC20:"TRC20",CRC20:"Crypto",ACA:"Acala",ALGO:"Algorand",BHP:"BHP",APT:"Aptos",ARBONE:"Arbitrum One",AVAXC:"Avalanche C",AVAXX:"Avalanche X-Chain",ARK:"ARK",AR:"Arweave",ASTR:"Astar",BCH:"BitcoinCash",BSV:"Bitcoin SV",BTM:"Bytom",ADA:"Cardano",CSPR:"Casper",CELO:"CELO",XCH:"Chia",CHZ:"Chiliz",ATOM:"Cosmos",TRUE:"TrueChain",DCR:"Decred",DGB:"Digibyte",DOGE:"Dogecoin",XEC:"XEC",EGLD:"Elrond",EOS:"EOS",ETC:"Ethereum Classic",ETHW:"EthereumPow",FTM:"Fantom",FIL:"Filecoin",FLOW:"FLOW",FSN:"Fusion",ONE:"Harmony",HBAR:"Hedera",HNT:"Helium",ZEN:"Horizen",ICX:"ICON",ICP:"Dfinity",IOST:"IOST",IOTA:"MIOTA",KDA:"Kadena",KAR:"KAR",KLAY:"Klaytn",KSM:"Kusama",LSK:"Lisk",LTC:"Litecoin",METIS:"Metis",MINA:"Mina",XMR:"Monero",GLRM:"Moonbeam",MOVR:"Moonriver",NANO:"Nano",NEAR:"NEAR",NAS:"Nebulas",NEM:"New Economy Movement",NULS:"NULS",OASYS:"OASYS",OKC:"OKC",ONT:"Ontology",OPTIMISM:"Optimism",LAT:"PlatON",DOT:"Polkadot",MATIC:"Polygon",RVN:"Ravencoin",XRP:"Ripple",SC:"Siacoin",SOL:"Solana",STX:"l-Stacks",XLM:"Stellar Lumens",XTZ:"Tezos",TON:"TON",THETA:"Theta",VSYS:"VSYSTEMS",WAVES:"WAVES",WAX:"Wax",ZEC:"Zcash",ZIL:"Zilliqa",ZKSYNC:"ZKSYNC",OMNI:"Omni"},fetchOpenInterestHistory:{timeframes:{"5m":"5m","1h":"1H","8h":"8H","1d":"1D","5M":"5m","1H":"1H","8H":"8H","1D":"1D"}},fetchOHLCV:{timezone:"UTC"},fetchPositions:{method:"privateGetAccountPositions"},createOrder:"privatePostTradeBatchOrders",createMarketBuyOrderRequiresPrice:!1,fetchMarkets:["spot","future","swap","option"],defaultType:"spot",fetchLedger:{method:"privateGetAccountBills"},fetchOrder:{method:"privateGetTradeOrder"},fetchOpenOrders:{method:"privateGetTradeOrdersPending"},cancelOrders:{method:"privatePostTradeCancelBatchOrders"},fetchCanceledOrders:{method:"privateGetTradeOrdersHistory"},fetchClosedOrders:{method:"privateGetTradeOrdersHistory"},withdraw:{password:void 0,pwd:void 0},algoOrderTypes:{conditional:!0,trigger:!0,oco:!0,move_order_stop:!0,iceberg:!0,twap:!0},accountsByType:{funding:"6",trading:"18",spot:"18",future:"18",futures:"18",margin:"18",swap:"18",option:"18"},accountsById:{6:"funding",18:"trading"},exchangeType:{spot:"SPOT",margin:"MARGIN",swap:"SWAP",future:"FUTURES",futures:"FUTURES",option:"OPTION",SPOT:"SPOT",MARGIN:"MARGIN",SWAP:"SWAP",FUTURES:"FUTURES",OPTION:"OPTION"},brokerId:"e847386590ce4dBC"},commonCurrencies:{AE:"AET",WIN:"WINTOKEN"}})}handleMarketTypeAndParams(e,t=void 0,s={},i=void 0){const r=this.safeString(s,"instType");s=this.omit(s,"instType");return void 0===this.safeString(s,"type")&&void 0!==r&&(s.type=r),super.handleMarketTypeAndParams(e,t,s,i)}convertToInstrumentType(e){const t=this.safeDict(this.options,"exchangeType",{});return this.safeString(t,e,e)}createExpiredOptionMarket(e){const t="USD",s=e.split("-"),i=e.split("/");let r;r=e.indexOf("/")>-1?this.safeString(i,0):this.safeString(s,0);const a=r,o=this.safeString(s,2),n=this.safeString(s,3),d=this.safeString(s,4),h=this.convertExpireDate(o),c=this.parse8601(h);return{id:r+"-"+t+"-"+o+"-"+n+"-"+d,symbol:r+"/"+t+":"+a+"-"+o+"-"+n+"-"+d,base:r,quote:t,settle:a,baseId:r,quoteId:t,settleId:a,active:!1,type:"option",linear:void 0,inverse:void 0,spot:!1,swap:!1,future:!1,option:!0,margin:!1,contract:!0,contractSize:this.parseNumber("1"),expiry:c,expiryDatetime:h,optionType:"C"===d?"call":"put",strike:this.parseNumber(n),precision:{amount:void 0,price:void 0},limits:{amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},info:void 0}}safeMarket(e=void 0,t=void 0,s=void 0,i=void 0){return void 0!==e&&(e.indexOf("-C")>-1||e.indexOf("-P")>-1)&&!(e in this.markets_by_id)?this.createExpiredOptionMarket(e):super.safeMarket(e,t,s,i)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e),s=this.safeList(t,"data",[]),i={updated:void 0,status:0===s.length?"ok":"maintenance",eta:void 0,url:void 0,info:t};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"state");i.eta=this.safeInteger(t,"end"),i.url=this.safeString(t,"href"),"ongoing"===r?i.status="maintenance":("scheduled"===r||"completed"===r||"canceled"===r)&&(i.status="ok")}return i}async fetchTime(e={}){const t=await this.publicGetPublicTime(e),s=this.safeList(t,"data",[]),i=this.safeDict(s,0,{});return this.safeInteger(i,"ts")}async fetchAccounts(e={}){const t=await this.privateGetAccountConfig(e),s=this.safeList(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"uid"),a=this.safeString(t,"acctLv");i.push({id:r,type:a,currency:void 0,info:t,code:void 0})}return i}async fetchMarkets(e={}){const t=this.safeList(this.options,"fetchMarkets",[]);let s=[],i=[];for(let i=0;i<t.length;i++)s.push(this.fetchMarketsByType(t[i],e));s=await Promise.all(s);for(let e=0;e<s.length;e++)i=this.arrayConcat(i,s[e]);return i}parseMarket(e){const t=this.safeString(e,"instId");let s=this.safeStringLower(e,"instType");"futures"===s&&(s="future");const i="spot"===s,r="future"===s,o="swap"===s,n="option"===s,d=o||r||n;let h=this.safeString(e,"baseCcy"),c=this.safeString(e,"quoteCcy");const l=this.safeString(e,"settleCcy"),u=this.safeCurrencyCode(l),p=this.safeString(e,"uly");if(void 0!==p&&!i){const e=p.split("-");h=this.safeString(e,0),c=this.safeString(e,1)}const f=this.safeCurrencyCode(h),m=this.safeCurrencyCode(c);let g,v,y,w=f+"/"+m;if(d)if(w=w+":"+u,g=this.safeInteger(e,"expTime"),r){w=w+"-"+this.yymmdd(g)}else if(n){v=this.safeString(e,"stk"),y=this.safeString(e,"optType");w=w+"-"+this.yymmdd(g)+"-"+v+"-"+y,y="P"===y?"put":"call"}const b=this.safeString(e,"tickSz"),S=this.safeDict2(this.fees,s,"trading",{});let k=this.safeString(e,"lever","1");k=a.Y.stringMax(k,"1");const O=this.safeNumber(e,"maxMktSz");return this.extend(S,{id:t,symbol:w,base:f,quote:m,settle:u,baseId:h,quoteId:c,settleId:l,type:s,spot:i,margin:i&&a.Y.stringGt(k,"1"),swap:o,future:r,option:n,active:!0,contract:d,linear:d?c===l:void 0,inverse:d?h===l:void 0,contractSize:d?this.safeNumber(e,"ctVal"):void 0,expiry:g,expiryDatetime:this.iso8601(g),strike:v,optionType:y,created:this.safeInteger(e,"listTime"),precision:{amount:this.safeNumber(e,"lotSz"),price:this.parseNumber(b)},limits:{leverage:{min:this.parseNumber("1"),max:this.parseNumber(k)},amount:{min:this.safeNumber(e,"minSz"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:d?void 0:O}},info:e})}async fetchMarketsByType(e,t={}){const s={instType:this.convertToInstrumentType(e)};if("option"===e){const e=this.safeList(this.options,"defaultUnderlying",["BTC-USD","ETH-USD"]),i=[];for(let r=0;r<e.length;r++){const a=e[r];s.uly=a,i.push(this.publicGetPublicInstruments(this.extend(s,t)))}const r=await Promise.all(i);let a=[];for(let e=0;e<r.length;e++){const t=this.safeDict(r,e,{}),s=this.safeList(t,"data",[]);a=this.arrayConcat(a,s)}return this.parseMarkets(a)}const i=await this.publicGetPublicInstruments(this.extend(s,t)),r=this.safeList(i,"data",[]);return this.parseMarkets(r)}async fetchCurrencies(e={}){const t=this.safeBool(this.options,"sandboxMode",!1);if(!this.checkRequiredCredentials(!1)||t)return;const s=await this.privateGetAssetCurrencies(e),i=this.safeList(s,"data",[]),r={},o=this.groupBy(i,"ccy"),n=Object.keys(o);for(let e=0;e<n.length;e++){const t=n[e],s=this.safeCurrency(t),i=s.code,d=o[t],h={};let c,l=!1,u=!1,p=!1;for(let e=0;e<d.length;e++){const t=d[e],i=this.safeBool(t,"canDep");u=i||u;const r=this.safeBool(t,"canWd");p=r||p;const o=this.safeBool(t,"canInternal"),n=!!(i&&r&&o);l=n||l;const f=this.safeString(t,"chain");if(void 0!==f&&f.indexOf("-")>=0){const e=f.split("-"),o=this.safeString(e,1,f),d=this.networkIdToCode(o,s.code),l=this.parsePrecision(this.safeString(t,"wdTickSz"));c=void 0===c?l:a.Y.stringMin(c,l),h[d]={id:f,network:d,active:n,deposit:i,withdraw:r,fee:this.safeNumber(t,"minFee"),precision:this.parseNumber(l),limits:{withdraw:{min:this.safeNumber(t,"minWd"),max:this.safeNumber(t,"maxWd")}},info:t}}}const f=this.safeDict(d,0,{});r[i]={info:void 0,code:i,id:t,name:this.safeString(f,"name"),active:l,deposit:u,withdraw:p,fee:void 0,precision:this.parseNumber(c),limits:{amount:{min:void 0,max:void 0}},networks:h}}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={instId:this.market(e).id};let r,a;[r,s]=this.handleOptionAndParams(s,"fetchOrderBook","method","publicGetMarketBooks"),"publicGetMarketBooksFull"===r&&void 0===t&&(t=5e3),void 0!==(t=void 0===t?100:t)&&(i.sz=t),a="publicGetMarketBooksFull"===r||t>400?await this.publicGetMarketBooksFull(this.extend(i,s)):await this.publicGetMarketBooks(this.extend(i,s));const o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{}),d=this.safeInteger(n,"ts");return this.parseOrderBook(n,e,d)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,a=this.safeString(e,"last"),o=this.safeString(e,"open24h"),n=this.safeBool(t,"spot",!1)?this.safeString(e,"volCcy24h"):void 0,d=this.safeString(e,"vol24h"),h=this.safeString(e,"high24h"),c=this.safeString(e,"low24h");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:h,low:c,bid:this.safeString(e,"bidPx"),bidVolume:this.safeString(e,"bidSz"),ask:this.safeString(e,"askPx"),askVolume:this.safeString(e,"askSz"),vwap:void 0,open:o,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},r=await this.publicGetMarketTicker(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.getMarketFromSymbols(e);let i;[i,t]=this.handleMarketTypeAndParams("fetchTickers",s,t);const a={instType:this.convertToInstrumentType(i)};if("option"===i){const e=this.safeString(this.options,"defaultUnderlying","BTC-USD"),s=this.safeString2(t,"uly","marketId",e);if(void 0===s)throw new r.ArgumentsRequired(this.id+" fetchTickers() requires an underlying uly or marketId parameter for options markets");a.uly=s}const o=await this.publicGetMarketTickers(this.extend(a,t)),n=this.safeList(o,"data",[]);return this.parseTickers(n,e)}parseTrade(e,t=void 0){const s=this.safeString(e,"tradeId"),i=this.safeString(e,"instId"),r=(t=this.safeMarket(i,t,"-")).symbol,o=this.safeInteger(e,"ts"),n=this.safeString2(e,"fillPx","px"),d=this.safeString2(e,"fillSz","sz"),h=this.safeString(e,"side"),c=this.safeString(e,"ordId"),l=this.safeString(e,"fee");let u;if(void 0!==l){const t=a.Y.stringNeg(l),s=this.safeString(e,"feeCcy");u={cost:t,currency:this.safeCurrencyCode(s)}}let p=this.safeString(e,"execType");return"T"===p?p="taker":"M"===p&&(p="maker"),this.safeTrade({info:e,timestamp:o,datetime:this.iso8601(o),symbol:r,id:s,order:c,type:void 0,takerOrMaker:p,side:h,price:n,amount:d,cost:void 0,fee:u},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchTrades",e,t,s,i,"tradeId","after",void 0,100);const a=this.market(e),o={instId:a.id};let n;if(a.option)n=await this.publicGetPublicOptionTrades(this.extend(o,i));else{let e;void 0!==s&&(o.limit=s),[e,i]=this.handleOptionAndParams(i,"fetchTrades","method","publicGetMarketTrades"),"publicGetMarketTrades"===e?n=await this.publicGetMarketTrades(this.extend(o,i)):"publicGetMarketHistoryTrades"===e&&(n=await this.publicGetMarketHistoryTrades(this.extend(o,i)))}const d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}parseOHLCV(e,t=void 0){const s="spot"===this.handleMarketTypeAndParams("fetchOHLCV",t,void 0)[0]?5:6;return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,s)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);let o=!1;if([o,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate"),o)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,200);const n=this.safeString(r,"price");r=this.omit(r,"price");const d=this.safeDict(this.options,"fetchOHLCV",{}),h=this.safeString(d,"timezone","UTC");void 0===i&&(i=100);const c=this.parseTimeframe(t);let l=this.safeString(this.timeframes,t,t);"UTC"===h&&c>=21600&&(l+=h.toLowerCase());const u={instId:a.id,bar:l,limit:i};let p="Candles";if(void 0!==s){const e=1e3*c;s<this.milliseconds()-1439*e&&(p="HistoryCandles");const t=Math.max(s-1,0);u.before=t,u.after=this.sum(s,e*i)}const f=this.safeInteger(r,"until");void 0!==f&&(u.after=f,r=this.omit(r,"until")),p=this.safeString(d,"type",p);const m=this.safeString(r,"type",p);r=this.omit(r,"type");const g="HistoryCandles"===m;let v;"mark"===n?v=g?await this.publicGetMarketHistoryMarkPriceCandles(this.extend(u,r)):await this.publicGetMarketMarkPriceCandles(this.extend(u,r)):"index"===n?(u.instId=a.info.instFamily,v=g?await this.publicGetMarketHistoryIndexCandles(this.extend(u,r)):await this.publicGetMarketIndexCandles(this.extend(u,r))):v=g?await this.publicGetMarketHistoryCandles(this.extend(u,r)):await this.publicGetMarketCandles(this.extend(u,r));const y=this.safeList(v,"data",[]);return this.parseOHLCVs(y,a,t,s,i)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();let a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),a)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,100);const o=this.market(e),n={instId:o.id};void 0!==t&&(n.before=Math.max(t-1,0)),void 0!==s&&(n.limit=s);const d=await this.publicGetPublicFundingRateHistory(this.extend(n,i)),h=[],c=this.safeList(d,"data",[]);for(let e=0;e<c.length;e++){const t=c[e],s=this.safeInteger(t,"fundingTime");h.push({info:t,symbol:this.safeSymbol(this.safeString(t,"instId")),fundingRate:this.safeNumber(t,"realizedRate"),timestamp:s,datetime:this.iso8601(s)})}const l=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(l,o.symbol,t,s)}parseBalanceByType(e,t){return"funding"===e?this.parseFundingBalance(t):this.parseTradingBalance(t)}parseTradingBalance(e){const t={info:e},s=this.safeList(e,"data",[]),i=this.safeDict(s,0,{}),r=this.safeInteger(i,"uTime"),a=this.safeList(i,"details",[]);for(let e=0;e<a.length;e++){const s=a[e],i=this.safeString(s,"ccy"),r=this.safeCurrencyCode(i),o=this.account(),n=this.safeString(s,"eq"),d=this.safeString(s,"availEq");void 0===n||void 0===d?(o.free=this.safeString(s,"availBal"),o.used=this.safeString(s,"frozenBal")):(o.total=n,o.free=d),t[r]=o}return t.timestamp=r,t.datetime=this.iso8601(r),this.safeBalance(t)}parseFundingBalance(e){const t={info:e},s=this.safeList(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"ccy"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"bal"),o.free=this.safeString(i,"availBal"),o.used=this.safeString(i,"frozenBal"),t[a]=o}return this.safeBalance(t)}parseTradingFee(e,t=void 0){return{info:e,symbol:this.safeSymbol(void 0,t),maker:this.parseNumber(a.Y.stringNeg(this.safeString2(e,"maker","makerU"))),taker:this.parseNumber(a.Y.stringNeg(this.safeString2(e,"taker","takerU"))),percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={instType:this.convertToInstrumentType(s.type)};if(s.spot)i.instId=s.id;else{if(!(s.swap||s.future||s.option))throw new r.NotSupported(this.id+" fetchTradingFee() supports spot, swap, future or option markets only");i.uly=s.baseId+"-"+s.quoteId}const a=await this.privateGetAccountTradeFee(this.extend(i,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseTradingFee(n,s)}async fetchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),i={};let r;return r="funding"===t?await this.privateGetAssetBalances(this.extend(i,s)):await this.privateGetAccountBalance(this.extend(i,s)),this.parseBalanceByType(t,r)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot markets only");return s.createMarketBuyOrderRequiresPrice=!1,s.tgtCcy="quote_ccy",await this.createOrder(e,"market","buy",t,void 0,s)}async createMarketSellOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketSellOrderWithCost() supports spot markets only");return s.createMarketBuyOrderRequiresPrice=!1,s.tgtCcy="quote_ccy",await this.createOrder(e,"market","sell",t,void 0,s)}createOrderRequest(e,t,s,i,o=void 0,n={}){const d=this.market(e),h={instId:d.id,side:s,ordType:t,sz:this.amountToPrecision(e,i)},c=d.spot,l=d.contract,u=this.safeValueN(n,["triggerPrice","stopPrice","triggerPx"]),p=this.safeString(n,"timeInForce","GTC"),f=this.safeValue2(n,"takeProfitPrice","tpTriggerPx"),m=this.safeValue(n,"tpOrdPx",o),g=this.safeString(n,"tpTriggerPxType","last"),v=this.safeValue2(n,"stopLossPrice","slTriggerPx"),y=this.safeValue(n,"slOrdPx",o),w=this.safeString(n,"slTriggerPxType","last"),b=this.safeString2(n,"clOrdId","clientOrderId"),S=this.safeValue(n,"stopLoss"),k=void 0!==S,O=this.safeValue(n,"takeProfit"),T=void 0!==O,P=this.safeString2(n,"trailingPercent","callbackRatio"),I=void 0!==P,x=void 0!==u||"trigger"===t,A=this.safeValue(n,"reduceOnly",!1),M=this.safeString2(this.options,"defaultMarginMode","marginMode","cross");let C=this.safeString2(n,"marginMode","tdMode"),E=!1;if(void 0!==C&&"cash"!==C?E=!0:(C=M,E=this.safeBool(n,"margin",!1)),c){if(E){const e="buy"===s?d.quote:d.base,t=this.safeString(n,"ccy",e);h.ccy=this.safeCurrencyCode(t)}const e=E?C:"cash";h.tdMode=e}else if(l){if(d.swap||d.future){let e;if([e,n]=this.handleOptionAndParams(n,"createOrder","positionSide"),void 0!==e)h.posSide=e;else{let e;if([e,n]=this.handleOptionAndParams(n,"createOrder","hedged"),e){const e="buy"===s;void 0!==f||void 0!==v||A?(h.posSide=e?"short":"long",A&&(n=this.omit(n,"reduceOnly"))):h.posSide=e?"long":"short"}}}h.tdMode=C}const _="market"===t;let B=!1;[B,n]=this.handlePostOnly(_,"post_only"===t,n),n=this.omit(n,["currency","ccy","marginMode","timeInForce","stopPrice","triggerPrice","clientOrderId","stopLossPrice","takeProfitPrice","slOrdPx","tpOrdPx","margin","stopLoss","takeProfit","trailingPercent"]);const N="IOC"===p||"ioc"===t,R="FOK"===p||"fok"===t,L=void 0!==v||void 0!==f||"conditional"===t,V=_&&N||"optimal_limit_ioc"===t,D=this.safeString(this.options,"tgtCcy","base_ccy"),q=this.safeString(n,"tgtCcy",D);if(l||E||(h.tgtCcy=q),_||V){if(h.ordType="market",c&&"buy"===s&&"quote_ccy"===q){let t=!0;[t,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);let s=this.safeNumber2(n,"cost","sz");if(n=this.omit(n,["cost","sz"]),t){if(void 0!==o){if(void 0===s){const e=this.numberToString(i),t=this.numberToString(o),r=a.Y.stringMul(e,t);s=this.parseNumber(r)}}else if(void 0===s)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'cost' unified extra parameter or in exchange-specific 'sz' extra parameter (the exchange-specific behaviour)")}else s=void 0===s?i:s;h.sz=this.costToPrecision(e,s)}V&&l&&(h.ordType="optimal_limit_ioc")}else x||L||(h.px=this.priceToPrecision(e,o));if(B?h.ordType="post_only":N&&!V?h.ordType="ioc":R&&(h.ordType="fok"),I){const e=a.Y.stringDiv(P,"100");h.callbackRatio=e,h.ordType="move_order_stop"}else if(k||T){if(k){const t=this.safeValueN(S,["triggerPrice","stopPrice","slTriggerPx"]);if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["stopLoss"]["triggerPrice"], or params["stopLoss"]["stopPrice"], or params["stopLoss"]["slTriggerPx"] for a stop loss order');h.slTriggerPx=this.priceToPrecision(e,t);const s=this.safeValueN(S,["price","stopLossPrice","slOrdPx"]),i=this.safeString(S,"type");if(void 0!==i){const t="limit"===i;if(!t&&!("market"===i))throw new r.InvalidOrder(this.id+' createOrder() params["stopLoss"]["type"] must be either "limit" or "market"');if(t){if(void 0===s)throw new r.InvalidOrder(this.id+' createOrder() requires a limit price in params["stopLoss"]["price"] or params["stopLoss"]["slOrdPx"] for a stop loss limit order');h.slOrdPx=this.priceToPrecision(e,s)}else"market"===i&&(h.slOrdPx="-1")}else h.slOrdPx=void 0!==s?this.priceToPrecision(e,s):"-1";const a=this.safeString2(S,"triggerPriceType","slTriggerPxType","last");if(void 0!==a){if("last"!==a&&"index"!==a&&"mark"!==a)throw new r.InvalidOrder(this.id+' createOrder() stop loss trigger price type must be one of "last", "index" or "mark"');h.slTriggerPxType=a}}if(T){const t=this.safeValueN(O,["triggerPrice","stopPrice","tpTriggerPx"]);if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["takeProfit"]["triggerPrice"], or params["takeProfit"]["stopPrice"], or params["takeProfit"]["tpTriggerPx"] for a take profit order');h.tpTriggerPx=this.priceToPrecision(e,t);const s=this.safeValueN(O,["price","takeProfitPrice","tpOrdPx"]),i=this.safeString2(O,"type","tpOrdKind");if(void 0!==i){const t="limit"===i;if(!t&&!("market"===i))throw new r.InvalidOrder(this.id+' createOrder() params["takeProfit"]["type"] must be either "limit" or "market"');if(t){if(void 0===s)throw new r.InvalidOrder(this.id+' createOrder() requires a limit price in params["takeProfit"]["price"] or params["takeProfit"]["tpOrdPx"] for a take profit limit order');h.tpOrdKind=i,h.tpOrdPx=this.priceToPrecision(e,s)}else"market"===i&&(h.tpOrdPx="-1")}else void 0!==s?(h.tpOrdKind="limit",h.tpOrdPx=this.priceToPrecision(e,s)):h.tpOrdPx="-1";const a=this.safeString2(O,"triggerPriceType","tpTriggerPxType","last");if(void 0!==a){if("last"!==a&&"index"!==a&&"mark"!==a)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "last", "index" or "mark"');h.tpTriggerPxType=a}}}else if(x)h.ordType="trigger",h.triggerPx=this.priceToPrecision(e,u),h.orderPx=_?"-1":this.priceToPrecision(e,o);else if(L){h.ordType="conditional";void 0!==f&&void 0!==v&&(h.ordType="oco"),void 0!==f&&(h.tpTriggerPx=this.priceToPrecision(e,f),h.tpOrdPx=void 0===m?"-1":this.priceToPrecision(e,m),h.tpTriggerPxType=g),void 0!==v&&(h.slTriggerPx=this.priceToPrecision(e,v),h.slOrdPx=void 0===y?"-1":this.priceToPrecision(e,y),h.slTriggerPxType=w)}if(void 0===b){const e=this.safeString(this.options,"brokerId");void 0!==e&&(h.clOrdId=e+this.uuid16(),h.tag=e)}else h.clOrdId=b,n=this.omit(n,["clOrdId","clientOrderId"]);return this.extend(h,n)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);let d=this.createOrderRequest(e,t,s,i,a,o),h=this.safeString(this.options,"createOrder","privatePostTradeBatchOrders");const c=this.safeString(d,"ordType");if("trigger"!==c&&"conditional"!==c&&"move_order_stop"!==c&&"move_order_stop"!==t&&"oco"!==t&&"iceberg"!==t&&"twap"!==t||(h="privatePostTradeOrderAlgo"),"privatePostTradeOrder"!==h&&"privatePostTradeOrderAlgo"!==h&&"privatePostTradeBatchOrders"!==h)throw new r.ExchangeError(this.id+' createOrder() this.options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder or privatePostTradeOrderAlgo');let l;"privatePostTradeBatchOrders"===h&&(d=[d]),l="privatePostTradeOrder"===h?await this.privatePostTradeOrder(d):"privatePostTradeOrderAlgo"===h?await this.privatePostTradeOrderAlgo(d):await this.privatePostTradeBatchOrders(d);const u=this.safeList(l,"data",[]),p=this.safeDict(u,0,{}),f=this.parseOrder(p,n);return f.type=t,f.side=s,f}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"symbol"),o=this.safeString(r,"type"),n=this.safeString(r,"side"),d=this.safeValue(r,"amount"),h=this.safeValue(r,"price"),c=this.safeDict(r,"params",{}),l=this.extend(c,t),u=this.createOrderRequest(a,o,n,d,h,l);s.push(u)}const i=await this.privatePostTradeBatchOrders(s),r=this.safeList(i,"data",[]);return this.parseOrders(r)}editOrderRequest(e,t,s,i,a=void 0,o=void 0,n={}){const d={instId:this.market(t).id};let h;"trigger"!==s&&"conditional"!==s&&"move_order_stop"!==s&&"oco"!==s&&"iceberg"!==s&&"twap"!==s||(h=!0);const c=this.safeString2(n,"clOrdId","clientOrderId");void 0!==c?h?d.algoClOrdId=c:d.clOrdId=c:h?d.algoId=e:d.ordId=e;let l=this.safeValue2(n,"stopLossPrice","newSlTriggerPx"),u=this.safeValue(n,"newSlOrdPx");const p=this.safeString(n,"newSlTriggerPxType","last");let f=this.safeValue2(n,"takeProfitPrice","newTpTriggerPx"),m=this.safeValue(n,"newTpOrdPx");const g=this.safeString(n,"newTpTriggerPxType","last"),v=this.safeValue(n,"stopLoss"),y=this.safeValue(n,"takeProfit"),w=void 0!==v,b=void 0!==y;if(h){if(void 0===l&&void 0===f)throw new r.BadRequest(this.id+" editOrder() requires a stopLossPrice or takeProfitPrice parameter for editing an algo order");if(void 0!==l){if(void 0===u)throw new r.BadRequest(this.id+" editOrder() requires a newSlOrdPx parameter for editing an algo order");d.newSlTriggerPx=this.priceToPrecision(t,l),d.newSlOrdPx="market"===s?"-1":this.priceToPrecision(t,u),d.newSlTriggerPxType=p}if(void 0!==f){if(void 0===m)throw new r.BadRequest(this.id+" editOrder() requires a newTpOrdPx parameter for editing an algo order");d.newTpTriggerPx=this.priceToPrecision(t,f),d.newTpOrdPx="market"===s?"-1":this.priceToPrecision(t,m),d.newTpTriggerPxType=g}}else{if(void 0!==l&&(d.newSlTriggerPx=this.priceToPrecision(t,l),d.newSlOrdPx="market"===s?"-1":this.priceToPrecision(t,u),d.newSlTriggerPxType=p),void 0!==f&&(d.newTpTriggerPx=this.priceToPrecision(t,f),d.newTpOrdPx="market"===s?"-1":this.priceToPrecision(t,m),d.newTpTriggerPxType=g),w){l=this.safeValue(v,"triggerPrice"),u=this.safeValue(v,"price");const e=this.safeString(v,"type");d.newSlTriggerPx=this.priceToPrecision(t,l),d.newSlOrdPx="market"===e?"-1":this.priceToPrecision(t,u),d.newSlTriggerPxType=p}if(b){f=this.safeValue(y,"triggerPrice"),m=this.safeValue(y,"price");const e=this.safeString(y,"type");d.newTpOrdKind="limit"===e?e:"condition",d.newTpTriggerPx=this.priceToPrecision(t,f),d.newTpOrdPx="market"===e?"-1":this.priceToPrecision(t,m),d.newTpTriggerPxType=g}}return void 0!==a&&(d.newSz=this.amountToPrecision(t,a)),h||void 0!==o&&(d.newPx=this.priceToPrecision(t,o)),n=this.omit(n,["clOrdId","clientOrderId","takeProfitPrice","stopLossPrice","stopLoss","takeProfit"]),this.extend(d,n)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editOrderRequest(e,t,s,i,r,a,o);let h,c;"trigger"!==s&&"conditional"!==s&&"move_order_stop"!==s&&"oco"!==s&&"iceberg"!==s&&"twap"!==s||(h=!0),c=h?await this.privatePostTradeAmendAlgos(this.extend(d,o)):await this.privatePostTradeAmendOrder(this.extend(d,o));const l=this.safeList(c,"data",[]),u=this.safeDict(l,0,{}),p=this.parseOrder(u,n);return p.type=s,p.side=i,p}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const i=this.safeValue2(s,"stop","trigger"),a=this.safeBool(s,"trailing",!1);if(i||a){const i=await this.cancelOrders([e],t,s);return this.safeValue(i,0)}await this.loadMarkets();const o=this.market(t),n={instId:o.id},d=this.safeString2(s,"clOrdId","clientOrderId");void 0!==d?n.clOrdId=d:n.ordId=e;const h=this.omit(s,["clOrdId","clientOrderId"]),c=await this.privatePostTradeCancelOrder(this.extend(n,h)),l=this.safeValue(c,"data",[]),u=this.safeDict(l,0);return this.parseOrder(u,o)}parseIds(e){return void 0!==e&&"string"==typeof e?e.split(","):e}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a=[],o=this.safeValue(this.options,"cancelOrders",{}),n=this.safeString(o,"method","privatePostTradeCancelBatchOrders");let d=this.safeString(s,"method",n);const h=this.parseIds(this.safeValue2(s,"clOrdId","clientOrderId")),c=this.parseIds(this.safeValue(s,"algoId")),l=this.safeValue2(s,"stop","trigger"),u=this.safeBool(s,"trailing",!1);if((l||u)&&(d="privatePostTradeCancelAlgos"),void 0===h){if(e=this.parseIds(e),void 0!==c)for(let e=0;e<c.length;e++)a.push({algoId:c[e],instId:i.id});for(let t=0;t<e.length;t++)u||l?a.push({algoId:e[t],instId:i.id}):a.push({ordId:e[t],instId:i.id})}else for(let e=0;e<h.length;e++)a.push({instId:i.id,clOrdId:h[e]});let p;p="privatePostTradeCancelAlgos"===d?await this.privatePostTradeCancelAlgos(a):await this.privatePostTradeCancelBatchOrders(a);const f=this.safeList(p,"data",[]);return this.parseOrders(f,i,void 0,void 0,s)}async cancelOrdersForSymbols(e,t={}){await this.loadMarkets();const s=[],i=this.safeDict(this.options,"cancelOrders",{}),r=this.safeString(i,"method","privatePostTradeCancelBatchOrders");let a=this.safeString(t,"method",r);const o=this.safeBool2(t,"stop","trigger"),n=this.safeBool(t,"trailing",!1),d=o||n;d&&(a="privatePostTradeCancelAlgos");for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"id"),a=this.safeString2(i,"clOrdId","clientOrderId"),o=this.safeString(i,"symbol");let n="ordId";d?n="algoId":void 0!==a&&(n="clOrdId");const h={instId:this.market(o).id};h[n]=void 0!==a?a:r,s.push(h)}let h;h="privatePostTradeCancelAlgos"===a?await this.privatePostTradeCancelAlgos(s):await this.privatePostTradeCancelBatchOrders(s);const c=this.safeList(h,"data",[]);return this.parseOrders(c,void 0,void 0,void 0,t)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={timeOut:e>0?this.parseToInt(e/1e3):0};return await this.privatePostTradeCancelAllAfter(this.extend(s,t))}parseOrderStatus(e){return this.safeString({canceled:"canceled",order_failed:"canceled",live:"open",partially_filled:"open",filled:"closed",effective:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"sCode");if(void 0!==s&&"0"!==s)return this.safeOrder({id:this.safeString(e,"ordId"),clientOrderId:this.safeString(e,"clOrdId"),status:"rejected",info:e});const i=this.safeString2(e,"algoId","ordId"),r=this.safeInteger(e,"cTime"),o=this.safeInteger(e,"uTime"),n=this.safeInteger(e,"fillTime"),d=this.safeString(e,"side");let h,c,l=this.safeString(e,"ordType");"post_only"===l?(h=!0,l="limit"):"fok"===l?(c="FOK",l="limit"):"ioc"===l&&(c="IOC",l="limit");const u=this.safeString(e,"instId");t=this.safeMarket(u,t);const p=this.safeSymbol(u,t,"-"),f=this.safeString(e,"accFillSz"),m=this.safeString2(e,"px","ordPx"),g=this.safeString(e,"avgPx"),v=this.parseOrderStatus(this.safeString(e,"state")),y=this.safeString(e,"fee");let w,b;const S=this.safeString(this.options,"tgtCcy","base_ccy"),k=this.safeString(e,"tgtCcy",S),O=this.safeString(e,"instType");let T;if("buy"===d&&"market"===l&&"SPOT"===O&&"quote_ccy"===k?b=this.safeString(e,"sz"):w=this.safeString(e,"sz"),void 0!==y){const t=a.Y.stringNeg(y),s=this.safeString(e,"feeCcy"),i=this.safeCurrencyCode(s);T={cost:this.parseNumber(t),currency:i}}let P=this.safeString(e,"clOrdId");void 0!==P&&P.length<1&&(P=void 0);const I=this.safeNumber2(e,"slTriggerPx","slOrdPx"),x=this.safeNumber2(e,"tpTriggerPx","tpOrdPx"),A=this.safeNumberN(e,["triggerPx","moveTriggerPx"]),M=this.safeString(e,"reduceOnly");let C=!1;return void 0!==C&&(C="true"===M),this.safeOrder({info:e,id:i,clientOrderId:P,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:n,lastUpdateTimestamp:o,symbol:p,type:l,timeInForce:c,postOnly:h,side:d,price:m,stopLossPrice:I,takeProfitPrice:x,stopPrice:A,triggerPrice:A,average:g,cost:b,amount:w,filled:f,remaining:void 0,status:v,fee:T,trades:void 0,reduceOnly:C},t)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={instId:i.id},o=this.safeString2(s,"clOrdId","clientOrderId"),n=this.safeValue(this.options,"fetchOrder",{}),d=this.safeString(n,"method","privateGetTradeOrder");let h=this.safeString(s,"method",d);this.safeValue2(s,"stop","trigger")?(h="privateGetTradeOrderAlgo",void 0!==o?a.algoClOrdId=o:a.algoId=e):void 0!==o?a.clOrdId=o:a.ordId=e;const c=this.omit(s,["method","clOrdId","clientOrderId","stop","trigger"]);let l;l="privateGetTradeOrderAlgo"===h?await this.privateGetTradeOrderAlgo(this.extend(a,c)):await this.privateGetTradeOrder(this.extend(a,c));const u=this.safeValue(l,"data",[]),p=this.safeDict(u,0);return this.parseOrder(p,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOpenOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchOpenOrders",e,t,s,i);const a={};let o;void 0!==e&&(o=this.market(e),a.instId=o.id),void 0!==s&&(a.limit=s);const n=this.safeValue(this.options,"fetchOpenOrders",{}),d=this.safeValue(this.options,"algoOrderTypes",{}),h=this.safeString(n,"method","privateGetTradeOrdersPending");let c=this.safeString(i,"method",h);const l=this.safeString(i,"ordType"),u=this.safeValue2(i,"stop","trigger"),p=this.safeBool(i,"trailing",!1);(p||u||l in d)&&(c="privateGetTradeOrdersAlgoPending"),p?a.ordType="move_order_stop":u&&void 0===l&&(a.ordType="trigger");const f=this.omit(i,["method","stop","trigger","trailing"]);let m;m="privateGetTradeOrdersAlgoPending"===c?await this.privateGetTradeOrdersAlgoPending(this.extend(a,f)):await this.privateGetTradeOrdersPending(this.extend(a,f));const g=this.safeList(m,"data",[]);return this.parseOrders(g,o,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o,n,d;void 0!==e&&(o=this.market(e),a.instId=o.id),[n,d]=this.handleMarketTypeAndParams("fetchCanceledOrders",o,i),a.instType=this.convertToInstrumentType(n),void 0!==s&&(a.limit=s),a.state="canceled";const h=this.safeValue(this.options,"fetchCanceledOrders",{}),c=this.safeValue(this.options,"algoOrderTypes",{}),l=this.safeString(h,"method","privateGetTradeOrdersHistory");let u=this.safeString(i,"method",l);const p=this.safeString(i,"ordType"),f=this.safeValue2(i,"stop","trigger");if(this.safeBool(i,"trailing",!1))u="privateGetTradeOrdersAlgoHistory",a.ordType="move_order_stop";else if(f||p in c){u="privateGetTradeOrdersAlgoHistory";const e=this.safeString(i,"algoId");if(void 0!==e&&(a.algoId=e,i=this.omit(i,"algoId")),f&&void 0===p)throw new r.ArgumentsRequired(this.id+' fetchCanceledOrders() requires an "ordType" string parameter, "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"')}else{void 0!==t&&(a.begin=t);const e=this.safeInteger(d,"until");void 0!==e&&(a.end=e,d=this.omit(d,["until"]))}const m=this.omit(d,["method","stop","trigger","trailing"]);let g;g="privateGetTradeOrdersAlgoHistory"===u?await this.privateGetTradeOrdersAlgoHistory(this.extend(a,m)):await this.privateGetTradeOrdersHistory(this.extend(a,m));const v=this.safeList(g,"data",[]);return this.parseOrders(v,o,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchClosedOrders","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchClosedOrders",e,t,s,i);const a={};let o,n,d;void 0!==e&&(o=this.market(e),a.instId=o.id),[n,d]=this.handleMarketTypeAndParams("fetchClosedOrders",o,i),a.instType=this.convertToInstrumentType(n),void 0!==s&&(a.limit=s);const h=this.safeDict(this.options,"fetchClosedOrders",{}),c=this.safeDict(this.options,"algoOrderTypes",{}),l=this.safeString(h,"method","privateGetTradeOrdersHistory");let u=this.safeString(i,"method",l);const p=this.safeString(i,"ordType"),f=this.safeBool2(i,"stop","trigger"),m=this.safeBool(i,"trailing",!1);if((m||f||p in c)&&(u="privateGetTradeOrdersAlgoHistory",a.state="effective"),m)a.ordType="move_order_stop";else if(f)void 0===p&&(a.ordType="trigger");else{void 0!==t&&(a.begin=t);const e=this.safeInteger(d,"until");void 0!==e&&(a.end=e,d=this.omit(d,["until"])),a.state="filled"}const g=this.omit(d,["method","stop","trigger","trailing"]);let v;v="privateGetTradeOrdersAlgoHistory"===u?await this.privateGetTradeOrdersAlgoHistory(this.extend(a,g)):"privateGetTradeOrdersHistoryArchive"===u?await this.privateGetTradeOrdersHistoryArchive(this.extend(a,g)):await this.privateGetTradeOrdersHistory(this.extend(a,g));const y=this.safeList(v,"data",[]);return this.parseOrders(y,o,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);let a,o={};void 0!==e&&(a=this.market(e),o.instId=a.id),void 0!==t&&(o.begin=t),[o,i]=this.handleUntilOption("end",o,i);const[n,d]=this.handleMarketTypeAndParams("fetchMyTrades",a,i);o.instType=this.convertToInstrumentType(n),void 0!==s&&void 0===t&&(o.limit=s);const h=await this.privateGetTradeFillsHistory(this.extend(o,d)),c=this.safeList(h,"data",[]);return this.parseTrades(c,a,t,s,d)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){const a={ordId:e};return await this.fetchMyTrades(t,s,i,this.extend(a,r))}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchLedger","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchLedger",e,t,s,i);const a=this.safeDict(this.options,"fetchLedger",{});let o=this.safeString(a,"method");o=this.safeString(i,"method",o),i=this.omit(i,"method");let n,d={};[n,i]=this.handleMarginModeAndParams("fetchLedger",i),void 0===n&&(n=this.safeString(i,"mgnMode")),"privateGetAssetBills"!==o&&void 0!==n&&(d.mgnMode=n);const[h,c]=this.handleMarketTypeAndParams("fetchLedger",void 0,i);let l,u;void 0!==h&&(d.instType=this.convertToInstrumentType(h)),void 0!==s&&(d.limit=s),void 0!==e&&(l=this.currency(e),d.ccy=l.id),[d,i]=this.handleUntilOption("end",d,i),u="privateGetAccountBillsArchive"===o?await this.privateGetAccountBillsArchive(this.extend(d,c)):"privateGetAssetBills"===o?await this.privateGetAssetBills(this.extend(d,c)):await this.privateGetAccountBills(this.extend(d,c));const p=this.safeList(u,"data",[]);return this.parseLedger(p,l,t,s)}parseLedgerEntryType(e){return this.safeString({1:"transfer",2:"trade",3:"trade",4:"rebate",5:"trade",6:"transfer",7:"trade",8:"fee",9:"trade",10:"trade",11:"trade"},e,e)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"billId"),i=this.safeString(e,"ordId"),r=this.parseLedgerEntryType(this.safeString(e,"type")),o=this.safeCurrencyCode(this.safeString(e,"ccy"),t),n=this.safeString(e,"balChg"),d=this.parseNumber(n),h=this.safeInteger(e,"ts"),c=this.safeString(e,"fee");let l;void 0!==c&&(l={cost:this.parseNumber(a.Y.stringNeg(c)),currency:o});const u=this.safeString(e,"bal"),p=this.parseNumber(u),f=this.safeString(e,"instId"),m=this.safeSymbol(f,void 0,"-");return{id:s,info:e,timestamp:h,datetime:this.iso8601(h),account:undefined,referenceId:i,referenceAccount:undefined,type:r,currency:o,symbol:m,amount:d,before:undefined,after:p,status:"ok",fee:l}}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"addr");let i=this.safeStringN(e,["tag","pmtId","memo"]);if(void 0===i){const t=this.safeValue(e,"addrEx",{});i=this.safeString(t,"comment")}const r=this.safeString(e,"ccy"),a=(t=this.safeCurrency(r,t)).code,o=this.safeString(e,"chain"),n=this.safeValue(t,"networks",{}),d=this.indexBy(n,"id");let h=this.safeValue(d,o);"USDT-Polygon"===o&&(h=this.safeValue2(d,"USDT-Polygon-Bridge","USDT-Polygon"));const c=this.safeString(h,"network"),l=this.networkIdToCode(c,a);return this.checkAddress(s),{currency:a,address:s,tag:i,network:l,info:e}}async fetchDepositAddressesByNetwork(e,t={}){await this.loadMarkets();const s=this.currency(e),i={ccy:s.id},r=await this.privateGetAssetDepositAddress(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.filterBy(a,"selected",!0),n=this.parseDepositAddresses(o,[s.code],!1);return this.indexBy(n,"network")}async fetchDepositAddress(e,t={}){const s=this.safeStringUpper(t,"network"),i=this.safeValue(this.options,"networks",{}),a=this.safeString(i,s,s);t=this.omit(t,"network");const o=await this.fetchDepositAddressesByNetwork(e,t);let n;if(void 0===a){if(n=this.safeValue(o,e),void 0===n){const t=this.safeString(i,e,e);if(n=this.safeValue(o,t),void 0===n){const t=this.safeString(this.options,"defaultNetwork","ERC20");if(n=this.safeValue(o,t),void 0===n){const t=Object.values(o);if(n=this.safeValue(t,0),void 0===n)throw new r.InvalidAddress(this.id+" fetchDepositAddress() cannot find deposit address for "+e)}}}return n}if(n=this.safeValue(o,a),void 0===n)throw new r.InvalidAddress(this.id+" fetchDepositAddress() cannot find "+a+" deposit address for "+e);return n}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);void 0!==i&&i.length>0&&(s=s+":"+i);const n={ccy:o.id,toAddr:s,dest:"4",amt:this.numberToString(t)};let d=this.safeString(a,"network");if(void 0!==d){const e=this.safeDict(this.options,"networks",{});d=this.safeString(e,d.toUpperCase(),d),n.chain=o.id+"-"+d,a=this.omit(a,"network")}let h=this.safeString(a,"fee");if(void 0===h){const e=await this.fetchCurrencies();this.currencies=this.deepExtend(this.currencies,e);const t=this.safeDict(o.networks,this.networkIdToCode(d),{});if(h=this.safeString(t,"fee"),void 0===h)throw new r.ArgumentsRequired(this.id+' withdraw() requires a "fee" string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKX are fee-free, please set "0". Withdrawing to external digital asset address requires network transaction fee.')}n.fee=this.numberToString(h);const c=this.omit(a,["fee"]),l=await this.privatePostAssetWithdrawal(this.extend(n,c)),u=this.safeList(l,"data",[]),p=this.safeDict(u,0);return this.parseTransaction(p,o)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchDeposits",e,t,s,i);let a,o={};void 0!==e&&(a=this.currency(e),o.ccy=a.id),void 0!==t&&(o.before=Math.max(t-1,0)),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("after",o,i);const n=await this.privateGetAssetDepositHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s,i)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={depId:e};let r;void 0!==t&&(r=this.currency(t),i.ccy=r.id);const a=await this.privateGetAssetDepositHistory(this.extend(i,s)),o=this.safeValue(a,"data"),n=this.safeDict(o,0,{});return this.parseTransaction(n,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallDynamic("fetchWithdrawals",e,t,s,i);let a,o={};void 0!==e&&(a=this.currency(e),o.ccy=a.id),void 0!==t&&(o.before=Math.max(t-1,0)),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("after",o,i);const n=await this.privateGetAssetWithdrawalHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,a,t,s,i)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={wdId:e};let r;void 0!==t&&(r=this.currency(t),i.ccy=r.id);const a=await this.privateGetAssetWithdrawalHistory(this.extend(i,s)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseTransaction(n)}parseTransactionStatus(e){return this.safeString({"-3":"pending","-2":"canceled","-1":"failed",0:"pending",1:"pending",2:"ok",3:"pending",4:"pending",5:"pending",6:"pending",7:"pending",8:"pending",9:"pending",10:"pending",12:"pending",15:"pending",16:"pending"},e,e)}parseTransaction(e,t=void 0){let s,i;const r=this.safeString(e,"wdId"),a=this.safeString(e,"from"),o=this.safeString(e,"to"),n=o;let d=this.safeString2(e,"tag","memo");d=this.safeString2(e,"pmtId",d),void 0!==r?(s="withdrawal",i=r):(i=this.safeString(e,"depId"),s="deposit");const h=this.safeString(e,"ccy"),c=this.safeCurrencyCode(h),l=this.safeNumber(e,"amt"),u=this.parseTransactionStatus(this.safeString(e,"state")),p=this.safeString(e,"txId"),f=this.safeInteger(e,"ts");let m;return m="deposit"===s?0:this.safeNumber(e,"fee"),{info:e,id:i,currency:c,amount:l,network:void 0,addressFrom:a,addressTo:o,address:n,tagFrom:void 0,tagTo:d,tag:d,status:u,type:s,updated:void 0,txid:p,timestamp:f,datetime:this.iso8601(f),internal:void 0,comment:void 0,fee:{currency:c,cost:m}}}async fetchLeverage(e,t={}){let s;if(await this.loadMarkets(),[s,t]=this.handleMarginModeAndParams("fetchLeverage",t),void 0===s&&(s=this.safeString(t,"mgnMode","cross")),"cross"!==s&&"isolated"!==s)throw new r.BadRequest(this.id+" fetchLeverage() requires a marginMode parameter that must be either cross or isolated");const i=this.market(e),a={instId:i.id,mgnMode:s},o=await this.privateGetAccountLeverageInfo(this.extend(a,t)),n=this.safeList(o,"data",[]);return this.parseLeverage(n,i)}parseLeverage(e,t=void 0){let s,i,r,a;for(let t=0;t<e.length;t++){const o=e[t];i=this.safeStringLower(o,"mgnMode"),s=this.safeString(o,"instId");const n=this.safeStringLower(o,"posSide");"long"===n?r=this.safeInteger(o,"lever"):("short"===n||(r=this.safeInteger(o,"lever")),a=this.safeInteger(o,"lever"))}return{info:e,symbol:this.safeSymbol(s,t),marginMode:i,longLeverage:r,shortLeverage:a}}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),[i,r]=this.handleMarketTypeAndParams("fetchPosition",s,t),a={instId:s.id};void 0!==i&&(a.instType=this.convertToInstrumentType(i));const o=await this.privateGetAccountPositions(this.extend(a,r)),n=this.safeList(o,"data",[]),d=this.safeDict(n,0);if(void 0!==d)return this.parsePosition(d,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=[];for(let s=0;s<e.length;s++){const i=e[s],r=this.market(i);t.push(r.id)}t.length>0&&(s.instId=t.join(","))}const i=this.safeDict(this.options,"fetchPositions",{});let r;r="privateGetAccountPositionsHistory"===this.safeString(i,"method","privateGetAccountPositions")?await this.privateGetAccountPositionsHistory(this.extend(s,t)):await this.privateGetAccountPositions(this.extend(s,t));const a=this.safeList(r,"data",[]),o=[];for(let e=0;e<a.length;e++)o.push(this.parsePosition(a[e]));return this.filterByArrayPositions(o,"symbol",this.marketSymbols(e),!1)}async fetchPositionsForSymbol(e,t={}){return await this.fetchPositions([e],t)}parsePosition(e,t=void 0){const s=this.safeString(e,"instId"),i=(t=this.safeMarket(s,t,void 0,"contract")).symbol,r=this.safeString(e,"pos"),o=a.Y.stringAbs(r);let n=this.safeString2(e,"posSide","direction");const d="net"!==n,h=this.parseNumber(o);if(t.margin){if("net"===n){const s=this.safeString(e,"posCcy"),i=this.safeCurrencyCode(s);void 0!==i&&(n=t.base===i?"long":"short")}void 0===n&&(n=this.safeString(e,"direction"))}else void 0!==r&&"net"===n&&(n=a.Y.stringGt(r,"0")?"long":a.Y.stringLt(r,"0")?"short":void 0);const c=this.safeNumber(t,"contractSize"),l=this.numberToString(c),u=this.safeString(e,"markPx");let p=this.safeString(e,"notionalUsd");t.inverse&&(p=a.Y.stringDiv(a.Y.stringMul(o,l),u));const f=this.parseNumber(p),m=this.safeString(e,"mgnMode");let g;const v=this.safeString2(e,"avgPx","openAvgPx"),y=this.safeString(e,"upl"),w=this.safeString(e,"lever");let b,S;"cross"===m?(g=this.safeString(e,"imr"),S=a.Y.stringAdd(g,y)):"isolated"===m&&(b=a.Y.stringDiv("1",w),S=this.safeString(e,"margin"));const k=this.safeString(e,"mmr"),O=this.parseNumber(k),T=a.Y.stringDiv(k,p);void 0===b?b=this.parseNumber(a.Y.stringDiv(g,p,4)):void 0===g&&(g=a.Y.stringMul(b,p));const P=this.parseNumber(a.Y.stringDiv(a.Y.stringAdd(T,"0.00005"),"1",4)),I=this.safeNumber(e,"liqPx"),x=this.safeString(e,"uplRatio"),A=this.parseNumber(a.Y.stringMul(x,"100")),M=this.safeInteger(e,"cTime"),C=this.parseNumber(a.Y.stringDiv(k,S,4));return this.safePosition({info:e,id:this.safeString(e,"posId"),symbol:i,notional:f,marginMode:m,liquidationPrice:I,entryPrice:this.parseNumber(v),unrealizedPnl:this.parseNumber(y),realizedPnl:this.safeNumber(e,"realizedPnl"),percentage:A,contracts:h,contractSize:c,markPrice:this.parseNumber(u),lastPrice:this.safeNumber(e,"closeAvgPx"),side:n,hedged:d,timestamp:M,datetime:this.iso8601(M),lastUpdateTimestamp:this.safeInteger(e,"uTime"),maintenanceMargin:O,maintenanceMarginPercentage:P,collateral:this.parseNumber(S),initialMargin:this.parseNumber(g),initialMarginPercentage:this.parseNumber(b),leverage:this.parseNumber(w),marginRatio:C,stopLossPrice:void 0,takeProfitPrice:void 0})}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeDict(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h={ccy:a.id,amt:this.currencyToPrecision(e,t),type:"0",from:n,to:d};"master"===n?(h.type="1",h.subAcct=d,h.from=this.safeString(r,"from","6"),h.to=this.safeString(r,"to","6")):"master"===d&&(h.type="2",h.subAcct=n,h.from=this.safeString(r,"from","6"),h.to=this.safeString(r,"to","6"));const c=await this.privatePostAssetTransfer(this.extend(h,r)),l=this.safeList(c,"data",[]),u=this.safeDict(l,0,{});return this.parseTransfer(u,a)}parseTransfer(e,t=void 0){const s=this.safeString2(e,"transId","billId"),i=this.safeString(e,"ccy"),r=this.safeCurrencyCode(i,t);let o=this.safeNumber(e,"amt");const n=this.safeString(e,"from"),d=this.safeString(e,"to"),h=this.safeDict(this.options,"accountsById",{}),c=this.safeInteger(e,"ts"),l=this.safeString(e,"sz");return void 0!==l&&(o=this.parseNumber(a.Y.stringAbs(l))),{info:e,id:s,timestamp:c,datetime:this.iso8601(c),currency:r,amount:o,fromAccount:this.safeString(h,n),toAccount:this.safeString(h,d),status:this.parseTransferStatus(this.safeString(e,"state"))}}parseTransferStatus(e){return this.safeString({success:"ok"},e,e)}async fetchTransfer(e,t=void 0,s={}){await this.loadMarkets();const i={transId:e},r=await this.privateGetAssetTransferState(this.extend(i,s)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0);return this.parseTransfer(o)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={type:"1"};void 0!==e&&(r=this.currency(e),a.ccy=r.id),void 0!==t&&(a.begin=t),void 0!==s&&(a.limit=s);const o=await this.privateGetAccountBillsArchive(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTransfers(n,r,t,s,i)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=Array.isArray(i),d="/api/"+this.version+"/"+this.implodeParams(e,i),h=this.omit(i,this.extractParams(e));let c=this.implodeHostname(this.urls.api.rest)+d;if("public"===t)Object.keys(h).length&&(c+="?"+this.urlencode(h));else if("private"===t){if(this.checkRequiredCredentials(),"POST"===s&&("trade/batch-orders"===e||"trade/order-algo"===e||"trade/order"===e)){const e=this.safeString(this.options,"brokerId","e847386590ce4dBC");if(Array.isArray(i))for(let t=0;t<i.length;t++){const s=i[t];void 0===this.safeString(s,"clOrdId")&&(s.clOrdId=e+this.uuid16(),s.tag=e,i[t]=s)}else{void 0===this.safeString(i,"clOrdId")&&(i.clOrdId=e+this.uuid16(),i.tag=e)}}const t=this.iso8601(this.milliseconds());r={"OK-ACCESS-KEY":this.apiKey,"OK-ACCESS-PASSPHRASE":this.password,"OK-ACCESS-TIMESTAMP":t};let l=t+s+d;if("GET"===s){if(Object.keys(h).length){const e="?"+this.urlencode(h);c+=e,l+=e}}else(o||Object.keys(h).length)&&(l+=a=this.json(h)),r["Content-Type"]="application/json";const u=this.hmac(this.encode(l),this.encode(this.secret),n.s,"base64");r["OK-ACCESS-SIGN"]=u}return{url:c,method:s,body:a,headers:r}}parseFundingRate(e,t=void 0){const s=this.safeInteger(e,"nextFundingTime"),i=this.safeString(e,"instId"),r=this.safeSymbol(i,t),a=this.safeNumber(e,"nextFundingRate"),o=this.safeInteger(e,"fundingTime");return{info:e,symbol:r,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:o,fundingDatetime:this.iso8601(o),nextFundingRate:a,nextFundingTimestamp:s,nextFundingDatetime:this.iso8601(s),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.ExchangeError(this.id+" fetchFundingRate() is only valid for swap markets");const i={instId:s.id},a=await this.publicGetPublicFundingRate(this.extend(i,t)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseFundingRate(n,s)}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={type:"8"};let a;void 0!==s&&(r.limit=s.toString()),void 0!==e&&(a=this.market(e),e=a.symbol,a.contract&&(a.linear?(r.ctType="linear",r.ccy=a.quoteId):(r.ctType="inverse",r.ccy=a.baseId)));const[o,n]=this.handleMarketTypeAndParams("fetchFundingHistory",a,i);"swap"===o&&(r.instType=this.convertToInstrumentType(o));const d=await this.privateGetAccountBillsArchive(this.extend(r,n)),h=this.safeList(d,"data",[]),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeInteger(t,"ts"),i=this.safeString(t,"instId"),r=this.safeMarket(i),a=this.safeString(t,"ccy"),o=this.safeCurrencyCode(a);c.push({info:t,symbol:r.symbol,code:o,timestamp:s,datetime:this.iso8601(s),id:this.safeString(t,"billId"),amount:this.safeNumber(t,"balChg")})}const l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,e,t,s)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<1||e>125)throw new r.BadRequest(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const i=this.market(t);let a;if([a,s]=this.handleMarginModeAndParams("setLeverage",s),void 0===a&&(a=this.safeString(s,"mgnMode","cross")),"cross"!==a&&"isolated"!==a)throw new r.BadRequest(this.id+" setLeverage() requires a marginMode parameter that must be either cross or isolated");const o={lever:e,mgnMode:a,instId:i.id},n=this.safeString(s,"posSide");if("isolated"===a){if(void 0===n)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a posSide argument for isolated margin");if("long"!==n&&"short"!==n&&"net"!==n)throw new r.BadRequest(this.id+' setLeverage() requires the posSide argument to be either "long", "short" or "net"')}return await this.privatePostAccountSetLeverage(this.extend(o,s))}async fetchPositionMode(e=void 0,t={}){const s=await this.fetchAccounts();let i;if(s.length>1){const e=this.safeString(t,"accountId");if(void 0===e){const e=this.getListFromObjectValues(s,"id");throw new r.ExchangeError(this.id+' fetchPositionMode() can not detect position mode, because you have multiple accounts. Set params["accountId"] to desired id from: '+e.join(", "))}{const t=this.indexBy(s,"id");i=this.safeDict(t,e)}}else i=s[0];const a=i.info;return{info:a,hedged:"long_short_mode"===this.safeString(a,"posMode")}}async setPositionMode(e,t=void 0,s={}){let i;i=e?"long_short_mode":"net_mode";const r={posMode:i};return await this.privatePostAccountSetPositionMode(this.extend(r,s))}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("cross"!==(e=e.toLowerCase())&&"isolated"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode must be either cross or isolated");await this.loadMarkets();const i=this.market(t),a=this.safeInteger2(s,"lever","leverage");if(void 0===a||a<1||a>125)throw new r.BadRequest(this.id+' setMarginMode() params["lever"] should be between 1 and 125');s=this.omit(s,["leverage"]);const o={lever:a,mgnMode:e,instId:i.id};return await this.privatePostAccountSetLeverage(this.extend(o,s))}async fetchCrossBorrowRates(e={}){await this.loadMarkets();const t=await this.privateGetAccountInterestRate(e),s=this.safeList(t,"data",[]),i=[];for(let e=0;e<s.length;e++)i.push(this.parseBorrowRate(s[e]));return i}async fetchCrossBorrowRate(e,t={}){await this.loadMarkets();const s={ccy:this.currency(e).id},i=await this.privateGetAccountInterestRate(this.extend(s,t)),r=this.safeList(i,"data",[]),a=this.safeDict(r,0,{});return this.parseBorrowRate(a)}parseBorrowRate(e,t=void 0){const s=this.safeString(e,"ccy"),i=this.safeInteger(e,"ts");return{currency:this.safeCurrencyCode(s),rate:this.safeNumber2(e,"interestRate","rate"),period:864e5,timestamp:i,datetime:this.iso8601(i),info:e}}parseBorrowRateHistories(e,t,s,i){const r={};for(let s=0;s<e.length;s++){const i=e[s],a=this.safeCurrencyCode(this.safeString(i,"ccy"));if(void 0===t||this.inArray(a,t)){a in r||(r[a]=[]);const e=this.parseBorrowRate(i);r[a].push(e)}}const a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e];r[t]=this.filterByCurrencySinceLimit(r[t],t,s,i)}return r}parseBorrowRateHistory(e,t,s,i){const r=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.parseBorrowRate(s);r.push(i)}const a=this.sortBy(r,"timestamp");return this.filterByCurrencySinceLimit(a,t,s,i)}async fetchBorrowRateHistories(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};void 0!==t&&(r.before=t),void 0!==s&&(r.limit=s);const a=await this.publicGetFinanceSavingsLendingRateHistory(this.extend(r,i)),o=this.safeList(a,"data",[]);return this.parseBorrowRateHistories(o,e,t,s)}async fetchBorrowRateHistory(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={ccy:this.currency(e).id};void 0!==t&&(r.before=t),void 0!==s&&(r.limit=s);const a=await this.publicGetFinanceSavingsLendingRateHistory(this.extend(r,i)),o=this.safeList(a,"data",[]);return this.parseBorrowRateHistory(o,e,t,s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a=this.safeString(i,"posSide","net");i=this.omit(i,["posSide"]);const o={instId:r.id,amt:t,type:s,posSide:a},n=await this.privatePostAccountPositionMarginBalance(this.extend(o,i)),d=this.safeList(n,"data",[]),h=this.safeDict(d,0,{}),c=this.safeString(n,"code");return this.extend(this.parseMarginModification(h,r),{status:"0"===c?"ok":"failed"})}parseMarginModification(e,t=void 0){const s=this.safeString2(e,"amt","posBalChg"),i=this.safeString(e,"type");let r;r="6"===i?a.Y.stringGt(s,"0")?"add":"reduce":i;const o=a.Y.stringAbs(s),n=this.safeString(e,"instId"),d=this.safeMarket(n,t),h=d.inverse?d.base:d.quote,c=this.safeInteger(e,"ts");return{info:e,symbol:d.symbol,type:r,marginMode:"isolated",amount:this.parseNumber(o),code:h,total:void 0,status:void 0,timestamp:c,datetime:this.iso8601(c)}}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"reduce",s)}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"add",s)}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.spot?"MARGIN":this.convertToInstrumentType(s.type),a=this.safeString(s.info,"uly");if(!a&&"MARGIN"!==i)throw new r.BadRequest(this.id+" fetchMarketLeverageTiers() cannot fetch leverage tiers for "+e);let o;[o,t]=this.handleMarginModeAndParams("fetchMarketLeverageTiers",t),void 0===o&&(o=this.safeString(t,"tdMode","cross"));const n={instType:i,tdMode:o,uly:a};"MARGIN"===i&&(n.instId=s.id);const d=await this.publicGetPublicPositionTiers(this.extend(n,t)),h=this.safeList(d,"data",[]);return this.parseMarketLeverageTiers(h,s)}parseMarketLeverageTiers(e,t=void 0){const s=[];for(let i=0;i<e.length;i++){const r=e[i];s.push({tier:this.safeInteger(r,"tier"),currency:t.quote,minNotional:this.safeNumber(r,"minSz"),maxNotional:this.safeNumber(r,"maxSz"),maintenanceMarginRate:this.safeNumber(r,"mmr"),maxLeverage:this.safeNumber(r,"maxLever"),info:r})}return s}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),[a,r]=this.handleMarginModeAndParams("fetchBorrowInterest",r),void 0===a&&(a=this.safeString(r,"mgnMode","cross"));const o={mgnMode:a};let n;if(void 0!==e){const t=this.currency(e);o.ccy=t.id}void 0!==s&&(o.before=s-1),void 0!==i&&(o.limit=i),void 0!==t&&(n=this.market(t),o.instId=n.id);const d=await this.privateGetAccountInterestAccrued(this.extend(o,r)),h=this.safeList(d,"data",[]),c=this.parseBorrowInterests(h);return this.filterByCurrencySinceLimit(c,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"instId");void 0!==s&&(t=this.safeMarket(s,t));const i=this.safeInteger(e,"ts");return{symbol:this.safeString(t,"symbol"),marginMode:this.safeString(e,"mgnMode"),currency:this.safeCurrencyCode(this.safeString(e,"ccy")),interest:this.safeNumber(e,"interest"),interestRate:this.safeNumber(e,"interestRate"),amountBorrowed:this.safeNumber(e,"liab"),timestamp:i,datetime:this.iso8601(i),info:e}}async borrowCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.currency(e),r={ccy:i.id,amt:this.currencyToPrecision(e,t),side:"borrow"},a=await this.privatePostAccountBorrowRepay(this.extend(r,s)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{});return this.parseMarginLoan(n,i)}async repayCrossMargin(e,t,s={}){await this.loadMarkets();const i=this.safeString2(s,"id","ordId");if(s=this.omit(s,"id"),void 0===i)throw new r.ArgumentsRequired(this.id+" repayCrossMargin() requires an id parameter");const a=this.currency(e),o={ccy:a.id,amt:this.currencyToPrecision(e,t),side:"repay",ordId:i},n=await this.privatePostAccountBorrowRepay(this.extend(o,s)),d=this.safeList(n,"data",[]),h=this.safeDict(d,0,{});return this.parseMarginLoan(h,a)}parseMarginLoan(e,t=void 0){const s=this.safeString(e,"ccy");return{id:void 0,currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amt"),symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i={instType:this.convertToInstrumentType(s.type),uly:this.safeString(s.info,"uly"),instId:s.id},a=await this.publicGetPublicOpenInterest(this.extend(i,t)),o=this.safeList(a,"data",[]);return this.parseOpenInterest(o[0],s)}async fetchOpenInterestHistory(e,t="1d",s=void 0,i=void 0,a={}){const o=this.safeDict(this.options,"fetchOpenInterestHistory",{}),n=this.safeDict(o,"timeframes",{});if("5m"!==(t=this.safeString(n,t,t))&&"1H"!==t&&"1D"!==t)throw new r.BadRequest(this.id+" fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe");let d,h;if(await this.loadMarkets(),e in this.markets||e in this.markets_by_id)h=this.market(e),d=h.baseId;else{d=this.currency(e).id}const c={ccy:d,period:t};let l,u;if([l,a]=this.handleMarketTypeAndParams("fetchOpenInterestHistory",h,a),"option"===l)u=await this.publicGetRubikStatOptionOpenInterestVolume(this.extend(c,a));else{void 0!==s&&(c.begin=s);const e=this.safeInteger(a,"until");void 0!==e&&(c.end=e,a=this.omit(a,["until"])),u=await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(c,a))}const p=this.safeList(u,"data",[]);return this.parseOpenInterests(p,void 0,s,i)}parseOpenInterest(e,t=void 0){const s=this.safeString(e,"instId");t=this.safeMarket(s,t);const i=this.safeInteger(e,"ts"),r=this.safeInteger(e,0,i);let a,o,n,d;const h=this.safeString(this.options,"defaultType");return Array.isArray(e)?"option"===h?(n=this.safeNumber(e,1),a=this.safeNumber(e,2)):(d=this.safeNumber(e,1),o=this.safeNumber(e,2)):(a=this.safeNumber(e,"oiCcy"),n=this.safeNumber(e,"oi"),d=this.safeNumber(e,"oiCcy")),this.safeOpenInterest({symbol:this.safeSymbol(s),baseVolume:a,quoteVolume:o,openInterestAmount:n,openInterestValue:d,timestamp:r,datetime:this.iso8601(r),info:e},t)}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e,e?this.headers["x-simulated-trading"]="1":"x-simulated-trading"in this.headers&&(this.headers=this.omit(this.headers,"x-simulated-trading"))}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetAssetCurrencies(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);for(let s=0;s<e.length;s++){const r=e[s],a=this.safeString(r,"ccy"),o=this.safeCurrencyCode(a);if(void 0===t||this.inArray(o,t)){void 0===this.safeValue(i,o)&&(i[o]=this.depositWithdrawFee({})),i[o].info[a]=r;const e=this.safeString(r,"chain");if(void 0===e)continue;const t=e.split("-"),s=this.safeValue(t,1),n=this.safeNumber(r,"minFee"),d={fee:n,percentage:void 0===n&&void 0},h={fee:void 0,percentage:void 0},c=this.networkIdToCode(s,o);i[o].networks[c]={withdraw:d,deposit:h}}}const r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],s=this.currency(t);i[t]=this.assignDefaultDepositWithdrawFees(i[t],s)}return i}async fetchSettlementHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchSettlementHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e);let o;if([o,i]=this.handleMarketTypeAndParams("fetchSettlementHistory",a,i),"future"!==o&&"option"!==o)throw new r.NotSupported(this.id+" fetchSettlementHistory() supports futures and options markets only");const n={instType:this.convertToInstrumentType(o),uly:a.baseId+"-"+a.quoteId};void 0!==t&&(n.before=t-1),void 0!==s&&(n.limit=s);const d=await this.publicGetPublicDeliveryExerciseHistory(this.extend(n,i)),h=this.safeList(d,"data",[]),c=this.parseSettlements(h,a),l=this.sortBy(c,"timestamp");return this.filterBySymbolSinceLimit(l,a.symbol,t,s)}parseSettlement(e,t){const s=this.safeString(e,"insId");return{info:e,symbol:this.safeSymbol(s,t),price:this.safeNumber(e,"px"),timestamp:void 0,datetime:void 0}}parseSettlements(e,t){const s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeInteger(r,"ts"),o=this.safeList(r,"details",[]);for(let e=0;e<o.length;e++){const i=this.parseSettlement(o[e],t);s.push(this.extend(i,{timestamp:a,datetime:this.iso8601(a)}))}}return s}async fetchUnderlyingAssets(e={}){let t;if(await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchUnderlyingAssets",void 0,e),void 0!==t&&"spot"!==t||(t="option"),"option"!==t&&"swap"!==t&&"future"!==t)throw new r.NotSupported(this.id+" fetchUnderlyingAssets() supports contract markets only");const s={instType:this.convertToInstrumentType(t)},i=await this.publicGetPublicUnderlying(this.extend(s,e));return this.safeList(i,"data",[])[0]}async fetchGreeks(e,t={}){await this.loadMarkets();const s=this.market(e),i=s.id,r=i.split("-"),a={uly:s.info.uly,instFamily:s.info.instFamily,expTime:this.safeString(r,2)},o=await this.publicGetPublicOptSummary(this.extend(a,t)),n=this.safeList(o,"data",[]);for(let e=0;e<n.length;e++){const t=n[e];if(this.safeString(t,"instId")===i)return this.parseGreeks(t,s)}}parseGreeks(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"instId");return{symbol:this.safeSymbol(i,t),timestamp:s,datetime:this.iso8601(s),delta:this.safeNumber(e,"delta"),gamma:this.safeNumber(e,"gamma"),theta:this.safeNumber(e,"theta"),vega:this.safeNumber(e,"vega"),rho:void 0,bidSize:void 0,askSize:void 0,bidImpliedVolatility:this.safeNumber(e,"bidVol"),askImpliedVolatility:this.safeNumber(e,"askVol"),markImpliedVolatility:this.safeNumber(e,"markVol"),bidPrice:void 0,askPrice:void 0,markPrice:void 0,lastPrice:void 0,underlyingPrice:void 0,info:e}}async closePosition(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.safeString(s,"clientOrderId"),a=this.safeString(s,"code");let o;[o,s]=this.handleMarginModeAndParams("closePosition",s,"cross");const n={instId:i.id,mgnMode:o};if(void 0!==t&&(n.posSide="buy"===t?"long":"sell"===t?"short":t),void 0!==r&&(n.clOrdId=r),void 0!==a){const e=this.currency(a);n.ccy=e.id}const d=await this.privatePostTradeClosePosition(this.extend(n,s)),h=this.safeList(d,"data",[]),c=this.safeDict(h,0);return this.parseOrder(c,i)}async fetchOption(e,t={}){await this.loadMarkets();const s=this.market(e),i={instId:s.id},r=await this.publicGetMarketTicker(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseOption(o,void 0,s)}async fetchOptionChain(e,t={}){await this.loadMarkets();const s={uly:this.currency(e).code+"-USD",instType:"OPTION"},i=await this.publicGetMarketTickers(this.extend(s,t)),r=this.safeList(i,"data",[]);return this.parseOptionChain(r,void 0,"instId")}parseOption(e,t=void 0,s=void 0){const i=this.safeString(e,"instId");s=this.safeMarket(i,s);const r=this.safeInteger(e,"ts");return{info:e,currency:void 0,symbol:s.symbol,timestamp:r,datetime:this.iso8601(r),impliedVolatility:void 0,openInterest:void 0,bidPrice:this.safeNumber(e,"bidPx"),askPrice:this.safeNumber(e,"askPx"),midPrice:void 0,markPrice:void 0,lastPrice:this.safeNumber(e,"last"),underlyingPrice:void 0,change:void 0,percentage:void 0,baseVolume:this.safeNumber(e,"volCcy24h"),quoteVolume:void 0}}async fetchConvertQuote(e,t,s=void 0,i={}){await this.loadMarkets();const r={baseCcy:e.toUpperCase(),quoteCcy:t.toUpperCase(),rfqSzCcy:e.toUpperCase(),rfqSz:this.numberToString(s),side:"sell"},a=await this.privatePostAssetConvertEstimateQuote(this.extend(r,i)),o=this.safeList(a,"data",[]),n=this.safeDict(o,0,{}),d=this.safeString(n,"baseCcy",e),h=this.currency(d),c=this.safeString(n,"quoteCcy",t),l=this.currency(c);return this.parseConversion(n,h,l)}async createConvertTrade(e,t,s,i=void 0,r={}){await this.loadMarkets();const a={quoteId:e,baseCcy:t,quoteCcy:s,szCcy:t,sz:this.numberToString(i),side:"sell"},o=await this.privatePostAssetConvertTrade(this.extend(a,r)),n=this.safeList(o,"data",[]),d=this.safeDict(n,0,{}),h=this.safeString(d,"baseCcy",t),c=this.currency(h),l=this.safeString(d,"quoteCcy",s),u=this.currency(l);return this.parseConversion(d,c,u)}async fetchConvertTrade(e,t=void 0,s={}){await this.loadMarkets();const i={clTReqId:e},r=await this.privateGetAssetConvertHistory(this.extend(i,s)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{}),n=this.safeString(o,"baseCcy"),d=this.safeString(o,"quoteCcy");let h,c;return void 0!==n&&(h=this.currency(n)),void 0!==d&&(c=this.currency(d)),this.parseConversion(o,h,c)}async fetchConvertTradeHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r={};[r,i]=this.handleUntilOption("after",r,i),void 0!==t&&(r.before=t),void 0!==s&&(r.limit=s);const a=await this.privateGetAssetConvertHistory(this.extend(r,i)),o=this.safeList(a,"data",[]);return this.parseConversions(o,e,"baseCcy","quoteCcy",t,s)}parseConversion(e,t=void 0,s=void 0){const i=this.safeInteger2(e,"quoteTime","ts"),r=this.safeString(e,"baseCcy"),a=this.safeCurrencyCode(r,t),o=this.safeString(e,"quoteCcy"),n=this.safeCurrencyCode(o,s);return{info:e,timestamp:i,datetime:this.iso8601(i),id:this.safeStringN(e,["clQReqId","tradeId","quoteId"]),fromCurrency:a,fromAmount:this.safeNumber2(e,"baseSz","fillBaseSz"),toCurrency:n,toAmount:this.safeNumber2(e,"quoteSz","fillQuoteSz"),price:this.safeNumber2(e,"cnvtPx","fillPx"),fee:void 0}}async fetchConvertCurrencies(e={}){await this.loadMarkets();const t=await this.privateGetAssetConvertCurrencies(e),s={},i=this.safeList(t,"data",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"ccy"),a=this.safeCurrencyCode(r);s[a]={info:t,id:r,code:a,networks:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:void 0,limits:{amount:{min:this.safeNumber(t,"min"),max:this.safeNumber(t,"max")},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},created:void 0}}return s}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeString(n,"code");if("0"!==c&&"2"!==c){const e=this.id+" "+o,t=this.safeList(n,"data",[]);for(let s=0;s<t.length;s++){const i=t[s],r=this.safeString(i,"sCode"),a=this.safeString(i,"sMsg");this.throwExactlyMatchedException(this.exceptions.exact,r,e),this.throwBroadlyMatchedException(this.exceptions.broad,a,e)}throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}async fetchMarginAdjustmentHistory(e=void 0,t=void 0,s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.safeBool(a,"auto");if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchMarginAdjustmentHistory () requires a type argument");const n="add"===t;let d=n?"160":"161";if(o){if(!n)throw new r.BadRequest(this.id+" cannot fetch margin adjustments for type "+t);d="162"}const h={subType:d,mgnMode:"isolated"},c=this.safeInteger(a,"until");let l;a=this.omit(a,"until"),void 0!==s&&(h.startTime=s),void 0!==i&&(h.limit=i),void 0!==c&&(h.endTime=c);const u=this.milliseconds(),p=u-7776e6;if(void 0===s||s>u-6048e5)l=await this.privateGetAccountBills(this.extend(h,a));else{if(!(s>p))throw new r.BadRequest(this.id+" fetchMarginAdjustmentHistory () cannot fetch margin adjustments older than 3 months");l=await this.privateGetAccountBillsArchive(this.extend(h,a))}const f=this.safeList(l,"data"),m=this.parseMarginModifications(f);return this.filterBySymbolSinceLimit(m,e,s,i)}async fetchPositionsHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeString(i,"marginMode"),a=this.safeStringUpper(i,"instType");i=this.omit(i,["until","marginMode","instType"]),void 0===s&&(s=100);const o={limit:s};if(void 0!==e){if(1===e.length){const t=this.market(e[0]);o.instId=t.id}}void 0!==r&&(o.mgnMode=r),void 0!==a&&(o.instType=a);const n=await this.privateGetAccountPositionsHistory(this.extend(o,i)),d=this.safeList(n,"data"),h=this.parsePositions(d,e,i);return this.filterBySinceLimit(h,t,s)}}},3573:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(3800),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"onetrading",name:"One Trading",countries:["AT"],rateLimit:300,version:"v1",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!1,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLeverage:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1/MINUTES","5m":"5/MINUTES","15m":"15/MINUTES","30m":"30/MINUTES","1h":"1/HOURS","4h":"4/HOURS","1d":"1/DAYS","1w":"1/WEEKS","1M":"1/MONTHS"},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/bdbc26fd-02f2-4ca7-9f1e-17333690bb1c",api:{public:"https://api.onetrading.com/public",private:"https://api.onetrading.com/public"},www:"https://onetrading.com/",doc:["https://docs.onetrading.com"],fees:"https://onetrading.com/fees"},api:{public:{get:["currencies","candlesticks/{instrument_code}","fees","instruments","order-book/{instrument_code}","market-ticker","market-ticker/{instrument_code}","price-ticks/{instrument_code}","time"]},private:{get:["account/balances","account/deposit/crypto/{currency_code}","account/deposit/fiat/EUR","account/deposits","account/deposits/bitpanda","account/withdrawals","account/withdrawals/bitpanda","account/fees","account/orders","account/orders/{order_id}","account/orders/{order_id}/trades","account/trades","account/trades/{trade_id}","account/trading-volume"],post:["account/deposit/crypto","account/withdraw/crypto","account/withdraw/fiat","account/fees","account/orders"],delete:["account/orders","account/orders/{order_id}","account/orders/client/{client_id}"]}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0015"),maker:this.parseNumber("0.001"),tiers:[{taker:[[this.parseNumber("0"),this.parseNumber("0.0015")],[this.parseNumber("100"),this.parseNumber("0.0013")],[this.parseNumber("250"),this.parseNumber("0.0013")],[this.parseNumber("1000"),this.parseNumber("0.001")],[this.parseNumber("5000"),this.parseNumber("0.0009")],[this.parseNumber("10000"),this.parseNumber("0.00075")],[this.parseNumber("20000"),this.parseNumber("0.00065")]],maker:[[this.parseNumber("0"),this.parseNumber("0.001")],[this.parseNumber("100"),this.parseNumber("0.001")],[this.parseNumber("250"),this.parseNumber("0.0009")],[this.parseNumber("1000"),this.parseNumber("0.00075")],[this.parseNumber("5000"),this.parseNumber("0.0006")],[this.parseNumber("10000"),this.parseNumber("0.0005")],[this.parseNumber("20000"),this.parseNumber("0.0005")]]}]}},requiredCredentials:{apiKey:!0,secret:!1},precisionMode:o.kb,exceptions:{exact:{INVALID_CLIENT_UUID:r.InvalidOrder,ORDER_NOT_FOUND:r.OrderNotFound,ONLY_ONE_ERC20_ADDRESS_ALLOWED:r.InvalidAddress,DEPOSIT_ADDRESS_NOT_USED:r.InvalidAddress,INVALID_CREDENTIALS:r.AuthenticationError,MISSING_CREDENTIALS:r.AuthenticationError,INVALID_APIKEY:r.AuthenticationError,INVALID_SCOPES:r.AuthenticationError,INVALID_SUBJECT:r.AuthenticationError,INVALID_ISSUER:r.AuthenticationError,INVALID_AUDIENCE:r.AuthenticationError,INVALID_DEVICE_ID:r.AuthenticationError,INVALID_IP_RESTRICTION:r.AuthenticationError,APIKEY_REVOKED:r.AuthenticationError,APIKEY_EXPIRED:r.AuthenticationError,SYNCHRONIZER_TOKEN_MISMATCH:r.AuthenticationError,SESSION_EXPIRED:r.AuthenticationError,INTERNAL_ERROR:r.AuthenticationError,CLIENT_IP_BLOCKED:r.PermissionDenied,MISSING_PERMISSION:r.PermissionDenied,ILLEGAL_CHARS:r.BadRequest,UNSUPPORTED_MEDIA_TYPE:r.BadRequest,ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG:r.BadRequest,CANDLESTICKS_TIME_RANGE_TOO_BIG:r.BadRequest,INVALID_INSTRUMENT_CODE:r.BadRequest,INVALID_ORDER_TYPE:r.BadRequest,INVALID_UNIT:r.BadRequest,INVALID_PERIOD:r.BadRequest,INVALID_TIME:r.BadRequest,INVALID_DATE:r.BadRequest,INVALID_CURRENCY:r.BadRequest,INVALID_AMOUNT:r.BadRequest,INVALID_PRICE:r.BadRequest,INVALID_LIMIT:r.BadRequest,INVALID_QUERY:r.BadRequest,INVALID_CURSOR:r.BadRequest,INVALID_ACCOUNT_ID:r.BadRequest,INVALID_SIDE:r.InvalidOrder,INVALID_ACCOUNT_HISTORY_FROM_TIME:r.BadRequest,INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE:r.BadRequest,INVALID_ACCOUNT_HISTORY_TIME_PERIOD:r.BadRequest,INVALID_ACCOUNT_HISTORY_TO_TIME:r.BadRequest,INVALID_CANDLESTICKS_GRANULARITY:r.BadRequest,INVALID_CANDLESTICKS_UNIT:r.BadRequest,INVALID_ORDER_BOOK_DEPTH:r.BadRequest,INVALID_ORDER_BOOK_LEVEL:r.BadRequest,INVALID_PAGE_CURSOR:r.BadRequest,INVALID_TIME_RANGE:r.BadRequest,INVALID_TRADE_ID:r.BadRequest,INVALID_UI_ACCOUNT_SETTINGS:r.BadRequest,NEGATIVE_AMOUNT:r.InvalidOrder,NEGATIVE_PRICE:r.InvalidOrder,MIN_SIZE_NOT_SATISFIED:r.InvalidOrder,BAD_AMOUNT_PRECISION:r.InvalidOrder,BAD_PRICE_PRECISION:r.InvalidOrder,BAD_TRIGGER_PRICE_PRECISION:r.InvalidOrder,MAX_OPEN_ORDERS_EXCEEDED:r.BadRequest,MISSING_PRICE:r.InvalidOrder,MISSING_ORDER_TYPE:r.InvalidOrder,MISSING_SIDE:r.InvalidOrder,MISSING_CANDLESTICKS_PERIOD_PARAM:r.ArgumentsRequired,MISSING_CANDLESTICKS_UNIT_PARAM:r.ArgumentsRequired,MISSING_FROM_PARAM:r.ArgumentsRequired,MISSING_INSTRUMENT_CODE:r.ArgumentsRequired,MISSING_ORDER_ID:r.InvalidOrder,MISSING_TO_PARAM:r.ArgumentsRequired,MISSING_TRADE_ID:r.ArgumentsRequired,INVALID_ORDER_ID:r.OrderNotFound,NOT_FOUND:r.OrderNotFound,INSUFFICIENT_LIQUIDITY:r.InsufficientFunds,INSUFFICIENT_FUNDS:r.InsufficientFunds,NO_TRADING:r.ExchangeNotAvailable,SERVICE_UNAVAILABLE:r.ExchangeNotAvailable,GATEWAY_TIMEOUT:r.ExchangeNotAvailable,RATELIMIT:r.DDoSProtection,CF_RATELIMIT:r.DDoSProtection,INTERNAL_SERVER_ERROR:r.ExchangeError},broad:{}},commonCurrencies:{MIOTA:"IOTA"},options:{fetchTradingFees:{method:"fetchPrivateTradingFees"},fiat:["EUR","CHF"]}})}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"epoch_millis")}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"code"),a=this.safeCurrencyCode(r);s[a]={id:r,code:a,name:void 0,info:i,active:void 0,fee:void 0,precision:this.parseNumber(this.parsePrecision(this.safeString(i,"precision"))),withdraw:void 0,deposit:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:{}}}return s}async fetchMarkets(e={}){const t=await this.publicGetInstruments(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeValue(e,"base",{}),s=this.safeValue(e,"quote",{}),i=this.safeString(t,"code"),r=this.safeString(s,"code"),a=i+"_"+r,o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(r);return{id:a,symbol:o+"/"+n,base:o,quote:n,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"ACTIVE"===this.safeString(e,"state"),contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"amount_precision"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"market_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"min_size"),max:void 0}},created:void 0,info:e}}async fetchTradingFees(e={}){let t=this.safeString(e,"method");if(e=this.omit(e,"method"),void 0===t){const e=this.safeValue(this.options,"fetchTradingFees",{});t=this.safeString(e,"method","fetchPrivateTradingFees")}return await this[t](e)}async fetchPublicTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetFees(e),s=this.safeValue(t,0,{}),i=this.safeValue(s,"fee_tiers"),r=this.parseFeeTiers(i),a=this.safeValue(i,0,{}),o={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e];o[t]={info:s,symbol:t,maker:this.safeNumber(a,"maker_fee"),taker:this.safeNumber(a,"taker_fee"),percentage:!0,tierBased:!0,tiers:r}}return o}async fetchPrivateTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetAccountFees(e),s=this.safeValue(t,"active_fee_tier",{});let i=this.safeString(s,"maker_fee"),r=this.safeString(s,"taker_fee");i=a.Y.stringDiv(i,"100"),r=a.Y.stringDiv(r,"100");const o=this.safeValue(t,"fee_tiers"),n={},d=this.parseFeeTiers(o);for(let e=0;e<this.symbols.length;e++){const s=this.symbols[e];n[s]={info:t,symbol:s,maker:this.parseNumber(i),taker:this.parseNumber(r),percentage:!0,tierBased:!0,tiers:d}}return n}parseFeeTiers(e,t=void 0){const s=[],i=[];for(let t=0;t<e.length;t++){const r=e[t],o=this.safeNumber(r,"volume");let n=this.safeString(r,"taker_fee"),d=this.safeString(r,"maker_fee");d=a.Y.stringDiv(d,"100"),n=a.Y.stringDiv(n,"100"),i.push([o,this.parseNumber(d)]),s.push([o,this.parseNumber(n)])}return{maker:i,taker:s}}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"instrument_code"),r=this.safeSymbol(i,t,"_"),a=this.safeString(e,"last_price"),o=this.safeString(e,"price_change_percentage"),n=this.safeString(e,"price_change"),d=this.safeString(e,"base_volume"),h=this.safeString(e,"quote_volume");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"best_bid"),bidVolume:void 0,ask:this.safeString(e,"best_ask"),askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:n,percentage:o,average:void 0,baseVolume:d,quoteVolume:h,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={instrument_code:s.id},r=await this.publicGetMarketTickerInstrumentCode(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketTicker(t),i={};for(let e=0;e<s.length;e++){const t=this.parseTicker(s[e]);i[t.symbol]=t}return this.filterByArrayTickers(i,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={instrument_code:i.id};void 0!==t&&(r.depth=t);const a=await this.publicGetOrderBookInstrumentCode(this.extend(r,s)),o=this.parse8601(this.safeString(a,"time"));return this.parseOrderBook(a,i.symbol,o,"bids","asks","price","amount")}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"granularity"),i=this.safeString(s,"unit"),r=this.safeString(s,"period")+this.safeString({MINUTES:"m",HOURS:"h",DAYS:"d",WEEKS:"w",MONTHS:"M"},i),a=1e3*this.parseTimeframe(r),o=this.parse8601(this.safeString(e,"time")),n=a*this.parseToInt(o/a),d=this.safeValue(this.options,"fetchOHLCV",{}),h=this.safeString(d,"volume","total_amount");return[n,this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,h)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t),[n,d]=o.split("/"),h=1e3*this.parseTimeframe(t);void 0===i&&(i=1500);const c={instrument_code:a.id,period:n,unit:d};if(void 0===s){const e=this.milliseconds();c.to=this.iso8601(e),c.from=this.iso8601(e-i*h)}else c.from=this.iso8601(s),c.to=this.iso8601(this.sum(s,i*h));const l=await this.publicGetCandlesticksInstrumentCode(this.extend(c,r));return this.parseOHLCVs(l,a,t,s,i)}parseTrade(e,t=void 0){const s=this.safeValue(e,"fee",{});e=this.safeValue(e,"trade",e);let i=this.safeInteger(e,"trade_timestamp");void 0===i&&(i=this.parse8601(this.safeString(e,"time")));const r=this.safeStringLower2(e,"side","taker_side"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),n=this.safeString(e,"volume"),d=this.safeString(e,"instrument_code"),h=this.safeSymbol(d,t,"_"),c=this.safeString(s,"fee_amount");let l,u;if(void 0!==c){const e=this.safeString(s,"fee_currency");u={cost:c,currency:this.safeCurrencyCode(e),rate:this.safeString(s,"fee_percentage")},l=this.safeStringLower(s,"fee_type")}return this.safeTrade({id:this.safeString2(e,"trade_id","sequence"),order:this.safeString(e,"order_id"),timestamp:i,datetime:this.iso8601(i),symbol:h,type:void 0,side:r,price:a,amount:o,cost:n,takerOrMaker:l,fee:u,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={instrument_code:r.id};void 0!==t&&(a.from=this.iso8601(t),a.to=this.iso8601(this.sum(t,144e5)));const o=await this.publicGetPriceTicksInstrumentCode(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseBalance(e){const t=this.safeValue(e,"balances",[]),s={info:e};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency_code"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"available"),o.used=this.safeString(i,"locked"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalances(e);return this.parseBalance(t)}parseDepositAddress(e,t=void 0){let s;void 0!==t&&(s=t.code);const i=this.safeString(e,"address"),r=this.safeString(e,"destination_tag");return this.checkAddress(i),{currency:s,address:i,tag:r,network:void 0,info:e}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.privatePostAccountDepositCrypto(this.extend(i,t));return this.parseDepositAddress(r,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_code:s.id},r=await this.privateGetAccountDepositCryptoCurrencyCode(this.extend(i,t));return this.parseDepositAddress(r,s)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e&&(o=this.currency(e),a.currency_code=o.id),void 0!==s&&(a.max_page_size=s),void 0!==t){if(void 0===this.safeString(i,"to"))throw new r.ArgumentsRequired(this.id+' fetchDeposits() requires a "to" iso8601 string param with the since argument is specified');a.from=this.iso8601(t)}const n=await this.privateGetAccountDeposits(this.extend(a,i)),d=this.safeList(n,"deposit_history",[]);return this.parseTransactions(d,o,t,s,{type:"deposit"})}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e&&(o=this.currency(e),a.currency_code=o.id),void 0!==s&&(a.max_page_size=s),void 0!==t){if(void 0===this.safeString(i,"to"))throw new r.ArgumentsRequired(this.id+' fetchWithdrawals() requires a "to" iso8601 string param with the since argument is specified');a.from=this.iso8601(t)}const n=await this.privateGetAccountWithdrawals(this.extend(a,i)),d=this.safeList(n,"withdrawal_history",[]);return this.parseTransactions(d,o,t,s,{type:"withdrawal"})}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={currency:e,amount:this.currencyToPrecision(e,t)},d=this.safeValue(this.options,"fiat",[]),h=this.inArray(e,d),c=h?"privatePostAccountWithdrawFiat":"privatePostAccountWithdrawCrypto";if(h){if(void 0===this.safeString(a,"payout_account_id"))throw new r.ArgumentsRequired(this.id+" withdraw() requires a payout_account_id param for fiat "+e+" withdrawals")}else{const e={address:s};void 0!==i&&(e.destination_tag=i),n.recipient=e}const l=await this[c](this.extend(n,a));return this.parseTransaction(l,o)}parseTransaction(e,t=void 0){const s=this.safeString(e,"transaction_id"),i=this.safeNumber(e,"amount"),r=this.parse8601(this.safeString(e,"time")),a=this.safeString(e,"currency");t=this.safeCurrency(a,t);const o=this.safeNumber2(e,"fee_amount","fee");let n;const d=this.safeString(e,"recipient"),h=this.safeString(e,"destination_tag");if(void 0!==o){const t=this.safeString(e,"fee_currency",a);n={cost:o,currency:this.safeCurrencyCode(t)}}return{info:e,id:s,currency:t.code,amount:i,network:void 0,address:d,addressFrom:void 0,addressTo:d,tag:h,tagFrom:void 0,tagTo:h,status:"ok",type:void 0,updated:void 0,txid:this.safeString(e,"blockchain_transaction_id"),comment:void 0,internal:void 0,timestamp:r,datetime:this.iso8601(r),fee:n}}parseOrderStatus(e){return this.safeString({FILLED:"open",FILLED_FULLY:"closed",FILLED_CLOSED:"canceled",FILLED_REJECTED:"rejected",OPEN:"open",REJECTED:"rejected",CLOSED:"canceled",FAILED:"failed",STOP_TRIGGERED:"triggered"},e,e)}parseOrder(e,t=void 0){const s=this.safeValue(e,"order",e),i=this.safeString(s,"order_id"),r=this.safeString(s,"client_id"),a=this.parse8601(this.safeString(s,"time")),o=this.parseOrderStatus(this.safeString(s,"status")),n=this.parseOrderStatus(o),d=this.safeString(s,"instrument_code"),h=this.safeSymbol(d,t,"_"),c=this.safeString(s,"price"),l=this.safeString(s,"amount"),u=this.safeString(s,"filled_amount"),p=this.safeStringLower(s,"side"),f=this.safeStringLower(s,"type"),m=this.parseTimeInForce(this.safeString(s,"time_in_force")),g=this.safeNumber(s,"trigger_price"),v=this.safeValue(s,"is_post_only"),y=this.safeValue(e,"trades",[]);return this.safeOrder({id:i,clientOrderId:r,info:e,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,symbol:h,type:f,timeInForce:m,postOnly:v,side:p,price:c,stopPrice:g,triggerPrice:g,amount:l,cost:void 0,average:void 0,filled:u,remaining:void 0,status:n,trades:y},t)}parseTimeInForce(e){return this.safeString({GOOD_TILL_CANCELLED:"GTC",GOOD_TILL_TIME:"GTT",IMMEDIATE_OR_CANCELLED:"IOC",FILL_OR_KILL:"FOK"},e,e)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=t.toUpperCase(),h={instrument_code:n.id,type:d,side:s.toUpperCase(),amount:this.amountToPrecision(e,i)};let c=!1;"LIMIT"!==d&&"STOP"!==d||(c=!0);const l=this.safeNumberN(o,["triggerPrice","trigger_price","stopPrice"]);if(void 0!==l){if("MARKET"===d)throw new r.BadRequest(this.id+" createOrder() cannot place stop market orders, only stop limit");h.trigger_price=this.priceToPrecision(e,l),h.type="STOP",o=this.omit(o,["triggerPrice","trigger_price","stopPrice"])}else if("STOP"===d)throw new r.ArgumentsRequired(this.id+" createOrder() requires a triggerPrice param for "+t+" orders");c&&(h.price=this.priceToPrecision(e,a));const u=this.safeString2(o,"clientOrderId","client_id");void 0!==u&&(h.client_id=u,o=this.omit(o,["clientOrderId","client_id"]));const p=await this.privatePostAccountOrders(this.extend(h,o));return this.parseOrder(p,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeString2(s,"clientOrderId","client_id");s=this.omit(s,["clientOrderId","client_id"]);let r="privateDeleteAccountOrdersOrderId";const a={};void 0!==i?(r="privateDeleteAccountOrdersClientClientId",a.client_id=i):a.order_id=e;return await this[r](this.extend(a,s))}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=this.market(e);s.instrument_code=t.id}return await this.privateDeleteAccountOrders(this.extend(s,t))}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={ids:e.join(",")};return await this.privateDeleteAccountOrders(this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:e},r=await this.privateGetAccountOrdersOrderId(this.extend(i,s));return this.parseOrder(r)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e&&(o=this.market(e),a.instrument_code=o.id),void 0!==t){if(void 0===this.safeString(i,"to"))throw new r.ArgumentsRequired(this.id+' fetchOpenOrders() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');a.from=this.iso8601(t)}void 0!==s&&(a.max_page_size=s);const n=await this.privateGetAccountOrders(this.extend(a,i)),d=this.safeList(n,"order_history",[]);return this.parseOrders(d,o,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOpenOrders(e,t,s,this.extend({with_cancelled_and_rejected:!0},i))}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={order_id:e};void 0!==i&&(a.max_page_size=i);const o=await this.privateGetAccountOrdersOrderIdTrades(this.extend(a,r)),n=this.safeValue(o,"trade_history",[]);let d;return void 0!==t&&(d=this.market(t)),this.parseTrades(n,d,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const a={};let o;if(void 0!==e&&(o=this.market(e),a.instrument_code=o.id),void 0!==t){if(void 0===this.safeString(i,"to"))throw new r.ArgumentsRequired(this.id+' fetchMyTrades() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');a.from=this.iso8601(t)}void 0!==s&&(a.max_page_size=s);const n=await this.privateGetAccountTrades(this.extend(a,i)),d=this.safeList(n,"trade_history",[]);return this.parseTrades(d,o,t,s)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t]+"/"+this.version+"/"+this.implodeParams(e,i);const n=this.omit(i,this.extractParams(e));return"public"===t?Object.keys(n).length&&(o+="?"+this.urlencode(n)):"private"===t&&(this.checkRequiredCredentials(),r={Accept:"application/json",Authorization:"Bearer "+this.apiKey},"POST"===s?(a=this.json(n),r["Content-Type"]="application/json"):Object.keys(n).length&&(o+="?"+this.urlencode(n))),{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"error");if(void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}}},6358:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9401),r=s(5147),a=s(2079),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"oxfun",name:"OXFUN",countries:["PA"],version:"v3",rateLimit:120,pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createPostOnlyOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,deposit:!1,editOrder:!1,fetchAccounts:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!1,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!0,ws:!0},timeframes:{"1m":"60s","5m":"300s","15m":"900s","30m":"1800s","1h":"3600s","2h":"7200s","4h":"14400s","1d":"86400s"},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/6a196124-c1ee-4fae-8573-962071b61a85",referral:"https://ox.fun/register?shareAccountId=5ZUD4a7G",api:{public:"https://api.ox.fun",private:"https://api.ox.fun"},test:{public:"https://stgapi.ox.fun",private:"https://stgapi.ox.fun"},www:"https://ox.fun/",doc:"https://docs.ox.fun/",fees:"https://support.ox.fun/en/articles/8819866-trading-fees"},api:{public:{get:{"v3/markets":1,"v3/assets":1,"v3/tickers":1,"v3/funding/estimates":1,"v3/candles":1,"v3/depth":1,"v3/markets/operational":1,"v3/exchange-trades":1,"v3/funding/rates":1,"v3/leverage/tiers":1}},private:{get:{"v3/account":1,"v3/account/names":1,"v3/wallet":1,"v3/transfer":1,"v3/balances":1,"v3/positions":1,"v3/funding":1,"v3/deposit-addresses":1,"v3/deposit":1,"v3/withdrawal-addresses":1,"v3/withdrawal":1,"v3/withdrawal-fees":1,"v3/orders/status":1,"v3/orders/working":1,"v3/trades":1},post:{"v3/transfer":1,"v3/withdrawal":1,"v3/orders/place":1},delete:{"v3/orders/cancel":1,"v3/orders/cancel-all":1}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.00020"),taker:this.parseNumber("0.00070"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.00020")],[this.parseNumber("2500000"),this.parseNumber("0.00010")],[this.parseNumber("25000000"),this.parseNumber("0")]],taker:[[this.parseNumber("0"),this.parseNumber("0.00070")],[this.parseNumber("2500000"),this.parseNumber("0.00050")],[this.parseNumber("25000000"),this.parseNumber("0.00040")]]}}},precisionMode:o.kb,options:{sandboxMode:!1,networks:{BTC:"Bitcoin",ERC20:"Ethereum",AVAX:"Avalanche",SOL:"Solana",ARB:"Arbitrum",MATIC:"Polygon",FTM:"Fantom",BNB:"BNBSmartChain",OPTIMISM:"Optimism"},networksById:{Bitcoin:"BTC",Ethereum:"ERC20",Avalanche:"AVAX",Solana:"SOL",Arbitrum:"ARB",Polygon:"MATIC",Fantom:"FTM",Base:"BASE",BNBSmartChain:"BNB",Optimism:"OPTIMISM"}},exceptions:{exact:{"-0010":a.OperationFailed,"-429":a.RateLimitExceeded,"-05001":a.AuthenticationError,"-10001":a.ExchangeError,"-20000":a.BadRequest,"-20001":a.BadRequest,"-20002":a.BadRequest,"-20003":a.NotSupported,"-20005":a.AuthenticationError,"-20006":a.BadRequest,"-20007":a.AuthenticationError,"-20008":a.BadRequest,"-20009":a.BadRequest,"-20010":a.ArgumentsRequired,"-20011":a.ArgumentsRequired,"-20012":a.ArgumentsRequired,"-20013":a.ArgumentsRequired,"-20014":a.BadRequest,"-20015":a.BadSymbol,"-20016":a.BadRequest,"-20017":a.BadRequest,"-20018":a.BadRequest,"-20019":a.BadRequest,"-20020":a.BadRequest,"-20021":a.BadRequest,"-20022":a.ArgumentsRequired,"-20023":a.ArgumentsRequired,"-20024":a.ExchangeError,"-20025":a.AuthenticationError,"-20026":a.BadRequest,"-20027":a.BadRequest,"-20028":a.BadRequest,"-20029":a.BadRequest,"-20030":a.BadRequest,"-20031":a.MarketClosed,"-20032":a.NetworkError,"-20033":a.BadRequest,"-20034":a.BadRequest,"-20050":a.ExchangeError,"-30001":a.BadRequest,"-35034":a.AuthenticationError,"-35046":a.AuthenticationError,"-40001":a.ExchangeError,"-50001":a.ExchangeError,"-300001":a.AccountNotEnabled,"-300011":a.InvalidOrder,"-300012":a.InvalidOrder,"-100005":a.OrderNotFound,"-100006":a.InvalidOrder,"-100008":a.BadRequest,"-100015":a.NetworkError,"-710001":a.ExchangeError,"-710002":a.BadRequest,"-710003":a.BadRequest,"-710004":a.BadRequest,"-710005":a.InsufficientFunds,"-710006":a.InsufficientFunds,"-710007":a.InsufficientFunds,"-000101":a.NetworkError,"-000201":a.NetworkError},broad:{"-20001":a.OperationFailed,"-200050":a.RequestTimeout}}})}async fetchMarkets(e={}){const[t,s]=await Promise.all([this.publicGetV3Markets(e),this.publicGetV3Tickers(e)]),i=this.safeList(t,"data",[]),r=this.safeList(s,"data",[]),a=this.arrayConcat(i,r);return this.parseMarkets(a)}parseMarkets(e){const t=[],s=[];for(let i=0;i<e.length;i++){const r=e[i],a=this.safeString(r,"marketCode");this.inArray(a,t)||(t.push(a),s.push(this.parseMarket(r)))}return s}parseMarket(e){const t=this.safeString(e,"marketCode",""),s=t.split("-"),i=this.safeString(s,0),r=this.safeString(s,1),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r);let n,d,h=a+"/"+o,c=this.safeStringLower(e,"type","spot");const l="future"===c;l&&(c="swap",n="OX",d=this.safeCurrencyCode("OX"),h=h+":"+d);const u="spot"===c;return this.safeMarketStructure({id:t,numericId:void 0,symbol:h,base:a,quote:o,settle:d,baseId:i,quoteId:r,settleId:n,type:c,spot:u,margin:!1,swap:l,future:!1,option:!1,active:!0,contract:l,linear:!!l||void 0,inverse:!l&&void 0,taker:this.fees.trading.taker,maker:this.fees.trading.maker,contractSize:l?1:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:void 0,price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minSize"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:this.safeInteger(e,"listedAt"),index:void 0,info:e})}async fetchCurrencies(e={}){const t=await this.publicGetV3Assets(e),s=this.safeList(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],a=this.safeString(t,"asset","").split(".")[0],o=this.safeCurrencyCode(a);let n={};const d=this.safeList(t,"networkList",[]);let h,c,l;for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"network"),i=this.networkIdToCode(s),a=this.safeBool(t,"canDeposit"),o=this.safeBool(t,"canWithdraw"),u=a&&o,p=this.safeString(t,"minDeposit"),f=this.safeString(t,"minWithdrawal"),m=this.parsePrecision(this.safeString(t,"transactionPrecision"));n[i]={id:s,network:i,margin:void 0,deposit:a,withdraw:o,active:u,fee:void 0,precision:this.parseNumber(m),limits:{deposit:{min:p,max:void 0},withdraw:{min:f,max:void 0}},info:t},(void 0===c||a)&&(c=a),(void 0===l||o)&&(l=o),(void 0===h||r.Y.stringGt(h,m))&&(h=m)}o in i&&(n=this.extend(i[o].networks,n)),i[o]={id:a,code:o,name:void 0,type:void 0,active:void 0,deposit:c,withdraw:l,fee:void 0,precision:this.parseNumber(h),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},networks:n,info:t}}return i}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetV3Tickers(t),i=this.safeList(s,"data",[]);return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={marketCode:s.id},r=await this.publicGetV3Tickers(this.extend(i,t)),a=this.safeList(r,"data",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"lastUpdatedAt"),i=this.safeString(e,"marketCode"),r=(t=this.safeMarket(i,t)).symbol,a=this.safeString(e,"lastTradedPrice");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high24h"),low:this.safeString(e,"low24h"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open24h"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"currencyVolume24h"),quoteVolume:void 0,info:e},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);t=this.safeString(this.timeframes,t,t);const o={marketCode:a.id,timeframe:t};void 0!==s&&(o.startTime=s),void 0!==i&&(o.limit=i);const n=this.safeInteger(r,"until");void 0!==n?(o.endTime=n,r=this.omit(r,"until")):void 0!==s&&(o.endTime=this.sum(s,6048e5));const d=await this.publicGetV3Candles(this.extend(o,r)),h=this.safeList(d,"data",[]);return this.parseOHLCVs(h,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"openedAt"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"currencyVolume")]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={marketCode:i.id};void 0!==t&&(r.level=t);const a=await this.publicGetV3Depth(this.extend(r,s)),o=this.safeDict(a,"data",{}),n=this.safeInteger(o,"lastUpdatedAt");return this.parseOrderBook(o,i.symbol,n)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetV3FundingEstimates(t),i=this.safeList(s,"data",[]),r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"marketCode");t=this.market(s);const i=this.safeInteger(e,"fundingAt");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:i,datetime:this.iso8601(i),fundingRate:this.safeNumber(e,"estFundingRate"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={marketCode:r.id};void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s);const o=this.safeInteger(i,"until");void 0!==o&&(a.endTime=o,i=this.omit(i,"until"));const n=await this.publicGetV3FundingRates(this.extend(a,i)),d=this.safeList(n,"data",[]);return this.parseFundingRateHistories(d,r,t,s)}parseFundingRateHistory(e,t=void 0){const s=this.safeString(e,"marketCode"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeInteger(e,"createdAt");return{info:e,symbol:i,fundingRate:this.safeNumber(e,"fundingRate"),timestamp:r,datetime:this.iso8601(r)}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={marketCode:r.id};void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s);const o=this.safeInteger(i,"until");void 0!==o&&(a.endTime=o,i=this.omit(i,"until"));const n=await this.privateGetV3Funding(this.extend(a,i)),d=this.safeList(n,"data",[]);return this.parseIncomes(d,r,t,s)}parseIncome(e,t=void 0){const s=this.safeString(e,"marketCode"),i=this.safeSymbol(s,t),r=this.safeNumber(e,"payment"),a=this.safeCurrencyCode("OX"),o=this.safeString(e,"id"),n=this.safeTimestamp(e,"createdAt"),d=this.safeNumber(e,"fundingRate");return{info:e,symbol:i,code:a,timestamp:n,datetime:this.iso8601(n),id:o,amount:r,rate:d}}async fetchLeverageTiers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetV3LeverageTiers(t),i=this.safeList(s,"data",[]);return this.parseLeverageTiers(i,e,"marketCode")}parseMarketLeverageTiers(e,t=void 0){const s=this.safeString(e,"marketCode");t=this.safeMarket(s,t);const i=this.safeList(e,"tiers",[]),r=[];for(let e=0;e<i.length;e++){const s=i[e];r.push({tier:this.safeNumber(s,"tier"),currency:t.settle,minNotional:this.safeNumber(s,"positionFloor"),maxNotional:this.safeNumber(s,"positionCap"),maintenanceMarginRate:this.safeNumber(s,"maintenanceMargin"),maxLeverage:this.safeNumber(s,"leverage"),info:s})}return r}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={marketCode:r.id};void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s);const o=this.safeInteger(i,"until");void 0!==o?(a.endTime=o,i=this.omit(i,"until")):void 0!==t&&(a.endTime=this.sum(t,6048e5));const n=await this.publicGetV3ExchangeTrades(this.extend(a,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.marketCode=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");void 0!==o?(r.endTime=o,i=this.omit(i,"until")):void 0!==t&&(r.endTime=this.sum(t,6048e5));const n=await this.privateGetV3Trades(this.extend(r,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,a,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"marketCode"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeInteger(e,"matchedAt"),a={cost:this.safeString(e,"fee"),currency:this.safeCurrencyCode(this.safeString(e,"feeAsset"))};return this.safeTrade({id:this.safeString(e,"matchId"),timestamp:r,datetime:this.iso8601(r),symbol:i,type:void 0,order:this.safeString(e,"orderId"),side:this.safeStringLower(e,"side"),takerOrMaker:this.safeStringLower2(e,"matchType","orderMatchType"),price:this.safeString(e,"matchPrice"),amount:this.safeString2(e,"matchQuantity","matchedQuantity"),cost:void 0,fee:a,info:e},t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetV3Balances(e),s=this.safeList(t,"data",[]);let i=s[0];const r=this.safeString(e,"subAcc");if(void 0!==r)for(let e=0;e<s.length;e++){const t=s[e];if(this.safeString(t,"name")===r){i=t;break}}return this.parseBalance(i)}parseBalance(e){const t={info:e},s=this.safeList(e,"balances",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"total"),o.free=this.safeString(i,"available"),o.used=this.safeString(i,"reserved"),t[a]=o}return this.safeBalance(t)}async fetchAccounts(e={}){await this.loadMarkets();const t=await this.privateGetV3AccountNames(e),s=this.safeList(t,"data",[]);return this.parseAccounts(s,e)}parseAccount(e){return{id:this.safeString(e,"accountId"),type:void 0,code:void 0,info:e}}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={asset:a.id,quantity:this.currencyToPrecision(e,t),fromAccount:s,toAccount:i},n=await this.privatePostV3Transfer(this.extend(o,r)),d=this.safeDict(n,"data",{});return this.parseTransfer(d,a)}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");void 0!==o?(r.endTime=o,i=this.omit(i,"until")):void 0!==t&&(r.endTime=this.sum(t,6048e5));const n=await this.privateGetV3Transfer(this.extend(r,i)),d=this.safeList(n,"data",[]);return this.parseTransfers(d,a,t,s)}parseTransfer(e,t=void 0){const s=this.safeInteger(e,"transferredAt"),i=this.safeString(e,"asset");return{id:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"quantity"),fromAccount:this.safeString(e,"fromAccount"),toAccount:this.safeString(e,"toAccount"),status:this.parseTransferStatus(this.safeString(e,"status")),info:e}}parseTransferStatus(e){return this.safeString({COMPLETED:"ok"},e,e)}async fetchDepositAddress(e,t={}){const s=this.safeString(t,"network"),i=this.networkCodeToId(s,e);if(void 0===i)throw new a.BadRequest(this.id+" fetchDepositAddress() require network parameter");await this.loadMarkets();const r=this.currency(e),o={asset:r.id,network:i};t=this.omit(t,"network");const n=await this.privateGetV3DepositAddresses(this.extend(o,t)),d=this.safeDict(n,"data",{});return this.parseDepositAddress(d,r)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:t.code,address:s,tag:void 0,network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");void 0!==o&&(r.endTime=o,i=this.omit(i,"until"));const n=await this.privateGetV3Deposit(this.extend(r,i)),d=this.safeList(n,"data",[]);for(let e=0;e<d.length;e++)d[e].type="deposit";return this.parseTransactions(d,a,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.asset=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");void 0!==o&&(r.endTime=o,i=this.omit(i,"until"));const n=await this.privateGetV3Withdrawal(this.extend(r,i)),d=this.safeList(n,"data",[]);for(let e=0;e<d.length;e++)d[e].type="withdrawal";return this.parseTransactions(d,a,t,s)}parseTransactions(e,t=void 0,s=void 0,i=void 0,r={}){let a=[];for(let s=0;s<e.length;s++){e[s]=this.extend(e[s],r);const i=this.parseTransaction(e[s],t);a.push(i)}a=this.sortBy(a,"timestamp");const o=void 0!==t?t.code:void 0;return this.filterByCurrencySinceLimit(a,o,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"type");let r,a,o;e=this.omit(e,"type"),"deposit"===i?(r=this.safeString(e,"address"),o=this.parseDepositStatus(this.safeString(e,"status"))):"withdrawal"===i&&(a=this.safeString(e,"address"),o=this.parseWithdrawalStatus(this.safeString(e,"status")));const n=this.safeString(e,"txId"),d=this.safeString(e,"asset"),h=this.safeCurrencyCode(d,t),c=this.safeString(e,"network"),l=this.networkIdToCode(c),u=this.safeInteger2(e,"creditedAt","requestedAt"),p=this.safeNumber(e,"quantity"),f=this.safeNumber(e,"fee");let m;return void 0!==f&&(m={cost:f,currency:h}),{info:e,id:s,txid:n,timestamp:u,datetime:this.iso8601(u),network:l,address:r,addressTo:a,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:i,amount:p,currency:h,status:o,updated:void 0,internal:void 0,comment:void 0,fee:m}}parseDepositStatus(e){return this.safeString({COMPLETED:"ok"},e,e)}parseWithdrawalStatus(e){return this.safeString({COMPLETED:"ok",PROCESSING:"pending","IN SWEEPING":"pending",PENDING:"pending","ON HOLD":"pending",CANCELED:"canceled",FAILED:"failed"},e,e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets();const a=this.currency(e),o=this.currencyToPrecision(e,t),n={asset:a.id,address:s,quantity:o};let d;void 0!==i&&(n.memo=i),[d,r]=this.handleNetworkCodeAndParams(r),void 0!==d&&(n.network=this.networkCodeToId(d)),n.externalFee=!1;const h=await this.privatePostV3Withdrawal(this.extend(n,r)),c=this.safeDict(h,"data",{});return c.type="withdrawal",this.parseTransaction(c,a)}async fetchPositions(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.privateGetV3Positions(t),i=this.safeList(s,"data",[]);let r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeList(t,"positions",[]);r=this.arrayConcat(r,s)}return this.parsePositions(r,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"marketCode");return t=this.safeMarket(s,t),this.safePosition({info:e,id:void 0,symbol:t.symbol,notional:void 0,marginMode:"cross",liquidationPrice:this.safeNumber(e,"estLiquidationPrice"),entryPrice:this.safeNumber(e,"entryPrice"),unrealizedPnl:this.safeNumber(e,"positionPnl"),realizedPnl:void 0,percentage:void 0,contracts:this.safeNumber(e,"position"),contractSize:void 0,markPrice:this.safeNumber(e,"markPrice"),lastPrice:void 0,side:void 0,hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:this.safeInteger(e,"lastUpdatedAt"),maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o={responseType:this.safeString(a,"responseType","FULL"),timestamp:this.safeInteger(a,"timestamp",this.milliseconds())};a=this.omit(a,["responseType","timestamp"]);const n=this.safeInteger(a,"recvWindow");void 0!==n&&(o.recvWindow=n,a=this.omit(a,"recvWindow"));const d=this.createOrderRequest(e,t,s,i,r,a);o.orders=[d];const h=await this.privatePostV3OrdersPlace(o),c=this.safeList(h,"data",[]),l=this.safeDict(c,0,{});return this.parseOrder(l)}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"symbol"),a=this.safeString(i,"type"),o=this.safeString(i,"side"),n=this.safeNumber(i,"amount"),d=this.safeNumber(i,"price"),h=this.safeDict(i,"params",{}),c=this.createOrderRequest(r,a,o,n,d,h);s.push(c)}const i={responseType:"FULL",timestamp:this.milliseconds(),orders:s},r=await this.privatePostV3OrdersPlace(this.extend(i,t)),a=this.safeList(r,"data",[]);return this.parseOrders(a)}createOrderRequest(e,t,s,i,r=void 0,a={}){const o={marketCode:this.market(e).id,side:s.toUpperCase(),source:1e3},n=this.safeString2(a,"cost","amount");void 0!==n?(o.amount=n,a=this.omit(a,["cost","amount"])):o.quantity=i;const d=this.safeString2(a,"triggerPrice","stopPrice");let h,c=t.toUpperCase();void 0!==d&&("MARKET"===c?c="STOP_MARKET":"LIMIT"===c&&(c="STOP_LIMIT"),o.stopPrice=d,a=this.omit(a,["triggerPrice","stopPrice"])),o.orderType=c,"STOP_LIMIT"===c?o.limitPrice=r:void 0!==r&&(o.price=r);const l="MARKET"===c||"STOP_MARKET"===c;[h,a]=this.handlePostOnly(l,!1,a);const u=this.safeStringUpper(a,"timeInForce");return h&&"MAKER_ONLY_REPRICE"!==u&&(o.timeInForce="MAKER_ONLY"),this.extend(o,a)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new a.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");const i={cost:t};return await this.createOrder(e,"market","buy",void 0,void 0,this.extend(i,s))}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderId:e},r=await this.privateGetV3OrdersStatus(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r;void 0!==e&&(r=this.market(e));const a=await this.privateGetV3OrdersWorking(this.extend({},i)),o=this.safeList(a,"data",[]);return this.parseOrders(o,r,t,s)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");const i=this.market(t).id,r={timestamp:this.milliseconds(),responseType:"FULL"},o={marketCode:i,orderId:e},n=this.safeInteger(s,"clientOrderId");void 0!==n&&(o.clientOrderId=n),r.orders=[o];const d=await this.privateDeleteV3OrdersCancel(this.extend(r,s)),h=this.safeList(d,"data",[]),c=this.safeDict(h,0,{});return this.parseOrder(c)}async cancelAllOrders(e=void 0,t={}){const s={};if(void 0!==e){const t=this.market(e);s.marketCode=t.id}return await this.privateDeleteV3OrdersCancelAll(this.extend(s,t))}async cancelOrders(e,t=void 0,s={}){if(void 0===t)throw new a.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t),r=i.id,o={timestamp:this.milliseconds(),responseType:"FULL"},n=[];for(let t=0;t<e.length;t++){const s={marketCode:r,orderId:e[t]};n.push(s)}o.orders=n;const d=await this.privateDeleteV3OrdersCancel(this.extend(o,s)),h=this.safeList(d,"data",[]);return this.parseOrders(h,i)}parseOrder(e,t=void 0){const s=this.safeString(e,"marketCode");t=this.safeMarket(s,t);const i=this.safeInteger(e,"createdAt");let r;const a=this.safeString(e,"feeInstrumentId");void 0!==a&&(r={currency:this.safeCurrencyCode(a),cost:this.safeNumber(e,"fees")});let o=this.safeString(e,"status");void 0!==this.safeInteger(e,"code")&&(o="rejected");const n=this.safeString(e,"stopPrice");return this.safeOrder({id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"clientOrderId"),timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:this.safeInteger(e,"lastMatchedAt"),lastUpdateTimestamp:this.safeInteger(e,"lastModifiedAt"),status:this.parseOrderStatus(o),symbol:t.symbol,type:this.parseOrderType(this.safeString(e,"orderType")),timeInForce:this.parseOrderTimeInForce(this.safeString(e,"timeInForce")),side:this.safeStringLower(e,"side"),price:this.safeStringN(e,["price","matchPrice","limitPrice"]),average:void 0,amount:this.safeString2(e,"totalQuantity","quantity"),filled:this.safeString2(e,"cumulativeMatchedQuantity","matchQuantity"),remaining:this.safeString(e,"remainQuantity"),triggerPrice:n,stopLossPrice:n,cost:this.omitZero(this.safeString(e,"amount")),trades:void 0,fee:r,info:e},t)}parseOrderStatus(e){return this.safeString({OPEN:"open",PARTIALLY_FILLED:"open",PARTIAL_FILL:"open",FILLED:"closed",CANCELED:"canceled",CANCELED_BY_USER:"canceled",CANCELED_BY_MAKER_ONLY:"rejected",CANCELED_BY_FOK:"rejected",CANCELED_ALL_BY_IOC:"rejected",CANCELED_PARTIAL_BY_IOC:"canceled",CANCELED_BY_SELF_TRADE_PROTECTION:"rejected"},e,e)}parseOrderType(e){return this.safeString({LIMIT:"limit",STOP_LIMIT:"limit",MARKET:"market",STOP_MARKET:"market"},e,e)}parseOrderTimeInForce(e){return this.safeString({GTC:"GTC",IOC:"IOC",FOK:"FOK",MAKER_ONLY:"PO",MAKER_ONLY_REPRICE:"PO"},e,e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.urls.api[t];let d=o+"/"+e,h="";if("GET"===s&&(h=this.urlencode(i),0!==h.length&&(d+="?"+h)),"private"===t){this.checkRequiredCredentials();const t=this.milliseconds(),d=this.iso8601(t).split(".")[0],c=this.nonce(),l=o.split("//");"POST"!==s&&"DELETE"!==s||(h=a=this.json(i));const u=d+"\n"+c.toString()+"\n"+s+"\n"+l[1]+"\n/"+e+"\n"+h,p=this.hmac(this.encode(u),this.encode(this.secret),n.s,"base64");r={"Content-Type":"application/json",AccessKey:this.apiKey,Timestamp:d,Signature:p,Nonce:c}}return{url:d,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,o,n,d,h){if(void 0!==n&&200!==e){const e=this.safeString(n,"code",void 0),t=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,o,t),this.throwExactlyMatchedException(this.exceptions.exact,e,t),new a.ExchangeError(t)}}}},4998:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7849),r=s(2079),a=s(1579),o=s(7481);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"p2b",name:"p2b",countries:["LT"],rateLimit:100,version:"v2",pro:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createMarketOrder:!1,createOrder:!0,createOrders:!1,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLedgerEntry:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!0,fetchPermissions:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawAddresses:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1},timeframes:{"1m":"1m","1h":"1h","1d":"1d"},urls:{extension:".json",referral:"https://p2pb2b.com?referral=ee784c53",logo:"https://github.com/ccxt/ccxt/assets/43336371/8da13a80-1f0a-49be-bb90-ff8b25164755",api:{public:"https://api.p2pb2b.com/api/v2/public",private:"https://api.p2pb2b.com/api/v2"},www:"https://p2pb2b.com/",doc:"https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md",fees:"https://p2pb2b.com/fee-schedule/"},api:{public:{get:{markets:1,market:1,tickers:1,ticker:1,book:1,history:1,"depth/result":1,"market/kline":1}},private:{post:{"account/balances":1,"account/balance":1,"order/new":1,"order/cancel":1,orders:1,"account/market_order_history":1,"account/market_deal_history":1,"account/order":1,"account/order_history":1,"account/executed_history":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:[[this.parseNumber("0"),this.parseNumber("0.2")],[this.parseNumber("1"),this.parseNumber("0.19")],[this.parseNumber("5"),this.parseNumber("0.18")],[this.parseNumber("10"),this.parseNumber("0.17")],[this.parseNumber("25"),this.parseNumber("0.16")],[this.parseNumber("75"),this.parseNumber("0.15")],[this.parseNumber("100"),this.parseNumber("0.14")],[this.parseNumber("150"),this.parseNumber("0.13")],[this.parseNumber("300"),this.parseNumber("0.12")],[this.parseNumber("450"),this.parseNumber("0.11")],[this.parseNumber("500"),this.parseNumber("0.1")]],maker:[[this.parseNumber("0"),this.parseNumber("0.2")],[this.parseNumber("1"),this.parseNumber("0.18")],[this.parseNumber("5"),this.parseNumber("0.16")],[this.parseNumber("10"),this.parseNumber("0.14")],[this.parseNumber("25"),this.parseNumber("0.12")],[this.parseNumber("75"),this.parseNumber("0.1")],[this.parseNumber("100"),this.parseNumber("0.08")],[this.parseNumber("150"),this.parseNumber("0.06")],[this.parseNumber("300"),this.parseNumber("0.04")],[this.parseNumber("450"),this.parseNumber("0.02")],[this.parseNumber("500"),this.parseNumber("0.01")]]}},commonCurrencies:{},precisionMode:a.kb,exceptions:{1001:r.AuthenticationError,1002:r.AuthenticationError,1003:r.AuthenticationError,1004:r.AuthenticationError,1005:r.AuthenticationError,1006:r.AuthenticationError,1007:r.AuthenticationError,1008:r.AuthenticationError,1009:r.AuthenticationError,1010:r.AuthenticationError,1011:r.AuthenticationError,1012:r.AuthenticationError,1013:r.AuthenticationError,1014:r.AuthenticationError,1015:r.AuthenticationError,1016:r.AuthenticationError,2010:r.BadRequest,2020:r.BadRequest,2021:r.BadRequest,2030:r.BadRequest,2040:r.InsufficientFunds,2050:r.BadRequest,2051:r.BadRequest,2052:r.BadRequest,2060:r.BadRequest,2061:r.BadRequest,2062:r.BadRequest,2070:r.BadRequest,3001:r.BadRequest,3020:r.BadRequest,3030:r.BadRequest,3040:r.BadRequest,3050:r.BadRequest,3060:r.BadRequest,3070:r.BadRequest,3080:r.BadRequest,3090:r.BadRequest,3100:r.BadRequest,3110:r.BadRequest,4001:r.ExchangeNotAvailable,6010:r.InsufficientFunds},options:{}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeValue(t,"result",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeString(e,"stock"),i=this.safeString(e,"money"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeValue(e,"limits"),n=this.safeString(o,"max_amount"),d=this.safeString(o,"max_price");return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(o,"step_size"),price:this.safeNumber(o,"tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.parseNumber(this.omitZero(n))},price:{min:this.safeNumber(o,"min_price"),max:this.parseNumber(this.omitZero(d))},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeValue(s,"result",{});return this.parseTickers(i,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.publicGetTicker(this.extend(i,t)),a=this.safeValue(r,"result",{}),o=this.safeIntegerProduct(r,"cache_time",1e3);return this.extend({timestamp:o,datetime:this.iso8601(o)},this.parseTicker(a,s))}parseTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"at",1e3);"ticker"in e&&(e=this.safeValue(e,"ticker"));const i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:i,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString2(e,"vol","volume"),quoteVolume:this.safeString(e,"deal"),info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={market:i.id};void 0!==t&&(r.limit=t);const a=await this.publicGetDepthResult(this.extend(r,s)),o=this.safeValue(a,"result",{}),n=this.safeIntegerProduct(a,"current_time",1e3);return this.parseOrderBook(o,i.symbol,n,"bids","asks",0,1)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const a=this.safeInteger(i,"lastId");if(void 0===a)throw new r.ArgumentsRequired(this.id+' fetchTrades () requires an extra parameter params["lastId"]');const o=this.market(e),n={market:o.id,lastId:a};void 0!==s&&(n.limit=s);const d=await this.publicGetHistory(this.extend(n,i)),h=this.safeList(d,"result",[]);return this.parseTrades(h,o,t,s)}parseTrade(e,t=void 0){const s=this.safeIntegerProduct2(e,"time","deal_time",1e3);let i=this.safeString(e,"role");return"1"===i?i="maker":"2"===i&&(i="taker"),this.safeTrade({info:e,id:this.safeString2(e,"id","deal_id"),timestamp:s,datetime:this.iso8601(s),symbol:this.safeString(t,"symbol"),order:this.safeString2(e,"dealOrderId","deal_order_id"),type:void 0,side:this.safeString2(e,"type","side"),takerOrMaker:i,price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:this.safeString(e,"deal"),fee:{currency:t.quote,cost:this.safeString2(e,"fee","deal_fee")}},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,interval:t};void 0!==i&&(o.limit=i);const n=await this.publicGetMarketKline(this.extend(o,r)),d=this.safeList(n,"result",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeIntegerProduct(e,0,1e3),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostAccountBalances(e),s=this.safeValue(t,"result",{});return this.parseBalance(s)}parseBalance(e){const t={info:e},s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i],a=e[r],o=this.safeCurrencyCode(r),n=this.safeString(a,"freeze"),d={free:this.safeString(a,"available"),used:n};t[o]=d}return this.safeBalance(t)}async createOrder(e,t,s,i,a=void 0,o={}){if(await this.loadMarkets(),"market"===t)throw new r.BadRequest(this.id+' createOrder () can only accept orders with type "limit"');const n=this.market(e),d={market:n.id,side:s,amount:this.amountToPrecision(e,i),price:this.priceToPrecision(e,a)},h=await this.privatePostOrderNew(this.extend(d,o)),c=this.safeDict(h,"result");return this.parseOrder(c,n)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={market:this.market(t).id,orderId:e},a=await this.privatePostOrderCancel(this.extend(i,s)),o=this.safeDict(a,"result");return this.parseOrder(o)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders () requires the symbol argument");await this.loadMarkets();const a=this.market(e),o={market:a.id};void 0!==s&&(o.limit=s);const n=await this.privatePostOrders(this.extend(o,i)),d=this.safeList(n,"result",[]);return this.parseOrders(d,a,t,s)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.safeMarket(t),o={orderId:e};void 0!==i&&(o.limit=i);const n=await this.privatePostAccountOrder(this.extend(o,r)),d=this.safeValue(n,"result",{}),h=this.safeList(d,"records",[]);return this.parseTrades(h,a,s,i)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();let a=this.safeInteger(i,"until");if(i=this.omit(i,"until"),void 0===a&&(a=void 0===t?this.milliseconds():t+864e5),void 0===t&&(t=a-864e5),a-t>864e5)throw new r.BadRequest(this.id+' fetchMyTrades () the time between since and params["until"] cannot be greater than 24 hours');const o=this.market(e),n={market:o.id,startTime:this.parseToInt(t/1e3),endTime:this.parseToInt(a/1e3)};void 0!==s&&(n.limit=s);const d=await this.privatePostAccountMarketDealHistory(this.extend(n,i)),h=this.safeValue(d,"result",{}),c=this.safeList(h,"deals",[]);return this.parseTrades(c,o,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let a,o=this.safeInteger(i,"until");if(i=this.omit(i,"until"),void 0!==e&&(a=this.market(e)),void 0===o&&(o=void 0===t?this.milliseconds():t+864e5),void 0===t&&(t=o-864e5),o-t>864e5)throw new r.BadRequest(this.id+' fetchClosedOrders () the time between since and params["until"] cannot be greater than 24 hours');const n={startTime:this.parseToInt(t/1e3),endTime:this.parseToInt(o/1e3)};void 0!==a&&(n.market=a.id),void 0!==s&&(n.limit=s);const d=await this.privatePostAccountOrderHistory(this.extend(n,i)),h=this.safeValue(d,"result");let c=[];const l=Object.keys(h);for(let e=0;e<l.length;e++){const i=h[l[e]],r=this.parseOrders(i,a,t,s);c=this.arrayConcat(c,r)}return c}parseOrder(e,t=void 0){const s=this.safeIntegerProduct2(e,"timestamp","ctime",1e3),i=this.safeString(e,"market");return t=this.safeMarket(i,t),this.safeOrder({info:e,id:this.safeString2(e,"id","orderId"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:this.safeString(e,"price"),stopPrice:void 0,amount:this.safeString(e,"amount"),cost:void 0,average:void 0,filled:this.safeString(e,"dealStock"),remaining:this.safeString(e,"left"),status:void 0,fee:{currency:t.quote,cost:this.safeString(e,"dealFee")},trades:void 0},t)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let n=this.urls.api[t]+"/"+this.implodeParams(e,i);if(i=this.omit(i,this.extractParams(e)),"GET"===s&&Object.keys(i).length&&(n+="?"+this.urlencode(i)),"private"===t){i.request="/api/v2/"+e,i.nonce=this.nonce().toString();const t=this.stringToBase64(this.json(i));r={"Content-Type":"application/json","X-TXC-APIKEY":this.apiKey,"X-TXC-PAYLOAD":t,"X-TXC-SIGNATURE":this.hmac(this.encode(t),this.encode(this.secret),o.Zf)},a=this.json(i)}return{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(void 0!==o&&400===e){const e=this.safeValue(o,"error"),t=this.safeString(e,"code"),s=this.id+" "+this.json(o);this.throwExactlyMatchedException(this.exceptions,t,s)}}}},6993:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(5147),r=s(2134),a=s(2079),o=s(1579),n=s(8283),d=s(8432),h=s(987);class c extends r.A{describe(){return this.deepExtend(super.describe(),{id:"paradex",name:"Paradex",countries:[],version:"v1",rateLimit:50,certified:!1,pro:!0,dex:!0,has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,borrowCrossMargin:!1,borrowIsolatedMargin:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!1,cancelOrder:!1,cancelOrders:!1,cancelOrdersForSymbols:!1,closeAllPositions:!1,closePosition:!1,createMarketBuyOrderWithCost:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!1,createReduceOnlyOrder:!1,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDeposits:!0,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchLiquidations:!0,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},timeframes:{"1m":1,"3m":3,"5m":5,"15m":15,"30m":30,"1h":60},hostname:"paradex.trade",urls:{logo:"https://github.com/user-attachments/assets/84628770-784e-4ec4-a759-ec2fbb2244ea",api:{v1:"https://api.prod.{hostname}/v1"},test:{v1:"https://api.testnet.{hostname}/v1"},www:"https://www.paradex.trade/",doc:"https://docs.api.testnet.paradex.trade/",fees:"https://docs.paradex.trade/getting-started/trading-fees",referral:"https://app.paradex.trade/r/ccxt24"},api:{public:{get:{"bbo/{market}":1,"funding/data":1,markets:1,"markets/klines":1,"markets/summary":1,"orderbook/{market}":1,insurance:1,"referrals/config":1,"system/config":1,"system/state":1,"system/time":1,trades:1}},private:{get:{account:1,"account/profile":1,balance:1,fills:1,"funding/payments":1,positions:1,tradebusts:1,transactions:1,liquidations:1,orders:1,"orders-history":1,"orders/by_client_id/{client_id}":1,"orders/{order_id}":1,"points_data/{market}/{program}":1,"referrals/summary":1,transfers:1},post:{"account/profile/referral_code":1,"account/profile/username":1,auth:1,onboarding:1,orders:1},delete:{orders:1,"orders/by_client_id/{client_id}":1,"orders/{order_id}":1}}},fees:{swap:{taker:this.parseNumber("0.0002"),maker:this.parseNumber("0.0002")},spot:{taker:this.parseNumber("0.0002"),maker:this.parseNumber("0.0002")}},requiredCredentials:{apiKey:!1,secret:!1,walletAddress:!0,privateKey:!0},exceptions:{exact:{VALIDATION_ERROR:a.AuthenticationError,BINDING_ERROR:a.OperationRejected,INTERNAL_ERROR:a.ExchangeError,NOT_FOUND:a.BadRequest,SERVICE_UNAVAILABLE:a.ExchangeError,INVALID_REQUEST_PARAMETER:a.BadRequest,ORDER_ID_NOT_FOUND:a.InvalidOrder,ORDER_IS_CLOSED:a.InvalidOrder,ORDER_IS_NOT_OPEN_YET:a.InvalidOrder,CLIENT_ORDER_ID_NOT_FOUND:a.InvalidOrder,DUPLICATED_CLIENT_ID:a.InvalidOrder,INVALID_PRICE_PRECISION:a.OperationRejected,INVALID_SYMBOL:a.OperationRejected,INVALID_TOKEN:a.OperationRejected,INVALID_ETHEREUM_ADDRESS:a.OperationRejected,INVALID_ETHEREUM_SIGNATURE:a.OperationRejected,INVALID_STARKNET_ADDRESS:a.OperationRejected,INVALID_STARKNET_SIGNATURE:a.OperationRejected,STARKNET_SIGNATURE_VERIFICATION_FAILED:a.AuthenticationError,BAD_STARKNET_REQUEST:a.BadRequest,ETHEREUM_SIGNER_MISMATCH:a.BadRequest,ETHEREUM_HASH_MISMATCH:a.BadRequest,NOT_ONBOARDED:a.BadRequest,INVALID_TIMESTAMP:a.BadRequest,INVALID_SIGNATURE_EXPIRATION:a.AuthenticationError,ACCOUNT_NOT_FOUND:a.AuthenticationError,INVALID_ORDER_SIGNATURE:a.AuthenticationError,PUBLIC_KEY_INVALID:a.BadRequest,UNAUTHORIZED_ETHEREUM_ADDRESS:a.BadRequest,ETHEREUM_ADDRESS_ALREADY_ONBOARDED:a.BadRequest,MARKET_NOT_FOUND:a.BadRequest,ALLOWLIST_ENTRY_NOT_FOUND:a.BadRequest,USERNAME_IN_USE:a.AuthenticationError,GEO_IP_BLOCK:a.PermissionDenied,ETHEREUM_ADDRESS_BLOCKED:a.PermissionDenied,PROGRAM_NOT_FOUND:a.BadRequest,INVALID_DASHBOARD:a.OperationRejected,MARKET_NOT_OPEN:a.BadRequest,INVALID_REFERRAL_CODE:a.OperationRejected,PARENT_ADDRESS_ALREADY_ONBOARDED:a.BadRequest,INVALID_PARENT_ACCOUNT:a.OperationRejected,INVALID_VAULT_OPERATOR_CHAIN:a.OperationRejected,VAULT_OPERATOR_ALREADY_ONBOARDED:a.OperationRejected,VAULT_NAME_IN_USE:a.OperationRejected,BATCH_SIZE_OUT_OF_RANGE:a.OperationRejected,ISOLATED_MARKET_ACCOUNT_MISMATCH:a.OperationRejected,POINTS_SUMMARY_NOT_FOUND:a.OperationRejected,"-32700":a.BadRequest,"-32600":a.BadRequest,"-32601":a.BadRequest,"-32602":a.BadRequest,"-32603":a.ExchangeError,100:a.BadRequest,40110:a.AuthenticationError,40111:a.AuthenticationError,40112:a.PermissionDenied},broad:{}},precisionMode:o.kb,commonCurrencies:{},options:{broker:"CCXT"}})}async fetchTime(e={}){const t=await this.publicGetSystemTime(e);return this.safeInteger(t,"server_time")}async fetchStatus(e={}){const t=await this.publicGetSystemState(e);return{status:"ok"===this.safeString(t,"status")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=this.safeList(t,"results");return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"quote_currency"),i=this.safeString(e,"base_currency"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeString(e,"settlement_currency"),n=this.safeCurrencyCode(o),d=a+"/"+r+":"+n,h=this.safeInteger(e,"expiry_at"),c=this.parseNumber("0.0003"),l=this.parseNumber("-0.00005");return this.safeMarketStructure({id:t,symbol:d,base:a,quote:r,settle:n,baseId:i,quoteId:s,settleId:o,type:"swap",spot:!1,margin:void 0,swap:!0,future:!1,option:!1,active:this.safeBool(e,"enableTrading"),contract:!0,linear:!0,inverse:void 0,taker:c,maker:l,contractSize:this.parseNumber("1"),expiry:0===h?void 0:h,expiryDatetime:0===h?void 0:this.iso8601(h),strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"order_size_increment"),price:this.safeNumber(e,"price_tick_size")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:this.safeNumber(e,"max_order_size")},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"min_notional"),max:void 0}},created:void 0,info:e})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={resolution:this.safeString(this.timeframes,t,t),symbol:a.id},n=this.milliseconds(),d=this.parseTimeframe(t),h=this.safeInteger2(r,"until","till",n);r=this.omit(r,["until","till"]),void 0!==s?(o.start_at=s,o.end_at=void 0!==i?this.sum(s,d*(i+1)*1e3)-1:h):(o.end_at=h,o.start_at=void 0!==i?h-d*(i+1)*1e3+1:h-101*d*1e3+1);const c=await this.publicGetMarketsKlines(this.extend(o,r)),l=this.safeList(c,"results",[]);return this.parseOHLCVs(l,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};void 0!==(e=this.marketSymbols(e))?Array.isArray(e)?s.market=this.marketId(e[0]):s.market=this.marketId(e):s.market="ALL";const i=await this.publicGetMarketsSummary(this.extend(s,t)),r=this.safeList(i,"results",[]);return this.parseTickers(r,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.publicGetMarketsSummary(this.extend(i,t)),a=this.safeList(r,"results",[]),o=this.safeDict(a,0,{});return this.parseTicker(o,s)}parseTicker(e,t=void 0){let s=this.safeString(e,"price_change_rate_24h");void 0!==s&&(s=i.Y.stringMul(s,"100"));const r=this.safeString(e,"last_traded_price"),a=this.safeString(e,"symbol"),o=(t=this.safeMarket(a,t)).symbol,n=this.safeInteger(e,"created_at");return this.safeTicker({symbol:o,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"sdk"),askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:s,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume_24h"),info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={market:i.id},a=await this.publicGetOrderbookMarket(this.extend(r,s));void 0!==t&&(r.depth=t);const o=this.safeInteger(a,"last_updated_at"),n=this.parseOrderBook(a,i.symbol,o);return n.nonce=this.safeInteger(a,"seq_no"),n}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchTrades",e,t,s,i,"next","cursor",void 0,100);const a=this.market(e);let o={market:a.id};void 0!==s&&(o.page_size=s),void 0!==t&&(o.start_at=t),[o,i]=this.handleUntilOption("end_at",o,i);const n=await this.publicGetTrades(this.extend(o,i)),d=this.safeList(n,"results",[]);for(let e=0;e<d.length;e++)d[e].next=this.safeString(n,"next");return this.parseTrades(d,a,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"market");t=this.safeMarket(s,t);const i=this.safeString(e,"id"),r=this.safeInteger(e,"created_at"),a=this.safeString(e,"price"),o=this.safeString(e,"size"),n=this.safeStringLower(e,"side"),d="taker"===this.safeStringLower(e,"liquidity","taker")?"taker":"maker",h=this.safeString(e,"fee_currency"),c=this.safeCurrencyCode(h);return this.safeTrade({info:e,id:i,order:this.safeString(e,"order_id"),timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:void 0,takerOrMaker:d,side:n,price:a,amount:o,cost:void 0,fee:{cost:this.safeString(e,"fee"),currency:c,rate:void 0}},t)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new a.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i={market:s.id},r=await this.publicGetMarketsSummary(this.extend(i,t)),o=this.safeList(r,"results",[]),n=this.safeDict(o,0,{});return this.parseOpenInterest(n,s)}parseOpenInterest(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.safeString(e,"symbol"),r=(t=this.safeMarket(i,t)).symbol;return this.safeOpenInterest({symbol:r,openInterestAmount:this.safeString(e,"open_interest"),openInterestValue:void 0,timestamp:s,datetime:this.iso8601(s),info:e},t)}hashMessage(e){return"0x"+this.hash(e,d.lY,"hex")}signHash(e,t){const s=(0,n.h1)(e.slice(-64),t.slice(-64),h.bI,void 0),i=s.r,r=s.s,a=this.intToBase16(this.sum(27,s.v));return"0x"+i.padStart(64,"0")+r.padStart(64,"0")+a}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}async getSystemConfig(){const e=this.safeDict(this.options,"systemConfig");if(void 0!==e)return e;const t=await this.publicGetSystemConfig();return this.options.systemConfig=t,t}async prepareParadexDomain(e=!1){const t=await this.getSystemConfig();return!0===e?{name:"Paradex",chainId:t.l1_chain_id,version:"1"}:{name:"Paradex",chainId:t.starknet_chain_id,version:1}}async retrieveAccount(){this.checkRequiredCredentials();const e=this.safeDict(this.options,"paradexAccount");if(void 0!==e)return e;const t=await this.getSystemConfig(),s=await this.prepareParadexDomain(!0),i=this.ethEncodeStructuredData(s,{Constant:[{name:"action",type:"string"}]},{action:"STARK Key"}),r=this.signMessage(i,this.privateKey),a=this.retrieveStarkAccount(r,t.paraclear_account_hash,t.paraclear_account_proxy_hash);return this.options.paradexAccount=a,a}async onboarding(e={}){const t=await this.retrieveAccount(),s=await this.prepareParadexDomain(),i=this.starknetEncodeStructuredData(s,{Constant:[{name:"action",type:"felt"}]},{action:"Onboarding"},t.address),r=this.starknetSign(i,t.privateKey);e.signature=r,e.account=t.address,e.public_key=t.publicKey;return await this.privatePostOnboarding(e)}async authenticateRest(e={}){const t=this.safeString(this.options,"authToken");if(void 0!==t)return t;const s=await this.retrieveAccount(),i=this.nonce(),r={method:"POST",path:"/v1/auth",body:"",timestamp:i,expiration:i+604800},a=await this.prepareParadexDomain(),o=this.starknetEncodeStructuredData(a,{Request:[{name:"method",type:"felt"},{name:"path",type:"felt"},{name:"body",type:"felt"},{name:"timestamp",type:"felt"},{name:"expiration",type:"felt"}]},r,s.address),n=this.starknetSign(o,s.privateKey);e.signature=n,e.account=s.address,e.timestamp=r.timestamp,e.expiration=r.expiration;const d=await this.privatePostAuth(e),h=this.safeString(d,"jwt_token");return this.options.authToken=h,h}parseOrder(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.safeString(e,"id"),r=this.omitZero(this.safeString(e,"client_id")),a=this.safeString(e,"market"),o=(t=this.safeMarket(a,t)).symbol,n=this.safeString(e,"price"),d=this.safeString(e,"size"),h=this.safeString(e,"type"),c=this.safeString(e,"status"),l=this.safeStringLower(e,"side"),u=this.omitZero(this.safeString(e,"avg_fill_price")),p=this.omitZero(this.safeString(e,"remaining_size")),f=this.safeString(e,"trigger_price"),m=this.safeInteger(e,"last_updated_at");return this.safeOrder({id:i,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,lastUpdateTimestamp:m,status:this.parseOrderStatus(c),symbol:o,type:this.parseOrderType(h),timeInForce:this.parseTimeInForce(this.safeString(e,"instrunction")),postOnly:void 0,reduceOnly:void 0,side:l,price:n,stopPrice:f,triggerPrice:f,takeProfitPrice:void 0,stopLossPrice:void 0,average:u,amount:d,filled:void 0,remaining:p,cost:void 0,trades:void 0,fee:{cost:void 0,currency:void 0},info:e},t)}parseTimeInForce(e){return this.safeString({IOC:"IOC",GTC:"GTC",POST_ONLY:"PO"},e,void 0)}parseOrderStatus(e){if(void 0!==e){const t={NEW:"open",UNTRIGGERED:"open",OPEN:"open",CLOSED:"closed"};return this.safeString(t,e,e)}return e}parseOrderType(e){return this.safeStringLower({LIMIT:"limit",MARKET:"market",STOP_LIMIT:"limit",STOP_MARKET:"market"},e,e)}convertShortString(e){return"0x"+this.binaryToBase16(this.base64ToBinary(this.stringToBase64(e)))}scaleNumber(e){return i.Y.stringMul(e,"100000000")}async createOrder(e,t,s,i,r=void 0,a={}){await this.authenticateRest(),await this.loadMarkets();const o=this.market(e),n=this.safeBool2(a,"reduceOnly","reduce_only"),d=t.toUpperCase(),h=s.toUpperCase(),c={market:o.id,side:h,type:d,size:this.amountToPrecision(e,i)},l=this.safeString2(a,"triggerPrice","stopPrice"),u="MARKET"===d,p=this.safeStringUpper(a,"timeInForce"),f=this.isPostOnly(u,void 0,a);u||(f?c.instruction="POST_ONLY":"ioc"===p&&(c.instruction="IOC")),n&&(c.flags=["REDUCE_ONLY"]),void 0!==r&&(c.price=this.priceToPrecision(e,r));const m=this.safeStringN(a,["clOrdID","clientOrderId","client_order_id"]);void 0!==m&&(c.client_id=m),void 0!==l&&(c.type=u?"STOP_MARKET":"STOP_LIMIT",c.trigger_price=this.priceToPrecision(e,l)),a=this.omit(a,["reduceOnly","reduce_only","clOrdID","clientOrderId","client_order_id","postOnly","timeInForce","stopPrice","triggerPrice"]);const g=await this.retrieveAccount(),v={timestamp:1e3*this.nonce(),market:this.convertShortString(c.market),side:"BUY"===h?"1":"2",orderType:this.convertShortString(c.type),size:this.scaleNumber(c.size),price:u?"0":this.scaleNumber(c.price)},y=await this.prepareParadexDomain(),w=this.starknetEncodeStructuredData(y,{Order:[{name:"timestamp",type:"felt"},{name:"market",type:"felt"},{name:"side",type:"felt"},{name:"orderType",type:"felt"},{name:"size",type:"felt"},{name:"price",type:"felt"}]},v,g.address),b=this.starknetSign(w,g.privateKey);c.signature=b,c.signature_timestamp=v.timestamp;const S=await this.privatePostOrders(this.extend(c,a));return this.parseOrder(S,o)}async cancelOrder(e,t=void 0,s={}){await this.authenticateRest(),await this.loadMarkets();const i={},r=this.safeStringN(s,["clOrdID","clientOrderId","client_order_id"]);let a;return void 0!==r?(i.client_id=r,a=await this.privateDeleteOrdersByClientIdClientId(this.extend(i,s))):(i.order_id=e,a=await this.privateDeleteOrdersOrderId(this.extend(i,s))),this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.authenticateRest(),await this.loadMarkets();const s={market:this.market(e).id};return await this.privateDeleteOrders(this.extend(s,t))}async fetchOrder(e,t=void 0,s={}){await this.authenticateRest(),await this.loadMarkets();const i={},r=this.safeStringN(s,["clOrdID","clientOrderId","client_order_id"]);let a;return s=this.omit(s,["clOrdID","clientOrderId","client_order_id"]),void 0!==r?(i.client_id=r,a=await this.privateGetOrdersByClientIdClientId(this.extend(i,s))):(i.order_id=e,a=await this.privateGetOrdersOrderId(this.extend(i,s))),this.parseOrder(a)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.authenticateRest(),await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),r)return await this.fetchPaginatedCallCursor("fetchOrders",e,t,s,i,"next","cursor",void 0,50);let a,o={};void 0!==e&&(a=this.market(e),o.market=a.id),void 0!==t&&(o.start_at=t),void 0!==s&&(o.page_size=s),[o,i]=this.handleUntilOption("end_at",o,i);const n=await this.privateGetOrdersHistory(this.extend(o,i)),d=this.safeList(n,"results",[]),h=this.safeString(n,"next"),c=d.length;if(void 0!==h&&c>0){const e=d[0];e.next=h,d[0]=e}return this.parseOrders(d,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.authenticateRest(),await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.privateGetOrders(this.extend(r,i)),n=this.safeList(o,"results",[]);return this.parseOrders(n,a,t,s)}async fetchBalance(e={}){await this.authenticateRest(),await this.loadMarkets();const t=await this.privateGetBalance(),s=this.safeList(t,"results",[]);return this.parseBalance(s)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=this.safeDict(e,s,{}),r=this.safeString(i,"token"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"size"),t[a]=o}return this.safeBalance(t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.authenticateRest(),await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallCursor("fetchMyTrades",e,t,s,i,"next","cursor",void 0,100);let a,o={};void 0!==e&&(a=this.market(e),o.market=a.id),void 0!==s&&(o.page_size=s),void 0!==t&&(o.start_at=t),[o,i]=this.handleUntilOption("end_at",o,i);const n=await this.privateGetFills(this.extend(o,i)),d=this.safeList(n,"results",[]);for(let e=0;e<d.length;e++)d[e].next=this.safeString(n,"next");return this.parseTrades(d,a,t,s)}async fetchPosition(e,t={}){await this.authenticateRest(),await this.loadMarkets();const s=this.market(e),i=await this.fetchPositions([s.symbol],t);return this.safeDict(i,0,{})}async fetchPositions(e=void 0,t={}){await this.authenticateRest(),await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.privateGetPositions(),i=this.safeList(s,"results",[]);return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"market"),r=(t=this.safeMarket(s,t)).symbol,a=this.safeStringLower(e,"side");let o=this.safeString(e,"size");"long"!==a&&(o=i.Y.stringMul("-1",o));const n=this.safeInteger(e,"time");return this.safePosition({info:e,id:this.safeString(e,"id"),symbol:r,entryPrice:this.safeString(e,"average_entry_price"),markPrice:void 0,notional:void 0,collateral:this.safeString(e,"cost"),unrealizedPnl:this.safeString(e,"unrealized_pnl"),side:a,contracts:this.parseNumber(o),contractSize:void 0,timestamp:n,datetime:this.iso8601(n),hedged:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,liquidationPrice:void 0,marginRatio:void 0,marginMode:void 0,percentage:void 0})}async fetchLiquidations(e,t=void 0,s=void 0,i={}){await this.authenticateRest();let r={};r.from=void 0!==t?t:1;const a=this.market(e);[r,i]=this.handleUntilOption("to",r,i);const o=await this.privateGetLiquidations(this.extend(r,i)),n=this.safeList(o,"results",[]);return this.parseLiquidations(n,a,t,s)}parseLiquidation(e,t=void 0){const s=this.safeInteger(e,"created_at");return this.safeLiquidation({info:e,symbol:void 0,contracts:void 0,contractSize:void 0,price:void 0,baseValue:void 0,quoteValue:void 0,timestamp:s,datetime:this.iso8601(s)})}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.authenticateRest(),await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchDeposits","paginate"),r)return await this.fetchPaginatedCallCursor("fetchDeposits",e,t,s,i,"next","cursor",void 0,100);let a={};void 0!==s&&(a.page_size=s),void 0!==t&&(a.start_at=t),[a,i]=this.handleUntilOption("end_at",a,i);const o=await this.privateGetTransfers(this.extend(a,i)),n=this.safeList(o,"results",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e];"DEPOSIT"===t.kind&&d.push(t)}return this.parseTransactions(d,void 0,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.authenticateRest(),await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchWithdrawals","paginate"),r)return await this.fetchPaginatedCallCursor("fetchWithdrawals",e,t,s,i,"next","cursor",void 0,100);let a={};void 0!==s&&(a.page_size=s),void 0!==t&&(a.start_at=t),[a,i]=this.handleUntilOption("end_at",a,i);const o=await this.privateGetTransfers(this.extend(a,i)),n=this.safeList(o,"results",[]),d=[];for(let e=0;e<n.length;e++){const t=n[e];"WITHDRAWAL"===t.kind&&d.push(t)}return this.parseTransactions(d,void 0,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"account"),r=this.safeString(e,"txn_hash"),a=this.safeString(e,"token"),o=this.safeCurrencyCode(a,t),n=this.safeInteger(e,"created_at"),d=this.safeInteger(e,"last_updated_at");let h=this.safeString(e,"kind");h="DEPOSIT"===h?"deposit":"withdrawal";const c=this.parseTransactionStatus(this.safeString(e,"status")),l=this.safeNumber(e,"amount");return{info:e,id:s,txid:r,timestamp:n,datetime:this.iso8601(n),network:void 0,address:i,addressTo:i,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:h,amount:l,currency:o,status:c,updated:d,internal:void 0,comment:void 0,fee:void 0}}parseTransactionStatus(e){return this.safeString({PENDING:"pending",AVAILABLE:"pending",COMPLETED:"ok",FAILED:"failed"},e,e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.implodeHostname(this.urls.api[this.version])+"/"+this.implodeParams(e,i);const n=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(n).length&&(o+="?"+this.urlencode(n));else if("private"===t)if(this.checkRequiredCredentials(),r={Accept:"application/json","PARADEX-PARTNER":this.safeString(this.options,"broker","CCXT")},"auth"===e)r["PARADEX-STARKNET-ACCOUNT"]=n.account,r["PARADEX-STARKNET-SIGNATURE"]=n.signature,r["PARADEX-TIMESTAMP"]=n.timestamp.toString(),r["PARADEX-SIGNATURE-EXPIRATION"]=n.expiration.toString();else if("onboarding"===e)r["PARADEX-ETHEREUM-ACCOUNT"]=this.walletAddress,r["PARADEX-STARKNET-ACCOUNT"]=n.account,r["PARADEX-STARKNET-SIGNATURE"]=n.signature,r["PARADEX-TIMESTAMP"]=this.nonce().toString(),r["Content-Type"]="application/json",a=this.json({public_key:n.public_key});else{const e=this.options.authToken;r.Authorization="Bearer "+e,"POST"===s?(r["Content-Type"]="application/json",a=this.json(n)):o=o+"?"+this.urlencode(n)}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,o,n,d,h){if(!n)return;const c=this.safeString(n,"error");if(void 0!==c){const e=this.id+" "+o;throw this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e),new a.ExchangeError(e)}}}},3280:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8563),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"paymium",name:"Paymium",countries:["FR","EU"],rateLimit:2e3,version:"v1",has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createOrder:!0,fetchBalance:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,transfer:!0},urls:{logo:"https://user-images.githubusercontent.com/51840849/87153930-f0f02200-c2c0-11ea-9c0a-40337375ae89.jpg",api:{rest:"https://paymium.com/api"},www:"https://www.paymium.com",fees:"https://www.paymium.com/page/help/fees",doc:["https://github.com/Paymium/api-documentation","https://www.paymium.com/page/developers","https://paymium.github.io/api-documentation/"],referral:"https://www.paymium.com/page/sign-up?referral=eDAzPoRQFMvaAB8sf-qj"},api:{public:{get:["countries","currencies","data/{currency}/ticker","data/{currency}/trades","data/{currency}/depth","bitcoin_charts/{id}/trades","bitcoin_charts/{id}/depth"]},private:{get:["user","user/addresses","user/addresses/{address}","user/orders","user/orders/{uuid}","user/price_alerts","merchant/get_payment/{uuid}"],post:["user/addresses","user/orders","user/withdrawals","user/email_transfers","user/payment_requests","user/price_alerts","merchant/create_payment"],delete:["user/orders/{uuid}","user/orders/{uuid}/cancel","user/price_alerts/{id}"]}},markets:{"BTC/EUR":this.safeMarketStructure({id:"eur",symbol:"BTC/EUR",base:"BTC",quote:"EUR",baseId:"btc",quoteId:"eur",type:"spot",spot:!0})},fees:{trading:{maker:this.parseNumber("-0.001"),taker:this.parseNumber("0.005")}},precisionMode:o.kb})}parseBalance(e){const t={info:e},s=Object.keys(this.currencies);for(let i=0;i<s.length;i++){const r=s[i],a=this.currency(r).id,o="balance_"+a;if(o in e){const s=this.account(),i="locked_"+a;s.free=this.safeString(e,o),s.used=this.safeString(e,i),t[r]=s}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetUser(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={currency:i.id},a=await this.publicGetDataCurrencyDepth(this.extend(r,s));return this.parseOrderBook(a,i.symbol,void 0,"bids","asks","price","amount")}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeTimestamp(e,"at"),r=this.safeString(e,"vwap"),o=this.safeString(e,"volume"),n=a.Y.stringMul(o,r),d=this.safeString(e,"price");return this.safeTicker({symbol:s,timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:r,open:this.safeString(e,"open"),close:d,last:d,previousClose:void 0,change:void 0,percentage:this.safeString(e,"variation"),average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={currency:s.id},r=await this.publicGetDataCurrencyTicker(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"created_at_int"),i=this.safeString(e,"uuid");t=this.safeMarket(void 0,t);const r=this.safeString(e,"side"),a=this.safeString(e,"price"),o="traded_"+t.base.toLowerCase(),n=this.safeString(e,o);return this.safeTrade({info:e,id:i,order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,type:void 0,side:r,takerOrMaker:void 0,price:a,amount:n,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={currency:r.id},o=await this.publicGetDataCurrencyTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async createDepositAddress(e,t={}){await this.loadMarkets();const s=await this.privatePostUserAddresses(t);return this.parseDepositAddress(s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={address:e},i=await this.privateGetUserAddressesAddress(this.extend(s,t));return this.parseDepositAddress(i)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetUserAddresses(t);return this.parseDepositAddresses(s,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"currency");return{info:e,currency:this.safeCurrencyCode(i,t),address:s,tag:void 0,network:void 0}}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={type:this.capitalize(t)+"Order",currency:o.id,direction:s,amount:i};"market"!==t&&(n.price=r);const d=await this.privatePostUserOrders(this.extend(n,a));return this.safeOrder({info:d,id:d.uuid},o)}async cancelOrder(e,t=void 0,s={}){const i={uuid:e},r=await this.privateDeleteUserOrdersUuidCancel(this.extend(i,s));return this.safeOrder({info:r})}async transfer(e,t,s,i,a={}){await this.loadMarkets();const o=this.currency(e);if(i.indexOf("@")<0)throw new r.ExchangeError(this.id+" transfer() only allows transfers to an email address");if("BTC"!==e&&"EUR"!==e)throw new r.ExchangeError(this.id+" transfer() only allows BTC or EUR");const n={currency:o.id,amount:this.currencyToPrecision(e,t),email:i},d=await this.privatePostUserEmailTransfers(this.extend(n,a));return this.parseTransfer(d,o)}parseTransfer(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"updated_at"),r=this.parseDate(i),a=this.safeValue(e,"account_operations"),o=this.safeValue(a,0,{}),n=this.safeString(e,"state");return{info:e,id:this.safeString(e,"uuid"),timestamp:r,datetime:this.iso8601(r),currency:this.safeCurrencyCode(s,t),amount:this.safeNumber(e,"amount"),fromAccount:void 0,toAccount:this.safeString(o,"address"),status:this.parseTransferStatus(n)}}parseTransferStatus(e){return this.safeString({executed:"ok"},e,e)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+this.version+"/"+this.implodeParams(e,i);const d=this.omit(i,this.extractParams(e));if("public"===t)Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t=e+o;if(r={"Api-Key":this.apiKey,"Api-Nonce":e},"POST"===s)Object.keys(d).length&&(t+=a=this.json(d),r["Content-Type"]="application/json");else if(Object.keys(d).length){const e=this.urlencode(d);t+=e,o+="?"+e}r["Api-Signature"]=this.hmac(this.encode(t),this.encode(this.secret),n.s)}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(void 0!==this.safeValue(n,"errors"))throw new r.ExchangeError(this.id+" "+this.json(n))}}},9075:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(4158),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"phemex",name:"Phemex",countries:["CN"],rateLimit:120.5,version:"v1",certified:!1,pro:!0,hostname:"api.phemex.com",has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistories:!1,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!0,setMargin:!0,setMarginMode:!0,setPositionMode:!0,transfer:!0,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/85225056-221eb600-b3d7-11ea-930d-564d2690e3f6.jpg",test:{v1:"https://testnet-api.phemex.com/v1",v2:"https://testnet-api.phemex.com",public:"https://testnet-api.phemex.com/exchange/public",private:"https://testnet-api.phemex.com"},api:{v1:"https://{hostname}/v1",v2:"https://{hostname}",public:"https://{hostname}/exchange/public",private:"https://{hostname}"},www:"https://phemex.com",doc:"https://github.com/phemex/phemex-api-docs",fees:"https://phemex.com/fees-conditions",referral:{url:"https://phemex.com/register?referralCode=EDNVJ",discount:.1}},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","3h":"10800","4h":"14400","6h":"21600","12h":"43200","1d":"86400","1w":"604800","1M":"2592000","3M":"7776000","1Y":"31104000"},api:{public:{get:{"cfg/v2/products":5,"cfg/fundingRates":5,products:5,"nomics/trades":5,"md/kline":5,"md/v2/kline/list":5,"md/v2/kline":5,"md/v2/kline/last":5,"md/orderbook":5,"md/trade":5,"md/spot/ticker/24hr":5,"exchange/public/cfg/chain-settings":5}},v1:{get:{"md/fullbook":5,"md/orderbook":5,"md/trade":5,"md/ticker/24hr":5,"md/ticker/24hr/all":5,"md/spot/ticker/24hr":5,"md/spot/ticker/24hr/all":5,"exchange/public/products":5,"api-data/public/data/funding-rate-history":5}},v2:{get:{"public/products":5,"md/v2/orderbook":5,"md/v2/trade":5,"md/v2/ticker/24hr":5,"md/v2/ticker/24hr/all":5,"api-data/public/data/funding-rate-history":5}},private:{get:{"spot/orders/active":1,"spot/orders":1,"spot/wallets":5,"exchange/spot/order":5,"exchange/spot/order/trades":5,"exchange/order/v2/orderList":5,"exchange/order/v2/tradingList":5,"accounts/accountPositions":1,"g-accounts/accountPositions":1,"accounts/positions":25,"api-data/futures/funding-fees":5,"api-data/g-futures/funding-fees":5,"api-data/futures/orders":5,"api-data/g-futures/orders":5,"api-data/futures/orders/by-order-id":5,"api-data/g-futures/orders/by-order-id":5,"api-data/futures/trades":5,"api-data/g-futures/trades":5,"api-data/futures/trading-fees":5,"api-data/g-futures/trading-fees":5,"api-data/futures/v2/tradeAccountDetail":5,"g-orders/activeList":1,"orders/activeList":1,"exchange/order/list":5,"exchange/order":5,"exchange/order/trade":5,"phemex-user/users/children":5,"phemex-user/wallets/v2/depositAddress":5,"phemex-user/wallets/tradeAccountDetail":5,"phemex-deposit/wallets/api/depositAddress":5,"phemex-deposit/wallets/api/depositHist":5,"phemex-deposit/wallets/api/chainCfg":5,"phemex-withdraw/wallets/api/withdrawHist":5,"phemex-withdraw/wallets/api/asset/info":5,"phemex-user/order/closedPositionList":5,"exchange/margins/transfer":5,"exchange/wallets/confirm/withdraw":5,"exchange/wallets/withdrawList":5,"exchange/wallets/depositList":5,"exchange/wallets/v2/depositAddress":5,"api-data/spots/funds":5,"api-data/spots/orders":5,"api-data/spots/orders/by-order-id":5,"api-data/spots/pnls":5,"api-data/spots/trades":5,"api-data/spots/trades/by-order-id":5,"assets/convert":5,"assets/transfer":5,"assets/spots/sub-accounts/transfer":5,"assets/futures/sub-accounts/transfer":5,"assets/quote":5},post:{"spot/orders":1,orders:1,"g-orders":1,"positions/assign":5,"exchange/wallets/transferOut":5,"exchange/wallets/transferIn":5,"exchange/margins":5,"exchange/wallets/createWithdraw":5,"exchange/wallets/cancelWithdraw":5,"exchange/wallets/createWithdrawAddress":5,"assets/transfer":5,"assets/spots/sub-accounts/transfer":5,"assets/futures/sub-accounts/transfer":5,"assets/universal-transfer":5,"assets/convert":5,"phemex-withdraw/wallets/api/createWithdraw":5,"phemex-withdraw/wallets/api/cancelWithdraw":5},put:{"spot/orders/create":1,"spot/orders":1,"orders/replace":1,"g-orders/replace":1,"positions/leverage":5,"g-positions/leverage":5,"g-positions/switch-pos-mode-sync":5,"positions/riskLimit":5},delete:{"spot/orders":2,"spot/orders/all":2,"orders/cancel":1,orders:1,"orders/all":3,"g-orders/cancel":1,"g-orders":1,"g-orders/all":3}}},precisionMode:o.kb,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},requiredCredentials:{apiKey:!0,secret:!0},exceptions:{exact:{401:r.AuthenticationError,412:r.BadRequest,6001:r.BadRequest,19999:r.BadRequest,10001:r.DuplicateOrderId,10002:r.OrderNotFound,10003:r.CancelPending,10004:r.CancelPending,10005:r.CancelPending,11001:r.InsufficientFunds,11002:r.InvalidOrder,11003:r.InsufficientFunds,11004:r.InvalidOrder,11005:r.InsufficientFunds,11006:r.ExchangeError,11007:r.ExchangeError,11008:r.ExchangeError,11009:r.ExchangeError,11010:r.InsufficientFunds,11011:r.InvalidOrder,11012:r.InvalidOrder,11013:r.InvalidOrder,11014:r.InvalidOrder,11015:r.InvalidOrder,11016:r.BadRequest,11017:r.ExchangeError,11018:r.ExchangeError,11019:r.ExchangeError,11020:r.ExchangeError,11021:r.ExchangeError,11022:r.AccountSuspended,11023:r.ExchangeError,11024:r.ExchangeError,11025:r.BadRequest,11026:r.ExchangeError,11027:r.BadSymbol,11028:r.BadSymbol,11029:r.ExchangeError,11030:r.ExchangeError,11031:r.DDoSProtection,11032:r.DDoSProtection,11033:r.DuplicateOrderId,11034:r.InvalidOrder,11035:r.InvalidOrder,11036:r.InvalidOrder,11037:r.InvalidOrder,11038:r.InvalidOrder,11039:r.InvalidOrder,11040:r.InvalidOrder,11041:r.InvalidOrder,11042:r.InvalidOrder,11043:r.InvalidOrder,11044:r.InvalidOrder,11045:r.InvalidOrder,11046:r.InvalidOrder,11047:r.InvalidOrder,11048:r.InvalidOrder,11049:r.InvalidOrder,11050:r.InvalidOrder,11051:r.InvalidOrder,11052:r.InvalidOrder,11053:r.InvalidOrder,11054:r.InvalidOrder,11055:r.InvalidOrder,11056:r.InvalidOrder,11057:r.InvalidOrder,11058:r.InvalidOrder,11059:r.InvalidOrder,11060:r.InvalidOrder,11061:r.CancelPending,11062:r.InvalidOrder,11063:r.InvalidOrder,11064:r.InvalidOrder,11065:r.InvalidOrder,11066:r.InvalidOrder,11067:r.InvalidOrder,11068:r.InvalidOrder,11069:r.ExchangeError,11070:r.BadSymbol,11071:r.InvalidOrder,11072:r.InvalidOrder,11073:r.InvalidOrder,11074:r.InvalidOrder,11075:r.InvalidOrder,11076:r.InvalidOrder,11077:r.InvalidOrder,11078:r.InvalidOrder,11079:r.InvalidOrder,11080:r.InvalidOrder,11081:r.InvalidOrder,11082:r.InsufficientFunds,11083:r.InvalidOrder,11084:r.InvalidOrder,11085:r.DuplicateOrderId,11086:r.InvalidOrder,11087:r.InvalidOrder,11088:r.InvalidOrder,11089:r.InvalidOrder,11090:r.InvalidOrder,11091:r.InvalidOrder,11092:r.InvalidOrder,11093:r.InvalidOrder,11094:r.InvalidOrder,11095:r.InvalidOrder,11096:r.InvalidOrder,11097:r.BadRequest,11098:r.BadRequest,11099:r.ExchangeError,11100:r.InsufficientFunds,11101:r.InsufficientFunds,11102:r.BadRequest,11103:r.BadRequest,11104:r.BadRequest,11105:r.InsufficientFunds,11106:r.InsufficientFunds,11107:r.ExchangeError,11108:r.InvalidOrder,11109:r.InvalidOrder,11110:r.InvalidOrder,11111:r.InvalidOrder,11112:r.InvalidOrder,11113:r.BadRequest,11114:r.InvalidOrder,11115:r.InvalidOrder,11116:r.InvalidOrder,11117:r.InvalidOrder,11118:r.InvalidOrder,11119:r.InvalidOrder,11120:r.InvalidOrder,11121:r.InvalidOrder,11122:r.InvalidOrder,11123:r.InvalidOrder,11124:r.InvalidOrder,11125:r.InvalidOrder,11126:r.InvalidOrder,11128:r.InvalidOrder,11129:r.InvalidOrder,11130:r.InvalidOrder,11131:r.InvalidOrder,11132:r.InvalidOrder,11133:r.InvalidOrder,11134:r.InvalidOrder,3e4:r.BadRequest,30018:r.BadRequest,34003:r.PermissionDenied,35104:r.InsufficientFunds,39995:r.RateLimitExceeded,39996:r.PermissionDenied,39997:r.BadSymbol},broad:{"401 Insufficient privilege":r.PermissionDenied,"401 Request IP mismatch":r.PermissionDenied,"Failed to find api-key":r.AuthenticationError,"Missing required parameter":r.BadRequest,"API Signature verification failed":r.AuthenticationError,"Api key not found":r.AuthenticationError}},options:{brokerId:"CCXT123456","x-phemex-request-expiry":60,createOrderByQuoteRequiresPrice:!0,networks:{TRC20:"TRX",ERC20:"ETH",BEP20:"BNB"},defaultNetworks:{USDT:"ETH"},defaultSubType:"linear",accountsByType:{spot:"spot",swap:"future"},stableCoins:["BUSD","FEI","TUSD","USD","USDC","USDD","USDP","USDT"],transfer:{fillResponseFromRequest:!0}}})}parseSafeNumber(e=void 0){if(void 0===e)return e;let t=e.split(",");return e=t.join(""),t=e.split(" "),this.safeNumber(t,0)}parseSwapMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString2(e,"baseCurrency","contractUnderlyingAssets"),i=this.safeString(e,"quoteCurrency"),r=this.safeString(e,"settleCurrency"),a=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(r);let d=!1;r!==i&&(d=!0);const h=this.safeInteger(e,"priceScale"),c=this.safeInteger(e,"ratioScale"),l=this.safeInteger(e,"valueScale"),u=this.safeString(e,"minPriceEp"),p=this.safeString(e,"maxPriceEp"),f=this.safeString(e,"makerFeeRateEr"),m=this.safeString(e,"takerFeeRateEr"),g=this.safeString(e,"status"),v=this.safeString(e,"contractSize"," ");let y;if("USDT"===n)y=this.parseNumber("1");else if(v.indexOf(" ")){const e=v.split(" ");y=this.parseNumber(e[0])}else y=this.parseNumber(v);return this.safeMarketStructure({id:t,symbol:a+"/"+o+":"+n,base:a,quote:o,settle:n,baseId:s,quoteId:i,settleId:r,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:"Listed"===g,contract:!0,linear:!d,inverse:d,taker:this.parseNumber(this.fromEn(m,c)),maker:this.parseNumber(this.fromEn(f,c)),contractSize:y,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:h,valueScale:l,ratioScale:c,precision:{amount:this.safeNumber2(e,"lotSize","qtyStepSize"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(e,"maxLeverage")},amount:{min:void 0,max:void 0},price:{min:this.parseNumber(this.fromEn(u,h)),max:this.parseNumber(this.fromEn(p,h))},cost:{min:void 0,max:this.parseNumber(this.safeString(e,"maxOrderQty"))}},created:void 0,info:e})}parseSpotMarket(e){const t=this.safeStringLower(e,"type"),s=this.safeString(e,"symbol"),i=this.safeString(e,"quoteCurrency"),r=this.safeString(e,"baseCurrency"),a=this.safeCurrencyCode(r),o=this.safeCurrencyCode(i),n=this.safeString(e,"status"),d=this.parseSafeNumber(this.safeString(e,"baseTickSize")),h=this.parseSafeNumber(this.safeString(e,"quoteTickSize"));return this.safeMarketStructure({id:s,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:r,quoteId:i,settleId:void 0,type:t,spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"Listed"===n,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"defaultTakerFee"),maker:this.safeNumber(e,"defaultMakerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,priceScale:this.safeInteger(e,"priceScale"),valueScale:this.safeInteger(e,"valueScale"),ratioScale:this.safeInteger(e,"ratioScale"),precision:{amount:d,price:h},limits:{leverage:{min:void 0,max:void 0},amount:{min:d,max:this.parseSafeNumber(this.safeString(e,"maxBaseOrderSize"))},price:{min:h,max:void 0},cost:{min:this.parseSafeNumber(this.safeString(e,"minOrderValue")),max:this.parseSafeNumber(this.safeString(e,"maxOrderValue"))}},created:void 0,info:e})}async fetchMarkets(e={}){const t=await this.v2GetPublicProducts(e),s=await this.v1GetExchangePublicProducts(e),i=this.safeValue(s,"data",[]),r=this.safeValue(t,"data",{});let a=this.safeValue(r,"products",[]);const o=this.safeValue(r,"perpProductsV2",[]);a=this.arrayConcat(a,o);let n=this.safeValue(r,"riskLimits",[]);const d=this.safeValue(r,"riskLimitsV2",[]);n=this.arrayConcat(n,d);const h=this.safeValue(r,"currencies",[]),c=this.indexBy(n,"symbol"),l=this.indexBy(i,"symbol"),u=this.indexBy(h,"currency"),p=[];for(let e=0;e<a.length;e++){let t=a[e];const s=this.safeStringLower(t,"type");if("perpetual"===s||"perpetualv2"===s){const e=this.safeString(t,"symbol"),s=this.safeValue(c,e,{});t=this.extend(t,s);const i=this.safeValue(l,e,{});t=this.extend(t,i),t=this.parseSwapMarket(t)}else{const e=this.safeString(t,"baseCurrency"),s=this.safeValue(u,e,{}),i=this.safeString(s,"valueScale","8");t=this.extend(t,{valueScale:i}),t=this.parseSpotMarket(t)}p.push(t)}return p}async fetchCurrencies(e={}){const t=await this.v2GetPublicProducts(e),s=this.safeValue(t,"data",{}),i=this.safeValue(s,"currencies",[]),r={};for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"currency"),o=this.safeString(t,"name"),n=this.safeCurrencyCode(s),d=this.safeString(t,"status"),h=this.safeString(t,"valueScale"),c=parseInt(h),l=this.safeString(t,"minValueEv"),u=this.safeString(t,"maxValueEv");let p,f,m;if(void 0!==c){const e=this.parsePrecision(h);m=this.parseNumber(e),p=this.parseNumber(a.Y.stringMul(l,e)),f=this.parseNumber(a.Y.stringMul(u,e))}r[n]={id:s,info:t,code:n,name:o,active:"Listed"===d,deposit:void 0,withdraw:void 0,fee:void 0,precision:m,limits:{amount:{min:p,max:f},withdraw:{min:void 0,max:void 0}},valueScale:c,networks:{}}}return r}customParseBidAsk(e,t=0,s=1,i=void 0){if(void 0===i)throw new r.ArgumentsRequired(this.id+" customParseBidAsk() requires a market argument");let a=this.safeString(e,s);return i.spot&&(a=this.fromEv(a,i)),[this.parseNumber(this.fromEp(this.safeString(e,t),i)),this.parseNumber(a)]}customParseOrderBook(e,t,s=void 0,i="bids",r="asks",a=0,o=1,n=void 0){const d={symbol:t,timestamp:s,datetime:this.iso8601(s),nonce:void 0},h=[i,r];for(let t=0;t<h.length;t++){const s=h[t],i=[],r=this.safeValue(e,s);for(let e=0;e<r.length;e++)i.push(this.customParseBidAsk(r[e],a,o,n));d[s]=i}return d[i]=this.sortBy(d[i],0,!0),d[r]=this.sortBy(d[r],0),d}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let a;a=i.linear&&"USDT"===i.settle?await this.v2GetMdV2Orderbook(this.extend(r,s)):void 0!==t&&t<=30?await this.v1GetMdOrderbook(this.extend(r,s)):await this.v1GetMdFullbook(this.extend(r,s));const o=this.safeValue(a,"result",{}),n=this.safeValue2(o,"book","orderbook_p",{}),d=this.safeIntegerProduct(o,"timestamp",1e-6),h=this.customParseOrderBook(n,e,d,"bids","asks",0,1,i);return h.nonce=this.safeInteger(o,"sequence"),h}toEn(e,t){const s=this.numberToString(e),i=new a.Y(s);i.decimals=i.decimals-t,i.reduce();const r=i.toString();return this.parseToInt(r)}toEv(e,t=void 0){return void 0===e||void 0===t?e:this.toEn(e,t.valueScale)}toEp(e,t=void 0){return void 0===e||void 0===t?e:this.toEn(e,t.priceScale)}fromEn(e,t){if(void 0===e)return;const s=new a.Y(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}parseOHLCV(e,t=void 0){let s;return s=void 0!==t&&t.spot?this.parseNumber(this.fromEv(this.safeString(e,7),t)):this.safeNumber(e,7),[this.safeTimestamp(e,0),this.parseNumber(this.fromEp(this.safeString(e,3),t)),this.parseNumber(this.fromEp(this.safeString(e,4),t)),this.parseNumber(this.fromEp(this.safeString(e,5),t)),this.parseNumber(this.fromEp(this.safeString(e,6),t)),s]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=i,n={symbol:a.id,resolution:this.safeString(this.timeframes,t,t)},d=this.safeInteger2(r,"until","to");r=this.omit(r,["until"]);let h,c=1e3;if((a.linear||"USDT"===a.settle)&&(void 0!==s||void 0!==d)&&(c=2e3),void 0===i&&(i=c),n.limit=Math.min(i,c),a.linear||"USDT"===a.settle)if(void 0!==d||void 0!==s){const e=this.parseTimeframe(t);if(void 0!==s?(s=Math.round(s/1e3),n.from=s):s=d/100-c*e,void 0!==d)n.to=Math.round(d/1e3);else{let t=s+c*e;const i=this.seconds();t>i&&(t=i),n.to=t}h=await this.publicGetMdV2KlineList(this.extend(n,r))}else h=await this.publicGetMdV2KlineLast(this.extend(n,r));else{if(void 0!==s){const e=1e3*this.parseTimeframe(t),r=this.milliseconds()-s;i=this.parseToInt(r/e)}h=await this.publicGetMdV2Kline(this.extend(n,r))}const l=this.safeValue(h,"data",{}),u=this.safeList(l,"rows",[]);return this.parseOHLCVs(u,a,t,s,o)}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeIntegerProduct(e,"timestamp",1e-6),a=this.fromEp(this.safeString2(e,"lastEp","closeRp"),t),o=this.fromEr(this.safeString2(e,"turnoverEv","turnoverRv"),t);let n=this.safeString(e,"volume");void 0===n&&(n=this.fromEv(this.safeString2(e,"volumeEv","volumeRq"),t));const d=this.fromEp(this.safeString(e,"openEp"),t);return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.fromEp(this.safeString2(e,"highEp","highRp"),t),low:this.fromEp(this.safeString2(e,"lowEp","lowRp"),t),bid:this.fromEp(this.safeString(e,"bidEp"),t),bidVolume:void 0,ask:this.fromEp(this.safeString(e,"askEp"),t),askVolume:void 0,vwap:void 0,open:d,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.swap?s.inverse||"USD"===s.settle?await this.v1GetMdTicker24hr(this.extend(i,t)):await this.v2GetMdV2Ticker24hr(this.extend(i,t)):await this.v1GetMdSpotTicker24hr(this.extend(i,t));const a=this.safeDict(r,"result",{});return this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){let s,i,r;if(await this.loadMarkets(),void 0!==e){const t=this.safeValue(e,0);s=this.market(t)}[i,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),[r,t]=this.handleSubTypeAndParams("fetchTickers",s,t);const a=this.omit(t,"type");let o;o="spot"===i?await this.v1GetMdSpotTicker24hrAll(a):"inverse"===r||"USD"===this.safeString(s,"settle")?await this.v1GetMdTicker24hrAll(a):await this.v2GetMdV2Ticker24hrAll(a);const n=this.safeList(o,"result",[]);return this.parseTickers(n,e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};let o;o=r.linear&&"USDT"===r.settle?await this.v2GetMdV2Trade(this.extend(a,i)):await this.v1GetMdTrade(this.extend(a,i));const n=this.safeValue(o,"result",{}),d=this.safeValue2(n,"trades","trades_p",[]);return this.parseTrades(d,r,t,s)}parseTrade(e,t=void 0){let s,i,r,a,o,n,d,h,c,l,u;const p=this.safeString(e,"symbol"),f=(t=this.safeMarket(p,t)).symbol;let m,g;if(Array.isArray(e)){const n=e.length;r=this.safeIntegerProduct(e,0,1e-6),n>4&&(a=this.safeString(e,n-4)),o=this.safeStringLower(e,n-3),s=this.safeString(e,n-2),i=this.safeString(e,n-1),"number"==typeof e[n-2]&&(s=this.fromEp(s,t),i=this.fromEv(i,t))}else{if(r=this.safeIntegerProduct(e,"transactTimeNs",1e-6),void 0===r&&(r=this.safeInteger(e,"createdAt")),a=this.safeString2(e,"execId","execID"),m=this.safeString(e,"orderID"),"USDT"===t.settle){const t=this.safeStringLower(e,"side");"buy"===t||"sell"===t?o=t:void 0!==t&&(o="1"===t?"buy":"sell");const r=this.safeString(e,"ordType");if("1"===r?d="market":"2"===r&&(d="limit"),s=this.safeString(e,"execPriceRp"),i=this.safeString(e,"execQtyRq"),n=this.safeString(e,"execValueRv"),c=this.omitZero(this.safeString(e,"execFeeRv")),l=this.safeString(e,"feeRateRr"),void 0!==c){const t=this.safeString(e,"currency");u=this.safeCurrencyCode(t)}else{const t=this.omitZero(this.safeString(e,"ptFeeRv"));void 0!==t&&(c=t,u="PT")}}else{o=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType"));if("MakerFill"===this.safeString(e,"execStatus")&&(g="maker"),s=this.fromEp(this.safeString(e,"execPriceEp"),t),i=this.fromEv(this.safeString(e,"execBaseQtyEv"),t),i=this.safeString(e,"execQty",i),n=this.fromEr(this.safeString2(e,"execQuoteQtyEv","execValueEv"),t),c=this.fromEr(this.omitZero(this.safeString(e,"execFeeEv")),t),void 0!==c)if(l=this.fromEr(this.safeString(e,"feeRateEr"),t),t.spot)u=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));else{const e=this.safeValue(t,"info");if(void 0!==e){const t=this.safeString(e,"settlementCurrency");u=this.safeCurrencyCode(t)}}else c=this.safeString(e,"ptFeeRv"),void 0!==c&&(u="PT")}h={cost:c,rate:l,currency:u}}return this.safeTrade({info:e,id:a,symbol:f,timestamp:r,datetime:this.iso8601(r),order:m,type:d,side:o,takerOrMaker:g,price:s,amount:i,cost:n,fee:h},t)}parseSpotBalance(e){let t;const s={info:e},i=this.safeValue(e,"data",[]);for(let e=0;e<i.length;e++){const r=i[e],o=this.safeString(r,"currency"),n=this.safeCurrencyCode(o),d=this.safeValue(this.currencies,n,{}),h=this.safeInteger(d,"valueScale",8),c=this.account(),l=this.safeString(r,"balanceEv"),u=this.safeString(r,"lockedTradingBalanceEv"),p=this.safeString(r,"lockedWithdrawEv"),f=this.fromEn(l,h),m=this.fromEn(u,h),g=this.fromEn(p,h),v=a.Y.stringAdd(m,g),y=this.safeIntegerProduct(r,"lastUpdateTimeNs",1e-6);t=void 0===t?y:Math.max(t,y),c.total=f,c.used=v,s[n]=c}return s.timestamp=t,s.datetime=this.iso8601(t),this.safeBalance(s)}parseSwapBalance(e){const t={info:e},s=this.safeValue(e,"data",{}),i=this.safeValue(s,"account",{}),r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.currency(a),n=this.safeInteger(o,"valueScale",8),d=this.account(),h=this.safeString2(i,"accountBalanceEv","accountBalanceRv"),c=this.safeString2(i,"totalUsedBalanceEv","totalUsedBalanceRv"),l="USDT"!==a;return d.total=l?this.fromEn(h,n):h,d.used=l?this.fromEn(c,n):c,t[a]=d,this.safeBalance(t)}async fetchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e);const s=this.safeString(e,"code");let i;e=this.omit(e,["code"]);const a={};if("spot"!==t&&"swap"!==t)throw new r.BadRequest(this.id+" does not support "+t+" markets, only spot and swap");if("swap"===t){let o;if([o,e]=this.handleOptionAndParams(e,"fetchBalance","settle","USDT"),void 0!==s||void 0!==o){let t;t=void 0!==s?s:o;const r=this.currency(t);a.currency=r.id,i="USDT"===r.id?await this.privateGetGAccountsAccountPositions(this.extend(a,e)):await this.privateGetAccountsAccountPositions(this.extend(a,e))}else{if(void 0===this.safeString(e,"currency"))throw new r.ArgumentsRequired(this.id+" fetchBalance() requires a code parameter or a currency or settle parameter for "+t+" type");i=await this.privateGetSpotWallets(this.extend(a,e))}}else i=await this.privateGetSpotWallets(this.extend(a,e));return"swap"===t?this.parseSwapBalance(i):this.parseSpotBalance(i)}parseOrderStatus(e){return this.safeString({Created:"open",Untriggered:"open",Deactivated:"closed",Triggered:"open",Rejected:"rejected",New:"open",PartiallyFilled:"open",Filled:"closed",Canceled:"canceled",1:"open",2:"canceled",3:"closed",4:"canceled",5:"open",6:"open",7:"closed",8:"canceled"},e,e)}parseOrderType(e){return this.safeString({1:"market",2:"limit",3:"stop",4:"stopLimit",5:"market",6:"limit",7:"market",8:"market",9:"stopLimit",10:"market",Limit:"limit",Market:"market"},e,e)}parseTimeInForce(e){return this.safeString({GoodTillCancel:"GTC",PostOnly:"PO",ImmediateOrCancel:"IOC",FillOrKill:"FOK"},e,e)}parseSpotOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");void 0!==i&&i.length<1&&(i=void 0);const r=this.safeString(e,"symbol"),a=(t=this.safeMarket(r,t)).symbol,o=this.fromEp(this.safeString(e,"priceEp"),t),n=this.fromEv(this.safeString(e,"baseQtyEv"),t),d=this.omitZero(this.fromEv(this.safeString(e,"leavesBaseQtyEv"),t)),h=this.fromEv(this.safeString2(e,"cumBaseQtyEv","cumBaseValueEv"),t),c=this.fromEr(this.safeString2(e,"cumQuoteValueEv","quoteQtyEv"),t),l=this.fromEp(this.safeString(e,"avgPriceEp"),t),u=this.parseOrderStatus(this.safeString(e,"ordStatus")),p=this.safeStringLower(e,"side"),f=this.parseOrderType(this.safeString(e,"ordType")),m=this.safeIntegerProduct2(e,"actionTimeNs","createTimeNs",1e-6);let g;const v=this.fromEv(this.safeString(e,"cumFeeEv"),t);void 0!==v&&(g={cost:v,currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))});const y=this.parseTimeInForce(this.safeString(e,"timeInForce")),w=this.parseNumber(this.omitZero(this.fromEp(this.safeString(e,"stopPxEp")))),b="PO"===y;return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:void 0,symbol:a,type:f,timeInForce:y,postOnly:b,side:p,price:o,stopPrice:w,triggerPrice:w,amount:n,cost:c,average:l,filled:h,remaining:d,status:u,fee:g,trades:void 0},t)}parseOrderSide(e){return this.safeString({1:"buy",2:"sell"},e,e)}parseSwapOrder(e,t=void 0){const s=this.safeString2(e,"orderID","orderId");let i=this.safeString2(e,"clOrdID","clOrdId");void 0!==i&&i.length<1&&(i=void 0);const r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t);t=this.safeMarket(r,t);const o=this.parseOrderStatus(this.safeString(e,"ordStatus")),n=this.parseOrderSide(this.safeStringLower(e,"side")),d=this.parseOrderType(this.safeString(e,"orderType"));let h=this.safeString(e,"priceRp");void 0===h&&(h=this.fromEp(this.safeString(e,"priceEp"),t));const c=this.safeNumber2(e,"orderQty","orderQtyRq"),l=this.safeNumber2(e,"cumQty","cumQtyRq"),u=this.safeNumber2(e,"leavesQty","leavesQtyRq");let p=this.safeIntegerProduct(e,"actionTimeNs",1e-6);void 0===p&&(p=this.safeInteger(e,"createdAt"));const f=this.safeNumber2(e,"cumValue","cumValueRv");let m=this.safeIntegerProduct(e,"transactTimeNs",1e-6);0===m&&(m=void 0);const g=this.parseTimeInForce(this.safeString(e,"timeInForce")),v=this.omitZero(this.safeString2(e,"stopPx","stopPxRp")),y="PO"===g;let w=this.safeValue(e,"reduceOnly");"ReduceOnly"===this.safeString(e,"execInst")&&(w=!0);const b=this.safeString(e,"takeProfitRp"),S=this.safeString(e,"stopLossRp"),k=this.omitZero(this.safeString(e,"execFeeRv")),O=this.omitZero(this.safeString(e,"ptFeeRv"));let T;return void 0!==k?T={cost:k,currency:t.quote}:void 0!==O&&(T={cost:O,currency:"PT"}),this.safeOrder({info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:m,symbol:a,type:d,timeInForce:g,postOnly:y,reduceOnly:w,side:n,price:h,stopPrice:v,triggerPrice:v,takeProfitPrice:b,stopLossPrice:S,amount:c,filled:l,remaining:u,cost:f,average:void 0,status:o,fee:T,trades:void 0})}parseOrder(e,t=void 0){return this.safeBool(t,"swap",!1)||("closedPnl"in e||"closedPnlRv"in e||"totalPnlRv"in e)?this.parseSwapOrder(e,t):this.parseSpotOrder(e,t)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e),h=this.capitalize(s);t=this.capitalize(t);const c=this.safeBool(n,"reduceOnly"),l={symbol:d.id,side:h,ordType:t},u=this.safeString2(n,"clOrdID","clientOrderId"),p=this.safeValue(n,"stopLoss"),f=void 0!==p,m=this.safeValue(n,"takeProfit"),g=void 0!==m;if(void 0===u){const e=this.safeString(this.options,"brokerId","CCXT123456");void 0!==e&&(l.clOrdID=e+this.uuid16())}else l.clOrdID=u,n=this.omit(n,["clOrdID","clientOrderId"]);const v=this.safeStringN(n,["stopPx","stopPrice","triggerPrice"]);if(void 0!==v&&("USDT"===d.settle?l.stopPxRp=this.priceToPrecision(e,v):l.stopPxEp=this.toEp(v,d)),n=this.omit(n,["stopPx","stopPrice","stopLoss","takeProfit","triggerPrice"]),d.spot){let e=this.safeValue(n,"qtyType","ByBase");if("Market"!==t&&"Stop"!==t&&"MarketIfTouched"!==t||void 0!==o&&(e="ByQuote"),void 0!==v&&("Limit"===t?l.ordType="StopLimit":"Market"===t&&(l.ordType="Stop"),l.trigger="ByLastPrice"),l.qtyType=e,"ByQuote"===e){let t=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),this.options.createOrderByQuoteRequiresPrice)if(void 0!==o){const e=this.numberToString(i),s=this.numberToString(o),r=a.Y.stringMul(e,s);t=this.parseNumber(r)}else if(void 0===t)throw new r.ArgumentsRequired(this.id+" createOrder() "+e+" requires a price argument or a cost parameter");t=void 0===t?i:t;const s=this.numberToString(t);l.quoteQtyEv=this.toEv(s,d)}else{const e=this.numberToString(i);l.baseQtyEv=this.toEv(e,d)}}else if(d.swap){let t=this.safeStringLower(n,"posSide");if(void 0===t&&(t="Merged"),t=this.capitalize(t),l.posSide=t,void 0!==c&&(l.reduceOnly=c),"USDT"===d.settle?l.orderQtyRq=i:l.orderQty=this.parseToInt(i),void 0!==v){const e=this.safeString(n,"triggerType","ByMarkPrice");l.triggerType=e}if(f||g){if(f){const t=this.safeValue2(p,"triggerPrice","stopPrice");if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["stopLoss"]["triggerPrice"], or params["stopLoss"]["stopPrice"] for a stop loss order');"USDT"===d.settle?l.stopLossRp=this.priceToPrecision(e,t):l.stopLossEp=this.toEp(t,d);const s=this.safeString2(p,"triggerPriceType","slTrigger");if(void 0!==s){if("USDT"===d.settle){if("ByMarkPrice"!==s&&"ByLastPrice"!==s&&"ByIndexPrice"!==s&&"ByAskPrice"!==s&&"ByBidPrice"!==s&&"ByMarkPriceLimit"!==s&&"ByLastPriceLimit"!==s)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "ByMarkPrice", "ByIndexPrice", "ByAskPrice", "ByBidPrice", "ByMarkPriceLimit", "ByLastPriceLimit" or "ByLastPrice"')}else if("ByMarkPrice"!==s&&"ByLastPrice"!==s)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "ByMarkPrice", or "ByLastPrice"');l.slTrigger=s}}if(g){const t=this.safeValue2(m,"triggerPrice","stopPrice");if(void 0===t)throw new r.InvalidOrder(this.id+' createOrder() requires a trigger price in params["takeProfit"]["triggerPrice"], or params["takeProfit"]["stopPrice"] for a take profit order');"USDT"===d.settle?l.takeProfitRp=this.priceToPrecision(e,t):l.takeProfitEp=this.toEp(t,d);const s=this.safeString2(p,"triggerPriceType","tpTrigger");if(void 0!==s){if("USDT"===d.settle){if("ByMarkPrice"!==s&&"ByLastPrice"!==s&&"ByIndexPrice"!==s&&"ByAskPrice"!==s&&"ByBidPrice"!==s&&"ByMarkPriceLimit"!==s&&"ByLastPriceLimit"!==s)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "ByMarkPrice", "ByIndexPrice", "ByAskPrice", "ByBidPrice", "ByMarkPriceLimit", "ByLastPriceLimit" or "ByLastPrice"')}else if("ByMarkPrice"!==s&&"ByLastPrice"!==s)throw new r.InvalidOrder(this.id+' createOrder() take profit trigger price type must be one of "ByMarkPrice", or "ByLastPrice"');l.tpTrigger=s}}}}if("Limit"===t||"StopLimit"===t||"LimitIfTouched"===t)if("USDT"===d.settle)l.priceRp=this.priceToPrecision(e,o);else{const e=this.numberToString(o);l.priceEp=this.toEp(e,d)}const y=this.safeString(n,"takeProfitPrice");void 0!==y&&("USDT"===d.settle?l.takeProfitRp=this.priceToPrecision(e,y):l.takeProfitEp=this.toEp(y,d),n=this.omit(n,"takeProfitPrice"));const w=this.safeString(n,"stopLossPrice");let b;void 0!==w&&("USDT"===d.settle?l.stopLossRp=this.priceToPrecision(e,w):l.stopLossEp=this.toEp(w,d),n=this.omit(n,"stopLossPrice")),n=this.omit(n,"reduceOnly"),b="USDT"===d.settle?await this.privatePostGOrders(this.extend(l,n)):d.contract?await this.privatePostOrders(this.extend(l,n)):await this.privatePostSpotOrders(this.extend(l,n));const S=this.safeDict(b,"data",{});return this.parseOrder(S,d)}async editOrder(e,t,s=void 0,i=void 0,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={symbol:n.id},h=this.safeString2(o,"clientOrderId","clOrdID");o=this.omit(o,["clientOrderId","clOrdID"]);const c="USDT"===n.settle;void 0!==h?d.clOrdID=h:d.orderID=e,void 0!==a&&(c?d.priceRp=this.priceToPrecision(n.symbol,a):d.priceEp=this.toEp(a,n));const l=this.safeString(o,"baseQtyEv");o=this.omit(o,["baseQtyEv"]),void 0!==l?d.baseQtyEV=l:void 0!==r&&(c?d.orderQtyRq=this.amountToPrecision(n.symbol,r):d.baseQtyEV=this.toEv(r,n));const u=this.safeString2(o,"stopPx","stopPrice");let p;if(void 0!==u&&(c?d.stopPxRp=this.priceToPrecision(t,u):d.stopPxEp=this.toEp(u,n)),o=this.omit(o,["stopPx","stopPrice"]),c){void 0===this.safeString(o,"posSide")&&(d.posSide="Merged"),p=await this.privatePutGOrdersReplace(this.extend(d,o))}else p=n.swap?await this.privatePutOrdersReplace(this.extend(d,o)):await this.privatePutSpotOrders(this.extend(d,o));const f=this.safeDict(p,"data",{});return this.parseOrder(f,n)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id},o=this.safeString2(s,"clientOrderId","clOrdID");let n;if(s=this.omit(s,["clientOrderId","clOrdID"]),void 0!==o?a.clOrdID=o:a.orderID=e,"USDT"===i.settle){void 0===this.safeString(s,"posSide")&&(a.posSide="Merged"),n=await this.privateDeleteGOrdersCancel(this.extend(a,s))}else n=i.swap?await this.privateDeleteOrdersCancel(this.extend(a,s)):await this.privateDeleteSpotOrders(this.extend(a,s));const d=this.safeDict(n,"data",{});return this.parseOrder(d,i)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s=this.market(e),i=this.safeValue2(t,"stop","trigger",!1);t=this.omit(t,"stop","trigger");const a={symbol:s.id};let o;return i&&(a.untriggerred=i),o="USDT"===s.settle?await this.privateDeleteGOrdersAll(this.extend(a,t)):s.swap?await this.privateDeleteOrdersAll(this.extend(a,t)):await this.privateDeleteSpotOrdersAll(this.extend(a,t)),[this.safeOrder({info:o})]}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={symbol:i.id},o=this.safeString2(s,"clientOrderId","clOrdID");let n;s=this.omit(s,["clientOrderId","clOrdID"]),void 0!==o?a.clOrdID=o:a.orderID=e,n="USDT"===i.settle?await this.privateGetApiDataGFuturesOrdersByOrderId(this.extend(a,s)):i.spot?await this.privateGetApiDataSpotsOrdersByOrderId(this.extend(a,s)):await this.privateGetExchangeOrder(this.extend(a,s));const d=this.safeValue(n,"data",{});let h=d;if(Array.isArray(d)){if(d.length<1)throw void 0!==o?new r.OrderNotFound(this.id+" fetchOrder() "+t+" order with clientOrderId "+o+" not found"):new r.OrderNotFound(this.id+" fetchOrder() "+t+" order with id "+e+" not found");h=this.safeDict(d,0,{})}else if(i.spot){const e=this.safeList(d,"rows",[]);h=this.safeDict(e,0,{})}return this.parseOrder(h,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};let n;void 0!==t&&(o.start=t),void 0!==s&&(o.limit=s),"USDT"===a.settle?(o.currency=a.settle,n=await this.privateGetExchangeOrderV2OrderList(this.extend(o,i))):n=a.swap?await this.privateGetExchangeOrderList(this.extend(o,i)):await this.privateGetApiDataSpotsOrders(this.extend(o,i));const d=this.safeValue(n,"data",{}),h=this.safeList(d,"rows",d);return this.parseOrders(h,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};let n;try{n="USDT"===a.settle?await this.privateGetGOrdersActiveList(this.extend(o,i)):a.swap?await this.privateGetOrdersActiveList(this.extend(o,i)):await this.privateGetSpotOrders(this.extend(o,i))}catch(e){if(e instanceof r.OrderNotFound)return[];throw e}const d=this.safeValue(n,"data",{});if(Array.isArray(d))return this.parseOrders(d,a,t,s);{const e=this.safeList(d,"rows",[]);return this.parseOrders(e,a,t,s)}}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};let o;void 0!==r&&(a.symbol=r.id),void 0!==t&&(a.start=t),void 0!==s&&(a.limit=s),void 0===e||"USDT"===this.safeString(r,"settle")?(a.currency=this.safeString(i,"settle","USDT"),o=await this.privateGetExchangeOrderV2OrderList(this.extend(a,i))):o=r.swap?await this.privateGetExchangeOrderList(this.extend(a,i)):await this.privateGetExchangeSpotOrder(this.extend(a,i));const n=this.safeValue(o,"data",{});if(Array.isArray(n))return this.parseOrders(n,r,t,s);{const e=this.safeList(n,"rows",[]);return this.parseOrders(e,r,t,s)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==s&&(s=Math.min(200,s),a.limit=s);const o=void 0===e||"USDT"===this.safeString(r,"settle");let n,d;return o?(a.currency="USDT",a.offset=0,void 0===s&&(a.limit=200)):a.symbol=r.id,void 0!==t&&(a.start=t),n=o?await this.privateGetExchangeOrderV2TradingList(this.extend(a,i)):r.swap?await this.privateGetExchangeOrderTrade(this.extend(a,i)):await this.privateGetExchangeSpotOrderTrades(this.extend(a,i)),o?d=this.safeValue(n,"data",[]):(d=this.safeValue(n,"data",{}),d=this.safeValue(d,"rows",[])),this.parseTrades(d,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=this.safeValue(this.options,"defaultNetworks"),a=this.safeStringUpper(r,e),o=this.safeValue(this.options,"networks",{});let n=this.safeStringUpper(t,"network",a);n=this.safeString(o,n,n),void 0===n?i.chainName=s.id:(i.chainName=n,t=this.omit(t,"network"));const d=await this.privateGetPhemexUserWalletsV2DepositAddress(this.extend(i,t)),h=this.safeValue(d,"data",{}),c=this.safeString(h,"address"),l=this.safeString(h,"tag");return this.checkAddress(c),{currency:e,address:c,tag:l,network:void 0,info:d}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a=await this.privateGetExchangeWalletsDepositList(i),o=this.safeList(a,"data",[]);return this.parseTransactions(o,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.currency(e));const a=await this.privateGetExchangeWalletsWithdrawList(i),o=this.safeList(a,"data",[]);return this.parseTransactions(o,r,t,s)}parseTransactionStatus(e){return this.safeString({Success:"ok",Succeed:"ok",Rejected:"failed","Security check failed":"failed",SecurityCheckFailed:"failed",Expired:"failed","Address Risk":"failed","Security Checking":"pending",SecurityChecking:"pending","Pending Review":"pending","Pending Transfer":"pending",AmlCsApporve:"pending",New:"pending",Confirmed:"pending",Cancelled:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"address"),r=void 0,a=this.safeString(e,"txHash"),o=this.safeString(e,"currency"),n=(t=this.safeCurrency(o,t)).code,d=this.safeString(e,"chainName"),h=this.safeIntegerN(e,["createdAt","submitedAt","submittedAt"]);let c,l=this.safeStringLower(e,"type"),u=this.parseNumber(this.fromEn(this.safeString(e,"feeEv"),t.valueScale));void 0===u&&(u=this.safeNumber(e,"feeRv")),void 0!==u&&(l="withdrawal",c={cost:u,currency:n});const p=this.parseTransactionStatus(this.safeString(e,"status"));let f=this.parseNumber(this.fromEn(this.safeString(e,"amountEv"),t.valueScale));return void 0===f&&(f=this.safeNumber(e,"amountRv")),{info:e,id:s,txid:a,timestamp:h,datetime:this.iso8601(h),network:this.networkIdToCode(d),address:i,addressTo:i,addressFrom:void 0,tag:r,tagTo:r,tagFrom:void 0,type:l,amount:f,currency:n,status:p,updated:void 0,comment:void 0,internal:void 0,fee:c}}async fetchPositions(e=void 0,t={}){let s;await this.loadMarkets(),e=this.marketSymbols(e);let i,r,a=this.safeString(t,"currency");const o=this.safeString(e,0);void 0!==o?(r=this.market(o),i=r.settle,a=r.settle):[i,t]=this.handleOptionAndParams(t,"fetchPositions","settle","USD"),[s,t]=this.handleSubTypeAndParams("fetchPositions",r,t);const n="USDT"===i;n?a="USDT":void 0===a?a="linear"===s?"USD":"BTC":t=this.omit(t,"code");const d={currency:this.currency(a).id};let h;if(n){let e;[e,t]=this.handleOptionAndParams(t,"fetchPositions","method","privateGetGAccountsAccountPositions"),h="privateGetGAccountsAccountPositions"===e?await this.privateGetGAccountsAccountPositions(this.extend(d,t)):await this.privateGetAccountsPositions(this.extend(d,t))}else h=await this.privateGetAccountsAccountPositions(this.extend(d,t));const c=this.safeValue(h,"data",{}),l=this.safeValue(c,"positions",[]),u=[];for(let e=0;e<l.length;e++){const t=l[e];u.push(this.parsePosition(t))}return this.filterByArrayPositions(u,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"positionMargin","positionMarginRv"),o=this.safeString2(e,"value","valueRv"),n=this.safeString2(e,"maintMarginReq","maintMarginReqRr"),d=a.Y.stringMul(o,n),h=this.safeString2(e,"assignedPosBalance","assignedPosBalanceRv"),c=a.Y.stringDiv(h,o),l=this.safeNumber2(e,"liquidationPrice","liquidationPriceRp"),u=this.safeString2(e,"markPrice","markPriceRp"),p=this.safeString(e,"size"),f=this.safeValue(t,"contractSize"),m=this.numberToString(f),g=this.parseNumber(a.Y.stringAbs(this.safeString2(e,"leverage","leverageRr"))),v=this.safeString2(e,"avgEntryPrice","avgEntryPriceRp"),y=this.safeString(e,"side");let w,b;void 0!==y&&(w="Buy"===y?"long":"short");b="USD"===this.safeString(e,"currency")?"long"===w?a.Y.stringSub(u,v):a.Y.stringSub(v,u):"long"===w?a.Y.stringSub(a.Y.stringDiv("1",v),a.Y.stringDiv("1",u)):a.Y.stringSub(a.Y.stringDiv("1",u),a.Y.stringDiv("1",v));const S=a.Y.stringMul(a.Y.stringMul(b,p),m),k=a.Y.stringDiv(d,r),O=this.safeValue(e,"crossMargin");return this.safePosition({info:e,id:void 0,symbol:i,contracts:this.parseNumber(p),contractSize:f,unrealizedPnl:this.parseNumber(S),leverage:g,liquidationPrice:l,collateral:this.parseNumber(r),notional:this.parseNumber(o),markPrice:this.parseNumber(u),lastPrice:void 0,entryPrice:this.parseNumber(v),timestamp:void 0,lastUpdateTimestamp:void 0,initialMargin:this.parseNumber(h),initialMarginPercentage:this.parseNumber(c),maintenanceMargin:this.parseNumber(d),maintenanceMarginPercentage:this.parseNumber(n),marginRatio:this.parseNumber(k),datetime:void 0,marginMode:O?"cross":"isolated",side:w,hedged:!1,percentage:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};if(void 0!==s){if(s>200)throw new r.BadRequest(this.id+" fetchFundingHistory() limit argument cannot exceed 200");o.limit=s}let n;n="USDT"===a.settle?await this.privateGetApiDataGFuturesFundingFees(this.extend(o,i)):await this.privateGetApiDataFuturesFundingFees(this.extend(o,i));const d=this.safeValue(n,"data",{}),h=this.safeValue(d,"rows",[]),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.safeInteger(t,"createTime"),i=this.safeString2(t,"execFeeEv","execFeeRv"),r=this.safeCurrencyCode(this.safeString(t,"currency"));c.push({info:t,symbol:this.safeString(t,"symbol"),code:r,timestamp:s,datetime:this.iso8601(s),id:void 0,amount:this.parseFundingFeeToPrecision(i,a,r)})}return c}parseFundingFeeToPrecision(e,t=void 0,s=void 0){if(void 0===e||void 0===s)return e;if(!("USDT"===t.settle)){const t=this.safeCurrency(s),i=this.safeString(t.info,"valueScale"),r=this.parsePrecision(i);e=a.Y.stringMul(e,r)}return e}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new r.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id};let a={};a=s.linear?await this.v2GetMdV2Ticker24hr(this.extend(i,t)):await this.v1GetMdTicker24hr(this.extend(i,t));const o=this.safeValue(a,"result",{});return this.parseFundingRate(o,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.safeIntegerProduct(e,"timestamp",1e-6);return{info:e,symbol:i,markPrice:this.fromEp(this.safeString2(e,"markEp","markPriceRp"),t),indexPrice:this.fromEp(this.safeString2(e,"indexEp","indexPriceRp"),t),interestRate:void 0,estimatedSettlePrice:void 0,timestamp:r,datetime:this.iso8601(r),fundingRate:this.fromEr(this.safeString(e,"fundingRateEr"),t),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:this.fromEr(this.safeString2(e,"predFundingRateEr","predFundingRateRr"),t),nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async setMargin(e,t,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id,posBalanceEv:this.toEv(t,i)},a=await this.privatePostPositionsAssign(this.extend(r,s));return this.extend(this.parseMarginModification(a,i),{amount:t})}parseMarginStatus(e){return this.safeString({0:"ok"},e,e)}parseMarginModification(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeValue(t,"inverse")?"base":"quote";return{info:e,symbol:this.safeSymbol(void 0,t),type:"set",marginMode:"isolated",amount:void 0,total:void 0,code:t[s],status:this.parseMarginStatus(this.safeString(e,"code")),timestamp:void 0,datetime:void 0}}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");await this.loadMarkets();const i=this.market(t);if(!i.swap||"USDT"===i.settle)throw new r.BadSymbol(this.id+" setMarginMode() supports swap (non USDT based) contracts only");if("isolated"!==(e=e.toLowerCase())&&"cross"!==e)throw new r.BadRequest(this.id+" setMarginMode() marginMode argument should be isolated or cross");let a=this.safeInteger(s,"leverage");if("cross"===e&&(a=0),void 0===a)throw new r.ArgumentsRequired(this.id+" setMarginMode() requires a leverage parameter");const o={symbol:i.id,leverage:a};return await this.privatePutPositionsLeverage(this.extend(o,s))}async setPositionMode(e,t=void 0,s={}){this.checkRequiredArgument("setPositionMode",t,"symbol"),await this.loadMarkets();const i=this.market(t);if("USDT"!==i.settle)throw new r.BadSymbol(this.id+" setPositionMode() supports USDT settled markets only");const a={symbol:i.id};return a.targetPosMode=e?"Hedged":"OneWay",await this.privatePutGPositionsSwitchPosModeSync(this.extend(a,s))}async fetchLeverageTiers(e=void 0,t={}){if(await this.loadMarkets(),void 0!==e){const t=this.safeValue(e,0);if("USD"!==this.market(t).settle)throw new r.BadSymbol(this.id+" fetchLeverageTiers() supports USD settled markets only")}const s=await this.publicGetCfgV2Products(t),i=this.safeValue(s,"data",{}),a=this.safeList(i,"riskLimits");return this.parseLeverageTiers(a,e,"symbol")}parseMarketLeverageTiers(e,t=void 0){const s=(t=this.safeMarket(void 0,t)).info.riskLimits,i=[];let r=0;for(let e=0;e<s.length;e++){const a=s[e],o=this.safeInteger(a,"limit");i.push({tier:this.sum(e,1),currency:t.settle,minNotional:r,maxNotional:o,maintenanceMarginRate:this.safeString(a,"maintenanceMargin"),maxLeverage:void 0,info:a}),r=o}return i}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),d="/"+this.implodeParams(e,i);let h=d,c="";if("GET"!==s&&"DELETE"!==s&&"PUT"!==s&&"/positions/assign"!==h||Object.keys(o).length&&(c=this.urlencodeWithArrayRepeat(o),h+="?"+c),"private"===t){this.checkRequiredCredentials();const t=this.seconds(),o=this.safeInteger(this.options,"x-phemex-request-expiry",60),h=this.sum(t,o).toString();r={"x-phemex-access-token":this.apiKey,"x-phemex-request-expiry":h};let l="";if("POST"===s){if(("g-orders"===e||"spot/orders"===e||"orders"===e)&&void 0===this.safeString(i,"clOrdID")){const e=this.safeString(this.options,"brokerId","CCXT123456");i.clOrdID=e+this.uuid16()}l=this.json(i),a=l,r["Content-Type"]="application/json"}const u=d+c+h+l;r["x-phemex-request-signature"]=this.hmac(this.encode(u),this.encode(this.secret),n.s)}return h=this.implodeHostname(this.urls.api[t])+h,{url:h,method:s,body:a,headers:r}}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");if(e<-100||e>100)throw new r.BadRequest(this.id+" setLeverage() leverage should be between -100 and 100");await this.loadMarkets();const i=this.safeBool(s,"hedged",!1),a=this.safeInteger(s,"longLeverageRr"),o=this.safeInteger(s,"shortLeverageRr"),n=this.market(t),d={symbol:n.id};let h;if("USDT"===n.settle){if(i||void 0!==a||void 0!==o){const t=void 0!==a?a:e,s=void 0!==o?o:e;d.longLeverageRr=t,d.shortLeverageRr=s}else d.leverageRr=e;h=await this.privatePutGPositionsLeverage(this.extend(d,s))}else d.leverage=e,h=await this.privatePutPositionsLeverage(this.extend(d,s));return h}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.toEv(t,a);let c,l;if("spot"===n&&"future"===d?c=2:"future"===n&&"spot"===d&&(c=1),void 0!==c){const e={currency:a.id,moveOp:c,amountEv:h},t=await this.privatePostAssetsTransfer(this.extend(e,r)),s=this.safeValue(t,"data",{});l=this.parseTransfer(s,a)}else{const e={fromUserId:n,toUserId:d,amountEv:h,currency:a.id,bizType:this.safeString(r,"bizType","SPOT")},t=await this.privatePostAssetsUniversalTransfer(this.extend(e,r));l=this.parseTransfer(t)}const u=this.safeValue(this.options,"transfer",{});return this.safeBool(u,"fillResponseFromRequest",!0)&&(void 0===l.fromAccount&&(l.fromAccount=s),void 0===l.toAccount&&(l.toAccount=i),void 0===l.amount&&(l.amount=t),void 0===l.currency&&(l.currency=e)),l}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchTransfers() requires a code argument");const a=this.currency(e),o={currency:a.id};void 0!==t&&(o.start=t),void 0!==s&&(o.limit=s);const n=await this.privateGetAssetsTransfer(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"rows",[]);return this.parseTransfers(h,a,t,s)}parseTransfer(e,t=void 0){const s=this.safeString(e,"linkKey"),i=this.safeString(e,"status"),r=this.safeString(e,"amountEv"),a=this.fromEv(r),o=this.safeString(e,"currency"),n=this.safeCurrencyCode(o,t),d=this.safeInteger(e,"side");let h,c;1===d?(h="swap",c="spot"):2===d&&(h="spot",c="swap");const l=this.safeInteger(e,"createTime");return{info:e,id:s,timestamp:l,datetime:this.iso8601(l),currency:n,amount:a,fromAccount:h,toAccount:c,status:this.parseTransferStatus(i)}}parseTransferStatus(e){return this.safeString({3:"rejected",6:"canceled",10:"ok",11:"failed"},e,e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o="USDT"===a.settle;if(!a.swap)throw new r.BadRequest(this.id+" fetchFundingRateHistory() supports swap contracts only");let n,d=!1;if([d,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),d)return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory",e,t,s,"8h",i,100);n=o?"."+a.id+"FR8H":"."+a.baseId+"FR8H";let h,c={symbol:n};void 0!==t&&(c.start=t),void 0!==s&&(c.limit=s),[c,i]=this.handleUntilOption("end",c,i),h=o?await this.v2GetApiDataPublicDataFundingRateHistory(this.extend(c,i)):await this.v1GetApiDataPublicDataFundingRateHistory(this.extend(c,i));const l=this.safeValue(h,"data",{}),u=this.safeValue(l,"rows"),p=[];for(let t=0;t<u.length;t++){const s=u[t],i=this.safeInteger(s,"fundingTime");p.push({info:s,symbol:e,fundingRate:this.safeNumber(s,"fundingRate"),timestamp:i,datetime:this.iso8601(i)})}const f=this.sortBy(p,"timestamp");return this.filterBySymbolSinceLimit(f,e,t,s)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),await this.loadMarkets(),this.checkAddress(s);const o=this.currency(e);let n,d;[n,a]=this.handleNetworkCodeAndParams(a),void 0!==n&&(d=this.networkCodeToId(n));const h=this.safeValue(this.options,"stableCoins");if(void 0===d){if(this.inArray(e,h))throw new r.ArgumentsRequired(this.id+' withdraw () requires an extra argument params["network"]');d=o.id}const c={currency:o.id,address:s,amount:t,chainName:d.toUpperCase()};void 0!==i&&(c.addressTag=i);const l=await this.privatePostPhemexWithdrawWalletsApiCreateWithdraw(this.extend(c,a)),u=this.safeDict(l,"data",{});return this.parseTransaction(u,o)}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeValue(n,"error",n),l=this.safeString(c,"code"),u=this.safeString(c,"msg");if(void 0!==l&&"0"!==l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,l,e),this.throwBroadlyMatchedException(this.exceptions.broad,u,e),new r.ExchangeError(e)}}}},288:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7733),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"poloniex",name:"Poloniex",countries:["US"],rateLimit:5,certified:!1,pro:!0,has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelOrder:!0,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,editOrder:!0,fetchBalance:!0,fetchClosedOrder:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingRate:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrderTrades:!0,fetchPosition:!1,fetchPositionMode:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!0,sandbox:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"MINUTE_1","5m":"MINUTE_5","10m":"MINUTE_10","15m":"MINUTE_15","30m":"MINUTE_30","1h":"HOUR_1","2h":"HOUR_2","4h":"HOUR_4","6h":"HOUR_6","12h":"HOUR_12","1d":"DAY_1","3d":"DAY_3","1w":"WEEK_1","1M":"MONTH_1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:{rest:"https://api.poloniex.com"},test:{rest:"https://sand-spot-api-gateway.poloniex.com"},www:"https://www.poloniex.com",doc:"https://api-docs.poloniex.com/spot/",fees:"https://poloniex.com/fees",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{markets:20,"markets/{symbol}":1,currencies:20,"currencies/{currency}":20,"v2/currencies":20,"v2/currencies/{currency}":20,timestamp:1,"markets/price":1,"markets/{symbol}/price":1,"markets/markPrice":1,"markets/{symbol}/markPrice":1,"markets/{symbol}/markPriceComponents":1,"markets/{symbol}/orderBook":1,"markets/{symbol}/candles":1,"markets/{symbol}/trades":20,"markets/ticker24h":20,"markets/{symbol}/ticker24h":20,"markets/collateralInfo":1,"markets/{currency}/collateralInfo":1,"markets/borrowRatesInfo":1}},private:{get:{accounts:4,"accounts/balances":4,"accounts/{id}/balances":4,"accounts/activity":20,"accounts/transfer":20,"accounts/transfer/{id}":4,feeinfo:20,"accounts/interest/history":1,subaccounts:4,"subaccounts/balances":20,"subaccounts/{id}/balances":4,"subaccounts/transfer":20,"subaccounts/transfer/{id}":4,"wallets/addresses":20,"wallets/addresses/{currency}":20,"wallets/activity":20,"margin/accountMargin":4,"margin/borrowStatus":4,"margin/maxSize":4,orders:20,"orders/{id}":4,"orders/killSwitchStatus":4,smartorders:20,"smartorders/{id}":4,"orders/history":20,"smartorders/history":20,trades:20,"orders/{id}/trades":4},post:{"accounts/transfer":4,"subaccounts/transfer":20,"wallets/address":20,"wallets/withdraw":20,"v2/wallets/withdraw":20,orders:4,"orders/batch":20,"orders/killSwitch":4,smartorders:4},delete:{"orders/{id}":4,"orders/cancelByIds":20,orders:20,"smartorders/{id}":4,"smartorders/cancelByIds":20,smartorders:20},put:{"orders/{id}":20,"smartorders/{id}":20}}},fees:{trading:{feeSide:"get",maker:this.parseNumber("0.0009"),taker:this.parseNumber("0.0009")},funding:{}},commonCurrencies:{AIR:"AirCoin",APH:"AphroditeCoin",BCC:"BTCtalkcoin",BCHABC:"BCHABC",BDG:"Badgercoin",BTM:"Bitmark",CON:"Coino",ETHTRON:"ETH",GOLD:"GoldEagles",GPUC:"GPU",HOT:"Hotcoin",ITC:"Information Coin",KEY:"KEYCoin",MASK:"NFTX Hashmasks Index",MEME:"Degenerator Meme",PLX:"ParallaxCoin",REPV2:"REP",STR:"XLM",SOC:"SOCC",TRADE:"Unitrade",TRXETH:"TRX",XAP:"API Coin",USDTBSC:"USDT",USDTTRON:"USDT",USDTETH:"USDT",UST:"USTC"},options:{createMarketBuyOrderRequiresPrice:!0,networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON"},limits:{cost:{min:{BTC:1e-4,ETH:1e-4,USDT:1,TRX:100,BNB:.06,USDC:1,USDJ:1,TUSD:1e-4,DAI:1,PAX:1,BUSD:1}}},accountsByType:{spot:"spot",future:"futures"},accountsById:{exchange:"spot",futures:"future"}},precisionMode:o.kb,exceptions:{exact:{500:r.ExchangeNotAvailable,603:r.RequestTimeout,601:r.BadRequest,415:r.ExchangeError,602:r.ArgumentsRequired,21604:r.BadRequest,21600:r.AuthenticationError,21605:r.AuthenticationError,21102:r.ExchangeError,21100:r.AuthenticationError,21704:r.AuthenticationError,21700:r.BadRequest,21705:r.BadRequest,21707:r.ExchangeError,21708:r.BadRequest,21601:r.AccountSuspended,21711:r.ExchangeError,21709:r.InsufficientFunds,25e4:r.ExchangeError,250001:r.BadRequest,250002:r.BadRequest,250003:r.BadRequest,250004:r.BadRequest,250005:r.InsufficientFunds,250008:r.BadRequest,250012:r.ExchangeError,21110:r.BadRequest,10040:r.BadSymbol,10060:r.ExchangeError,10020:r.BadSymbol,10041:r.BadSymbol,21340:r.OnMaintenance,21341:r.InvalidOrder,21342:r.InvalidOrder,21343:r.InvalidOrder,21351:r.AccountSuspended,21352:r.BadSymbol,21353:r.PermissionDenied,21354:r.PermissionDenied,21359:r.OrderNotFound,21360:r.InvalidOrder,24106:r.BadRequest,24201:r.ExchangeNotAvailable,21301:r.OrderNotFound,21302:r.ExchangeError,21304:r.ExchangeError,21305:r.OrderNotFound,21307:r.ExchangeError,21309:r.InvalidOrder,21310:r.InvalidOrder,21311:r.InvalidOrder,21312:r.InvalidOrder,21314:r.InvalidOrder,21315:r.InvalidOrder,21317:r.InvalidOrder,21319:r.InvalidOrder,21320:r.InvalidOrder,21321:r.InvalidOrder,21322:r.InvalidOrder,21324:r.BadRequest,21327:r.InvalidOrder,21328:r.InvalidOrder,21330:r.InvalidOrder,21335:r.InvalidOrder,21336:r.InvalidOrder,21337:r.InvalidOrder,21344:r.InvalidOrder,21345:r.InvalidOrder,21346:r.InvalidOrder,21348:r.InvalidOrder,21347:r.InvalidOrder,21349:r.InvalidOrder,21350:r.InvalidOrder,21355:r.ExchangeError,21356:r.BadRequest,21721:r.InsufficientFunds,24101:r.BadSymbol,24102:r.InvalidOrder,24103:r.InvalidOrder,24104:r.InvalidOrder,24105:r.InvalidOrder,25020:r.InvalidOrder,25e3:r.InvalidOrder,25001:r.InvalidOrder,25002:r.InvalidOrder,25003:r.ExchangeError,25004:r.InvalidOrder,25005:r.ExchangeError,25006:r.InvalidOrder,25007:r.InvalidOrder,25008:r.InvalidOrder,25009:r.ExchangeError,25010:r.PermissionDenied,25011:r.InvalidOrder,25012:r.ExchangeError,25013:r.OrderNotFound,25014:r.OrderNotFound,25015:r.OrderNotFound,25016:r.ExchangeError,25017:r.ExchangeError,25018:r.BadRequest,25019:r.BadSymbol},broad:{}}})}parseOHLCV(e,t=void 0){return[this.safeInteger(e,12),this.safeNumber(e,2),this.safeNumber(e,1),this.safeNumber(e,0),this.safeNumber(e,3),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();let a=!1;if([a,r]=this.handleOptionAndParams(r,"fetchOHLCV","paginate",!1),a)return await this.fetchPaginatedCallDeterministic("fetchOHLCV",e,s,i,t,r,500);const o=this.market(e);let n={symbol:o.id,interval:this.safeString(this.timeframes,t,t)};void 0!==s&&(n.startTime=s),void 0!==i&&(n.limit=i),[n,r]=this.handleUntilOption("endTime",n,r);const d=await this.publicGetMarketsSymbolCandles(this.extend(n,r));return this.parseOHLCVs(d,o,t,s,i)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);return(void 0===this.safeValue(this.options,"currenciesByNumericId")||e)&&(this.options.currenciesByNumericId=this.indexBy(this.currencies,"numericId")),s}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"baseCurrencyName"),i=this.safeString(e,"quoteCurrencyName"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o="NORMAL"===this.safeString(e,"state"),n=this.safeValue(e,"symbolTradeLimit");return{id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:o,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(n,"quantityScale"))),price:this.parseNumber(this.parsePrecision(this.safeString(n,"priceScale")))},limits:{amount:{min:this.safeNumber(n,"minQuantity"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(n,"minAmount"),max:void 0}},created:this.safeInteger(e,"tradableStartTime"),info:e}}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeInteger(e,"ts"),i=this.safeString(e,"symbol");t=this.safeMarket(i);const r=this.safeString(e,"close"),o=this.safeString(e,"dailyChange"),n=a.Y.stringMul(o,"100"),d=this.safeString(e,"bidQuantity"),h=this.safeString(e,"askQuantity");return this.safeTicker({id:i,symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:d,ask:this.safeString(e,"ask"),askVolume:h,vwap:void 0,open:this.safeString(e,"open"),close:r,last:r,previousClose:void 0,change:void 0,percentage:n,average:void 0,baseVolume:this.safeString(e,"quantity"),quoteVolume:this.safeString(e,"amount"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.publicGetMarketsTicker24h(t);return this.parseTickers(s,e)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(this.extend(e,{includeMultiChainCurrencies:!0})),s={};for(let e=0;e<t.length;e++){const i=this.safeValue(t,e),r=Object.keys(i),o=this.safeValue(r,0),n=this.safeValue(i,o),d=this.safeCurrencyCode(o),h=this.safeString(n,"name"),c=this.safeString(n,"blockchain");let l;void 0!==c&&(l=this.networkIdToCode(c,d));const u=this.safeValue(n,"delisted"),p="ENABLED"===this.safeString(n,"walletState"),f="ENABLED"===this.safeString(n,"walletDepositState"),m="ENABLED"===this.safeString(n,"walletWithdrawalState"),g=!u&&p&&f&&m,v=this.safeInteger(n,"id"),y=this.safeString(n,"withdrawalFee"),w=void 0===this.safeValue(n,"parentChain");void 0===this.safeValue(s,d)&&(s[d]={id:o,code:d,info:void 0,name:h,active:g,deposit:f,withdraw:m,fee:this.parseNumber(y),precision:void 0,limits:{amount:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}});let b=this.safeString(s[d],"fee");void 0!==y&&(b=void 0===b?y:a.Y.stringMin(y,b));let S=this.safeValue(s[d],"deposit");S=f||S;let k=this.safeValue(s[d],"withdraw");k=m||k;const O=this.safeValue(s[d],"networks",{});void 0!==l&&(O[l]={info:n,id:c,network:l,currencyId:o,numericId:v,deposit:f,withdraw:m,active:g,fee:this.parseNumber(y),precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}}}),s[d].networks=O;const T=this.safeValue(s[d],"info",[]),P={};P[o]=n,T.push(P),s[d].info=T,w&&(s[d].id=o,s[d].name=h),s[d].active=S&&k,s[d].deposit=S,s[d].withdraw=k,s[d].fee=this.parseNumber(b)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetMarketsSymbolTicker24h(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"id","tradeID"),i=this.safeString(e,"orderId"),r=this.safeInteger2(e,"ts","createTime"),a=this.safeString(e,"symbol"),o=(t=this.safeMarket(a,t,"_")).symbol,n=this.safeStringLower2(e,"side","takerSide");let d;const h=this.safeString(e,"price"),c=this.safeString(e,"quantity"),l=this.safeString(e,"amount"),u=this.safeString(e,"feeCurrency"),p=this.safeString(e,"feeAmount");if(void 0!==p){d={cost:p,currency:this.safeCurrencyCode(u)}}return this.safeTrade({id:s,info:e,timestamp:r,datetime:this.iso8601(r),symbol:o,order:i,type:this.safeStringLower(e,"type"),side:n,takerOrMaker:this.safeStringLower(e,"matchRole"),price:h,amount:c,cost:l,fee:d},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetMarketsSymbolTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a=!1;if([a,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),a)return await this.fetchPaginatedCallDynamic("fetchMyTrades",e,t,s,i);void 0!==e&&(r=this.market(e));let o={};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s),[o,i]=this.handleUntilOption("endTime",o,i);const n=await this.privateGetTrades(this.extend(o,i));return this.parseTrades(n,r,t,s)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",PENDING_CANCEL:"canceled",PARTIALLY_CANCELED:"canceled",CANCELED:"canceled",FAILED:"canceled"},e,e)}parseOrder(e,t=void 0){let s=this.safeInteger2(e,"timestamp","createTime");void 0===s&&(s=this.parse8601(this.safeString(e,"date")));const i=this.safeString(e,"symbol"),r=(t=this.safeMarket(i,t,"_")).symbol;let a=this.safeValue(e,"resultingTrades");void 0!==a&&(Array.isArray(a)||(a=this.safeValue(a,this.safeString(t,"id",i))));const o=this.safeString2(e,"price","rate"),n=this.safeString(e,"quantity"),d=this.safeString(e,"filledQuantity"),h=this.parseOrderStatus(this.safeString(e,"state")),c=this.safeStringLower(e,"side"),l=this.safeString(e,"type"),u=this.parseOrderType(l),p=this.safeStringN(e,["orderNumber","id","orderId"]);let f;const m=this.safeString(e,"tokenFeeCurrency");let g,v;const y=this.safeString(e,"fee");void 0===m?v="buy"===c?t.base:t.quote:(v=this.safeCurrencyCode(m),g=this.safeString(e,"tokenFee")),void 0!==g&&(f={rate:y,cost:g,currency:v});const w=this.safeString(e,"clientOrderId"),b=this.safeString2(e,"triggerPrice","stopPrice");return this.safeOrder({info:e,id:p,clientOrderId:w,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"updateTime"),status:h,symbol:r,type:u,timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:c,price:o,stopPrice:b,triggerPrice:b,cost:void 0,average:this.safeString(e,"avgPrice"),amount:n,filled:d,remaining:void 0,trades:a,fee:f},t)}parseOrderType(e){return this.safeString({MARKET:"market",LIMIT:"limit","STOP-LIMIT":"limit","STOP-MARKET":"market"},e,e)}parseOpenOrders(e,t,s){for(let i=0;i<e.length;i++){const r=e[i],a=this.extend(r,{status:"open",type:"limit",side:r.type,price:r.rate});s.push(this.parseOrder(a,t))}return s}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.symbol=r.id),void 0!==s&&(a.limit=s);const o=this.safeValue2(i,"trigger","stop");let n;i=this.omit(i,["trigger","stop"]),n=o?await this.privateGetSmartorders(this.extend(a,i)):await this.privateGetOrders(this.extend(a,i));return this.parseOrders(n,r,t,s,{status:"open"})}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);if(!n.spot)throw new r.NotSupported(this.id+" createOrder() does not support "+n.type+" orders, only spot orders are accepted");let d={symbol:n.id,side:s};const h=this.safeNumber2(o,"stopPrice","triggerPrice");let c;return[d,o]=this.orderRequest(e,t,s,i,d,a,o),c=void 0!==h?await this.privatePostSmartorders(this.extend(d,o)):await this.privatePostOrders(this.extend(d,o)),c=this.extend(c,{type:t,side:s}),this.parseOrder(c,n)}orderRequest(e,t,s,i,o,n=void 0,d={}){let h=t.toUpperCase();const c="MARKET"===h,l=this.isPostOnly(c,"LIMIT_MAKER"===h,d),u=this.safeNumber2(d,"stopPrice","triggerPrice");if(d=this.omit(d,["postOnly","triggerPrice","stopPrice"]),void 0!==u?(h=void 0===n?"STOP":"STOP_LIMIT",o.stopPrice=u):l&&(h="LIMIT_MAKER"),o.type=h,c)if("buy"===s){let t,s=!0;[s,d]=this.handleOptionAndParams(d,"createOrder","createMarketBuyOrderRequiresPrice",!0);const h=this.safeNumber(d,"cost");if(d=this.omit(d,"cost"),void 0!==h)t=this.costToPrecision(e,h);else if(s){if(void 0===n)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),r=this.numberToString(n),o=a.Y.stringMul(s,r);t=this.costToPrecision(e,o)}}else t=this.costToPrecision(e,i);o.amount=t}else o.quantity=this.amountToPrecision(e,i);else o.quantity=this.amountToPrecision(e,i),o.price=this.priceToPrecision(e,n);const p=this.safeString(d,"clientOrderId");return void 0!==p&&(o.clientOrderId=p,d=this.omit(d,"clientOrderId")),[o,d]}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t);if(!d.spot)throw new r.NotSupported(this.id+" editOrder() does not support "+d.type+" orders, only spot orders are accepted");let h={id:e};const c=this.safeNumber2(n,"stopPrice","triggerPrice");let l;return[h,n]=this.orderRequest(t,s,i,a,h,o,n),l=void 0!==c?await this.privatePutSmartordersId(this.extend(h,n)):await this.privatePutOrdersId(this.extend(h,n)),l=this.extend(l,{side:i,type:s}),this.parseOrder(l,d)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={},r=this.safeValue(s,"clientOrderId");void 0!==r&&(e=r),i.id=e;const a=this.safeValue2(s,"trigger","stop");let o;return s=this.omit(s,["clientOrderId","trigger","stop"]),o=a?await this.privateDeleteSmartordersId(this.extend(i,s)):await this.privateDeleteOrdersId(this.extend(i,s)),this.parseOrder(o)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={symbols:[]};let i;void 0!==e&&(i=this.market(e),s.symbols=[i.id]);const r=this.safeValue2(t,"trigger","stop");let a;return t=this.omit(t,["trigger","stop"]),a=r?await this.privateDeleteSmartorders(this.extend(s,t)):await this.privateDeleteOrders(this.extend(s,t)),this.parseOrders(a,i)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={id:e=e.toString()},r=this.safeValue2(s,"trigger","stop");let a;s=this.omit(s,["trigger","stop"]),r?(a=await this.privateGetSmartordersId(this.extend(i,s)),a=this.safeValue(a,0)):a=await this.privateGetOrdersId(this.extend(i,s));const o=this.parseOrder(a);return o.id=e,o}async fetchOrderStatus(e,t=void 0,s={}){await this.loadMarkets();const i=await this.fetchOpenOrders(t,void 0,void 0,s);return e in this.indexBy(i,"id")?"open":"closed"}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={id:e},o=await this.privateGetOrdersIdTrades(this.extend(a,r));return this.parseTrades(o)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=this.safeValue(e,s,{}),r=this.safeValue(i,"balances");for(let e=0;e<r.length;e++){const s=this.safeValue(r,e),i=this.safeString(s,"currency"),a=this.safeCurrencyCode(i),o=this.account();o.free=this.safeString(s,"available"),o.used=this.safeString(s,"hold"),t[a]=o}}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountsBalances(this.extend({accountType:"SPOT"},e));return this.parseBalance(t)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.privateGetFeeinfo(e),s={};for(let e=0;e<this.symbols.length;e++){const i=this.symbols[e];s[i]={info:t,symbol:i,maker:this.safeNumber(t,"makerRate"),taker:this.safeNumber(t,"takerRate"),percentage:!0,tierBased:!0}}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit=t);const a=await this.publicGetMarketsSymbolOrderBook(this.extend(r,s)),o=this.safeInteger(a,"time"),n=this.safeValue(a,"asks"),d=this.safeValue(a,"bids"),h=[],c=[];for(let e=0;e<n.length;e++)if(e%2<1){const t=this.safeNumber(n,e),s=this.safeNumber(n,this.sum(e,1));h.push([t,s])}for(let e=0;e<d.length;e++)if(e%2<1){const t=this.safeNumber(d,e),s=this.safeNumber(d,this.sum(e,1));c.push([t,s])}return{symbol:i.symbol,bids:this.sortBy(c,0,!0),asks:this.sortBy(h,0),timestamp:o,datetime:this.iso8601(o),nonce:void 0}}async createDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network");if(o=this.safeString(a,o,o),void 0!==o)i.currency+=o,t=this.omit(t,"network");else if("USDT"===s.id)throw new r.ArgumentsRequired(this.id+" createDepositAddress requires a network parameter for "+e+".");const n=await this.privatePostWalletsAddress(this.extend(i,t));let d,h=this.safeString(n,"address");if(this.checkAddress(h),void 0!==s){const e=this.safeString(s.info,"depositAddress");void 0!==e&&(d=h,h=e)}return{currency:e,address:h,tag:d,network:o,info:n}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network");if(o=this.safeString(a,o,o),void 0!==o)i.currency+=o,t=this.omit(t,"network");else if("USDT"===s.id)throw new r.ArgumentsRequired(this.id+" fetchDepositAddress requires a network parameter for "+e+".");const n=await this.privateGetWalletsAddresses(this.extend(i,t));let d,h=this.safeString(n,i.currency);if(this.checkAddress(h),void 0!==s){const e=this.safeString(s.info,"depositAddress");void 0!==e&&(d=h,h=e)}return{currency:e,address:h,tag:d,network:o,info:n}}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType",{}),n=this.safeString(o,s,s),d=this.safeString(o,i,s),h={amount:this.currencyToPrecision(e,t),currency:a.id,fromAccount:n,toAccount:d},c=await this.privatePostAccountsTransfer(this.extend(h,r));return this.parseTransfer(c,a)}parseTransfer(e,t=void 0){return{info:e,id:this.safeString(e,"transferId"),timestamp:void 0,datetime:void 0,currency:this.safeString(t,"id"),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e),o={currency:a.id,amount:t,address:s};void 0!==i&&(o.paymentId=i);const n=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeString(n,d,d),void 0!==d&&(o.currency+=d,r=this.omit(r,"network"));const h=await this.privatePostWalletsWithdraw(this.extend(o,r));return this.parseTransaction(h,a)}async fetchTransactionsHelper(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.seconds(),a={start:void 0!==t?this.parseToInt(t/1e3):r-31104e4,end:r};return await this.privateGetWalletsActivity(this.extend(a,i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.fetchTransactionsHelper(e,t,s,i);let a;void 0!==e&&(a=this.currency(e));const o=this.safeValue(r,"withdrawals",[]),n=this.safeValue(r,"deposits",[]),d=this.parseTransactions(o,a,t,s),h=this.parseTransactions(n,a,t,s),c=this.arrayConcat(h,d);return this.filterByCurrencySinceLimit(this.sortBy(c,"timestamp"),e,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchTransactionsHelper(e,t,s,i);let a;void 0!==e&&(a=this.currency(e));const o=this.safeValue(r,"withdrawals",[]),n=this.parseTransactions(o,a,t,s);return this.filterByCurrencySinceLimit(n,e,t,s)}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCurrencies(this.extend(t,{includeMultiChainCurrencies:!0})),i={};for(let e=0;e<s.length;e++){const t=s[e],r=Object.keys(t),a=this.safeString(r,0);i[a]=t[a]}return this.parseDepositWithdrawFees(i,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const r=Object.keys(e);for(let s=0;s<r.length;s++){const a=r[s],o=this.safeCurrencyCode(a),n=e[a];if(void 0===t||this.inArray(o,t)){const t=this.currency(o);i[o]=this.parseDepositWithdrawFee(n,t);const s=this.safeValue(n,"childChains");if(s.length>0)for(let t=0;t<s.length;t++){let r=s[t];r=r.replace(o,"");const a=this.networkIdToCode(r),n=this.safeValue(e,r),d={},h=this.safeNumber(n,"withdrawalFee");d[a]={withdraw:{fee:h,percentage:void 0===h&&void 0},deposit:{fee:void 0,percentage:void 0}},i[o].networks=this.extend(i[o].networks,d)}}}return i}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee({});s.info[t.code]=e;const i=this.safeString(e,"blockchain"),r=this.safeNumber(e,"withdrawalFee"),a={fee:r,percentage:void 0===r&&void 0},o={fee:void 0,percentage:void 0};s.withdraw=a,s.deposit=o;const n=this.networkIdToCode(i);return s.networks[n]={withdraw:a,deposit:o},s}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchTransactionsHelper(e,t,s,i);let a;void 0!==e&&(a=this.currency(e));const o=this.safeValue(r,"deposits",[]),n=this.parseTransactions(o,a,t,s);return this.filterByCurrencySinceLimit(n,e,t,s)}parseTransactionStatus(e){return this.safeString({COMPLETE:"ok",COMPLETED:"ok","AWAITING APPROVAL":"pending",AWAITING_APPROVAL:"pending",PENDING:"pending",PROCESSING:"pending","COMPLETE ERROR":"failed",COMPLETE_ERROR:"failed"},e,e)}parseTransaction(e,t=void 0){const s=this.safeTimestamp(e,"timestamp"),i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i);let o=this.safeString(e,"status","pending");o=this.parseTransactionStatus(o);const n=this.safeString(e,"txid"),d="withdrawalRequestsId"in e?"withdrawal":"deposit",h=this.safeString2(e,"withdrawalRequestsId","depositNumber"),c=this.safeString(e,"address"),l=this.safeString(e,"paymentID");let u=this.safeString(e,"amount");const p=this.safeString(e,"fee");return"withdrawal"===d&&(u=a.Y.stringSub(u,p)),{info:e,id:h,currency:r,amount:this.parseNumber(u),network:void 0,address:c,addressTo:void 0,addressFrom:void 0,tag:l,tagTo:void 0,tagFrom:void 0,status:o,type:d,updated:void 0,txid:n,timestamp:s,datetime:this.iso8601(s),comment:void 0,internal:void 0,fee:{currency:r,cost:this.parseNumber(p),rate:void 0}}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest;const d=this.omit(i,this.extractParams(e)),h=this.implodeParams(e,i);if("public"===t)o+="/"+h,Object.keys(d).length&&(o+="?"+this.urlencode(d));else{this.checkRequiredCredentials();const e=this.nonce().toString();let t=s+"\n";if(o+="/"+h,t+="/"+h,"POST"===s||"PUT"===s||"DELETE"===s)t+="\n",Object.keys(d).length&&(t+="requestBody="+(a=this.json(d))+"&"),t+="signTimestamp="+e;else{let s=this.extend({signTimestamp:e},d);s=this.keysort(s),t+="\n"+this.urlencode(s),Object.keys(d).length&&(o+="?"+this.urlencode(d))}const i=this.hmac(this.encode(t),this.encode(this.secret),n.s,"base64");r={"Content-Type":"application/json",key:this.apiKey,signTimestamp:e,signature:i}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code");if(void 0!==c&&"200"!==c){const e=n.code,t=this.safeString(n,"message"),s=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,s),this.throwBroadlyMatchedException(this.exceptions.broad,t,s),new r.ExchangeError(s)}}}},6826:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5147),r=s(4025),a=s(1579),o=s(2079),n=s(4852);class d extends r.A{describe(){return this.deepExtend(super.describe(),{id:"poloniexfutures",name:"Poloniex Futures",countries:["US"],rateLimit:33.3,certified:!1,pro:!0,version:"v1",has:{CORS:void 0,spot:!1,margin:!0,swap:!0,future:!1,option:void 0,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchCurrencies:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchL3OrderBook:!0,fetchMarkets:!0,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrdersByStatus:!0,fetchPositions:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,setMarginMode:!0},timeframes:{"1m":1,"5m":5,"15m":15,"30m":30,"1h":60,"2h":120,"4h":480,"12h":720,"1d":1440,"1w":10080},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",api:{public:"https://futures-api.poloniex.com",private:"https://futures-api.poloniex.com"},www:"https://www.poloniex.com",doc:"https://api-docs.poloniex.com/futures/",fees:"https://poloniex.com/fee-schedule",referral:"https://poloniex.com/signup?c=UBFZJRPJ"},api:{public:{get:{"contracts/active":10,"contracts/{symbol}":10,ticker:10,tickers:10,"level2/snapshot":180.002,"level2/depth":180.002,"level2/message/query":180.002,"level3/snapshot":180.002,"trade/history":10,"interest/query":10,"index/query":10,"mark-price/{symbol}/current":10,"premium/query":10,"funding-rate/{symbol}/current":10,timestamp:10,status:10,"kline/query":10},post:{"bullet-public":10}},private:{get:{"account-overview":1,"transaction-history":1,maxActiveOrders:1,maxRiskLimit:1,userFeeRate:1,"marginType/query":1,orders:1,stopOrders:1,recentDoneOrders:1,"orders/{order-id}":1,"clientOrderId/{clientOid}":1,fills:1,openOrderStatistics:1,position:1.5,positions:1.5,"funding-history":1},post:{orders:1.5,batchOrders:1.5,"position/margin/auto-deposit-status":1.5,"position/margin/deposit-margin":1.5,"position/margin/withdraw-margin":1.5,"bullet-private":1,"marginType/change":1},delete:{"orders/{order-id}":1.5,orders:150.016,stopOrders:150.016}}},precisionMode:a.kb,fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.00075"),maker:this.parseNumber("0.0001")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},commonCurrencies:{},requiredCredentials:{apiKey:!0,secret:!0,password:!0},options:{networks:{OMNI:"omni",ERC20:"eth",TRC20:"trx"},versions:{public:{GET:{ticker:"v2",tickers:"v2","level3/snapshot":"v2"}}}},exceptions:{exact:{400:o.BadRequest,401:o.AuthenticationError,403:o.NotSupported,404:o.NotSupported,405:o.NotSupported,415:o.BadRequest,429:o.RateLimitExceeded,500:o.ExchangeNotAvailable,503:o.ExchangeNotAvailable,400001:o.AuthenticationError,400002:o.InvalidNonce,400003:o.AuthenticationError,400004:o.AuthenticationError,400005:o.AuthenticationError,400006:o.AuthenticationError,400007:o.AuthenticationError,404e3:o.NotSupported,400100:o.BadRequest,411100:o.AccountSuspended,5e5:o.ExchangeNotAvailable},broad:{"Position does not exist":o.OrderNotFound}}})}async fetchMarkets(e={}){const t=await this.publicGetContractsActive(e),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"baseCurrency"),r=this.safeString(e,"quoteCurrency"),a=this.safeString(e,"rootSymbol"),o=this.safeCurrencyCode(s),n=this.safeCurrencyCode(r),d=this.safeCurrencyCode(a),h=o+"/"+n+":"+d,c=this.safeValue(e,"isInverse"),l=this.safeString(e,"status"),u=this.safeString(e,"multiplier"),p=this.safeNumber(e,"indexPriceTickSize"),f=this.safeNumber(e,"lotSize"),m=this.safeNumber(e,"maxOrderQty"),g=this.safeNumber(e,"maxPrice");return{id:t,symbol:h,base:o,quote:n,settle:d,baseId:s,quoteId:r,settleId:a,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:"Open"===l,contract:!0,linear:!c,inverse:c,taker:this.safeNumber(e,"takerFeeRate"),maker:this.safeNumber(e,"makerFeeRate"),contractSize:this.parseNumber(i.Y.stringAbs(u)),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:f,price:p},limits:{leverage:{min:this.parseNumber("1"),max:this.safeNumber(e,"maxLeverage")},amount:{min:f,max:m},price:{min:p,max:g},cost:{min:void 0,max:void 0}},created:this.safeInteger(e,"firstOpenDate"),info:e}}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),r=this.safeSymbol(s,t),a=this.safeString(e,"ts");let o;o=16===a.length?.001:17===a.length?1e-4:18===a.length?1e-5:1e-6;const n=this.safeIntegerProduct(e,"ts",o),d=this.safeString2(e,"price","lastPrice"),h=i.Y.stringMul(this.safeString(e,"priceChgPct"),"100");return this.safeTicker({symbol:r,timestamp:n,datetime:this.iso8601(n),high:void 0,low:void 0,bid:this.safeString(e,"bestBidPrice"),bidVolume:this.safeString(e,"bestBidSize"),ask:this.safeString(e,"bestAskPrice"),askVolume:this.safeString(e,"bestAskSize"),vwap:void 0,open:void 0,close:d,last:d,previousClose:void 0,change:void 0,percentage:h,average:void 0,baseVolume:this.safeString2(e,"size","volume"),quoteVolume:this.safeString(e,"turnover"),info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTicker(this.extend(i,t));return this.parseTicker(this.safeValue(r,"data",{}),s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers(t),i=this.safeList(s,"data",[]);return this.parseTickers(i,e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeNumber(s,"level");if(s=this.omit(s,"level"),void 0!==i&&2!==i&&3!==i)throw new o.BadRequest(this.id+" fetchOrderBook() can only return level 2 & 3");const r=this.market(e),a={symbol:r.id};let n;n=3===i?await this.publicGetLevel3Snapshot(this.extend(a,s)):await this.publicGetLevel2Snapshot(this.extend(a,s));const d=this.safeValue(n,"data",{}),h=this.safeIntegerProduct(d,"ts",1e-6);let c;return c=3===i?this.parseOrderBook(d,r.symbol,h,"bids","asks",1,2):this.parseOrderBook(d,r.symbol,h,"bids","asks",0,1),c.nonce=this.safeInteger(d,"sequence"),c}async fetchL3OrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);return this.fetchOrderBook(i.id,void 0,{level:3})}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"-");const i=this.safeString(e,"tradeId"),r=this.safeString(e,"orderId"),a=this.safeString(e,"liquidity");let o=this.safeInteger(e,"ts");void 0!==o?o=this.parseToInt(o/1e6):(o=this.safeInteger(e,"createdAt"),"dealValue"in e&&void 0!==o&&(o*=1e3));const n=this.safeString(e,"price"),d=this.safeString(e,"size"),h=this.safeString(e,"side");let c;const l=this.safeString(e,"fee");if(void 0!==l){const s=this.safeString(e,"feeCurrency");let i=this.safeCurrencyCode(s);void 0===i&&(i="sell"===h?t.quote:t.base),c={cost:l,currency:i,rate:this.safeString(e,"feeRate")}}let u=this.safeString(e,"orderType");"match"===u&&(u=void 0);const p=this.safeString(e,"value");return this.safeTrade({info:e,id:i,order:r,timestamp:o,datetime:this.iso8601(o),symbol:t.symbol,type:u,takerOrMaker:a,side:h,price:n,amount:d,cost:p,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id},o=await this.publicGetTradeHistory(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}async fetchTime(e={}){const t=await this.publicGetTimestamp(e);return this.safeInteger(t,"data")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=a.id,n=this.safeInteger(this.timeframes,t),d={symbol:o};d.granularity=void 0!==n?n:t;const h=1e3*this.parseTimeframe(t);let c=this.milliseconds();void 0!==s?(d.from=s,void 0===i&&(i=this.safeInteger(this.options,"fetchOHLCVLimit",200)),c=this.sum(s,i*h),d.to=c):void 0!==i&&(s=c-i*h,d.from=s);const l=await this.publicGetKlineQuery(this.extend(d,r)),u=this.safeList(l,"data",[]);return this.parseOHLCVs(u,a,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data"),i=this.safeString(s,"currency"),r=this.safeCurrencyCode(i),a=this.account();return a.free=this.safeString(s,"availableBalance"),a.total=this.safeString(s,"accountEquity"),t[r]=a,this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"currency");let s={};if(void 0!==t){s={currency:this.currency(t).id}}const i=await this.privateGetAccountOverview(this.extend(s,e));return this.parseBalance(i)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const n=this.market(e),d=this.safeString2(a,"clientOid","clientOrderId",this.uuid());if(a=this.omit(a,["clientOid","clientOrderId"]),i<1)throw new o.InvalidOrder(this.id+" createOrder() minimum contract order amount is 1");const h=parseInt(this.amountToPrecision(e,i)),c={clientOid:d,side:s,symbol:n.id,type:t,size:h,leverage:1},l=this.safeValue2(a,"triggerPrice","stopPrice");if(l){c.stop="buy"===s?"up":"down";const t=this.safeString(a,"stopPriceType","TP");c.stopPriceType=t,c.stopPrice=this.priceToPrecision(e,l)}const u=this.safeStringUpper(a,"timeInForce");if("limit"===t){if(void 0===r)throw new o.ArgumentsRequired(this.id+" createOrder() requires a price argument for limit orders");c.price=this.priceToPrecision(e,r),void 0!==u&&(c.timeInForce=u)}const p=this.safeBool(a,"postOnly",!1),f=this.safeValue(a,"hidden");if(p&&void 0!==f)throw new o.BadRequest(this.id+" createOrder() does not support the postOnly parameter together with a hidden parameter");if(this.safeValue(a,"iceberg")){if(void 0===this.safeValue(a,"visibleSize"))throw new o.ArgumentsRequired(this.id+" createOrder() requires a visibleSize parameter for iceberg orders")}a=this.omit(a,["timeInForce","stopPrice","triggerPrice"]);const m=await this.privatePostOrders(this.extend(c,a)),g=this.safeValue(m,"data",{});return this.safeOrder({id:this.safeString(g,"orderId"),clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:m},n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={"order-id":e},r=await this.privateDeleteOrdersOrderId(this.extend(i,s)),a=this.safeValue(r,"data");if(0===this.safeValue(a,"cancelledOrderIds").length)throw new o.InvalidOrder(this.id+" cancelOrder() order already cancelled");return this.parseOrder(a)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetPositions(t),i=this.safeList(s,"data");return this.parsePositions(i,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const r=this.safeInteger(e,"currentTimestamp"),a=this.safeString(e,"currentQty");let o;i.Y.stringGt(a,"0")?o="long":i.Y.stringLt(a,"0")&&(o="short");const n=i.Y.stringAbs(this.safeString(e,"posCost")),d=this.safeString(e,"posInit"),h=i.Y.stringDiv(d,n),c=this.safeString(e,"unrealisedPnl"),l=this.safeValue(e,"crossMode")?"cross":"isolated";return{info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:r,datetime:this.iso8601(r),initialMargin:this.parseNumber(d),initialMarginPercentage:this.parseNumber(h),maintenanceMargin:this.safeNumber(e,"posMaint"),maintenanceMarginPercentage:this.safeNumber(e,"maintMarginReq"),entryPrice:this.safeNumber(e,"avgEntryPrice"),notional:this.parseNumber(n),leverage:this.safeNumber(e,"realLeverage"),unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(i.Y.stringAbs(a)),contractSize:this.safeValue(t,"contractSize"),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"liquidationPrice"),markPrice:this.safeNumber(e,"markPrice"),collateral:this.safeNumber(e,"maintMargin"),marginMode:l,side:o,percentage:this.parseNumber(i.Y.stringDiv(c,d)),stopLossPrice:void 0,takeProfitPrice:void 0}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchFundingHistory() requires a symbol argument");await this.loadMarkets();const r={symbol:this.market(e).id};void 0!==t&&(r.startAt=t),void 0!==s&&(r.maxCount=s);const a=await this.privateGetFundingHistory(this.extend(r,i)),n=this.safeValue(a,"data"),d=this.safeValue(n,"dataList",[]),h=d.length,c=[];for(let t=0;t<h;t++){const s=d[t],i=this.safeInteger(s,"timePoint");c.push({info:s,symbol:e,code:this.safeCurrencyCode(this.safeString(s,"settleCurrency")),timestamp:i,datetime:this.iso8601(i),id:this.safeNumber(s,"id"),amount:this.safeNumber(s,"funding"),fundingRate:this.safeNumber(s,"fundingRate"),markPrice:this.safeNumber(s,"markPrice"),positionQty:this.safeNumber(s,"positionQty"),positionCost:this.safeNumber(s,"positionCost")})}return c}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};void 0!==e&&(s.symbol=this.marketId(e));const i=this.safeValue2(t,"stop","trigger");let r;t=this.omit(t,["stop","trigger"]),r=i?await this.privateDeleteStopOrders(this.extend(s,t)):await this.privateDeleteOrders(this.extend(s,t));const a=this.safeValue(r,"data"),o=[],n=this.safeValue(a,"cancelledOrderIds"),d=n.length;for(let e=0;e<d;e++){const t=this.safeString(n,e);o.push(this.safeOrder({id:t,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:void 0,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0,timeInForce:void 0,postOnly:void 0,stopPrice:void 0,info:r}))}return o}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.safeValue2(r,"stop","trigger"),n=this.safeInteger(r,"until");r=this.omit(r,["trigger","stop","until"]),"closed"===e&&(e="done");const d={};if(a){if("open"!==e)throw new o.BadRequest(this.id+" fetchOrdersByStatus() can only fetch untriggered stop orders")}else d.status="open"===e?"active":"done";let h,c;void 0!==t&&(h=this.market(t),d.symbol=h.id),void 0!==s&&(d.startAt=s),void 0!==n&&(d.endAt=n),c=a?await this.privateGetStopOrders(this.extend(d,r)):await this.privateGetOrders(this.extend(d,r));const l=this.safeValue(c,"data",{}),u=this.safeValue(l,"items",[]),p=u.length,f=[];for(let t=0;t<p;t++){const s=u[t];e===this.safeString(s,"status")&&f.push(u[t])}return this.parseOrders(f,h,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchOrder(e=void 0,t=void 0,s={}){await this.loadMarkets();const i={};let r;if(void 0===e){const e=this.safeString2(s,"clientOid","clientOrderId");if(void 0===e)throw new o.InvalidOrder(this.id+" fetchOrder() requires parameter id or params.clientOid");i.clientOid=e,s=this.omit(s,["clientOid","clientOrderId"]),r=await this.privateGetClientOrderIdClientOid(this.extend(i,s))}else i["order-id"]=e,r=await this.privateGetOrdersOrderId(this.extend(i,s));const a=void 0!==t?this.market(t):void 0,n=this.safeDict(r,"data");return this.parseOrder(n,a)}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const r=this.safeInteger(e,"createdAt"),a=this.safeString(e,"feeCurrency"),o=this.safeString(e,"dealSize"),n=this.safeString2(e,"dealFunds","filledValue");let d;if(i.Y.stringGt(o,"0")){const e=this.safeString(t,"contractSize");d=t.linear?i.Y.stringDiv(n,i.Y.stringMul(e,o)):i.Y.stringDiv(i.Y.stringMul(e,o),n)}const h=this.safeBool(e,"isActive",!1),c=this.safeBool(e,"cancelExist",!1),l=h?"open":"closed";let u=this.safeString(e,"id");if("cancelledOrderIds"in e){const t=this.safeValue(e,"cancelledOrderIds");u=this.safeString(t,0)}return this.safeOrder({info:e,id:u,clientOrderId:this.safeString(e,"clientOid"),symbol:this.safeString(t,"symbol"),type:this.safeString(e,"type"),timeInForce:this.safeString(e,"timeInForce"),postOnly:this.safeValue(e,"postOnly"),side:this.safeString(e,"side"),amount:this.safeString(e,"size"),price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stopPrice"),cost:this.safeString(e,"dealValue"),filled:o,remaining:void 0,timestamp:r,datetime:this.iso8601(r),fee:{currency:this.safeCurrencyCode(a),cost:this.safeString(e,"fee")},status:c?"canceled":l,lastTradeTimestamp:void 0,average:d,trades:void 0},t)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetFundingRateSymbolCurrent(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeInteger(a,"timePoint");return{info:a,symbol:s.symbol,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(a,"predictedValue"),fundingTimestamp:void 0,fundingDatetime:void 0,nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(a,"value"),previousFundingTimestamp:o,previousFundingDatetime:this.iso8601(o)}}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==t&&(r.startAt=t);const o=await this.privateGetFills(this.extend(r,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"items",[]);return this.parseTrades(d,a,t,s)}async setMarginMode(e,t=void 0,s={}){if(void 0===t)throw new o.ArgumentsRequired(this.id+" setMarginMode() requires a symbol argument");if("0"!==e&&"1"!==e&&"isolated"!==e&&"cross"!==e)throw new o.ArgumentsRequired(this.id+" setMarginMode() marginMode must be 0/isolated or 1/cross");await this.loadMarkets(),"isolated"===e&&(e="0"),"cross"===e&&(e="1");const i={symbol:this.market(t).id,marginType:this.parseToInt(e)};return await this.privatePostMarginTypeChange(i)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t];const d=this.safeValue(this.options,"versions",{}),h=this.safeValue(d,t,{}),c=this.safeValue(h,s,{}),l=this.safeString(c,e,this.version);o+="/api/"+this.safeString(i,"version",l)+"/"+this.implodeParams(e,i);const u=this.omit(i,this.extractParams(e)),p=Object.keys(u).length;if("public"===t)p&&(o+="?"+this.urlencode(u));else{this.checkRequiredCredentials();let t="/api/v1/"+this.implodeParams(e,i);const d=this.urlencode(u);"GET"!==s&&"HEAD"!==s?a=u:p&&""!==d&&(o+="?"+d,t+="?"+d);const h=this.milliseconds().toString();let c="";void 0!==a&&(c=a=this.json(u));const l=h+s+t+c;(r={"PF-API-SIGN":this.hmac(this.encode(l),this.encode(this.secret),n.s,"base64"),"PF-API-TIMESTAMP":h,"PF-API-KEY":this.apiKey,"PF-API-PASSPHRASE":this.password})["Content-Type"]="application/json"}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(!o)return void this.throwBroadlyMatchedException(this.exceptions.broad,a,a);const h=this.safeString(o,"code"),c=this.safeString(o,"msg",""),l=this.id+" "+c;this.throwExactlyMatchedException(this.exceptions.exact,c,l),this.throwExactlyMatchedException(this.exceptions.exact,h,l),this.throwBroadlyMatchedException(this.exceptions.broad,a,l)}}},6810:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(7930),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchPosition:!1},urls:{api:{ws:{crypto:"wss://stream.data.alpaca.markets/v1beta2/crypto",trading:"wss://api.alpaca.markets/stream"}},test:{ws:{crypto:"wss://stream.data.alpaca.markets/v1beta2/crypto",trading:"wss://paper-api.alpaca.markets/stream"}}},options:{},streaming:{},exceptions:{ws:{exact:{}}}})}async watchTicker(e,t={}){const s=this.urls.api.ws.crypto;await this.authenticate(s),await this.loadMarkets();const i=this.market(e),r="ticker:"+i.symbol,a={action:"subscribe",quotes:[i.id]};return await this.watch(s,r,this.extend(a,t),r)}handleTicker(e,t){const s=this.parseTicker(t),i=s.symbol,r="ticker:"+i;this.tickers[i]=s,e.resolve(this.tickers[i],r)}parseTicker(e,t=void 0){const s=this.safeString(e,"S"),i=this.safeString(e,"t");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:this.parse8601(i),datetime:i,high:void 0,low:void 0,bid:this.safeString(e,"bp"),bidVolume:this.safeString(e,"bs"),ask:this.safeString(e,"ap"),askVolume:this.safeString(e,"as"),vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){const a=this.urls.api.ws.crypto;await this.authenticate(a),await this.loadMarkets();const o=this.market(e);e=o.symbol;const n={action:"subscribe",bars:[o.id]},d="ohlcv:"+e,h=await this.watch(a,d,this.extend(n,r),d);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s);let r=this.safeValue(this.ohlcvs,i);if(void 0===r){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);r=new a.TG(e),this.ohlcvs[i]=r}const o=this.parseOHLCV(t);r.append(o);const n="ohlcv:"+i;e.resolve(r,n)}async watchOrderBook(e,t=void 0,s={}){const i=this.urls.api.ws.crypto;await this.authenticate(i),await this.loadMarkets();const r=this.market(e),a="orderbook:"+(e=r.symbol),o={action:"subscribe",orderbooks:[r.id]};return(await this.watch(i,a,this.extend(o,s),a)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s),r=this.safeString(t,"t"),a=this.parse8601(r),o=this.safeBool(t,"r",!1);i in this.orderbooks||(this.orderbooks[i]=this.orderBook());const n=this.orderbooks[i];if(o){const e=this.parseOrderBook(t,i,a,"b","a","p","s");n.reset(e)}else{const e=this.safeList(t,"a",[]),s=this.safeList(t,"b",[]);this.handleDeltas(n.asks,e),this.handleDeltas(n.bids,s),n.timestamp=a,n.datetime=r}const d="orderbook:"+i;this.orderbooks[i]=n,e.resolve(n,d)}handleDelta(e,t){const s=this.parseBidAsk(t,"p","s");e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){const r=this.urls.api.ws.crypto;await this.authenticate(r),await this.loadMarkets();const a=this.market(e),o="trade:"+(e=a.symbol),n={action:"subscribe",trades:[a.id]},d=await this.watch(r,o,this.extend(n,i),o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"S"),i=this.safeSymbol(s);let r=this.safeValue(this.trades,i);if(void 0===r){const e=this.safeInteger(this.options,"tradesLimit",1e3);r=new a.I3(e),this.trades[i]=r}const o=this.parseTrade(t);r.append(o);const n="trade:"+i;e.resolve(r,n)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){const r=this.urls.api.ws.trading;await this.authenticate(r);let a="myTrades";await this.loadMarkets(),void 0!==e&&(a+=":"+(e=this.symbol(e)));const o=await this.watch(r,a,this.extend({action:"listen",data:{streams:["trade_updates"]}},i),a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const r=this.urls.api.ws.trading;await this.authenticate(r),await this.loadMarkets();let a="orders";if(void 0!==e){a="orders:"+(e=this.market(e).symbol)}const o=await this.watch(r,a,this.extend({action:"listen",data:{streams:["trade_updates"]}},i),a);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleTradeUpdate(e,t){this.handleOrder(e,t),this.handleMyTrade(e,t)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"order",{});if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const r=this.orders,o=this.parseOrder(i);r.append(o);let n="orders";e.resolve(r,n),n="orders:"+o.symbol,e.resolve(r,n)}handleMyTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"event");if("fill"!==i&&"partial_fill"!==i)return;const r=this.safeValue(s,"order",{});let o=this.myTrades;if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.Pt(e)}const n=this.parseMyTrade(r);o.append(n);let d="myTrades:"+n.symbol;e.resolve(o,d),d="myTrades",e.resolve(o,d)}parseMyTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"filled_at");let r=this.safeString(e,"type");return r.indexOf("limit")>=0&&(r="limit"),this.safeTrade({id:this.safeString(e,"i"),info:e,timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,void 0,"/"),order:this.safeString(e,"id"),type:r,side:this.safeString(e,"side"),takerOrMaker:"market"===r?"taker":"maker",price:this.safeString(e,"filled_avg_price"),amount:this.safeString(e,"filled_qty"),cost:void 0,fee:void 0},t)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e),r=i.future(s);if(void 0===this.safeValue(i.subscriptions,s)){let t={action:"auth",key:this.apiKey,secret:this.secret};e===this.urls.api.ws.trading&&(t={action:"authenticate",data:{key_id:this.apiKey,secret_key:this.secret}}),this.watch(e,s,t,s,r)}return await r}handleErrorMessage(e,t){const s=this.safeString(t,"code"),i=this.safeValue(t,"msg",{});throw new r.ExchangeError(this.id+" code: "+s+" message: "+i)}handleConnected(e,t){return t}handleCryptoMessage(e,t){for(let s=0;s<t.length;s++){const i=t[s],r=this.safeString(i,"T"),a=this.safeString(i,"msg");if("subscription"===r)return void this.handleSubscription(e,i);if("success"===r&&"connected"===a)return void this.handleConnected(e,i);if("success"===r&&"authenticated"===a)return void this.handleAuthenticate(e,i);const o={error:this.handleErrorMessage,b:this.handleOHLCV,q:this.handleTicker,t:this.handleTrades,o:this.handleOrderBook},n=this.safeValue(o,r);void 0!==n&&n.call(this,e,i)}}handleTradingMessage(e,t){const s=this.safeString(t,"stream"),i={authorization:this.handleAuthenticate,listening:this.handleSubscription,trade_updates:this.handleTradeUpdate},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}handleMessage(e,t){Array.isArray(t)?this.handleCryptoMessage(e,t):this.handleTradingMessage(e,t)}handleAuthenticate(e,t){const s=this.safeString(t,"T"),i=this.safeValue(t,"data",{}),a=this.safeString(i,"status");if("success"!==s&&"authorized"!==a)throw new r.AuthenticationError(this.id+" failed to authenticate.");e.futures.authenticated.resolve(t)}handleSubscription(e,t){return t}}},1657:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(1411),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTrades:!0,watchTradesForSymbols:!0},urls:{api:{ws:{public:"wss://ascendex.com:443/api/pro/v2/stream",private:"wss://ascendex.com:443/{accountGroup}/api/pro/v2/stream"}},test:{ws:{public:"wss://api-test.ascendex-sandbox.com:443/api/pro/v2/stream",private:"wss://api-test.ascendex-sandbox.com:443/{accountGroup}/api/pro/v2/stream"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,categoriesAccount:{cash:"spot",futures:"swap",margin:"margin"}}})}async watchPublic(e,t={}){const s=this.urls.api.ws.public,i={id:this.nonce().toString(),op:"sub"},r=this.extend(i,t);return await this.watch(s,e,r,e)}async watchPublicMultiple(e,t={}){const s=this.urls.api.ws.public,i={id:this.nonce().toString(),op:"sub"},r=this.extend(i,t);return await this.watchMultiple(s,e,r,e)}async watchPrivate(e,t,s={}){await this.loadAccounts();const i=this.safeString(this.options,"account-group");let r=this.urls.api.ws.private;r=this.implodeParams(r,{accountGroup:i});const a={id:this.nonce().toString(),op:"sub",ch:e},o=this.extend(a,s);return await this.authenticate(r,s),await this.watch(r,t,o,e)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol,(void 0===i||i>1440)&&(i=100);const o="bar:"+this.safeString(this.timeframes,t,t)+":"+a.id;r={ch:o};const n=await this.watchPublic(o,r);return this.newUpdates&&(i=n.getLimit(e,i)),this.filterBySinceLimit(n,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"s"),i=this.safeSymbol(s),r=this.safeString(t,"m"),o=this.safeValue(t,"data",{}),n=this.safeString(o,"i"),d=r+":"+n+":"+s,h=this.findTimeframe(n),c=this.market(i),l=this.parseOHLCV(t,c);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let u=this.safeValue(this.ohlcvs[i],h);if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new a.TG(e),this.ohlcvs[i][h]=u}return u.append(l),e.resolve(u,d),t}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[],a=[];if(void 0!==(e=this.marketSymbols(e,void 0,!1,!0,!0)))for(let t=0;t<e.length;t++){const s=this.market(e[t]);r.push(s.id),a.push("trades:"+s.id)}const o="trades:"+r.join(",");i=this.extend(i,{ch:o});const n=await this.watchPublicMultiple(a,i);if(this.newUpdates){const e=this.safeValue(n,0),t=this.safeString(e,"symbol");s=n.getLimit(t,s)}return this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+s,o=this.market(i);let n=this.safeValue(t,"data");void 0===n&&(n=[]);const d=this.parseTrades(n,o);let h=this.safeValue(this.trades,i);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e)}for(let e=0;e<d.length;e++)h.append(d[e]);this.trades[i]=h,e.resolve(h,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="depth:"+this.market(e).id;s=this.extend(s,{ch:i});return(await this.watchPublic(i,s)).limit()}async watchOrderBookSnapshot(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="depth-snapshot",a=r+":"+i.id;s=this.extend(s,{action:r,args:{symbol:i.id},op:"req"});return(await this.watchPublic(a,s)).limit()}async fetchOrderBookSnapshot(e,t=void 0,s={}){const i=await this.fetchRestOrderBookSafe(e,t,s);e in this.orderbooks||(this.orderbooks[e]=this.orderBook());const r=this.orderbooks[e];return r.reset(i),r}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeString(t,"m")+":"+i,a=this.orderbooks[i],o=this.safeValue(t,"data"),n=this.parseOrderBook(o,i);n.nonce=this.safeInteger(o,"seqnum"),a.reset(n);const d=a.cache;for(let t=0;t<d.length;t++){const s=d[t];this.handleOrderBookMessage(e,s,a)}this.orderbooks[i]=a,e.resolve(a,r)}handleOrderBook(e,t){const s=this.safeString(t,"m"),i=this.safeString(t,"symbol"),r=this.safeSymbol(i),a=s+":"+i;r in this.orderbooks||(this.orderbooks[r]=this.orderBook({}));const o=this.orderbooks[r];void 0===o.nonce?o.cache.push(t):(this.handleOrderBookMessage(e,t,o),e.resolve(o,a))}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"data",{}),r=this.safeInteger(i,"seqnum");if(r>s.nonce){const e=this.safeValue(i,"asks",[]),t=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,e),this.handleDeltas(s.bids,t),s.nonce=r;const a=this.safeInteger(i,"ts");s.timestamp=a,s.datetime=this.iso8601(a)}return s}async watchBalance(e={}){await this.loadMarkets();const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let i,r;if("spot"===t||"margin"===t){const e=this.safeValue(this.options,"accountCategories",{});let s=this.safeString(e,t,"cash");s=s.toUpperCase(),i="order:"+s,r="balance:"+t}else i="futures-account-update",r="balance:swap";return await this.watchPrivate(i,r,s)}handleBalance(e,t){const s=this.safeString(t,"m");let i,r;if("order"===s||"futures-order"===s){const e=this.safeValue(t,"data"),s=this.safeString(e,"s"),a=this.safeMarket(s),o=this.account();o.free=this.safeString(e,"bab"),o.total=this.safeString(e,"btb");const n=this.account();n.free=this.safeString(e,"qab"),n.total=this.safeString(e,"qtb"),a.contract?(r="swap",i=this.safeValue(this.balance,r,{})):(r=a.type,i=this.safeValue(this.balance,r,{})),i[a.base]=o,i[a.quote]=n}else{const e=this.safeStringLower2(t,"ac","at"),s=this.safeValue(this.options,"categoriesAccount");r=this.safeString(s,e,"spot"),i=this.safeValue(this.balance,r,{});const a=this.safeValue(t,"data");let o;o=void 0===a?this.safeValue(t,"col"):[a];for(let e=0;e<o.length;e++){const t=o[e],s=this.safeCurrencyCode(this.safeString(t,"a")),r=this.account();r.free=this.safeString(t,"ab"),r.total=this.safeString2(t,"tb","b"),i[s]=r}}const a="balance:"+r;e.resolve(this.safeBalance(i),a)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol);const[a,o]=this.handleMarketTypeAndParams("watchOrders",r,i);let n,d;if("spot"!==a&&"margin"!==a)d="futures-order",n="order:FUTURES";else{const e=this.safeValue(this.options,"accountCategories",{});let t=this.safeString(e,a,"cash");t=t.toUpperCase(),n="order:"+t,d=n}void 0!==e&&(n=n+":"+e);const h=await this.watchPrivate(d,n,o);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrder(e,t){const s="order:"+this.safeString(t,"ac"),i=this.safeValue(t,"data",t),r=this.parseWsOrder(i);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const o=this.orders;o.append(r);const n=s+":"+r.symbol;e.resolve(o,n),e.resolve(o,s)}parseWsOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"st")),i=this.safeString(e,"s"),r=this.safeInteger(e,"t"),a=this.safeSymbol(i,t,"/"),o=this.safeInteger(e,"t"),n=this.safeString(e,"p"),d=this.safeString(e,"q"),h=this.safeString(e,"ap"),c=this.safeString(e,"cfq"),l=this.safeString(e,"orderId"),u=this.safeStringLower(e,"ot"),p=this.safeStringLower(e,"sd"),f=this.safeNumber(e,"cf");let m;if(void 0!==f){const t=this.safeString(e,"fa");m={cost:f,currency:this.safeCurrencyCode(t)}}const g=this.parseNumber(this.omitZero(this.safeString(e,"sp")));return this.safeOrder({info:e,id:l,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:o,symbol:a,type:u,timeInForce:void 0,postOnly:void 0,side:p,price:n,stopPrice:g,triggerPrice:g,amount:d,cost:void 0,average:h,filled:c,remaining:void 0,status:s,fee:m,trades:void 0},t)}handleErrorMessage(e,t){const s=this.safeInteger(t,"code");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e);const i=this.safeValue(t,"message");void 0!==i&&this.throwBroadlyMatchedException(this.exceptions.broad,i,e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t);return!0}}handleAuthenticate(e,t){e.resolve(t,"authenticated")}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"m"),i={ping:this.handlePing,auth:this.handleAuthenticate,sub:this.handleSubscriptionStatus,depth:this.handleOrderBook,"depth-snapshot":this.handleOrderBookSnapshot,trades:this.handleTrades,bar:this.handleOHLCV,balance:this.handleBalance,"futures-account-update":this.handleBalance},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t),"order"!==s&&"futures-order"!==s||(this.handleOrder(e,t),"order"===s&&this.handleBalance(e,t))}handleSubscriptionStatus(e,t){const s=this.safeString(t,"ch","");return s.indexOf("depth")>-1&&!(s.indexOf("depth-snapshot")>-1)&&this.handleOrderBookSubscription(e,t),t}handleOrderBookSubscription(e,t){const s=this.safeString(t,"ch").split(":")[1],i=this.safeMarket(s),r=i.symbol;r in this.orderbooks&&delete this.orderbooks[r],this.orderbooks[r]=this.orderBook({}),"swap"===this.options.defaultType||i.contract?this.spawn(this.fetchOrderBookSnapshot,r):this.spawn(this.watchOrderBookSnapshot,r)}async pong(e,t){try{await e.send({op:"pong",hp:this.safeInteger(t,"hp")})}catch(t){const s=new r.NetworkError(this.id+" handlePing failed with error "+this.json(t));e.reset(s)}}handlePing(e,t){this.spawn(this.pong,e,t)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e);let r=this.safeValue(i.subscriptions,s);if(void 0===r){const a=this.milliseconds().toString(),n=e.split("/"),d=n.length,h=this.safeString(n,d-1),c=a+"+"+this.safeString(n,d-2)+"/"+h,l=this.base64ToBinary(this.secret),u=this.hmac(this.encode(c),l,o.s,"base64"),p={op:"auth",id:this.nonce().toString(),t:a,key:this.apiKey,sig:u};r=await this.watch(e,s,this.extend(p,t),s),i.subscriptions[s]=r}return r}}},9338:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4524),r=s(7996),a=s(9002);class o extends i.A{describe(){const e=this.getDescribeForExtendedWsExchange(new a.A,new r.A,super.describe());return this.deepExtend(e,{id:"bequant",name:"Bequant",countries:["MT"],pro:!0,urls:{logo:"https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg",api:{public:"https://api.bequant.io/api/3",private:"https://api.bequant.io/api/3",ws:{public:"wss://api.bequant.io/api/3/ws/public",private:"wss://api.bequant.io/api/3/ws/trading"}},www:"https://bequant.io",doc:["https://api.bequant.io/"],fees:["https://bequant.io/fees-and-limits"],referral:"https://bequant.io"}})}}},9544:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(3192),r=s(5147),a=s(2079),o=s(2931),n=s(4852),d=s(5354),h=s(8283),c=s(6414);class l extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchLiquidations:!0,watchLiquidationsForSymbols:!0,watchMyLiquidations:!0,watchMyLiquidationsForSymbols:!0,watchBidsAsks:!0,watchMyTrades:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchOrdersForSymbols:!0,watchPositions:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,createOrderWs:!0,editOrderWs:!0,cancelOrderWs:!0,cancelOrdersWs:!1,cancelAllOrdersWs:!0,fetchBalanceWs:!0,fetchDepositsWs:!1,fetchMarketsWs:!1,fetchMyTradesWs:!0,fetchOHLCVWs:!0,fetchOrderBookWs:!0,fetchOpenOrdersWs:!0,fetchOrderWs:!0,fetchOrdersWs:!0,fetchPositionWs:!0,fetchPositionForSymbolWs:!0,fetchPositionsWs:!0,fetchTickerWs:!0,fetchTradesWs:!0,fetchTradingFeesWs:!1,fetchWithdrawalsWs:!1},urls:{test:{ws:{spot:"wss://testnet.binance.vision/ws",margin:"wss://testnet.binance.vision/ws",future:"wss://fstream.binancefuture.com/ws",delivery:"wss://dstream.binancefuture.com/ws","ws-api":{spot:"wss://testnet.binance.vision/ws-api/v3",future:"wss://testnet.binancefuture.com/ws-fapi/v1"}}},api:{ws:{spot:"wss://stream.binance.com:9443/ws",margin:"wss://stream.binance.com:9443/ws",future:"wss://fstream.binance.com/ws",delivery:"wss://dstream.binance.com/ws","ws-api":{spot:"wss://ws-api.binance.com:443/ws-api/v3",future:"wss://ws-fapi.binance.com/ws-fapi/v1"},papi:"wss://fstream.binance.com/pm/ws"}},doc:"https://developers.binance.com/en"},streaming:{keepAlive:18e4},options:{returnRateLimits:!1,streamLimits:{spot:50,margin:50,future:50,delivery:50},subscriptionLimitByStream:{spot:200,margin:200,future:200,delivery:200},streamBySubscriptionsHash:this.createSafeDictionary(),streamIndex:-1,watchOrderBookRate:100,liquidationsLimit:1e3,myLiquidationsLimit:1e3,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,requestId:this.createSafeDictionary(),watchOrderBookLimit:1e3,watchTrades:{name:"trade"},watchTicker:{name:"ticker"},watchTickers:{name:"ticker"},watchOHLCV:{name:"kline"},watchOrderBook:{maxRetries:3,checksum:!0},watchBalance:{fetchBalanceSnapshot:!1,awaitBalanceSnapshot:!0},watchLiquidationsForSymbols:{defaultType:"swap"},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0},wallet:"wb",listenKeyRefreshRate:12e5,ws:{cost:5},tickerChannelsMap:{"24hrTicker":"ticker","24hrMiniTicker":"miniTicker","1hTicker":"ticker_1h","4hTicker":"ticker_4h","1dTicker":"ticker_1d",bookTicker:"bookTicker"}}})}requestId(e){const t=this.safeDict(this.options,"requestId",this.createSafeDictionary()),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}stream(e,t,s=1){const i=this.safeDict(this.options,"streamBySubscriptionsHash",this.createSafeDictionary());let r=this.safeString(i,t);if(void 0===r){let i=this.safeInteger(this.options,"streamIndex",-1);const o=this.safeValue(this.options,"streamLimits");i+=1;const n=i%this.safeInteger(o,e);this.options.streamIndex=i,r=this.numberToString(n),this.options.streamBySubscriptionsHash[t]=r;void 0===this.safeValue(this.options,"numSubscriptionsByStream")&&(this.options.numSubscriptionsByStream=this.createSafeDictionary());const d=this.safeInteger(this.options.numSubscriptionsByStream,r,0);if(d+s>this.safeInteger(this.options.subscriptionLimitByStream,e,200))throw new a.BadRequest(this.id+" reached the limit of subscriptions by stream. Increase the number of streams, or increase the stream limit or subscription limit by stream if the exchange allows.");this.options.numSubscriptionsByStream[r]=d+s}return r}async watchLiquidations(e,t=void 0,s=void 0,i={}){return await this.watchLiquidationsForSymbols([e],t,s,i)}async watchLiquidationsForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[],o=[];let n="liquidations";if(e=this.marketSymbols(e,void 0,!0,!0),this.isEmpty(e))r.push("!forceOrder@arr"),o.push("liquidations");else{for(let t=0;t<e.length;t++){const s=this.market(e[t]);r.push(s.lowercaseId+"@forceOrder"),o.push("liquidations::"+e[t])}n+="::"+e.join(",")}const d=this.getMarketFromSymbols(e);let h,c;if([h,i]=this.handleMarketTypeAndParams("watchLiquidationsForSymbols",d,i),"spot"===h)throw new a.BadRequest(this.id+"watchLiquidationsForSymbols is not supported for swap symbols");[c,i]=this.handleSubTypeAndParams("watchLiquidationsForSymbols",d,i),this.isLinear(h,c)?h="future":this.isInverse(h,c)&&(h="delivery");const l=r.length,u=this.urls.api.ws[h]+"/"+this.stream(h,n,l),p=this.requestId(u),f={method:"SUBSCRIBE",params:r,id:p},m={id:p},g=await this.watchMultiple(u,o,this.extend(f,i),r,m);return this.newUpdates?g:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s,!0)}handleLiquidation(e,t){const s=this.safeValue(t,"o",{}),i=this.safeString(s,"s"),r=this.safeMarket(i,void 0,"","contract"),a=r.symbol,n=this.parseWsLiquidation(s,r);let d=this.safeValue(this.liquidations,a);if(void 0===d){const e=this.safeInteger(this.options,"liquidationsLimit",1e3);d=new o.I3(e)}d.append(n),this.liquidations[a]=d,e.resolve([n],"liquidations"),e.resolve([n],"liquidations::"+a)}parseWsLiquidation(e,t=void 0){const s=this.safeString(e,"s");t=this.safeMarket(s,t);const i=this.safeInteger(e,"T");return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.safeNumber(e,"l"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"ap"),baseValue:void 0,quoteValue:void 0,timestamp:i,datetime:this.iso8601(i)})}async watchMyLiquidations(e,t=void 0,s=void 0,i={}){return this.watchMyLiquidationsForSymbols([e],t,s,i)}async watchMyLiquidationsForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0,!0);const r=this.getMarketFromSymbols(e),a=["myLiquidations"];if(!this.isEmpty(e))for(let t=0;t<e.length;t++){const s=e[t];a.push("myLiquidations::"+s)}let o,n;[o,i]=this.handleMarketTypeAndParams("watchMyLiquidationsForSymbols",r,i),[n,i]=this.handleSubTypeAndParams("watchMyLiquidationsForSymbols",r,i),this.isLinear(o,n)?o="future":this.isInverse(o,n)&&(o="delivery"),await this.authenticate(i);const d=this.urls.api.ws[o]+"/"+this.options[o].listenKey,h=await this.watchMultiple(d,a,undefined,[o]);return this.newUpdates?h:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s)}handleMyLiquidation(e,t){if("LIQUIDATION"!==this.safeString(t,"o"))return;const s=this.safeString(t,"s"),i=this.safeMarket(s),r=this.safeSymbol(s),a=this.parseWsLiquidation(t,i);let n=this.safeValue(this.myLiquidations,r);if(void 0===n){const e=this.safeInteger(this.options,"myLiquidationsLimit",1e3);n=new o.I3(e)}n.append(a),this.myLiquidations[r]=n,e.resolve([a],"myLiquidations"),e.resolve([a],"myLiquidations::"+r)}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0,!0);const i=this.market(e[0]);let r=i.type;i.contract&&(r=i.linear?"future":"delivery");const o="depth";let n="multipleOrderbook";if(void 0!==e){if(e.length>200)throw new a.BadRequest(this.id+" watchOrderBookForSymbols() accepts 200 symbols at most. To watch more symbols call watchOrderBookForSymbols() multiple times");n+="::"+e.join(",")}const d=this.safeString(this.options,"watchOrderBookRate","100"),h=[],c=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);c.push("orderbook::"+s);const r=i.lowercaseId+"@"+o+"@"+d+"ms";h.push(r)}const l=c.length,u=this.urls.api.ws[r]+"/"+this.stream(r,n,l),p=this.requestId(u),f={method:"SUBSCRIBE",params:h,id:p},m={id:p.toString(),name:o,symbols:e,method:this.handleOrderBookSubscription,limit:t,type:r,params:s};return(await this.watchMultiple(u,c,this.extend(f,s),c,m)).limit()}async unWatchOrderBookForSymbols(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0,!0);const s=this.market(e[0]);let i=s.type;s.contract&&(i=s.linear?"future":"delivery");let r="multipleOrderbook";void 0!==e&&(r+="::"+e.join(","));const a=this.safeString(this.options,"watchOrderBookRate","100"),o=[],n=[],d=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);n.push("orderbook::"+s),d.push("unsubscribe:orderbook:"+s);const r=i.lowercaseId+"@depth"+"@"+a+"ms";o.push(r)}const h=n.length,c=this.urls.api.ws[i]+"/"+this.stream(i,r,h),l=this.requestId(c),u={method:"UNSUBSCRIBE",params:o,id:l},p={unsubscribe:!0,id:l.toString(),symbols:e,subMessageHashes:n,messageHashes:d,topic:"orderbook"};return await this.watchMultiple(c,d,this.extend(u,t),d,p)}async unWatchOrderBook(e,t={}){return await this.unWatchOrderBookForSymbols([e],t)}async fetchOrderBookWs(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};void 0!==t&&(r.limit=t);const o=this.getMarketType("fetchOrderBookWs",i,s);if("future"!==o)throw new a.BadRequest(this.id+" fetchOrderBookWs only supports swap markets");const n=this.urls.api.ws["ws-api"][o],d=this.requestId(n).toString();let h=!1;[h,s]=this.handleOptionAndParams(s,"createOrderWs","returnRateLimits",!1),r.returnRateLimits=h,s=this.omit(s,"test");const c={id:d,method:"depth",params:this.signParams(this.extend(r,s))},l={method:this.handleFetchOrderBook},u=await this.watch(n,d,c,d,l);return u.symbol=i.symbol,u}handleFetchOrderBook(e,t){const s=this.safeString(t,"id"),i=this.safeDict(t,"result"),r=this.safeInteger(i,"T"),a=this.parseOrderBook(i,void 0,r);a.nonce=this.safeInteger2(i,"lastUpdateId","u"),e.resolve(a,s)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),r="orderbook::"+i;try{const t=this.safeInteger(this.options,"watchOrderBookLimit",1e3),a=this.safeValue(s,"type"),o=this.safeInteger(s,"limit",t),n=this.safeValue(s,"params"),d=await this.fetchRestOrderBookSafe(i,o,n);if(void 0===this.safeValue(this.orderbooks,i))return;const h=this.orderbooks[i];h.reset(d);const c=h.cache;for(let t=0;t<c.length;t++){const s=c[t],i=this.safeInteger(s,"U"),r=this.safeInteger(s,"u"),o=this.safeInteger(s,"pu");if("future"===a){if(r<h.nonce)continue;(i<=h.nonce&&r>=h.nonce||o===h.nonce)&&this.handleOrderBookMessage(e,s,h)}else{if(r<=h.nonce)continue;i-1<=h.nonce&&r-1>=h.nonce&&this.handleOrderBookMessage(e,s,h)}}this.orderbooks[i]=h,e.resolve(h,r)}catch(t){delete e.subscriptions[r],e.reject(t,r)}}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"u");this.handleDeltas(s.asks,this.safeValue(t,"a",[])),this.handleDeltas(s.bids,this.safeValue(t,"b",[])),s.nonce=i;const r=this.safeInteger(t,"E");return s.timestamp=r,s.datetime=this.iso8601(r),s}handleOrderBook(e,t){const s=e.url.indexOf("testnet")>0,i=e.url.indexOf("/stream.binance.")>0,r=s||i?"spot":"contract",o=this.safeString(t,"s"),n=this.safeMarket(o,void 0,void 0,r).symbol,d="orderbook::"+n;if(!(n in this.orderbooks))return;const h=this.orderbooks[n],c=this.safeInteger(h,"nonce");if(void 0===c)h.cache.push(t);else try{const s=this.safeInteger(t,"U"),i=this.safeInteger(t,"u"),r=this.safeInteger(t,"pu");if(void 0===r){if(i>h.nonce){let r;if(r=void 0===this.safeInteger(h,"timestamp")?s-1<=h.nonce&&i-1>=h.nonce:s-1===h.nonce,r)this.handleOrderBookMessage(e,t,h),c<h.nonce&&e.resolve(h,d);else{if(this.handleOption("watchOrderBook","checksum",!0))throw new a.ChecksumError(this.id+" "+this.orderbookChecksumMessage(n))}}}else if(i>=h.nonce)if(s<=h.nonce||r===h.nonce)this.handleOrderBookMessage(e,t,h),c<=h.nonce&&e.resolve(h,d);else{if(this.handleOption("watchOrderBook","checksum",!0))throw new a.ChecksumError(this.id+" "+this.orderbookChecksumMessage(n))}}catch(t){delete this.orderbooks[n],delete e.subscriptions[d],e.reject(t,d)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),r=this.safeString(s,"symbol"),a=this.safeValue(s,"symbols",[r]),o=this.safeInteger(s,"limit",i);for(let i=0;i<a.length;i++){const r=a[i];r in this.orderbooks&&delete this.orderbooks[r],this.orderbooks[r]=this.orderBook({},o),s=this.extend(s,{symbol:r}),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s,{}),a=this.safeValue(r,"method");void 0!==a&&a.call(this,e,t,r);return this.safeBool(r,"unsubscribe",!1)&&this.handleUnSubscription(e,r),t}handleUnSubscription(e,t){const s=this.safeList(t,"messageHashes",[]),i=this.safeList(t,"subMessageHashes",[]);for(let r=0;r<s.length;r++){const o=s[r],n=i[r];o in e.subscriptions&&delete e.subscriptions[o],n in e.subscriptions&&delete e.subscriptions[n];const d=new a.UnsubscribeError(this.id+" "+n);e.reject(d,n),e.resolve(!0,o),this.cleanCache(t)}}cleanCache(e){const t=this.safeString(e,"topic"),s=this.safeList(e,"symbols",[]);if(s.length>0)for(let e=0;e<s.length;e++){const i=s[e];"trade"===t?delete this.trades[i]:"orderbook"===t?delete this.orderbooks[i]:"ticker"===t&&delete this.tickers[i]}else if("myTrades"===t){const e=Object.keys(this.myTrades);for(let t=0;t<e.length;t++)delete this.myTrades[e[t]]}else if("orders"===t){const e=Object.keys(this.orders);for(let t=0;t<e.length;t++)delete this.orders[e[t]]}else if("ticker"===t){const e=Object.keys(this.tickers);for(let t=0;t<e.length;t++)delete this.tickers[e[t]]}}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,o="multipleTrades";if(void 0!==(e=this.marketSymbols(e,void 0,!1,!0,!0))){if(e.length>200)throw new a.BadRequest(this.id+" watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times");o+="::"+e.join(",")}[r,i]=this.handleOptionAndParams(i,"watchTradesForSymbols","name","trade"),i=this.omit(i,"callerMethodName");const n=this.market(e[0]);let d=n.type;n.contract&&(d=n.linear?"future":"delivery");const h=[],c=[];for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);h.push("trade::"+s);const a=i.lowercaseId+"@"+r;c.push(a)}const l=this.omit(i,"type"),u=c.length,p=this.urls.api.ws[d]+"/"+this.stream(d,o,u),f=this.requestId(p),m={method:"SUBSCRIBE",params:c,id:f},g={id:f},v=await this.watchMultiple(p,h,this.extend(m,l),h,g);if(this.newUpdates){const e=this.safeValue(v,0),t=this.safeString(e,"symbol");s=v.getLimit(t,s)}return this.filterBySinceLimit(v,t,s,"timestamp",!0)}async unWatchTradesForSymbols(e,t={}){await this.loadMarkets();let s,i="multipleTrades";if(void 0!==(e=this.marketSymbols(e,void 0,!1,!0,!0))){if(e.length>200)throw new a.BadRequest(this.id+" watchTradesForSymbols() accepts 200 symbols at most. To watch more symbols call watchTradesForSymbols() multiple times");i+="::"+e.join(",")}[s,t]=this.handleOptionAndParams(t,"watchTradesForSymbols","name","trade"),t=this.omit(t,"callerMethodName");const r=this.market(e[0]);let o=r.type;r.contract&&(o=r.linear?"future":"delivery");const n=[],d=[],h=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.market(i);n.push("trade::"+i),h.push("unsubscribe:trade:"+i);const a=r.lowercaseId+"@"+s;d.push(a)}const c=this.omit(t,"type"),l=d.length,u=this.urls.api.ws[o]+"/"+this.stream(o,i,l),p=this.requestId(u),f={method:"UNSUBSCRIBE",params:d,id:p},m={unsubscribe:!0,id:p.toString(),subMessageHashes:n,messageHashes:h,symbols:e,topic:"trade"};return await this.watchMultiple(u,h,this.extend(f,c),h,m)}async unWatchTrades(e,t={}){return await this.loadMarkets(),await this.unWatchTradesForSymbols([e],t)}async watchTrades(e,t=void 0,s=void 0,i={}){return i.callerMethodName="watchTrades",await this.watchTradesForSymbols([e],t,s,i)}parseWsTrade(e,t=void 0){const s="TRADE"===this.safeString(e,"x");if(!s)return this.parseTrade(e,t);const i=this.safeString2(e,"t","a"),a=this.safeInteger(e,"T"),o=this.safeString2(e,"L","p");let n=this.safeString(e,"q");s&&(n=this.safeString(e,"l",n));let d=this.safeString(e,"Y");void 0===d&&void 0!==o&&void 0!==n&&(d=r.Y.stringMul(o,n));const h=this.safeString(e,"s"),c="ps"in e?"contract":"spot",l=this.safeSymbol(h,void 0,void 0,c);let u,p=this.safeStringLower(e,"S");const f=this.safeString(e,"i");let m;"m"in e&&(void 0===p&&(p=e.m?"sell":"buy"),u=e.m?"maker":"taker");const g=this.safeString(e,"n");if(void 0!==g){const t=this.safeString(e,"N");m={cost:g,currency:this.safeCurrencyCode(t)}}const v=this.safeStringLower(e,"o");return this.safeTrade({info:e,timestamp:a,datetime:this.iso8601(a),symbol:l,id:i,order:f,type:v,takerOrMaker:u,side:p,price:o,amount:n,cost:d,fee:m})}handleTrade(e,t){const s=e.url.indexOf("wss://stream.binance.com")>-1||e.url.indexOf("/testnet.binance")>-1?"spot":"contract",i=this.safeString(t,"s"),r=this.safeMarket(i,void 0,void 0,s),a=r.symbol,n="trade::"+a,d=this.parseWsTrade(t,r);let h=this.safeValue(this.trades,a);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new o.I3(e)}h.append(d),this.trades[a]=h,e.resolve(h,n)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();e=this.market(e).symbol,r.callerMethodName="watchOHLCV";return(await this.watchOHLCVForSymbols([[e,t]],s,i,r))[e][t]}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){let a;await this.loadMarkets(),[a,i]=this.handleParamString2(i,"channel","name","kline");const o=this.getListFromObjectValues(e,0),n=this.marketSymbols(o,void 0,!1,!1,!0),d=this.market(n[0]);let h=d.type;d.contract&&(h=d.linear?"future":"delivery");const c="spot"===h;let l;[l,i]=this.handleParamString(i,"timezone",void 0);const u=void 0!==l&&("+08:00"===l||r.Y.stringEq(l,"8")),p=[],f=[];for(let t=0;t<e.length;t++){const s=e[t],i=s[0],r=s[1],o=this.safeString(this.timeframes,r,r),n=this.market(i);let d=n.lowercaseId;"indexPriceKline"===a&&(d=d.replace("_perp",""));const h=u&&c?"@+08:00":"";p.push(d+"@"+a+"_"+o+h),f.push("ohlcv::"+n.symbol+"::"+r)}const m=this.urls.api.ws[h]+"/"+this.stream(h,"multipleOHLCV"),g=this.requestId(m),v={method:"SUBSCRIBE",params:p,id:g},y={id:g};i=this.omit(i,"callerMethodName");const[w,b,S]=await this.watchMultiple(m,f,this.extend(v,i),f,y);this.newUpdates&&(s=S.getLimit(w,s));const k=this.filterBySinceLimit(S,t,s,0,!0);return this.createOHLCVObject(w,b,k)}handleOHLCV(e,t){let s=this.safeString(t,"e");s=this.safeString({indexPrice_kline:"indexPriceKline",markPrice_kline:"markPriceKline"},s,s);const i=this.safeValue(t,"k");let r=this.safeString2(i,"s","ps");"indexPriceKline"===s&&(r=this.safeString(t,"ps"));const a=this.safeString(i,"i"),n=this.findTimeframe(a),d=[this.safeInteger(i,"t"),this.safeFloat(i,"o"),this.safeFloat(i,"h"),this.safeFloat(i,"l"),this.safeFloat(i,"c"),this.safeFloat(i,"v")],h=e.url.indexOf("/stream")>-1||e.url.indexOf("/testnet.binance")>-1?"spot":"contract",c=this.safeSymbol(r,void 0,void 0,h),l="ohlcv::"+c+"::"+n;this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let u=this.safeValue(this.ohlcvs[c],n);if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new o.TG(e),this.ohlcvs[c][n]=u}u.append(d);const p=[c,n,u];e.resolve(p,l)}async fetchTickerWs(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=this.getMarketType("fetchTickerWs",s,t);if("future"!==r)throw new a.BadRequest(this.id+" fetchTickerWs only supports swap markets");const o=this.urls.api.ws["ws-api"][r],n=this.requestId(o).toString(),d={method:this.handleTickerWs};let h,c=!1;[c,t]=this.handleOptionAndParams(t,"fetchTickerWs","returnRateLimits",!1),i.returnRateLimits=c,t=this.omit(t,"test"),[h,t]=this.handleOptionAndParams(t,"fetchTickerWs","method","ticker.book");const l={id:n,method:h,params:this.signParams(this.extend(i,t))};return await this.watch(o,n,l,n,d)}async fetchOHLCVWs(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const o=this.market(e),n=this.getMarketType("fetchOHLCVWs",o,r);if("spot"!==n&&"future"!==n)throw new a.BadRequest(this.id+" fetchOHLCVWs only supports spot or swap markets");const d=this.urls.api.ws["ws-api"][n],h=this.requestId(d).toString();let c=!1;[c,r]=this.handleOptionAndParams(r,"fetchOHLCVWs","returnRateLimits",!1);const l={symbol:this.marketId(e),returnRateLimits:c,interval:this.timeframes[t]},u=this.safeInteger(r,"until");r=this.omit(r,"until"),void 0!==s&&(l.startTime=s),void 0!==i&&(l.limit=i),void 0!==u&&(l.endTime=u);const p={id:h,method:"klines",params:this.extend(l,r)},f={method:this.handleFetchOHLCV};return await this.watch(d,h,p,h,f)}handleFetchOHLCV(e,t){const s=this.safeList(t,"result"),i=this.parseOHLCVs(s),r=this.safeString(t,"id");e.resolve(i,r)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchTickers([e],this.extend(t,{callerMethodName:"watchTicker"})))[e]}async watchTickers(e=void 0,t={}){let s;if([s,t]=this.handleOptionAndParams(t,"watchTickers","name","ticker"),"bookTicker"===s)throw new a.BadRequest(this.id+" deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead");const i=await this.watchMultiTickerHelper("watchTickers",s,e,t);return this.newUpdates?i:this.filterByArray(this.tickers,"symbol",e)}async unWatchTickers(e=void 0,t={}){let s;if([s,t]=this.handleOptionAndParams(t,"watchTickers","name","ticker"),"bookTicker"===s)throw new a.BadRequest(this.id+" deprecation notice - to subscribe for bids-asks, use watch_bids_asks() method instead");await this.loadMarkets();const i="watchTickers";let r,o;const n=void 0!==(e=this.marketSymbols(e,void 0,!0,!1,!0));let d,h;if(n&&(r=this.market(e[0])),[o,t]=this.handleMarketTypeAndParams(i,r,t),[d,t]=this.handleSubTypeAndParams(i,r,t),this.isLinear(o,d))h="future";else if(this.isInverse(o,d))h="delivery";else{if("spot"!==o)throw new a.NotSupported(this.id+" "+i+"() does not support options markets");h=o}const c="bookTicker"===s,l=[],u=[],p=[];if(n)for(let t=0;t<e.length;t++){const i=e[t],r=this.market(i);l.push(r.lowercaseId+"@"+s),u.push(this.getMessageHash(s,r.symbol,c)),p.push("unsubscribe:ticker:"+i)}else{if(c){if("spot"===o)throw new a.ArgumentsRequired(this.id+" "+i+"() requires symbols for this channel for spot markets");l.push("!"+s)}else l.push("!"+s+"@arr");u.push(this.getMessageHash(s,void 0,c)),p.push("unsubscribe:ticker")}let f=s;n&&(f=s+"::"+e.join(","));const m=this.urls.api.ws[h]+"/"+this.stream(h,f),g=this.requestId(m),v={method:"UNSUBSCRIBE",params:l,id:g},y={unsubscribe:!0,id:g.toString(),subMessageHashes:u,messageHashes:u,symbols:e,topic:"ticker"};return await this.watchMultiple(m,u,this.extend(v,t),u,y)}async unWatchTicker(e,t={}){return await this.unWatchTickers([e],t)}async watchBidsAsks(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!1,!0);const s=await this.watchMultiTickerHelper("watchBidsAsks","bookTicker",e,t);return this.newUpdates?s:this.filterByArray(this.tickers,"symbol",e)}async watchMultiTickerHelper(e,t,s=void 0,i={}){let r,o;await this.loadMarkets();const n=void 0!==(s=this.marketSymbols(s,void 0,!0,!1,!0));let d,h;if(n&&(r=this.market(s[0])),[o,i]=this.handleMarketTypeAndParams(e,r,i),[d,i]=this.handleSubTypeAndParams(e,r,i),this.isLinear(o,d))h="future";else if(this.isInverse(o,d))h="delivery";else{if("spot"!==o)throw new a.NotSupported(this.id+" "+e+"() does not support options markets");h=o}const c="bookTicker"===t,l=[],u=[];if(n)for(let e=0;e<s.length;e++){const i=s[e],r=this.market(i);l.push(r.lowercaseId+"@"+t),u.push(this.getMessageHash(t,r.symbol,c))}else{if(c){if("spot"===o)throw new a.ArgumentsRequired(this.id+" "+e+"() requires symbols for this channel for spot markets");l.push("!"+t)}else l.push("!"+t+"@arr");u.push(this.getMessageHash(t,void 0,c))}let p=t;n&&(p=t+"::"+s.join(","));const f=this.urls.api.ws[h]+"/"+this.stream(h,p),m=this.requestId(f),g={method:"SUBSCRIBE",params:l,id:m},v={id:m},y=await this.watchMultiple(f,u,this.deepExtend(g,i),l,v);if(n){const e={};return e[y.symbol]=y,e}return y}parseWsTicker(e,t){let s,i=this.safeString(e,"e","bookTicker");"24hrTicker"===i&&(i="ticker"),s="bookTicker"===i?this.safeInteger2(e,"E","time"):this.safeIntegerN(e,["C","E","time"]);const r=this.safeString2(e,"s","symbol"),a=this.safeSymbol(r,void 0,void 0,t),o=this.safeMarket(r,void 0,void 0,t),n=this.safeString2(e,"c","price");return this.safeTicker({symbol:a,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString2(e,"b","bidPrice"),bidVolume:this.safeString2(e,"B","bidQty"),ask:this.safeString2(e,"a","askPrice"),askVolume:this.safeString2(e,"A","askQty"),vwap:this.safeString(e,"w"),open:this.safeString(e,"o"),close:n,last:n,previousClose:this.safeString(e,"x"),change:this.safeString(e,"p"),percentage:this.safeString(e,"P"),average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"q"),info:e},o)}handleTickerWs(e,t){const s=this.safeString(t,"id"),i=this.safeValue(t,"result",{}),r=this.parseWsTicker(i,"future");e.resolve(r,s)}handleBidsAsks(e,t){this.handleTickersAndBidsAsks(e,t,"bidasks")}handleTickers(e,t){this.handleTickersAndBidsAsks(e,t,"tickers")}handleTickersAndBidsAsks(e,t,s){const i=e.url.indexOf("/stream")>-1||e.url.indexOf("/testnet.binance")>-1?"spot":"contract",r="bidasks"===s;let a;const o=[];let n=[];const d={};Array.isArray(t)?n=t:n.push(t);for(let t=0;t<n.length;t++){const s=n[t];let h=this.safeString(s,"e");if(r&&(h="bookTicker"),a=this.safeString(this.options.tickerChannelsMap,h,h),void 0===a)continue;const c=this.parseWsTicker(s,i),l=c.symbol;d[l]=c,r?this.bidsasks[l]=c:this.tickers[l]=c;const u=this.getMessageHash(a,l,r);o.push(u),e.resolve(c,u)}if(o.length>0){const t=this.getMessageHash(a,void 0,r);e.resolve(d,t)}}getMessageHash(e,t,s){const i=s?"bidask":"ticker";return void 0!==t?i+":"+e+"@"+t:i+"s:"+e}signParams(e={}){this.checkRequiredCredentials();let t=this.extend({timestamp:this.nonce(),apiKey:this.apiKey},e);const s=this.safeInteger(this.options,"recvWindow");void 0!==s&&(e.recvWindow=s);const i=this.safeInteger(e,"recvWindow");void 0!==i&&(e.recvWindow=i),t=this.keysort(t);const r=this.urlencode(t);let a;return a=this.secret.indexOf("PRIVATE KEY")>-1?this.secret.length>120?(0,d.n)(r,this.secret,n.s):(0,h.q4)(this.encode(r),this.secret,c.ev):this.hmac(this.encode(r),this.encode(this.secret),n.s),t.signature=a,t}async authenticate(e={}){const t=this.milliseconds();let s,i,r,o;[s,e]=this.handleMarketTypeAndParams("authenticate",void 0,e),[i,e]=this.handleSubTypeAndParams("authenticate",void 0,e),[r,e]=this.handleOptionAndParams2(e,"authenticate","papi","portfolioMargin",!1),this.isLinear(s,i)?s="future":this.isInverse(s,i)&&(s="delivery"),[o,e]=this.handleMarginModeAndParams("authenticate",e);const n="isolated"===o,d="cross"===o||void 0===o,h=this.safeString(e,"symbol");e=this.omit(e,"symbol");const c=this.safeValue(this.options,s,{}),l=this.safeInteger(c,"lastAuthenticatedTime",0),u=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);if(t-l>this.sum(u,1e4)){let i;if(r)i=await this.papiPostListenKey(e);else if("future"===s)i=await this.fapiPrivatePostListenKey(e);else if("delivery"===s)i=await this.dapiPrivatePostListenKey(e);else if("margin"===s&&d)i=await this.sapiPostUserDataStream(e);else if(n){if(void 0===h)throw new a.ArgumentsRequired(this.id+" authenticate() requires a symbol argument for isolated margin mode");const t=this.marketId(h);e=this.extend(e,{symbol:t}),i=await this.sapiPostUserDataStreamIsolated(e)}else i=await this.publicPostUserDataStream(e);this.options[s]=this.extend(c,{listenKey:this.safeString(i,"listenKey"),lastAuthenticatedTime:t}),this.delay(u,this.keepAliveListenKey,e)}}async keepAliveListenKey(e={}){let t,s=this.safeString2(this.options,"defaultType","authenticate","spot");s=this.safeString(e,"type",s),[t,e]=this.handleOptionAndParams2(e,"keepAliveListenKey","papi","portfolioMargin",!1);const i=this.handleSubTypeAndParams("keepAliveListenKey",void 0,e)[0];this.isLinear(s,i)?s="future":this.isInverse(s,i)&&(s="delivery");const r=this.safeValue(this.options,s,{}),a=this.safeString(r,"listenKey");if(void 0===a)return;const o={},n=this.safeString(e,"symbol");e=this.omit(e,["type","symbol"]);const d=this.milliseconds();try{t?await this.papiPutListenKey(this.extend(o,e)):"future"===s?await this.fapiPrivatePutListenKey(this.extend(o,e)):"delivery"===s?await this.dapiPrivatePutListenKey(this.extend(o,e)):(o.listenKey=a,"margin"===s?(o.symbol=n,await this.sapiPutUserDataStream(this.extend(o,e))):await this.publicPutUserDataStream(this.extend(o,e)))}catch(e){let i=s;t&&(i="papi");const a=this.urls.api.ws[i]+"/"+this.options[s].listenKey,o=this.client(a),n=Object.keys(o.futures);for(let t=0;t<n.length;t++){const s=n[t];o.reject(e,s)}return void(this.options[s]=this.extend(r,{listenKey:void 0,lastAuthenticatedTime:0}))}this.options[s]=this.extend(r,{listenKey:a,lastAuthenticatedTime:d});const h=Object.values(this.clients),c=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);for(let t=0;t<h.length;t++){const i=h[t],r=Object.keys(i.subscriptions);for(let t=0;t<r.length;t++){if(r[t]===s)return void this.delay(c,this.keepAliveListenKey,e)}}}setBalanceCache(e,t,s=!1){if(t in e.subscriptions)return;const i=this.safeValue(this.options,"watchBalance");if(this.safeBool(i,"fetchBalanceSnapshot",!1)){const i=t+":fetchBalanceSnapshot";i in e.futures||(e.future(i),this.spawn(this.loadBalanceSnapshot,e,i,t,s))}else this.balance[t]={}}async loadBalanceSnapshot(e,t,s,i){const r={type:s};i&&(r.portfolioMargin=!0);const a=await this.fetchBalance(r);this.balance[s]=this.extend(a,this.safeValue(this.balance,s,{}));e.futures[t].resolve(),e.resolve(this.balance[s],s+":balance")}async fetchBalanceWs(e={}){await this.loadMarkets();const t=this.getMarketType("fetchBalanceWs",void 0,e);if("spot"!==t&&"future"!==t)throw new a.BadRequest(this.id+" fetchBalanceWs only supports spot or swap markets");const s=this.urls.api.ws["ws-api"][t],i=this.requestId(s).toString();let r=!1;[r,e]=this.handleOptionAndParams(e,"fetchBalanceWs","returnRateLimits",!1);const o={returnRateLimits:r};let n;[n,e]=this.handleOptionAndParams(e,"fetchBalanceWs","method","account.status");const d={id:i,method:n,params:this.signParams(this.extend(o,e))},h={method:"account.status"===n?this.handleAccountStatusWs:this.handleBalanceWs};return await this.watch(s,i,d,i,h)}handleBalanceWs(e,t){const s=this.safeString(t,"id");let i;if(Array.isArray(t.result))i=this.safeList(t,"result",[]);else{const e=this.safeDict(t,"result",{});i=this.safeList(e,"assets",[])}const r=this.parseBalanceCustom(i);e.resolve(r,s)}handleAccountStatusWs(e,t){const s=this.safeString(t,"id"),i=this.safeDict(t,"result",{}),r=this.parseBalanceCustom(i);e.resolve(r,s)}async fetchPositionWs(e,t={}){return await this.fetchPositionsWs([e],t)}async fetchPositionsWs(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,"swap",!0,!0,!0);const s=this.urls.api.ws["ws-api"].future,i=this.requestId(s).toString(),r={};if(void 0!==e){1===e.length&&(r.symbol=this.marketId(e[0]))}let a,o=!1;[o,t]=this.handleOptionAndParams(t,"fetchPositionsWs","returnRateLimits",!1),r.returnRateLimits=o,[a,t]=this.handleOptionAndParams(t,"fetchPositionsWs","method","account.position");const n={id:i,method:a,params:this.signParams(this.extend(r,t))},d={method:this.handlePositionsWs},h=await this.watch(s,i,n,i,d);return this.filterByArrayPositions(h,"symbol",e,!1)}handlePositionsWs(e,t){const s=this.safeString(t,"id"),i=this.safeList(t,"result",[]),r=[];for(let e=0;e<i.length;e++){const t=this.parsePositionRisk(i[e]),s=this.safeString(t,"entryPrice");"0"!==s&&"0.0"!==s&&"0.00000000"!==s&&r.push(t)}e.resolve(r,s)}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate(e);const t=this.safeString(this.options,"defaultType","spot");let s,i,r=this.safeString(e,"type",t);[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e),[i,e]=this.handleOptionAndParams2(e,"watchBalance","papi","portfolioMargin",!1);let a=r;i&&(a="papi"),this.isLinear(r,s)?r="future":this.isInverse(r,s)&&(r="delivery");const o=this.urls.api.ws[a]+"/"+this.options[r].listenKey,n=this.client(o);this.setBalanceCache(n,r,i),this.setPositionsCache(n,r,void 0,i);const d=this.safeDict(this.options,"watchBalance"),h=this.safeBool(d,"fetchBalanceSnapshot",!1),c=this.safeBool(d,"awaitBalanceSnapshot",!0);h&&c&&await n.future(r+":fetchBalanceSnapshot");const l=r+":balance";return await this.watch(o,l,undefined,r)}handleBalance(e,t){const s=this.safeString(this.options,"wallet","wb"),i=Object.keys(e.subscriptions)[0],a=i+":balance";void 0===this.balance[i]&&(this.balance[i]={}),this.balance[i].info=t;if("balanceUpdate"===this.safeString(t,"e")){const e=this.safeString(t,"a"),s=this.safeCurrencyCode(e),a=this.account(),o=this.safeString(t,"d");if(s in this.balance[i]){let e=this.balance[i][s].free;"string"!=typeof e&&(e=this.numberToString(e)),a.free=r.Y.stringAdd(e,o)}else a.free=o;this.balance[i][s]=a}else{t=this.safeDict(t,"a",t);const e=this.safeList(t,"B");for(let t=0;t<e.length;t++){const r=e[t],a=this.safeString(r,"a"),o=this.safeCurrencyCode(a),n=this.account();n.free=this.safeString(r,"f"),n.used=this.safeString(r,"l"),n.total=this.safeString(r,s),this.balance[i][o]=n}}const o=this.safeInteger(t,"E");this.balance[i].timestamp=o,this.balance[i].datetime=this.iso8601(o),this.balance[i]=this.safeBalance(this.balance[i]),e.resolve(this.balance[i],a)}getMarketType(e,t,s={}){let i,r;return[i,s]=this.handleMarketTypeAndParams(e,t,s),[r,s]=this.handleSubTypeAndParams(e,t,s),this.isLinear(i,r)?i="future":this.isInverse(i,r)&&(i="delivery"),i}async createOrderWs(e,t,s,i,r=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=this.getMarketType("createOrderWs",n,o);if("spot"!==d&&"future"!==d)throw new a.BadRequest(this.id+" createOrderWs only supports spot or swap markets");const h=this.urls.api.ws["ws-api"][d],c=this.requestId(h).toString(),l=this.safeBool2(o,"sor","SOR",!1);o=this.omit(o,"sor","SOR");const u=this.createOrderRequest(e,t,s,i,r,o);let p=!1;[p,o]=this.handleOptionAndParams(o,"createOrderWs","returnRateLimits",!1),u.returnRateLimits=p;const f=this.safeBool(o,"test",!1);o=this.omit(o,"test");const m={id:c,method:"order.place",params:this.signParams(this.extend(u,o))};f&&(m.method=l?"sor.order.test":"order.test");const g={method:this.handleOrderWs};return await this.watch(h,c,m,c,g)}handleOrderWs(e,t){const s=this.safeString(t,"id"),i=this.safeDict(t,"result",{}),r=this.parseOrder(i);e.resolve(r,s)}handleOrdersWs(e,t){const s=this.safeString(t,"id"),i=this.safeList(t,"result",[]),r=this.parseOrders(i);e.resolve(r,s)}async editOrderWs(e,t,s,i,r=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t),h=this.getMarketType("editOrderWs",d,n);if("spot"!==h&&"future"!==h)throw new a.BadRequest(this.id+" editOrderWs only supports spot or swap markets");const c=this.urls.api.ws["ws-api"][h],l=this.requestId(c).toString();let u;"spot"===h?u=this.editSpotOrderRequest(e,t,s,i,r,o,n):"future"===h&&(u=this.editContractOrderRequest(e,t,s,i,r,o,n));let p=!1;[p,n]=this.handleOptionAndParams(n,"editOrderWs","returnRateLimits",!1),u.returnRateLimits=p;const f={id:l,method:"future"===h?"order.modify":"order.cancelReplace",params:this.signParams(this.extend(u,n))},m={method:this.handleEditOrderWs};return await this.watch(c,l,f,l,m)}handleEditOrderWs(e,t){const s=this.safeString(t,"id"),i=this.safeDict(t,"result",{}),r=this.safeDict(i,"newOrderResponse");let a;a=void 0!==r?this.parseOrder(r):this.parseOrder(i),e.resolve(a,s)}async cancelOrderWs(e,t=void 0,s={}){if(await this.loadMarkets(),void 0===t)throw new a.BadRequest(this.id+" cancelOrderWs requires a symbol");const i=this.market(t),r=this.getMarketType("cancelOrderWs",i,s),o=this.urls.api.ws["ws-api"][r],n=this.requestId(o).toString();let d=!1;[d,s]=this.handleOptionAndParams(s,"cancelOrderWs","returnRateLimits",!1);const h={symbol:this.marketId(t),returnRateLimits:d},c=this.safeString2(s,"origClientOrderId","clientOrderId");void 0!==c?h.origClientOrderId=c:h.orderId=this.parseToInt(e),s=this.omit(s,["origClientOrderId","clientOrderId"]);const l={id:n,method:"order.cancel",params:this.signParams(this.extend(h,s))},u={method:this.handleOrderWs};return await this.watch(o,n,l,n,u)}async cancelAllOrdersWs(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i=this.getMarketType("cancelAllOrdersWs",s,t);if("spot"!==i&&"future"!==i)throw new a.BadRequest(this.id+" cancelAllOrdersWs only supports spot or swap markets");const r=this.urls.api.ws["ws-api"][i],o=this.requestId(r).toString();let n=!1;[n,t]=this.handleOptionAndParams(t,"cancelAllOrdersWs","returnRateLimits",!1);const d={symbol:this.marketId(e),returnRateLimits:n},h={id:o,method:"order.cancel",params:this.signParams(this.extend(d,t))},c={method:this.handleOrdersWs};return await this.watch(r,o,h,o,c)}async fetchOrderWs(e,t=void 0,s={}){if(await this.loadMarkets(),void 0===t)throw new a.BadRequest(this.id+" cancelOrderWs requires a symbol");const i=this.market(t),r=this.getMarketType("fetchOrderWs",i,s);if("spot"!==r&&"future"!==r)throw new a.BadRequest(this.id+" fetchOrderWs only supports spot or swap markets");const o=this.urls.api.ws["ws-api"][r],n=this.requestId(o).toString();let d=!1;[d,s]=this.handleOptionAndParams(s,"fetchOrderWs","returnRateLimits",!1);const h={symbol:this.marketId(t),returnRateLimits:d},c=this.safeString2(s,"origClientOrderId","clientOrderId");void 0!==c?h.origClientOrderId=c:h.orderId=this.parseToInt(e);const l={id:n,method:"order.status",params:this.signParams(this.extend(h,s))},u={method:this.handleOrderWs};return await this.watch(o,n,l,n,u)}async fetchOrdersWs(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new a.BadRequest(this.id+" fetchOrdersWs requires a symbol");const r=this.market(e),o=this.getMarketType("fetchOrdersWs",r,i);if("spot"!==o)throw new a.BadRequest(this.id+" fetchOrdersWs only supports spot markets");const n=this.urls.api.ws["ws-api"][o],d=this.requestId(n).toString();let h=!1;[h,i]=this.handleOptionAndParams(i,"fetchOrderWs","returnRateLimits",!1);const c={symbol:this.marketId(e),returnRateLimits:h},l={id:d,method:"allOrders",params:this.signParams(this.extend(c,i))},u={method:this.handleOrdersWs},p=await this.watch(n,d,l,d,u);return this.filterBySymbolSinceLimit(p,e,t,s)}async fetchClosedOrdersWs(e=void 0,t=void 0,s=void 0,i={}){const r=await this.fetchOrdersWs(e,t,s,i),a=[];for(let e=0;e<r.length;e++){const t=r[e];"closed"===t.status&&a.push(t)}return a}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),o=this.getMarketType("fetchOpenOrdersWs",r,i);if("spot"!==o&&"future"!==o)throw new a.BadRequest(this.id+" fetchOpenOrdersWs only supports spot or swap markets");const n=this.urls.api.ws["ws-api"][o],d=this.requestId(n).toString();let h=!1;[h,i]=this.handleOptionAndParams(i,"fetchOrderWs","returnRateLimits",!1);const c={returnRateLimits:h};void 0!==e&&(c.symbol=this.marketId(e));const l={id:d,method:"openOrders.status",params:this.signParams(this.extend(c,i))},u={method:this.handleOrdersWs},p=await this.watch(n,d,l,d,u);return this.filterBySymbolSinceLimit(p,e,t,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o,n,d="orders";void 0!==e&&(r=this.market(e),d+=":"+(e=r.symbol)),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i),[o,i]=this.handleSubTypeAndParams("watchOrders",r,i),this.isLinear(a,o)?a="future":this.isInverse(a,o)&&(a="delivery"),i=this.extend(i,{type:a,symbol:e}),await this.authenticate(i),[n,i]=this.handleMarginModeAndParams("watchOrders",i);let h,c=a;("margin"===a||"spot"===a&&void 0!==n)&&(c="spot"),[h,i]=this.handleOptionAndParams2(i,"watchOrders","papi","portfolioMargin",!1),h&&(c="papi");const l=this.urls.api.ws[c]+"/"+this.options[a].listenKey,u=this.client(l);this.setBalanceCache(u,a,h),this.setPositionsCache(u,a,void 0,h);const p=await this.watch(l,d,undefined,a);return this.newUpdates&&(s=p.getLimit(e,s)),this.filterBySymbolSinceLimit(p,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"x"),i=this.safeString(e,"i"),a=this.safeString(e,"s"),o="ps"in e?"contract":"spot",n=this.safeSymbol(a,void 0,void 0,o);let d=this.safeInteger(e,"O");const h=this.safeInteger(e,"T");let c;"NEW"===s||"AMENDMENT"===s||"CANCELED"===s?void 0===d&&(d=h):"TRADE"===s&&(c=h);const l=h;let u;const p=this.safeString(e,"n");if(void 0!==p&&r.Y.stringGt(p,"0")){const t=this.safeString(e,"N");u={cost:p,currency:this.safeCurrencyCode(t)}}const f=this.safeString(e,"p"),m=this.safeString(e,"q"),g=this.safeStringLower(e,"S"),v=this.safeStringLower(e,"o"),y=this.safeString(e,"z"),w=this.safeString(e,"Z"),b=this.safeString(e,"ap"),S=this.safeString(e,"X"),k=this.parseOrderStatus(S);let O=this.safeString(e,"C");void 0!==O&&0!==O.length||(O=this.safeString(e,"c"));const T=this.safeString2(e,"P","sp");let P=this.safeString(e,"f");return"GTX"===P&&(P="PO"),this.safeOrder({info:e,symbol:n,id:i,clientOrderId:O,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:c,lastUpdateTimestamp:l,type:v,timeInForce:P,postOnly:void 0,reduceOnly:this.safeBool(e,"R"),side:g,price:f,stopPrice:T,triggerPrice:T,amount:m,cost:w,average:b,filled:y,remaining:void 0,status:k,fee:u,trades:undefined})}handleOrderUpdate(e,t){"ORDER_TRADE_UPDATE"===this.safeString(t,"e")&&(t=this.safeDict(t,"o",t)),this.handleMyTrade(e,t),this.handleOrder(e,t),this.handleMyLiquidation(e,t)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a="";e=this.marketSymbols(e),this.isEmpty(e)||(r=this.getMarketFromSymbols(e),a="::"+e.join(","));const o={};let n,d,h;void 0!==r&&(o.type=r.type,o.subType=r.subType),await this.authenticate(this.extend(o,i)),[n,i]=this.handleMarketTypeAndParams("watchPositions",r,i),"spot"!==n&&"margin"!==n||(n="future"),[d,i]=this.handleSubTypeAndParams("watchPositions",r,i),this.isLinear(n,d)?n="future":this.isInverse(n,d)&&(n="delivery"),a=n+":positions"+a,[h,i]=this.handleOptionAndParams2(i,"watchPositions","papi","portfolioMargin",!1);let c=n;h&&(c="papi");const l=this.urls.api.ws[c]+"/"+this.options[n].listenKey,u=this.client(l);this.setBalanceCache(u,n,h),this.setPositionsCache(u,n,e,h);const p=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),f=this.handleOption("watchPositions","awaitPositionsSnapshot",!0),m=this.safeValue(this.positions,n);if(p&&f&&void 0===m){const i=await u.future(n+":fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const g=await this.watch(l,a,void 0,n);return this.newUpdates?g:this.filterBySymbolsSinceLimit(m,e,t,s,!0)}setPositionsCache(e,t,s=void 0,i=!1){if("spot"===t)return;if(void 0===this.positions&&(this.positions={}),t in this.positions)return;if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const s=t+":fetchPositionsSnapshot";s in e.futures||(e.future(s),this.spawn(this.loadPositionsSnapshot,e,s,t,i))}else this.positions[t]=new o.Hk}async loadPositionsSnapshot(e,t,s,i){const r={type:s};i&&(r.portfolioMargin=!0);const a=await this.fetchPositions(void 0,r);this.positions[s]=new o.Hk;const n=this.positions[s];for(let e=0;e<a.length;e++){const t=a[e];this.safeNumber(t,"contracts",0)>0&&n.append(t)}e.futures[t].resolve(n),e.resolve(n,s+":position")}handlePositions(e,t){const s=Object.keys(e.subscriptions)[0];void 0===this.positions&&(this.positions={}),s in this.positions||(this.positions[s]=new o.Hk);const i=this.positions[s],r=this.safeDict(t,"a",{}),a=this.safeList(r,"P",[]),n=[];for(let e=0;e<a.length;e++){const s=a[e],r=this.parseWsPosition(s),o=this.safeInteger(t,"E");r.timestamp=o,r.datetime=this.iso8601(o),n.push(r),i.append(r)}const d=this.findMessageHashes(e,s+":positions::");for(let t=0;t<d.length;t++){const s=d[t],i=s.split("::")[1].split(","),r=this.filterByArray(n,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(n,s+":positions")}parseWsPosition(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeString(e,"pa"),a=r.Y.stringAbs(this.safeString(e,"pa"));let o=this.safeStringLower(e,"ps"),n=!0;return"both"===o&&(n=!1,r.Y.stringEq(i,"0")||(o=r.Y.stringLt(i,"0")?"short":"long")),this.safePosition({info:e,id:void 0,symbol:this.safeSymbol(s,void 0,void 0,"contract"),notional:void 0,marginMode:this.safeString(e,"mt"),liquidationPrice:void 0,entryPrice:this.safeNumber(e,"ep"),unrealizedPnl:this.safeNumber(e,"up"),percentage:void 0,contracts:this.parseNumber(a),contractSize:void 0,markPrice:void 0,side:o,hedged:n,timestamp:void 0,datetime:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,marginRatio:void 0})}async fetchMyTradesWs(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new a.BadRequest(this.id+" fetchMyTradesWs requires a symbol");const r=this.market(e),o=this.getMarketType("fetchMyTradesWs",r,i);if("spot"!==o&&"future"!==o)throw new a.BadRequest(this.id+" fetchMyTradesWs does not support "+o+" markets");const n=this.urls.api.ws["ws-api"][o],d=this.requestId(n).toString();let h=!1;[h,i]=this.handleOptionAndParams(i,"fetchMyTradesWs","returnRateLimits",!1);const c={symbol:this.marketId(e),returnRateLimits:h};void 0!==t&&(c.startTime=t),void 0!==s&&(c.limit=s);if(void 0!==this.safeInteger(i,"fromId")&&void 0!==t)throw new a.BadRequest(this.id+"fetchMyTradesWs does not support fetching by both fromId and since parameters at the same time");const l={id:d,method:"myTrades",params:this.signParams(this.extend(c,i))},u={method:this.handleTradesWs},p=await this.watch(n,d,l,d,u);return this.filterBySymbolSinceLimit(p,e,t,s)}async fetchTradesWs(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0===e)throw new a.BadRequest(this.id+" fetchTradesWs () requires a symbol argument");const r=this.market(e),o=this.getMarketType("fetchTradesWs",r,i);if("spot"!==o&&"future"!==o)throw new a.BadRequest(this.id+" fetchTradesWs does not support "+o+" markets");const n=this.urls.api.ws["ws-api"][o],d=this.requestId(n).toString();let h=!1;[h,i]=this.handleOptionAndParams(i,"fetchTradesWs","returnRateLimits",!1);const c={symbol:this.marketId(e),returnRateLimits:h};void 0!==s&&(c.limit=s);const l={id:d,method:"trades.historical",params:this.extend(c,i)},u={method:this.handleTradesWs},p=await this.watch(n,d,l,d,u);return this.filterBySinceLimit(p,t,s)}handleTradesWs(e,t){const s=this.safeString(t,"id"),i=this.safeList(t,"result",[]),r=this.parseTrades(i);e.resolve(r,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r,a,o;await this.loadMarkets(),void 0!==e&&(a=this.market(e),e=a.symbol),[r,i]=this.handleMarketTypeAndParams("watchMyTrades",a,i),[o,i]=this.handleSubTypeAndParams("watchMyTrades",a,i),this.isLinear(r,o)?r="future":this.isInverse(r,o)&&(r="delivery");let n="myTrades";void 0!==e&&(n+=":"+(e=this.symbol(e)),i=this.extend(i,{type:a.type,symbol:e})),await this.authenticate(i);let d,h=r;"margin"===r&&(h="spot"),[d,i]=this.handleOptionAndParams2(i,"watchMyTrades","papi","portfolioMargin",!1),d&&(h="papi");const c=this.urls.api.ws[h]+"/"+this.options[r].listenKey,l=this.client(c);this.setBalanceCache(l,r,d),this.setPositionsCache(l,r,void 0,d);const u=await this.watch(c,n,undefined,r);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}handleMyTrade(e,t){const s="myTrades";if("TRADE"===this.safeString(t,"x")){const i=this.parseWsTrade(t),r=this.safeString(i,"order");let a=this.safeDict(i,"fee",{});a=this.extend({},a);const n=this.safeString(i,"symbol");if(void 0!==r&&void 0!==a&&void 0!==n){const e=this.orders;if(void 0!==e){const t=this.safeValue(e.hashmap,n,{}),s=this.safeValue(t,r);if(void 0!==s){const e=this.safeValue(s,"fees"),t=this.safeValue(s,"fee");if(this.isEmpty(e))if(void 0!==t)if(t.currency===a.currency){const e=this.sum(t.cost,a.cost);s.fee.cost=parseFloat(this.currencyToPrecision(a.currency,e))}else void 0===t.currency?s.fee=a:(s.fees=[t,a],s.fee=void 0);else s.fee=a;else{let t=!0;for(let i=0;i<e.length;i++){const r=e[i];if(r.currency===a.currency){const e=this.sum(a.cost,r.cost);s.fees[i].cost=parseFloat(this.currencyToPrecision(a.currency,e)),t=!1;break}}t&&s.fees.push(a)}const r=this.safeList(s,"trades",[]);r.push(i),s.trades=r}}}if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new o.Pt(e)}this.myTrades.append(i),e.resolve(this.myTrades,s);const d=s+":"+n;e.resolve(this.myTrades,d)}}handleOrder(e,t){const s=this.parseWsOrder(t),i=this.safeString(s,"symbol"),r=this.safeString(s,"id");if(void 0!==i){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new o.Pt(e)}const t=this.orders,a=this.safeValue(t.hashmap,i,{}),n=this.safeValue(a,r);if(void 0!==n){const e=this.safeValue(n,"fee");void 0!==e&&(s.fee=e);const t=this.safeValue(n,"fees");void 0!==t&&(s.fees=t),s.trades=this.safeValue(n,"trades");void 0===this.safeInteger(s,"timestamp")&&(s.timestamp=this.safeInteger(n,"timestamp"),s.datetime=this.safeString(n,"datetime"))}t.append(s);const d="orders",h="orders:"+i;e.resolve(t,d),e.resolve(t,h)}}handleAcountUpdate(e,t){this.handleBalance(e,t),this.handlePositions(e,t)}handleWsError(e,t){const s=this.safeString(t,"id");let i=!1;const r=this.safeDict(t,"error",{}),a=this.safeInteger(r,"code"),o=this.safeString(r,"msg");try{this.handleErrors(a,o,e.url,void 0,void 0,this.json(r),r,void 0,void 0)}catch(t){i=!0,e.reject(t,s);const r=Object.keys(e.subscriptions);for(let i=0;i<r.length;i++){const a=r[i];s===this.safeString(e.subscriptions[a],"id")&&e.reject(t,a)}}i||e.reject(t,s),"5"===this.safeString(a,0)&&e.reset(t)}handleMessage(e,t){const s=this.safeString(t,"status");if(void 0!==this.safeValue(t,"error")||void 0!==s&&"200"!==s)return void this.handleWsError(e,t);const i=this.safeString(t,"id"),r=this.safeValue(e.subscriptions,i);let a=this.safeValue(r,"method");if(void 0!==a)return void a.call(this,e,t);const o={depthUpdate:this.handleOrderBook,trade:this.handleTrade,aggTrade:this.handleTrade,kline:this.handleOHLCV,markPrice_kline:this.handleOHLCV,indexPrice_kline:this.handleOHLCV,"1hTicker@arr":this.handleTickers,"4hTicker@arr":this.handleTickers,"1dTicker@arr":this.handleTickers,"24hrTicker@arr":this.handleTickers,"24hrMiniTicker@arr":this.handleTickers,"1hTicker":this.handleTickers,"4hTicker":this.handleTickers,"1dTicker":this.handleTickers,"24hrTicker":this.handleTickers,"24hrMiniTicker":this.handleTickers,bookTicker:this.handleBidsAsks,outboundAccountPosition:this.handleBalance,balanceUpdate:this.handleBalance,ACCOUNT_UPDATE:this.handleAcountUpdate,executionReport:this.handleOrderUpdate,ORDER_TRADE_UPDATE:this.handleOrderUpdate,forceOrder:this.handleLiquidation};let n=this.safeString(t,"e");if(Array.isArray(t)){const e=t[0];n=this.safeString(e,"e")+"@arr"}if(a=this.safeValue(o,n),void 0===a){if(void 0!==this.safeString(t,"id"))return void this.handleSubscriptionStatus(e,t);void 0===n&&"a"in t&&"b"in t&&this.handleBidsAsks(e,t)}else a.call(this,e,t)}}},902:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(9544),r=s(1510);class a extends i.A{describe(){const e=(new r.A).describe(),t=this.deepExtend(super.describe(),e);return this.deepExtend(t,{id:"binancecoinm",name:"Binance COIN-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:"https://developers.binance.com/en"},options:{fetchMarkets:["inverse"],defaultSubType:"inverse"}})}}},8788:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(9544),r=s(8228);class a extends i.A{describe(){const e=(new r.A).describe(),t=this.deepExtend(e,super.describe());return this.deepExtend(t,{id:"binanceus",name:"Binance US",countries:["US"],certified:!1,urls:{logo:"https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg",api:{ws:{spot:"wss://stream.binance.us:9443/ws"},web:"https://www.binance.us",sapi:"https://api.binance.us/sapi/v1",wapi:"https://api.binance.us/wapi/v3",public:"https://api.binance.us/api/v1",private:"https://api.binance.us/api/v3",v3:"https://api.binance.us/api/v3",v1:"https://api.binance.us/api/v1"},www:"https://www.binance.us",referral:"https://www.binance.us/?ref=35005074",doc:"https://github.com/binance-us/binance-official-api-docs",fees:"https://www.binance.us/en/fee/schedule"},options:{fetchCurrencies:!1,quoteOrderQty:!1,defaultType:"spot",fetchMarkets:["spot"]}})}}},8251:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(9544),r=s(2079);class a extends i.A{describe(){return this.deepExtend(super.describe(),{id:"binanceusdm",name:"Binance USDⓈ-M",urls:{logo:"https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg",doc:"https://developers.binance.com/en"},options:{fetchMarkets:["linear"],defaultSubType:"linear"},exceptions:{exact:{"-5021":r.InvalidOrder,"-5022":r.InvalidOrder,"-5028":r.InvalidOrder}}})}}},9456:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2480),r=s(2079),a=s(2931),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTrades:!0,watchTradesForSymbols:!1,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrders:!0,watchMyTrades:!0,watchTicker:!0,watchTickers:!0,watchBalance:!0},urls:{api:{ws:{spot:"wss://open-api-ws.bingx.com/market",linear:"wss://open-api-swap.bingx.com/swap-market",inverse:"wss://open-api-cswap-ws.bingx.com/market"}}},options:{listenKeyRefreshRate:354e4,ws:{gunzip:!0},swap:{timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"}},spot:{timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"60min","1d":"1day"}},watchBalance:{fetchBalanceSnapshot:!0,awaitBalanceSnapshot:!1},watchOrderBook:{depth:100,interval:500},watchOrderBookForSymbols:{depth:100,interval:500}},streaming:{keepAlive:18e5}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);let i,r,a;[i,t]=this.handleMarketTypeAndParams("watchTicker",s,t),[r,t]=this.handleSubTypeAndParams("watchTicker",s,t,"linear"),a="swap"===i?this.safeString(this.urls.api.ws,r):this.safeString(this.urls.api.ws,i);const o=s.id+"@ticker",n=this.getMessageHash("ticker",s.symbol),d={id:this.uuid(),dataType:o};return"swap"===i&&(d.reqType="sub"),await this.watch(a,n,this.extend(d,t),o)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"s"),r=e.url.indexOf("swap")>=0?"swap":"spot",a=this.safeMarket(i,void 0,void 0,r),o=a.symbol,n=this.parseWsTicker(s,a);this.tickers[o]=n,e.resolve(n,this.getMessageHash("ticker",o)),"all@ticker"===this.safeString(t,"dataType")&&e.resolve(n,this.getMessageHash("ticker"))}parseWsTicker(e,t=void 0){const s=this.safeInteger(e,"C"),i=this.safeString(e,"s");t=this.safeMarket(i,t);const r=this.safeString(e,"c");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"B"),bidVolume:this.safeString(e,"b"),ask:this.safeString(e,"A"),askVolume:this.safeString(e,"a"),vwap:void 0,open:this.safeString(e,"o"),close:r,last:r,previousClose:void 0,change:this.safeString(e,"p"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"q"),info:e},t)}async watchTickers(e=void 0,t={}){let s,i,a;await this.loadMarkets();const o=void 0!==(e=this.marketSymbols(e,void 0,!0,!0,!1));if(o&&(s=this.market(e[0])),[i,t]=this.handleMarketTypeAndParams("watchTickers",s,t),[a,t]=this.handleSubTypeAndParams("watchTickers",s,t,"linear"),"spot"===i)throw new r.NotSupported(this.id+" watchTickers is not supported for spot markets yet");if("inverse"===a)throw new r.NotSupported(this.id+" watchTickers is not supported for inverse markets yet");const n=[];if(o)for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);n.push(this.getMessageHash("ticker",i.symbol))}else n.push(this.getMessageHash("ticker"));const d=this.safeString(this.urls.api.ws,a),h={id:this.uuid(),dataType:"all@ticker"};"swap"===i&&(h.reqType="sub");const c=await this.watchMultiple(d,n,this.deepExtend(h,t),["all@ticker"]);if(this.newUpdates){const e={};return e[c.symbol]=c,e}return this.tickers}async watchOrderBookForSymbols(e,t=void 0,s={}){let i,a,o;const n=void 0!==(e=this.marketSymbols(e,void 0,!0,!0,!1));if(n&&(i=this.market(e[0])),[a,s]=this.handleMarketTypeAndParams("watchOrderBookForSymbols",i,s),[o,s]=this.handleSubTypeAndParams("watchOrderBookForSymbols",i,s,"linear"),"spot"===a)throw new r.NotSupported(this.id+" watchOrderBookForSymbols is not supported for spot markets yet");if("inverse"===o)throw new r.NotSupported(this.id+" watchOrderBookForSymbols is not supported for inverse markets yet");let d;t=this.getOrderBookLimitByMarketType(a,t),[d,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","interval",500),this.checkRequiredArgument("watchOrderBookForSymbols",d,"interval",[100,200,500,1e3]);const h="all@"+("depth"+t.toString()+"@"+d.toString()+"ms"),c=[];if(n)for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);c.push(this.getMessageHash("orderbook",i.symbol))}else c.push(this.getMessageHash("orderbook"));const l=this.safeString(this.urls.api.ws,o),u={id:this.uuid(),dataType:h};"swap"===a&&(u.reqType="sub");const p={symbols:e,limit:t,interval:d,params:s};return(await this.watchMultiple(l,c,this.deepExtend(u,s),[h],p)).limit()}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){const a=e.length;if(0!==a&&!Array.isArray(e[0]))throw new r.ArgumentsRequired(this.id+" watchOHLCVForSymbols() requires a an array like  [['BTC/USDT:USDT', '1m'], ['LTC/USDT:USDT', '5m']]");await this.loadMarkets();const o=[];let n,d,h,c;if(0!==a){let t=this.getListFromObjectValues(e,0);t=this.marketSymbols(t,void 0,!0,!0,!1),c=this.market(t[0])}if([n,i]=this.handleMarketTypeAndParams("watchOHLCVForSymbols",c,i),[d,i]=this.handleSubTypeAndParams("watchOHLCVForSymbols",c,i,"linear"),"spot"===n)throw new r.NotSupported(this.id+" watchOHLCVForSymbols is not supported for spot markets yet");if("inverse"===d)throw new r.NotSupported(this.id+" watchOHLCVForSymbols is not supported for inverse markets yet");const l=this.safeDict(this.options,n),u=this.safeDict(l,"timeframes",{});for(let t=0;t<e.length;t++){const s=e[t],i=s[0],a=s[1],n=this.market(i),d=this.safeString(u,a,a);if(void 0===h)h=d;else if(h!==d)throw new r.BadRequest(this.id+" watchOHLCVForSymbols requires all timeframes to be the same");o.push(this.getMessageHash("ohlcv",n.symbol,h))}const p="all@kline_"+h,f=this.safeString(this.urls.api.ws,d),m={id:this.uuid(),dataType:p};"swap"===n&&(m.reqType="sub");const g={limit:s,params:i},[v,y,w]=await this.watchMultiple(f,o,m,[p],g);this.newUpdates&&(s=w.getLimit(v,s));const b=this.filterBySinceLimit(w,t,s,0,!0);return this.createOHLCVObject(v,y,b)}getOrderBookLimitByMarketType(e,t=void 0){return void 0===t?t=100:"swap"===e||"future"===e?t=this.findNearestCeiling([5,10,20,50,100],t):"spot"===e&&(t=this.findNearestCeiling([20,100],t)),t}getMessageHash(e,t=void 0,s=void 0){let i=e;return i+=void 0!==t?"::"+t:"s",void 0!==s&&(i+="::"+s),i}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);let a,o,n;e=r.symbol,[a,i]=this.handleMarketTypeAndParams("watchTrades",r,i),[o,i]=this.handleSubTypeAndParams("watchTrades",r,i,"linear"),n="swap"===a?this.safeString(this.urls.api.ws,o):this.safeString(this.urls.api.ws,a);const d=r.id+"@trade",h="trade::"+e,c={id:this.uuid(),dataType:d};"swap"===a&&(c.reqType="sub");const l=await this.watch(n,h,this.extend(c,i),h);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"dataType").split("@")[0],r=e.url.indexOf("swap")>=0?"swap":"spot",o=this.safeMarket(i,void 0,void 0,r),n=o.symbol,d="trade::"+n;let h;h=Array.isArray(s)?this.parseTrades(s,o):[this.parseTrade(s,o)];let c=this.safeValue(this.trades,n);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[n]=c}for(let e=0;e<h.length;e++)c.append(h[e]);e.resolve(c,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);let r,a,o;[r,s]=this.handleMarketTypeAndParams("watchOrderBook",i,s),[a,s]=this.handleSubTypeAndParams("watchOrderBook",i,s,"linear"),o="swap"===r?this.safeString(this.urls.api.ws,a):this.safeString(this.urls.api.ws,r);let n,d="depth"+(t=this.getOrderBookLimitByMarketType(r,t)).toString();"spot"!==r&&(i.inverse||([n,s]=this.handleOptionAndParams(s,"watchOrderBook","interval",500),this.checkRequiredArgument("watchOrderBook",n,"interval",[100,200,500,1e3]),d=d+"@"+n.toString()+"ms"));const h=i.id+"@"+d,c=this.getMessageHash("orderbook",i.symbol),l={id:this.uuid(),dataType:h};"swap"===r&&(l.reqType="sub");let u={};u=i.inverse?{count:t,params:s}:{level:t,interval:n,params:s};return(await this.watch(o,c,this.deepExtend(l,s),h,u)).limit()}handleDelta(e,t){const s=this.safeFloat2(t,0,"p"),i=this.safeFloat2(t,1,"a");e.store(s,i)}handleOrderBook(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(t,"dataType"),r=i.split("@")[0],a="all"===r,o=this.safeString(s,"symbol",r),n=e.url.indexOf("swap")>=0?"swap":"spot",d=this.safeMarket(o,void 0,void 0,n),h=d.symbol;if(void 0===this.safeValue(this.orderbooks,h)){const t=i,s=e.subscriptions[t],r=this.safeInteger(s,"limit");this.orderbooks[h]=this.orderBook({},r)}const c=this.orderbooks[h];let l;l=d.inverse?this.parseOrderBook(s,h,void 0,"bids","asks","p","a"):this.parseOrderBook(s,h,void 0,"bids","asks",0,1),c.reset(l),this.orderbooks[h]=c;const u=this.getMessageHash("orderbook",h);if(e.resolve(c,u),a){const t=this.getMessageHash("orderbook");e.resolve(c,t)}}parseWsOHLCV(e,t=void 0){let s=t.spot?"t":"T";return t.swap&&(s=t.inverse?"t":"T"),[this.safeInteger(e,s),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}handleOHLCV(e,t){const s=e.url.indexOf("swap")>=0,i=this.safeString(t,"dataType"),r=i.split("@")[0],o="all"===r,n=this.safeString(t,"s",r),d=s?"swap":"spot",h=this.safeMarket(n,void 0,void 0,d);let c;if(s)c=h.inverse?[this.safeDict(t,"data",{})]:this.safeList(t,"data",[]);else{const e=this.safeDict(t,"data",{});c=[this.safeDict(e,"K",{})]}const l=h.symbol;this.ohlcvs[l]=this.safeValue(this.ohlcvs,l,{});const u=i.split("_")[1],p=this.safeDict(this.options,d),f=this.safeDict(p,"timeframes",{}),m=this.findTimeframe(u,f);if(void 0===this.safeValue(this.ohlcvs[l],u)){const t=i,s=e.subscriptions[t],r=this.safeInteger(s,"limit");this.ohlcvs[l][m]=new a.TG(r)}const g=this.ohlcvs[l][m];for(let e=0;e<c.length;e++){const t=c[e],s=this.parseWsOHLCV(t,h);g.append(s)}const v=[l,m,g],y=this.getMessageHash("ohlcv",l,m);if(e.resolve(v,y),o){const t=this.getMessageHash("ohlcv",void 0,m);e.resolve(v,t)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e);let n,d,h;if([n,a]=this.handleMarketTypeAndParams("watchOHLCV",o,a),[d,a]=this.handleSubTypeAndParams("watchOHLCV",o,a,"linear"),h="swap"===n?this.safeString(this.urls.api.ws,d):this.safeString(this.urls.api.ws,n),void 0===h)throw new r.BadRequest(this.id+" watchOHLCV is not supported for "+n+" markets.");const c=this.safeValue(this.options,n,{}),l=this.safeValue(c,"timeframes",{}),u=this.safeString(l,t,t),p=this.getMessageHash("ohlcv",o.symbol,t),f=o.id+"@kline_"+u,m={id:this.uuid(),dataType:f};"swap"===n&&(m.reqType="sub");const g={interval:u,params:a},v=(await this.watch(h,p,this.extend(m,a),f,g))[2];return this.newUpdates&&(i=v.getLimit(e,i)),this.filterBySinceLimit(v,s,i,0,!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o,n;await this.loadMarkets(),await this.authenticate(),void 0!==e&&(n=this.market(e),e=n.symbol),[a,i]=this.handleMarketTypeAndParams("watchOrders",n,i),[o,i]=this.handleSubTypeAndParams("watchOrders",n,i,"linear");const d="spot"===a,h=d?"spot:private":"swap:private";let c=d?"spot:order":"swap:order";void 0!==n&&(c+=":"+e);const l=this.uuid();let u,p;if("swap"===a){if("inverse"===o)throw new r.NotSupported(this.id+" watchOrders is not supported for inverse swap markets yet");u=this.safeString(this.urls.api.ws,o)}else u=this.safeString(this.urls.api.ws,a),p={id:l,reqType:"sub",dataType:"spot.executionReport"};const f=u+"?listenKey="+this.options.listenKey,m=await this.watch(f,c,p,h);return this.newUpdates&&(s=m.getLimit(e,s)),this.filterBySymbolSinceLimit(m,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let a,o,n;await this.loadMarkets(),await this.authenticate(),void 0!==e&&(n=this.market(e),e=n.symbol),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",n,i),[o,i]=this.handleSubTypeAndParams("watchMyTrades",n,i,"linear");const d="spot"===a,h=d?"spot:private":"swap:private";let c=d?"spot:mytrades":"swap:mytrades";void 0!==n&&(c+=":"+e);const l=this.uuid();let u,p;if("swap"===a){if("inverse"===o)throw new r.NotSupported(this.id+" watchMyTrades is not supported for inverse swap markets yet");u=this.safeString(this.urls.api.ws,o)}else u=this.safeString(this.urls.api.ws,a),p={id:l,reqType:"sub",dataType:"spot.executionReport"};const f=u+"?listenKey="+this.options.listenKey,m=await this.watch(f,c,p,h);return this.newUpdates&&(s=m.getLimit(e,s)),this.filterBySymbolSinceLimit(m,e,t,s,!0)}async watchBalance(e={}){let t,s;await this.loadMarkets(),await this.authenticate(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e,"linear");const i="spot"===t,a=i?"spot:balance":"swap:balance",o=i?"spot:balance":"swap:private";let n,d;const h=this.uuid();if("swap"===t){if("inverse"===s)throw new r.NotSupported(this.id+" watchBalance is not supported for inverse swap markets yet");d=this.safeString(this.urls.api.ws,s)}else d=this.safeString(this.urls.api.ws,t),n={id:h,dataType:"ACCOUNT_UPDATE"};const c=d+"?listenKey="+this.options.listenKey,l=this.client(c);let u,p;return this.setBalanceCache(l,t,s,o,e),[u,e]=this.handleOptionAndParams(e,"watchBalance","fetchBalanceSnapshot",!0),[p,e]=this.handleOptionAndParams(e,"watchBalance","awaitBalanceSnapshot",!1),u&&p&&await l.future(t+":fetchBalanceSnapshot"),await this.watch(c,a,n,o)}setBalanceCache(e,t,s,i,r){if(i in e.subscriptions)return;if(this.handleOptionAndParams(r,"watchBalance","fetchBalanceSnapshot",!0)){const i=t+":fetchBalanceSnapshot";i in e.futures||(e.future(i),this.spawn(this.loadBalanceSnapshot,e,i,t,s))}else this.balance[t]={}}async loadBalanceSnapshot(e,t,s,i){const r=await this.fetchBalance({type:s,subType:i});this.balance[s]=this.extend(r,this.safeValue(this.balance,s,{}));e.futures[t].resolve(),e.resolve(this.balance[s],s+":balance")}handleErrorMessage(e,t){const s=this.safeString(t,"code");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e)}}catch(t){e.reject(t)}return!0}async keepAliveListenKey(e={}){const t=this.safeString(this.options,"listenKey");if(void 0===t)return;try{await this.userAuthPrivatePutUserDataStream({listenKey:t})}catch(e){const s=["spot","linear","inverse"];for(let i=0;i<s.length;i++){const r=s[i],a=this.urls.api.ws[r]+"?listenKey="+t,o=this.client(a),n=Object.keys(o.futures);for(let t=0;t<n.length;t++){const s=n[t];o.reject(e,s)}}return this.options.listenKey=void 0,void(this.options.lastAuthenticatedTime=0)}const s=this.safeInteger(this.options,"listenKeyRefreshRate",36e5);this.delay(s,this.keepAliveListenKey,e)}async authenticate(e={}){const t=this.milliseconds(),s=this.safeInteger(this.options,"lastAuthenticatedTime",0),i=this.safeInteger(this.options,"listenKeyRefreshRate",36e5);if(t-s>i){const s=await this.userAuthPrivatePostUserDataStream();this.options.listenKey=this.safeString(s,"listenKey"),this.options.lastAuthenticatedTime=t,this.delay(i,this.keepAliveListenKey,e)}}async pong(e,t){try{if("Ping"===t)await e.send("Pong");else{const s=this.safeString(t,"ping"),i=this.safeString(t,"time");await e.send({pong:s,time:i})}}catch(t){const s=new r.NetworkError(this.id+" pong failed with error "+this.json(t));e.reset(s)}}handleOrder(e,t){const s="dataType"in t,i=this.safeValue2(t,"data","o",{});if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const r=this.orders,o=this.parseOrder(i);r.append(o);const n=o.symbol,d=s?"spot:order":"swap:order";e.resolve(r,d),e.resolve(r,d+":"+n)}handleMyTrades(e,t){const s="dataType"in t,i=this.safeDict2(t,"data","o",{});let r=this.myTrades;if(void 0===r){const e=this.safeInteger(this.options,"tradesLimit",1e3);r=new a.Pt(e),this.myTrades=r}const o=s?"spot":"swap",n=this.safeString(i,"s"),d=this.safeMarket(n,void 0,"-",o),h=this.parseTrade(i,d),c=h.symbol,l=s?"spot:mytrades":"swap:mytrades";r.append(h),e.resolve(r,l),e.resolve(r,l+":"+c)}handleBalance(e,t){const s=this.safeDict(t,"a",{}),i=this.safeList(s,"B",[]),r=this.safeInteger2(t,"T","E"),a="P"in s?"swap":"spot";a in this.balance||(this.balance[a]={}),this.balance[a].info=i,this.balance[a].timestamp=r,this.balance[a].datetime=this.iso8601(r);for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"a"),r=this.safeCurrencyCode(s),n=r in this.balance[a]?this.balance[a][r]:this.account();n.free=this.safeString(t,"wb");const d=this.safeString(t,"bc");void 0!==n.used&&(n.used=o.Y.stringSub(this.safeString(n,"used"),d)),this.balance[a][r]=n}this.balance[a]=this.safeBalance(this.balance[a]),e.resolve(this.balance[a],a+":balance")}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if("Ping"===t||"ping"in t)return void this.spawn(this.pong,e,t);const s=this.safeString(t,"dataType","");if(s.indexOf("@depth")>=0)return void this.handleOrderBook(e,t);if(s.indexOf("@ticker")>=0)return void this.handleTicker(e,t);if(s.indexOf("@trade")>=0)return void this.handleTrades(e,t);if(s.indexOf("@kline")>=0)return void this.handleOHLCV(e,t);if(s.indexOf("executionReport")>=0){const s=this.safeValue(t,"data",{});return"TRADE"===this.safeString(s,"x")&&this.handleMyTrades(e,t),void this.handleOrder(e,t)}const i=this.safeString(t,"e");if("ACCOUNT_UPDATE"===i&&this.handleBalance(e,t),"ORDER_TRADE_UPDATE"===i){this.handleOrder(e,t);const s=this.safeValue(t,"o",{}),i=this.safeString(s,"x"),r=this.safeString(s,"X");"TRADE"===i&&"FILLED"===r&&this.handleMyTrades(e,t)}const r=this.safeValue(t,"data");"24hTicker"===this.safeString(r,"e")&&this.handleTicker(e,t)}}},5343:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4524),r=s(7996),a=s(8959);class o extends i.A{describe(){const e=this.getDescribeForExtendedWsExchange(new a.A,new r.A,super.describe());return this.deepExtend(e,{id:"bitcoincom",name:"bitcoin.com",countries:["KN"],urls:{logo:"https://user-images.githubusercontent.com/1294454/97296144-514fa300-1861-11eb-952b-3d55d492200b.jpg",api:{ws:"wss://api.fmfw.io/api/2/ws"}},fees:{trading:{maker:this.parseNumber("0.0015"),taker:this.parseNumber("0.002")}}})}}},1038:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8657),r=s(2079),a=s(2931),o=s(5147),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!1,watchOHLCV:!1},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/1",private:"wss://api.bitfinex.com/ws/1"}}},options:{watchOrderBook:{prec:"P0",freq:"F0"},ordersLimit:1e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t).id,r=this.urls.api.ws.public,a=e+":"+i,o={event:"subscribe",channel:e,symbol:i,messageHash:a};return await this.watch(r,a,this.deepExtend(o,s),a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.subscribe("trades",e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),r=this.safeString(s,"pair"),o=i+":"+r,n=this.safeInteger(this.options,"tradesLimit",1e3),d=this.safeMarket(r),h=d.symbol,c=this.safeValue(t,1);let l=this.safeValue(this.trades,h);if(void 0===l&&(l=new a.I3(n),this.trades[h]=l),Array.isArray(c)){const e=this.parseTrades(c,d);for(let t=0;t<e.length;t++)l.append(e[t])}else{if("tu"!==this.safeString(t,1))return;const e=this.parseTrade(t,d);l.append(e)}e.resolve(l,o)}parseTrade(e,t=void 0){if(!Array.isArray(e))return super.parseTrade(e,t);const s=e.length;let i;"tu"===this.safeString(e,1)&&(i=this.safeString(e,s-4));const r=this.safeTimestamp(e,s-3),a=this.safeString(e,s-2);let n,d=this.safeString(e,s-1);void 0!==d&&(n=o.Y.stringGt(d,"0")?"buy":"sell",d=o.Y.stringAbs(d));const h=this.safeString(e,2).split("-");let c=this.safeString(h,1);void 0!==c&&(c=c.replace("t",""));const l=this.safeSymbol(c,t);return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:l,id:i,order:undefined,type:void 0,takerOrMaker:undefined,side:n,price:a,amount:d,cost:void 0,fee:void 0})}handleTicker(e,t,s){const i=this.safeString(s,"pair"),r=this.safeSymbol(i),a="ticker:"+i,n=this.safeString(t,7),d=this.safeString(t,5);let h;void 0!==n&&void 0!==d&&(h=o.Y.stringSub(n,d));const c={symbol:r,timestamp:void 0,datetime:void 0,high:this.safeFloat(t,9),low:this.safeFloat(t,10),bid:this.safeFloat(t,1),bidVolume:void 0,ask:this.safeFloat(t,3),askVolume:void 0,vwap:void 0,open:this.parseNumber(h),close:this.parseNumber(n),last:this.parseNumber(n),previousClose:void 0,change:this.parseNumber(d),percentage:this.safeFloat(t,6),average:void 0,baseVolume:this.safeFloat(t,8),quoteVolume:void 0,info:t};this.tickers[r]=c,e.resolve(c,a)}async watchOrderBook(e,t=void 0,s={}){if(void 0!==t&&25!==t&&100!==t)throw new r.ExchangeError(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),a={prec:this.safeString(i,"prec","P0"),freq:this.safeString(i,"freq","F0"),len:t};return(await this.subscribe("book",e,this.deepExtend(a,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"pair"),r=this.safeSymbol(i),a="book:"+i,n="R0"===this.safeString(s,"prec","P0");if(Array.isArray(t[1])){const i=this.safeInteger(s,"len");this.orderbooks[r]=n?this.indexedOrderBook({},i):this.countedOrderBook({},i);const o=this.orderbooks[r];if(n){const e=t[1];for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,0),r=this.safeFloat(s,1),a=s[2],n=a<0?-a:a;o[a<0?"asks":"bids"].storeArray([r,n,i])}}else{const e=t[1];for(let t=0;t<e.length;t++){const s=e[t],i=s[2],r=i<0?-i:i;o[i<0?"asks":"bids"].storeArray([s[0],r,s[1]])}}e.resolve(o,a)}else{const s=this.orderbooks[r];if(n){const e=this.safeString(t,1),i=this.safeString(t,2),r=t[3],a=r<0?-r:r,n=s[r<0?"asks":"bids"],d=o.Y.stringGt(i,"0")?a:"0";n.storeArray([this.parseNumber(i),this.parseNumber(d),e])}else{const e=t[3],i=e<0?-e:e;s[e<0?"asks":"bids"].storeArray([t[1],i,t[2]])}e.resolve(s,a)}}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i=s.future("authenticated"),r="auth";if(void 0===this.safeValue(s.subscriptions,r)){const e=this.milliseconds(),s="AUTH"+e.toString(),i=this.hmac(this.encode(s),this.encode(this.secret),n.qt,"hex"),a={apiKey:this.apiKey,authSig:i,authNonce:e,authPayload:s,event:r,filter:["trading","wallet"]};this.spawn(this.watch,t,r,a,1)}return await i}handleAuthenticationMessage(e,t){if("OK"===this.safeString(t,"status")){this.safeValue(e.futures,"authenticated").resolve(!0)}else{const s=new r.AuthenticationError(this.json(t));e.reject(s,"authenticated");const i=this.safeString(t,"event");i in e.subscriptions&&delete e.subscriptions[i]}}async watchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.urls.api.ws.private;return await this.authenticate(),await this.watch(i,e,void 0,1)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),void 0!==e&&(e=this.symbol(e));const r=this.urls.api.ws.private,a=await this.watch(r,"os",void 0,1);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]);if("os"===this.safeString(t,1))for(let t=0;t<i.length;t++){const s=i[t];this.handleOrder(e,s)}else this.handleOrder(e,i);void 0!==this.orders&&e.resolve(this.orders,"os")}parseWsOrderStatus(e){return this.safeString({ACTIVE:"open",CANCELED:"canceled"},e,e)}handleOrder(e,t){const s=this.safeString(t,0),i=this.safeString(t,1),r=this.safeSymbol(i);let n=this.safeString(t,2),d=this.safeString(t,3),h="buy";o.Y.stringLt(n,"0")&&(n=o.Y.stringAbs(n),d=o.Y.stringAbs(d),h="sell");let c=this.safeString(t,4);c.indexOf("LIMIT")>-1?c="limit":c.indexOf("MARKET")>-1&&(c="market");const l=this.parseWsOrderStatus(this.safeString(t,5)),u=this.safeString(t,6),p=this.safeString(t,8),f=this.parse8601(p),m=this.safeOrder({info:t,id:s,clientOrderId:void 0,timestamp:f,datetime:this.iso8601(f),lastTradeTimestamp:void 0,symbol:r,type:c,side:h,price:u,stopPrice:void 0,triggerPrice:void 0,average:void 0,amount:n,remaining:d,filled:void 0,status:l,fee:void 0,cost:void 0,trades:void 0});if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}return this.orders.append(m),e.resolve(m,s),m}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0);if("hb"===t[1])return;const i=this.safeValue(e.subscriptions,s,{}),r=this.safeString(i,"channel"),a=this.safeString(t,1),o={book:this.handleOrderBook,ticker:this.handleTicker,trades:this.handleTrades,os:this.handleOrders,on:this.handleOrders,oc:this.handleOrders},n=this.safeValue2(o,r,a);void 0!==n&&n.call(this,e,t,i)}else{const s=this.safeString(t,"event");if(void 0!==s){const i={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}}}},8255:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8703),r=s(5147),a=s(2079),o=s(2931),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0,watchOrders:!0},urls:{api:{ws:{public:"wss://api-pub.bitfinex.com/ws/2",private:"wss://api.bitfinex.com/ws/2"}}},options:{watchOrderBook:{prec:"P0",freq:"F0",checksum:!0},ordersLimit:1e3}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t).id,r=this.urls.api.ws.public,a=this.client(r),o=e+":"+i,n={event:"subscribe",channel:e,symbol:i},d=await this.watch(r,o,this.deepExtend(n,s),o,{checksum:!1});return this.safeBool(this.options,"checksum",!0)&&!a.subscriptions[o].checksum&&"book"===e&&(a.subscriptions[o].checksum=!0,await a.send({event:"conf",flags:131072})),d}async subscribePrivate(e){await this.loadMarkets(),await this.authenticate();const t=this.urls.api.ws.private;return await this.watch(t,e,void 0,1)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeString(this.timeframes,t,t),n="candles",d="trade:"+o+":"+a.id,h=n+":"+o+":"+a.id,c={event:"subscribe",channel:n,key:d},l=this.urls.api.ws.public,u=await this.watch(l,h,this.deepExtend(c,r),h);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t,s){const i=this.safeValue(t,1,[]);let r;const a=this.safeValue(i,0);r=Array.isArray(a)?i:[i];const n=this.safeValue(s,"channel"),d=this.safeString(s,"key"),h=d.split(":"),c=this.safeString(h,1);let l=d;l=l.replace("trade:",""),l=l.replace(c+":","");const u=this.safeMarket(l),p=this.findTimeframe(c),f=u.symbol,m=n+":"+c+":"+l;this.ohlcvs[f]=this.safeValue(this.ohlcvs,f,{});let g=this.safeValue(this.ohlcvs[f],p);if(void 0===g){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);g=new o.TG(e),this.ohlcvs[f][p]=g}const v=r.length;for(let e=0;e<v;e++){const t=r[v-e-1],s=this.parseOHLCV(t,u);g.append(s)}e.resolve(g,m)}async watchTrades(e,t=void 0,s=void 0,i={}){const r=await this.subscribe("trades",e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="myTrade";if(void 0!==e){r+=":"+this.market(e).id}const a=await this.subscribePrivate(r);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleMyTrade(e,t,s={}){const i="myTrade",r=this.safeValue(t,2),a=this.parseWsTrade(r),n=a.symbol,d=i+":"+this.market(n).id;if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new o.Pt(e)}const h=this.myTrades;h.append(a),this.myTrades=h,e.resolve(h,i),e.resolve(h,d)}handleTrades(e,t,s){const i=this.safeValue(s,"channel"),r=this.safeString(s,"symbol"),a=this.safeMarket(r),n=i+":"+r,d=this.safeInteger(this.options,"tradesLimit",1e3),h=a.symbol;let c=this.safeValue(this.trades,h);void 0===c&&(c=new o.I3(d),this.trades[h]=c);if(2===t.length){const e=this.safeList(t,1,[]),s=e.length;for(let t=0;t<s;t++){const i=s-t-1,r=this.parseWsTrade(e[i],a);c.append(r)}}else{if("tu"===this.safeString(t,1))return;const e=this.safeValue(t,2,[]),s=this.parseWsTrade(e,a);c.append(s)}e.resolve(c,n)}parseWsTrade(e,t=void 0){const s=e.length<=8;let i=s?void 0:this.safeString(e,1);const a=s?1:2,o=s?3:5,n=s?2:4;i=(t=this.safeMarket(i,t)).id;let d=this.safeString(e,6);void 0!==d&&(d.indexOf("LIMIT")>-1?d="limit":d.indexOf("MARKET")>-1&&(d="market"));const h=s?void 0:this.safeString(e,3),c=this.safeString(e,0),l=this.safeInteger(e,a),u=this.safeString(e,o),p=this.safeString(e,n),f=this.parseNumber(r.Y.stringAbs(p));let m;void 0!==f&&(m=r.Y.stringGt(p,"0")?"buy":"sell");const g=this.safeSymbol(i,t),v=this.safeString(e,9);let y;if(void 0!==v){const t=this.safeString(e,10);y={cost:v,currency:this.safeCurrencyCode(t)}}const w=this.safeInteger(e,8);let b;return void 0!==w&&(b=-1===w?"taker":"maker"),this.safeTrade({info:e,timestamp:l,datetime:this.iso8601(l),symbol:g,id:c,order:h,type:d,takerOrMaker:b,side:m,price:u,amount:f,cost:void 0,fee:y},t)}handleTicker(e,t,s){const i=this.safeValue(t,1),r=this.safeString(s,"symbol"),a=this.safeMarket(r),o=this.safeSymbol(r),n=this.parseWsTicker(i,a),d="ticker:"+r;this.tickers[o]=n,e.resolve(n,d)}parseWsTicker(e,t=void 0){const s=(t=this.safeMarket(void 0,t)).symbol,i=this.safeString(e,6),r=this.safeString(e,4);return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,8),low:this.safeString(e,9),bid:this.safeString(e,0),bidVolume:this.safeString(e,1),ask:this.safeString(e,2),askVolume:this.safeString(e,3),vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:r,percentage:this.safeString(e,5),average:void 0,baseVolume:this.safeString(e,7),quoteVolume:void 0,info:e},t)}async watchOrderBook(e,t=void 0,s={}){if(void 0!==t&&25!==t&&100!==t)throw new a.ExchangeError(this.id+" watchOrderBook limit argument must be undefined, 25 or 100");const i=this.safeValue(this.options,"watchOrderBook",{}),r={prec:this.safeString(i,"prec","P0"),freq:this.safeString(i,"freq","F0")};void 0!==t&&(r.len=t);return(await this.subscribe("book",e,this.deepExtend(r,s))).limit()}handleOrderBook(e,t,s){const i=this.safeString(s,"symbol"),a=this.safeSymbol(i),o="book:"+i,n="R0"===this.safeString(s,"prec","P0");if(a in this.orderbooks){const s=this.orderbooks[a],i=t[1],d=this.orderbooks[a];if(n){const e=this.safeString(i,1),t=i[2],s=t<0?-t:t,a=d[t<0?"asks":"bids"],o=r.Y.stringGt(e,"0")?s:"0",n=this.safeString(i,0);a.storeArray([this.parseNumber(e),this.parseNumber(o),n])}else{const e=this.safeString(i,2),t=this.safeString(i,1),s=this.safeString(i,0),a=r.Y.stringLt(e,"0")?r.Y.stringNeg(e):e;d[r.Y.stringLt(e,"0")?"asks":"bids"].storeArray([this.parseNumber(s),this.parseNumber(a),this.parseNumber(t)])}e.resolve(s,o)}else{const i=this.safeInteger(s,"len");this.orderbooks[a]=n?this.indexedOrderBook({},i):this.countedOrderBook({},i);const r=this.orderbooks[a];if(n){const e=t[1];for(let t=0;t<e.length;t++){const s=e[t],i=s[2],a=i<0?-i:i,o=r[i<0?"asks":"bids"],n=this.safeString(s,0),d=this.safeFloat(s,1);o.storeArray([d,a,n])}}else{const e=t[1];for(let t=0;t<e.length;t++){const s=e[t],i=this.safeNumber(s,2),a=this.safeNumber(s,1),o=this.safeNumber(s,0),n=i<0?-i:i;r[i<0?"asks":"bids"].storeArray([o,n,a])}}r.symbol=a,e.resolve(r,o)}}handleChecksum(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeSymbol(i),o="book:"+i,n=this.safeValue(this.orderbooks,r);if(void 0===n)return;const d=[],h=n.bids,c=n.asks,l="R0"===this.safeString(s,"prec","P0")?2:0;for(let e=0;e<25;e++){const t=this.safeValue(h,e),s=this.safeValue(c,e);if(void 0!==t&&(d.push(this.numberToString(h[e][l])),d.push(this.numberToString(h[e][1]))),void 0!==s){d.push(this.numberToString(c[e][l]));const t=c[e][1];d.push(this.numberToString(-t))}}const u=d.join(":"),p=this.crc32(u,!0);if(this.safeInteger(t,2)!==p){delete e.subscriptions[o],delete this.orderbooks[r];if(this.handleOption("watchOrderBook","checksum",!0)){const t=new a.ChecksumError(this.id+" "+this.orderbookChecksumMessage(r));e.reject(t,o)}}}async watchBalance(e={}){await this.loadMarkets();const t=this.safeString(e,"wallet","exchange");e=this.omit(e,"wallet");const s="balance:"+t;return await this.subscribePrivate(s)}handleBalance(e,t,s){let i;i="ws"===this.safeValue(t,1)?this.safeValue(t,2):[this.safeValue(t,2)];const r={};for(let e=0;e<i.length;e++){const s=i[e],a=this.safeString(s,1),o=this.safeCurrencyCode(a),n=this.parseWsBalance(s),d=this.safeString(s,0),h=this.safeValue(this.balance,d,{});h[o]=n,h.info=t,this.balance[d]=this.safeBalance(h),r[d]=!0}const a=Object.keys(r);for(let t=0;t<a.length;t++){const s=a[t],i="balance:"+s;e.resolve(this.balance[s],i)}}parseWsBalance(e){const t=this.safeString(e,2),s=this.safeString(e,4),i=this.account();return void 0!==s&&(i.free=s),i.total=t,i}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"chanId");return e.subscriptions[s]=t,t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s=this.milliseconds(),r="AUTH"+s.toString(),a=this.hmac(this.encode(r),this.encode(this.secret),n.qt,"hex"),o="auth",d={apiKey:this.apiKey,authSig:a,authNonce:s,authPayload:r,event:o},h=this.extend(d,e);this.watch(t,i,h,i)}return await r}handleAuthenticationMessage(e,t){const s="authenticated";if("OK"===this.safeString(t,"status")){this.safeValue(e.futures,s).resolve(!0)}else{const i=new a.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="orders";if(void 0!==e){r+=":"+this.market(e).id}const a=await this.subscribePrivate(r);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrders(e,t,s){const i=this.safeValue(t,2,[]),r=this.safeString(t,1);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new o.Pt(e)}const a=this.orders,n={};if("os"===r){if(0===i.length)return;for(let e=0;e<i.length;e++){const t=i[e],s=this.parseWsOrder(t);n[s.symbol]=!0,a.append(s)}}else{const e=this.parseWsOrder(i);a.append(e);n[e.symbol]=!0}const d="orders";e.resolve(this.orders,d);const h=Object.keys(n);for(let t=0;t<h.length;t++){const s=h[t],i=d+":"+this.market(s).id;e.resolve(this.orders,i)}}parseWsOrderStatus(e){return this.safeString({ACTIVE:"open",CANCELED:"canceled",EXECUTED:"closed",PARTIALLY:"open"},e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,0),i=this.safeString(e,1),a=this.safeString(e,3),o=this.safeSymbol(a);t=this.safeMarket(o);let n=this.safeString(e,7),d="buy";r.Y.stringLt(n,"0")&&(n=r.Y.stringAbs(n),d="sell");const h=r.Y.stringAbs(this.safeString(e,6));let c=this.safeString(e,8);c.indexOf("LIMIT")>-1?c="limit":c.indexOf("MARKET")>-1&&(c="market");const l=this.safeString(e,13).split(" "),u=this.safeString(l,0),p=this.parseWsOrderStatus(u),f=this.safeString(e,16),m=this.safeInteger2(e,5,4),g=this.safeString(e,17),v=this.omitZero(this.safeString(e,18));return this.safeOrder({info:e,id:s,clientOrderId:i,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:void 0,symbol:o,type:c,side:d,price:f,stopPrice:v,triggerPrice:v,average:g,amount:n,remaining:h,filled:void 0,status:p,fee:void 0,cost:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeString(t,0);if(Array.isArray(t)){if("hb"===t[1])return;const i=this.safeValue(e.subscriptions,s,{}),r=this.safeString(i,"channel"),a=this.safeString(t,1),o={book:this.handleOrderBook,cs:this.handleChecksum,candles:this.handleOHLCV,ticker:this.handleTicker,trades:this.handleTrades},n={os:this.handleOrders,ou:this.handleOrders,on:this.handleOrders,oc:this.handleOrders,wu:this.handleBalance,ws:this.handleBalance,tu:this.handleMyTrade};let d;d="0"===s?this.safeValue(n,a):this.safeValue2(o,a,r),void 0!==d&&d.call(this,e,t,i)}else{const s=this.safeString(t,"event");if(void 0!==s){const i={info:this.handleSystemStatus,subscribed:this.handleSubscriptionStatus,auth:this.handleAuthenticationMessage},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}}}},205:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7757),r=s(2079),a=s(5147),o=s(2931),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,createOrderWs:!1,editOrderWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!1,cancelOrdersWs:!1,cancelAllOrdersWs:!1,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOHLCVForSymbols:!1,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,watchPositions:!0},urls:{api:{ws:{public:"wss://ws.bitget.com/v2/ws/public",private:"wss://ws.bitget.com/v2/ws/private"}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1H","4h":"4H","6h":"6H","12h":"12H","1d":"1D","1w":"1W"},watchOrderBook:{checksum:!0}},streaming:{ping:this.ping},exceptions:{ws:{exact:{30001:r.BadRequest,30002:r.AuthenticationError,30003:r.BadRequest,30004:r.AuthenticationError,30005:r.AuthenticationError,30006:r.RateLimitExceeded,30007:r.RateLimitExceeded,30011:r.AuthenticationError,30012:r.AuthenticationError,30013:r.AuthenticationError,30014:r.BadRequest,30015:r.AuthenticationError,30016:r.BadRequest},broad:{}}}})}getInstType(e,t={}){let s,i;return void 0===e?[s,t]=this.handleProductTypeAndParams(void 0,t):e.swap||e.future?[s,t]=this.handleProductTypeAndParams(e,t):s="SPOT",[i,t]=this.handleOptionAndParams(t,"getInstType","instType",s),s=i,[s,t]}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+(e=s.symbol);let r;[r,t]=this.getInstType(s,t);const a={instType:r,channel:"ticker",instId:s.id};return await this.watchPublic(i,a,t)}async unWatchTicker(e,t={}){return await this.loadMarkets(),await this.unWatchChannel(e,"ticker","ticker",t)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=this.market(e[0]);let i;[i,t]=this.getInstType(s,t);const r=[],a=[];for(let t=0;t<e.length;t++){const s=e[t],o={instType:i,channel:"ticker",instId:this.market(s).id};r.push(o),a.push("ticker:"+s)}const o=await this.watchPublicMultiple(a,r,t);if(this.newUpdates){const e={};return e[o.symbol]=o,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.parseWsTicker(t),i=s.symbol;this.tickers[i]=s;const r="ticker:"+i;e.resolve(s,r)}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"arg",{}),i=this.safeValue(e,"data",[]),r=this.safeValue(i,0,{}),o=this.safeInteger(r,"ts"),n="SPOT"===this.safeString(s,"instType")?"spot":"contract",d=this.safeString(r,"instId");t=this.safeMarket(d,t,void 0,n);const h=this.safeString(r,"lastPr"),c=this.safeString(r,"change24h"),l=a.Y.stringMul(c,"100");return this.safeTicker({symbol:t.symbol,timestamp:o,datetime:this.iso8601(o),high:this.safeString(r,"high24h"),low:this.safeString(r,"low24h"),bid:this.safeString(r,"bidPr"),bidVolume:this.safeString(r,"bidSz"),ask:this.safeString(r,"askPr"),askVolume:this.safeString(r,"askSz"),vwap:void 0,open:this.safeString(r,"open24h"),close:h,last:h,previousClose:void 0,change:void 0,percentage:l,average:void 0,baseVolume:this.safeString(r,"baseVolume"),quoteVolume:this.safeString(r,"quoteVolume"),info:r},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeValue(this.options,"timeframes"),n=this.safeString(o,t),d="candles:"+t+":"+e;let h;[h,r]=this.getInstType(a,r);const c={instType:h,channel:"candle"+n,instId:a.id},l=await this.watchPublic(d,c,r);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}async unWatchOHLCV(e,t="1m",s={}){await this.loadMarkets();const i=this.safeDict(this.options,"timeframes"),r="candle"+this.safeString(i,t);return await this.unWatchChannel(e,r,"candles:"+t,s)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i="SPOT"===this.safeString(s,"instType")?"spot":"contract",r=this.safeString(s,"instId"),a=this.safeMarket(r,void 0,void 0,i),n=a.symbol;this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});const d=this.safeString(s,"channel").replace("candle",""),h=this.safeValue(this.options,"timeframes"),c=this.findTimeframe(d,h);let l=this.safeValue(this.ohlcvs[n],c);if(void 0===l){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new o.TG(e),this.ohlcvs[n][c]=l}const u=this.safeValue(t,"data",[]);for(let e=0;e<u.length;e++){const t=this.parseWsOHLCV(u[e],a);l.append(t)}const p="candles:"+c+":"+n;e.resolve(l,p)}parseWsOHLCV(e,t=void 0){const s=t.inverse?6:5;return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,s)]}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async unWatchOrderBook(e,t={}){await this.loadMarkets();let s="books";const i=this.safeInteger(t,"limit");return 1!==i&&5!==i&&15!==i||(t=this.omit(t,"limit"),s+=i.toString()),await this.unWatchChannel(e,s,"orderbook",t)}async unWatchChannel(e,t,s,i={}){await this.loadMarkets();const r=this.market(e),a="unsubscribe:"+s+":"+r.symbol;let o;[o,i]=this.getInstType(r,i);const n={instType:o,channel:t,instId:r.id};return await this.unWatchPublic(a,n,i)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets(),e=this.marketSymbols(e);let i="books",r=!0;1!==t&&5!==t&&15!==t||(i+=t.toString(),r=!1);const a=[],o=[];for(let t=0;t<e.length;t++){const r=e[t],n=this.market(r);let d;[d,s]=this.getInstType(n,s);const h={instType:d,channel:i,instId:n.id};a.push(h),o.push("orderbook:"+r)}const n=await this.watchPublicMultiple(o,a,s);return r?n.limit():n}handleOrderBook(e,t){const s=this.safeValue(t,"arg"),i=this.safeString(s,"channel"),r="SPOT"===this.safeString(s,"instType")?"spot":"contract",a=this.safeString(s,"instId"),o=this.safeMarket(a,void 0,void 0,r).symbol,n="orderbook:"+o,d=this.safeValue(t,"data"),h=this.safeValue(d,0),c=this.safeInteger(h,"ts");if("books"===i){if(!(o in this.orderbooks)){const e=this.countedOrderBook({});e.symbol=o,this.orderbooks[o]=e}const s=this.orderbooks[o],i=this.safeValue(h,"asks",[]),r=this.safeValue(h,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,r),s.timestamp=c,s.datetime=this.iso8601(c);const a=this.safeBool(this.options,"checksum",!0);if(!("snapshot"===this.safeString(t,"action"))&&a){const t=s.asks,i=s.bids,r=t.length,a=i.length,d=[];for(let e=0;e<25;e++)e<a&&(d.push(i[e][2][0]),d.push(i[e][2][1])),e<r&&(d.push(t[e][2][0]),d.push(t[e][2][1]));const c=d.join(":");if(this.crc32(c,!0)!==this.safeInteger(h,"checksum"))return void this.spawn(this.handleCheckSumError,e,o,n)}}else{const e=this.orderBook({}),t=this.parseOrderBook(h,o,c);e.reset(t),this.orderbooks[o]=e}e.resolve(this.orderbooks[o],n)}async handleCheckSumError(e,t,s){await this.unWatchOrderBook(t);const i=new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(t));e.reject(i,s)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);s.push(t),e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");await this.loadMarkets(),e=this.marketSymbols(e);const a=[],o=[];for(let t=0;t<e.length;t++){const s=e[t],r=this.market(s);let n;[n,i]=this.getInstType(r,i);const d={instType:n,channel:"trade",instId:r.id};a.push(d),o.push("trade:"+s)}const n=await this.watchPublicMultiple(o,a,i);if(this.newUpdates){const e=this.safeValue(n,0),t=this.safeString(e,"symbol");s=n.getLimit(t,s)}return this.filterBySinceLimit(n,t,s,"timestamp",!0)}async unWatchTrades(e,t={}){return await this.loadMarkets(),await this.unWatchChannel(e,"trade","trade",t)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i="SPOT"===this.safeString(s,"instType")?"spot":"contract",r=this.safeString(s,"instId"),a=this.safeMarket(r,void 0,void 0,i),n=a.symbol;let d=this.safeValue(this.trades,n);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new o.I3(e),this.trades[n]=d}const h=this.safeList(t,"data",[]),c=h.length;for(let e=0;e<c;e++){const t=h[c-e-1],s=this.parseWsTrade(t,a);d.append(s)}const l="trade:"+n;e.resolve(d,l)}parseWsTrade(e,t=void 0){const s=this.safeString2(e,"symbol","instId"),i=void 0!==this.safeString(e,"posMode")?"contract":"spot";void 0===t&&(t=this.safeMarket(s,void 0,void 0,i));const r=this.safeIntegerN(e,["uTime","cTime","ts"]),o=this.safeList(e,"feeDetail",[]),n=this.safeDict(o,0);let d;if(void 0!==n){const e=this.safeString(n,"feeCoin"),t=this.safeCurrencyCode(e);d={cost:a.Y.stringAbs(this.safeString(n,"totalFee")),currency:t}}return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),order:this.safeString(e,"orderId"),timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:this.safeString(e,"orderType"),side:this.safeString(e,"side"),takerOrMaker:this.safeString(e,"tradeScope"),price:this.safeString2(e,"priceAvg","price"),amount:this.safeString2(e,"size","baseVolume"),cost:this.safeString2(e,"amount","quoteVolume"),fee:d},t)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a="";let o="USDT-FUTURES";e=this.marketSymbols(e),this.isEmpty(e)||(r=this.getMarketFromSymbols(e),[o,i]=this.getInstType(r,i)),a=o+":positions"+a;const n={instType:o,channel:"positions",instId:"default"},d=await this.watchPrivate(a,"positions",n,i);return this.newUpdates?d:this.filterBySymbolsSinceLimit(d,e,t,s,!0)}handlePositions(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"instType","");void 0===this.positions&&(this.positions={}),i in this.positions||(this.positions[i]=new o.Hk);const r=this.positions[i],a=this.safeValue(t,"data",[]);if(0===a.length)return;const n=[];for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"instId"),i=this.safeMarket(s,void 0,void 0,"contract"),o=this.parseWsPosition(t,i);n.push(o),r.append(o)}const d=this.findMessageHashes(e,i+":positions::");for(let t=0;t<d.length;t++){const s=d[t],i=s.split("::")[1].split(","),r=this.filterByArray(n,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(n,i+":positions")}parseWsPosition(e,t=void 0){const s=this.safeString(e,"instId"),i=this.safeString(e,"marginMode"),r=this.getSupportedMapping(i,{crossed:"cross",isolated:"isolated"}),o="hedge_mode"===this.safeString(e,"posMode"),n=this.safeInteger2(e,"uTime","cTime"),d=this.safeString(e,"unrealizedPLR"),h=a.Y.stringMul(d,"100");let c;return void 0!==t&&(c=t.contractSize),this.safePosition({info:e,id:this.safeString(e,"posId"),symbol:this.safeSymbol(s,t,void 0,"contract"),notional:void 0,marginMode:r,liquidationPrice:this.safeNumber(e,"liquidationPrice"),entryPrice:this.safeNumber(e,"openPriceAvg"),unrealizedPnl:this.safeNumber(e,"unrealizedPL"),percentage:this.parseNumber(h),contracts:this.safeNumber(e,"total"),contractSize:c,markPrice:void 0,side:this.safeString(e,"holdSide"),hedged:o,timestamp:n,datetime:this.iso8601(n),maintenanceMargin:void 0,maintenanceMarginPercentage:this.safeNumber(e,"keepMarginRate"),collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:this.safeNumber(e,"leverage"),marginRatio:this.safeNumber(e,"marginRate")})}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let a,o,n;await this.loadMarkets(),[n,i]=this.isTriggerOrder(i);let d=n?"triggerOrder":"order",h="order:trades";void 0!==e&&(a=this.market(e),e=a.symbol,o=a.id,d=d+":"+e);const c=this.safeString(i,"productType");let l,u,p;if([l,i]=this.handleMarketTypeAndParams("watchOrders",a,i),[u,i]=this.handleSubTypeAndParams("watchOrders",a,i,"linear"),("spot"===l||"margin"===l)&&void 0===e)throw new r.ArgumentsRequired(this.id+" watchOrders requires a symbol argument for "+l+" markets.");void 0===c&&"spot"!==l&&void 0===e?d=d+":"+u:"USDT-FUTURES"===c?d+=":linear":"COIN-FUTURES"===c?d+=":inverse":"USDC-FUTURES"===c&&(d+=":usdcfutures"),[p,i]=this.getInstType(a,i),"spot"===l&&(h=h+":"+e),n&&(h+=":stop");const f="spot"===l||"margin"===l?o:"default";let m,g=n?"orders-algo":"orders";[m,i]=this.handleMarginModeAndParams("watchOrders",i),void 0!==m&&(p="MARGIN",d=d+":"+m,g="isolated"===m?"orders-isolated":"orders-crossed"),h=h+":"+p;const v={instType:p,channel:g,instId:f},y=await this.watchPrivate(d,h,v,i);return this.newUpdates&&(s=y.getLimit(e,s)),this.filterBySymbolSinceLimit(y,e,t,s,!0)}handleOrder(e,t){const s=this.safeDict(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeString(s,"instType"),a=this.safeString(s,"instId");let n;n="SPOT"===r||"MARGIN"===r?"spot":"contract";const d="USDT-FUTURES"===r,h="COIN-FUTURES"===r,c="USDC-FUTURES"===r,l=this.safeValue(t,"data",[]);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new o.Pt(e),this.triggerOrders=new o.Pt(e)}const u="orders-algo"===i||"ordersAlgo"===i,p=u?this.triggerOrders:this.orders,f=u?"triggerOrder":"order",m={};for(let e=0;e<l.length;e++){const t=l[e],s=this.safeString(t,"instId",a),i=this.safeMarket(s,void 0,void 0,n),r=this.parseWsOrder(t,i);p.append(r);m[r.symbol]=!0}const g=Object.keys(m);for(let t=0;t<g.length;t++){let s=f+":"+g[t];"orders-crossed"===i?s+=":cross":"orders-isolated"===i&&(s+=":isolated"),e.resolve(p,s)}e.resolve(p,f),d&&e.resolve(p,"order:linear"),h&&e.resolve(p,"order:inverse"),c&&e.resolve(p,"order:usdcfutures")}parseWsOrder(e,t=void 0){const s=!("posMode"in e),i="loanType"in e,r=this.safeString(e,"instId");t=this.safeMarket(r,t);const o=this.safeInteger(e,"cTime"),n=t.symbol,d=this.safeString(e,"status"),h=this.safeValue(e,"feeDetail",[]),c=this.safeValue(h,0),l=this.safeString(c,"fee");let u;if(void 0!==l){const e=this.safeString(c,"feeCoin");u={cost:this.parseNumber(a.Y.stringAbs(l)),currency:this.safeCurrencyCode(e)}}const p=this.safeNumber(e,"triggerPrice"),f=void 0!==p;let m;f?s&&f&&(m=this.safeNumber(e,"executePrice")):m=this.safeNumber(e,"price");const g=this.omitZero(this.safeString2(e,"priceAvg","fillPrice")),v=this.safeString(e,"side"),y=this.safeString(e,"orderType"),w=this.omitZero(this.safeString(e,"accBaseVolume")),b=this.omitZero(this.safeString(e,"newSize")),S="market"===y,k="buy"===v;let O,T,P,I,x=this.safeString(e,"accBaseVolume");if(s)if(i)O=this.safeString(e,"baseSize"),x=this.safeString(e,"baseVolume"),P=this.safeString(e,"fillTotalAmount");else{const t=this.safeString(e,"baseVolume");T=void 0!==t?t:x,S?k?(O=w,P=b):O=b:O=this.safeString(e,"newSize")}else T=this.safeString(e,"baseVolume"),O=this.safeString(e,"size"),P=this.safeString(e,"fillNotionalUsd");return I=a.Y.stringSub(O,x),this.safeOrder({info:e,symbol:n,id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"clientOid"),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:this.safeInteger(e,"uTime"),type:y,timeInForce:this.safeStringUpper(e,"force"),postOnly:void 0,side:v,price:m,triggerPrice:p,amount:O,cost:P,average:g,filled:T,remaining:I,status:this.parseWsOrderStatus(d),fee:u,trades:void 0},t)}parseWsOrderStatus(e){return this.safeString({live:"open",partially_filled:"open",filled:"closed",cancelled:"canceled",not_trigger:"open"},e,e)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a,o="myTrades";void 0!==e&&(r=this.market(e),o=o+":"+(e=r.symbol)),[a,i]=this.getInstType(r,i);const n="fill:"+a,d={instType:a,channel:"fill",instId:"default"},h=await this.watchPrivate(o,n,d,i);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleMyTrades(e,t){if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new o.I3(e)}const s=this.myTrades,i=this.safeList(t,"data",[]),r=i.length;for(let t=0;t<r;t++){const r=i[t],a=this.parseWsTrade(r);s.append(a);const o="myTrades:"+a.symbol;e.resolve(s,o)}e.resolve(s,"myTrades")}async watchBalance(e={}){let t,s,i;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleMarginModeAndParams("watchBalance",e);let r="account";"swap"===t||"future"===t?i="USDT-FUTURES":void 0!==s?(i="MARGIN",r="isolated"===s?"account-isolated":"account-crossed"):i="SPOT",[i,e]=this.handleOptionAndParams(e,"watchBalance","instType",i);const a={instType:i,channel:r,coin:"default"},o="balance:"+i.toLowerCase();return await this.watchPrivate(o,o,a,e)}handleBalance(e,t){const s=this.safeValue(t,"data",[]);for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString2(t,"coin","marginCoin"),r=this.safeCurrencyCode(i),o=r in this.balance?this.balance[r]:this.account(),n=this.safeString(t,"borrow");if(void 0!==n){const e=this.safeString(t,"interest");o.debt=a.Y.stringAdd(n,e)}const d="maxTransferOut"in t?"maxTransferOut":"available";o.free=this.safeString(t,d),o.total=this.safeString(t,"equity"),o.used=this.safeString(t,"frozen"),this.balance[r]=o}this.balance=this.safeBalance(this.balance);const i=this.safeValue(t,"arg"),r="balance:"+this.safeStringLower(i,"instType");e.resolve(this.balance,r)}async watchPublic(e,t,s={}){const i=this.urls.api.ws.public,r={op:"subscribe",args:[t]},a=this.extend(r,s);return await this.watch(i,e,a,e)}async unWatchPublic(e,t,s={}){const i=this.urls.api.ws.public,r={op:"unsubscribe",args:[t]},a=this.extend(r,s);return await this.watch(i,e,a,e)}async watchPublicMultiple(e,t,s={}){const i=this.urls.api.ws.public,r={op:"subscribe",args:t},a=this.extend(r,s);return await this.watchMultiple(i,e,a,e)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s=this.seconds().toString(),r=s+"GET/user/verify",a=this.hmac(this.encode(r),this.encode(this.secret),n.s,"base64"),o={op:"login",args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:s,sign:a}]},d=this.extend(o,e);this.watch(t,i,d,i)}return await r}async watchPrivate(e,t,s,i={}){await this.authenticate();const r=this.urls.api.ws.private,a={op:"subscribe",args:[s]},o=this.extend(a,i);return await this.watch(r,e,o,t)}handleAuthenticate(e,t){this.safeValue(e.futures,"authenticated").resolve(!0)}handleErrorMessage(e,t){const s=this.safeString(t,"event");try{if("error"===s){const e=this.safeString(t,"code"),s=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,e,s);const i=this.safeString(t,"msg","");throw this.throwBroadlyMatchedException(this.exceptions.ws.broad,i,s),new r.ExchangeError(s)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if("pong"===this.safeString(t,"message"))return void this.handlePong(e,t);if("pong"===t)return void this.handlePong(e,t);const s=this.safeString(t,"event");if("login"===s)return void this.handleAuthenticate(e,t);if("subscribe"===s)return void this.handleSubscriptionStatus(e,t);if("unsubscribe"===s)return void this.handleUnSubscriptionStatus(e,t);const i={ticker:this.handleTicker,trade:this.handleTrades,fill:this.handleMyTrades,orders:this.handleOrder,ordersAlgo:this.handleOrder,"orders-algo":this.handleOrder,"orders-crossed":this.handleOrder,"orders-isolated":this.handleOrder,account:this.handleBalance,positions:this.handlePositions,"account-isolated":this.handleBalance,"account-crossed":this.handleBalance},r=this.safeValue(t,"arg",{}),a=this.safeValue(r,"channel",""),o=this.safeValue(i,a);void 0!==o&&o.call(this,e,t),a.indexOf("candle")>=0&&this.handleOHLCV(e,t),a.indexOf("books")>=0&&this.handleOrderBook(e,t)}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscriptionStatus(e,t){return t}handleOrderBookUnSubscription(e,t){const s=this.safeDict(t,"arg",{}),i="spot"===this.safeStringLower(s,"instType")?"spot":"contract",a=this.safeString(s,"instId"),o=this.safeMarket(a,void 0,void 0,i),n=o.symbol,d="unsubscribe:orderbook:"+o.symbol,h="orderbook:"+n;n in this.orderbooks&&delete this.orderbooks[n],h in e.subscriptions&&delete e.subscriptions[h],d in e.subscriptions&&delete e.subscriptions[d];const c=new r.UnsubscribeError(this.id+"orderbook "+n);e.reject(c,h),e.resolve(!0,d)}handleTradesUnSubscription(e,t){const s=this.safeDict(t,"arg",{}),i="spot"===this.safeStringLower(s,"instType")?"spot":"contract",a=this.safeString(s,"instId"),o=this.safeMarket(a,void 0,void 0,i),n=o.symbol,d="unsubscribe:trade:"+o.symbol,h="trade:"+n;n in this.trades&&delete this.trades[n],h in e.subscriptions&&delete e.subscriptions[h],d in e.subscriptions&&delete e.subscriptions[d];const c=new r.UnsubscribeError(this.id+"trades "+n);e.reject(c,h),e.resolve(!0,d)}handleTickerUnSubscription(e,t){const s=this.safeDict(t,"arg",{}),i="spot"===this.safeStringLower(s,"instType")?"spot":"contract",a=this.safeString(s,"instId"),o=this.safeMarket(a,void 0,void 0,i),n=o.symbol,d="unsubscribe:ticker:"+o.symbol,h="ticker:"+n;n in this.tickers&&delete this.tickers[n],h in e.subscriptions&&delete e.subscriptions[h],d in e.subscriptions&&delete e.subscriptions[d];const c=new r.UnsubscribeError(this.id+"ticker "+n);e.reject(c,h),e.resolve(!0,d)}handleOHLCVUnSubscription(e,t){const s=this.safeDict(t,"arg",{}),i="spot"===this.safeStringLower(s,"instType")?"spot":"contract",a=this.safeString(s,"instId"),o=this.safeString(s,"channel").replace("candle",""),n=this.safeValue(this.options,"timeframes"),d=this.findTimeframe(o,n),h=this.safeMarket(a,void 0,void 0,i),c=h.symbol,l="unsubscribe:candles:"+d+":"+h.symbol,u="candles:"+d+":"+c;c in this.ohlcvs&&d in this.ohlcvs[c]&&delete this.ohlcvs[c][d],u in e.subscriptions&&delete e.subscriptions[u],l in e.subscriptions&&delete e.subscriptions[l];const p=new r.UnsubscribeError(this.id+" ohlcv "+d+" "+c);e.reject(p,u),e.resolve(!0,l)}handleUnSubscriptionStatus(e,t){let s=this.safeList(t,"args");void 0===s&&(s=[this.safeDict(t,"arg",{})]);for(let i=0;i<s.length;i++){const r=s[i],a=this.safeString(r,"channel");"books"===a?this.handleOrderBookUnSubscription(e,t):"trade"===a?this.handleTradesUnSubscription(e,t):"ticker"===a?this.handleTickerUnSubscription(e,t):a.startsWith("candle")&&this.handleOHLCVUnSubscription(e,t)}return t}}},6181:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(357),r=s(2931),a=s(2079);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://pubwss.bithumb.com/pub/ws"}},options:{},streaming:{},exceptions:{}})}async watchTicker(e,t={}){const s=this.urls.api.ws;await this.loadMarkets();const i=this.market(e),r="ticker:"+i.symbol,a={type:"ticker",symbols:[i.base+"_"+i.quote],tickTypes:[this.safeString(t,"tickTypes","24H")]};return await this.watch(s,r,this.extend(a,t),r)}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.urls.api.ws,i=[],r=[];e=this.marketSymbols(e,void 0,!1,!0,!0);for(let t=0;t<e.length;t++){const s=e[t],a=this.market(s);i.push(a.base+"_"+a.quote),r.push("ticker:"+a.symbol)}const a={type:"ticker",symbols:i,tickTypes:[this.safeString(t,"tickTypes","24H")]},o=this.extend(a,t),n=await this.watchMultiple(s,r,o,r);if(this.newUpdates){const e={};return e[n.symbol]=n,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeDict(t,"content",{}),i=this.safeString(s,"symbol"),r=this.safeSymbol(i,void 0,"_"),a=this.parseWsTicker(s),o="ticker:"+r;this.tickers[r]=a,e.resolve(this.tickers[r],o)}parseWsTicker(e,t=void 0){const s=this.safeString(e,"date",""),i=this.safeString(e,"time",""),r=s.slice(0,4)+"-"+s.slice(4,6)+"-"+s.slice(6,8)+"T"+i.slice(0,2)+":"+i.slice(2,4)+":"+i.slice(4,6),a=this.safeString(e,"symbol");return this.safeTicker({symbol:this.safeSymbol(a,t,"_"),timestamp:this.parse8601(r),datetime:r,high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:void 0,bidVolume:this.safeString(e,"buyVolume"),ask:void 0,askVolume:this.safeString(e,"sellVolume"),vwap:void 0,open:this.safeString(e,"openPrice"),close:this.safeString(e,"closePrice"),last:void 0,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"chgAmt"),percentage:this.safeString(e,"chgRate"),average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"value"),info:e},t)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.urls.api.ws,r=this.market(e),a="orderbook:"+(e=r.symbol),o={type:"orderbookdepth",symbols:[r.base+"_"+r.quote]};return(await this.watch(i,a,this.extend(o,s),a)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"content",{}),i=this.safeList(s,"list",[]),r=this.safeDict(i,0,{}),a=this.safeString(r,"symbol"),o=this.safeSymbol(a,void 0,"_"),n=this.safeString(s,"datetime"),d=this.parseToInt(n.slice(0,13));if(!(o in this.orderbooks)){const e=this.orderBook();e.symbol=o,this.orderbooks[o]=e}const h=this.orderbooks[o];this.handleDeltas(h,i),h.timestamp=d,h.datetime=this.iso8601(d);const c="orderbook:"+o;e.resolve(h,c)}handleDelta(e,t){const s="bid"===this.safeString(t,"orderType")?"bids":"asks",i=this.parseBidAsk(t,"price","quantity");e[s].storeArray(i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.urls.api.ws,a=this.market(e),o="trade:"+(e=a.symbol),n={type:"transaction",symbols:[a.base+"_"+a.quote]},d=await this.watch(r,o,this.extend(n,i),o);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeDict(t,"content",{}),i=this.safeList(s,"list",[]);for(let t=0;t<i.length;t++){const s=i[t],a=this.safeString(s,"symbol"),o=this.safeSymbol(a,void 0,"_");if(!(o in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3),t=new r.I3(e);this.trades[o]=t}const n=this.trades[o],d=this.parseWsTrade(s);n.append(d);const h="trade:"+o;e.resolve(n,h)}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"contDtm"),r=this.safeString(e,"buySellGb");return this.safeTrade({id:void 0,info:e,timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,t,"_"),order:void 0,type:void 0,side:"1"===r?"buy":"sell",takerOrMaker:void 0,price:this.safeString(e,"contPrice"),amount:this.safeString(e,"contQty"),cost:this.safeString(e,"contAmt"),fee:void 0},t)}handleErrorMessage(e,t){if(!("status"in t))return!0;const s=this.safeString(t,"status");try{if("0000"!==s){const e=this.safeString(t,"resmsg");throw new a.ExchangeError(this.id+" "+e)}return!0}catch(t){e.reject(t)}return!0}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeString(t,"type");if(void 0!==s){const i={ticker:this.handleTicker,orderbookdepth:this.handleOrderBook,transaction:this.handleTrades},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}}},3069:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(1837),r=s(2079),a=s(2931),o=s(4852),n=s(975);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{createOrderWs:!1,editOrderWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!1,cancelOrdersWs:!1,cancelAllOrdersWs:!1,ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOHLCV:!0,watchPosition:"emulated",watchPositions:!0},urls:{api:{ws:{spot:{public:"wss://ws-manager-compress.{hostname}/api?protocol=1.1",private:"wss://ws-manager-compress.{hostname}/user?protocol=1.1"},swap:{public:"wss://openapi-ws-v2.{hostname}/api?protocol=1.1",private:"wss://openapi-ws-v2.{hostname}/user?protocol=1.1"}}}},options:{defaultType:"spot",watchBalance:{fetchBalanceSnapshot:!0,awaitBalanceSnapshot:!1},watchOrderBook:{depth:"depth/increase100"},watchOrderBookForSymbols:{depth:"depth/increase100"},ws:{inflate:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","45m":"45m","1h":"1H","2h":"2H","3h":"3H","4h":"4H","1d":"1D","1w":"1W","1M":"1M"}},streaming:{keepAlive:15e3}})}async subscribe(e,t,s,i={}){const r=this.market(t),a=this.implodeHostname(this.urls.api.ws[s].public);let o,n={};return"spot"===s?(o="spot/"+e+":"+r.id,n={op:"subscribe",args:[o]}):(o="futures/"+e+":"+r.id,n={action:"subscribe",args:[o]}),await this.watch(a,o,this.deepExtend(n,i),o)}async subscribeMultiple(e,t,s=void 0,i={}){s=this.marketSymbols(s,t,!1,!0);const r=this.implodeHostname(this.urls.api.ws[t].public),a="spot"===t?"spot":"futures",o="spot"===t?"op":"action";let n=[];const d=[];for(let t=0;t<s.length;t++){const i=this.market(s[t]),r=a+"/"+e+":"+i.id;n.push(r),d.push(e+":"+i.symbol)}"spot"!==t&&"ticker"===e&&(n=[a+"/"+e]);const h={args:n};return h[o]="subscribe",await this.watchMultiple(r,d,this.deepExtend(h,i),n)}async watchBalance(e={}){await this.loadMarkets();let t="spot";[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),await this.authenticate(t,e);let s={};s="spot"===t?{op:"subscribe",args:["spot/user/balance:BALANCE_UPDATE"]}:{action:"subscribe",args:["futures/asset:USDT","futures/asset:BTC","futures/asset:ETH"]};const i="balance:"+t,r=this.implodeHostname(this.urls.api.ws[t].private),a=this.client(r);let o,n;return this.setBalanceCache(a,t,i),[o,e]=this.handleOptionAndParams(this.options,"watchBalance","fetchBalanceSnapshot",!0),[n,e]=this.handleOptionAndParams(this.options,"watchBalance","awaitBalanceSnapshot",!1),o&&n&&await a.future(t+":fetchBalanceSnapshot"),await this.watch(r,i,this.deepExtend(s,e),i)}setBalanceCache(e,t,s){if(s in e.subscriptions)return;const i=this.safeValue(this.options,"watchBalance");if(this.safeBool(i,"fetchBalanceSnapshot",!0)){const s=t+":fetchBalanceSnapshot";s in e.futures||(e.future(s),this.spawn(this.loadBalanceSnapshot,e,s,t))}this.balance[t]={}}async loadBalanceSnapshot(e,t,s){const i=await this.fetchBalance({type:s});this.balance[s]=this.extend(i,this.safeValue(this.balance,s,{}));e.futures[t].resolve(),e.resolve(this.balance[s],"balance:"+s)}handleBalance(e,t){const s=this.safeString2(t,"table","group"),i=this.safeValue(t,"data");if(void 0===i)return;const r=s.indexOf("spot")>=0,a=r?"spot":"swap";if(this.balance[a].info=t,r){if(!Array.isArray(i))return;for(let e=0;e<i.length;e++){const s=this.safeInteger(t,"event_time");this.balance[a].timestamp=s,this.balance[a].datetime=this.iso8601(s);const r=this.safeValue(i[e],"balance_details",[]);for(let t=0;t<r.length;t++){const t=r[e],s=this.account(),i=this.safeString(t,"ccy"),o=this.safeCurrencyCode(i);s.free=this.safeString(t,"av_bal"),s.used=this.safeString(t,"fz_bal"),this.balance[a][o]=s}}}else{const e=this.safeString(i,"currency"),t=this.safeCurrencyCode(e),s=this.account();s.free=this.safeString(i,"available_balance"),s.used=this.safeString(i,"frozen_balance"),this.balance[a][t]=s}this.balance[a]=this.safeBalance(this.balance[a]);const o="balance:"+a;e.resolve(this.balance[a],o)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),[e,r,i]=this.getParamsForMultipleSub("watchTradesForSymbols",e,s,i);const a=await this.subscribeMultiple("trade",r,e,i);if(this.newUpdates){const e=this.safeDict(a,0),t=this.safeString(e,"symbol");s=a.getLimit(t,s)}return this.filterBySinceLimit(a,t,s,"timestamp",!0)}getParamsForMultipleSub(e,t,s=void 0,i={}){if((t=this.marketSymbols(t,void 0,!1,!0)).length>20)throw new r.NotSupported(this.id+" "+e+"() accepts a maximum of 20 symbols in one request");const a=this.market(t[0]);let o;return[o,i]=this.handleMarketTypeAndParams(e,a,i),[t,o,i]}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.getMarketFromSymbols(e);let i;[i,t]=this.handleMarketTypeAndParams("watchTickers",s,t);const r=await this.subscribeMultiple("ticker",i,e,t);if(this.newUpdates){const e={};return e[r.symbol]=r,e}return this.filterByArray(this.tickers,"symbol",e)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a="orders";void 0!==e&&(e=this.symbol(e),r=this.market(e),a="orders::"+e);let o,n="spot";if([n,i]=this.handleMarketTypeAndParams("watchOrders",r,i),await this.authenticate(n,i),"spot"===n){let t="spot/user/order:";void 0!==e?t+=r.id:t="spot/user/orders:ALL_SYMBOLS",o={op:"subscribe",args:[t]}}else o={action:"subscribe",args:["futures/order"]};const d=this.implodeHostname(this.urls.api.ws[n].private),h=await this.watch(d,a,this.deepExtend(o,i),a);return this.newUpdates?h:this.filterBySymbolSinceLimit(this.orders,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data");if(void 0===s)return;const i=[],r={};if(s.length>0){const e=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(e));const t=this.orders;for(let e=0;e<s.length;e++){const a=this.parseWsOrder(s[e]);t.append(a),i.push(a);r[a.symbol]=!0}}const o="orders",n=Object.keys(r);for(let t=0;t<n.length;t++){const s=o+"::"+n[t];e.resolve(i,s)}e.resolve(i,o)}parseWsOrder(e,t=void 0){if(void 0===this.safeNumber(e,"action")){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"_","spot");const i=this.safeString(e,"order_id"),r=this.safeString(e,"clientOid"),a=this.safeString(e,"price"),o=this.safeString(e,"filled_size"),n=this.safeString(e,"size"),d=this.safeString(e,"type"),h=this.safeString(e,"state"),c=this.parseOrderStatusByType(t.type,h),l=this.safeInteger(e,"ms_t"),u=t.symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:u,id:i,clientOrderId:r,timestamp:void 0,datetime:void 0,lastTradeTimestamp:l,type:d,timeInForce:void 0,postOnly:void 0,side:p,price:a,stopPrice:void 0,triggerPrice:void 0,amount:n,cost:void 0,average:void 0,filled:o,remaining:void 0,status:c,fee:void 0,trades:void 0},t)}{const s=this.safeValue(e,"order"),i=this.safeString(s,"symbol"),r=this.safeSymbol(i,t,"","swap"),a=this.safeString(s,"order_id"),o=this.safeInteger(s,"create_time"),n=this.safeInteger(s,"update_time"),d=this.safeValue(s,"last_trade"),h=this.orders,c=this.safeValue(h.hashmap,r,{});let l;return void 0!==this.safeValue(c,a)&&(l=this.safeValue(e,"trades")),void 0!==d&&(void 0===l&&(l=[]),l.push(d)),this.safeOrder({info:e,symbol:r,id:a,clientOrderId:this.safeString(s,"client_order_id"),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:n,type:this.safeString(s,"type"),timeInForce:void 0,postOnly:void 0,side:this.parseWsOrderSide(this.safeString(s,"side")),price:this.safeString(s,"price"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeString(s,"size"),cost:void 0,average:this.safeString(s,"deal_avg_price"),filled:this.safeString(s,"deal_size"),remaining:void 0,status:this.parseWsOrderStatus(this.safeString(e,"action")),fee:void 0,trades:l},t)}}parseWsOrderStatus(e){return this.safeString({1:"closed",2:"open",3:"canceled",4:"closed",5:"canceled",6:"open",7:"open",8:"closed",9:"closed"},e,e)}parseWsOrderSide(e){return this.safeString({1:"buy",2:"buy",3:"sell",4:"sell"},e,e)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="swap";await this.authenticate(r,i);let a="positions";void 0!==(e=this.marketSymbols(e,"swap",!0,!0,!1))&&(a+="::"+e.join(","));const o=this.implodeHostname(this.urls.api.ws[r].private),n=await this.watch(o,a,this.deepExtend({action:"subscribe",args:["futures/position"]},i),"futures/position");return this.newUpdates?n:this.filterBySymbolsSinceLimit(this.positions,e,t,s)}handlePositions(e,t){const s=this.safeValue(t,"data",[]);void 0===this.positions&&(this.positions=new a.Hk);const i=this.positions,r=[];for(let e=0;e<s.length;e++){const t=s[e],a=this.parseWsPosition(t);r.push(a),i.append(a)}const o=this.findMessageHashes(e,"positions::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),a=this.filterByArray(r,"symbol",i,!1);this.isEmpty(a)||e.resolve(a,s)}e.resolve(r,"positions")}parseWsPosition(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t,void 0,"swap")).symbol,r=this.safeInteger(e,"create_time"),a=this.safeInteger(e,"update_time"),o=this.safeInteger(e,"position_type"),n=this.safeInteger(e,"open_type");return this.safePosition({info:e,id:void 0,symbol:i,timestamp:r,datetime:this.iso8601(r),lastUpdateTimestamp:a,hedged:void 0,side:1===o?"long":"short",contracts:this.safeNumber(e,"hold_volume"),contractSize:this.safeNumber(t,"contractSize"),entryPrice:this.safeNumber(e,"open_avg_price"),markPrice:this.safeNumber(e,"hold_avg_price"),lastPrice:void 0,notional:void 0,leverage:void 0,collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,unrealizedPnl:void 0,realizedPnl:void 0,liquidationPrice:this.safeNumber(e,"liquidate_price"),marginMode:1===n?"isolated":"cross",percentage:void 0,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}handleTrade(e,t){const s=this.safeValue(t,"data");if(void 0===s)return;let i;const r=s.length;if("group"in t)for(let e=0;e<r;e++){const t=r-e-1;i=this.handleTradeLoop(s[t])}else for(let e=0;e<r;e++)i=this.handleTradeLoop(s[e]);e.resolve(this.trades[i],"trade:"+i)}handleTradeLoop(e){const t=this.parseWsTrade(e),s=t.symbol,i=this.safeInteger(this.options,"tradesLimit",1e3);void 0===this.safeValue(this.trades,s)&&(this.trades[s]=new a.I3(i));return this.trades[s].append(t),s}parseWsTrade(e,t=void 0){const s=void 0===this.safeString(e,"contract_id")?"spot":"swap",i="spot"===s?"_":"",r=this.safeInteger(e,"create_time_mill",this.safeTimestamp(e,"s_t")),a=this.safeString(e,"symbol");return this.safeTrade({info:e,id:this.safeString(e,"trade_id"),order:void 0,timestamp:r,datetime:this.iso8601(r),symbol:this.safeSymbol(a,t,i,s),type:void 0,side:this.safeString(e,"side"),price:this.safeString2(e,"price","deal_price"),amount:this.safeString2(e,"size","deal_vol"),cost:void 0,takerOrMaker:void 0,fee:void 0},t)}handleTicker(e,t){const s=void 0!==this.safeString(t,"table");let i=[];if(i=s?this.safeList(t,"data",[]):[this.safeValue(t,"data",{})],i.length)for(let t=0;t<i.length;t++){const r=s?this.parseTicker(i[t]):this.parseWsSwapTicker(i[t]),a=r.symbol;this.tickers[a]=r;const o="ticker:"+a;e.resolve(r,o)}}parseWsSwapTicker(e,t=void 0){const s=this.safeString(e,"symbol");return this.safeTicker({symbol:this.safeSymbol(s,t,"","swap"),timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:this.safeString(e,"bid_price"),bidVolume:this.safeString(e,"bid_vol"),ask:this.safeString(e,"ask_price"),askVolume:this.safeString(e,"ask_vol"),vwap:void 0,open:void 0,close:void 0,last:this.safeString(e,"last_price"),previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"fair_price"),baseVolume:void 0,quoteVolume:this.safeString(e,"volume_24"),info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);const a=this.market(e);let o="spot";[o,r]=this.handleMarketTypeAndParams("watchOrderBook",a,r);const n=this.safeValue(this.options,"timeframes",{}),d=this.safeString(n,t);let h;h="spot"===o?"kline"+d:"klineBin"+d;const c=await this.subscribe(h,e,o,r);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString2(t,"table","group"),i=s.indexOf("spot")>=0,r=this.safeValue(t,"data");if(void 0===r)return;const o=s.split("/");let n=this.safeString(o,1,"").replace("kline","");n=n.replace("Bin","");const d=n.split(":");n=this.safeString(d,0);const h=this.safeValue(this.options,"timeframes",{}),c=this.findTimeframe(n,h),l=1e3*this.parseTimeframe(c);if(i)for(let t=0;t<r.length;t++){const i=this.safeString(r[t],"symbol"),o=this.safeMarket(i),n=o.symbol,d=this.safeValue(r[t],"candle"),h=this.parseOHLCV(d,o);h[0]=this.parseToInt(h[0]/l)*l,this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let u=this.safeValue(this.ohlcvs[n],c);if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new a.TG(e),this.ohlcvs[n][c]=u}u.append(h);const p=s+":"+i;e.resolve(u,p)}else{const t=this.safeString(r,"symbol"),i=this.safeMarket(t,void 0,void 0,"swap"),o=i.symbol,n=this.safeValue(r,"items",[]);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let d=this.safeValue(this.ohlcvs[o],c);if(void 0===d){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);d=new a.TG(e),this.ohlcvs[o][c]=d}for(let e=0;e<n.length;e++){const t=n[e],s=this.parseOHLCV(t,i);d.append(s)}e.resolve(d,s)}}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"watchOrderBook",{});let r=this.safeString(i,"depth","depth/increase100");e=this.symbol(e);const a=this.market(e);let o="spot";[o,s]=this.handleMarketTypeAndParams("watchOrderBook",a,s),"swap"===o&&"depth/increase100"===r&&(r="depth50");return(await this.subscribe(r,e,o,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeList(t,"asks",[]),r=this.safeList(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,r);const a=this.safeInteger(t,"ms_t"),o=this.safeString(t,"symbol"),n=this.safeSymbol(o);return s.symbol=n,s.timestamp=a,s.datetime=this.iso8601(a),s}handleOrderBook(e,t){const s="table"in t;let i=[];if(s)i=this.safeList(t,"data",i);else{const e=this.safeDict(t,"data");void 0!==e&&i.push(e)}if(i.length<=0)return;const r=this.safeString2(t,"table","group"),a=["100","50","20","10","5"];let o=0;for(let e=0;e<a.length;e++){const t=a[e];if(r.indexOf(t)>=0){o=this.parseToInt(t);break}}if(s){const t=r.replace("spot/","");for(let s=0;s<i.length;s++){const a=i[s],n=this.safeString(a,"symbol"),d=this.safeSymbol(n);if(!(d in this.orderbooks)){const e=this.orderBook({},o);e.symbol=d,this.orderbooks[d]=e}const h=this.orderbooks[d];"snapshot"!==this.safeString(a,"type")&&r.indexOf("increase")>=0||h.reset({}),this.handleOrderBookMessage(e,a,h);const c=this.safeInteger(a,"ms_t");void 0===h.timestamp&&(h.timestamp=c,h.datetime=this.iso8601(c));const l=r+":"+n;e.resolve(h,l);const u=t+":"+d;e.resolve(h,u)}}else{const t=r.split(":")[0].replace("futures/",""),s=i[0],a=s.depths,d=this.safeString(s,"symbol"),h=this.safeSymbol(d);if(!(h in this.orderbooks)){const e=this.orderBook({},o);e.symbol=h,this.orderbooks[h]=e}const c=this.orderbooks[h],l=this.safeInteger(s,"way"),u=1===l?"bids":"asks";c[u]=1===l?new n.PB([],o):new n.$w([],o);for(let e=0;e<a.length;e++){const t=a[e],s=this.safeNumber(t,"price"),i=this.safeNumber(t,"vol");this.safeValue(c,u).store(s,i)}const p=c.bids.length,f=c.asks.length;if(0===p||0===f)return;const m=this.safeInteger(s,"ms_t");c.timestamp=m,c.datetime=this.iso8601(m);const g=r;e.resolve(c,g);const v=t+":"+h;e.resolve(c,v)}}async watchOrderBookForSymbols(e,t=void 0,s={}){let i,r;await this.loadMarkets(),[e,i,s]=this.getParamsForMultipleSub("watchOrderBookForSymbols",e,t,s),[r,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","depth","depth/increase100"),"swap"===i&&"depth/increase100"===r&&(r="depth50");return(await this.subscribeMultiple(r,i,e,s)).limit()}async authenticate(e,t={}){this.checkRequiredCredentials();const s=this.implodeHostname(this.urls.api.ws[e].private),i="authenticated",r=this.client(s),a=r.future(i);if(void 0===this.safeValue(r.subscriptions,i)){const r=this.milliseconds().toString(),a=r+"#"+this.uid+"#"+"bitmart.WebSocket",n=this.hmac(this.encode(a),this.encode(this.secret),o.s);let d;d="spot"===e?{op:"login",args:[this.apiKey,r,n]}:{action:"access",args:[this.apiKey,r,n,"web"]};const h=this.extend(d,t);this.watch(s,i,h,i)}return await a}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){this.safeValue(e.futures,"authenticated").resolve(!0)}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode"),i=this.safeString(t,"error");try{if(void 0!==s||void 0!==i){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e);const a=this.safeValue(t,"message",i);this.throwBroadlyMatchedException(this.exceptions.broad,a,e);if("access"===this.safeString(t,"action"))throw new r.AuthenticationError(e);throw new r.ExchangeError(e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}return e.reject(t),!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if("data"in t){const s=this.safeString2(t,"table","group"),i={depth:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade,kline:this.handleOHLCV,order:this.handleOrders,position:this.handlePositions,balance:this.handleBalance,asset:this.handleBalance},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a];if(s.indexOf(o)>=0){this.safeValue(i,o).call(this,e,t)}}}else{const s=this.safeString2(t,"event","action");if(void 0!==s){const i={login:this.handleAuthenticate,access:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}}}},3731:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(9523),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchLiquidations:!0,watchLiquidationsForSymbols:!0,watchMyLiquidations:void 0,watchMyLiquidationsForSymbols:void 0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchPostions:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0},urls:{test:{ws:"wss://ws.testnet.bitmex.com/realtime"},api:{ws:"wss://ws.bitmex.com/realtime"}},options:{watchOrderBookLevel:"orderBookL2",tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{ws:{exact:{},broad:{"Rate limit exceeded":r.RateLimitExceeded}}}})}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0);const s="instrument",i=this.urls.api.ws,r=[],a=[];if(void 0!==e)for(let t=0;t<e.length;t++){const i=e[t],o=s+":"+this.market(i).id;a.push(o);const n="ticker:"+i;r.push(n)}else a.push(s),r.push("alltickers");const o={op:"subscribe",args:a},n=await this.watchMultiple(i,r,this.extend(o,t),a);if(this.newUpdates){const e={};return e[n.symbol]=n,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeList(t,"data",[]),i={};for(let t=0;t<s.length;t++){const r=s[t],a=this.safeString(r,"symbol"),o=this.safeSymbol(a);o in this.tickers||(this.tickers[o]=this.parseTicker({}));const n=this.parseTicker(r),d=this.deepExtend(this.tickers[o],n);i[o]=d,this.tickers[o]=d;const h="ticker:"+o;e.resolve(d,h),e.resolve(d,"alltickers")}return t}async watchLiquidations(e,t=void 0,s=void 0,i={}){return this.watchLiquidationsForSymbols([e],t,s,i)}async watchLiquidationsForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0);const r=[],a=[];if(this.isEmpty(e))a.push("liquidation"),r.push("liquidations");else for(let t=0;t<e.length;t++){const s=e[t],i=this.market(s);a.push("liquidation:"+i.id),r.push("liquidations::"+s)}const o=this.urls.api.ws,n={op:"subscribe",args:a},d=await this.watchMultiple(o,r,this.deepExtend(n,i),a);return this.newUpdates?d:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s,!0)}handleLiquidation(e,t){const s=this.safeValue(t,"data",[]),i=[];for(let e=0;e<s.length;e++){const t=s[e],r=this.parseLiquidation(t),o=r.symbol;let n=this.safeValue(this.liquidations,o);if(void 0===n){const e=this.safeInteger(this.options,"liquidationsLimit",1e3);n=new a.I3(e)}n.append(r),this.liquidations[o]=n,i.push(r)}e.resolve(i,"liquidations");const r=this.indexBy(i,"symbol"),o=Object.keys(r);for(let t=0;t<o.length;t++){const s=o[t];e.resolve(r[s],"liquidations::"+s)}}async watchBalance(e={}){await this.loadMarkets(),await this.authenticate();const t="margin",s=this.urls.api.ws,i={op:"subscribe",args:[t]};return await this.watch(s,t,this.extend(i,e),t)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.parseBalance(s);this.balance=this.extend(this.balance,i);const r=this.safeString(t,"table");e.resolve(this.balance,r)}handleTrades(e,t){const s=this.safeValue(t,"data",[]),i=this.groupBy(s,"symbol"),r=Object.keys(i);for(let t=0;t<r.length;t++){const s=r[t],o=this.safeMarket(s),n=o.symbol,d="trade:"+n,h=this.parseTrades(i[s],o);let c=this.safeValue(this.trades,n);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[n]=c}for(let e=0;e<h.length;e++)c.append(h[e]);e.resolve(c,d)}}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){this.checkRequiredCredentials();const s=this.milliseconds(),r="GET/realtime"+s.toString(),a=this.hmac(this.encode(r),this.encode(this.secret),o.s),n={op:"authKeyExpires",args:[this.apiKey,s,a]},d=this.extend(n,e);this.watch(t,i,d,i)}return await r}handleAuthenticationMessage(e,t){const s="authenticated";if(this.safeBool(t,"success",!1)){this.safeValue(e.futures,s).resolve(!0)}else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r="position";let a="positions";this.isEmpty(e)||(a="::"+e.join(","));const o=this.urls.api.ws,n={op:"subscribe",args:[r]},d=await this.watch(o,a,n,r);return this.newUpdates?d:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}handlePositions(e,t){void 0===this.positions&&(this.positions=new a.Hk);const s=this.positions,i=this.safeValue(t,"data",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],a=this.parsePosition(t);r.push(a),s.append(a)}const o=this.findMessageHashes(e,"positions::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),a=this.filterByArray(r,"symbol",i,!1);this.isEmpty(a)||e.resolve(a,s)}e.resolve(r,"positions")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r="order",a=r;let o=r;void 0!==e&&(o+=":"+(e=this.symbol(e)));const n=this.urls.api.ws,d={op:"subscribe",args:[a]},h=await this.watch(n,o,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data",[]),i="order",r=s.length;if(r>0){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,o={};for(let e=0;e<r;e++){const i=s[e],r=this.safeString(i,"orderID"),a=this.safeValue(t.hashmap,r);let n=i;void 0!==a&&(n=this.extend(a.info,i));const d=this.parseOrder(n);t.append(d);o[d.symbol]=!0}e.resolve(this.orders,i);const n=Object.keys(o);for(let t=0;t<n.length;t++){const s=n[t];e.resolve(this.orders,i+":"+s)}}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r="execution",a=r;let o=r;void 0!==e&&(o+=":"+(e=this.symbol(e)));const n=this.urls.api.ws,d={op:"subscribe",args:[a]},h=await this.watch(n,o,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),r=this.groupBy(i,"execType"),o=this.safeValue(r,"Trade",[]),n=this.parseTrades(o);if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const d=this.myTrades,h={};for(let e=0;e<n.length;e++){const t=n[e],s=t.symbol;d.append(t),h[s]=t}n.length>0&&e.resolve(d,s);const c=Object.keys(h);for(let t=0;t<c.length;t++)e.resolve(d,s+":"+c[t])}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){let i;if(void 0===t)i=this.safeString(this.options,"watchOrderBookLevel","orderBookL2");else if(25===t)i="orderBookL2_25";else{if(10!==t)throw new r.ExchangeError(this.id+" watchOrderBookForSymbols limit argument must be undefined (L2), 25 (L2) or 10 (L3)");i="orderBookL10"}await this.loadMarkets(),e=this.marketSymbols(e);const a=[],o=[];for(let t=0;t<e.length;t++){const s=e[t],r=i+":"+this.market(s).id;a.push(r);const n=i+":"+s;o.push(n)}const n=this.urls.api.ws,d={op:"subscribe",args:a};return(await this.watchMultiple(n,o,this.deepExtend(d,s),a)).limit()}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const r="trade",a=[],o=[];for(let t=0;t<e.length;t++){const s=e[t],i=r+":"+this.market(s).id;a.push(i);const n=r+":"+s;o.push(n)}const n=this.urls.api.ws,d={op:"subscribe",args:a},h=await this.watchMultiple(n,o,this.deepExtend(d,i),a);if(this.newUpdates){const e=this.safeValue(h,0),t=this.safeString(e,"symbol");s=h.getLimit(t,s)}return this.filterBySinceLimit(h,t,s,"timestamp",!0)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="tradeBin"+this.safeString(this.timeframes,t,t)+":"+a.id,n=this.urls.api.ws,d={op:"subscribe",args:[o]},h=await this.watch(n,o,this.extend(d,r),o);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=s.replace("tradeBin",""),r=this.findTimeframe(i),o=this.parseTimeframe(r),n=this.safeValue(t,"data",[]),d={};for(let e=0;e<n.length;e++){const t=n[e],i=this.safeString(t,"symbol"),h=this.safeMarket(i),c=h.symbol,l=s+":"+h.id,u=[this.parse8601(this.safeString(t,"timestamp"))-1e3*o,void 0,this.safeFloat(t,"high"),this.safeFloat(t,"low"),this.safeFloat(t,"close"),this.safeFloat(t,"volume")];this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let p=this.safeValue(this.ohlcvs[c],r);if(void 0===p){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);p=new a.TG(e),this.ohlcvs[c][r]=p}p.append(u),d[l]=p}const h=Object.keys(d);for(let t=0;t<h.length;t++){const s=h[t];e.resolve(d[s],s)}}async watchHeartbeat(e={}){await this.loadMarkets();const t=this.urls.api.ws;return await this.watch(t,"heartbeat")}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeString(t,"table");if(void 0===i)return;const r=this.safeValue(t,"data",[]);if("partial"===s){const s=this.safeDict(t,"filter",{}),a=this.safeValue(s,"symbol");if(void 0===a)return;const o=this.safeMarket(a).symbol;"orderBookL2"===i?this.orderbooks[o]=this.indexedOrderBook():"orderBookL2_25"===i?this.orderbooks[o]=this.indexedOrderBook({},25):"orderBook10"===i&&(this.orderbooks[o]=this.indexedOrderBook({},10));const n=this.orderbooks[o];n.symbol=o;for(let e=0;e<r.length;e++){const t=this.safeFloat(r[e],"price"),s=this.convertFromRawQuantity(o,this.safeString(r[e],"size")),i=this.safeString(r[e],"id");let a=this.safeString(r[e],"side");a="Buy"===a?"bids":"asks";n[a].storeArray([t,s,i]);const d=this.safeString(r[e],"timestamp");n.timestamp=this.parse8601(d),n.datetime=d}const d=i+":"+o;e.resolve(n,d)}else{const t={};for(let e=0;e<r.length;e++){const i=this.safeValue(r[e],"symbol");if(void 0===i)return;i in t||(t[i]=0),t[i]=this.sum(t,1);const a=this.safeMarket(i).symbol,o=this.orderbooks[a],n=this.safeNumber(r[e],"price"),d="delete"===s?0:this.convertFromRawQuantity(a,this.safeString(r[e],"size","0")),h=this.safeString(r[e],"id");let c=this.safeString(r[e],"side");c="Buy"===c?"bids":"asks";o[c].storeArray([n,d,h]);const l=this.safeString(r[e],"timestamp");o.timestamp=this.parse8601(l),o.datetime=l}const a=Object.keys(t);for(let t=0;t<a.length;t++){const s=a[t],r=this.safeMarket(s).symbol,o=i+":"+r,n=this.orderbooks[r];e.resolve(n,o)}}}handleSystemStatus(e,t){return t}handleSubscriptionStatus(e,t){return t}handleErrorMessage(e,t){const s=this.safeString(t,"error");if(void 0!==s){const i=this.safeValue(t,"request",{}),a=this.safeValue(i,"args",[]);if(a.length>0){const t=a[0],i=this.exceptions.ws.broad,o=this.findBroadlyMatchedKey(i,s);let n;return n=void 0===o?new r.ExchangeError(s):new i[o](s),e.reject(n,t),!1}}return!0}handleMessage(e,t){if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"table"),i={orderBookL2:this.handleOrderBook,orderBookL2_25:this.handleOrderBook,orderBook10:this.handleOrderBook,instrument:this.handleTicker,trade:this.handleTrades,tradeBin1m:this.handleOHLCV,tradeBin5m:this.handleOHLCV,tradeBin1h:this.handleOHLCV,tradeBin1d:this.handleOHLCV,order:this.handleOrders,execution:this.handleMyTrades,margin:this.handleBalance,liquidation:this.handleLiquidation,position:this.handlePositions},r=this.safeValue(i,s);if(void 0===r){const s=this.safeValue(t,"request",{});"authKeyExpires"===this.safeValue(s,"op")&&this.handleAuthenticationMessage(e,t)}else r.call(this,e,t)}}}},4401:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2753),r=s(2079),a=s(2931),o=s(7481);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1},urls:{ws:{public:"wss://stream.bitopro.com:443/ws/v1/pub",private:"wss://stream.bitopro.com:443/ws/v1/pub/auth"}},requiredCredentials:{apiKey:!0,secret:!0,login:!0},options:{tradesLimit:1e3,ordersLimit:1e3,ws:{options:{headers:{}}}}})}async watchPublic(e,t,s){const i=this.urls.ws.public+"/"+e+"/"+s;return await this.watch(i,t,void 0,t)}async watchOrderBook(e,t=void 0,s={}){if(void 0!==t&&5!==t&&10!==t&&20!==t&&50!==t&&100!==t&&500!==t&&1e3!==t)throw new r.ExchangeError(this.id+" watchOrderBook limit argument must be undefined, 5, 10, 20, 50, 100, 500 or 1000");await this.loadMarkets();const i=this.market(e),a="ORDER_BOOK:"+(e=i.symbol);let o;o=void 0===t?i.id:i.id+":"+t;return(await this.watchPublic("order-books",a,o)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_").symbol,r=this.safeString(t,"event")+":"+i;let a=this.safeValue(this.orderbooks,i);void 0===a&&(a=this.orderBook({}));const o=this.safeInteger(t,"timestamp"),n=this.parseOrderBook(t,i,o,"bids","asks","price","amount");a.reset(n),e.resolve(a,r)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="TRADE:"+(e=r.symbol),o=await this.watchPublic("trades",a,r.id);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_"),r=i.symbol,o=this.safeString(t,"event")+":"+r,n=this.safeValue(t,"data",[]),d=this.parseTrades(n,i);let h=this.safeValue(this.trades,r);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e)}for(let e=0;e<d.length;e++)h.append(d[e]);this.trades[r]=h,e.resolve(h,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials(),await this.loadMarkets();let r="USER_TRADE";if(void 0!==e){r=r+":"+this.market(e).symbol}const a=this.urls.ws.private+"/user-trades";this.authenticate(a);const o=await this.watch(a,r,void 0,r);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleMyTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"base"),r=this.safeString(s,"quote"),o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(r),d=this.symbol(o+"/"+n),h=this.safeString(t,"event");if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const c=this.myTrades,l=this.parseWsTrade(s);c.append(l),e.resolve(c,h),e.resolve(c,h+":"+d)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"matchID"),i=this.safeString(e,"orderID"),r=this.safeTimestamp(e,"transactionTimestamp"),a=this.safeString(e,"base"),o=this.safeString(e,"quote"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o),h=this.symbol(n+"/"+d);t=this.safeMarket(h,t);const c=this.safeString(e,"price"),l=this.safeStringLower(e,"orderType");let u=this.safeString(e,"side");void 0!==u&&("ask"===u?u="sell":"bid"===u&&(u="buy"));const p=this.safeString(e,"volume");let f;const m=this.safeString(e,"fee"),g=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));void 0!==m&&(f={cost:m,currency:g,rate:void 0});const v=this.safeValue(e,"isMaker");let y;return void 0!==v&&(y=v?"maker":"taker"),this.safeTrade({id:s,info:e,order:i,timestamp:r,datetime:this.iso8601(r),symbol:h,takerOrMaker:y,type:l,side:u,price:c,amount:p,cost:void 0,fee:f},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="TICKER:"+(e=s.symbol);return await this.watchPublic("tickers",i,s.id)}handleTicker(e,t){const s=this.safeString(t,"pair"),i=this.safeMarket(s,void 0,"_").symbol,r=this.safeString(t,"event")+":"+i,a=this.parseTicker(t),o=this.safeInteger(t,"timestamp"),n=this.safeString(t,"datetime");a.timestamp=o,a.datetime=n,this.tickers[i]=a,e.resolve(a,r)}authenticate(e){if(void 0!==this.clients&&e in this.clients)return;this.checkRequiredCredentials();const t=this.milliseconds(),s=this.json({nonce:t,identity:this.login}),i=this.stringToBase64(s),r=this.hmac(this.encode(i),this.encode(this.secret),o.qt);this.extendExchangeOptions({ws:{options:{headers:{}}}});const a=this.options.ws.options.headers,n={"X-BITOPRO-API":"ccxt","X-BITOPRO-APIKEY":this.apiKey,"X-BITOPRO-PAYLOAD":i,"X-BITOPRO-SIGNATURE":r};this.options.ws.options.headers=n,this.client(e),this.options.ws.options.headers=a}async watchBalance(e={}){this.checkRequiredCredentials(),await this.loadMarkets();const t="ACCOUNT_BALANCE",s=this.urls.ws.private+"/account-balance";return this.authenticate(s),await this.watch(s,t,void 0,t)}handleBalance(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data"),r=this.safeInteger(t,"timestamp"),a=this.safeString(t,"datetime"),o=Object.keys(i),n={info:i,timestamp:r,datetime:a};for(let e=0;e<o.length;e++){const t=this.safeString(o,e),s=this.safeValue(i,t),r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),d=this.account();d.free=this.safeString(s,"available"),d.total=this.safeString(s,"amount"),n[a]=d}this.balance=this.safeBalance(n),e.resolve(this.balance,s)}handleMessage(e,t){const s={TRADE:this.handleTrade,TICKER:this.handleTicker,ORDER_BOOK:this.handleOrderBook,ACCOUNT_BALANCE:this.handleBalance,USER_TRADE:this.handleMyTrade},i=this.safeString(t,"event"),r=this.safeValue(s,i);void 0!==r&&r.call(this,e,t)}}},8265:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(4357);class r extends i.A{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"bitpanda"})}}},3333:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(9061),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!1,watchTickers:!1,watchTrades:!1,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{open:"https://open.bitrue.com",ws:{public:"wss://ws.bitrue.com/market/ws",private:"wss://wsapi.bitrue.com"}}},api:{open:{private:{post:{"poseidon/api/v1/listenKey":1},put:{"poseidon/api/v1/listenKey/{listenKey}":1},delete:{"poseidon/api/v1/listenKey/{listenKey}":1}}}},options:{listenKeyRefreshRate:18e5,ws:{gunzip:!0}}})}async watchBalance(e={}){const t=await this.authenticate(),s="balance",i=this.deepExtend({event:"sub",params:{channel:"user_balance_update"}},e);return await this.watch(t,s,i,s)}handleBalance(e,t){const s=this.safeValue(t,"B",[]);this.parseWSBalances(s);e.resolve(this.balance,"balance")}parseWSBalances(e){this.balance.info=e;for(let t=0;t<e.length;t++){const s=e[t],i=this.safeString(s,"a"),r=this.safeCurrencyCode(i),a=this.account(),o=this.safeString(s,"F"),n=this.safeString(s,"L"),d=0!==this.safeInteger(s,"T",0),h=0!==this.safeInteger(s,"t",0);(d||h)&&(d&&(a.free=o),h&&(a.used=n),this.balance[r]=a)}this.balance=this.safeBalance(this.balance)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0!==e){e=this.market(e).symbol}const r=await this.authenticate(),a="orders",o=this.deepExtend({event:"sub",params:{channel:"user_order_update"}},i),n=await this.watch(r,a,o,a);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}handleOrder(e,t){const s=this.parseWsOrder(t);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new r.Pt(e)}this.orders.append(s);e.resolve(this.orders,"orders")}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeStringUpper(e,"s"),r=this.safeString(e,"o"),a=1===this.safeInteger(e,"S")?"buy":"sell",o=this.safeString(e,"X"),n=this.safeString(e,"N");return this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:this.safeInteger(e,"T"),symbol:this.safeSymbol(i,t),type:this.parseWsOrderType(r),timeInForce:void 0,postOnly:void 0,side:a,price:this.safeString(e,"p"),triggerPrice:void 0,amount:this.safeString(e,"q"),cost:this.safeString(e,"Y"),average:void 0,filled:this.safeString(e,"z"),remaining:void 0,status:this.parseWsOrderStatus(o),fee:{currency:this.safeCurrencyCode(n),cost:this.safeNumber(e,"n")}},t)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+(e=i.symbol),a=i.id.toLowerCase(),o="market_"+a+"_simple_depth_step0",n=this.urls.api.ws.public,d={event:"sub",params:{cb_id:a,channel:o}},h=this.deepExtend(d,s);return await this.watch(n,r,h,r)}handleOrderBook(e,t){const s=this.safeString(t,"channel").split("_"),i=this.safeStringUpper(s,1),r=this.safeMarket(i).symbol,a=this.safeInteger(t,"ts"),o=this.safeValue(t,"tick",{});r in this.orderbooks||(this.orderbooks[r]=this.orderBook());const n=this.orderbooks[r],d=this.parseOrderBook(o,r,a,"buys","asks");n.reset(d);const h="orderbook:"+r;e.resolve(n,h)}parseWsOrderType(e){return this.safeString({1:"limit",2:"market",3:"limit"},e,e)}parseWsOrderStatus(e){return this.safeString({0:"open",1:"open",2:"closed",3:"open",4:"canceled",7:"open"},e,e)}handlePing(e,t){this.spawn(this.pong,e,t)}async pong(e,t){const s={pong:this.safeInteger(t,"ping")};await e.send(s)}handleMessage(e,t){if("channel"in t)this.handleOrderBook(e,t);else if("ping"in t)this.handlePing(e,t);else{const s=this.safeString(t,"e"),i={BALANCE:this.handleBalance,ORDER:this.handleOrder},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}async authenticate(e={}){if(void 0===this.safeValue(this.options,"listenKey")){const t=await this.openPrivatePostPoseidonApiV1ListenKey(e),s=this.safeValue(t,"data",{}),i=this.safeString(s,"listenKey");this.options.listenKey=i,this.options.listenKeyUrl=this.urls.api.ws.private+"/stream?listenKey="+i;const r=this.safeInteger(this.options,"listenKeyRefreshRate",18e5);this.delay(r,this.keepAliveListenKey)}return this.options.listenKeyUrl}async keepAliveListenKey(e={}){const t={listenKey:this.safeString(this.options,"listenKey")};try{await this.openPrivatePutPoseidonApiV1ListenKeyListenKey(this.extend(t,e))}catch(e){return this.options.listenKey=void 0,void(this.options.listenKeyUrl=void 0)}const s=this.safeInteger(this.options,"listenKeyRefreshRate",18e5);this.delay(s,this.keepAliveListenKey)}}},3326:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(382),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchTradesForSymbols:!1,watchOHLCV:!1,watchTicker:!1,watchTickers:!1},urls:{api:{ws:"wss://ws.bitstamp.net"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{snapshotDelay:6,snapshotMaxRetries:3},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:r.AuthenticationError}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+(e=i.symbol),a="diff_order_book_"+i.id,o=this.urls.api.ws,n={event:"bts:subscribe",data:{channel:a}},d=this.extend(n,s);return(await this.watch(o,r,d,r)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"channel").split("_"),i=this.safeString(s,3),r=this.safeSymbol(i),a=this.safeValue(this.orderbooks,r),o=this.safeValue(a,"nonce"),n=this.safeValue(t,"data"),d=this.safeInteger(n,"microtimestamp"),h="orderbook:"+r;if(void 0===o){return a.cache.length===this.handleOption("watchOrderBook","snapshotDelay",6)&&this.spawn(this.loadOrderBook,e,h,r,null,{}),void a.cache.push(n)}o>=d||(this.handleDelta(a,n),e.resolve(a,h))}handleDelta(e,t){const s=this.safeTimestamp(t,"timestamp");e.timestamp=s,e.datetime=this.iso8601(s),e.nonce=this.safeInteger(t,"microtimestamp");const i=this.safeValue(t,"bids",[]),r=this.safeValue(t,"asks",[]),a=e.bids,o=e.asks;this.handleBidAsks(a,i),this.handleBidAsks(o,r)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=this.parseBidAsk(t[s]);e.storeArray(i)}}getCacheIndex(e,t){const s=t[0],i=this.safeInteger(s,"microtimestamp"),r=this.safeInteger(e,"nonce");if(r<i)return-1;for(let e=0;e<t.length;e++){const s=t[e];if(this.safeInteger(s,"microtimestamp")===r)return e+1}return t.length}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trades:"+(e=r.symbol),o=this.urls.api.ws,n={event:"bts:subscribe",data:{channel:"live_trades_"+r.id}},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"microtimestamp"),i=this.safeString(e,"id"),r=this.parseToInt(s/1e3),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),n=t.symbol,d=0===this.safeInteger(e,"type")?"buy":"sell";return this.safeTrade({info:e,timestamp:r,datetime:this.iso8601(r),symbol:n,id:i,order:void 0,type:void 0,takerOrMaker:void 0,side:d,price:a,amount:o,cost:void 0,fee:void 0},t)}handleTrade(e,t){const s=this.safeString(t,"channel").split("_"),i=this.safeString(s,2),r=this.safeMarket(i),o=r.symbol,n="trades:"+o,d=this.safeValue(t,"data"),h=this.parseWsTrade(d,r);let c=this.safeValue(this.trades,o);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[o]=c}c.append(h),e.resolve(c,n)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="private-my_orders",n=o+"_"+a.id,d={symbol:e,limit:s,type:o,params:i},h=await this.subscribePrivate(d,n,i);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleOrders(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"data",{}),r=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(r));const o=this.orders,n=this.safeValue(e.subscriptions,s),d=this.safeString(n,"symbol"),h=this.market(d),c=this.parseWsOrder(i,h);o.append(c),e.resolve(this.orders,s)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"id_str"),i=this.safeStringLower(e,"order_type"),r=this.safeString(e,"price_str"),a=this.safeString(e,"amount_str"),o="1"===i?"sell":"buy",n=this.safeTimestamp(e,"datetime"),d=(t=this.safeMarket(void 0,t)).symbol;return this.safeOrder({info:e,symbol:d,id:s,clientOrderId:void 0,timestamp:n,datetime:this.iso8601(n),lastTradeTimestamp:void 0,type:void 0,timeInForce:void 0,postOnly:void 0,side:o,price:r,stopPrice:void 0,triggerPrice:void 0,amount:a,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0},t)}handleOrderBookSubscription(e,t){const s=this.safeString(t,"channel").split("_"),i=this.safeString(s,3),r=this.safeSymbol(i);this.orderbooks[r]=this.orderBook()}handleSubscriptionStatus(e,t){this.safeString(t,"channel").indexOf("order_book")>-1&&this.handleOrderBookSubscription(e,t)}handleSubject(e,t){const s=this.safeString(t,"channel"),i={live_trades:this.handleTrade,diff_order_book:this.handleOrderBook,"private-my_orders":this.handleOrders},r=Object.keys(i);for(let a=0;a<r.length;a++){const o=r[a];if(s.indexOf(o)>-1){i[o].call(this,e,t)}}}handleErrorMessage(e,t){if("bts:error"===this.safeString(t,"event")){const e=this.id+" "+this.json(t),s=this.safeValue(t,"data",{}),i=this.safeNumber(s,"code");this.throwExactlyMatchedException(this.exceptions.exact,i,e)}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;"bts:subscription_succeeded"===this.safeString(t,"event")?this.handleSubscriptionStatus(e,t):this.handleSubject(e,t)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.milliseconds(),s=this.safeInteger(this.options,"expiresIn");if(void 0===s||t>s){const s=await this.privatePostWebsocketsToken(e),i=this.safeString(s,"token");if(void 0!==i){const e=this.safeNumber(s,"user_id"),r=this.safeIntegerProduct(s,"valid_sec",1e3);this.options.expiresIn=this.sum(t,r),this.options.userId=e,this.options.wsSessionToken=i}}}async subscribePrivate(e,t,s={}){const i=this.urls.api.ws;await this.authenticate();const r={event:"bts:subscribe",data:{channel:t+="-"+this.options.userId,auth:this.options.wsSessionToken}};return e.messageHash=t,await this.watch(i,t,this.extend(r,s),t,e)}}},1327:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(3727),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelOrdersWs:!1,fetchTradesWs:!1,watchOrderBook:!0,watchTrades:!0,watchTicker:!0,watchOHLCV:!0,watchOrders:!0,watchMyTrades:!0,cancelAllOrdersWs:!0,cancelOrderWs:!0,createOrderWs:!0,createStopLimitOrderWs:!0,createStopMarketOrderWs:!0,createStopOrderWs:!0,editOrderWs:!0,fetchBalanceWs:!0,fetchCurrenciesWS:!0,fetchDepositAddressWs:!0,fetchDepositsWs:!0,fetchDepositWithdrawFeesWs:!0,fetchMyTradesWs:!0,fetchOHLCVWs:!0,fetchOpenOrdersWs:!0,fetchOrderWs:!0,fetchOrderBookWs:!0,fetchOrdersWs:!0,fetchTickerWs:!0,fetchTickersWs:!0,fetchTimeWs:!0,fetchTradingFeesWs:!0,fetchWithdrawalsWs:!0,withdrawWs:!0},urls:{api:{ws:"wss://ws.bitvavo.com/v2"}},options:{supressMultipleWsRequestsError:!1,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),r=e+"@"+i.id,a=this.urls.api.ws,o={action:"subscribe",channels:[{name:e,markets:[i.id]}]},n=this.extend(o,s);return await this.watch(a,r,n,r)}async watchTicker(e,t={}){return await this.watchPublic("ticker24h",e,t)}handleTicker(e,t){const s=this.safeString(t,"event"),i=this.safeValue(t,"data",[]);for(let t=0;t<i.length;t++){const r=i[t],a=this.safeString(r,"market"),o=this.safeMarket(a,void 0,"-"),n=s+"@"+a,d=this.parseTicker(r,o),h=d.symbol;this.tickers[h]=d,e.resolve(d,n)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.watchPublic("trades",e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),r=i.symbol,o="trades@"+s,n=this.parseTrade(t,i);let d=this.safeValue(this.trades,r);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new a.I3(e)}d.append(n),this.trades[r]=d,e.resolve(d,o)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=a.id,n=this.safeString(this.timeframes,t,t),d="candles@"+o+"_"+n,h=this.urls.api.ws,c={action:"subscribe",channels:[{name:"candles",interval:[n],markets:[o]}]},l=this.extend(c,r),u=await this.watch(h,d,l,d);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleFetchOHLCV(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"response"),r=this.parseOHLCVs(i,void 0,void 0,void 0),a=this.buildMessageHash(s);e.resolve(r,a)}handleOHLCV(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),r=i.symbol,o=this.safeString(t,"interval"),n=this.findTimeframe(o),d="candles@"+s+"_"+o,h=this.safeValue(t,"candle");this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let c=this.safeValue(this.ohlcvs[r],n);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[r][n]=c}for(let e=0;e<h.length;e++){const t=h[e],s=this.parseOHLCV(t,i);c.append(s)}e.resolve(c,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r="book",a=r+"@"+i.id,o=this.urls.api.ws,n={action:"subscribe",channels:[{name:r,markets:[i.id]}]},d={messageHash:a,name:r,symbol:e,marketId:i.id,method:this.handleOrderBookSubscription,limit:t,params:s},h=this.extend(n,s);return(await this.watch(o,a,h,a,d)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeInteger(t,"nonce");return i>s.nonce&&(this.handleDeltas(s.asks,this.safeValue(t,"asks",[])),this.handleDeltas(s.bids,this.safeValue(t,"bids",[])),s.nonce=i),s}handleOrderBook(e,t){const s=this.safeString(t,"event"),i=this.safeString(t,"market"),r=this.safeMarket(i,void 0,"-"),a=r.symbol,o=s+"@"+r.id,n=this.safeValue(this.orderbooks,a);if(void 0!==n)if(void 0===n.nonce){const s=this.safeValue(e.subscriptions,o,{});if(void 0===this.safeValue(s,"watchingOrderBookSnapshot")){s.watchingOrderBookSnapshot=!0,e.subscriptions[o]=s;const i=this.safeValue(this.options,"watchOrderBookSnapshot",{}),r=this.safeInteger(i,"delay",this.rateLimit);this.delay(r,this.watchOrderBookSnapshot,e,t,s)}n.cache.push(t)}else this.handleOrderBookMessage(e,t,n),e.resolve(n,o)}async watchOrderBookSnapshot(e,t,s){const i=this.safeValue(s,"params"),r=this.safeString(s,"marketId"),a="getBook",o=a+"@"+r,n=this.urls.api.ws,d={action:a,market:r};return(await this.watch(n,o,this.extend(d,i),o,s)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"response");if(void 0===s)return;const i=this.safeString(s,"market"),r=this.safeSymbol(i,void 0,"-"),a="book@"+i,o=this.orderbooks[r],n=this.parseOrderBook(s,r);n.nonce=this.safeInteger(s,"nonce"),o.reset(n);const d=o.cache;for(let t=0;t<d.length;t++){const s=d[t];this.handleOrderBookMessage(e,s,o)}this.orderbooks[r]=o,e.resolve(o,a)}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},r)}handleOrderBookSubscriptions(e,t,s){for(let i=0;i<s.length;i++){const r=this.safeString(s,i),a="book@"+r;if(!(this.safeSymbol(r,void 0,"-")in this.orderbooks)){const s=this.safeValue(e.subscriptions,a),i=this.safeValue(s,"method");void 0!==i&&i.call(this,e,t,s)}}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchOrders() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.market(e);e=a.symbol;const o=a.id,n=this.urls.api.ws,d="order:"+e,h={action:"subscribe",channels:[{name:"account",markets:[o]}]},c=await this.watch(n,d,h,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchMyTrades() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.market(e);e=a.symbol;const o=a.id,n=this.urls.api.ws,d="myTrades:"+e,h={action:"subscribe",channels:[{name:"account",markets:[o]}]},c=await this.watch(n,d,h,d);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets(),await this.authenticate();const o=this.createOrderRequest(e,t,s,i,r,a);return await this.watchRequest("privateCreateOrder",o)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets(),await this.authenticate();const n=this.editOrderRequest(e,t,s,i,r,a,o);return await this.watchRequest("privateUpdateOrder",n)}async cancelOrderWs(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.cancelOrderRequest(e,t,s);return await this.watchRequest("privateCancelOrder",i)}async cancelAllOrdersWs(e=void 0,t={}){await this.loadMarkets(),await this.authenticate();const s={};let i;return void 0!==e&&(i=this.market(e),s.market=i.id),await this.watchRequest("privateCancelOrders",this.extend(s,t))}handleMultipleOrders(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"response"),r=this.safeValue(i,0,{}),a=this.safeString(r,"market"),o=this.parseOrders(i);let n=this.buildMessageHash(s,{market:a});e.resolve(o,n),n=this.buildMessageHash(s,t),e.resolve(o,n)}async fetchOrderWs(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const i={orderId:e,market:this.market(t).id};return await this.watchRequest("privateGetOrder",this.extend(i,s))}async fetchOrdersWs(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrdersWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.fetchOrdersRequest(e,t,s,i),o=await this.watchRequest("privateGetOrders",a);return this.filterBySymbolSinceLimit(o,e,t,s)}async watchRequest(e,t){t.action=e;const s=this.buildMessageHash(e,t);this.checkMessageHashDoesNotExist(s);const i=this.urls.api.ws;return await this.watch(i,s,t,s)}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r={};let a;void 0!==e&&(a=this.market(e),r.market=a.id);const o=await this.watchRequest("privateGetOrdersOpen",this.extend(r,i));return this.filterBySymbolSinceLimit(o,e,t,s)}async fetchMyTradesWs(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTradesWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.fetchMyTradesRequest(e,t,s,i),o=await this.watchRequest("privateGetTrades",a);return this.filterBySymbolSinceLimit(o,e,t,s)}handleMyTrades(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"response"),r=this.safeValue(i,0,{}),a=this.safeString(r,"market"),o=this.parseTrades(i,void 0,void 0,void 0),n=this.buildMessageHash(s,{market:a});e.resolve(o,n)}async withdrawWs(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets(),await this.authenticate();const a=this.withdrawRequest(e,t,s,i,r);return await this.watchRequest("privateWithdrawAssets",a)}handleWithdraw(e,t){const s=this.safeString(t,"action"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response"),a=this.parseTransaction(r);e.resolve(a,i)}async fetchWithdrawalsWs(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r=this.fetchWithdrawalsRequest(e,t,s,i),a=await this.watchRequest("privateGetWithdrawalHistory",r);return this.filterByCurrencySinceLimit(a,e,t,s)}handleWithdraws(e,t){const s=this.safeString(t,"action"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response"),a=this.parseTransactions(r,void 0,void 0,void 0,{type:"withdrawal"});e.resolve(a,i)}async fetchOHLCVWs(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.fetchOHLCVRequest(e,t,s,i,r),o=await this.watchRequest("getCandles",a);return this.filterBySinceLimit(o,s,i,0,!0)}async fetchDepositsWs(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r=this.fetchDepositsRequest(e,t,s,i),a=await this.watchRequest("privateGetDepositHistory",r);return this.filterByCurrencySinceLimit(a,e,t,s)}handleDeposits(e,t){const s=this.safeString(t,"action"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response"),a=this.parseTransactions(r,void 0,void 0,void 0,{type:"deposit"});e.resolve(a,i)}async fetchTradingFeesWs(e={}){return await this.loadMarkets(),await this.authenticate(),await this.watchRequest("privateGetAccount",e)}async fetchMarketsWs(e={}){return await this.watchRequest("getMarkets",e)}async fetchCurrenciesWs(e={}){return await this.loadMarkets(),await this.watchRequest("getAssets",e)}handleFetchCurrencies(e,t){const s=this.safeString(t,"action"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response"),a=this.parseCurrencies(r);e.resolve(a,i)}handleTradingFees(e,t){const s=this.safeString(t,"action"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response"),a=this.parseTradingFees(r);e.resolve(a,i)}async fetchBalanceWs(e={}){return await this.loadMarkets(),await this.authenticate(),await this.watchRequest("privateGetBalance",e)}handleFetchBalance(e,t){const s=this.safeString(t,"action","privateGetBalance"),i=this.buildMessageHash(s,t),r=this.safeValue(t,"response",[]),a=this.parseBalance(r);e.resolve(a,i)}handleSingleOrder(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"response",{}),r=this.parseOrder(i),a=this.buildMessageHash(s,i);e.resolve(r,a)}handleMarkets(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"response",{}),r=this.parseMarkets(i),a=this.buildMessageHash(s,i);e.resolve(r,a)}buildMessageHash(e,t={}){const s={privateCreateOrder:this.actionAndMarketMessageHash,privateUpdateOrder:this.actionAndOrderIdMessageHash,privateCancelOrder:this.actionAndOrderIdMessageHash,privateGetOrder:this.actionAndOrderIdMessageHash,privateGetTrades:this.actionAndMarketMessageHash},i=this.safeValue(s,e);let r=e;return void 0!==i&&(r=i.call(this,e,t)),r}checkMessageHashDoesNotExist(e){if(!this.safeBool(this.options,"supressMultipleWsRequestsError",!1)){const t=this.safeValue(this.clients,this.urls.api.ws);if(void 0!==t){if(void 0!==this.safeValue(t.futures,e))throw new r.ExchangeError(this.id+" a similar request with messageHash "+e+" is already pending, you must wait for a response, or turn off this error by setting supressMultipleWsRequestsError in the options to true")}}}actionAndMarketMessageHash(e,t={}){return e+this.safeString(t,"market","")}actionAndOrderIdMessageHash(e,t={}){const s=this.safeString(t,"orderId");if(void 0===s)throw new r.ExchangeError(this.id+" privateUpdateOrderMessageHash requires a orderId parameter");return e+s}handleOrder(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),r="order:"+i.symbol,o=this.parseOrder(t,i);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}this.orders.append(o),e.resolve(this.orders,r)}handleMyTrade(e,t){const s=this.safeString(t,"market"),i=this.safeMarket(s,void 0,"-"),r="myTrades:"+i.symbol,o=this.parseTrade(t,i);if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.I3(e)}const n=this.myTrades;n.append(o),e.resolve(n,r)}handleSubscriptionStatus(e,t){const s=this.safeValue(t,"subscriptions",{}),i={book:this.handleOrderBookSubscriptions},r=Object.keys(s);for(let a=0;a<r.length;a++){const o=r[a],n=this.safeValue(i,o);if(void 0!==n){const i=this.safeValue(s,o);n.call(this,e,t,i)}}return t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated";let r=this.safeValue(s.subscriptions,i);if(void 0===r){const a=this.milliseconds(),n=a.toString()+"GET/"+this.version+"/websocket",d=this.hmac(this.encode(n),this.encode(this.secret),o.s),h={action:"authenticate",key:this.apiKey,signature:d,timestamp:a},c=this.extend(h,e);r=await this.watch(t,i,c,i),s.subscriptions[i]=r}return r}handleAuthenticationMessage(e,t){const s="authenticated";if(this.safeBool(t,"authenticated",!1))e.resolve(t,s);else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}}handleErrorMessage(e,t){const s=this.safeString(t,"error"),i=this.safeInteger(s,"errorCode"),r=this.safeString(t,"action"),a=this.buildMessageHash(r,t);let o=!1;try{this.handleErrors(i,s,e.url,void 0,void 0,s,t,void 0,void 0)}catch(t){o=!0,e.reject(t,a)}o||e.reject(t,a)}handleMessage(e,t){void 0!==this.safeString(t,"error")&&this.handleErrorMessage(e,t);const s={subscribed:this.handleSubscriptionStatus,book:this.handleOrderBook,getBook:this.handleOrderBookSnapshot,trade:this.handleTrade,candle:this.handleOHLCV,ticker24h:this.handleTicker,authenticate:this.handleAuthenticationMessage,order:this.handleOrder,fill:this.handleMyTrade,privateCreateOrder:this.handleSingleOrder,privateUpdateOrder:this.handleSingleOrder,privateGetBalance:this.handleFetchBalance,privateCancelOrders:this.handleMultipleOrders,privateGetOrders:this.handleMultipleOrders,privateGetOrder:this.handleSingleOrder,privateCancelOrder:this.handleSingleOrder,privateGetOrdersOpen:this.handleMultipleOrders,privateGetAccount:this.handleTradingFees,privateGetDepositHistory:this.handleDeposits,privateGetWithdrawalHistory:this.handleWithdraws,privateWithdrawAssets:this.handleWithdraw,privateGetTrades:this.handleMyTrades,getAssets:this.handleFetchCurrencies,getCandles:this.handleFetchOHLCV,getMarkets:this.handleMarkets},i=this.safeString(t,"event");let r=this.safeValue(s,i);if(void 0===r){const i=this.safeString(t,"action");r=this.safeValue(s,i),void 0!==r&&r.call(this,e,t)}else r.call(this,e,t)}}},8693:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(3205),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://ws.blockchain.info/mercury-gateway/v1/ws"}},options:{ws:{options:{headers:{Origin:"https://exchange.blockchain.com"}},noOriginHeader:!1}},streaming:{},exceptions:{},timeframes:{"1m":"60","5m":"300","15m":"900","1h":"3600","6h":"21600","1d":"86400"}})}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.deepExtend({action:"subscribe",channel:"balances"},e);return await this.watch(s,t,i,t,i)}handleBalance(e,t){if("subscribed"===this.safeString(t,"event"))return;const s={info:t},i=this.safeValue(t,"balances",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(t,"available"),o.total=this.safeString(t,"balance"),s[a]=o}this.balance=this.safeBalance(s),e.resolve(this.balance,"balance")}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeString(this.timeframes,t,t),n="ohlcv:"+e;let d={action:"subscribe",channel:"prices",symbol:a.id,granularity:this.parseNumber(o)};d=this.deepExtend(d,r);const h=this.urls.api.ws,c=await this.watch(h,n,d,n,d);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"event");if("rejected"===s){const e=this.json(t);throw new r.ExchangeError(this.id+" "+e)}if("updated"===s){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s,void 0,"-"),r="ohlcv:"+i,o=this.safeValue(e.subscriptions,r),n=this.safeNumber(o,"granularity"),d=this.findTimeframe(n),h=this.safeValue(t,"price",[]);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let c=this.safeValue(this.ohlcvs[i],d);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[i][d]=c}c.append(h),e.resolve(c,r)}else if("subscribed"!==s)throw new r.NotSupported(this.id+" "+this.json(t))}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws,r="ticker:"+e;let a={action:"subscribe",channel:"ticker",symbol:s.id};return a=this.deepExtend(a,t),await this.watch(i,r,a,r)}handleTicker(e,t){const s=this.safeString(t,"event"),i=this.safeString(t,"symbol"),r=this.safeMarket(i),a=r.symbol;let o;if("subscribed"===s)return;if("snapshot"===s)o=this.parseTicker(t,r);else if("updated"===s){const e=this.safeValue(this.tickers,a);o=this.parseWsUpdatedTicker(t,e,r)}const n="ticker:"+a;this.tickers[a]=o,e.resolve(o,n)}parseWsUpdatedTicker(e,t=void 0,s=void 0){const i=this.safeString(e,"symbol"),r=this.safeSymbol(i,void 0,"-"),a=this.safeString(e,"mark_price");return this.safeTicker({symbol:r,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(t,"open"),close:void 0,last:a,previousClose:this.safeString(t,"close"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(t,"baseVolume"),quoteVolume:void 0,info:this.extend(this.safeValue(t,"info",{}),e)},s)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o="trades:"+e;let n={action:"subscribe",channel:"trades",symbol:r.id};n=this.deepExtend(n,i);const d=await this.watch(a,o,n,o,n);return this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrades(e,t){if("updated"!==this.safeString(t,"event"))return;const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r=this.safeMarket(s),o="trades:"+i;let n=this.safeValue(this.trades,i);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[i]=n}const d=this.parseWsTrade(t,r);n.append(d),this.trades[i]=n,e.resolve(this.trades[i],o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeString(e,"timestamp");return this.safeTrade({id:this.safeString(e,"trade_id"),timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,t,"-"),order:void 0,type:void 0,side:this.safeString(e,"side"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"qty"),cost:void 0,fee:void 0,info:e},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),await this.authenticate(),void 0!==e){e=this.market(e).symbol}const r=this.urls.api.ws,a="orders",o=this.deepExtend({action:"subscribe",channel:"trading"},i),n=await this.watch(r,a,o,a);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}handleOrders(e,t){const s=this.safeString(t,"event"),i=this.orders;if(void 0===i){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}if("subscribed"!==s){if("rejected"===s)throw new r.ExchangeError(this.id+" "+this.json(t));if("snapshot"===s){const e=this.safeValue(t,"orders",[]);for(let t=0;t<e.length;t++){const s=e[t],r=this.parseWsOrder(s);i.append(r)}}else if("updated"===s){const e=this.parseWsOrder(t);i.append(e)}this.orders=i,e.resolve(this.orders,"orders")}}parseWsOrder(e,t=void 0){const s=this.safeString(e,"transactTime"),i=this.safeString(e,"ordStatus"),r=this.safeString(e,"symbol");t=this.safeMarket(r,t);const a=this.safeString(e,"tradeId"),o=[];return"0"!==a&&o.push({id:a}),this.safeOrder({id:this.safeString(e,"orderID"),clientOrderId:this.safeString(e,"clOrdID"),datetime:s,timestamp:this.parse8601(s),status:this.parseWsOrderStatus(i),symbol:this.safeSymbol(r,t),type:this.safeString(e,"ordType"),timeInForce:this.safeString(e,"timeInForce"),postOnly:"ALO"===this.safeString(e,"execInst"),side:this.safeString(e,"side"),price:this.safeString(e,"price"),stopPrice:this.safeString(e,"stopPx"),cost:void 0,amount:this.safeString(e,"orderQty"),filled:this.safeString(e,"cumQty"),remaining:this.safeString(e,"leavesQty"),trades:o,fee:{rate:void 0,cost:this.safeNumber(e,"fee"),currency:this.safeString(t,"quote")},info:e,lastTradeTimestamp:void 0,average:this.safeString(e,"avgPx")},t)}parseWsOrderStatus(e){return this.safeString({pending:"open",open:"open",rejected:"rejected",cancelled:"canceled",filled:"closed",partial:"open",expired:"expired"},e,e)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.urls.api.ws,a=this.safeString(s,"type","l2");s=this.omit(s,"type");const o="orderbook:"+e+":"+a,n={action:"subscribe",channel:a,symbol:i.id},d=this.deepExtend(n,s);return(await this.watch(r,o,d,o)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"event");if("subscribed"===s)return;const i=this.safeString(t,"channel"),a=this.safeString(t,"symbol"),o=this.safeSymbol(a),n="orderbook:"+o+":"+i,d=this.safeString(t,"timestamp"),h=this.parse8601(d);void 0===this.safeValue(this.orderbooks,o)&&(this.orderbooks[o]=this.countedOrderBook());const c=this.orderbooks[o];if("snapshot"===s){const e=this.parseOrderBook(t,o,h,"bids","asks","px","qty","num");c.reset(e)}else{if("updated"!==s)throw new r.NotSupported(this.id+" watchOrderBook() does not support "+s+" yet");{const e=this.safeList(t,"asks",[]),s=this.safeList(t,"bids",[]);this.handleDeltas(c.asks,e),this.handleDeltas(c.bids,s),c.timestamp=h,c.datetime=d}}e.resolve(c,n)}handleDelta(e,t){const s=this.parseBidAsk(t,"px","qty","num");e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"channel"),i={ticker:this.handleTicker,trades:this.handleTrades,prices:this.handleOHLCV,l2:this.handleOrderBook,l3:this.handleOrderBook,auth:this.handleAuthenticationMessage,balances:this.handleBalance,trading:this.handleOrders},a=this.safeValue(i,s);if(void 0===a)throw new r.NotSupported(this.id+" received an unsupported message: "+this.json(t));a.call(this,e,t)}handleAuthenticationMessage(e,t){if("subscribed"!==this.safeString(t,"event"))throw new r.AuthenticationError(this.id+" received an authentication error: "+this.json(t));const s=this.safeValue(e.futures,"authenticated");void 0!==s&&s.resolve(!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){this.checkRequiredCredentials();const s={action:"subscribe",channel:"auth",token:this.secret};return this.watch(t,i,this.extend(s,e),i)}return await r}}},1672:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2520),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchTicker:!0,watchTickers:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrders:!0,watchOrdersForSymbols:!0,watchPositions:!0},urls:{api:{ws:{swap:{public:"wss://openapi.blofin.com/ws/public",private:"wss://openapi.blofin.com/ws/private"}}}},options:{defaultType:"swap",tradesLimit:1e3,watchOrderBook:{channel:"books"},watchOrderBookForSymbols:{channel:"books"}},streaming:{ping:this.ping,keepAlive:25e3}})}ping(e){return"ping"}handlePong(e,t){e.lastPong=this.milliseconds()}async watchTrades(e,t=void 0,s=void 0,i={}){return i.callerMethodName="watchTrades",await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.watchMultipleWrapper(!0,"trades","watchTradesForSymbols",e,i);if(this.newUpdates){const e=this.safeDict(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeDict(t,"arg"),i=this.safeString(s,"channel"),r=this.safeList(t,"data");if(void 0!==r)for(let t=0;t<r.length;t++){const s=r[t],o=this.parseWsTrade(s),n=o.symbol;let d=this.safeValue(this.trades,n);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new a.I3(e),this.trades[n]=d}d.append(o);const h=i+":"+n;e.resolve(d,h)}}parseWsTrade(e,t=void 0){return this.parseTrade(e,t)}async watchOrderBook(e,t=void 0,s={}){return s.callerMethodName="watchOrderBook",await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){let i,a;if(await this.loadMarkets(),[i,s]=this.handleParamString(s,"callerMethodName","watchOrderBookForSymbols"),[a,s]=this.handleOptionAndParams(s,i,"channel","books"),"books"!==a)throw new r.NotSupported(this.id+" "+i+"() at this moment "+a+" is not supported, coming soon");return(await this.watchMultipleWrapper(!0,a,i,e,s)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"arg"),i=this.safeString(s,"channel"),r=this.safeDict(t,"data"),a=this.safeString(s,"instId"),o=this.safeMarket(a).symbol,n=i+":"+o;o in this.orderbooks||(this.orderbooks[o]=this.orderBook());const d=this.orderbooks[o],h=this.safeInteger(r,"ts");if("snapshot"===this.safeString(t,"action")){const e=this.parseOrderBook(r,o,h);e.nonce=this.safeInteger(r,"seqId"),d.reset(e)}else{const e=this.safeList(r,"asks",[]),t=this.safeList(r,"bids",[]);this.handleDeltasWithKeys(d.asks,e),this.handleDeltasWithKeys(d.bids,t),d.timestamp=h,d.datetime=this.iso8601(h)}this.orderbooks[o]=d,e.resolve(d,n)}async watchTicker(e,t={}){t.callerMethodName="watchTicker";e=this.market(e).symbol;return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){if(void 0===e)throw new r.NotSupported(this.id+" watchTickers() requires a list of symbols");const s=await this.watchMultipleWrapper(!0,"tickers","watchTickers",e,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeDict(t,"arg"),i=this.safeString(s,"channel"),r=this.safeList(t,"data");for(let t=0;t<r.length;t++){const s=this.parseWsTicker(r[t]),a=s.symbol,o=i+":"+a;this.tickers[a]=s,e.resolve(this.tickers[a],o)}}parseWsTicker(e,t=void 0){return this.parseTicker(e,t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){r.callerMethodName="watchOHLCV";return(await this.watchOHLCVForSymbols([[e,t]],s,i,r))[e][t]}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length||!Array.isArray(e[0]))throw new r.ArgumentsRequired(this.id+" watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]");await this.loadMarkets();const[a,o,n]=await this.watchMultipleWrapper(!0,"candle","watchOHLCVForSymbols",e,i);this.newUpdates&&(s=n.getLimit(a,s));const d=this.filterBySinceLimit(n,t,s,0,!0);return this.createOHLCVObject(a,o,d)}handleOHLCV(e,t){const s=this.safeDict(t,"arg"),i=this.safeString(s,"channel"),r=this.safeList(t,"data"),o=this.safeString(s,"instId"),n=this.safeMarket(o),d=n.symbol,h=i.replace("candle",""),c=this.findTimeframe(h);this.ohlcvs[d]=this.safeDict(this.ohlcvs,d,{});let l=this.safeValue(this.ohlcvs[d],c);if(void 0===l){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new a.TG(e),this.ohlcvs[d][c]=l}for(let e=0;e<r.length;e++){const t=r[e],s=this.parseOHLCV(t,n);l.append(s)}const u=[d,c,l],p="candle"+h+":"+d;e.resolve(u,p)}async watchBalance(e={}){let t;if(await this.loadMarkets(),await this.authenticate(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),"spot"===t)throw new r.NotSupported(this.id+" watchBalance() is not supported for spot markets yet");const s=t+":balance",i=this.getSubscriptionRequest([{channel:"account"}]),a=this.implodeHostname(this.urls.api.ws[t].private);return await this.watch(a,s,this.deepExtend(i,e),s)}handleBalance(e,t){const s="swap";s in this.balance||(this.balance[s]={}),this.balance[s]=this.parseWsBalance(t);const i=s+":balance";e.resolve(this.balance[s],i)}parseWsBalance(e){return this.parseBalance(e)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){i.callerMethodName="watchOrders";const r=void 0!==e?[e]:[];return await this.watchOrdersForSymbols(r,t,s,i)}async watchOrdersForSymbols(e,t=void 0,s=void 0,i={}){await this.authenticate(),await this.loadMarkets();const r=await this.watchMultipleWrapper(!1,"orders","watchOrdersForSymbols",e,i);if(this.newUpdates){const e=this.safeValue(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleOrders(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const s=this.orders,i=this.safeDict(t,"arg"),r=this.safeString(i,"channel"),o=this.safeList(t,"data");for(let t=0;t<o.length;t++){const i=this.parseWsOrder(o[t]),a=r+":"+i.symbol;s.append(i),e.resolve(s,a),e.resolve(s,r)}}parseWsOrder(e,t=void 0){return this.parseOrder(e,t)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(),await this.loadMarkets();const r=await this.watchMultipleWrapper(!1,"positions","watchPositions",e,i);return this.newUpdates?r:this.filterBySymbolsSinceLimit(this.positions,e,t,s)}handlePositions(e,t){void 0===this.positions&&(this.positions=new a.Hk);const s=this.positions,i=this.safeDict(t,"arg"),r=this.safeString(i,"channel"),o=this.safeList(t,"data"),n=[];for(let t=0;t<o.length;t++){const i=this.parseWsPosition(o[t]);n.push(i),s.append(i);const a=r+":"+i.symbol;e.resolve(i,a)}}parseWsPosition(e,t=void 0){return this.parsePosition(e,t)}async watchMultipleWrapper(e,t,s,i=void 0,a={}){await this.loadMarkets(),[s,a]=this.handleParamString(a,"callerMethodName",s);const o="candle"===t;let n,d=o?this.getListFromObjectValues(i,0):i;d=this.marketSymbols(d,void 0,!0,!0);const h=this.safeString(d,0);let c;if(void 0!==h&&(n=this.market(h)),[c,a]=this.handleMarketTypeAndParams(s,n,a),"swap"!==c)throw new r.NotSupported(this.id+" "+s+"() does not support "+c+" markets yet");let l=[];const u=[];void 0===d&&(d=[]);if(d.length>0)for(let e=0;e<d.length;e++){const s=d[e];let r,a=t;if(o){r=this.market(s);const t=i[e][1];a+=this.safeString(this.timeframes,t,t)}else r=this.market(s);const n={channel:a,instId:r.id};l.push(n),u.push(a+":"+r.symbol)}else l.push({channel:t}),u.push(t);this.inArray(t,["orders","positions"])&&(l=[{channel:t}]);const p=this.getSubscriptionRequest(l),f=e?"public":"private",m=this.implodeHostname(this.urls.api.ws[c][f]);return await this.watchMultiple(m,u,this.deepExtend(p,a),u)}getSubscriptionRequest(e){return{op:"subscribe",args:e}}handleMessage(e,t){const s={pong:this.handlePong,trades:this.handleTrades,books:this.handleOrderBook,tickers:this.handleTicker,candle:this.handleOHLCV,account:this.handleBalance,orders:this.handleOrders,positions:this.handlePositions};let i;if("pong"===t)i=this.safeValue(s,"pong");else{const a=this.safeString(t,"event");if("subscribe"===a)return;if("login"===a)return void e.resolve(t,"authenticate_hash");if("error"===a)throw new r.ExchangeError(this.id+" error: "+this.json(t));const o=this.safeDict(t,"arg"),n=this.safeString(o,"channel");i=this.safeValue(s,n),!i&&n.indexOf("candle")>=0&&(i=s.candle)}i&&i.call(this,e,t)}async authenticate(e={}){this.checkRequiredCredentials();const t="authenticate_hash",s=this.milliseconds().toString(),i="n_"+s,r="/users/self/verifyGET"+s+i,a=this.stringToBase64(this.hmac(this.encode(r),this.encode(this.secret),o.s)),n={op:"login",args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:s,nonce:i,sign:a}]},d=this.implodeHostname(this.urls.api.ws.swap.private);await this.watch(d,t,this.deepExtend(n,e),t)}}},8518:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(5462),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,createOrderWs:!0,editOrderWs:!0,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!0,cancelOrdersWs:!1,cancelAllOrdersWs:!1,fetchTradesWs:!1,fetchBalanceWs:!1,watchBalance:!0,watchLiquidations:!0,watchLiquidationsForSymbols:!1,watchMyLiquidations:!1,watchMyLiquidationsForSymbols:!1,watchMyTrades:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchPositions:!0,watchTradesForSymbols:!0},urls:{api:{ws:{public:{spot:"wss://stream.{hostname}/v5/public/spot",inverse:"wss://stream.{hostname}/v5/public/inverse",option:"wss://stream.{hostname}/v5/public/option",linear:"wss://stream.{hostname}/v5/public/linear"},private:{spot:{unified:"wss://stream.{hostname}/v5/private",nonUnified:"wss://stream.{hostname}/spot/private/v3"},contract:"wss://stream.{hostname}/v5/private",usdc:"wss://stream.{hostname}/trade/option/usdc/private/v1",trade:"wss://stream.bybit.com/v5/trade"}}},test:{ws:{public:{spot:"wss://stream-testnet.{hostname}/v5/public/spot",inverse:"wss://stream-testnet.{hostname}/v5/public/inverse",linear:"wss://stream-testnet.{hostname}/v5/public/linear",option:"wss://stream-testnet.{hostname}/v5/public/option"},private:{spot:{unified:"wss://stream-testnet.{hostname}/v5/private",nonUnified:"wss://stream-testnet.{hostname}/spot/private/v3"},contract:"wss://stream-testnet.{hostname}/v5/private",usdc:"wss://stream-testnet.{hostname}/trade/option/usdc/private/v1",trade:"wss://stream-testnet.bybit.com/v5/trade"}}},demotrading:{ws:{public:{spot:"wss://stream.{hostname}/v5/public/spot",inverse:"wss://stream.{hostname}/v5/public/inverse",option:"wss://stream.{hostname}/v5/public/option",linear:"wss://stream.{hostname}/v5/public/linear"},private:{spot:{unified:"wss://stream-demo.{hostname}/v5/private",nonUnified:"wss://stream-demo.{hostname}/spot/private/v3"},contract:"wss://stream-demo.{hostname}/v5/private",usdc:"wss://stream-demo.{hostname}/trade/option/usdc/private/v1",trade:"wss://stream-demo.bybit.com/v5/trade"}}}},options:{watchTicker:{name:"tickers"},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0},spot:{timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"}},contract:{timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","6h":"360","12h":"720","1d":"D","1w":"W","1M":"M"}}},streaming:{ping:this.ping,keepAlive:18e3}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async getUrlByMarketType(e=void 0,t=!1,s=void 0,i={}){const r=t?"private":"public";let a,o,n,d,h=this.urls.api.ws;if(void 0!==e)d=this.market(e),a="USDC"===d.settle,n=d.type;else{[n,i]=this.handleMarketTypeAndParams(s,void 0,i);let e=this.safeString(this.options,"defaultSettle");e=this.safeString2(i,"settle","defaultSettle",e),a="USDC"===e}if(o="spot"===n,t){const e=await this.isUnifiedEnabled(),t=this.safeBool(e,0,!1),s=this.safeBool(e,1,!1);h=!a||t||s?h[r].contract:h[r].usdc}else if(o)h=h[r].spot;else if("swap"===n||"future"===n){let e;[e,i]=this.handleSubTypeAndParams(s,d,i,"linear"),h=h[r][e]}else h=h[r].option;return h=this.implodeHostname(h),h}cleanParams(e){return e=this.omit(e,["type","subType","settle","defaultSettle","unifiedMargin"])}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.createOrderRequest(e,t,s,i,r,a,!0),n=this.urls.api.ws.private.trade;await this.authenticate(n);const d=this.requestId().toString(),h={op:"order.create",reqId:d,args:[o],header:{"X-BAPI-TIMESTAMP":this.milliseconds().toString(),"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()}};return await this.watch(n,d,h,d,!0)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.editOrderRequest(e,t,s,i,r,a,o),d=this.urls.api.ws.private.trade;await this.authenticate(d);const h=this.requestId().toString(),c={op:"order.amend",reqId:h,args:[n],header:{"X-BAPI-TIMESTAMP":this.milliseconds().toString(),"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()}};return await this.watch(d,h,c,h,!0)}async cancelOrderWs(e,t=void 0,s={}){await this.loadMarkets();const i=this.cancelOrderRequest(e,t,s),r=this.urls.api.ws.private.trade;await this.authenticate(r);const a=this.requestId().toString();"orderFilter"in i&&delete i.orderFilter;const o={op:"order.cancel",reqId:a,args:[i],header:{"X-BAPI-TIMESTAMP":this.milliseconds().toString(),"X-BAPI-RECV-WINDOW":this.options.recvWindow.toString()}};return await this.watch(r,a,o,a,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+(e=s.symbol),a=await this.getUrlByMarketType(e,!1,"watchTicker",t);t=this.cleanParams(t);const o=this.safeValue(this.options,"watchTicker",{});let n=this.safeString(o,"name","tickers");if(!s.spot&&"tickers"!==n)throw new r.BadRequest(this.id+" watchTicker() only supports name tickers for contract markets");n+="."+s.id;const d=[n];return await this.watchTopics(a,[i],d,t)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=[],i=await this.getUrlByMarketType(e[0],!1,"watchTickers",t);t=this.cleanParams(t);const r=this.safeValue(this.options,"watchTickers",{}),a=this.safeString(r,"name","tickers"),o=this.marketIds(e),n=[];for(let t=0;t<o.length;t++){const i=o[t];n.push(a+"."+i),s.push("ticker:"+e[t])}const d=await this.watchTopics(i,s,n,t);if(this.newUpdates){const e={};return e[d.symbol]=d,e}return this.filterByArray(this.tickers,"symbol",e)}async unWatchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=this.safeValue(this.options,"watchTickers",{}),i=this.safeString(s,"name","tickers"),r=[],a=[],o=this.marketIds(e),n=[];for(let t=0;t<o.length;t++){const s=o[t],d=e[t];n.push(i+"."+s),a.push("ticker:"+d),r.push("unsubscribe:ticker:"+d)}const d=await this.getUrlByMarketType(e[0],!1,"watchTickers",t);return await this.unWatchTopics(d,"ticker",e,r,a,n,t)}async unWatchTicker(e,t={}){return await this.loadMarkets(),await this.unWatchTickers([e],t)}handleTicker(e,t){const s=this.safeString(t,"topic",""),i=this.safeString(t,"type",""),r=this.safeDict(t,"data",{}),a=void 0!==this.safeString(r,"usdIndexPrice")?"spot":"contract";let o,n;if("snapshot"===i)n=this.parseTicker(r),o=n.symbol;else if("delta"===i){const e=s.split("."),t=e.length,i=this.safeString(e,t-1);o=this.safeMarket(i,void 0,void 0,a).symbol;const d=this.safeDict(this.tickers,o,{}),h=this.safeDict(d,"info",{}),c=this.extend(h,r);n=this.parseTicker(c)}const d=this.safeInteger(t,"ts");n.timestamp=d,n.datetime=this.iso8601(d),this.tickers[o]=n;const h="ticker:"+o;e.resolve(this.tickers[o],h)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){r.callerMethodName="watchOHLCV";return(await this.watchOHLCVForSymbols([[e,t]],s,i,r))[e][t]}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.getListFromObjectValues(e,0),a=this.marketSymbols(r,void 0,!1,!0,!0)[0],o=await this.getUrlByMarketType(a,!1,"watchOHLCVForSymbols",i),n=[],d=[];for(let t=0;t<e.length;t++){const s=e[t];let i=this.safeString(s,0);const r=this.market(i);i=r.symbol;const a=this.safeString(s,1),o=this.safeString(this.timeframes,a,a);n.push("kline."+o+"."+r.id),d.push("ohlcv::"+i+"::"+a)}const[h,c,l]=await this.watchTopics(o,d,n,i);this.newUpdates&&(s=l.getLimit(h,s));const u=this.filterBySinceLimit(l,t,s,0,!0);return this.createOHLCVObject(h,c,u)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic").split("."),r=i.length,o=this.safeString(i,1),n=this.findTimeframe(o),d=this.safeString(i,r-1),h=e.url.indexOf("spot")>-1?"spot":"contract",c=this.safeMarket(d,void 0,void 0,h).symbol,l=this.safeValue(this.ohlcvs,c);if(void 0===l&&(this.ohlcvs[c]={}),void 0===this.safeValue(l,n)){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[c][n]=new a.TG(e)}const u=this.ohlcvs[c][n];for(let e=0;e<s.length;e++){const t=this.parseWsOHLCV(s[e]);u.append(t)}const p="ohlcv::"+c+"::"+n,f=[c,n,u];e.resolve(f,p)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"start"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber2(e,"volume","turnover")]}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets();if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchOrderBookForSymbols() requires a non-empty array of symbols");e=this.marketSymbols(e);const i=await this.getUrlByMarketType(e[0],!1,"watchOrderBook",s);s=this.cleanParams(s);const a=this.market(e[0]);if(void 0===t)t=a.spot?50:500;else if(!a.spot&&1!==t&&50!==t&&200!==t&&500!==t)throw new r.BadRequest(this.id+" watchOrderBookForSymbols() can only use limit 1, 50, 200 and 500.");const o=[],n=[];for(let s=0;s<e.length;s++){const i=e[s],r=this.marketId(i),a="orderbook."+t.toString()+"."+r;o.push(a);const d="orderbook:"+i;n.push(d)}return(await this.watchTopics(i,n,o,s)).limit()}async unWatchOrderBookForSymbols(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);let s="orderbook.",i=this.safeInteger(t,"limit");if(void 0!==i)t=this.omit(t,"limit");else{i=this.market(e[0]).spot?50:500}s+=i.toString();const r=[],a=[],o=[];for(let t=0;t<e.length;t++){const i=e[t],n=s+"."+this.market(i).id;a.push("unsubscribe:orderbook:"+i),r.push("orderbook:"+i),o.push(n)}const n=await this.getUrlByMarketType(e[0],!1,"watchOrderBook",t);return await this.unWatchTopics(n,"orderbook",e,a,r,o,t)}async unWatchOrderBook(e,t={}){return await this.loadMarkets(),await this.unWatchOrderBookForSymbols([e],t)}handleOrderBook(e,t){const s=e.url.indexOf("spot")>=0,i="snapshot"===this.safeString(t,"type"),r=this.safeDict(t,"data",{}),a=this.safeString(r,"s"),o=s?"spot":"contract",n=this.safeMarket(a,void 0,void 0,o).symbol,d=this.safeInteger(t,"ts");n in this.orderbooks||(this.orderbooks[n]=this.orderBook());const h=this.orderbooks[n];if(i){const e=this.parseOrderBook(r,n,d,"b","a");h.reset(e)}else{const e=this.safeList(r,"a",[]),t=this.safeList(r,"b",[]);this.handleDeltas(h.asks,e),this.handleDeltas(h.bids,t),h.timestamp=d,h.datetime=this.iso8601(d)}const c="orderbook:"+n;this.orderbooks[n]=h,e.resolve(h,c)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();if(0===(e=this.marketSymbols(e)).length)throw new r.ArgumentsRequired(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");i=this.cleanParams(i);const a=await this.getUrlByMarketType(e[0],!1,"watchTrades",i),o=[],n=[];for(let t=0;t<e.length;t++){const s=e[t],i="publicTrade."+this.market(s).id;o.push(i);const r="trade:"+s;n.push(r)}const d=await this.watchTopics(a,n,o,i);if(this.newUpdates){const e=this.safeValue(d,0),t=this.safeString(e,"symbol");s=d.getLimit(t,s)}return this.filterBySinceLimit(d,t,s,"timestamp",!0)}async unWatchTradesForSymbols(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0);const s=await this.getUrlByMarketType(e[0],!1,"unWatchTradesForSymbols",t),i=[],r=[],a=[];for(let t=0;t<e.length;t++){const s=e[t],o="publicTrade."+this.market(s).id;r.push(o);const n="unsubscribe:trade:"+s;i.push(n),a.push("trade:"+s)}return await this.unWatchTopics(s,"trade",e,i,a,r,t)}async unWatchTrades(e,t={}){return await this.loadMarkets(),await this.unWatchTradesForSymbols([e],t)}handleTrades(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic").split("."),r=e.url.indexOf("spot")>=0?"spot":"contract",o=this.safeString(i,1),n=this.safeMarket(o,void 0,void 0,r),d=n.symbol;let h=this.safeValue(this.trades,d);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e),this.trades[d]=h}for(let e=0;e<s.length;e++){const t=this.parseWsTrade(s[e],n);h.append(t)}const c="trade:"+d;e.resolve(h,c)}parseWsTrade(e,t=void 0){const s=this.safeStringN(e,["i","T","v"]);let i="BT"in e?"contract":"spot";void 0!==t&&(i=t.type);const r=this.safeString(e,"s"),a=(t=this.safeMarket(r,t,void 0,i)).symbol,o=this.safeInteger2(e,"t","T");let n,d=this.safeStringLower(e,"S");const h=this.safeValue(e,"m");void 0===d?d=h?"buy":"sell":n=h;const c=this.safeString(e,"p"),l=this.safeString2(e,"q","v"),u=this.safeString(e,"o");return this.safeTrade({id:s,info:e,timestamp:o,datetime:this.iso8601(o),symbol:a,order:u,type:void 0,side:d,takerOrMaker:n,price:c,amount:l,cost:void 0,fee:void 0},t)}getPrivateType(e){return e.indexOf("spot")>=0?"spot":e.indexOf("v5/private")>=0?"unified":"usdc"}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r="myTrades";await this.loadMarkets(),void 0!==e&&(r+=":"+(e=this.symbol(e)));const a=await this.getUrlByMarketType(e,!0,"watchMyTrades",i);await this.authenticate(a);const o=this.safeValue({spot:"ticketInfo",unified:"execution",usdc:"user.openapi.perp.trade"},this.getPrivateType(a)),n=await this.watchTopics(a,[r],[o],i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}async unWatchMyTrades(e=void 0,t={}){let s="myTrades";await this.loadMarkets(),void 0!==e&&(s+=":"+(e=this.symbol(e)));const i=await this.getUrlByMarketType(e,!0,"watchMyTrades",t);await this.authenticate(i);const r=this.safeValue({spot:"ticketInfo",unified:"execution",usdc:"user.openapi.perp.trade"},this.getPrivateType(i));return await this.unWatchTopics(i,"myTrades",[],["unsubscribe:myTrades"],[s],[r],t)}handleMyTrades(e,t){const s="ticketInfo"===this.safeString(t,"topic");let i=this.safeValue(t,"data",[]);if(Array.isArray(i)||(i=this.safeValue(i,"result",[])),void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const r=this.myTrades,o={};for(let e=0;e<i.length;e++){const t=i[e];let a;a=s?this.parseWsTrade(t):this.parseTrade(t);o[a.symbol]=!0,r.append(a)}const n=Object.keys(o);for(let t=0;t<n.length;t++){const s="myTrades:"+n[t];e.resolve(r,s)}e.resolve(r,"myTrades")}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="";this.isEmpty(e)||(r="::"+(e=this.marketSymbols(e)).join(","));const a=this.safeString(e,0),o=await this.getUrlByMarketType(a,!0,"watchPositions",i);r="positions"+r;const n=this.client(o);await this.authenticate(o),this.setPositionsCache(n,e);const d=this.positions,h=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),c=this.handleOption("watchPositions","awaitPositionsSnapshot",!0);if(h&&c&&void 0===d){const i=await n.future("fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const l=await this.watchTopics(o,[r],["position"],i);return this.newUpdates?l:this.filterBySymbolsSinceLimit(d,e,t,s,!0)}setPositionsCache(e,t=void 0){if(void 0!==this.positions)return;if(this.handleOption("watchPositions","fetchPositionsSnapshot",!0)){const t="fetchPositionsSnapshot";t in e.futures||(e.future(t),this.spawn(this.loadPositionsSnapshot,e,t))}else this.positions=new a.Hk}async loadPositionsSnapshot(e,t){const s=[this.fetchPositions(void 0,{type:"swap",subType:"linear"}),this.fetchPositions(void 0,{type:"swap",subType:"inverse"})],i=await Promise.all(s);this.positions=new a.Hk;const r=this.positions;for(let e=0;e<i.length;e++){const t=i[e];for(let e=0;e<t.length;e++){const s=t[e];r.append(s)}}e.futures[t].resolve(r),e.resolve(r,"position")}handlePositions(e,t){void 0===this.positions&&(this.positions=new a.Hk);const s=this.positions,i=[],r=this.safeValue(t,"data",[]);for(let e=0;e<r.length;e++){const t=r[e],a=this.parsePosition(t),o=this.safeString(a,"side");i.push(a),void 0===o||""===o?(a.side="long",s.append(a),a.side="short",s.append(a),a.side=void 0):s.append(a)}const o=this.findMessageHashes(e,"positions::");for(let t=0;t<o.length;t++){const s=o[t],r=s.split("::")[1].split(","),a=this.filterByArray(i,"symbol",r,!1);this.isEmpty(a)||e.resolve(a,s)}e.resolve(i,"positions")}async watchLiquidations(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=await this.getUrlByMarketType(e,!1,"watchLiquidations",i);i=this.cleanParams(i);const o="liquidations::"+e,n="liquidation."+r.id,d=await this.watchTopics(a,[o],[n],i);return this.newUpdates?d:this.filterBySymbolsSinceLimit(this.liquidations,[e],t,s,!0)}handleLiquidation(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i,void 0,"","contract"),o=r.symbol,n=this.parseWsLiquidation(s,r);let d=this.safeValue(this.liquidations,o);if(void 0===d){const e=this.safeInteger(this.options,"liquidationsLimit",1e3);d=new a.I3(e)}d.append(n),this.liquidations[o]=d,e.resolve([n],"liquidations"),e.resolve([n],"liquidations::"+o)}parseWsLiquidation(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,"","contract");const i=this.safeInteger(e,"updatedTime");return this.safeLiquidation({info:e,symbol:t.symbol,contracts:this.safeNumber(e,"size"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"price"),baseValue:void 0,quoteValue:void 0,timestamp:i,datetime:this.iso8601(i)})}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="orders";void 0!==e&&(r+=":"+(e=this.symbol(e)));const a=await this.getUrlByMarketType(e,!0,"watchOrders",i);await this.authenticate(a);const o=this.safeValue({spot:["order","stopOrder"],unified:["order"],usdc:["user.openapi.perp.order"]},this.getPrivateType(a)),n=await this.watchTopics(a,[r],o,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}async unWatchOrders(e=void 0,t={}){await this.loadMarkets();let s="orders";void 0!==e&&(s+=":"+(e=this.symbol(e)));const i=await this.getUrlByMarketType(e,!0,"watchOrders",t);await this.authenticate(i);const r=this.safeValue({spot:["order","stopOrder"],unified:["order"],usdc:["user.openapi.perp.order"]},this.getPrivateType(i));return await this.unWatchTopics(i,"orders",[],["unsubscribe:orders"],[s],r,t)}handleOrderWs(e,t){const s=this.safeString(t,"reqId"),i=this.safeDict(t,"data"),r=this.parseOrder(i);e.resolve(r,s)}handleOrder(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const s=this.orders;let i=this.safeValue(t,"data",[]);const r=this.safeValue(i,0,{}),o="spot"===this.safeString(r,"category");o||(i=this.safeValue(i,"result",i));const n={};for(let e=0;e<i.length;e++){let t;t=o?this.parseWsSpotOrder(i[e]):this.parseOrder(i[e]);n[t.symbol]=!0,s.append(t)}const d=Object.keys(n);for(let t=0;t<d.length;t++){const i="orders:"+d[t];e.resolve(s,i)}e.resolve(s,"orders")}parseWsSpotOrder(e,t=void 0){const s=this.safeString2(e,"i","orderId"),i=this.safeString2(e,"s","symbol"),r=this.safeSymbol(i,t,void 0,"spot"),a=this.safeInteger2(e,"O","createdTime");let o=this.safeString2(e,"p","price");"0"===o&&(o=void 0);const n=this.safeString2(e,"z","cumExecQty"),d=this.parseOrderStatus(this.safeString2(e,"X","orderStatus")),h=this.safeStringLower2(e,"S","side"),c=this.safeString2(e,"E","updatedTime"),l=this.safeString2(e,"f","timeInForce");let u;const p=this.safeString2(e,"Z","cumExecValue");let f,m=this.safeStringLower2(e,"o","orderType");void 0!==m&&m.indexOf("market")>=0&&(m="market"),u="market"===m&&"buy"===h?n:this.safeString2(e,"orderQty","qty");const g=this.safeString2(e,"n","cumExecFee");if(void 0!==g&&"0"!==g){const t=this.safeString(e,"N");f={cost:g,currency:this.safeCurrencyCode(t)}}const v=this.omitZero(this.safeString(e,"triggerPrice"));return this.safeOrder({info:e,id:s,clientOrderId:this.safeString2(e,"c","orderLinkId"),timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:c,symbol:r,type:m,timeInForce:l,postOnly:void 0,side:h,price:o,stopPrice:v,triggerPrice:v,takeProfitPrice:this.safeString(e,"takeProfit"),stopLossPrice:this.safeString(e,"stopLoss"),reduceOnly:this.safeValue(e,"reduceOnly"),amount:u,cost:p,average:this.safeString(e,"avgPrice"),filled:n,remaining:void 0,status:d,fee:f},t)}async watchBalance(e={}){await this.loadMarkets();let t,s,i="balances";[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e);const r=await this.isUnifiedEnabled(),a=this.safeBool(r,0,!1),o=this.safeBool(r,1,!1),n=await this.getUrlByMarketType(void 0,!0,"watchBalance",e);await this.authenticate(n);o&&(i+="inverse"===s?":contract":":unified"),a||o||(i+="spot"===t?":spot":":contract"),a&&(i+="spot"===t?":spot":"linear"===s?":unified":":contract");const d=[this.safeValue({spot:"outboundAccountInfo",unified:"wallet"},this.getPrivateType(n))];return await this.watchTopics(n,[i],d,e)}handleBalance(e,t){void 0===this.balance&&(this.balance={});let s="balance";const i=this.safeValue(t,"topic");let r,a,o=[];if("outboundAccountInfo"===i){a="spot";const e=this.safeValue(t,"data",[]);for(let t=0;t<e.length;t++){const s=this.safeValue(e[t],"B",[]);o=this.arrayConcat(o,s)}r=o}if("wallet"===i){const e=this.safeValue(t,"data",{});for(let t=0;t<e.length;t++){const t=this.safeValue(e,0,{});a=this.safeStringLower(t,"accountType"),o=this.arrayConcat(o,this.safeValue(t,"coin",[]))}r=e}for(let e=0;e<o.length;e++)this.parseWsBalance(o[e],a);if(void 0!==a){void 0===this.safeValue(this.balance,a)&&(this.balance[a]={}),this.balance[a].info=r;const i=this.safeInteger(t,"ts");this.balance[a].timestamp=i,this.balance[a].datetime=this.iso8601(i),this.balance[a]=this.safeBalance(this.balance[a]),s="balances:"+a,e.resolve(this.balance[a],s)}else{this.balance.info=r;const i=this.safeInteger(t,"ts");this.balance.timestamp=i,this.balance.datetime=this.iso8601(i),this.balance=this.safeBalance(this.balance),s="balances",e.resolve(this.balance,s)}}parseWsBalance(e,t=void 0){const s=this.account(),i=this.safeString2(e,"a","coin"),r=this.safeCurrencyCode(i);s.free=this.safeStringN(e,["availableToWithdraw","f","free","availableToWithdraw"]),s.used=this.safeString2(e,"l","locked"),s.total=this.safeString(e,"walletBalance"),void 0!==t?(void 0===this.safeValue(this.balance,t)&&(this.balance[t]={}),this.balance[t][r]=s):this.balance[r]=s}async watchTopics(e,t,s,i={}){const r={op:"subscribe",req_id:this.requestId(),args:s},a=this.extend(r,i);return await this.watchMultiple(e,t,a,t)}async unWatchTopics(e,t,s,i,r,a,o={}){const n=this.requestId(),d={op:"unsubscribe",req_id:n,args:a},h={id:n,topic:t,messageHashes:i,subMessageHashes:r,symbols:s},c=this.extend(d,o);return await this.watchMultiple(e,i,c,i,h)}async authenticate(e,t={}){this.checkRequiredCredentials();const s="authenticated",i=this.client(e),r=i.future(s);if(void 0===this.safeValue(i.subscriptions,s)){const i=this.milliseconds()+1e4,r=this.numberToString(i),a="GET/realtime"+r,n=this.hmac(this.encode(a),this.encode(this.secret),o.s,"hex"),d={op:"auth",args:[this.apiKey,r,n]},h=this.extend(d,t);this.watch(e,s,h,s)}return await r}handleErrorMessage(e,t){const s=this.safeStringN(t,["code","ret_code","retCode"]);try{if(void 0!==s&&"0"!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e);const i=this.safeString2(t,"retMsg","ret_msg");throw this.throwBroadlyMatchedException(this.exceptions.broad,i,e),new r.ExchangeError(e)}const e=this.safeValue(t,"success");if(void 0!==e&&!e){const e=this.safeString(t,"ret_msg"),s=this.safeValue(t,"request",{});throw"auth"===this.safeString(s,"op")?new r.AuthenticationError("Authentication failed: "+e):new r.ExchangeError(this.id+" "+e)}return!1}catch(s){if(s instanceof r.AuthenticationError){const t="authenticated";e.reject(s,t),t in e.subscriptions&&delete e.subscriptions[t]}else{const i=this.safeString(t,"reqId");e.reject(s,i)}return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if("pong"===this.safeString(t,"ret_msg"))return void this.handlePong(e,t);if(void 0!==this.safeInteger(t,"pong"))return void this.handlePong(e,t);if("sub"===this.safeString(t,"event"))return void this.handleSubscriptionStatus(e,t);const s=this.safeString2(t,"topic","op",""),i={orderbook:this.handleOrderBook,kline:this.handleOHLCV,order:this.handleOrder,stopOrder:this.handleOrder,ticker:this.handleTicker,trade:this.handleTrades,publicTrade:this.handleTrades,depth:this.handleOrderBook,wallet:this.handleBalance,outboundAccountInfo:this.handleBalance,execution:this.handleMyTrades,ticketInfo:this.handleMyTrades,"user.openapi.perp.trade":this.handleMyTrades,position:this.handlePositions,liquidation:this.handleLiquidation,pong:this.handlePong,"order.create":this.handleOrderWs,"order.amend":this.handleOrderWs,"order.cancel":this.handleOrderWs,auth:this.handleAuthenticate,unsubscribe:this.handleUnSubscribe},r=this.safeValue(i,s);if(void 0!==r)return void r.call(this,e,t);const a=Object.keys(i);for(let r=0;r<a.length;r++){const o=a[r];if(s.indexOf(a[r])>=0){return void i[o].call(this,e,t)}}"AUTH_RESP"===this.safeString(t,"type")&&this.handleAuthenticate(e,t)}ping(e){return{req_id:this.requestId(),op:"ping"}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"pong"),t}handleAuthenticate(e,t){const s=this.safeValue(t,"success"),i=this.safeInteger(t,"retCode"),a="authenticated";if(s||0===i){this.safeValue(e.futures,a).resolve(!0)}else{const s=new r.AuthenticationError(this.id+" "+this.json(t));e.reject(s,a),a in e.subscriptions&&delete e.subscriptions[a]}return t}handleSubscriptionStatus(e,t){return t}handleUnSubscribe(e,t){const s=this.safeString(t,"req_id"),i=Object.keys(e.subscriptions);for(let t=0;t<i.length;t++){const a=i[t];if(a in e.subscriptions&&a.startsWith("unsubscribe")){const t=e.subscriptions[a];if(s!==this.safeString(t,"id"))continue;const i=this.safeList(t,"messageHashes",[]),o=this.safeList(t,"subMessageHashes",[]);for(let s=0;s<i.length;s++){const n=i[s],d=o[s];n in e.subscriptions&&delete e.subscriptions[n],d in e.subscriptions&&delete e.subscriptions[d];const h=new r.UnsubscribeError(this.id+" "+a);e.reject(h,d),e.resolve(!0,n),this.cleanCache(t)}}}return t}cleanCache(e){const t=this.safeString(e,"topic"),s=this.safeList(e,"symbols",[]);if(s.length>0)for(let e=0;e<s.length;e++){const i=s[e];"trade"===t?delete this.trades[i]:"orderbook"===t?delete this.orderbooks[i]:"ticker"===t&&delete this.tickers[i]}else if("myTrades"===t){const e=Object.keys(this.myTrades);for(let t=0;t<e.length;t++)delete this.myTrades[e[t]]}else if("orders"===t){const e=Object.keys(this.orders);for(let t=0;t<e.length;t++)delete this.orders[e[t]]}}}},3774:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8846),r=s(4852),a=s(2079),o=s(5147),n=s(2931);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0,watchPosition:void 0,createOrderWs:!0,editOrderWs:!0,cancelOrderWs:!0,cancelOrdersWs:!0,fetchOrderWs:!0,fetchOpenOrdersWs:!0,fetchTickerWs:!0,fetchBalanceWs:!0},urls:{api:{ws:"wss://ws.cex.io/ws"}},options:{orderbook:{}},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchBalance(e={}){await this.authenticate(e);const t=this.requestId(),s=this.urls.api.ws,i={e:"get-balance",data:{},oid:this.requestId()},r=this.deepExtend(i,e);return await this.watch(s,t,r,t,r)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"balance",{}),r=this.safeValue(s,"obalance",{}),a={info:s},o=Object.keys(i);for(let e=0;e<o.length;e++){const t=o[e],s=this.account();s.free=this.safeString(i,t),s.used=this.safeString(r,t);a[this.safeCurrencyCode(t)]=s}this.balance=this.safeBalance(a);const n=this.safeString(t,"oid");e.resolve(this.balance,n)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const o=this.urls.api.ws,n="old:"+e;this.options.currentWatchTradeSymbol=e;const d=this.safeValue(this.clients,o);if(void 0!==d){const e=Object.keys(d.subscriptions);for(let t=0;t<e.length;t++){let s=e[t];if(s!==n&&(s=s.slice(0,3),"old"===s))throw new a.ExchangeError(this.id+" watchTrades() only supports watching one symbol at a time.")}}const h={e:"subscribe",rooms:["pair-"+r.base+"-"+r.quote]},c=this.deepExtend(h,i),l=await this.watch(o,"trades",c,n);for(let t=0;t<l.length;t++)l[t].symbol=e;return this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTradesSnapshot(e,t){const s=this.safeList(t,"data",[]),i=this.safeInteger(this.options,"tradesLimit",1e3),r=new n.I3(i),a=this.safeString(this.options,"currentWatchTradeSymbol");if(void 0===a)return;const o=this.market(a),d=s.length;for(let e=0;e<d;e++){const t=s[d-1-e],i=this.parseWsOldTrade(t,o);r.append(i)}this.trades=r,e.resolve(this.trades,"trades")}parseWsOldTrade(e,t=void 0){Array.isArray(e)||(e=e.split(":"));const s=this.safeString(e,0),i=this.safeInteger(e,1),r=this.safeString(e,2),a=this.safeString(e,3),o=this.safeString(e,4);return this.safeTrade({info:e,id:o,timestamp:i,datetime:this.iso8601(i),symbol:this.safeString(t,"symbol"),type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:a,amount:r,cost:void 0,fee:void 0},t)}handleTrade(e,t){const s=this.safeValue(t,"data",[]),i=this.trades,r=s.length;for(let e=0;e<r;e++){const t=s[r-1-e],a=this.parseWsOldTrade(t);i.append(a)}this.trades=i,e.resolve(this.trades,"trades")}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws,r="ticker:"+e;let a={e:"subscribe",rooms:["tickers"]},o="tickers";"private"===this.safeString(t,"method","private")&&(await this.authenticate(),a={e:"ticker",data:[s.baseId,s.quoteId],oid:this.requestId()},o="ticker:"+e);const n=this.deepExtend(a,t);return await this.watch(i,r,n,o)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",r=this.deepExtend({e:"subscribe",rooms:["tickers"]},t),a=await this.watch(s,i,r,i),o=a.symbol;if(void 0!==e&&!this.inArray(o,e))return await this.watchTickers(e,t);if(this.newUpdates){const e={};return e[o]=a,e}return this.filterByArray(this.tickers,"symbol",e)}async fetchTickerWs(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,r=this.requestId(),a=this.extend({e:"ticker",oid:r,data:[s.base,s.quote]},t);return await this.watch(i,r,a,r)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTicker(s),r=i.symbol;if(void 0===r)return;this.tickers[r]=i;let a="ticker:"+r;e.resolve(i,a),e.resolve(i,"tickers"),a=this.safeString(t,"oid"),void 0!==a&&e.resolve(i,a)}parseWsTicker(e,t=void 0){const s=this.safeValue(e,"pair",[]);let i=this.safeString(e,"symbol1");void 0===i&&(i=this.safeString(s,0));let r=this.safeString(e,"symbol2");void 0===r&&(r=this.safeString(s,1));const a=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(r);let o=this.safeInteger(e,"timestamp");return void 0!==o&&(o*=1e3),this.safeTicker({symbol:a,timestamp:o,datetime:this.iso8601(o),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open24"),close:void 0,last:this.safeString2(e,"price","last"),previousClose:void 0,change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercentage"),average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"volume"),info:e},t)}async fetchBalanceWs(e={}){await this.loadMarkets(),await this.authenticate();const t=this.urls.api.ws,s=this.requestId(),i=this.extend({e:"get-balance",oid:s},e);return await this.watch(t,s,i,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" watchOrders() requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const r=this.urls.api.ws,o=this.market(e),n="orders:"+(e=o.symbol),d={e:"open-orders",data:{pair:[o.baseId,o.quoteId]},oid:e},h=this.deepExtend(d,i),c=await this.watch(r,n,h,n,h);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" watchMyTrades() requires a symbol argument");await this.loadMarkets(),await this.authenticate(i);const r=this.urls.api.ws,o=this.market(e),n="myTrades:"+o.symbol,d="orders:"+o.symbol,h={e:"open-orders",data:{pair:[o.baseId,o.quoteId]},oid:o.symbol},c=this.deepExtend(h,i),l=await this.watch(r,n,c,d,c);return this.filterBySymbolSinceLimit(l,o.symbol,t,s)}handleTransaction(e,t){const s=this.safeValue(t,"data");void 0!==this.safeString(s,"symbol2")&&(this.handleOrderUpdate(e,t),this.handleMyTrades(e,t))}handleMyTrades(e,t){const s=this.safeValue(t,"data",{});let i=this.myTrades;if(void 0===i){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new n.Pt(e),this.myTrades=i}const r=this.parseWsTrade(s);i.append(r);const a="myTrades:"+r.symbol;e.resolve(i,a)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"type"),i=this.safeString(e,"price"),r=this.safeString(e,"time"),a=this.safeString(e,"symbol"),n=this.safeString(e,"symbol2"),d=this.safeCurrencyCode(a),h=this.safeCurrencyCode(n);let c=d+"/"+h,l=this.safeString(e,"amount");"sell"===s&&(c=h+"/"+d,l=o.Y.stringDiv(l,i));const u={id:this.safeString(e,"id"),order:this.safeString(e,"order"),info:e,timestamp:this.parse8601(r),datetime:r,symbol:c,type:void 0,side:s,takerOrMaker:void 0,price:i,cost:void 0,amount:l,fee:void 0},p=this.safeString(e,"fee_amount");return void 0!==p&&(u.fee={cost:p,currency:h,rate:void 0}),this.safeTrade(u,t)}handleOrderUpdate(e,t){const s=this.safeValue(t,"data",{}),i="tx"===this.safeString(t,"e"),r=this.safeString2(s,"id","order");let a=this.safeString(s,"remains"),o=this.safeString(s,"symbol"),d=this.safeString(s,"symbol2");const h=this.safeValue(s,"pair");void 0!==h&&(o=this.safeString(h,"symbol1"),d=this.safeString(h,"symbol2"));const c=this.safeCurrencyCode(o),l=this.safeCurrencyCode(d),u=c+"/"+l,p=this.safeMarket(u);if(a=this.currencyFromPrecision(c,a),void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new n.Pt(e)}const f=this.orders,m=this.safeValue(f.hashmap,u,{});let g=this.safeValue(m,r);void 0===g&&(g=this.parseWsOrderUpdate(s,p)),g.remaining=a;this.safeBool(s,"cancel",!1)&&(g.status="canceled"),i&&(g.status="closed");const v=this.safeNumber(s,"fee");void 0!==v&&(g.fee={cost:v,currency:l,rate:void 0});const y=this.safeInteger(s,"time");g.timestamp=y,g.datetime=this.iso8601(y),g=this.safeOrder(g),f.append(g);const w="orders:"+u;e.resolve(f,w)}parseWsOrderUpdate(e,t=void 0){const s=void 0!==this.safeValue(e,"d"),i=this.safeString(e,"remains");let r;void 0!==i&&(r=this.currencyFromPrecision(t.base,i));const a=this.safeString(e,"amount");s||this.currencyFromPrecision(t.base,a);let o=this.safeString(e,"symbol"),n=this.safeString(e,"symbol2");void 0!==this.safeValue(e,"pair")&&(o=this.safeString(e,"symbol1"),n=this.safeString(e,"symbol2"));const d=this.safeCurrencyCode(o),h=this.safeCurrencyCode(n);let c;void 0!==d&&void 0!==h&&(c=d+"/"+h),t=this.safeMarket(c,t);const l=this.safeInteger(e,"time",this.milliseconds());let u=l;s&&(u=this.parse8601(l));let p="open";this.safeBool(e,"cancel",!1)?p="canceled":s&&(p="closed");const f={id:this.safeString2(e,"id","order"),clientOrderId:void 0,info:e,timestamp:u,datetime:this.iso8601(u),lastTradeTimestamp:void 0,status:p,symbol:c,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:this.safeNumber(e,"price"),stopPrice:void 0,triggerPrice:void 0,average:void 0,cost:void 0,amount:a,filled:void 0,remaining:r,fee:{cost:this.safeNumber2(e,"fee","fee_amount"),currency:h,rate:void 0},trades:void 0};return s&&(f.trades=this.parseWsTrade(e,t)),this.safeOrder(f,t)}fromPrecision(e,t){if(void 0===e)return;const s=new o.Y(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}currencyFromPrecision(e,t){const s=this.safeInteger(this.currencies[e],"precision",0);return this.fromPrecision(t,s)}handleOrdersSnapshot(e,t){const s=this.safeString(t,"oid"),i=this.safeValue(t,"data",[]);let r=this.orders;if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);r=new n.Pt(e)}for(let e=0;e<i.length;e++){const t=i[e],a=this.safeMarket(s),o=this.parseOrder(t,a);o.status="open",r.append(o)}this.orders=r;const a="orders:"+s;r.length>0&&e.resolve(r,a)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.market(e);e=i.symbol;const r=this.urls.api.ws,a="orderbook:"+e,o=void 0===t?0:t,n={e:"order-book-subscribe",data:{pair:[i.baseId,i.quoteId],subscribe:!0,depth:o},oid:this.requestId()},d=this.deepExtend(n,s);return(await this.watch(r,a,d,a)).limit()}handleOrderBookSnapshot(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),r=this.pairToSymbol(i),a="orderbook:"+r,o=this.safeInteger2(s,"timestamp_ms","timestamp"),n=this.safeInteger(s,"id"),d=this.orderBook({}),h=this.parseOrderBook(s,r,o,"bids","asks");h.nonce=n,d.reset(h),this.options.orderbook[r]={incrementalId:n},this.orderbooks[r]=d,e.resolve(d,a)}pairToSymbol(e){const t=e.split(":"),s=this.safeString(t,0),i=this.safeString(t,1);return this.safeCurrencyCode(s)+"/"+this.safeCurrencyCode(i)}handleOrderBookUpdate(e,t){const s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"id"),r=this.safeString(s,"pair",""),a=this.pairToSymbol(r),o=this.safeValue(this.orderbooks,a),n="orderbook:"+a;i!==o.nonce+1&&(delete e.subscriptions[n],e.reject(this.id+" watchOrderBook() skipped a message",n));const d=this.safeInteger(s,"time"),h=this.safeValue(s,"asks",[]),c=this.safeValue(s,"bids",[]);this.handleDeltas(o.asks,h),this.handleDeltas(o.bids,c),o.timestamp=d,o.datetime=this.iso8601(d),o.nonce=i,e.resolve(o,n)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o="ohlcv:"+(e=a.symbol),n=this.urls.api.ws,d={e:"init-ohlcv",i:t,rooms:["pair-"+a.baseId+"-"+a.quoteId]},h=await this.watch(n,o,this.extend(d,r),o);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleInitOHLCV(e,t){const s=this.safeString(t,"pair").split(":"),i=this.safeString(s,0),r=this.safeString(s,1),a=this.safeCurrencyCode(i)+"/"+this.safeCurrencyCode(r),o=this.safeMarket(a),d="ohlcv:"+a,h=this.safeValue(t,"data",[]),c=this.safeInteger(this.options,"OHLCVLimit",1e3),l=new n.TG(c),u=this.sortBy(h,0);for(let e=0;e<u.length;e++)l.append(this.parseOHLCV(u[e],o));a in this.ohlcvs||(this.ohlcvs[a]={}),this.ohlcvs[a].unknown=l,e.resolve(l,d)}handleOHLCV24(e,t){return t}handleOHLCV1m(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"pair"),r=this.pairToSymbol(i),a="ohlcv:"+r,o=[this.safeTimestamp(s,"time"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")],n=this.safeValue(this.ohlcvs,r);n.append(o),e.resolve(n,a)}handleOHLCV(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"pair"),r=this.pairToSymbol(i),a="ohlcv:"+r,o=this.ohlcvs[r].unknown;for(let e=0;e<s.length;e++){const t=[this.safeTimestamp(s[e],0),this.safeNumber(s[e],1),this.safeNumber(s[e],2),this.safeNumber(s[e],3),this.safeNumber(s[e],4),this.safeNumber(s[e],5)];o.append(t)}s.length>0&&e.resolve(o,a)}async fetchOrderWs(e,t=void 0,s={}){let i;await this.loadMarkets(),await this.authenticate(),void 0!==t&&(i=this.market(t));const r=this.extend({order_id:e.toString()},s),a=this.urls.api.ws,o=this.requestId(),n={e:"get-order",oid:o,data:r},d=await this.watch(a,o,n,o);return this.parseOrder(d,i)}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+"fetchOpenOrdersWs requires a symbol.");await this.loadMarkets(),await this.authenticate();const r=this.market(e),o=this.urls.api.ws,n=this.requestId(),d={e:"open-orders",oid:n,data:this.extend({pair:[r.baseId,r.quoteId]},i)},h=await this.watch(o,n,d,n);return this.parseOrders(h,r,t,s,i)}async createOrderWs(e,t,s,i,r=void 0,o={}){if(void 0===r)throw new a.BadRequest(this.id+" createOrderWs requires a price argument");await this.loadMarkets(),await this.authenticate();const n=this.market(e),d=this.urls.api.ws,h=this.requestId(),c={e:"place-order",oid:h,data:this.extend({pair:[n.baseId,n.quoteId],amount:i,price:r,type:s},o)},l=await this.watch(d,h,c,h);return this.parseOrder(l,n)}async editOrderWs(e,t,s,i,r=void 0,o=void 0,n={}){if(void 0===r)throw new a.ArgumentsRequired(this.id+" editOrder() requires a amount argument");if(void 0===o)throw new a.ArgumentsRequired(this.id+" editOrder() requires a price argument");await this.loadMarkets(),await this.authenticate();const d=this.market(t),h=this.extend({pair:[d.baseId,d.quoteId],type:i,amount:r,price:o,order_id:e},n),c=this.requestId(),l=this.urls.api.ws,u={e:"cancel-replace-order",oid:c,data:h},p=await this.watch(l,c,u,c,c);return this.parseOrder(p,d)}async cancelOrderWs(e,t=void 0,s={}){let i;await this.loadMarkets(),await this.authenticate(),void 0!==t&&(i=this.market(t));const r=this.extend({order_id:e},s),a=this.requestId(),o=this.urls.api.ws,n={e:"cancel-order",oid:a,data:r},d=await this.watch(o,a,n,a,a);return this.parseOrder(d,i)}async cancelOrdersWs(e,t=void 0,s={}){if(void 0!==t)throw new a.BadRequest(this.id+" cancelOrderWs does not allow filtering by symbol");await this.loadMarkets(),await this.authenticate();const i=this.requestId(),r=this.extend({"cancel-orders":e},s),o=this.urls.api.ws,n={e:"mass-cancel-place-orders",oid:i,data:r},d=await this.watch(o,i,n,i,i),h=this.safeValue(d,"cancel-orders");return this.parseOrders(h,void 0,void 0,void 0,s)}resolveData(e,t){const s=this.safeValue(t,"data"),i=this.safeString(t,"oid");e.resolve(s,i)}handleConnected(e,t){return t}handleErrorMessage(e,t){try{const e=this.safeValue(t,"data",{}),s=this.safeString(e,"error"),i=this.safeString(t,"e",""),r=this.id+" "+i+" "+s;throw this.throwExactlyMatchedException(this.exceptions.exact,s,r),this.throwBroadlyMatchedException(this.exceptions.broad,s,r),new a.ExchangeError(r)}catch(s){const i=this.safeString(t,"oid");if(void 0===this.safeValue(e.futures,i))throw s;e.reject(s,i)}}handleMessage(e,t){if("error"===this.safeString(t,"ok"))return void this.handleErrorMessage(e,t);const s=this.safeString(t,"e"),i={auth:this.handleAuthenticationMessage,connected:this.handleConnected,tick:this.handleTicker,ticker:this.handleTicker,"init-ohlcv-data":this.handleInitOHLCV,ohlcv24:this.handleOHLCV24,ohlcv1m:this.handleOHLCV1m,ohlcv:this.handleOHLCV,"get-balance":this.handleBalance,"order-book-subscribe":this.handleOrderBookSnapshot,md_update:this.handleOrderBookUpdate,"open-orders":this.resolveData,order:this.handleOrderUpdate,"history-update":this.handleTrade,history:this.handleTradesSnapshot,tx:this.handleTransaction,"place-order":this.resolveData,"cancel-replace-order":this.resolveData,"cancel-order":this.resolveData,"mass-cancel-place-orders":this.resolveData,"get-order":this.resolveData},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");void 0!==s&&s.resolve(!0)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",a=s.future("authenticated");if(void 0===this.safeValue(s.subscriptions,i)){this.checkRequiredCredentials();const s=this.seconds().toString(),a=s+this.apiKey,o=this.hmac(this.encode(a),this.encode(this.secret),r.s),n={e:"auth",auth:{key:this.apiKey,signature:o.toUpperCase(),timestamp:s}};await this.watch(t,i,this.extend(n,e),i)}return await a}}},8160:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7504),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!1,cancelOrdersWs:!1,cancelOrderWs:!1,createOrderWs:!1,editOrderWs:!1,fetchBalanceWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,fetchTradesWs:!1,watchBalance:!1,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0},urls:{api:{ws:"wss://advanced-trade-ws.coinbase.com"}},options:{tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3,sides:{bid:"bids",offer:"asks"}}})}async subscribe(e,t,s=void 0,i={}){let r;await this.loadMarkets();let a=e,o=[];if(Array.isArray(s)){const e=this.marketSymbols(s);o=this.marketIds(e),a=a+"::"+s.join(",")}else void 0!==s&&(r=this.market(s),a=e+"::"+r.id,o=[r.id]);const n=this.urls.api.ws;let d={type:"subscribe",product_ids:o,channel:e};return t&&(d=this.extend(d,this.createWSAuth(e,o))),await this.watch(n,a,d,a)}async subscribeMultiple(e,t,s=void 0,i={}){await this.loadMarkets();const r=[],a=[];s=this.marketSymbols(s,void 0,!1);for(let t=0;t<s.length;t++){const i=s[t],o=this.market(i).id;r.push(o),a.push(e+"::"+o)}const o=this.urls.api.ws;let n={type:"subscribe",product_ids:r,channel:e};return t&&(n=this.extend(n,this.createWSAuth(e,r))),await this.watchMultiple(o,a,n,a)}createWSAuth(e,t){const s={},i=this.numberToString(this.seconds());this.checkRequiredCredentials();const a=this.apiKey.indexOf("organizations/")>=0||this.secret.startsWith("-----BEGIN"),n=i+e+t.join(",");if(a){if(this.apiKey.startsWith("-----BEGIN"))throw new r.ArgumentsRequired(this.id+" apiKey should contain the name (eg: organizations/3b910e93....) and not the public key");const e=this.safeString(this.options,"wsToken"),t=this.safeInteger(this.options,"wsTokenTimestamp",0),i=this.seconds();if(void 0===e||t+120<i){const e=this.createAuthToken(i);this.options.wsToken=e,this.options.wsTokenTimestamp=i}s.jwt=this.safeString(this.options,"wsToken")}else s.api_key=this.apiKey,s.timestamp=i,s.signature=this.hmac(this.encode(n),this.encode(this.secret),o.s);return s}async watchTicker(e,t={}){return await this.subscribe("ticker",!1,e,t)}async watchTickers(e=void 0,t={}){void 0===e&&(e=this.symbols);const s=await this.subscribe("ticker_batch",!1,e,t);return this.newUpdates?s:this.tickers}handleTickers(e,t){const s=this.safeString(t,"channel"),i=this.safeValue(t,"events",[]),r=this.safeString(t,"timestamp"),a=this.parse8601(r),o=[];for(let t=0;t<i.length;t++){const n=i[t],d=this.safeList(n,"tickers",[]);for(let t=0;t<d.length;t++){const i=d[t],n=this.parseWsTicker(i);n.timestamp=a,n.datetime=r;const h=n.symbol;this.tickers[h]=n;const c=this.safeString(i,"product_id");if(void 0===c)continue;const l=s+"::"+c;o.push(n),e.resolve(n,l),l.endsWith("USD")&&e.resolve(n,l+"C")}}const n=this.findMessageHashes(e,"ticker_batch::");for(let t=0;t<n.length;t++){const s=n[t],i=s.split("::")[1].split(","),r=this.filterByArray(o,"symbol",i);this.isEmpty(r)||(e.resolve(r,s),s.endsWith("USD")&&e.resolve(r,s+"C"))}return t}parseWsTicker(e,t=void 0){const s=this.safeString(e,"product_id"),i=void 0,r=this.safeNumber(e,"price");return this.safeTicker({info:e,symbol:this.safeSymbol(s,t,"-"),timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"high_24_h"),low:this.safeString(e,"low_24_h"),bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_quantity"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_quantity"),vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"price_percent_chg_24_h"),average:void 0,baseVolume:this.safeString(e,"volume_24_h"),quoteVolume:void 0})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.subscribe("market_trades",!1,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.subscribeMultiple("market_trades",!1,e,i);if(this.newUpdates){const e=this.safeDict(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.subscribe("user",!0,e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();e=this.market(e).symbol;return(await this.subscribe("level2",!1,e,s)).limit()}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets();return(await this.subscribeMultiple("level2",!1,e,s)).limit()}handleTrade(e,t){const s=this.safeValue(t,"events"),i=this.safeValue(s,0),r=this.safeValue(i,"trades"),o=this.safeValue(r,0),n=this.safeString(o,"product_id"),d="market_trades::"+n,h=this.safeSymbol(n);let c=this.safeValue(this.trades,h);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.Pt(e),this.trades[h]=c}for(let e=0;e<s.length;e++){const t=s[e],i=this.safeValue(t,"trades");for(let t=0;t<i.length;t++){const t=i[e];c.append(this.parseTrade(t))}}return e.resolve(c,d),n.endsWith("USD")&&e.resolve(c,d+"C"),t}handleOrder(e,t){const s=this.safeValue(t,"events"),i=[];if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}for(let e=0;e<s.length;e++){const t=s[e],r=this.safeValue(t,"orders");for(let e=0;e<r.length;e++){const t=r[e],s=this.parseWsOrder(t),a=this.orders,o=this.safeString(t,"product_id");o in i||i.push(o),a.append(s)}}for(let t=0;t<i.length;t++){const s="user::"+i[t];e.resolve(this.orders,s),s.endsWith("USD")&&e.resolve(this.orders,s+"C")}return e.resolve(this.orders,"user"),t}parseWsOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"client_order_id"),r=this.safeString(e,"product_id"),a=this.safeString(e,"time");return t=this.safeMarket(r,t),this.safeOrder({info:e,symbol:this.safeString(t,"symbol"),id:s,clientOrderId:i,timestamp:this.parse8601(a),datetime:a,lastTradeTimestamp:void 0,type:this.safeString(e,"order_type"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:void 0,stopPrice:void 0,triggerPrice:void 0,amount:void 0,cost:void 0,average:this.safeString(e,"avg_price"),filled:this.safeString(e,"cumulative_quantity"),remaining:this.safeString(e,"leaves_quantity"),status:this.safeStringLower(e,"status"),fee:{amount:this.safeString(e,"total_fees"),currency:this.safeString(t,"quote")},trades:void 0})}handleOrderBookHelper(e,t){for(let s=0;s<t.length;s++){const i=t[s],r=this.safeString(i,"side"),a=this.safeString(this.options.sides,r),o=this.safeNumber(i,"price_level"),n=this.safeNumber(i,"new_quantity");e[a].store(o,n)}}handleOrderBook(e,t){const s=this.safeValue(t,"events"),i=this.safeString(t,"timestamp");for(let t=0;t<s.length;t++){const r=s[t],a=this.safeValue(r,"updates",[]),o=this.safeString(r,"product_id"),n="level2::"+o,d=this.safeValue(e.subscriptions,n,{}),h=this.safeInteger(d,"limit"),c=this.safeSymbol(o),l=this.safeString(r,"type");if("snapshot"===l){this.orderbooks[c]=this.orderBook({},h);const t=this.orderbooks[c];this.handleOrderBookHelper(t,a),t.timestamp=this.parse8601(i),t.datetime=i,t.symbol=c,e.resolve(t,n),n.endsWith("USD")&&e.resolve(t,n+"C")}else if("update"===l){const t=this.orderbooks[c];this.handleOrderBookHelper(t,a),t.datetime=i,t.timestamp=this.parse8601(i),t.symbol=c,e.resolve(t,n),n.endsWith("USD")&&e.resolve(t,n+"C")}}}handleSubscriptionStatus(e,t){return t}handleHeartbeats(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"channel"),i={subscriptions:this.handleSubscriptionStatus,ticker:this.handleTickers,ticker_batch:this.handleTickers,market_trades:this.handleTrade,user:this.handleOrder,l2_data:this.handleOrderBook,heartbeats:this.handleHeartbeats};if("error"===this.safeString(t,"type")){const e=this.safeString(t,"message");throw new r.ExchangeError(e)}const a=this.safeValue(i,s);a&&a.call(this,e,t)}}},1925:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(4293),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!1,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,watchMyTradesForSymbols:!0,watchBalance:!1,watchStatus:!1,watchOrders:!0,watchOrdersForSymbols:!0,watchMyTrades:!0},urls:{api:{ws:"wss://ws-feed.exchange.coinbase.com"},test:{ws:"wss://ws-feed-public.sandbox.exchange.coinbase.com"}},options:{tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3}})}authenticate(){this.checkRequiredCredentials();const e=this.nonce(),t=e.toString()+"GET/users/self/verify",s=this.hmac(this.encode(t),this.base64ToBinary(this.secret),o.s,"base64");return{timestamp:e,key:this.apiKey,signature:s,passphrase:this.password}}async subscribe(e,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a=s;const o=[];void 0!==t&&(r=this.market(t),a+=":"+r.id,o.push(r.id));let n=this.urls.api.ws;"signature"in i&&(n+="?");const d={type:"subscribe",product_ids:o,channels:[e]},h=this.extend(d,i);return await this.watch(n,a,h,a)}async subscribeMultiple(e,t=[],s=void 0,i={}){let r;await this.loadMarkets(),t=this.marketSymbols(t);const a=[],o=[];for(let e=0;e<t.length;e++){const i=t[e];r=this.market(i),o.push(r.id),a.push(s+":"+r.symbol)}let n=this.urls.api.ws;"signature"in i&&(n+="?");const d={type:"subscribe",product_ids:o,channels:[e]},h=this.extend(d,i);return await this.watchMultiple(n,a,h,a)}async watchTicker(e,t={}){const s="ticker";return await this.subscribe(s,e,s,t)}async watchTickers(e=void 0,t={}){await this.loadMarkets();if(0===e.length)throw new r.BadSymbol(this.id+" watchTickers requires a non-empty symbols array");const s=await this.subscribeMultiple("ticker",e,"ticker",t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.tickers,"symbol",e)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r="matches",a=await this.subscribe(r,e,r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length)throw new r.BadRequest(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");await this.loadMarkets(),e=this.marketSymbols(e);const a="matches",o=await this.subscribeMultiple(a,e,a,i);if(this.newUpdates){const e=this.safeValue(o,0),t=this.safeString(e,"symbol");s=o.getLimit(t,s)}return this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchMyTrades() requires a symbol argument");await this.loadMarkets(),e=this.symbol(e);const a=this.authenticate(),o=await this.subscribe("user",e,"myTrades",this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchMyTradesForSymbols(e=void 0,t=void 0,s=void 0,i={}){e=this.marketSymbols(e,void 0,!1),await this.loadMarkets();const r=this.authenticate(),a=await this.subscribeMultiple("user",e,"myTrades",this.extend(i,r));if(this.newUpdates){const e=this.safeValue(a,0),t=this.safeString(e,"symbol");s=a.getLimit(t,s)}return this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchOrdersForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const r=this.authenticate(),a=await this.subscribeMultiple("user",e,"orders",this.extend(i,r));if(this.newUpdates){const e=this.safeValue(a,0),t=this.safeString(e,"symbol");s=a.getLimit(t,s)}return this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.BadSymbol(this.id+" watchMyTrades requires a symbol");await this.loadMarkets(),e=this.symbol(e);const a=this.authenticate(),o=await this.subscribe("user",e,"orders",this.extend(i,a));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrderBookForSymbols(e,t=void 0,s={}){const i=e.length;if(0===i)throw new r.BadRequest(this.id+" watchOrderBookForSymbols() requires a non-empty array of symbols");const a="level2";await this.loadMarkets(),e=this.marketSymbols(e);const o=this.marketIds(e),n=[];for(let e=0;e<i;e++){const t=o[e];n.push(a+":"+t)}const d=this.urls.api.ws,h={type:"subscribe",product_ids:o,channels:[a]},c=this.extend(h,s),l={messageHash:a,symbols:e,marketIds:o,limit:t},u=this.authenticate();return(await this.watchMultiple(d,n,this.extend(c,u),n,l)).limit()}async watchOrderBook(e,t=void 0,s={}){const i="level2";await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=i+":"+r.id,o=this.urls.api.ws,n={type:"subscribe",product_ids:[r.id],channels:[i]},d=this.extend(n,s),h={messageHash:a,symbol:e,marketId:r.id,limit:t},c=this.authenticate();return(await this.watch(o,a,this.extend(d,c),a,h)).limit()}handleTrade(e,t){const s=this.safeString(t,"product_id");if(void 0!==s){const i=this.parseWsTrade(t),r=i.symbol,o="matches"+":"+s;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}n.append(i),e.resolve(n,o)}return t}handleMyTrade(e,t){const s=this.safeString(t,"product_id");if(void 0!==s){const i=this.parseWsTrade(t),r="myTrades"+":"+s;let o=this.myTrades;if(void 0===o){const e=this.safeInteger(this.options,"myTradesLimit",1e3);o=new a.Pt(e),this.myTrades=o}o.append(i),e.resolve(o,r)}return t}parseWsTrade(e,t=void 0){const s=super.parseTrade(e);let i,r=!1;if("maker_fee_rate"in e)r=!0,s.takerOrMaker="maker",i=this.safeNumber(e,"maker_fee_rate");else{s.takerOrMaker="taker",i=this.safeNumber(e,"taker_fee_rate");const t=s.side;s.side=this.safeString({buy:"sell",sell:"buy"},t,t)}const a=r?"maker_order_id":"taker_order_id";s.order=this.safeString(e,a);const o=this.market(s.symbol).quote;let n;if(void 0!==s.cost&&void 0!==i){n=this.safeNumber(s,"cost")*i}return s.fee={rate:i,cost:n,currency:o},s}parseWsOrderStatus(e){return this.safeString({filled:"closed",canceled:"canceled"},e,"open")}handleOrder(e,t){let s=this.orders;if(void 0===s){const e=this.safeInteger(this.options,"ordersLimit",1e3);s=new a.Pt(e),this.orders=s}const i=this.safeString(t,"type"),r=this.safeString(t,"product_id");if(void 0!==r){const s="orders:"+r,a=this.safeSymbol(r),o=this.safeString(t,"order_id"),n=this.safeString(t,"maker_order_id"),d=this.safeString(t,"taker_order_id"),h=this.orders,c=this.safeValue(h.hashmap,a,{});let l=this.safeValue(c,o);if(void 0===l&&(l=this.safeValue2(c,n,d)),void 0===l){const i=this.parseWsOrder(t);h.append(i),e.resolve(h,s)}else{const r=this.safeInteger(t,"sequence"),a=this.safeValue(l,"info",{}),o=this.safeInteger(a,"sequence");if(void 0===o||r>o)if("match"===i){const i=this.parseWsTrade(t);void 0===l.trades&&(l.trades=[]),l.trades.push(i),l.lastTradeTimestamp=i.timestamp;let r=0,a=0;const o=l.trades;for(let e=0;e<o.length;e++){const t=o[e];r=this.sum(r,t.cost),a=this.sum(a,t.amount)}a>0&&(l.average=r/a),l.cost=r,void 0!==l.filled&&(l.filled+=i.amount,void 0!==l.amount&&(l.remaining=l.amount-l.filled)),void 0===l.fee&&(l.fee={cost:0,currency:i.fee.currency}),void 0!==l.fee.cost&&void 0!==i.fee.cost&&(l.fee.cost=this.sum(l.fee.cost,i.fee.cost)),h.append(l),e.resolve(h,s)}else if("received"===i||"done"===i){const i=this.extend(l.info,t),r=this.parseWsOrder(i),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e];void 0!==r[t]&&(l[t]=r[t])}h.append(l),e.resolve(h,s)}}}}parseWsOrder(e,t=void 0){const s=this.safeString(e,"order_id"),i=this.safeString(e,"client_oid"),r=this.safeString(e,"product_id"),a=this.safeSymbol(r),o=this.safeString(e,"side"),n=this.safeNumber(e,"price"),d=this.safeNumber2(e,"size","funds"),h=this.safeString(e,"time"),c=this.parse8601(h),l=this.safeString(e,"reason"),u=this.parseWsOrderStatus(l),p=this.safeString(e,"order_type");let f=this.safeNumber(e,"remaining_size");const m=this.safeString(e,"type");let g;return void 0!==d&&void 0!==f?g=d-f:"received"===m&&(g=0,void 0!==d&&(f=d-g)),this.safeOrder({info:e,symbol:a,id:s,clientOrderId:i,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,type:p,timeInForce:void 0,postOnly:void 0,side:o,price:n,stopPrice:void 0,triggerPrice:void 0,amount:d,cost:void 0,average:void 0,filled:g,remaining:f,status:u,fee:void 0,trades:void 0})}handleTicker(e,t){const s=this.safeString(t,"product_id");if(void 0!==s){const i=this.parseTicker(t),r=i.symbol;this.tickers[r]=i;const a="ticker:"+r,o="ticker:"+s;e.resolve(i,a),e.resolve(i,o)}return t}parseTicker(e,t=void 0){if(void 0===this.safeString(e,"type"))return super.parseTicker(e,t);const s=this.safeString(e,"product_id"),i=this.safeSymbol(s,t,"-"),r=this.parse8601(this.safeString(e,"time")),a=this.safeString(e,"price");return this.safeTicker({symbol:i,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high_24h"),low:this.safeString(e,"low_24h"),bid:this.safeString(e,"best_bid"),bidVolume:this.safeString(e,"best_bid_size"),ask:this.safeString(e,"best_ask"),askVolume:this.safeString(e,"best_ask_size"),vwap:void 0,open:this.safeString(e,"open_24h"),close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume_24h"),quoteVolume:void 0,info:e})}handleDelta(e,t){const s=this.safeNumber(t,0),i=this.safeNumber(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.safeMarket(i,void 0,"-").symbol,a="level2:"+i,o=this.safeValue(e.subscriptions,a,{}),n=this.safeInteger(o,"limit");if("snapshot"===s){this.orderbooks[r]=this.orderBook({},n);const s=this.orderbooks[r];this.handleDeltas(s.asks,this.safeValue(t,"asks",[])),this.handleDeltas(s.bids,this.safeValue(t,"bids",[])),s.timestamp=void 0,s.datetime=void 0,s.symbol=r,e.resolve(s,a)}else if("l2update"===s){const s=this.orderbooks[r],i=this.parse8601(this.safeString(t,"time")),o=this.safeValue(t,"changes",[]),n={sell:"asks",buy:"bids"};for(let e=0;e<o.length;e++){const t=o[e],i=this.safeString(t,0),r=this.safeString(n,i),a=this.safeNumber(t,1),d=this.safeNumber(t,2);s[r].store(a,d)}s.timestamp=i,s.datetime=this.iso8601(i),e.resolve(s,a)}}handleSubscriptionStatus(e,t){return t}handleErrorMessage(e,t){const s=this.safeString(t,"message"),i=this.safeString(t,"reason");try{throw"Authentication Failed"===s?new r.AuthenticationError("Authentication failed: "+i):new r.ExchangeError(this.id+" "+i)}catch(t){return e.reject(t),!0}}handleMessage(e,t){const s=this.safeString(t,"type"),i={snapshot:this.handleOrderBook,l2update:this.handleOrderBook,subscribe:this.handleSubscriptionStatus,ticker:this.handleTicker,received:this.handleOrder,open:this.handleOrder,change:this.handleOrder,done:this.handleOrder,error:this.handleErrorMessage},r=e.url.length-0,a="?"===e.url[r-1],o=this.safeValue(i,s);void 0===o?"match"===s&&(a?(this.handleMyTrade(e,t),this.handleOrder(e,t)):this.handleTrade(e,t)):o.call(this,e,t)}}},998:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(1558),r=s(2079),a=s(4852),o=s(2931);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchTicker:!0,watchBalance:!1,watchMyTrades:!1,watchOHLCV:!0,watchOHLCVForSymbols:!1,watchOrders:!1,watchOrdersForSymbols:!1,watchPositions:!1,watchTickers:!0,createOrderWs:!1,editOrderWs:!1,cancelOrderWs:!1,cancelOrdersWs:!1,cancelAllOrdersWs:!1,fetchOrderWs:!1,fetchOrdersWs:!1,fetchBalanceWs:!1,fetchMyTradesWs:!1},urls:{api:{ws:"wss://ws-md.international.coinbase.com"},test:{ws:"wss://ws-md.n5e2.coinbase.com"}},options:{watchTicker:{channel:"LEVEL1"},tradesLimit:1e3,ordersLimit:1e3,myTradesLimit:1e3,timeframes:{"1m":"CANDLES_ONE_MINUTE","5m":"CANDLES_FIVE_MINUTES","30m":"CANDLES_THIRTY_MINUTES","1h":"CANDLES_ONE_HOUR","2h":"CANDLES_TWO_HOURS","1d":"CANDLES_ONE_DAY"}},exceptions:{exact:{"Unable to authenticate":r.AuthenticationError}}})}async subscribe(e,t=void 0,s={}){let i;await this.loadMarkets(),this.checkRequiredCredentials();let o,n=e;void 0===t&&(t=this.getActiveSymbols());const d=t.length,h=[];if(d>1){const s=this.marketSymbols(t);o=this.marketIds(s);for(let t=0;t<s.length;t++)h.push(e+"::"+s[t])}else 1===d&&(i=this.market(t[0]),n=e+"::"+i.symbol,o=[i.id]);const c=this.urls.api.ws;if(void 0===c)throw new r.NotSupported(this.id+" is not supported in sandbox environment");const l=this.nonce().toString(),u=l+this.apiKey+"CBINTLMD"+this.password,p=this.hmac(this.encode(u),this.base64ToBinary(this.secret),a.s,"base64"),f={type:"SUBSCRIBE",channels:[e],time:l,key:this.apiKey,passphrase:this.password,signature:p};return void 0!==o&&(f.product_ids=o),d>1?await this.watchMultiple(c,h,this.extend(f,s),h):await this.watch(c,n,this.extend(f,s),n)}async subscribeMultiple(e,t=void 0,s={}){await this.loadMarkets(),this.checkRequiredCredentials(),t=this.isEmpty(t)?this.symbols:this.marketSymbols(t);const i=[],o=[];for(let s=0;s<t.length;s++){const r=this.marketId(t[s]),a=this.symbol(r);o.push(r),i.push(e+"::"+a)}const n=this.urls.api.ws;if(void 0===n)throw new r.NotSupported(this.id+" is not supported in sandbox environment");const d=this.numberToString(this.seconds()),h=d+this.apiKey+"CBINTLMD"+this.password,c=this.hmac(this.encode(h),this.base64ToBinary(this.secret),a.s,"base64"),l={type:"SUBSCRIBE",time:d,product_ids:o,channels:[e],key:this.apiKey,passphrase:this.password,signature:c};return await this.watchMultiple(n,i,this.extend(l,s),i)}async watchFundingRate(e,t={}){return await this.loadMarkets(),await this.subscribe("RISK",[e],t)}async watchFundingRates(e,t={}){await this.loadMarkets();const s=await this.subscribeMultiple("RISK",e,t),i=this.safeString(s,"symbol");if(this.newUpdates){const e={};return e[i]=s,e}return this.filterByArray(this.fundingRates,"symbol",e)}async watchTicker(e,t={}){let s;return await this.loadMarkets(),[s,t]=this.handleOptionAndParams(t,"watchTicker","channel","LEVEL1"),await this.subscribe(s,[e],t)}getActiveSymbols(){const e=this.symbols,t=[];for(let s=0;s<e.length;s++){const i=e[s];this.markets[i].active&&t.push(i)}return t}async watchTickers(e=void 0,t={}){let s;await this.loadMarkets(),[s,t]=this.handleOptionAndParams(t,"watchTickers","channel","LEVEL1");const i=await this.subscribe(s,e,t);if(this.newUpdates){const e={};return e[i.symbol]=i,e}return this.filterByArray(this.tickers,"symbol",e)}handleInstrument(e,t){const s=this.parseWsInstrument(t),i=this.safeString(t,"channel");e.resolve(s,i),e.resolve(s,i+"::"+s.symbol)}parseWsInstrument(e,t=void 0){const s=this.safeString(e,"product_id"),i=this.safeString(e,"time");return this.safeTicker({info:e,symbol:this.safeSymbol(s,t,"-"),timestamp:this.parse8601(i),datetime:i,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString2(e,"total_24_hour_quantity","total24_hour_quantity"),quoteVolume:this.safeString2(e,"total_24_hour_volume","total24_hour_volume")})}handleTicker(e,t){const s=this.parseWsTicker(t),i=this.safeString(t,"channel");e.resolve(s,i),e.resolve(s,i+"::"+s.symbol)}parseWsTicker(e,t=void 0){const s=this.safeString(e,"time"),i=this.safeString(e,"product_id");return this.safeTicker({info:e,symbol:this.safeSymbol(i,t),timestamp:this.parse8601(s),datetime:s,bid:this.safeNumber(e,"bid_price"),bidVolume:this.safeNumber(e,"bid_qty"),ask:this.safeNumber(e,"ask_price"),askVolume:this.safeNumber(e,"ask_qty"),high:void 0,low:void 0,open:void 0,close:void 0,last:void 0,change:void 0,percentage:void 0,average:void 0,vwap:void 0,baseVolume:void 0,quoteVolume:void 0,previousClose:void 0})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();e=this.market(e).symbol;const a=this.safeDict(this.options,"timeframes",{}),o=this.safeString(a,t,t),n=await this.subscribe(o,[e],r);return this.newUpdates&&(i=n.getLimit(e,i)),this.filterBySinceLimit(n,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"channel"),i=this.safeString(t,"product_id"),r=this.safeMarket(i),a=r.symbol,n=this.findTimeframe(s);if(this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{}),void 0===this.safeValue(this.ohlcvs[a],n)){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[a][n]=new o.TG(e)}const d=this.ohlcvs[a][n],h=this.safeList(t,"candles",[]);for(let e=0;e<h.length;e++){const t=h[e],s=this.parseOHLCV(t,r);d.append(s)}e.resolve(d,s+"::"+a)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0,!0);const r=await this.subscribeMultiple("MATCH",e,i);if(this.newUpdates){const e=this.safeDict(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.parseWsTrade(t),i=s.symbol,r=this.safeString(t,"channel");if(!(i in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3),t=new o.I3(e);this.trades[i]=t}const a=this.trades[i];return a.append(s),this.trades[i]=a,e.resolve(a,r),e.resolve(a,r+"::"+s.symbol),t}parseWsTrade(e,t=void 0){const s=this.safeString2(e,"symbol","product_id"),i=this.safeString(e,"time");return this.safeTrade({info:e,id:this.safeString(e,"match_id"),order:void 0,timestamp:this.parse8601(i),datetime:i,symbol:this.safeSymbol(s,t),type:void 0,side:this.safeStringLower(e,"agressor_side"),takerOrMaker:void 0,price:this.safeString(e,"trade_price"),amount:this.safeString(e,"trade_qty"),cost:void 0,fee:void 0})}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){return await this.loadMarkets(),await this.subscribeMultiple("LEVEL2",e,s)}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.safeSymbol(i),a=this.safeString(t,"time"),o=this.safeString(t,"channel");if(!(r in this.orderbooks)){const e=this.safeInteger(this.options,"watchOrderBookLimit",1e3);this.orderbooks[r]=this.orderBook({},e)}const n=this.orderbooks[r];if("SNAPSHOT"===s){const e=this.parseOrderBook(t,r,void 0,"bids","asks");n.reset(e),n.symbol=r}else{const e=this.safeList(t,"changes",[]);this.handleDeltas(n,e)}n.nonce=this.safeInteger(t,"sequence"),n.datetime=a,n.timestamp=this.parse8601(a),this.orderbooks[r]=n,e.resolve(n,o+"::"+r)}handleDelta(e,t){const s="buy"===this.safeStringLower(t,0)?"bids":"asks",i=this.safeFloat(t,1),r=this.safeFloat(t,2);e[s].store(i,r)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleSubscriptionStatus(e,t){return t}handleFundingRate(e,t){const s=this.safeString(t,"channel"),i=this.parseFundingRate(t);this.fundingRates[i.symbol]=i,e.resolve(i,s+"::"+i.symbol)}handleErrorMessage(e,t){if("REJECT"!==this.safeString(t,"type"))return!1;const s=this.safeString(t,"reason"),i=this.safeString(t,"message");try{const e=this.id+" "+i+s;throw this.throwExactlyMatchedException(this.exceptions.exact,s,e),this.throwBroadlyMatchedException(this.exceptions.broad,s,e),new r.ExchangeError(e)}catch(t){e.reject(t)}return!0}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"channel",""),i={SUBSCRIPTIONS:this.handleSubscriptionStatus,INSTRUMENTS:this.handleInstrument,LEVEL1:this.handleTicker,MATCH:this.handleTrade,LEVEL2:this.handleOrderBook,FUNDING:this.handleFundingRate,RISK:this.handleTicker};if("error"===this.safeString(t,"type")){const e=this.safeString(t,"message");throw new r.ExchangeError(e)}s.indexOf("CANDLES")>-1&&this.handleOHLCV(e,t);const a=this.safeValue(i,s);void 0!==a&&a.call(this,e,t)}}},5317:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(2741),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!1,watchTrades:!0,watchTradesForSymbols:!1,watchOHLCV:!1,watchTicker:!1,watchTickers:!1},urls:{api:{ws:"wss://ws-api.coincheck.com/"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{snapshotDelay:6,snapshotMaxRetries:3},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:r.AuthenticationError}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+i.symbol,a=this.urls.api.ws,o={type:"subscribe",channel:i.id+"-orderbook"},n=this.extend(o,s);return(await this.watch(a,r,n,r)).limit()}handleOrderBook(e,t){const s=this.symbol(this.safeString(t,0)),i=this.safeValue(t,1,{}),r=this.safeTimestamp(i,"last_update_at"),a=this.parseOrderBook(i,s,r);let o=this.safeValue(this.orderbooks,s);void 0===o?(o=this.orderBook(a),this.orderbooks[s]=o):(o=this.orderbooks[s],o.reset(a));const n="orderbook:"+s;e.resolve(o,n)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="trade:"+r.symbol,o=this.urls.api.ws,n={type:"subscribe",channel:r.id+"-trades"},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,0,[]),i=this.symbol(this.safeString(s,2));let r=this.safeValue(this.trades,i);if(void 0===r){const e=this.safeInteger(this.options,"tradesLimit",1e3);r=new a.I3(e),this.trades[i]=r}for(let e=0;e<t.length;e++){const s=this.safeValue(t,e),i=this.parseWsTrade(s);r.append(i)}const o="trade:"+i;e.resolve(r,o)}parseWsTrade(e,t=void 0){const s=this.symbol(this.safeString(e,2)),i=this.safeTimestamp(e,0),r=this.safeString(e,5),a=this.safeString(e,3),o=this.safeString(e,4);return this.safeTrade({id:this.safeString(e,1),info:e,timestamp:i,datetime:this.iso8601(i),order:void 0,symbol:s,type:void 0,side:r,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}handleMessage(e,t){const s=this.safeValue(t,0);Array.isArray(s)?this.handleTrades(e,t):this.handleOrderBook(e,t)}}},9088:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(9344),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchBidsAsks:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOHLCV:!1,fetchOHLCVWs:!1},urls:{api:{ws:{spot:"wss://socket.coinex.com/v2/spot/",swap:"wss://socket.coinex.com/v2/futures/"}}},options:{ws:{gunzip:!0},timeframes:{"1m":60,"3m":180,"5m":300,"15m":900,"30m":1800,"1h":3600,"2h":7200,"4h":14400,"6h":21600,"12h":43200,"1d":86400,"3d":259200,"1w":604800},account:"spot",watchOrderBook:{limits:[5,10,20,50],defaultLimit:50,aggregations:["1000","100","10","1","0","0.1","0.01","0.001","0.0001","0.00001","0.000001","0.0000001","0.00000001","0.000000001","0.0000000001","0.00000000001"],defaultAggregation:"0"}},streaming:{},exceptions:{exact:{20001:r.BadRequest,20002:r.NotSupported,21001:r.AuthenticationError,21002:r.AuthenticationError,23001:r.RequestTimeout,23002:r.RateLimitExceeded,24001:r.ExchangeError,24002:r.ExchangeNotAvailable,30001:r.BadRequest,30002:r.NotSupported,31001:r.AuthenticationError,31002:r.AuthenticationError,33001:r.RequestTimeout,33002:r.RateLimitExceeded,34001:r.ExchangeError,34002:r.ExchangeNotAvailable},broad:{}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}handleTicker(e,t){const s=this.safeString(this.options,"defaultType"),i=this.safeDict(t,"data",{}),r=this.safeList(i,"state_list",[]),a=[];for(let e=0;e<r.length;e++){const t=r[e],i=this.safeString(t,"market"),o=this.safeSymbol(i,void 0,void 0,s),n=this.safeMarket(i,void 0,void 0,s),d=this.parseWSTicker(t,n);this.tickers[o]=d,a.push(d)}const o=this.findMessageHashes(e,"tickers::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),r=this.filterByArray(a,"symbol",i);Object.keys(r).length>0&&e.resolve(r,s)}e.resolve(a,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(this.options,"defaultType"),i=this.safeString(e,"market");return this.safeTicker({symbol:this.safeSymbol(i,t,void 0,s),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:this.safeString(e,"volume_buy"),ask:void 0,askVolume:this.safeString(e,"volume_sell"),vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:this.safeString(e,"last"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"value"),info:e},t)}async watchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e,"spot"),await this.authenticate(t);const s=this.urls.api.ws[t];let i=Object.keys(this.currencies_by_id);void 0===i&&(i=[]);let r="balances";r+="spot"===t?":spot":":swap";const a={method:"balance.subscribe",params:{ccy_list:i},id:this.requestId()},o=this.deepExtend(a,e);return await this.watch(s,r,o,r)}handleBalance(e,t){void 0===this.balance&&(this.balance={});const s=this.safeDict(t,"data",{}),i=this.safeList(s,"balance_list",[]),r=i[0],a=this.safeInteger(r,"updated_at"),o=void 0!==this.safeString(r,"unrealized_pnl");let n,d,h,c=[];if(void 0!==a){d="spot";for(let e=0;e<i.length;e++)c=this.arrayConcat(c,i);n=c}if(o){d="swap";for(let e=0;e<i.length;e++)c=this.arrayConcat(c,i);n=c}for(let e=0;e<c.length;e++){const t=c[e];this.parseWsBalance(t,d)}void 0!==d&&(void 0===this.safeValue(this.balance,d)&&(this.balance[d]={}),this.balance[d].info=n,this.balance[d]=this.safeBalance(this.balance[d]),h="balances:"+d,e.resolve(this.balance[d],h))}parseWsBalance(e,t=void 0){const s=this.account(),i=this.safeString(e,"ccy"),r=this.safeCurrencyCode(i);s.free=this.safeString(e,"available"),s.used=this.safeString(e,"frozen"),void 0!==t?(void 0===this.safeValue(this.balance,t)&&(this.balance[t]={}),this.balance[t][r]=s):this.balance[r]=s}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i,"spot"),await this.authenticate(a);const o=this.urls.api.ws[a],n=[];let d="myTrades";void 0!==r?(d+=":"+e,n.push(r.id)):d+="spot"===a?":spot":":swap";const h={method:"user_deals.subscribe",params:{market_list:n},id:this.requestId()},c=this.deepExtend(h,i),l=await this.watch(o,d,c,d);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySymbolSinceLimit(l,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"market"),r=e.url.indexOf("spot")>-1?"spot":"swap",o=this.safeMarket(i,void 0,void 0,r),n=o.symbol,d="myTrades:"+n,h="myTrades:"+o.type;let c=this.safeValue(this.trades,n);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[n]=c}const l=this.parseWsTrade(s,o);c.append(l),this.trades[n]=c,e.resolve(this.trades[n],h),e.resolve(this.trades[n],d)}handleTrades(e,t){const s=this.safeDict(t,"data",{}),i=this.safeList(s,"deal_list",[]),r=this.safeString(s,"market"),o=e.url.indexOf("spot")>-1?"spot":"swap",n=this.safeMarket(r,void 0,void 0,o),d=n.symbol,h="trades:"+d;let c=this.safeValue(this.trades,d);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[d]=c}for(let e=0;e<i.length;e++){const t=i[e],s=this.parseWsTrade(t,n);c.append(s)}this.trades[d]=c,e.resolve(this.trades[d],h)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"created_at"),i="margin_market"in e?"spot":"swap",r=this.safeString(e,"market");t=this.safeMarket(r,t,void 0,i);let a={};const o=this.omitZero(this.safeString(e,"fee"));if(void 0!==o){const s=this.safeString(e,"fee_ccy",t.quote);a={currency:this.safeCurrencyCode(s),cost:o}}return this.safeTrade({id:this.safeString(e,"deal_id"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(r,t,void 0,i),order:this.safeString(e,"order_id"),type:void 0,side:this.safeString(e,"side"),takerOrMaker:this.safeString(e,"role"),price:this.safeString(e,"price"),amount:this.safeString(e,"amount"),cost:void 0,fee:a},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);return(await this.watchTickers([e],t))[s.symbol]}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.marketIds(e);let i;const r=[];if(void 0!==e)for(let t=0;t<e.length;t++){const s=e[t];i=this.market(s),r.push("tickers::"+i.symbol)}else r.push("tickers");let a;[a,t]=this.handleMarketTypeAndParams("watchTickers",i,t);const o=this.urls.api.ws[a],n={method:"state.subscribe",params:{market_list:s},id:this.requestId()},d=await this.watchMultiple(o,r,this.deepExtend(n,t),["all@ticker"]);return this.newUpdates?d:this.filterByArray(this.tickers,"symbol",e)}async watchTrades(e,t=void 0,s=void 0,i={}){return i.callerMethodName="watchTrades",await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[],a=[];let o,n;[n,i]=this.handleParamString(i,"callerMethodName","watchTradesForSymbols");if(void 0!==e)for(let t=0;t<e.length;t++){const s=e[t];o=this.market(s),r.push(o.id),a.push("trades:"+o.symbol)}else a.push("trades");let d;[d,i]=this.handleMarketTypeAndParams(n,o,i);const h=this.urls.api.ws[d],c={method:"deals.subscribe",params:{market_list:r},id:this.requestId()},l=await this.watchMultiple(h,a,this.deepExtend(c,i),["trades"]);return this.newUpdates?l:this.filterBySinceLimit(l,t,s,"timestamp",!0)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets();const i={},a=[];let n,d,h;[h,s]=this.handleParamString(s,"callerMethodName","watchOrderBookForSymbols"),[d,s]=this.handleMarketTypeAndParams(h,void 0,s);const c=this.safeDict(this.options,"watchOrderBook",{}),l=this.safeList(c,"limits",[]);if(void 0===t&&(t=this.safeInteger(c,"defaultLimit",50)),!this.inArray(t,l))throw new r.NotSupported(this.id+" watchOrderBookForSymbols() limit must be one of "+l.join(", "));const u=this.safeString(c,"defaultAggregation","0"),p=this.safeList(c,"aggregations",[]),f=this.safeString(s,"aggregation",u);if(!this.inArray(f,p))throw new r.NotSupported(this.id+" watchOrderBookForSymbols() aggregation must be one of "+p.join(", "));s=this.omit(s,"aggregation");if(void 0!==e)for(let s=0;s<e.length;s++){const r=e[s];n=this.market(r),a.push("orderbook:"+n.symbol),i[r]=[n.id,t,f,!0]}else a.push("orderbook");const m={method:"depth.subscribe",params:{market_list:Object.values(i)},id:this.requestId()},g=this.hash(this.encode(this.json(i)),o.s),v=this.urls.api.ws[d],y=await this.watchMultiple(v,a,this.deepExtend(m,s),g);return this.newUpdates?y:y.limit()}async watchOrderBook(e,t=void 0,s={}){return s.callerMethodName="watchOrderBook",await this.watchOrderBookForSymbols([e],t,s)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(this.options,"defaultType"),i=this.safeDict(t,"data",{}),r=this.safeDict(i,"depth",{}),a=this.safeString(i,"market"),o=this.safeMarket(a,void 0,void 0,s).symbol,n="orderbook:"+o,d=this.safeInteger(r,"updated_at"),h=this.safeValue(this.orderbooks,o);if(this.safeBool(i,"is_full",!1)){const e=this.parseOrderBook(r,o,d);if(void 0===h)this.orderbooks[o]=this.orderBook(e);else{this.orderbooks[o].reset(e)}}else{const e=this.safeList(r,"asks",[]),t=this.safeList(r,"bids",[]);this.handleDeltas(h.asks,e),this.handleDeltas(h.bids,t),h.nonce=d,h.timestamp=d,h.datetime=this.iso8601(d),this.orderbooks[o]=h}e.resolve(this.orderbooks[o],n)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool2(i,"trigger","stop");i=this.omit(i,["trigger","stop"]);let a,o,n,d,h="orders";void 0!==e&&(a=this.market(e),e=a.symbol),[n,i]=this.handleMarketTypeAndParams("watchOrders",a,i,"spot"),await this.authenticate(n),void 0!==e?(o=[a.id],h+=":"+e):(o=[],h+="spot"===n?":spot":":swap"),d=r?"stop.subscribe":"order.subscribe";const c={method:d,params:{market_list:o},id:this.requestId()},l=this.urls.api.ws[n],u=this.deepExtend(c,i),p=await this.watch(l,h,u,h,u);return this.newUpdates&&(s=p.getLimit(e,s)),this.filterBySymbolSinceLimit(p,e,t,s,!0)}handleOrders(e,t){const s=this.safeDict(t,"data",{}),i=this.safeDict2(s,"order","stop",{}),r=this.parseWsOrder(i),o=r.symbol,n=this.market(o);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}this.orders.append(r);let d="orders";const h=d+":"+n.type;e.resolve(this.orders,h),d+=":"+o,e.resolve(this.orders,d)}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.safeString(e,"market"),r=this.safeString(e,"status"),a="margin_market"in e?"spot":"swap";let o;t=this.safeMarket(i,t,void 0,a);const n=this.omitZero(this.safeString2(e,"fee","quote_ccy_fee"));if(void 0!==n){const s=this.safeString(e,"fee_ccy",t.quote);o={currency:this.safeCurrencyCode(s),cost:n}}return this.safeOrder({info:e,id:this.safeString2(e,"order_id","stop_id"),clientOrderId:this.safeString(e,"client_id"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:this.safeInteger(e,"updated_at"),symbol:t.symbol,type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:this.safeString(e,"price"),stopPrice:this.safeString(e,"trigger_price"),triggerPrice:this.safeString(e,"trigger_price"),amount:this.safeString(e,"amount"),filled:this.safeString2(e,"filled_amount","fill_value"),remaining:this.safeString2(e,"unfilled_amount","unfill_amount"),cost:void 0,average:void 0,status:this.parseWsOrderStatus(r),fee:o,trades:void 0},t)}parseWsOrderStatus(e){return this.safeString({active_success:"open",active_fail:"canceled",cancel:"canceled"},e,e)}async watchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=this.marketIds(e),i=[];let r;if(void 0!==e)for(let t=0;t<e.length;t++){const s=e[t];r=this.market(s),i.push("bidsasks:"+r.symbol)}else i.push("bidsasks");let a;[a,t]=this.handleMarketTypeAndParams("watchBidsAsks",r,t);const o=this.urls.api.ws[a],n={method:"bbo.subscribe",params:{market_list:s},id:this.requestId()},d=await this.watchMultiple(o,i,this.deepExtend(n,t),["all@bidsasks"]);return this.newUpdates?d:this.filterByArray(this.bidsasks,"symbol",e)}handleBidAsk(e,t){const s=this.safeDict(t,"data",{}),i=this.parseWsBidAsk(s),r=i.symbol;this.bidsasks[r]=i;const a="bidsasks:"+r;e.resolve(i,a)}parseWsBidAsk(e,t=void 0){const s=this.safeString(this.options,"defaultType"),i=this.safeString(e,"market");t=this.safeMarket(i,t,void 0,s);const r=this.safeTimestamp(e,"updated_at");return this.safeTicker({symbol:this.safeSymbol(i,t,void 0,s),timestamp:r,datetime:this.iso8601(r),ask:this.safeNumber(e,"best_ask_price"),askVolume:this.safeNumber(e,"best_ask_size"),bid:this.safeNumber(e,"best_bid_price"),bidVolume:this.safeNumber(e,"best_bid_size"),info:e},t)}handleMessage(e,t){const s=this.safeString(t,"method"),i=this.safeString(t,"message");void 0!==i&&this.handleErrors(void 0,void 0,e.url,s,void 0,this.json(i),t,void 0,void 0);const r={"state.update":this.handleTicker,"balance.update":this.handleBalance,"deals.update":this.handleTrades,"user_deals.update":this.handleMyTrades,"depth.update":this.handleOrderBook,"order.update":this.handleOrders,"stop.update":this.handleOrders,"bbo.update":this.handleBidAsk},a=this.safeValue(r,s);void 0===a?this.handleSubscriptionStatus(e,t):a.call(this,e,t)}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeStringLower(n,"message"),l=void 0!==c&&"ok"!==c,u=this.safeString(n,"code");if(void 0!==u&&"0"!==u||l){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,u,e),this.throwBroadlyMatchedException(this.exceptions.broad,c,e),new r.ExchangeError(e)}}handleAuthenticationMessage(e,t){const s=this.safeStringLower(t,"message"),i=this.safeString(t,"code"),a="authenticated";if("ok"===s||"0"===i){this.safeValue(e.futures,a).resolve(!0)}else{const s=new r.AuthenticationError(this.json(t));e.reject(s,a),a in e.subscriptions&&delete e.subscriptions[a]}}handleSubscriptionStatus(e,t){const s=this.safeInteger(t,"id"),i=this.safeValue(e.subscriptions,s);if(void 0!==i){const t=this.safeString(i,"future"),r=this.safeValue(e.futures,t);void 0!==r&&r.resolve(!0),delete e.subscriptions[s]}}async authenticate(e){const t=this.urls.api.ws[e],s=this.client(t),i=this.milliseconds(),r=i.toString(),a="authenticated",n=s.future(a);if(void 0!==this.safeValue(s.subscriptions,a))return await n;const d=this.requestId(),h={id:d,future:a},c=this.hmac(this.encode(r),this.encode(this.secret),o.s,"hex"),l={id:d,method:"server.sign",params:{access_id:this.apiKey,signed_str:c.toLowerCase(),timestamp:i}};return this.watch(t,a,l,d,h),s.subscriptions[a]=!0,await n}}},8673:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(5377),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchOrders:!1,watchTrades:!0,watchTradesForSymbols:!1,watchOHLCV:!1,watchTicker:!0,watchTickers:!1},urls:{api:{ws:"wss://stream.coinone.co.kr"}},options:{expiresIn:"",userId:"",wsSessionToken:"",watchOrderBook:{snapshotDelay:6,snapshotMaxRetries:3},tradesLimit:1e3,OHLCVLimit:1e3},exceptions:{exact:{4009:r.AuthenticationError}},streaming:{ping:this.ping,keepAlive:2e4}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+i.symbol,a=this.urls.api.ws,o={request_type:"SUBSCRIBE",channel:"ORDERBOOK",topic:{quote_currency:i.quote,target_currency:i.base}},n=this.extend(o,s);return(await this.watch(a,r,n,r)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeStringUpper(s,"target_currency"),r=this.safeStringUpper(s,"quote_currency"),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r),n=this.symbol(a+"/"+o),d=this.safeInteger(s,"timestamp");let h=this.safeValue(this.orderbooks,n);void 0===h?h=this.orderBook():h.reset(),h.symbol=n;const c=this.safeValue(s,"asks",[]),l=this.safeValue(s,"bids",[]);this.handleDeltas(h.asks,c),this.handleDeltas(h.bids,l),h.timestamp=d,h.datetime=this.iso8601(d);const u="orderbook:"+n;this.orderbooks[n]=h,e.resolve(h,u)}handleDelta(e,t){const s=this.parseBidAsk(t,"price","qty");e.storeArray(s)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+s.symbol,r=this.urls.api.ws,a={request_type:"SUBSCRIBE",channel:"TICKER",topic:{quote_currency:s.quote,target_currency:s.base}},o=this.extend(a,t);return await this.watch(r,i,o,i)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTicker(s),r=i.symbol;this.tickers[r]=i;const a="ticker:"+r;e.resolve(this.tickers[r],a)}parseWsTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"last"),r=this.safeString(e,"target_currency"),a=this.safeString(e,"quote_currency"),o=this.safeCurrencyCode(r),n=this.safeCurrencyCode(a),d=this.symbol(o+"/"+n);return this.safeTicker({symbol:d,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeNumber(e,"bid_best_price"),bidVolume:this.safeNumber(e,"bid_best_qty"),ask:this.safeNumber(e,"ask_best_price"),askVolume:this.safeNumber(e,"ask_best_qty"),vwap:void 0,open:this.safeString(e,"first"),close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"target_volume"),quoteVolume:this.safeString(e,"quote_volume"),info:e},t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trade:"+r.symbol,o=this.urls.api.ws,n={request_type:"SUBSCRIBE",channel:"TRADE",topic:{quote_currency:r.quote,target_currency:r.base}},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(r.symbol,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsTrade(s),r=i.symbol;let o=this.safeValue(this.trades,r);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.I3(e),this.trades[r]=o}o.append(i);const n="trade:"+r;e.resolve(o,n)}parseWsTrade(e,t=void 0){const s=this.safeStringUpper(e,"target_currency"),i=this.safeStringUpper(e,"quote_currency"),r=this.safeCurrencyCode(s)+"/"+this.safeCurrencyCode(i),a=this.safeInteger(e,"timestamp");t=this.safeMarket(r,t);const o=this.safeValue(e,"is_seller_maker");let n;void 0!==o&&(n=o?"sell":"buy");const d=this.safeString(e,"price"),h=this.safeString(e,"qty");return this.safeTrade({id:this.safeString(e,"id"),info:e,timestamp:a,datetime:this.iso8601(a),order:void 0,symbol:t.symbol,type:void 0,side:n,takerOrMaker:void 0,price:d,amount:h,cost:void 0,fee:void 0},t)}handleErrorMessage(e,t){return"ERROR"===this.safeString(t,"response_type","")}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"response_type");if("PONG"!==s){if("DATA"===s){const s=this.safeString(t,"channel",""),i={ORDERBOOK:this.handleOrderBook,TICKER:this.handleTicker,TRADE:this.handleTrades},r=this.safeValue(i,s);if(void 0!==r)return void r.call(this,e,t);const a=Object.keys(i);for(let r=0;r<a.length;r++){const o=a[r];if(s.indexOf(a[r])>=0){return void i[o].call(this,e,t)}}}}else this.handlePong(e,t)}ping(e){return{request_type:"PING"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}}},6292:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(6068),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchMyTrades:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchOHLCV:!0,watchPositions:!0,createOrderWs:!0,cancelOrderWs:!0,cancelAllOrders:!0},urls:{api:{ws:{public:"wss://stream.crypto.com/exchange/v1/market",private:"wss://stream.crypto.com/exchange/v1/user"}},test:{public:"wss://uat-stream.3ona.co/exchange/v1/market",private:"wss://uat-stream.3ona.co/exchange/v1/user"}},options:{watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0},watchOrderBook:{checksum:!0}},streaming:{}})}async pong(e,t){try{await e.send({id:this.safeInteger(t,"id"),method:"public/respond-heartbeat"})}catch(t){const s=new r.NetworkError(this.id+" pong failed with error "+this.json(t));e.reset(s)}}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets(),e=this.marketSymbols(e);const i=[],r=[];t||(t=50);let a,o,n,d;void 0===this.safeValue(s,"params")&&(s.params={}),[a,s]=this.handleOptionAndParams(s,"watchOrderBook","bookSubscriptionType","SNAPSHOT_AND_UPDATE"),[o,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","bookSubscriptionType",a),s.params.bookSubscriptionType=o,[n,s]=this.handleOptionAndParams(s,"watchOrderBook","bookUpdateFrequency"),[d,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","bookUpdateFrequency",n),void 0!==d&&(s.params.bookSubscriptionType=d);for(let s=0;s<e.length;s++){const a=e[s],o=this.market(a),n="book."+o.id+"."+t.toString(),d="orderbook:"+o.symbol;r.push(d),i.push(n)}return(await this.watchPublicMultiple(r,i,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),r=this.safeInteger(t,2);e.storeArray([s,i,r])}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeString(t,"instrument_name"),i=this.safeMarket(s).symbol;let a=this.safeValue(t,"data");a=this.safeValue(a,0);const o=this.safeInteger(a,"t");if(!(i in this.orderbooks)){const e=this.safeInteger(t,"depth");this.orderbooks[i]=this.countedOrderBook({},e)}const n=this.orderbooks[i],d=this.safeString(t,"channel"),h=this.safeInteger2(a,"u","s");let c=a;if("book"===d)n.reset({}),n.symbol=i,n.timestamp=o,n.datetime=this.iso8601(o),n.nonce=h;else{c=this.safeValue(a,"update",{});const e=this.safeInteger(a,"pu");if(n.nonce!==e){if(this.handleOption("watchOrderBook","checksum",!0))throw new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(i))}}this.handleDeltas(n.asks,this.safeValue(c,"asks",[])),this.handleDeltas(n.bids,this.safeValue(c,"bids",[])),n.nonce=h,this.orderbooks[i]=n;const l="orderbook:"+i;e.resolve(n,l)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e);const r=[];for(let t=0;t<e.length;t++){const s=e[t],i="trade."+this.market(s).id;r.push(i)}const a=await this.watchPublicMultiple(r,r,i);if(this.newUpdates){const e=this.safeValue(a,0),t=this.safeString(e,"symbol");s=a.getLimit(t,s)}return this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"channel"),i=this.safeString(t,"instrument_name"),r=this.safeString(t,"subscription"),o=this.safeMarket(i),n=o.symbol;let d=this.safeValue(this.trades,n);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new a.I3(e),this.trades[n]=d}const h=this.safeValue(t,"data",[]);if(0===h.length)return;const c=this.parseTrades(h,o);for(let e=0;e<c.length;e++)d.append(c[e]);const l=s.replace("."+i,"");e.resolve(d,r),e.resolve(d,l)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol);let a="user.trade";a=void 0!==r?a+"."+r.id:a;const o=await this.watchPrivateSubscribe(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s="ticker."+this.market(e).id;return await this.watchPublic(s,t)}handleTicker(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),r=this.safeMarket(i),a=this.safeValue(t,"data",[]);for(let t=0;t<a.length;t++){const i=a[t],o=this.parseTicker(i,r),n=o.symbol;this.tickers[n]=o,e.resolve(o,s)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="candlestick."+this.safeString(this.timeframes,t,t)+"."+a.id,n=await this.watchPublic(o,r);return this.newUpdates&&(i=n.getLimit(e,i)),this.filterBySinceLimit(n,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"subscription"),i=this.safeString(t,"instrument_name"),r=this.safeMarket(i),o=r.symbol,n=this.safeString(t,"interval"),d=this.findTimeframe(n);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let h=this.safeValue(this.ohlcvs[o],d);if(void 0===h){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new a.TG(e),this.ohlcvs[o][d]=h}const c=this.safeValue(t,"data");for(let e=0;e<c.length;e++){const t=c[e],s=this.parseOHLCV(t,r);h.append(s)}e.resolve(h,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol);let a="user.order";a=void 0!==r?a+"."+r.id:a;const o=await this.watchPrivateSubscribe(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"channel"),r=this.safeString(t,"subscription"),o=this.safeValue(t,"data",[]);if(o.length>0){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,s=this.parseOrders(o);for(let e=0;e<s.length;e++)t.append(s[e]);e.resolve(t,r),e.resolve(t,i),e.resolve(t,"user.order")}}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r=this.urls.api.ws.private,a={method:"subscribe",params:{channels:["user.position_balance"]},nonce:this.nonce()};let o="positions";e=this.marketSymbols(e),this.isEmpty(e)||(o="::"+e.join(","));const n=this.client(r);this.setPositionsCache(n,e);const d=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),h=this.handleOption("watchPositions","awaitPositionsSnapshot",!0);if(d&&h&&void 0===this.positions){const i=await n.future("fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const c=await this.watch(r,o,this.extend(a,i));return this.newUpdates?c:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}setPositionsCache(e,t,s=void 0){if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const t="fetchPositionsSnapshot";t in e.futures||(e.future(t),this.spawn(this.loadPositionsSnapshot,e,t))}else this.positions=new a.Hk}async loadPositionsSnapshot(e,t){const s=await this.fetchPositions();this.positions=new a.Hk;const i=this.positions;for(let e=0;e<s.length;e++){const t=s[e];this.safeNumber(t,"contracts",0)>0&&i.append(t)}e.futures[t].resolve(i),e.resolve(i,"positions")}handlePositions(e,t){const s=this.safeValue(t,"data",[]),i=this.safeValue(s,0,{}),r=this.safeValue(i,"positions",[]);void 0===this.positions&&(this.positions=new a.Hk);const o=this.positions,n=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.parsePosition(t);n.push(s),o.append(s)}const d=this.findMessageHashes(e,"positions::");for(let t=0;t<d.length;t++){const s=d[t],i=s.split("::")[1].split(","),r=this.filterByArray(n,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(n,"positions")}async watchBalance(e={}){return await this.watchPrivateSubscribe("user.balance",e)}handleBalance(e,t){const s=this.safeString(t,"subscription"),i=this.safeValue(t,"data",[]),r=this.safeValue(i[0],"position_balances",[]);this.balance.info=i;for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"instrument_name"),i=this.safeCurrencyCode(s),a=this.account();a.total=this.safeString(t,"quantity"),a.used=this.safeString(t,"reserved_qty"),this.balance[i]=a,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,s);const a=this.safeString(t,"id");e.resolve(this.balance,a)}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o={method:"private/create-order",params:a=this.createOrderRequest(e,t,s,i,r,a)},n=this.nonce();return await this.watchPrivateRequest(n,o)}handleOrder(e,t){const s=this.safeString(t,"id"),i=this.safeValue(t,"result",{}),r=this.parseOrder(i);e.resolve(r,s)}async cancelOrderWs(e,t=void 0,s={}){await this.loadMarkets();const i={method:"private/cancel-order",params:s=this.extend({order_id:e},s)},r=this.nonce();return await this.watchPrivateRequest(r,i)}async cancelAllOrdersWs(e=void 0,t={}){let s;await this.loadMarkets();const i={method:"private/cancel-all-orders",params:this.extend({},t)};void 0!==e&&(s=this.market(e),i.params.instrument_name=s.id);const r=this.nonce();return await this.watchPrivateRequest(r,i)}handleCancelAllOrders(e,t){const s=this.safeString(t,"id");e.resolve(t,s)}async watchPublic(e,t={}){const s=this.urls.api.ws.public,i={method:"subscribe",params:{channels:[e]},nonce:this.nonce()},r=this.extend(i,t);return await this.watch(s,e,r,e)}async watchPublicMultiple(e,t,s={}){const i=this.urls.api.ws.public,r={method:"subscribe",params:{channels:t},nonce:this.nonce()},a=this.deepExtend(r,s);return await this.watchMultiple(i,e,a,e)}async watchPrivateRequest(e,t={}){await this.authenticate();const s=this.urls.api.ws.private,i={id:e,nonce:e},r=this.extend(i,t);return await this.watch(s,e.toString(),r,!0)}async watchPrivateSubscribe(e,t={}){await this.authenticate();const s=this.urls.api.ws.private,i={method:"subscribe",params:{channels:[e]},nonce:this.nonce()},r=this.extend(i,t);return await this.watch(s,e,r,e)}handleErrorMessage(e,t){const s=this.safeString(t,"id"),i=this.safeString(t,"code");try{if(i&&"0"!==i){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,i,e);const s=this.safeValue(t,"message");throw void 0!==s&&this.throwBroadlyMatchedException(this.exceptions.broad,s,e),new r.ExchangeError(e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t,s);return!0}}handleSubscribe(e,t){const s={candlestick:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,book:this.handleOrderBook,"book.update":this.handleOrderBook,"user.order":this.handleOrders,"user.trade":this.handleTrades,"user.balance":this.handleBalance,"user.position_balance":this.handlePositions},i=this.safeValue2(t,"result","info"),r=this.safeString(i,"channel");void 0!==r&&r.indexOf("user.trade")>-1&&this.handleTrades(e,i),void 0!==r&&r.startsWith("user.order")&&this.handleOrders(e,i);const a=this.safeValue(s,r);void 0!==a&&a.call(this,e,i)}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"method"),i={"":this.handlePing,"public/heartbeat":this.handlePing,"public/auth":this.handleAuthenticate,"private/create-order":this.handleOrder,"private/cancel-order":this.handleOrder,"private/cancel-all-orders":this.handleCancelAllOrders,"private/close-position":this.handleOrder,subscribe:this.handleSubscribe},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s="public/auth",r=this.nonce().toString(),a=s+r+this.apiKey+r,n=this.hmac(this.encode(a),this.encode(this.secret),o.s),d={id:r,nonce:r,method:s,api_key:this.apiKey,sig:n},h=this.extend(d,e);this.watch(t,i,h,i)}return await r}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){this.safeValue(e.futures,"authenticated").resolve(!0)}}},6302:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(8686),r=s(5147),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://api-adapter.backend.currency.com/connect"}},options:{tradesLimit:1e3,OHLCVLimit:1e3,timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"W1"}},streaming:{ping:this.ping,keepAlive:2e4}})}ping(e){return{destination:"ping",correlationId:this.requestId().toString(),payload:{}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleBalance(e,t,s){const i=this.safeValue(t,"payload"),r=this.parseBalance(i);this.balance=this.extend(this.balance,r);const a=this.safeString(s,"messageHash");e.resolve(this.balance,a),a in e.subscriptions&&delete e.subscriptions[a]}handleTicker(e,t,s){const i=this.safeValue(t,"payload"),r=this.safeValue(i,"tickers",[]);for(let t=0;t<r.length;t++){const s=this.parseTicker(r[t]),i=s.symbol;this.tickers[i]=s;const a="/api/v1/ticker/24hr:"+i;e.resolve(s,a),a in e.subscriptions&&delete e.subscriptions[a]}}handleTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,void 0,"/"),a=this.safeInteger(e,"ts"),o=this.safeString(e,"price"),n=this.safeString(e,"size"),d=this.parseNumber(r.Y.stringMul(o,n)),h=this.parseNumber(o),c=this.parseNumber(n),l=this.safeString(e,"id"),u=this.safeString(e,"orderId"),p=this.safeValue(e,"buyer")?"buy":"sell";return{info:e,timestamp:a,datetime:this.iso8601(a),symbol:i,id:l,order:u,type:void 0,takerOrMaker:void 0,side:p,price:h,amount:c,cost:d,fee:void 0}}handleTrades(e,t){const s=this.safeValue(t,"payload"),i=this.handleTrade(s),r=i.symbol,o="trades.subscribe:"+r;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}n.append(i),e.resolve(n,o)}findTimeframe(e,t=void 0){const s=this.safeValue(this.options,"timeframes",t),i=Object.keys(s);for(let t=0;t<i.length;t++){const r=i[t];if(s[r]===e)return r}}handleOHLCV(e,t){const s=this.safeValue(t,"payload",{}),i=this.safeString(s,"interval"),r=this.findTimeframe(i),o=this.safeString(s,"symbol"),n=this.safeMarket(o).symbol,d="OHLCMarketData.subscribe:"+r+":"+n,h=[this.safeInteger(s,"t"),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),void 0];this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let c=this.safeValue(this.ohlcvs[n],r);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[n][r]=c}c.append(h),e.resolve(c,d)}requestId(){const e=this.sum(this.safeInteger(this.options,"correlationId",0),1);return this.options.correlationId=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),r=e+":"+(t=i.symbol),a=this.urls.api.ws,o=this.requestId().toString(),n=this.deepExtend({destination:e,correlationId:o,payload:{symbols:[i.id]}},s),d=this.extend(n,{messageHash:r,symbol:t});return await this.watch(a,r,n,r,d)}async watchPrivate(e,t={}){await this.loadMarkets();const s="/api/v1/account",i=this.urls.api.ws,r=this.requestId().toString(),a={timestamp:this.milliseconds(),apiKey:this.apiKey},n=this.urlencode(this.keysort(a)),d=this.deepExtend({destination:e,correlationId:r,payload:a},t);d.payload.signature=this.hmac(this.encode(n),this.encode(this.secret),o.s);const h=this.extend(d,{messageHash:s});return await this.watch(i,s,d,s,h)}async watchBalance(e={}){return await this.loadMarkets(),await this.watchPrivate("/api/v1/account",e)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="/api/v1/ticker/24hr",r=i+":"+(e=s.symbol),a=this.urls.api.ws,o=this.requestId().toString(),n=this.deepExtend({destination:i,correlationId:o,payload:{symbol:s.id}},t),d=this.extend(n,{messageHash:r,symbol:e});return await this.watch(a,r,n,r,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.watchPublic("trades.subscribe",e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchPublic("depthMarketData.subscribe",e,s)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);const a="OHLCMarketData.subscribe",o=a+":"+t,n={destination:a,payload:{intervals:[this.safeValue(this.options,"timeframes")[t]]}},d=await this.watchPublic(o,e,this.extend(n,r));return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleDeltas(e,t){const s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i],a=t[r];e.store(parseFloat(r),parseFloat(a))}}handleOrderBook(e,t){const s=this.safeValue(t,"payload",{}),i=this.safeValue(s,"data",{}),r=this.safeString(s,"symbol"),a=this.safeSymbol(r,void 0,"/"),o="depthMarketData.subscribe:"+a,n=this.safeInteger(i,"ts");a in this.orderbooks||(this.orderbooks[a]=this.orderBook());const d=this.orderbooks[a];d.reset({symbol:a,timestamp:n,datetime:this.iso8601(n)});const h=this.safeDict(i,"bid",{}),c=this.safeDict(i,"ofr",{});this.handleDeltas(d.bids,h),this.handleDeltas(d.asks,c),this.orderbooks[a]=d,e.resolve(d,o)}handleMessage(e,t){const s=this.safeString(t,"correlationId");if(void 0!==s){const i=this.indexBy(e.subscriptions,"correlationId"),r=this.safeString(t,"status"),a=this.safeValue(i,s);if(void 0!==a&&"OK"===r){const s=this.safeString(a,"destination");if(void 0!==s){const i={"/api/v1/ticker/24hr":this.handleTicker,"/api/v1/account":this.handleBalance},r=this.safeValue(i,s);return void 0===r?void 0:void r.call(this,e,t,a)}}}const i=this.safeString(t,"destination");if(void 0!==i){const s={"marketdepth.event":this.handleOrderBook,"internal.trade":this.handleTrades,"ohlc.event":this.handleOHLCV,ping:this.handlePong},r=this.safeValue(s,i);void 0!==r&&r.call(this,e,t)}}}},7791:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2591),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0},urls:{test:{ws:"wss://test.deribit.com/ws/api/v2"},api:{ws:"wss://www.deribit.com/ws/api/v2"}},options:{ws:{timeframes:{"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"180","6h":"360","12h":"720","1d":"1D"},watchTradesForSymbols:{interval:"100ms"},watchOrderBookForSymbols:{interval:"100ms",useDepthEndpoint:!1,depth:"20",group:"none"}},currencies:["BTC","ETH","SOL","USDC"]},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.safeValue(this.options,"currencies",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e];r.push("user.portfolio."+t)}const a={jsonrpc:"2.0",method:"private/subscribe",params:{channels:r},id:this.requestId()},o=this.deepExtend(a,e);return await this.watch(s,t,o,t,o)}handleBalance(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{});this.balance.info=i;const r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.parseBalance(i);this.balance[a]=o;e.resolve(this.balance,"balance")}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,r=this.safeString(t,"interval","100ms");t=this.omit(t,"interval"),await this.loadMarkets(),"raw"===r&&await this.authenticate();const a="ticker."+s.id+"."+r,o={jsonrpc:"2.0",method:"public/subscribe",params:{channels:["ticker."+s.id+"."+r]},id:this.requestId()},n=this.deepExtend(o,t);return await this.watch(i,a,n,a,n)}handleTicker(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),r=this.safeString(i,"instrument_name"),a=this.safeSymbol(r),o=this.parseTicker(i),n=this.safeString(s,"channel");this.tickers[a]=o,e.resolve(o,n)}async watchTrades(e,t=void 0,s=void 0,i={}){return i.callerMethodName="watchTrades",await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){let r;[r,i]=this.handleOptionAndParams(i,"watchTradesForSymbols","interval","100ms"),"raw"===r&&await this.authenticate();const a=await this.watchMultipleWrapper("trades",r,e,i);if(this.newUpdates){const e=this.safeDict(a,0),t=this.safeString(e,"symbol");s=a.getLimit(t,s)}return this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeDict(t,"params",{}),i=this.safeString(s,"channel","").split("."),r=this.safeString(i,1),o=this.safeString(i,2),n=this.safeSymbol(r),d=this.safeMarket(r),h=this.safeList(s,"data",[]);if(void 0===this.safeValue(this.trades,n)){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.trades[n]=new a.I3(e)}const c=this.trades[n];for(let e=0;e<h.length;e++){const t=h[e],s=this.parseTrade(t,d);c.append(s)}this.trades[n]=c;const l="trades|"+n+"|"+o;e.resolve(this.trades[n],l)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(i),void 0!==e&&(await this.loadMarkets(),e=this.symbol(e));const r=this.urls.api.ws,a=this.safeString(i,"interval","raw");i=this.omit(i,"interval");const o="user.trades.any.any."+a,n={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[o]},id:this.requestId()},d=this.deepExtend(n,i),h=await this.watch(r,o,d,o,d);return this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),r=this.safeValue(s,"data",[]);let o=this.myTrades;if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.Pt(e)}const n=this.parseTrades(r),d={};for(let e=0;e<n.length;e++){const t=n[e];o.append(t);d[t.symbol]=!0}e.resolve(o,i)}async watchOrderBook(e,t=void 0,s={}){return s.callerMethodName="watchOrderBook",await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){let i;[i,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","interval","100ms"),"raw"===i&&await this.authenticate();let r,a="";if([r,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","useDepthEndpoint",!1),r){let e,t;[e,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","depth","20"),[t,s]=this.handleOptionAndParams(s,"watchOrderBookForSymbols","group","none"),a=t+"."+e+"."+i}else a=i;return(await this.watchMultipleWrapper("book",a,e,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",{}),i=this.safeValue(s,"data",{}),r=this.safeString(s,"channel").split(".");let a="";if(5===r.length){a=this.safeString(r,2)+"."+this.safeString(r,3)+"."+this.safeString(r,4)}else{a=this.safeString(r,2)}const o=this.safeString(i,"instrument_name"),n=this.safeSymbol(o),d=this.safeInteger(i,"timestamp");n in this.orderbooks||(this.orderbooks[n]=this.countedOrderBook());const h=this.orderbooks[n],c=this.safeList(i,"asks",[]),l=this.safeList(i,"bids",[]);this.handleDeltas(h.asks,c),this.handleDeltas(h.bids,l),h.nonce=d,h.timestamp=d,h.datetime=this.iso8601(d),h.symbol=n,this.orderbooks[n]=h;const u="book|"+n+"|"+a;e.resolve(h,u)}cleanOrderBook(e){const t=this.safeList(e,"bids",[]),s=this.safeList(e,"asks",[]),i=[];for(let e=0;e<t.length;e++)i.push([t[e][1],t[e][2]]);const r=[];for(let e=0;e<s.length;e++)r.push([s[e][1],s[e][2]]);return e.bids=i,e.asks=r,e}handleDelta(e,t){const s=t[1],i=t[2];"new"===t[0]||"change"===t[0]?e.storeArray([s,i,1]):"delete"===t[0]&&e.storeArray([s,i,0])}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i),void 0!==e&&(e=this.symbol(e));const r=this.urls.api.ws,a=this.safeString(i,"currency","any"),o=this.safeString(i,"interval","raw"),n=this.safeString(i,"kind","any");i=this.omit(i,"interval","currency","kind");const d="user.orders."+n+"."+a+"."+o,h={jsonrpc:"2.0",method:"private/subscribe",params:{channels:[d]},id:this.requestId()},c=this.deepExtend(h,i),l=await this.watch(r,d,c,d,c);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySymbolSinceLimit(l,e,t,s,!0)}handleOrders(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const s=this.safeValue(t,"params",{}),i=this.safeString(s,"channel",""),r=this.safeValue(s,"data",{});let o=[];if(Array.isArray(r))o=this.parseOrders(r);else{o=[this.parseOrder(r)]}const n=this.orders;for(let e=0;e<o.length;e++)n.append(o[e]);e.resolve(this.orders,i)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchOHLCVForSymbols([[e,t]],s,i,r))[e][t]}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length||!Array.isArray(e[0]))throw new r.ArgumentsRequired(this.id+" watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]");const[a,o,n]=await this.watchMultipleWrapper("chart.trades",void 0,e,i);this.newUpdates&&(s=n.getLimit(a,s));const d=this.filterBySinceLimit(n,t,s,0,!0);return this.createOHLCVObject(a,o,d)}handleOHLCV(e,t){const s=this.safeDict(t,"params",{}),i=this.safeString(s,"channel","").split("."),r=this.safeString(i,2),o=this.safeString(i,3),n=this.safeMarket(r),d=n.symbol,h=this.safeDict(this.options,"ws",{}),c=this.safeDict(h,"timeframes",{}),l=this.findTimeframe(o,c);if(this.ohlcvs[d]=this.safeDict(this.ohlcvs,d,{}),void 0===this.safeValue(this.ohlcvs[d],l)){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[d][l]=new a.TG(e)}const u=this.ohlcvs[d][l],p=this.safeDict(s,"data",{}),f=this.parseWsOHLCV(p,n);u.append(f),this.ohlcvs[d][l]=u;const m=[d,l,u],g="chart.trades|"+d+"|"+o;e.resolve(m,g)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"tick"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async watchMultipleWrapper(e,t,s=void 0,i={}){await this.loadMarkets();const a=this.urls.api.ws,o=[],n=[],d="chart.trades"===e,h=d?this.getListFromObjectValues(s,0):s;this.marketSymbols(h,void 0,!1);for(let i=0;i<s.length;i++){const r=s[i];let a;if(d){a=this.market(r[0]);const e=r[1];t=this.safeString(this.timeframes,e,e)}else a=this.market(r);const h=e+"."+a.id+"."+t;o.push(h),n.push(e+"|"+a.symbol+"|"+t)}const c={jsonrpc:"2.0",method:"public/subscribe",params:{channels:o},id:this.requestId()},l=this.deepExtend(c,i);if(this.json(l).length>=32767)throw new r.ExchangeError(this.id+" requested subscription length over limit, try to reduce symbols amount");return await this.watchMultiple(a,n,l,o)}handleMessage(e,t){const s=this.safeValue(t,"error");if(void 0!==s)throw new r.ExchangeError(this.id+" "+this.json(s));const i=this.safeValue(t,"params"),a=this.safeString(i,"channel");if(void 0!==a){const s=a.split("."),i=this.safeString(s,0),o={trades:this.handleMyTrades,portfolio:this.handleBalance,orders:this.handleOrders},n={ticker:this.handleTicker,book:this.handleOrderBook,trades:this.handleTrades,chart:this.handleOHLCV,user:this.safeValue(o,this.safeString(s,1))},d=this.safeValue(n,i);if(void 0!==d)return void d.call(this,e,t);throw new r.NotSupported(this.id+" no handler found for this message "+this.json(t))}const o=this.safeValue(t,"result",{});void 0!==this.safeString(o,"access_token")&&this.handleAuthenticationMessage(e,t)}handleAuthenticationMessage(e,t){return e.resolve(t,"authenticated"),t}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=this.milliseconds(),r=this.numberToString(i),a=r,n="authenticated";let d=this.safeValue(s.subscriptions,n);if(void 0===d){this.checkRequiredCredentials();const h=this.requestId(),c=this.hmac(this.encode(r+"\n"+a+"\n"),this.encode(this.secret),o.s),l={jsonrpc:"2.0",id:h,method:"public/auth",params:{grant_type:"client_signature",client_id:this.apiKey,timestamp:i,signature:c,nonce:a,data:""}};d=await this.watch(t,n,this.extend(l,e),n),s.subscriptions[n]=d}return d}}},5233:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7057),r=s(2079),a=s(2931),o=s(7481);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!1,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:{public:"wss://ws-api.exmo.com:443/v1/public",spot:"wss://ws-api.exmo.com:443/v1/private",margin:"wss://ws-api.exmo.com:443/v1/margin/private"}}},options:{},streaming:{},exceptions:{}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchBalance(e={}){await this.authenticate(e);const[t,s]=this.handleMarketTypeAndParams("watchBalance",void 0,e),i="balance:"+t,r=this.urls.api.ws[t],a={method:"subscribe",topics:[t+"/wallet"],id:this.requestId()},o=this.deepExtend(a,s);return await this.watch(r,i,o,i,o)}handleBalance(e,t){const s=this.safeString(t,"topic").split("/"),i=this.safeString(s,0);"spot"===i?this.parseSpotBalance(t):"margin"===i&&this.parseMarginBalance(t);const r="balance:"+i;e.resolve(this.balance,r)}parseSpotBalance(e){const t=this.safeString(e,"event"),s=this.safeValue(e,"data");if(this.balance.info=s,"snapshot"===t){const e=this.safeValue(s,"balances",{}),t=this.safeValue(s,"reserved",{}),i=Object.keys(e);for(let s=0;s<i.length;s++){const r=i[s],a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(e,r),o.used=this.safeString(t,r),this.balance[a]=o}}else if("update"===t){const e=this.safeString(s,"currency"),t=this.safeCurrencyCode(e),i=this.account();i.free=this.safeString(s,"balance"),i.used=this.safeString(s,"reserved"),this.balance[t]=i}this.balance=this.safeBalance(this.balance)}parseMarginBalance(e){const t=this.safeValue(e,"data");this.balance.info=t;const s=Object.keys(t);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeCurrencyCode(i),a=this.safeValue(t,i),o=this.account();o.free=this.safeString(a,"free"),o.used=this.safeString(a,"used"),o.total=this.safeString(a,"balance"),this.balance[r]=o,this.balance=this.safeBalance(this.balance)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.urls.api.ws.public,r="ticker:"+e,a={method:"subscribe",topics:["spot/ticker:"+s.id],id:this.requestId()},o=this.deepExtend(a,t);return await this.watch(i,r,o,r,o)}handleTicker(e,t){const s=this.safeString(t,"topic").split(":"),i=this.safeString(s,1),r=this.safeSymbol(i),a=this.safeValue(t,"data",{}),o=this.safeMarket(i),n=this.parseTicker(a,o),d="ticker:"+r;this.tickers[r]=n,e.resolve(n,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws.public,o="trades:"+e,n={method:"subscribe",topics:["spot/trades:"+r.id],id:this.requestId()},d=this.deepExtend(n,i),h=await this.watch(a,o,d,o,d);return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"topic").split(":"),i=this.safeString(s,1),r=this.safeSymbol(i),o=this.safeMarket(i),n=this.safeValue(t,"data",[]),d="trades:"+r;let h=this.safeValue(this.trades,r);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e),this.trades[r]=h}for(let e=0;e<n.length;e++){const t=n[e],s=this.parseTrade(t,o);h.append(s)}this.trades[r]=h,e.resolve(this.trades[r],d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const[r,a]=this.handleMarketTypeAndParams("watchMyTrades",void 0,i),o=this.urls.api.ws[r];let n;if(void 0===e)n="myTrades:"+r;else{const t=this.market(e);e=t.symbol,n="myTrades:"+t.symbol}const d={method:"subscribe",topics:[r+"/user_trades"],id:this.requestId()},h=this.deepExtend(d,a),c=await this.watch(o,n,h,n,h);return this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"topic").split("/"),i="myTrades:"+this.safeString(s,0),r=this.safeString(t,"event");let o,n=[];if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.Pt(e),this.myTrades=o}else o=this.myTrades;if("snapshot"===r)n=this.safeValue(t,"data",[]);else if("update"===r){n=[this.safeValue(t,"data",{})]}const d=this.parseTrades(n),h={};for(let e=0;e<d.length;e++){const t=d[e];o.append(t),h[t.symbol]=!0}const c=Object.keys(h);for(let t=0;t<c.length;t++){const s="myTrades:"+c[t];e.resolve(o,s)}e.resolve(o,i)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r=this.urls.api.ws.public,a="orderbook:"+e;s=this.omit(s,"aggregation");const o={method:"subscribe",id:this.requestId(),topics:["spot/order_book_updates:"+i.id]},n=this.deepExtend(o,s);return(await this.watch(r,a,n,a)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"topic").split(":"),i=this.safeString(s,1),r=this.safeSymbol(i),a=this.safeValue(t,"data",{}),o="orderbook:"+r,n=this.safeInteger(t,"ts");r in this.orderbooks||(this.orderbooks[r]=this.orderBook({}));const d=this.orderbooks[r];if("snapshot"===this.safeString(t,"event")){const e=this.parseOrderBook(a,r,n,"bid","ask");d.reset(e)}else{const e=this.safeList(a,"ask",[]),t=this.safeList(a,"bid",[]);this.handleDeltas(d.asks,e),this.handleDeltas(d.bids,t),d.timestamp=n,d.datetime=this.iso8601(n)}e.resolve(d,o)}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleMessage(e,t){const s=this.safeString(t,"event"),i={logged_in:this.handleAuthenticationMessage,info:this.handleInfo,subscribed:this.handleSubscribed},a=this.safeValue(i,s);if(void 0===a){if("update"===s||"snapshot"===s){const s=this.safeString(t,"topic");if(void 0!==s){const i=s.split(":"),r=this.safeString(i,0),a={"spot/ticker":this.handleTicker,"spot/wallet":this.handleBalance,"margin/wallet":this.handleBalance,"margin/wallets":this.handleBalance,"spot/trades":this.handleTrades,"margin/trades":this.handleTrades,"spot/order_book_updates":this.handleOrderBook,"spot/user_trades":this.handleMyTrades,"margin/user_trades":this.handleMyTrades},o=this.safeValue(a,r);if(void 0!==o)return void o.call(this,e,t)}}throw new r.NotSupported(this.id+" received an unsupported message: "+this.json(t))}a.call(this,e,t)}handleSubscribed(e,t){return t}handleInfo(e,t){return t}handleAuthenticationMessage(e,t){e.resolve(t,"authenticated")}async authenticate(e={}){const t="authenticated",[s,i]=this.handleMarketTypeAndParams("authenticate",void 0,e),r=this.urls.api.ws[s],a=this.client(r);let n=this.safeValue(a.subscriptions,t);if(void 0===n){const e=this.milliseconds();this.checkRequiredCredentials();const s=this.requestId(),d=this.apiKey+e.toString(),h=this.hmac(this.encode(d),this.encode(this.secret),o.Zf,"base64"),c={method:"login",id:s,api_key:this.apiKey,sign:h,nonce:e},l=this.extend(c,i);n=await this.watch(r,t,l,t),a.subscriptions[t]=n}return n}}},9195:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9403),r=s(2079),a=s(2931),o=s(7481),n=s(5147);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!0,cancelOrderWs:!0,createMarketBuyOrderWithCostWs:!0,createMarketOrderWs:!0,createMarketOrderWithCostWs:!1,createMarketSellOrderWithCostWs:!1,createOrderWs:!0,createOrdersWs:!0,createPostOnlyOrderWs:!0,createReduceOnlyOrderWs:!0,createStopLimitOrderWs:!0,createStopLossOrderWs:!0,createStopMarketOrderWs:!1,createStopOrderWs:!0,createTakeProfitOrderWs:!0,createTriggerOrderWs:!0,editOrderWs:!0,fetchOrderWs:!0,fetchOrdersWs:!1,fetchOpenOrdersWs:!0,fetchClosedOrdersWs:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,watchMyTrades:!0,watchOHLCV:!0,watchBalance:!0,watchOrders:!0,watchLiquidations:!1,watchLiquidationsForSymbols:!1,watchMyLiquidations:!0,watchMyLiquidationsForSymbols:!0,watchPositions:!0},urls:{api:{ws:"wss://ws.gate.io/v4",spot:"wss://api.gateio.ws/ws/v4/",swap:{usdt:"wss://fx-ws.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws.gateio.ws/v4/ws/delivery/usdt",btc:"wss://fx-ws.gateio.ws/v4/ws/delivery/btc"},option:{usdt:"wss://op-ws.gateio.live/v4/ws/usdt",btc:"wss://op-ws.gateio.live/v4/ws/btc"}},test:{swap:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},future:{usdt:"wss://fx-ws-testnet.gateio.ws/v4/ws/usdt",btc:"wss://fx-ws-testnet.gateio.ws/v4/ws/btc"},option:{usdt:"wss://op-ws-testnet.gateio.live/v4/ws/usdt",btc:"wss://op-ws-testnet.gateio.live/v4/ws/btc"}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,watchTradesSubscriptions:{},watchTickerSubscriptions:{},watchOrderBookSubscriptions:{},watchTicker:{name:"tickers"},watchOrderBook:{interval:"100ms",snapshotDelay:10,snapshotMaxRetries:3,checksum:!0},watchBalance:{settle:"usdt",spot:"spot.balances"},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0}},exceptions:{ws:{exact:{1:r.BadRequest,2:r.BadRequest,4:r.AuthenticationError,6:r.AuthenticationError,11:r.AuthenticationError},broad:{}}}})}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e);e=o.symbol;const n=this.getTypeByMarket(o),d=n+".order_place",h=this.getUrlByMarket(o);a.textIsRequired=!0;const c=this.createOrderRequest(e,t,s,i,r,a);await this.authenticate(h,n);const l=await this.requestPrivate(h,c,d);return this.parseOrder(l,o)}async createOrdersWs(e,t={}){await this.loadMarkets();const s=this.createOrdersRequest(e,t),i=e[0],a=this.market(i.symbol);if(!0!==a.swap)throw new r.NotSupported(this.id+" createOrdersWs is not supported for swap markets");const o=this.getTypeByMarket(a),n=o+".order_batch_place",d=this.getUrlByMarket(a);await this.authenticate(d,o);const h=await this.requestPrivate(d,s,n);return this.parseOrders(h,a)}async cancelAllOrdersWs(e=void 0,t={}){await this.loadMarkets();const s=void 0===e?void 0:this.market(e),i=this.safeBool2(t,"stop","trigger"),r=this.getTypeByMarket(s);let a=r+".order_cancel_cp";[a,t]=this.handleOptionAndParams(t,"cancelAllOrdersWs","channel",a);const o=this.getUrlByMarket(s);t=this.omit(t,["stop","trigger"]);const[n,d]=this.handleMarketTypeAndParams("cancelAllOrders",s,t),[h,c]="spot"===n?this.multiOrderSpotPrepareRequest(s,i,d):this.prepareRequest(s,n,d);await this.authenticate(o,r);const l=await this.requestPrivate(o,this.extend(h,c),a);return this.parseOrders(l,s)}async cancelOrderWs(e,t=void 0,s={}){await this.loadMarkets();const i=void 0===t?void 0:this.market(t),r=this.safeValueN(s,["is_stop_order","stop","trigger"],!1);s=this.omit(s,["is_stop_order","stop","trigger"]);const[a,o]=this.handleMarketTypeAndParams("cancelOrder",i,s),[n,d]="spot"===a||"margin"===a?this.spotOrderPrepareRequest(i,r,o):this.prepareRequest(i,a,o),h=this.getTypeByMarket(i),c=h+".order_cancel",l=this.getUrlByMarket(i);await this.authenticate(l,h),n.order_id=e.toString();const u=await this.requestPrivate(l,this.extend(n,d),c);return this.parseOrder(u,i)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.editOrderRequest(e,t,s,i,r,a,o),h=this.getTypeByMarket(n),c=h+".order_amend",l=this.getUrlByMarket(n);await this.authenticate(l,h);const u=await this.requestPrivate(l,d,c);return this.parseOrder(u,n)}async fetchOrderWs(e,t=void 0,s={}){await this.loadMarkets();const i=void 0===t?void 0:this.market(t),[r,a]=this.fetchOrderRequest(e,t,s),o=this.getTypeByMarket(i),n=o+".order_status",d=this.getUrlByMarket(i);await this.authenticate(d,o);const h=await this.requestPrivate(d,this.extend(r,a),n);return this.parseOrder(h,i)}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatusWs("open",e,t,s,i)}async fetchClosedOrdersWs(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatusWs("finished",e,t,s,i)}async fetchOrdersByStatusWs(e,t=void 0,s=void 0,i=void 0,a={}){let o;if(await this.loadMarkets(),void 0!==t&&(o=this.market(t),t=o.symbol,!0!==o.swap))throw new r.NotSupported(this.id+" fetchOrdersByStatusWs is only supported by swap markets. Use rest API for other markets");const[n,d]=this.fetchOrdersByStatusRequest(e,t,s,i,a),h=this.omit(n,["settle"]),c=this.getTypeByMarket(o),l=c+".order_list",u=this.getUrlByMarket(o);await this.authenticate(u,c);const p=await this.requestPrivate(u,this.extend(h,d),l),f=this.parseOrders(p,o);return this.filterBySymbolSinceLimit(f,t,s,i)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r=i.id,[a,o]=this.handleOptionAndParams(s,"watchOrderBook","interval","100ms"),n=this.getTypeByMarket(i)+".order_book_update",d="orderbook:"+e,h=this.getUrlByMarket(i),c=[r,a];if(void 0===t&&(t=100),i.contract){const e=t.toString();c.push(e)}const l={symbol:e,limit:t};return(await this.subscribePublic(h,d,c,n,o,l)).limit()}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},r)}handleOrderBook(e,t){const s=this.safeString(t,"channel").split("."),i="spot"===this.safeString(s,0),a=i?"spot":"contract",o=this.safeValue(t,"result"),n=this.safeInteger(o,"U"),d=this.safeInteger(o,"u"),h=this.safeString(o,"s"),c=this.safeSymbol(h,void 0,"_",a),l="orderbook:"+c,u=this.safeValue(this.orderbooks,c,this.orderBook({})),p=this.safeInteger(u,"nonce");if(void 0!==p){if(!(p>=d)){if(p>=n-1)this.handleDelta(u,o);else{delete e.subscriptions[l],delete this.orderbooks[c];if(this.handleOption("watchOrderBook","checksum",!0)){const t=new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(c));e.reject(t,l)}}e.resolve(u,l)}}else{let t=0;void 0!==u&&(t=u.cache.length);const s=this.handleOption("watchOrderBook","snapshotDelay",10);if(t===(i?s:0)){const t=e.subscriptions[l],s=this.safeInteger(t,"limit");this.spawn(this.loadOrderBook,e,l,c,s,{})}u.cache.push(o)}}getCacheIndex(e,t){const s=this.safeInteger(e,"nonce"),i=t[0];if(s<this.safeInteger(i,"U"))return-1;for(let e=0;e<t.length;e++){const i=t[e],r=this.safeInteger(i,"U"),a=this.safeInteger(i,"u");if(s>=r-1&&s<a)return e}return t.length}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=t[s];if(Array.isArray(i))e.storeArray(this.parseBidAsk(i));else{const t=this.safeFloat(i,"p"),s=this.safeFloat(i,"s");e.store(t,s)}}}handleDelta(e,t){const s=this.safeInteger(t,"t");e.timestamp=s,e.datetime=this.iso8601(s),e.nonce=this.safeInteger(t,"u");const i=this.safeValue(t,"b",[]),r=this.safeValue(t,"a",[]),a=e.bids,o=e.asks;this.handleBidAsks(a,i),this.handleBidAsks(o,r)}async watchTicker(e,t={}){await this.loadMarkets();e=this.market(e).symbol,t.callerMethodName="watchTicker";const s=await this.watchTickers([e],t);return this.safeValue(s,e)}async watchTickers(e=void 0,t={}){return await this.subscribeWatchTickersAndBidsAsks(e,"watchTickers",this.extend({method:"tickers"},t))}handleTicker(e,t){this.handleTickerAndBidAsk("ticker",e,t)}async watchBidsAsks(e=void 0,t={}){return await this.subscribeWatchTickersAndBidsAsks(e,"watchBidsAsks",this.extend({method:"book_ticker"},t))}handleBidAsk(e,t){this.handleTickerAndBidAsk("bidask",e,t)}async subscribeWatchTickersAndBidsAsks(e=void 0,t=void 0,s={}){await this.loadMarkets(),[t,s]=this.handleParamString(s,"callerMethodName",t),e=this.marketSymbols(e,void 0,!1);const i=this.market(e[0]),r=this.getTypeByMarket(i),a=this.marketIds(e);let o;[o,s]=this.handleOptionAndParams(s,t,"method");const n=this.getUrlByMarket(i),d=r+"."+o,h=t.indexOf("watchTicker")>=0,c=h?"ticker":"bidask",l=[];for(let t=0;t<e.length;t++){const s=e[t];l.push(c+":"+s)}const u=await this.subscribePublicMultiple(n,l,a,d,s);if(this.newUpdates){const e={};return e[u.symbol]=u,e}const p=h?this.tickers:this.bidsasks;return this.filterByArray(p,"symbol",e,!0)}handleTickerAndBidAsk(e,t,s){const i=this.safeString(s,"channel").split("."),r="futures"===this.safeString(i,0)?"contract":"spot",a=this.safeValue(s,"result");let o=[];if(Array.isArray(a))o=this.safeList(s,"result",[]);else{o=[this.safeDict(s,"result",{})]}const n="ticker"===e;for(let s=0;s<o.length;s++){const i=o[s],a=this.safeString(i,"s"),d=this.safeMarket(a,void 0,"_",r),h=this.parseTicker(i,d),c=h.symbol;n?this.tickers[c]=h:this.bidsasks[c]=h;const l=e+":"+c;t.resolve(h,l)}}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e);const r=this.marketIds(e),a=this.market(e[0]),o=this.getTypeByMarket(a)+".trades",n=[];for(let t=0;t<e.length;t++){const s=e[t];n.push("trades:"+s)}const d=this.getUrlByMarket(a),h=await this.subscribePublicMultiple(d,n,r,o,i);if(this.newUpdates){const e=this.safeValue(h,0),t=this.safeString(e,"symbol");s=h.getLimit(t,s)}return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){let s=this.safeValue(t,"result");Array.isArray(s)||(s=[s]);const i=this.parseTrades(s);for(let t=0;t<i.length;t++){const s=i[t],r=s.symbol;let o=this.safeValue(this.trades,r);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.I3(e),this.trades[r]=o}o.append(s);const n="trades:"+r;e.resolve(o,n)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=a.id,n=this.safeString(this.timeframes,t,t),d=this.getTypeByMarket(a)+".candlesticks",h="candles:"+n+":"+a.symbol,c=this.getUrlByMarket(a),l=[n,o],u=await this.subscribePublic(c,h,l,d,r);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"channel").split("."),i="spot"===this.safeString(s,0)?"spot":"contract";let r=this.safeValue(t,"result");Array.isArray(r)||(r=[r]);const o={};for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"n",""),n=s.split("_"),d=this.safeString(n,0),h=this.findTimeframe(d),c=d+"_",l=s.replace(c,""),u=this.safeSymbol(l,void 0,"_",i),p=this.parseOHLCV(t);this.ohlcvs[u]=this.safeValue(this.ohlcvs,u,{});let f=this.safeValue(this.ohlcvs[u],d);if(void 0===f){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);f=new a.TG(e),this.ohlcvs[u][h]=f}f.append(p),o[u]=d}const n=Object.keys(o);for(let t=0;t<n.length;t++){const s=n[t],i=o[s],r=this.findTimeframe(i),a="candles:"+r+":"+s,d=this.safeValue(this.ohlcvs[s],r);e.resolve(d,a)}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets();let o,n="!all";void 0!==e&&(o=this.market(e),n=o.id),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",o,i),[r,i]=this.handleSubTypeAndParams("watchMyTrades",o,i);const d=this.getSupportedMapping(a,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".usertrades";let h="myTrades";void 0!==e&&(h+=":"+e);const c="inverse"===r,l=this.getUrlByMarketType(a,c),u=[n],p="spot"!==a,f=await this.subscribePrivate(l,h,u,d,i,p);return this.newUpdates&&(s=f.getLimit(e,s)),this.filterBySymbolSinceLimit(f,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"result",[]);if(0===s.length)return;let i=this.myTrades;if(void 0===i){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new a.Pt(e),this.myTrades=i}const r=this.parseTrades(s),o={};for(let e=0;e<r.length;e++){const t=r[e];i.append(t);o[t.symbol]=!0}const n=Object.keys(o);for(let t=0;t<n.length;t++){const s="myTrades:"+n[t];e.resolve(i,s)}e.resolve(i,"myTrades")}async watchBalance(e={}){let t,s;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e);const i="inverse"===s,r=this.getUrlByMarketType(t,i),a="spot"!==t,o=this.getSupportedMapping(t,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".balances",n=t+".balance";return await this.subscribePrivate(r,n,void 0,o,e,a)}handleBalance(e,t){const s=this.safeValue(t,"result",[]),i=this.safeInteger(t,"time_ms");this.balance.info=s,this.balance.timestamp=i,this.balance.datetime=this.iso8601(i);for(let e=0;e<s.length;e++){const t=s[e],i=this.account(),r=this.safeString(t,"currency","USDT"),a=this.safeCurrencyCode(r);i.free=this.safeString(t,"available"),i.total=this.safeString2(t,"total","balance"),this.balance[a]=i}const r=this.safeString(t,"channel").split("."),a=this.safeString(r,0),o=this.getSupportedMapping(a,{spot:"spot",futures:"swap",options:"option"})+".balance";this.balance=this.safeBalance(this.balance),e.resolve(this.balance,o)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),e=this.marketSymbols(e);let a,o;this.isEmpty(e)||(r=this.getMarketFromSymbols(e)),[a,o]=this.handleMarketTypeAndParams("watchPositions",r,i),"spot"===a&&(a="swap");const n=this.getSupportedMapping(a,{future:"futures",swap:"futures",option:"options"});let d=a+":positions";this.isEmpty(e)||(d+="::"+e.join(","));const h=n+".positions";let c;[c,o]=this.handleSubTypeAndParams("watchPositions",r,o);const l="inverse"===c,u=this.getUrlByMarketType(a,l),p=this.client(u);this.setPositionsCache(p,a,e);const f=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),m=this.handleOption("watchPositions","awaitPositionsSnapshot",!0),g=this.safeValue(this.positions,a);if(f&&m&&void 0===g)return await p.future(a+":fetchPositionsSnapshot");const v=await this.subscribePrivate(u,d,["!all"],h,o,!0);return this.newUpdates?v:this.filterBySymbolsSinceLimit(this.positions[a],e,t,s,!0)}setPositionsCache(e,t,s=void 0){if(void 0===this.positions&&(this.positions={}),t in this.positions)return;if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const s=t+":fetchPositionsSnapshot";s in e.futures||(e.future(s),this.spawn(this.loadPositionsSnapshot,e,s,t))}else this.positions[t]=new a.Hk}async loadPositionsSnapshot(e,t,s){const i=await this.fetchPositions(void 0,{type:s});this.positions[s]=new a.Hk;const r=this.positions[s];for(let e=0;e<i.length;e++){const t=i[e];r.append(t)}e.futures[t].resolve(r),e.resolve(r,s+":position")}handlePositions(e,t){const s=this.getMarketTypeByUrl(e.url),i=this.safeValue(t,"result",[]),r=this.positions[s],a=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.parsePosition(t);a.push(s),r.append(s)}const o=this.findMessageHashes(e,s+":positions::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),r=this.filterByArray(a,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(a,s+":positions")}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a,o;await this.loadMarkets(),void 0!==e&&(r=this.market(e),e=r.symbol),[a,o]=this.handleMarketTypeAndParams("watchOrders",r,i);const n=this.getSupportedMapping(a,{spot:"spot",margin:"spot",future:"futures",swap:"futures",option:"options"})+".orders";let d,h="orders",c=["!all"];void 0!==e&&(h+=":"+r.id,c=[r.id]),[d,o]=this.handleSubTypeAndParams("watchOrders",r,o);const l="inverse"===d,u=this.getUrlByMarketType(a,l),p="spot"!==a,f=await this.subscribePrivate(u,h,c,n,o,p);return this.newUpdates&&(s=f.getLimit(e,s)),this.filterBySinceLimit(f,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeValue(t,"result",[]),i=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(i));const r=this.orders,o={},n=this.parseOrders(s);for(let e=0;e<n.length;e++){const t=n[e],s=this.safeValue(t,"info"),i=this.safeString(s,"event");if("put"===i||"update"===i)t.status="open";else if("finish"===i){if(void 0===this.safeString(t,"status")){const e=this.safeInteger(s,"left");t.status=0===e?"closed":"canceled"}}r.append(t);const a=t.symbol;o[this.market(a).id]=!0}const d=Object.keys(o);for(let t=0;t<d.length;t++){const s="orders:"+d[t];e.resolve(this.orders,s)}e.resolve(this.orders,"orders")}async watchMyLiquidations(e,t=void 0,s=void 0,i={}){return this.watchMyLiquidationsForSymbols([e],t,s,i)}async watchMyLiquidationsForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0);const a=this.getMarketFromSymbols(e);let o,n;[o,n]=this.handleMarketTypeAndParams("watchMyLiquidationsForSymbols",a,i);const d=this.getSupportedMapping(o,{future:"futures",swap:"futures",option:"options"});let h;[h,n]=this.handleSubTypeAndParams("watchMyLiquidationsForSymbols",a,n);const c="inverse"===h,l=this.getUrlByMarketType(o,c),u=[];let p="";if(this.isEmpty(e)){if("futures"!==d&&!c)throw new r.BadRequest(this.id+" watchMyLiquidationsForSymbols() does not support listening to all symbols, you must call watchMyLiquidations() instead for each symbol you wish to watch.");p="myLiquidations",u.push("!all")}else{if(1!==e.length)throw new r.BadRequest(this.id+" watchMyLiquidationsForSymbols() only allows one symbol at a time. To listen to several symbols call watchMyLiquidationsForSymbols() several times.");p="myLiquidations::"+e[0],u.push(a.id)}const f=d+".liquidates",m=await this.subscribePrivate(l,p,u,f,n,!0);return this.newUpdates?m:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s,!0)}handleLiquidation(e,t){const s=this.safeList(t,"result",[]);for(let t=0;t<s.length;t++){const i=s[t],r=this.parseWsLiquidation(i),o=this.safeString(r,"symbol");let n=this.safeValue(this.liquidations,o);if(void 0===n){const e=this.safeInteger(this.options,"liquidationsLimit",1e3);n=new a.I3(e)}n.append(r),this.liquidations[o]=n,e.resolve(n,"myLiquidations::"+o)}e.resolve([],"myLiquidations")}parseWsLiquidation(e,t=void 0){const s=this.safeString(e,"contract");t=this.safeMarket(s,t);const i=this.safeInteger(e,"time_ms"),r=this.safeString(e,"size"),a=this.safeString(e,"left"),o=n.A.stringAbs(n.A.stringSub(r,a));return this.safeLiquidation({info:e,symbol:this.safeSymbol(s,t),contracts:this.parseNumber(o),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"fill_price"),baseValue:void 0,quoteValue:void 0,timestamp:i,datetime:this.iso8601(i)})}handleErrorMessage(e,t){const s=this.safeDict(t,"data"),i=this.safeDict(s,"errs"),a=this.safeDict(t,"error",i),o=this.safeString2(a,"code","label"),n=this.safeStringN(t,["id","requestId","request_id"]);if(void 0!==a){const s=this.safeString(e.subscriptions,n);try{this.throwExactlyMatchedException(this.exceptions.ws.exact,o,this.json(t)),this.throwExactlyMatchedException(this.exceptions.exact,o,this.json(i));const e=this.safeString(a,"message",this.safeString(i,"message"));throw this.throwBroadlyMatchedException(this.exceptions.ws.broad,e,this.json(t)),new r.ExchangeError(this.json(t))}catch(t){e.reject(t,s),void 0!==s&&s in e.subscriptions&&delete e.subscriptions[s]}return void 0!==n&&n in e.subscriptions&&delete e.subscriptions[n],!0}return!1}handleBalanceSubscription(e,t,s=void 0){this.balance={}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channel"),i={balance:this.handleBalanceSubscription,"spot.order_book_update":this.handleOrderBookSubscription,"futures.order_book_update":this.handleOrderBookSubscription},r=this.safeString(t,"id");if(s in i){const a=this.safeString(e.subscriptions,r),o=this.safeValue(e.subscriptions,a);i[s].call(this,e,t,o)}r in e.subscriptions&&delete e.subscriptions[r]}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if("subscribe"===this.safeString(t,"event"))return void this.handleSubscriptionStatus(e,t);const s=this.safeString(t,"channel","").split("."),i=this.safeValue(s,1),r={usertrades:this.handleMyTrades,candlesticks:this.handleOHLCV,orders:this.handleOrder,positions:this.handlePositions,tickers:this.handleTicker,book_ticker:this.handleBidAsk,trades:this.handleTrades,order_book_update:this.handleOrderBook,balances:this.handleBalance,liquidates:this.handleLiquidation},a=this.safeValue(r,i);void 0!==a&&a.call(this,e,t);const o=this.safeString(t,"request_id");if("authenticated"!==o){if(void 0!==o){const s=this.safeDict(t,"data"),i=this.safeValue(s,"result");!0!==this.safeBool(t,"ack")&&e.resolve(i,o)}}else this.handleAuthenticationMessage(e,t)}getUrlByMarket(e){const t=this.urls.api[e.type];return e.contract?e.linear?t.usdt:t.btc:t}getTypeByMarket(e){return e.spot?"spot":e.option?"options":"futures"}getUrlByMarketType(e,t=!1){const s=this.urls.api[e];return"swap"===e||"future"===e?t?s.btc:s.usdt:s}getMarketTypeByUrl(e){const t={"op-":"option",delivery:"future",fx:"swap"},s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i],a=t[r];if(e.indexOf(r)>=0)return a}return"spot"}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async subscribePublic(e,t,s,i,r={},a=void 0){const o=this.requestId(),n={id:o,time:this.seconds(),channel:i,event:"subscribe",payload:s};if(void 0!==a){const s=this.client(e);if(!(t in s.subscriptions)){const e=o.toString();s.subscriptions[e]=t}}const d=this.extend(n,r);return await this.watch(e,t,d,t,a)}async subscribePublicMultiple(e,t,s,i,r={}){const a={id:this.requestId(),time:this.seconds(),channel:i,event:"subscribe",payload:s},o=this.extend(a,r);return await this.watchMultiple(e,t,o,t)}async authenticate(e,t){const s=t+".login",i=this.client(e),r="authenticated",a=i.future(r);return void 0===this.safeValue(i.subscriptions,r)?await this.requestPrivate(e,{},s,r):a}handleAuthenticationMessage(e,t){this.safeValue(e.futures,"authenticated").resolve(!0)}async requestPrivate(e,t,s,i=void 0){this.checkRequiredCredentials();const r="api";if(void 0===i){i=this.requestId().toString()}const a=i,n=this.seconds(),d=[r,s,this.json(t),n.toString()].join("\n"),h=this.hmac(this.encode(d),this.encode(this.secret),o.Zf,"hex"),c={req_id:i,timestamp:n.toString(),api_key:this.apiKey,signature:h,req_param:t},l={id:i,time:n,channel:s,event:r,payload:c};return await this.watch(e,a,l,a,i)}async subscribePrivate(e,t,s,i,a,n=!1){if(this.checkRequiredCredentials(),n){if(void 0===this.uid||0===this.uid.length)throw new r.ArgumentsRequired(this.id+" requires uid to subscribe");const e=[this.uid];s=void 0===s?e:this.arrayConcat(e,s)}const d=this.seconds(),h="subscribe",c="channel="+i+"&event="+h+"&time="+d.toString(),l=this.hmac(this.encode(c),this.encode(this.secret),o.Zf,"hex"),u={method:"api_key",KEY:this.apiKey,SIGN:l},p=this.requestId(),f={id:p,time:d,channel:i,event:h,auth:u};void 0!==s&&(f.payload=s);const m=this.client(e);if(!(t in m.subscriptions)){const e=p.toString();m.subscriptions[e]=t}const g=this.extend(f,a);return await this.watch(e,t,g,t,t)}}},5843:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(9195);class r extends i.A{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"gateio"})}}},375:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8823),r=s(2931),a=s(2079),o=s(7481),n=s(5147);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchTicker:!1,watchTickers:!1,watchBidsAsks:!0,watchTrades:!0,watchTradesForSymbols:!0,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOHLCV:!0},hostname:"api.gemini.com",urls:{api:{ws:"wss://api.gemini.com"},test:{ws:"wss://api.sandbox.gemini.com"}}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trades:"+r.symbol,o={type:"subscribe",subscriptions:[{name:"l2",symbols:[r.id.toUpperCase()]}]},n="l2:"+r.symbol,d=this.urls.api.ws+"/v2/marketdata",h=await this.watch(d,a,o,n);return this.newUpdates&&(s=h.getLimit(r.symbol,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){const r=await this.helperForWatchMultipleConstruct("trades",e,i);if(this.newUpdates){const e=this.safeList(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"event_id","tid"),r=this.safeString(e,"price"),a=this.safeString2(e,"quantity","amount");let o=this.safeStringLower(e,"side");if(void 0===o){const t=this.safeStringLower(e,"makerSide");"bid"===t?o="sell":"ask"===t&&(o="buy")}const n=this.safeStringLower(e,"symbol"),d=this.safeSymbol(n,t);return this.safeTrade({id:i,order:void 0,info:e,timestamp:s,datetime:this.iso8601(s),symbol:d,type:void 0,side:o,takerOrMaker:void 0,price:r,cost:void 0,amount:a,fee:void 0},t)}handleTrade(e,t){const s=this.parseWsTrade(t),i=s.symbol,a=this.safeInteger(this.options,"tradesLimit",1e3);let o=this.safeValue(this.trades,i);void 0===o&&(o=new r.I3(a),this.trades[i]=o),o.append(s);const n="trades:"+i;e.resolve(o,n)}handleTrades(e,t){const s=this.safeStringLower(t,"symbol"),i=this.safeMarket(s),a=this.safeValue(t,"trades");if(void 0!==a){const t=i.symbol,s=this.safeInteger(this.options,"tradesLimit",1e3);let o=this.safeValue(this.trades,t);void 0===o&&(o=new r.I3(s),this.trades[t]=o);for(let e=0;e<a.length;e++){const t=this.parseWsTrade(a[e],i);o.append(t)}const n="trades:"+t;e.resolve(o,n)}}handleTradesForMultidata(e,t,s){if(void 0!==t){const i=this.safeInteger(this.options,"tradesLimit",1e3),a={};for(let e=0;e<t.length;e++){const o=t[e].symbol,n=this.safeMarket(o.toLowerCase()),d=n.symbol,h=this.parseWsTrade(t[e],n);h.timestamp=s,h.datetime=this.iso8601(s);let c=this.safeValue(this.trades,d);void 0===c&&(c=new r.I3(i),this.trades[d]=c),c.append(h),a[d]=c}const o=Object.keys(a);for(let t=0;t<o.length;t++){const s=o[t],i=a[s],r="trades:"+s;e.resolve(i,r)}}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t,t),n={type:"subscribe",subscriptions:[{name:"candles_"+o,symbols:[a.id.toUpperCase()]}]},d="ohlcv:"+a.symbol+":"+o,h=this.urls.api.ws+"/v2/marketdata",c=await this.watch(h,d,n,d);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){let s=this.safeString(t,"type","").slice(8);const i=s.indexOf("_");s=s.slice(0,i);const a=this.safeString(t,"symbol","").toLowerCase(),o=this.safeMarket(a),n=this.safeSymbol(a,o),d=this.safeValue(t,"changes",[]),h=this.findTimeframe(s);void 0===this.safeValue(this.ohlcvs,n)&&(this.ohlcvs[n]={});let c=this.safeValue(this.ohlcvs[n],h);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new r.TG(e),this.ohlcvs[n][h]=c}const l=d.length;for(let e=0;e<l;e++){const t=l-e-1,s=this.parseOHLCV(d[t],o);c.append(s)}const u="ohlcv:"+n+":"+s;return e.resolve(c,u),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+i.symbol,a={type:"subscribe",subscriptions:[{name:"l2",symbols:[i.id.toUpperCase()]}]},o="l2:"+i.symbol,n=this.urls.api.ws+"/v2/marketdata";return(await this.watch(n,r,a,o)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"changes",[]),i=this.safeStringLower(t,"symbol"),r=this.safeMarket(i).symbol,a="orderbook:"+r;r in this.orderbooks||(this.orderbooks[r]=this.orderBook());const o=this.orderbooks[r];for(let e=0;e<s.length;e++){const t=s[e],i=this.safeNumber(t,1),r=this.safeNumber(t,2),a="buy"===t[0]?"bids":"asks",n=o[a];n.store(i,r),o[a]=n}o.symbol=r,this.orderbooks[r]=o,e.resolve(o,a)}async watchOrderBookForSymbols(e,t=void 0,s={}){return(await this.helperForWatchMultipleConstruct("orderbook",e,s)).limit()}async watchBidsAsks(e=void 0,t={}){return await this.helperForWatchMultipleConstruct("bidsasks",e,t)}handleBidsAsksForMultidata(e,t,s,i){const r=t[0].symbol,a=this.safeMarket(r.toLowerCase()).symbol;a in this.bidsasks||(this.bidsasks[a]=this.parseTicker({}),this.bidsasks[a].symbol=a);const o=this.bidsasks[a],d="bidsasks:"+a;for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString(s,"side"),r=this.safeNumber(s,"price"),a=this.safeString(s,"remaining");if(n.A.stringEq(a,"0"))continue;const d=this.parseNumber(a);"bid"===i?(o.bid=r,o.bidVolume=d):(o.ask=r,o.askVolume=d)}o.timestamp=s,o.datetime=this.iso8601(s),o.info=t,this.bidsasks[a]=o,e.resolve(o,d)}async helperForWatchMultipleConstruct(e,t,s={}){await this.loadMarkets(),t=this.marketSymbols(t,void 0,!1,!0,!0);const i=this.market(t[0]);if(!i.spot&&!i.linear)throw new a.NotSupported(this.id+" watchMultiple supports only spot or linear-swap symbols");const r=[],o=[];for(let s=0;s<t.length;s++){const i=t[s],a=e+":"+i;r.push(a);const n=this.market(i);o.push(n.id)}const n=o.join(",");let d=this.urls.api.ws+"/v1/multimarketdata?symbols="+n+"&heartbeat=true&";return"orderbook"===e?d+="trades=false&bids=true&offers=true":"bidsasks"===e?d+="trades=false&bids=true&offers=true&top_of_book=true":"trades"===e&&(d+="trades=true&bids=false&offers=false"),await this.watchMultiple(d,r,void 0)}handleOrderBookForMultidata(e,t,s,i){const r=t[0].symbol,a=this.safeMarket(r.toLowerCase()).symbol,o="orderbook:"+a;if(!(a in this.orderbooks)){const e=this.orderBook();this.orderbooks[a]=e}const n=this.orderbooks[a],d=n.bids,h=n.asks;for(let e=0;e<t.length;e++){const s=t[e],i=this.safeNumber(s,"price"),r=this.safeNumber(s,"remaining");"bid"===this.safeString(s,"side")?d.store(i,r):h.store(i,r)}n.bids=d,n.asks=h,n.symbol=a,n.nonce=i,n.timestamp=s,n.datetime=this.iso8601(s),this.orderbooks[a]=n,e.resolve(n,o)}handleL2Updates(e,t){this.handleOrderBook(e,t),this.handleTrades(e,t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){const r=this.urls.api.ws+"/v1/order/events?eventTypeFilter=initial&eventTypeFilter=accepted&eventTypeFilter=rejected&eventTypeFilter=fill&eventTypeFilter=cancelled&eventTypeFilter=booked";await this.loadMarkets();const a={url:r};if(await this.authenticate(a),void 0!==e){e=this.market(e).symbol}const o="orders",n=await this.watch(r,o,void 0,o);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}handleHeartbeat(e,t){return e.lastPong=this.milliseconds(),t}handleSubscription(e,t){return t}handleOrder(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new r.Pt(e)}const s=this.orders;for(let e=0;e<t.length;e++){const i=this.parseWsOrder(t[e]);s.append(i)}e.resolve(this.orders,"orders")}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"timestampms"),i=this.safeString(e,"type"),r=this.safeString(e,"symbol"),a=this.safeString(e,"order_type"),o=this.safeString(e,"behavior");let n="GTC",d=!1;return"immediate-or-cancel"===o?n="IOC":"fill-or-kill"===o?n="FOK":"maker-or-cancel"===o&&(n="PO",d=!0),this.safeOrder({id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_order_id"),info:e,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseWsOrderStatus(i),symbol:this.safeSymbol(r,t),type:this.parseWsOrderType(a),timeInForce:n,postOnly:d,side:this.safeString(e,"side"),price:this.safeNumber(e,"price"),stopPrice:void 0,average:this.safeNumber(e,"avg_execution_price"),cost:void 0,amount:this.safeNumber(e,"original_amount"),filled:this.safeNumber(e,"executed_amount"),remaining:this.safeNumber(e,"remaining_amount"),fee:void 0,trades:void 0},t)}parseWsOrderStatus(e){return this.safeString({accepted:"open",booked:"open",fill:"closed",cancelled:"canceled",cancel_rejected:"rejected",rejected:"rejected"},e,e)}parseWsOrderType(e){return this.safeString({"exchange limit":"limit","market buy":"market","market sell":"market"},e,e)}handleError(e,t){throw new a.ExchangeError(this.json(t))}handleMessage(e,t){if(Array.isArray(t))return void this.handleOrder(e,t);"error"===this.safeString(t,"reason")&&this.handleError(e,t);const s={l2_updates:this.handleL2Updates,trade:this.handleTrade,subscription_ack:this.handleSubscription,heartbeat:this.handleHeartbeat},i=this.safeString(t,"type","");if(i.indexOf("candles")>=0)return void this.handleOHLCV(e,t);const r=this.safeValue(s,i);if(void 0!==r&&r.call(this,e,t),"update"===i){const s=this.safeInteger(t,"timestampms",this.milliseconds()),i=this.safeInteger(t,"eventId"),r=this.safeList(t,"events"),a=[],o=[],n=[],d=r.length;for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"type"),i="change"===s&&"side"in t&&this.inArray(t.side,["ask","bid"]),h=this.safeString(t,"reason");"top-of-book"===h||i&&"initial"===h&&2===d?o.push(t):i?a.push(t):"trade"===s&&n.push(r[e])}o.length>0&&this.handleBidsAsksForMultidata(e,o,s,i);a.length>0&&this.handleOrderBookForMultidata(e,a,s,i);n.length>0&&this.handleTradesForMultidata(e,n,s)}}async authenticate(e={}){const t=this.safeString(e,"url");if(void 0!==this.clients&&t in this.clients)return;this.checkRequiredCredentials();const s=this.urls.api.ws.length,i=t.indexOf("?"),r=t.length,a=i>=0?i:r,n={request:t.slice(s,a),nonce:this.nonce()},d=this.stringToBase64(this.json(n)),h=this.hmac(this.encode(d),this.encode(this.secret),o.qt,"hex");this.extendExchangeOptions({ws:{options:{headers:{}}}});const c=this.options.ws.options.headers,l={"X-GEMINI-APIKEY":this.apiKey,"X-GEMINI-PAYLOAD":d,"X-GEMINI-SIGNATURE":h};this.options.ws.options.headers=l,this.client(t),this.options.ws.options.headers=c}}},1481:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(2937),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!1,watchPositions:!1},urls:{api:{ws:{public:"wss://stream-glb.hashkey.com/quote/ws/v1",private:"wss://stream-glb.hashkey.com/api/v1/ws"},test:{ws:{public:"wss://stream-glb.sim.hashkeydev.com/quote/ws/v1",private:"wss://stream-glb.sim.hashkeydev.com/api/v1/ws"}}}},options:{listenKeyRefreshRate:36e5,listenKey:void 0,watchBalance:{fetchBalanceSnapshot:!0,awaitBalanceSnapshot:!1}},streaming:{keepAlive:1e4}})}async wathPublic(e,t,s,i={}){const r={symbol:e.id,topic:t,event:"sub"},a=this.urls.api.ws.public;return await this.watch(a,s,this.deepExtend(r,i),s)}async watchPrivate(e){const t=await this.authenticate(),s=this.getPrivateUrl(t);return await this.watch(s,e,void 0,e)}getPrivateUrl(e){return this.urls.api.ws.private+"/"+e}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="kline_"+this.safeString(this.timeframes,t,t),n="ohlcv:"+e+":"+t,d=await this.wathPublic(a,o,n,r);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),a=this.safeSymbol(s,i);a in this.ohlcvs||(this.ohlcvs[a]={});const o=this.safeDict(t,"params"),n=this.safeString(o,"klineType"),d=this.findTimeframe(n);if(!(d in this.ohlcvs[a])){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[a][d]=new r.TG(e)}const h=this.safeList(t,"data",[]),c=this.ohlcvs[a][d];for(let e=0;e<h.length;e++){const t=this.safeDict(h,e,{}),s=this.parseWsOHLCV(t,i);c.append(s)}const l="ohlcv:"+a+":"+d;e.resolve(c,l)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+(e=s.symbol);return await this.wathPublic(s,"realtimes",i,t)}handleTicker(e,t){const s=this.safeList(t,"data",[]),i=this.parseTicker(this.safeDict(s,0)),r=i.symbol,a="ticker:"+r;this.tickers[r]=i,e.resolve(this.tickers[r],a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trades:"+(e=r.symbol),o=await this.wathPublic(r,"trade",a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),a=i.symbol;if(!(a in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.trades[a]=new r.I3(e)}const o=this.trades[a];let n=this.safeList(t,"data");if(void 0!==n){n=this.sortBy(n,"t");for(let e=0;e<n.length;e++){const t=this.safeDict(n,e),s=this.parseWsTrade(t,i);o.append(s)}}const d="trades:"+a;e.resolve(o,d)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+(e=i.symbol);return(await this.wathPublic(i,"depth",r,s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeSymbol(s),r="orderbook:"+i;i in this.orderbooks||(this.orderbooks[i]=this.orderBook({}));const a=this.orderbooks[i],o=this.safeList(t,"data",[]),n=this.safeDict(o,0),d=this.safeInteger(n,"t"),h=this.parseOrderBook(n,i,d,"b","a");a.reset(h),a.nonce=this.safeInteger(t,"id"),this.orderbooks[i]=a,e.resolve(a,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="orders";void 0!==e&&(r=r+":"+(e=this.symbol(e)));const a=await this.watchPrivate(r);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleOrder(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new r.Pt(e)}const s=this.parseWsOrder(t),i=this.orders;i.append(s);const a="orders";e.resolve(i,a);const o=a+":"+s.symbol;e.resolve(i,o)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"s");t=this.safeMarket(s,t);const i=this.safeInteger(e,"O");let r,a=this.safeStringLower(e,"S");[a,r]=this.parseOrderSideAndReduceOnly(a);let o,n=this.parseOrderType(this.safeString(e,"o")),d=this.safeString(e,"f");return[n,d,o]=this.parseOrderTypeTimeInForceAndPostOnly(n,d),t.contract&&(n=void 0),this.safeOrder({id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),datetime:this.iso8601(i),timestamp:i,lastTradeTimestamp:void 0,lastUpdateTimestamp:void 0,status:this.parseOrderStatus(this.safeString(e,"X")),symbol:t.symbol,type:n,timeInForce:d,side:a,price:this.safeString(e,"p"),average:this.safeString(e,"V"),amount:this.omitZero(this.safeString(e,"q")),filled:this.safeString(e,"z"),remaining:this.safeString(e,"r"),stopPrice:void 0,triggerPrice:void 0,takeProfitPrice:void 0,stopLossPrice:void 0,cost:this.omitZero(this.safeString(e,"Z")),trades:void 0,fee:{currency:this.safeCurrencyCode(this.safeString(e,"N")),amount:this.omitZero(this.safeString(e,"n"))},reduceOnly:r,postOnly:o,info:e},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="myTrades";void 0!==e&&(r+=":"+(e=this.symbol(e)));const a=await this.watchPrivate(r);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleMyTrade(e,t,s={}){if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new r.Pt(e)}const i=this.myTrades,a=this.parseWsTrade(t);i.append(a),this.myTrades=i;const o="myTrades";e.resolve(i,o);const n=o+":"+a.symbol;e.resolve(i,n)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"s");t=this.safeMarket(s,t);const i=this.safeInteger(e,"t"),r=this.safeBool(e,"m");let a;return void 0!==r&&(a=r?"maker":"taker"),this.safeTrade({id:this.safeString2(e,"v","T"),timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,side:this.safeStringLower(e,"S"),price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,takerOrMaker:a,type:void 0,order:this.safeString(e,"o"),fee:void 0,info:e},t)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.authenticate(),a="positions",o=[];if(void 0===(e=this.marketSymbols(e)))o.push(a);else for(let t=0;t<e.length;t++){const s=e[t];o.push(a+":"+s)}const n=this.getPrivateUrl(r),d=await this.watchMultiple(n,o,void 0,o);return this.newUpdates?d:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}handlePosition(e,t){void 0===this.positions&&(this.positions=new r.Hk);const s=this.positions,i=this.parseWsPosition(t);s.append(i);const a="positions";e.resolve(i,a);const o=i.symbol;e.resolve(i,a+":"+o)}parseWsPosition(e,t=void 0){const s=this.safeString(e,"s");t=this.safeMarket(s);const i=this.safeInteger(e,"E");return this.safePosition({symbol:t.symbol,id:void 0,timestamp:i,datetime:this.iso8601(i),contracts:this.safeNumber(e,"P"),contractSize:void 0,side:this.safeStringLower(e,"S"),notional:this.safeNumber(e,"pv"),leverage:this.safeInteger(e,"v"),unrealizedPnl:this.safeNumber(e,"up"),realizedPnl:this.safeNumber(e,"r"),collateral:void 0,entryPrice:this.safeNumber(e,"p"),markPrice:void 0,liquidationPrice:this.safeNumber(e,"f"),marginMode:this.safeStringLower(e,"mt"),hedged:!0,maintenanceMargin:this.safeNumber(e,"mm"),maintenanceMarginPercentage:void 0,initialMargin:this.safeNumber(e,"m"),initialMarginPercentage:void 0,marginRatio:void 0,lastUpdateTimestamp:void 0,lastPrice:void 0,stopLossPrice:void 0,takeProfitPrice:void 0,percentage:void 0,info:e})}async watchBalance(e={}){const t=await this.authenticate();await this.loadMarkets();let s="spot";[s,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e,s);const i="balance:"+s,r=this.getPrivateUrl(t),a=this.client(r);let o,n;return this.setBalanceCache(a,s,i),[o,e]=this.handleOptionAndParams(this.options,"watchBalance","fetchBalanceSnapshot",!0),[n,e]=this.handleOptionAndParams(this.options,"watchBalance","awaitBalanceSnapshot",!1),o&&n&&await a.future(s+":fetchBalanceSnapshot"),await this.watch(r,i,void 0,i)}setBalanceCache(e,t,s){if(s in e.subscriptions)return;const i=this.safeDict(this.options,"watchBalance");if(this.safeBool(i,"fetchBalanceSnapshot",!0)){const s=t+":fetchBalanceSnapshot";s in e.futures||(e.future(s),this.spawn(this.loadBalanceSnapshot,e,s,t))}this.balance[t]={}}async loadBalanceSnapshot(e,t,s){const i=await this.fetchBalance({type:s});this.balance[s]=this.extend(i,this.safeValue(this.balance,s,{}));e.futures[t].resolve(),e.resolve(this.balance[s],"balance:"+s)}handleBalance(e,t){const s=this.safeString(t,"e"),i=this.safeList(t,"B",[]),r=this.safeDict(i,0),a="outboundAccountInfo"===s?"spot":"swap";a in this.balance||(this.balance[a]={}),this.balance[a].info=t;const o=this.safeString(r,"a"),n=this.safeCurrencyCode(o),d=this.account();d.free=this.safeString(r,"f"),d.used=this.safeString(r,"l"),this.balance[a][n]=d,this.balance[a]=this.safeBalance(this.balance[a]);const h="balance:"+a;e.resolve(this.balance[a],h)}async authenticate(e={}){let t=this.safeString(this.options,"listenKey");if(void 0!==t)return t;const s=await this.privatePostApiV1UserDataStream(e);t=this.safeString(s,"listenKey"),this.options.listenKey=t;const i=this.safeInteger(this.options,"listenKeyRefreshRate",36e5);return this.delay(i,this.keepAliveListenKey,t,e),t}async keepAliveListenKey(e,t={}){if(void 0===e)return;const s={listenKey:e};try{await this.privatePutApiV1UserDataStream(this.extend(s,t));const i=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);this.delay(i,this.keepAliveListenKey,e,t)}catch(t){const s=this.getPrivateUrl(e),i=this.client(s);this.options.listenKey=void 0,i.reject(t),delete this.clients[s]}}handleMessage(e,t){Array.isArray(t)&&(t=this.safeDict(t,0,{}));const s=this.safeString2(t,"topic","e");"kline"===s?this.handleOHLCV(e,t):"realtimes"===s?this.handleTicker(e,t):"trade"===s?this.handleTrades(e,t):"depth"===s?this.handleOrderBook(e,t):"contractExecutionReport"===s||"executionReport"===s?this.handleOrder(e,t):"ticketInfo"===s?this.handleMyTrade(e,t):"outboundContractPositionInfo"===s?this.handlePosition(e,t):"outboundAccountInfo"!==s&&"outboundContractAccountInfo"!==s||this.handleBalance(e,t)}}},4524:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7996),r=s(2931),a=s(4852),o=s(2079);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchOrderBook:!0,watchBalance:!0,watchOrders:!0,watchOHLCV:!0,watchMyTrades:!1,createOrderWs:!0,cancelOrderWs:!0,fetchOpenOrdersWs:!0,cancelAllOrdersWs:!0},urls:{api:{ws:{public:"wss://api.hitbtc.com/api/3/ws/public",private:"wss://api.hitbtc.com/api/3/ws/trading"}},test:{ws:{public:"wss://api.demo.hitbtc.com/api/3/ws/public",private:"wss://api.demo.hitbtc.com/api/3/ws/trading"}}},options:{tradesLimit:1e3,watchTicker:{method:"ticker/{speed}"},watchTickers:{method:"ticker/{speed}"},watchOrderBook:{method:"orderbook/full"}},timeframes:{"1m":"M1","3m":"M3","5m":"M5","15m":"M15","30m":"M30","1h":"H1","4h":"H4","1d":"D1","1w":"D7","1M":"1M"},streaming:{keepAlive:4e3}})}async authenticate(){this.checkRequiredCredentials();const e=this.urls.api.ws.private,t="authenticated",s=this.client(e),i=s.future(t);if(void 0===this.safeValue(s.subscriptions,t)){const s=this.milliseconds(),i=this.hmac(this.encode(this.numberToString(s)),this.encode(this.secret),a.s,"hex"),r={method:"login",params:{type:"HS256",api_key:this.apiKey,timestamp:s,signature:i}};this.watch(e,t,r,t)}return await i}async subscribePublic(e,t,s=void 0,i={}){await this.loadMarkets();const r=this.urls.api.ws.public;let a=t;void 0!==s&&(a=a+"::"+s.join(","));const o={method:"subscribe",id:this.nonce(),ch:e},n=this.extend(o,i);return await this.watch(r,a,n,a)}async subscribePrivate(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws.private,r=e.split("_subscribe");let a=this.safeString(r,0);void 0!==t&&(a=a+"::"+t);const o={method:e,params:s,id:this.nonce()};return await this.watch(i,a,o,a)}async tradeRequest(e,t={}){await this.loadMarkets(),await this.authenticate();const s=this.urls.api.ws.private,i=this.nonce().toString(),r={method:e,params:t,id:i};return await this.watch(s,i,r,i)}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook"),r=this.safeString(i,"method","orderbook/full");let a=this.safeString2(s,"method","defaultMethod",r);const o=this.safeString(s,"depth","20"),n=this.safeString(s,"depth","100");"orderbook/{depth}/{speed}"===a?a="orderbook/D"+o+"/"+n+"ms":"orderbook/{depth}/{speed}/batch"===a?a="orderbook/D"+o+"/"+n+"ms/batch":"orderbook/top/{speed}"===a?a="orderbook/top/"+n+"ms":"orderbook/top/{speed}/batch"===a&&(a="orderbook/top/"+n+"ms/batch");const d={params:{symbols:[this.market(e).id]}};return(await this.subscribePublic(a,"orderbooks",[e],this.deepExtend(d,s))).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"snapshot"),i=this.safeDict(t,"update"),r=s||i,a=s?"snapshot":"update",o=Object.keys(r);for(let t=0;t<o.length;t++){const s=o[t],i=this.safeMarket(s).symbol,n=r[s],d="orderbooks::"+i;if(!(i in this.orderbooks)){const t=this.safeDict(e.subscriptions,d,{}),s=this.safeInteger(t,"limit");this.orderbooks[i]=this.orderBook({},s)}const h=this.orderbooks[i],c=this.safeInteger(n,"t"),l=this.safeInteger(n,"s");if("snapshot"===a){const e=this.parseOrderBook(n,i,c,"b","a");h.reset(e)}else{const e=this.safeList(n,"a",[]),t=this.safeList(n,"b",[]);this.handleDeltas(h.asks,e),this.handleDeltas(h.bids,t)}h.timestamp=c,h.datetime=this.iso8601(c),h.nonce=l,h.symbol=i,this.orderbooks[i]=h,e.resolve(h,d)}}handleDelta(e,t){const s=this.safeNumber(t,0),i=this.safeNumber(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){const s=this.safeValue(this.options,"watchTicker"),i=this.safeString(s,"method","ticker/{speed}"),r=this.safeString2(t,"method","defaultMethod",i),a=this.safeString(t,"speed","1s"),o=this.implodeParams(r,{speed:a});t=this.omit(t,["method","speed"]);const n={params:{symbols:[this.market(e).id]}},d=await this.subscribePublic(o,"tickers",[e],this.deepExtend(n,t));return this.safeValue(d,e)}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeValue(this.options,"watchTicker"),i=this.safeString(s,"method","ticker/{speed}"),r=this.safeString2(t,"method","defaultMethod",i),a=this.safeString(t,"speed","1s"),o=this.implodeParams(r,{speed:a});t=this.omit(t,["method","speed"]);const n=[];if(void 0===e)n.push("*");else for(let t=0;t<e.length;t++){const s=this.marketId(e[t]);n.push(s)}const d={params:{symbols:n}},h=await this.subscribePublic(o,"tickers",e,this.deepExtend(d,t));return this.newUpdates?h:this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],a=this.safeMarket(t),o=a.symbol,n=this.parseWsTicker(s[t],a);this.tickers[o]=n,r[o]=n}e.resolve(r,"tickers");const a=this.findMessageHashes(e,"tickers::");for(let t=0;t<a.length;t++){const s=a[t],i=s.split("::")[1].split(","),o=this.filterByArray(r,"symbol",i);Object.keys(o).length>0&&e.resolve(o,s)}return t}parseWsTicker(e,t=void 0){const s=this.safeInteger(e,"t"),i=this.safeSymbol(void 0,t),r=this.safeString(e,"c");return this.safeTicker({symbol:i,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeString(e,"b"),bidVolume:this.safeString(e,"B"),ask:this.safeString(e,"a"),askVolume:this.safeString(e,"A"),vwap:void 0,open:this.safeString(e,"o"),close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:this.safeString(e,"q"),info:e},t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={params:{symbols:[this.market(e).id]}};void 0!==s&&(r.limit=s);const a=await this.subscribePublic("trades","trades",[e],this.deepExtend(r,i));return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp")}handleTrades(e,t){const s=this.safeValue2(t,"snapshot","update",{}),i=Object.keys(s);for(let t=0;t<i.length;t++){const a=i[t],o=this.safeMarket(a),n=this.safeInteger(this.options,"tradesLimit",1e3),d=o.symbol;let h=this.safeValue(this.trades,d);void 0===h&&(h=new r.I3(n),this.trades[d]=h);const c=this.parseWsTrades(s[a],o);for(let e=0;e<c.length;e++)h.append(c[e]);const l="trades::"+d;e.resolve(h,l)}return t}parseWsTrades(e,t=void 0,s=void 0,i=void 0,r={}){e=this.toArray(e);let a=[];for(let s=0;s<e.length;s++){const i=this.extend(this.parseWsTrade(e[s],t),r);a.push(i)}a=this.sortBy2(a,"timestamp","id");const o=this.safeString(t,"symbol");return this.filterBySymbolSinceLimit(a,o,s,i)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"t");return this.safeTrade({info:e,id:this.safeString(e,"i"),order:void 0,timestamp:s,datetime:this.iso8601(s),symbol:this.safeString(t,"symbol"),type:void 0,side:this.safeString(e,"s"),takerOrMaker:void 0,price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,fee:void 0},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){const a="candles/"+this.safeString(this.timeframes,t,t),o={params:{symbols:[this.market(e).id]}};void 0!==i&&(o.params.limit=i);const n=await this.subscribePublic(a,"candles",[e],this.deepExtend(o,r));return this.newUpdates&&(i=n.getLimit(e,i)),this.filterBySinceLimit(n,s,i,0)}handleOHLCV(e,t){const s=this.safeValue2(t,"snapshot","update",{}),i=Object.keys(s),a=this.safeString(t,"ch").split("/"),o=this.safeString(a,1),n=this.findTimeframe(o);for(let t=0;t<i.length;t++){const a=i[t],o=this.safeMarket(a),d=o.symbol;this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let h=this.safeValue(this.ohlcvs[d],n);if(void 0===h){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);h=new r.TG(e),this.ohlcvs[d][n]=h}const c=this.parseWsOHLCVs(s[a],o);for(let e=0;e<c.length;e++)h.append(c[e]);const l="candles::"+d;e.resolve(h,l)}return t}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber(e,"v")]}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),void 0!==e&&(a=this.market(e)),[r,i]=this.handleMarketTypeAndParams("watchOrders",a,i);const o=this.getSupportedMapping(r,{spot:"spot_subscribe",margin:"margin_subscribe",swap:"futures_subscribe",future:"futures_subscribe"}),n=await this.subscribePrivate(o,e,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp")}handleOrder(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit");this.orders=new r.Pt(e)}const s=this.safeValue(t,"params",[]);if(Array.isArray(s))for(let i=0;i<s.length;i++){const r=s[i];this.handleOrderHelper(e,t,r)}else this.handleOrderHelper(e,t,s);return t}handleOrderHelper(e,t,s){const i=this.orders,r=this.safeStringLower2(s,"instrument","symbol"),a=this.safeString(t,"method").split("_order"),o=this.safeString(a,0),n=this.safeSymbol(r),d=this.parseOrder(s);i.append(d),e.resolve(i,o),e.resolve(i,o+"::"+n)}parseWsOrderTrade(e,t=void 0){const s=this.safeInteger(e,"created_at"),i=this.safeString(e,"symbol");return this.safeTrade({info:e,id:this.safeString(e,"trade_id"),order:this.safeString(e,"id"),timestamp:s,datetime:this.iso8601(s),symbol:this.safeMarket(i,t),type:void 0,side:this.safeString(e,"side"),takerOrMaker:this.safeString(e,"trade_taker"),price:this.safeString(e,"trade_price"),amount:this.safeString(e,"trade_quantity"),cost:void 0,fee:{cost:this.safeString(e,"trade_fee"),currency:void 0,rate:void 0}},t)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"created_at"),i=this.safeString(e,"symbol");t=this.safeMarket(i,t);let r;if(void 0!==this.safeString(e,"trade_id")){r=[this.parseWsOrderTrade(e,t)]}const a=this.safeString(e,"status"),o=this.safeString(e,"report_type");let n;return n="canceled"===o?this.parseOrderStatus(o):this.parseOrderStatus(a),this.safeOrder({info:e,id:this.safeString(e,"id"),clientOrderId:this.safeString(e,"client_order_id"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,price:this.safeString(e,"price"),amount:this.safeString(e,"quantity"),type:this.safeString(e,"type"),side:this.safeStringUpper(e,"side"),timeInForce:this.safeString(e,"time_in_force"),postOnly:this.safeString(e,"post_only"),reduceOnly:this.safeValue(e,"reduce_only"),filled:void 0,remaining:void 0,cost:void 0,status:n,average:void 0,trades:r,fee:void 0},t)}async watchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const s=this.getSupportedMapping(t,{spot:"spot_balance_subscribe",swap:"futures_balance_subscribe",future:"futures_balance_subscribe"}),i=this.safeString(e,"mode","batches");e=this.omit(e,"mode");const r={mode:i};return await this.subscribePrivate(s,void 0,this.extend(r,e))}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e);let n,d,h;return[d,a]=this.handleMarketTypeAndParams("createOrder",o,a),[h,a]=this.handleMarginModeAndParams("createOrder",a),[n,a]=this.createOrderRequest(o,d,t,s,i,r,h,a),n=this.extend(n,a),"swap"===d?await this.tradeRequest("futures_new_order",n):"margin"===d||void 0!==h?await this.tradeRequest("margin_new_order",n):await this.tradeRequest("spot_new_order",n)}async cancelOrderWs(e,t=void 0,s={}){let i;await this.loadMarkets();let r,a={client_order_id:e};void 0!==t&&(i=this.market(t)),[r,s]=this.handleMarketTypeAndParams("cancelOrderWs",i,s);const[o,n]=this.handleMarginModeAndParams("cancelOrderWs",s);return a=this.extend(a,n),"swap"===r?await this.tradeRequest("futures_cancel_order",a):"margin"===r||void 0!==o?await this.tradeRequest("margin_cancel_order",a):await this.tradeRequest("spot_cancel_order",a)}async cancelAllOrdersWs(e=void 0,t={}){let s,i,r;if(await this.loadMarkets(),void 0!==e&&(s=this.market(e)),[i,t]=this.handleMarketTypeAndParams("cancelAllOrdersWs",s,t),[r,t]=this.handleMarginModeAndParams("cancelAllOrdersWs",t),"swap"===i)return await this.tradeRequest("futures_cancel_orders",t);if("margin"===i||void 0!==r)throw new o.NotSupported(this.id+" cancelAllOrdersWs is not supported for margin orders");return await this.tradeRequest("spot_cancel_orders",t)}async fetchOpenOrdersWs(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};let o,n;return void 0!==e&&(r=this.market(e),a.symbol=r.id),[o,i]=this.handleMarketTypeAndParams("fetchOpenOrdersWs",r,i),[n,i]=this.handleMarginModeAndParams("fetchOpenOrdersWs",i),"swap"===o?await this.tradeRequest("futures_get_orders",a):"margin"===o||void 0!==n?await this.tradeRequest("margin_get_orders",a):await this.tradeRequest("spot_get_orders",a)}handleBalance(e,t){const s=this.safeString(t,"method"),i=this.safeValue(t,"params"),r=this.parseBalance(i);this.balance=this.deepExtend(this.balance,r),e.resolve(this.balance,s)}handleNotification(e,t){return t}handleOrderRequest(e,t){const s=this.safeString(t,"id"),i=this.safeValue(t,"result",{});if(Array.isArray(i)){const t=[];for(let e=0;e<i.length;e++){const s=this.parseWsOrder(i[e]);t.push(s)}e.resolve(t,s)}else{const t=this.parseWsOrder(i);e.resolve(t,s)}return t}handleMessage(e,t){if(this.handleError(e,t))return;let s=this.safeString2(t,"ch","method");if(void 0!==s){const i=s.split("/");s=this.safeString(i,0);const r={candles:this.handleOHLCV,ticker:this.handleTicker,trades:this.handleTrades,orderbook:this.handleOrderBook,spot_order:this.handleOrder,spot_orders:this.handleOrder,margin_order:this.handleOrder,margin_orders:this.handleOrder,futures_order:this.handleOrder,futures_orders:this.handleOrder,spot_balance:this.handleBalance,futures_balance:this.handleBalance},a=this.safeValue(r,s);void 0!==a&&a.call(this,e,t)}else{const s=this.safeValue(t,"result");if(void 0!==this.safeString(s,"client_order_id")&&this.handleOrderRequest(e,t),!0!==s||"id"in t||this.handleAuthenticate(e,t),Array.isArray(s)){const i=this.safeValue(s,0,{});(0===s.length||"client_order_id"in i)&&this.handleOrderRequest(e,t)}}}handleAuthenticate(e,t){const s="authenticated";if(this.safeValue(t,"result")){this.safeValue(e.futures,s).resolve(!0)}else{const i=new o.AuthenticationError(this.id+" "+this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}return t}handleError(e,t){const s=this.safeValue(t,"error");if(void 0!==s)try{const e=this.safeValue(s,"code"),t=this.safeString(s,"message"),i=this.safeString(s,"description"),r=this.id+" "+i;throw this.throwExactlyMatchedException(this.exceptions.exact,e,r),this.throwBroadlyMatchedException(this.exceptions.broad,t,r),new o.ExchangeError(r)}catch(s){if(s instanceof o.AuthenticationError){const t="authenticated";e.reject(s,t),t in e.subscriptions&&delete e.subscriptions[t]}else{const i=this.safeString(t,"id");e.reject(s,i)}return!0}}}},8247:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(4455),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1},urls:{api:{ws:"wss://api.hollaex.com/stream"},test:{ws:"wss://api.sandbox.hollaex.com/stream"}},options:{watchBalance:{},watchOrders:{}},streaming:{ping:this.ping},exceptions:{ws:{exact:{"Bearer or HMAC authentication required":r.BadSymbol,"Error: wrong input":r.BadRequest}}}})}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="orderbook:"+this.market(e).id;return(await this.watchPublic(i,s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeString(t,"topic"),r=this.safeMarket(s).symbol,a=this.safeValue(t,"data"),o=this.safeString(a,"timestamp"),n=this.parse8601(o),d=this.parseOrderBook(a,r,n);let h;r in this.orderbooks?(h=this.orderbooks[r],h.reset(d)):(h=this.orderBook(d),this.orderbooks[r]=h);const c=i+":"+s;e.resolve(h,c)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="trade:"+r.id,o=await this.watchPublic(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"topic"),i=this.safeString(t,"symbol"),r=this.safeMarket(i),o=r.symbol;let n=this.safeValue(this.trades,o);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[o]=n}const d=this.safeValue(t,"data",[]),h=this.parseTrades(d,r);for(let e=0;e<h.length;e++)n.append(h[e]);const c=s+":"+i;e.resolve(n,c),e.resolve(n,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a="usertrade";void 0!==e&&(r=this.market(e),e=r.symbol,a+=":"+r.id);const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeString(t,"topic"),r=this.safeValue(t,"data");if(0===r.length)return;if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.I3(e)}const o=this.myTrades,n={};for(let e=0;e<r.length;e++){const t=r[e],s=this.parseTrade(t);o.append(s);const i=t.symbol;n[this.market(i).id]=!0}e.resolve(this.myTrades,i);const d=Object.keys(n);for(let t=0;t<d.length;t++){const s=i+":"+d[t];e.resolve(this.myTrades,s)}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a="order";void 0!==e&&(r=this.market(e),e=r.symbol,a+=":"+r.id);const o=await this.watchPrivate(a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeString(t,"topic"),r=this.safeValue(t,"data",{});if(0===r.length)return;if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const o=this.orders;let n;n=Array.isArray(r)?r:[r];const d={};for(let e=0;e<n.length;e++){const t=n[e],s=this.parseOrder(t);o.append(s);const i=t.symbol;d[this.market(i).id]=!0}e.resolve(this.orders,i);const h=Object.keys(d);for(let t=0;t<h.length;t++){const s=i+":"+h[t];e.resolve(this.orders,s)}}async watchBalance(e={}){return await this.watchPrivate("wallet",e)}handleBalance(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data"),r=Object.keys(i),a=this.safeTimestamp(t,"time");this.balance.info=i,this.balance.timestamp=a,this.balance.datetime=this.iso8601(a);for(let e=0;e<r.length;e++){const t=r[e],s=t.split("_"),a=this.safeString(s,0),o=this.safeCurrencyCode(a),n=o in this.balance?this.balance[o]:this.account();n["available"===this.safeString(s,1)?"free":"total"]=this.safeString(i,t),this.balance[o]=n}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}async watchPublic(e,t={}){const s=this.urls.api.ws,i={op:"subscribe",args:[e]},r=this.extend(i,t);return await this.watch(s,e,r,e)}async watchPrivate(e,t={}){this.checkRequiredCredentials();let s=this.safeString(this.options,"ws-expires");if(void 0===s){const e=parseInt((this.timeout/1e3).toString());s=this.sum(this.seconds(),e),s=s.toString(),this.options["ws-expires"]=s}const i=this.urls.api.ws,r="CONNECT/stream"+s,a=this.hmac(this.encode(r),this.encode(this.secret),o.s),n={"api-key":this.apiKey,"api-signature":a,"api-expires":s},d=i+"?"+this.urlencode(n),h={op:"subscribe",args:[e]},c=this.extend(h,t);return await this.watch(d,e,c,e)}handleErrorMessage(e,t){const s=this.safeInteger(t,"error");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,s,e)}}catch(e){if(e instanceof r.AuthenticationError)return!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if("pong"===this.safeString(t,"message"))return void this.handlePong(e,t);const s={trade:this.handleTrades,orderbook:this.handleOrderBook,order:this.handleOrder,wallet:this.handleBalance,usertrade:this.handleMyTrades},i=this.safeValue(t,"topic"),r=this.safeValue(s,i);void 0!==r&&r.call(this,e,t)}ping(e){return{op:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}onError(e,t){this.options["ws-expires"]=void 0,this.onError(e,t)}onClose(e,t){this.options["ws-expires"]=void 0,this.onClose(e,t)}}},3898:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(9946),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,createOrderWs:!1,editOrderWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!1,cancelOrdersWs:!1,cancelAllOrdersWs:!1,fetchTradesWs:!1,fetchBalanceWs:!1,watchOrderBook:!0,watchOrders:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!0,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:{api:{spot:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2",feed:"wss://{hostname}/feed"},future:{linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"},inverse:{public:"wss://api.hbdm.com/ws",private:"wss://api.hbdm.com/notification"}},swap:{inverse:{public:"wss://api.hbdm.com/swap-ws",private:"wss://api.hbdm.com/swap-notification"},linear:{public:"wss://api.hbdm.com/linear-swap-ws",private:"wss://api.hbdm.com/linear-swap-notification"}}},"api-aws":{spot:{public:"wss://api-aws.huobi.pro/ws",private:"wss://api-aws.huobi.pro/ws/v2",feed:"wss://{hostname}/feed"},future:{linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"},inverse:{public:"wss://api.hbdm.vn/ws",private:"wss://api.hbdm.vn/notification"}},swap:{linear:{public:"wss://api.hbdm.vn/linear-swap-ws",private:"wss://api.hbdm.vn/linear-swap-notification"},inverse:{public:"wss://api.hbdm.vn/swap-ws",private:"wss://api.hbdm.vn/swap-notification"}}}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",watchOrderBook:{maxRetries:3,checksum:!0},ws:{gunzip:!0},watchTicker:{name:"market.{marketId}.detail"}},exceptions:{ws:{exact:{"bad-request":r.BadRequest,2002:r.AuthenticationError,2021:r.BadRequest,2001:r.BadSymbol,2011:r.BadSymbol,2040:r.BadRequest,4007:r.BadRequest}}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=this.safeValue(this.options,"watchTicker",{}),a=this.safeString(i,"name","market.{marketId}.detail");if("market.{marketId}.ticker"===a&&"spot"!==s.type)throw new r.BadRequest(this.id+" watchTicker() with name market.{marketId}.ticker is only allowed for spot markets, use market.{marketId}.detail instead");const o=this.implodeParams(a,{marketId:s.id}),n=this.getUrlByMarketType(s.type,s.linear);return await this.subscribePublic(n,e,o,void 0,t)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),r=i.split("."),a=this.safeString(r,1),o=this.safeMarket(a),n=this.parseTicker(s,o),d=this.safeValue(t,"ts");n.timestamp=d,n.datetime=this.iso8601(d);const h=n.symbol;return this.tickers[h]=n,e.resolve(n,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="market."+r.id+".trade.detail",o=this.getUrlByMarketType(r.type,r.linear),n=await this.subscribePublic(o,e,a,void 0,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),r=this.safeString(t,"ch"),o=r.split("."),n=this.safeString(o,1),d=this.safeMarket(n),h=d.symbol;let c=this.safeValue(this.trades,h);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[h]=c}for(let e=0;e<i.length;e++){const t=this.parseTrade(i[e],d);c.append(t)}return e.resolve(c,r),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeString(this.timeframes,t,t),n="market."+a.id+".kline."+o,d=this.getUrlByMarketType(a.type,a.linear),h=await this.subscribePublic(d,e,n,void 0,r);return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),r=this.safeString(i,1),o=this.safeMarket(r),n=o.symbol,d=this.safeString(i,3),h=this.findTimeframe(d);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let c=this.safeValue(this.ohlcvs[n],h);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[n][h]=c}const l=this.safeValue(t,"tick"),u=this.parseOHLCV(l,o);c.append(u),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;if(void 0===t&&(t=i.spot?150:20),!this.inArray(t,[20,150]))throw new r.ExchangeError(this.id+" watchOrderBook market accepts limits of 20 and 150 only");let a;a=i.spot?"market."+i.id+".mbp."+t.toString():"market."+i.id+".depth.size_"+t.toString()+".high_freq";const o=this.getUrlByMarketType(i.type,i.linear,!1,!0);let n=this.handleOrderBookSubscription;i.spot||((s=this.extend(s)).data_type="incremental",n=void 0);return(await this.subscribePublic(o,e,a,n,s)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),a=this.safeString(s,"messageHash"),o=this.safeString(t,"id"),n=this.safeInteger(s,"lastTimestamp");try{const d=this.orderbooks[i],h=this.safeValue(t,"data"),c=d.cache,l=this.safeValue(c,0,{}),u=this.parseOrderBook(h,i),p=this.safeValue(l,"tick"),f=this.safeInteger(p,"prevSeqNum"),m=this.safeInteger(h,"seqNum");u.nonce=m;const g=this.safeInteger(t,"ts");s.lastTimestamp=g;const v=this.safeInteger(s,"limit"),y=this.orderBook(u,v);if(e.resolve(y,o),void 0===f||m<f){const o=this.handleOption("watchOrderBook","maxRetries",3);let d=this.safeInteger(s,"numAttempts",0);if(!(d<o))throw new r.InvalidNonce(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+i+" in "+o.toString()+" attempts");if(a in e.subscriptions){d=this.sum(d,1);const i=this.sum(1e3,n-g);s.numAttempts=d,e.subscriptions[a]=s,this.delay(i,this.watchOrderBookSnapshot,e,t,s)}}else{d.reset(u);for(let t=0;t<c.length;t++)this.handleOrderBookMessage(e,c[t]);d.cache=[],this.orderbooks[i]=d,e.resolve(d,a)}}catch(t){delete e.subscriptions[a],delete this.orderbooks[i],e.reject(t,a)}}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"messageHash"),r=this.safeString(s,"symbol"),a=this.safeInteger(s,"limit"),o=this.safeInteger(t,"ts"),n=this.safeValue(s,"params"),d=this.safeInteger(s,"numAttempts",0),h=this.market(r),c=this.getUrlByMarketType(h.type,h.linear,!1,!0),l=this.requestId(),u={req:i,id:l},p={id:l,messageHash:i,symbol:r,limit:a,params:n,numAttempts:d,lastTimestamp:o,method:this.handleOrderBookSnapshot};try{return(await this.watch(c,l,u,l,p)).limit()}catch(t){delete e.subscriptions[i],e.reject(t,i)}}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t){const s=this.safeValue(t,"ch").split("."),i=this.safeString(s,1),a=this.safeMarket(i),o=a.symbol,n=this.orderbooks[o],d=this.safeValue(t,"tick",{}),h=this.safeInteger(d,"seqNum"),c=this.safeInteger(d,"prevSeqNum"),l=this.safeString(d,"event"),u=this.safeInteger(d,"version"),p=this.safeInteger(t,"ts");if("snapshot"===l){const e=this.parseOrderBook(d,o,p);n.reset(e),n.nonce=u}if(void 0!==c&&c>n.nonce){if(this.handleOption("watchOrderBook","checksum",!0))throw new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(o))}const f=a.spot&&c===n.nonce,m=a.contract&&u-1===n.nonce;if(f||m){const e=this.safeValue(d,"asks",[]),t=this.safeValue(d,"bids",[]);this.handleDeltas(n.asks,e),this.handleDeltas(n.bids,t),n.nonce=f?h:u,n.timestamp=p,n.datetime=this.iso8601(p)}}handleOrderBook(e,t){const s=this.safeString(t,"ch"),i=this.safeDict(t,"tick"),r=this.safeString(i,"event"),a=this.safeString(t,"ch").split("."),o=this.safeString(a,1),n=this.safeSymbol(o);if(!(n in this.orderbooks)){const e=this.safeString(a,3).split("_"),t=this.safeInteger(e,1);this.orderbooks[n]=this.orderBook({},t)}const d=this.orderbooks[n];void 0===r&&void 0===d.nonce?d.cache.push(t):(this.handleOrderBookMessage(e,t),e.resolve(d,s))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),r=this.market(i),a=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},a),r.spot&&this.spawn(this.watchOrderBookSnapshot,e,t,s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;this.checkRequiredCredentials(),await this.loadMarkets();let a,o,n,d,h,c="*";if(void 0!==e?(a=this.market(e),e=a.symbol,r=a.type,h=a.linear?"linear":"inverse",c=a.lowercaseId):(r=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",r),h=this.safeString2(this.options,"subType","defaultSubType","linear"),h=this.safeString(i,"subType",h),i=this.omit(i,["type","subType"])),"spot"===r){let e;void 0===e&&(e=this.safeString2(this.options,"watchMyTrades","mode","0"),e=this.safeString(i,"mode",e),i=this.omit(i,"mode")),o="trade.clearing#"+c+"#"+e,n=o}else{const e=this.getOrderChannelAndMessageHash(r,h,a,i);n=this.safeString(e,0);o=this.safeString(e,1)+":trade"}return d=await this.subscribePrivate(n,o,r,h,i),this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}getOrderChannelAndMessageHash(e,t,s=void 0,i={}){let r,a,o=this.safeString(this.options,"orderType","orders");o=this.safeString(i,"orderType",o),i=this.omit(i,"orderType");const n=void 0!==s?s.lowercaseId.toLowerCase():void 0,d=void 0!==s?s.baseId:void 0,h=o;if(r=h,"linear"===t){const e="cross"===this.safeString(i,"margin","cross")?h+"_cross":h;r=e,void 0!==n?(r+="."+n,a=r):a=e+".*"}else"future"===e?void 0!==d?(a=h+"."+d.toLowerCase(),r=a):a=h+".*":void 0!==n?(a=h+"."+n,r=a):a=h+".*";return[a,r]}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a,o;await this.loadMarkets();let n,d,h="*";if(void 0!==e?(o=this.market(e),e=o.symbol,r=o.type,h=o.lowercaseId,a=o.linear?"linear":"inverse"):(r=this.safeString(this.options,"defaultType","spot"),r=this.safeString(i,"type",r),a=this.safeString2(this.options,"subType","defaultSubType","linear"),a=this.safeString(i,"subType",a),i=this.omit(i,["type","subType"])),"spot"===r)n="orders#"+h,d=n;else{const e=this.getOrderChannelAndMessageHash(r,a,o,i);d=this.safeString(e,0),n=this.safeString(e,1)}const c=await this.subscribePrivate(d,n,r,a,i);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString2(t,"ch","topic"),i=this.safeValue(t,"data");let r=this.safeString(t,"contract_code");void 0===r&&(r=this.safeString(i,"symbol"));const o=this.safeMarket(r);let n;if(void 0!==i){if("trade"===this.safeString(i,"eventType")){const e=this.parseOrderTrade(i,o),t=this.safeString(e,"order"),s=[e],r=this.parseOrderStatus(this.safeString2(i,"orderStatus","status","closed")),a=this.safeString(i,"execAmt"),d=this.safeString(i,"remainAmt");n={id:t,trades:s,status:r,symbol:o.symbol,filled:this.parseNumber(a),remaining:this.parseNumber(d)}}else n=this.parseWsOrder(i,o)}else{n=this.parseWsOrder(t,o);const i=this.safeValue(t,"trade",[]);if(i.length>0){const t={trades:i,ch:s,symbol:r},a={order:this.safeString(n,"id"),type:this.safeString(n,"type"),side:this.safeString(n,"side")};this.handleMyTrade(e,t,a)}}if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}this.orders.append(n),e.resolve(this.orders,s);let d=s.replace("."+o.lowercaseId,"");const h=this.safeStringLower(o,"baseId");d=d.replace("."+h,""),e.resolve(this.orders,d)}parseWsOrder(e,t=void 0){const s=this.safeInteger2(e,"lastActTime","ts"),i=this.safeInteger(e,"orderCreateTime"),r=this.safeString2(e,"contract_code","symbol");t=this.safeMarket(r,t);const a=this.safeSymbol(r,t),o=this.safeString2(e,"orderSize","volume"),n=this.parseOrderStatus(this.safeString2(e,"orderStatus","status")),d=this.safeString2(e,"orderId","order_id"),h=this.safeString2(e,"clientOrderId","client_order_id"),c=this.safeString2(e,"orderPrice","price"),l=this.safeString(e,"execAmt"),u=this.safeString(e,"type"),p=this.safeString(e,"fee");let f;if(void 0!==p){const t=this.safeString(e,"fee_asset");f={cost:p,currency:this.safeCurrencyCode(t)}}const m=this.safeString(e,"trade_avg_price"),g=this.safeValue(e,"trade");let v=[];void 0!==u&&(v=u.split("-"));let y=this.safeStringLower(v,1);void 0===y&&(y=this.safeString(e,"order_price_type"));let w=this.safeStringLower(v,0);void 0===w&&(w=this.safeString(e,"direction"));const b=this.safeString(e,"orderValue");return this.safeOrder({info:e,id:d,clientOrderId:h,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:s,status:n,symbol:a,type:y,timeInForce:void 0,postOnly:void 0,side:w,price:c,amount:o,filled:l,remaining:void 0,cost:b,fee:f,average:m,trades:g},t)}parseOrderTrade(e,t=void 0){const s=(t=this.safeMarket(void 0,t)).symbol,i=this.safeString(e,"tradeId"),r=this.safeString(e,"tradePrice"),a=this.safeString(e,"tradeVolume"),o=this.safeString(e,"orderId"),n=this.safeInteger(e,"tradeTime");let d,h=this.safeString(e,"type");if(void 0!==h){const e=h.split("-");d=e[0],h=e[1]}const c=this.safeValue(e,"aggressor");let l;return void 0!==c&&(l=c?"taker":"maker"),this.safeTrade({info:e,timestamp:n,datetime:this.iso8601(n),symbol:s,id:i,order:o,type:h,takerOrMaker:l,side:d,price:r,amount:a,cost:void 0,fee:void 0},t)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();let a,o,n,d="";this.isEmpty(e)||(r=this.getMarketFromSymbols(e),d="::"+e.join(",")),void 0!==r?(a=r.type,o=r.linear?"linear":"inverse"):([a,i]=this.handleMarketTypeAndParams("watchPositions",r,i),"spot"===a&&(a="future"),[o,i]=this.handleOptionAndParams(i,"watchPositions","subType",o)),e=this.marketSymbols(e),[n,i]=this.handleMarginModeAndParams("watchPositions",i,"cross");const h="linear"===o,c=this.getUrlByMarketType(a,h,!0);d=n+":positions"+d;const l="cross"===n?"positions_cross.*":"positions.*",u=await this.subscribePrivate(l,d,a,o,i);return this.newUpdates?u:this.filterBySymbolsSinceLimit(this.positions[c][n],e,t,s,!1)}handlePositions(e,t){const s=e.url,i="positions_cross"===this.safeString(t,"topic","")?"cross":"isolated";void 0===this.positions&&(this.positions={});const r=this.safeValue(this.positions,s);void 0===r&&(this.positions[s]={});void 0===this.safeValue(r,i)&&(this.positions[s][i]=new a.Hk);const o=this.positions[s][i],n=this.safeValue(t,"data",[]),d=[],h=this.safeInteger(t,"ts");for(let e=0;e<n.length;e++){const t=n[e],s=this.parsePosition(t);s.timestamp=h,s.datetime=this.iso8601(h),d.push(s),o.append(s)}const c=this.findMessageHashes(e,i+":positions::");for(let t=0;t<c.length;t++){const s=c[t],i=s.split("::")[1].split(","),r=this.filterByArray(d,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(d,i+":positions")}async watchBalance(e={}){let t,s;[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("watchBalance",void 0,e,"linear");const i=this.safeValue2(e,"isUnifiedAccount","unified",!1);let r,a,o;if(e=this.omit(e,["isUnifiedAccount","unified"]),await this.loadMarkets(),"spot"===t){let t=this.safeString2(this.options,"watchBalance","mode","2");t=this.safeString(e,"mode",t),r="accounts.update#"+t,a=r}else{const n=this.safeString(e,"symbol"),d=this.safeString(e,"currency"),h=void 0!==n?this.market(n):void 0,c=void 0!==d?this.currency(d):void 0;o=this.safeString(e,"margin","cross"),e=this.omit(e,["currency","symbol","margin"]);let l="accounts";r=l,"linear"===s?i?(l="accounts_unify",r=l,a=l+".usdt"):(l="cross"===o?l+"_cross":l,r=l,"isolated"===o?void 0!==n?(r+="."+h.id,a=r):a=l+".*":void 0!==c?(a=l+"."+c.id,r=a):a=l+".*"):"future"===t?void 0!==c?(r+="."+c.id,a=r):a=l+".*":void 0!==h?(r+="."+h.id,a=r):a=l+".*"}const n={type:t,subType:s,margin:o};return await this.subscribePrivate(a,r,t,s,e,n)}handleBalance(e,t){const s=this.safeString(t,"ch"),i=this.safeValue(t,"data",[]),r=this.safeInteger(i,"changeTime",this.safeInteger(t,"ts"));if(this.balance.timestamp=r,this.balance.datetime=this.iso8601(r),this.balance.info=i,void 0!==s){const t=this.safeString(i,"currency"),r=this.safeCurrencyCode(t),a=this.account();a.free=this.safeString(i,"available"),a.total=this.safeString(i,"balance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,s)}else{if(0===i.length)return;const s=this.safeValue(i,0,{}),r=this.safeString(t,"topic"),a=r.split(".");let o=this.safeString(a,0),n=this.safeValue2(e.subscriptions,o,o+".*");if(void 0===n){o+="."+this.safeString2(s,"margin_asset","symbol").toLowerCase(),n=this.safeValue(e.subscriptions,o)}const d=this.safeString(n,"type"),h=this.safeString(n,"subType");if("accounts_unify"===r){const t=this.safeString(s,"margin_asset"),i=this.safeCurrencyCode(t),r=this.safeString(s,"margin_frozen"),a=this.account();a.free=this.safeString(s,"withdraw_available"),a.used=r,this.balance[i]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"accounts_unify")}else if("linear"===h){if("cross"===this.safeString(n,"margin")){const e="future"===d?"futures_contract_detail":"contract_detail",t=this.safeValue(s,e,[]);if(t.length>0)for(let e=0;e<t.length;e++){const s=t[e],i=this.safeString2(s,"contract_code","margin_account"),r=this.safeMarket(i),a=this.safeString(s,"margin_asset"),o=this.safeCurrency(a),n=this.safeString(r,"settle",o.code);if(void 0!==n){const e=this.account();e.free=this.safeString2(s,"margin_balance","margin_available"),e.used=this.safeString(s,"margin_frozen");const t={};t[n]=e;const i=r.symbol;this.balance[i]=this.safeBalance(t)}}}else for(let e=0;e<i.length;e++){const t=i[e],s=this.account();s.free=this.safeString(t,"margin_balance","margin_available"),s.used=this.safeString(t,"margin_frozen");const r=this.safeString2(t,"margin_asset","symbol"),a=this.safeCurrencyCode(r);this.balance[a]=s,this.balance=this.safeBalance(this.balance)}}else for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"symbol"),r=this.safeCurrencyCode(s),a=this.account();a.free=this.safeString(t,"margin_available"),a.used=this.safeString(t,"margin_frozen"),this.balance[r]=a,this.balance=this.safeBalance(this.balance)}e.resolve(this.balance,o)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s);if(void 0!==r){const i=this.safeValue(r,"method");if(void 0!==i)return void i.call(this,e,t,r);s in e.subscriptions&&delete e.subscriptions[s]}}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeValue(t,"ch",""),i=s.split(".");if("market"===this.safeString(i,0)){const s=this.safeString(i,2),r={depth:this.handleOrderBook,mbp:this.handleOrderBook,detail:this.handleTicker,bbo:this.handleTicker,ticker:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},a=this.safeValue(r,s);if(void 0!==a)return void a.call(this,e,t)}const r=s.split("#"),a=this.safeString(r,0,"");if("trade.clearing"===a)return void this.handleMyTrade(e,t);if(a.indexOf("accounts.update")>=0)return void this.handleBalance(e,t);if("orders"===a)return void this.handleOrder(e,t);if("notify"===this.safeString(t,"op")){const s=this.safeString(t,"topic","");s.indexOf("orders")>=0&&this.handleOrder(e,t),s.indexOf("account")>=0&&this.handleBalance(e,t),s.indexOf("positions")>=0&&this.handlePositions(e,t)}}async pong(e,t){try{const s=this.safeInteger(t,"ping");if(void 0!==s)return void await e.send({pong:s});if("ping"===this.safeString(t,"action")){const s=this.safeValue(t,"data"),i=this.safeInteger(s,"ts");return void await e.send({action:"pong",data:{ts:i}})}if("ping"===this.safeString(t,"op")){const s=this.safeInteger(t,"ts");await e.send({op:"pong",ts:s})}}catch(t){const s=new r.NetworkError(this.id+" pong failed "+this.json(t));e.reset(s)}}handlePing(e,t){this.spawn(this.pong,e,t)}handleAuthenticate(e,t){e.futures.auth.resolve(t)}handleErrorMessage(e,t){if("error"===this.safeString(t,"status")){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),a=this.safeValue(i,s);if(void 0!==a){const i=this.safeString(t,"err-code");try{throw this.throwExactlyMatchedException(this.exceptions.ws.exact,i,this.json(t)),new r.ExchangeError(this.json(t))}catch(t){const i=this.safeString(a,"messageHash");e.reject(t,i),e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}}return!1}const s=this.safeString2(t,"code","err-code");if(void 0!==s&&"200"!==s&&"0"!==s){const i=this.id+" "+this.json(t);try{throw this.throwExactlyMatchedException(this.exceptions.ws.exact,s,i),new r.ExchangeError(i)}catch(t){if(t instanceof r.AuthenticationError){e.reject(t,"auth");const s="auth";return s in e.subscriptions&&delete e.subscriptions[s],!1}e.reject(t)}}return t}handleMessage(e,t){if(this.handleErrorMessage(e,t)){if("id"in t)return void this.handleSubscriptionStatus(e,t);if("action"in t){const s=this.safeString(t,"action");if("ping"===s)return void this.handlePing(e,t);if("sub"===s)return void this.handleSubscriptionStatus(e,t)}if("ch"in t)return"auth"===t.ch?void this.handleAuthenticate(e,t):void this.handleSubject(e,t);if("op"in t){const s=this.safeString(t,"op");if("ping"===s)return void this.handlePing(e,t);if("auth"===s)return void this.handleAuthenticate(e,t);if("sub"===s)return void this.handleSubscriptionStatus(e,t);if("notify"===s)return void this.handleSubject(e,t)}"ping"in t&&this.handlePing(e,t)}}handleMyTrade(e,t,s={}){if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const i=this.myTrades,r=this.safeString(t,"ch");if(void 0!==r){const a=this.safeValue(t,"data");if(void 0!==a){const t=this.parseWsTrade(a);void 0!==this.safeString(t,"symbol")&&(i.append(t),e.resolve(this.myTrades,r))}else{const a=this.safeValue(t,"trades",[]),o=this.safeValue(t,"symbol"),n=this.market(o);for(let e=0;e<a.length;e++){const t=a[e];let r=this.parseTrade(t,n);r=this.extend(r,s),i.append(r)}const d=r+":trade";e.resolve(this.myTrades,d);let h=r.replace("."+n.lowercaseId,"");const c=this.safeStringLower(n,"baseId");h=h.replace("."+c,"");const l=h+":trade";e.resolve(this.myTrades,l)}}}parseWsTrade(e,t=void 0){const s=this.safeSymbol(this.safeString(e,"symbol")),i=this.safeString2(e,"side","orderSide"),r=this.safeString(e,"tradeId"),a=this.safeString(e,"tradePrice"),o=this.safeString(e,"tradeVolume"),n=this.safeString(e,"orderId"),d=this.safeInteger(e,"tradeTime");t=this.market(s);const h=this.safeString(e,"orderType"),c=this.safeValue(e,"aggressor");let l,u;void 0!==c&&(l=c?"taker":"maker");let p,f=[];void 0!==h&&(f=h.split("-"),u=this.safeString(f,1));const m=this.safeCurrencyCode(this.safeString(e,"feeCurrency"));return void 0!==m&&(p={cost:this.safeString(e,"transactFee"),currency:m}),this.safeTrade({info:e,timestamp:d,datetime:this.iso8601(d),symbol:s,id:r,order:n,type:u,takerOrMaker:l,side:i,price:a,amount:o,cost:void 0,fee:p},t)}getUrlByMarketType(e,t=!0,s=!1,i=!1){const r=this.safeString(this.options,"api","api"),a={hostname:this.hostname};let o,n;if("spot"===e)o=s?this.urls.api.ws[r].spot.private:i?this.urls.api.ws[r].spot.feed:this.urls.api.ws[r].spot.public,n=this.implodeParams(o,a);else{const i=this.urls.api.ws[r][e],a=t?i.linear:i.inverse;n=s?a.private:a.public}return n}async subscribePublic(e,t,s,i=void 0,r={}){const a=this.requestId(),o={sub:s,id:a},n={id:a,messageHash:s,symbol:t,params:r};return void 0!==i&&(n.method=i),await this.watch(e,s,this.extend(o,r),s,n)}async subscribePrivate(e,t,s,i,r={},a={}){const o=this.requestId(),n={id:o,messageHash:t,params:r},d=this.extend(n,a);let h;h="spot"===s?{action:"sub",ch:e}:{op:"sub",topic:e,cid:o};const c="linear"===i,l=this.getUrlByMarketType(s,c,!0),u={type:s,url:l,hostname:"spot"===s?this.urls.hostnames.spot:this.urls.hostnames.contract};return await this.authenticate(u),await this.watch(l,t,this.extend(h,r),e,d)}async authenticate(e={}){const t=this.safeString(e,"url"),s=this.safeString(e,"hostname"),i=this.safeString(e,"type");if(void 0===t||void 0===s||void 0===i)throw new r.ArgumentsRequired(this.id+" authenticate requires a url, hostname and type argument");this.checkRequiredCredentials();const a="auth",n=t.replace("wss://"+s,""),d=this.client(t),h=d.future(a);if(void 0===this.safeValue(d.subscriptions,a)){const r=this.ymdhms(this.milliseconds(),"T");let d;d="spot"===i?{accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:r}:{AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:r},d=this.keysort(d);const h=["GET",s,n,this.urlencode(d)].join("\n"),c=this.hmac(this.encode(h),this.encode(this.secret),o.s,"base64");let l;if("spot"===i){l={params:{authType:"api",accessKey:this.apiKey,signatureMethod:"HmacSHA256",signatureVersion:"2.1",timestamp:r,signature:c},action:"req",ch:"auth"}}else l={op:"auth",type:"api",AccessKeyId:this.apiKey,SignatureMethod:"HmacSHA256",SignatureVersion:"2",Timestamp:r,Signature:c};const u={id:this.requestId(),messageHash:a,params:e};this.watch(t,a,l,a,u)}return await h}}},6335:(e,t,s)=>{s.d(t,{A:()=>r});var i=s(3898);class r extends i.A{describe(){return this.deepExtend(super.describe(),{alias:!0,id:"huobi"})}}},6973:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(1325),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTickers:!1,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!1,watchOHLCV:!0},urls:{api:{ws:{api:{public:"wss://{hostname}/ws",private:"wss://{hostname}/ws/v2"}}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,api:"api",ws:{gunzip:!0}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e.toString()}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i="market."+s.id+".detail",r=this.safeString(this.options,"api","api"),a={hostname:this.hostname},o=this.implodeParams(this.urls.api.ws[r].public,a),n=this.requestId(),d={sub:i,id:n},h={id:n,messageHash:i,symbol:e,params:t};return await this.watch(o,i,this.extend(d,t),i,h)}handleTicker(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeString(t,"ch"),r=i.split("."),a=this.safeString(r,1),o=this.safeMarket(a),n=this.parseTicker(s,o),d=this.safeValue(t,"ts");n.timestamp=d,n.datetime=this.iso8601(d);const h=n.symbol;return this.tickers[h]=n,e.resolve(n,i),t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="market."+r.id+".trade.detail",o=this.safeString(this.options,"api","api"),n={hostname:this.hostname},d=this.implodeParams(this.urls.api.ws[o].public,n),h=this.requestId(),c={sub:a,id:h},l={id:h,messageHash:a,symbol:e,params:i},u=await this.watch(d,a,this.extend(c,i),a,l);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"tick",{}),i=this.safeValue(s,"data",{}),r=this.safeString(t,"ch"),o=r.split("."),n=this.safeString(o,1),d=this.safeMarket(n),h=d.symbol;let c=this.safeValue(this.trades,h);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[h]=c}for(let e=0;e<i.length;e++){const t=this.parseTrade(i[e],d);c.append(t)}return e.resolve(c,r),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeString(this.timeframes,t,t),n="market."+a.id+".kline."+o,d=this.safeString(this.options,"api","api"),h={hostname:this.hostname},c=this.implodeParams(this.urls.api.ws[d].public,h),l=this.requestId(),u={sub:n,id:l},p={id:l,messageHash:n,symbol:e,timeframe:t,params:r},f=await this.watch(c,n,this.extend(u,r),n,p);return this.newUpdates&&(i=f.getLimit(e,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"ch"),i=s.split("."),r=this.safeString(i,1),o=this.safeMarket(r),n=o.symbol,d=this.safeString(i,3),h=this.findTimeframe(d);this.ohlcvs[n]=this.safeValue(this.ohlcvs,n,{});let c=this.safeValue(this.ohlcvs[n],h);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[n][h]=c}const l=this.safeValue(t,"tick"),u=this.parseOHLCV(l,o);c.append(u),e.resolve(c,s)}async watchOrderBook(e,t=void 0,s={}){if(void 0!==t&&150!==t)throw new r.ExchangeError(this.id+" watchOrderBook accepts limit = 150 only");await this.loadMarkets();const i=this.market(e);e=i.symbol,t=void 0===t?150:t;const a="market."+i.id+".mbp."+t.toString(),o=this.safeString(this.options,"api","api"),n={hostname:this.hostname},d=this.implodeParams(this.urls.api.ws[o].public,n),h=this.requestId(),c={sub:a,id:h},l={id:h,messageHash:a,symbol:e,limit:t,params:s,method:this.handleOrderBookSubscription};return(await this.watch(d,a,this.extend(c,s),a,l)).limit()}handleOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeString(s,"messageHash"),a=this.orderbooks[i],o=this.safeValue(t,"data"),n=this.parseOrderBook(o,i);n.nonce=this.safeInteger(o,"seqNum"),a.reset(n);const d=a.cache;for(let t=0;t<d.length;t++)this.handleOrderBookMessage(e,d[t],a);this.orderbooks[i]=a,e.resolve(a,r)}async watchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"messageHash");try{const e=this.safeString(s,"symbol"),t=this.safeInteger(s,"limit"),r=this.safeValue(s,"params"),a=this.safeString(this.options,"api","api"),o={hostname:this.hostname},n=this.implodeParams(this.urls.api.ws[a].public,o),d=this.requestId(),h={req:i,id:d},c={id:d,messageHash:i,symbol:e,limit:t,params:r,method:this.handleOrderBookSnapshot};return(await this.watch(n,d,h,d,c)).limit()}catch(t){delete e.subscriptions[i],e.reject(t,i)}}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"tick",{}),r=this.safeInteger(i,"seqNum");if(this.safeInteger(i,"prevSeqNum")<=s.nonce&&r>s.nonce){const e=this.safeValue(i,"asks",[]),a=this.safeValue(i,"bids",[]);this.handleDeltas(s.asks,e),this.handleDeltas(s.bids,a),s.nonce=r;const o=this.safeInteger(t,"ts");s.timestamp=o,s.datetime=this.iso8601(o)}return s}handleOrderBook(e,t){const s=this.safeString(t,"ch"),i=this.safeValue(t,"ch").split("."),r=this.safeString(i,1),a=this.safeSymbol(r),o=this.orderbooks[a];void 0===o.nonce?o.cache.push(t):(this.handleOrderBookMessage(e,t,o),e.resolve(o,s))}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit");i in this.orderbooks&&delete this.orderbooks[i],this.orderbooks[i]=this.orderBook({},r),this.spawn(this.watchOrderBookSnapshot,e,t,s)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s);if(void 0!==r){const i=this.safeValue(r,"method");if(void 0!==i)return i.call(this,e,t,r);s in e.subscriptions&&delete e.subscriptions[s]}return t}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeValue(t,"ch").split(".");if("market"===this.safeString(s,0)){const i=this.safeString(s,2),r={mbp:this.handleOrderBook,detail:this.handleTicker,trade:this.handleTrades,kline:this.handleOHLCV},a=this.safeValue(r,i);void 0!==a&&a.call(this,e,t)}}async pong(e,t){await e.send({pong:this.safeInteger(t,"ping")})}handlePing(e,t){this.spawn(this.pong,e,t)}handleErrorMessage(e,t){if("error"===this.safeString(t,"status")){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s);if(void 0!==r){const i=this.safeString(t,"err-code");try{this.throwExactlyMatchedException(this.exceptions.exact,i,this.json(t))}catch(t){const i=this.safeString(r,"messageHash");e.reject(t,i),e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}}return!1}return t}handleMessage(e,t){this.handleErrorMessage(e,t)&&(void 0!==this.safeString(t,"id")?this.handleSubscriptionStatus(e,t):void 0!==this.safeString(t,"ch")?this.handleSubject(e,t):void 0!==this.safeString(t,"ping")&&this.handlePing(e,t))}}},3984:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(1936),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,createOrderWs:!0,createOrdersWs:!0,editOrderWs:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!1,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchPosition:!1},urls:{api:{ws:{public:"wss://api.hyperliquid.xyz/ws"}},test:{ws:{public:"wss://api.hyperliquid-testnet.xyz/ws"}}},options:{},streaming:{ping:this.ping,keepAlive:2e4},exceptions:{ws:{exact:{}}}})}async createOrdersWs(e,t={}){await this.loadMarkets();const s=this.urls.api.ws.public,i=this.createOrdersRequest(e,t),r=this.wrapAsPostAction(i),a=this.safeDict(r,"request",{}),o=this.safeString(r,"requestId"),n=await this.watch(s,o,a,o),d=this.safeDict(n,"response",{}),h=this.safeDict(d,"data",{}),c=this.safeList(h,"statuses",[]);return this.parseOrders(c,void 0)}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const[o,n]=this.parseCreateOrderArgs(e,t,s,i,r,a);return(await this.createOrdersWs([o],n))[0]}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d=this.urls.api.ws.public,h=this.editOrderRequest(e,t,s,i,r,a,o),c=this.wrapAsPostAction(h),l=this.safeDict(c,"request",{}),u=this.safeString(c,"requestId"),p=await this.watch(d,u,l,u),f=this.safeDict(p,"response",{}),m=this.safeDict(f,"data",{}),g=this.safeList(m,"statuses",[]),v=this.safeDict(g,0,{});return this.parseOrder(v,n)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+(e=i.symbol),a=this.urls.api.ws.public,o={method:"subscribe",subscription:{type:"l2Book",coin:i.swap?i.base:i.id}},n=this.extend(o,s);return(await this.watch(a,r,n,r)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"coin"),r=this.coinToMarketId(i),a=this.market(r).symbol,o=this.safeList(s,"levels",[]),n={bids:this.safeList(o,0,[]),asks:this.safeList(o,1,[])},d=this.safeInteger(s,"time"),h=this.parseOrderBook(n,a,d,"bids","asks","px","sz");if(!(a in this.orderbooks)){const e=this.orderBook(h);this.orderbooks[a]=e}const c=this.orderbooks[a];c.reset(h);const l="orderbook:"+a;e.resolve(c,l)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0);const s="tickers",i=this.urls.api.ws.public,r=await this.watch(i,s,this.extend({method:"subscribe",subscription:{type:"webData2",user:"0x0000000000000000000000000000000000000000"}},t),s);return this.newUpdates?this.filterByArrayTickers(r,"symbol",e):this.tickers}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handlePublicAddress("watchMyTrades",i),await this.loadMarkets();let a="myTrades";void 0!==e&&(a+=":"+(e=this.symbol(e)));const o=this.urls.api.ws.public,n={method:"subscribe",subscription:{type:"userFills",user:r}},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleWsTickers(e,t){const s=this.safeDict(t,"data",{}),i=this.safeList(s,"spotAssetCtxs",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"coin"),a=this.safeMarket(s,void 0,void 0,"spot"),o=this.parseWsTicker(t,a);r.push(o)}const a=this.safeDict(s,"meta",{}),o=this.safeList(a,"universe",[]),n=this.safeList(s,"assetCtxs",[]);for(let e=0;e<o.length;e++){const t=this.extend(this.safeDict(o,e,{}),this.safeDict(n,e,{})),s=t.name+"/USDC:USDC",i=this.safeMarket(s,void 0,void 0,"swap"),a=this.parseWsTicker(t,i);r.push(a)}const d=this.indexBy(r,"symbol");e.resolve(d,"tickers")}parseWsTicker(e,t=void 0){return this.parseTicker(e,t)}handleMyTrades(e,t){const s=this.safeDict(t,"data",{});if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const i=this.myTrades,r={},o=this.safeList(s,"fills",[]);if(0===o.length)return;for(let e=0;e<o.length;e++){const t=o[e],s=this.parseWsTrade(t);r[s.symbol]=!0,i.append(s)}const n=Object.keys(r);for(let t=0;t<n.length;t++){const s="myTrades:"+n[t];e.resolve(i,s)}e.resolve(i,"myTrades")}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trade:"+(e=r.symbol),o=this.urls.api.ws.public,n={method:"subscribe",subscription:{type:"trades",coin:r.swap?r.base:r.id}},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeList(t,"data",[]),i=this.safeDict(s,0,{}),r=this.safeString(i,"coin"),o=this.coinToMarketId(r),n=this.market(o).symbol;if(!(n in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3),t=new a.I3(e);this.trades[n]=t}const d=this.trades[n];for(let e=0;e<s.length;e++){const t=this.safeDict(s,e),i=this.parseWsTrade(t);d.append(i)}const h="trade:"+n;e.resolve(d,h)}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"px"),r=this.safeString(e,"sz"),a=this.safeString(e,"coin"),o=this.coinToMarketId(a),n=(t=this.safeMarket(o,void 0)).symbol,d=this.safeString(e,"tid");let h=this.safeString(e,"side");void 0!==h&&(h="A"===h?"sell":"buy");const c=this.safeString(e,"fee");return this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,id:d,order:void 0,type:void 0,side:h,takerOrMaker:void 0,price:i,amount:r,cost:void 0,fee:{cost:c,currency:"USDC"}},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.urls.api.ws.public,n={method:"subscribe",subscription:{type:"candle",coin:a.swap?a.base:a.id,interval:t}},d="candles:"+t+":"+e,h=this.extend(n,r),c=await this.watch(o,d,h,d);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"s"),r=this.coinToMarketId(i),o=this.safeSymbol(r),n=this.safeString(s,"i");if(o in this.ohlcvs||(this.ohlcvs[o]={}),!(n in this.ohlcvs[o])){const e=this.safeInteger(this.options,"OHLCVLimit",1e3),t=new a.TG(e);this.ohlcvs[o][n]=t}const d=this.ohlcvs[o][n],h=this.parseOHLCV(s);d.append(h);const c="candles:"+n+":"+o;e.resolve(d,c)}handleWsPost(e,t){const s=this.safeDict(t,"data"),i=this.safeString(s,"id"),r=this.safeDict(s,"response"),a=this.safeDict(r,"payload");e.resolve(a,i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),[r,i]=this.handlePublicAddress("watchOrders",i);let o="order";void 0!==e&&(a=this.market(e),o=o+":"+(e=a.symbol));const n=this.urls.api.ws.public,d={method:"subscribe",subscription:{type:"orderUpdates",user:r}},h=this.extend(d,i),c=await this.watch(n,o,h,o);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrder(e,t){const s=this.safeList(t,"data",[]);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}if(0===s.length)return;const i=this.orders,r="order",o={};for(let e=0;e<s.length;e++){const t=s[e],r=this.parseOrder(t);i.append(r);o[this.safeString(r,"symbol")]=!0}const n=Object.keys(o);for(let t=0;t<n.length;t++){const s=r+":"+n[t];e.resolve(i,s)}e.resolve(i,r)}handleErrorMessage(e,t){const s=this.safeString(t,"channel",""),i=this.safeString(t,"data","");if("error"===s)throw new r.ExchangeError(this.id+" "+i);return!1}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"channel",""),i={pong:this.handlePong,trades:this.handleTrades,l2Book:this.handleOrderBook,candle:this.handleOHLCV,orderUpdates:this.handleOrder,userFills:this.handleMyTrades,webData2:this.handleWsTickers,post:this.handleWsPost},r=this.safeValue(i,s);if(void 0!==r)return void r.call(this,e,t);const a=Object.keys(i);for(let r=0;r<a.length;r++){const o=a[r];if(s.indexOf(a[r])>=0){return void i[o].call(this,e,t)}}}ping(e){return{method:"ping"}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"pong"),t}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}wrapAsPostAction(e){const t=this.requestId();return{requestId:t,request:{method:"post",id:t,request:{type:"action",payload:e}}}}}},460:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(636),r=s(2079),a=s(2931),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchOHLCV:!0,watchTicker:!0,watchTickers:!1,watchOrders:!0,watchTransactions:!0},urls:{test:{ws:"wss://websocket-matic.idex.io/v1"},api:{}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchOrderBookLimit:1e3,orderBookSubscriptions:{},token:void 0,watchOrderBook:{maxRetries:3},fetchOrderBookSnapshotMaxAttempts:10,fetchOrderBookSnapshotMaxDelay:1e4}})}async subscribe(e,t,s=!0){const i=this.urls.test.ws,r={method:"subscribe",subscriptions:[e]};return await this.watch(i,t,r,t,s)}async subscribePrivate(e,t){const s=await this.authenticate(),i=this.urls.test.ws,r={method:"subscribe",token:s,subscriptions:[e]};return await this.watch(i,t,r,t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="tickers",r={name:i,markets:[s.id]},a=i+":"+s.id;return await this.subscribe(this.extend(r,t),a)}handleTicker(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),r=this.safeString(i,"m"),a=this.safeSymbol(r),n=s+":"+r,d=this.safeInteger(i,"t"),h=this.safeString(i,"c"),c=this.safeString(i,"P");let l;void 0!==c&&void 0!==h&&(l=o.Y.stringMul(h,c));const u=this.safeTicker({symbol:a,timestamp:d,datetime:this.iso8601(d),high:this.safeString(i,"h"),low:this.safeString(i,"l"),bid:this.safeString(i,"b"),bidVolume:void 0,ask:this.safeString(i,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(i,"o"),close:h,last:h,previousClose:void 0,change:l,percentage:c,average:void 0,baseVolume:this.safeString(i,"v"),quoteVolume:this.safeString(i,"q"),info:t});e.resolve(u,n)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="trades",o={name:a,markets:[r.id]},n=a+":"+r.id,d=await this.subscribe(o,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySinceLimit(d,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),r=s+":"+this.safeString(i,"m"),o=this.parseWsTrade(i);if(0===Object.keys(this.trades).length){const e=this.safeInteger(this.options,"tradesLimit");this.trades=new a.Pt(e)}const n=this.trades;n.append(o),e.resolve(n,r)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"m"),i=this.safeSymbol(s),r=this.safeString(e,"i"),a=this.safeString(e,"p"),o=this.safeString(e,"q"),n=this.safeString(e,"Q"),d=this.safeInteger(e,"t"),h=this.safeString(e,"s"),c={currency:this.safeString(e,"a"),cost:this.safeString(e,"f")},l=this.safeString(e,"l");return this.safeTrade({info:e,timestamp:d,datetime:this.iso8601(d),symbol:i,id:r,order:void 0,type:void 0,takerOrMaker:l,side:h,price:a,amount:o,cost:n,fee:c})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="candles",n=this.safeString(this.timeframes,t,t),d={name:o,markets:[a.id],interval:n},h=o+":"+a.id,c=await this.subscribe(d,h);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),r=this.safeString(i,"m"),o=s+":"+r,n=[this.safeInteger(i,"s"),this.safeFloat(i,"o"),this.safeFloat(i,"h"),this.safeFloat(i,"l"),this.safeFloat(i,"c"),this.safeFloat(i,"v")],d=this.safeSymbol(r),h=this.safeString(i,"i"),c=this.findTimeframe(h);this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let l=this.safeValue(this.ohlcvs[d],c);if(void 0===l){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new a.TG(e),this.ohlcvs[d][c]=l}l.append(n),e.resolve(l,o)}handleSubscribeMessage(e,t){const s=this.safeValue(t,"subscriptions");for(let t=0;t<s.length;t++){const i=s[t];if("l2orderbook"===this.safeString(i,"name")){const t=this.safeValue(i,"markets");for(let s=0;s<t.length;s++){const i=t[s];if(!(i in this.safeValue(this.options,"orderBookSubscriptions",{}))){const t=this.safeSymbol(i);if(!(t in this.orderbooks)){const e=this.countedOrderBook({});this.orderbooks[t]=e}this.spawn(this.fetchOrderBookSnapshot,e,t)}}break}}}async fetchOrderBookSnapshot(e,t,s={}){const i=this.orderbooks[t],a="l2orderbook:"+this.market(t).id,o=e.subscriptions[a];o.fetchingOrderBookSnapshot||(o.startTime=this.milliseconds()),o.fetchingOrderBookSnapshot=!0;const n=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxAttempts",10),d=this.safeInteger(this.options,"fetchOrderBookSnapshotMaxDelay",1e4);try{const s=this.safeInteger(o,"limit",0),h=await this.fetchRestOrderBookSafe(t,s),c=this.safeValue(i.cache,0),l=this.safeValue(c,"data"),u=this.safeInteger(l,"u"),p=i.cache.length,f=this.safeValue(i.cache,p-1),m=this.safeValue(f,"data"),g=this.safeInteger(m,"u");if(void 0!==u&&void 0!==g&&u<=h.nonce+1&&g>h.nonce){i.reset(h);for(let t=0;t<i.cache.length;t++){const s=i.cache[t],r=this.safeValue(s,"data");this.safeInteger(r,"u")>i.nonce&&this.handleOrderBookMessage(e,s,i)}o.fetchingOrderBookSnapshot=!1,e.resolve(i,a)}else{o.numAttempts=o.numAttempts+1;const s=this.milliseconds()-o.startTime,i=o.numAttempts<n;if(!i||!(s<d)){const e=i?" after "+d.toString()+" milliseconds":" in "+n.toString()+" attempts";throw new r.InvalidNonce(this.id+" failed to synchronize WebSocket feed with the snapshot for symbol "+t+e)}this.delay(this.rateLimit,this.fetchOrderBookSnapshot,e,t)}}catch(t){o.fetchingOrderBookSnapshot=!1,e.reject(t,a)}}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="l2orderbook",a={name:r,markets:[i.id]},o=r+":"+i.id,n={fetchingOrderBookSnapshot:!1,numAttempts:0,startTime:void 0};n.limit=void 0===t?1e3:t;return(await this.subscribe(a,o,n)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(s,"m"),r=this.safeSymbol(i),a=this.orderbooks[r];void 0===a.nonce?a.cache.push(t):this.handleOrderBookMessage(e,t,a)}handleOrderBookMessage(e,t,s){const i=this.safeString(t,"type"),r=this.safeValue(t,"data"),a=i+":"+this.safeString(r,"m"),o=this.safeInteger(r,"u"),n=this.safeInteger(r,"t"),d=this.safeValue(r,"b"),h=this.safeValue(r,"a");this.handleDeltas(s.bids,d),this.handleDeltas(s.asks,h),s.nonce=o,s.timestamp=n,s.datetime=this.iso8601(n),e.resolve(s,a)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1),r=this.safeInteger(t,2);e.storeArray([s,i,r])}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async authenticate(e={}){const t=this.seconds();if(t-this.safeInteger(this.options,"lastAuthenticatedTime",0)>900){const s={wallet:this.walletAddress,nonce:this.uuidv1()},i=await this.privateGetWsToken(this.extend(s,e));this.options.lastAuthenticatedTime=t,this.options.token=this.safeString(i,"token")}return this.options.token}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="orders",a={name:r};let o=r;if(void 0!==e){e=this.symbol(e);const t=this.marketId(e);a.markets=[t],o=r+":"+t}const n=await this.subscribePrivate(a,o);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleOrder(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),r=this.safeString(i,"m"),n=this.safeSymbol(r),d=this.safeInteger(i,"t"),h=this.safeValue(i,"F",[]),c=[];for(let e=0;e<h.length;e++)c.push(this.parseWsTrade(h[e]));const l=this.safeString(i,"i"),u=this.safeString(i,"s"),p=this.safeString(i,"o"),f=this.safeString(i,"q"),m=this.safeString(i,"z"),g=this.safeString(i,"v"),v=this.safeString(i,"price",g),y=this.safeString(i,"X"),w=this.parseOrderStatus(y),b={currency:void 0,cost:void 0};let S;for(let e=0;e<c.length;e++){S=c[e],b.currency=S.fee.currency;const t=S.fee.cost;b.cost=o.Y.stringAdd(b.cost,t)}const k=this.safeInteger(S,"timestamp"),O=this.safeOrder({info:t,id:l,clientOrderId:void 0,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:k,symbol:n,type:p,side:u,price:this.parseNumber(v),stopPrice:void 0,triggerPrice:void 0,amount:this.parseNumber(f),cost:void 0,average:this.parseNumber(g),filled:this.parseNumber(m),remaining:void 0,status:w,fee:b,trades:c});if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const T=this.orders;T.append(O);const P=s+":"+r;e.resolve(T,P),e.resolve(T,s)}async watchTransactions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="balances",a={name:r};let o=r;void 0!==e&&(o=r+":"+e);const n=await this.subscribePrivate(a,o);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp")}handleTransaction(e,t){const s=this.safeString(t,"type"),i=this.safeValue(t,"data"),r=this.safeString(i,"a"),o=s+":"+r,n=this.safeCurrencyCode(r),d={info:t,id:void 0,currency:n,amount:void 0,address:this.safeString(i,"w"),addressTo:void 0,addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,status:"ok",type:void 0,updated:void 0,txid:void 0,timestamp:void 0,datetime:void 0,fee:void 0};if(!(n in this.transactions)){const e=this.safeInteger(this.options,"transactionsLimit",1e3);this.transactions[n]=new a.I3(e)}const h=this.transactions[n];h.append(d),e.resolve(h,o),e.resolve(h,s)}handleMessage(e,t){const s=this.safeString(t,"type"),i={tickers:this.handleTicker,trades:this.handleTrade,subscriptions:this.handleSubscribeMessage,candles:this.handleOHLCV,l2orderbook:this.handleOrderBook,balances:this.handleTransaction,orders:this.handleOrder};if(s in i){i[s].call(this,e,t)}}}},98:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4162),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!1,watchOrders:!1,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://websockets.independentreserve.com"}},options:{watchOrderBook:{checksum:!0}},streaming:{},exceptions:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws+"?subscribe=ticker-"+r.base+"-"+r.quote,o="trades:"+e,n=await this.watch(a,o,void 0,o);return this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"Data",{}),i=this.safeString(s,"Pair"),r=this.safeSymbol(i,void 0,"-"),o="trades:"+r;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}const d=this.parseWsTrade(s);n.append(d),this.trades[r]=n,e.resolve(this.trades[r],o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"TradeDate"),i=this.safeString(t,"Pair");return this.safeTrade({info:e,id:this.safeString(e,"TradeGuid"),order:this.safeString(e,"orderNo"),symbol:this.safeSymbol(i,t,"-"),side:this.safeStringLower(e,"Side"),type:void 0,takerOrMaker:void 0,price:this.safeString(e,"Price"),amount:this.safeString(e,"Volume"),cost:void 0,fee:void 0,timestamp:this.parse8601(s),datetime:s},t)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol,void 0===t&&(t=100);const r=this.numberToString(t),a=this.urls.api.ws+"/orderbook/"+r+"?subscribe="+i.base+"-"+i.quote,o="orderbook:"+e+":"+r;return(await this.watch(a,o,void 0,o,{receivedSnapshot:!1})).limit()}handleOrderBook(e,t){const s=this.safeString(t,"Event"),i=this.safeString(t,"Channel").split("/"),a=this.safeString(i,1),o=this.safeString(i,2),n=this.safeString(i,3),d=this.safeCurrencyCode(o)+"/"+this.safeCurrencyCode(n),h=this.safeDict(t,"Data",{}),c="orderbook:"+d+":"+a,l=this.safeValue(e.subscriptions,c,{}),u=this.safeBool(l,"receivedSnapshot",!1),p=this.safeInteger(t,"Time");d in this.orderbooks||(this.orderbooks[d]=this.orderBook({}));const f=this.orderbooks[d];if("OrderBookSnapshot"===s){const e=this.parseOrderBook(h,d,p,"Bids","Offers","Price","Volume");f.reset(e),l.receivedSnapshot=!0}else{const e=this.safeList(h,"Offers",[]),t=this.safeList(h,"Bids",[]);this.handleDeltas(f.asks,e),this.handleDeltas(f.bids,t),f.timestamp=p,f.datetime=this.iso8601(p)}if(this.handleOption("watchOrderBook","checksum",!0)&&u){const t=f.asks,s=f.bids,i=t.length,a=s.length;let o="";for(let e=0;e<10;e++)e<a&&(o=o+this.valueToChecksum(s[e][0])+this.valueToChecksum(s[e][1]));for(let e=0;e<10;e++)e<i&&(o=o+this.valueToChecksum(t[e][0])+this.valueToChecksum(t[e][1]));if(this.crc32(o,!0)!==this.safeInteger(h,"Crc32")){const t=new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(d));delete e.subscriptions[c],delete this.orderbooks[d],e.reject(t,c)}}u&&e.resolve(f,c)}valueToChecksum(e){let t=e.toFixed(8);return t=t.replace(".",""),t=this.parseNumber(t),t=this.numberToString(t),t}handleDelta(e,t){const s=this.parseBidAsk(t,"Price","Volume");e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleHeartbeat(e,t){return t}handleSubscriptions(e,t){return t}handleMessage(e,t){const s=this.safeString(t,"Event"),i={Subscriptions:this.handleSubscriptions,Heartbeat:this.handleHeartbeat,Trade:this.handleTrades,OrderBookSnapshot:this.handleOrderBook,OrderBookChange:this.handleOrderBook},a=this.safeValue(i,s);if(void 0===a)throw new r.NotSupported(this.id+" received an unsupported message: "+this.json(t));a.call(this,e,t)}}},9050:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(8042),r=s(2079),a=s(2931),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,createOrderWs:!0,editOrderWs:!0,cancelOrderWs:!0,cancelOrdersWs:!0,cancelAllOrdersWs:!0},urls:{api:{ws:{public:"wss://ws.kraken.com",private:"wss://ws-auth.kraken.com",privateV2:"wss://ws-auth.kraken.com/v2",beta:"wss://beta-ws.kraken.com","beta-private":"wss://beta-ws-auth.kraken.com"}}},options:{tradesLimit:1e3,OHLCVLimit:1e3,ordersLimit:1e3,symbolsByOrderId:{},watchOrderBook:{checksum:!0}},exceptions:{ws:{exact:{"Event(s) not found":r.BadRequest},broad:{"Already subscribed":r.BadRequest,"Currency pair not in ISO 4217-A3 format":r.BadSymbol,"Malformed request":r.BadRequest,"Pair field must be an array":r.BadRequest,"Pair field unsupported for this subscription type":r.BadRequest,"Pair(s) not found":r.BadSymbol,"Subscription book depth must be an integer":r.BadRequest,"Subscription depth not supported":r.BadRequest,"Subscription field must be an object":r.BadRequest,"Subscription name invalid":r.BadRequest,"Subscription object unsupported field":r.BadRequest,"Subscription ohlc interval must be an integer":r.BadRequest,"Subscription ohlc interval not supported":r.BadRequest,"Subscription ohlc requires interval":r.BadRequest,"EAccount:Invalid permissions":r.PermissionDenied,"EAuth:Account temporary disabled":r.AccountSuspended,"EAuth:Account unconfirmed":r.AuthenticationError,"EAuth:Rate limit exceeded":r.RateLimitExceeded,"EAuth:Too many requests":r.RateLimitExceeded,"EDatabase: Internal error (to be deprecated)":r.ExchangeError,"EGeneral:Internal error[:<code>]":r.ExchangeError,"EGeneral:Invalid arguments":r.BadRequest,"EOrder:Cannot open opposing position":r.InvalidOrder,"EOrder:Cannot open position":r.InvalidOrder,"EOrder:Insufficient funds (insufficient user funds)":r.InsufficientFunds,"EOrder:Insufficient margin (exchange does not have sufficient funds to allow margin trading)":r.InsufficientFunds,"EOrder:Invalid price":r.InvalidOrder,"EOrder:Margin allowance exceeded":r.InvalidOrder,"EOrder:Margin level too low":r.InvalidOrder,"EOrder:Margin position size exceeded (client would exceed the maximum position size for this pair)":r.InvalidOrder,"EOrder:Order minimum not met (volume too low)":r.InvalidOrder,"EOrder:Orders limit exceeded":r.InvalidOrder,"EOrder:Positions limit exceeded":r.InvalidOrder,"EOrder:Rate limit exceeded":r.RateLimitExceeded,"EOrder:Scheduled orders limit exceeded":r.InvalidOrder,"EOrder:Unknown position":r.OrderNotFound,"EOrder:Unknown order":r.OrderNotFound,"EOrder:Invalid order":r.InvalidOrder,"EService:Deadline elapsed":r.ExchangeNotAvailable,"EService:Market in cancel_only mode":r.NotSupported,"EService:Market in limit_only mode":r.NotSupported,"EService:Market in post_only mode":r.NotSupported,"EService:Unavailable":r.ExchangeNotAvailable,"ETrade:Invalid request":r.BadRequest}}}})}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=await this.authenticate(),n=this.market(e),d=this.urls.api.ws.private,h=this.requestId(),c=h;let l={event:"addOrder",token:o,reqid:h,ordertype:t,type:s,pair:n.wsId,volume:this.amountToPrecision(e,i)};return[l,a]=this.orderRequest("createOrderWs",e,t,l,i,r,a),await this.watch(d,c,this.extend(l,a),c)}handleCreateEditOrder(e,t){const s=this.parseOrder(t),i=this.safeValue(t,"reqid");e.resolve(s,i)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=await this.authenticate(),d=this.market(t),h=this.urls.api.ws.private,c=this.requestId(),l=c;let u={event:"editOrder",token:n,reqid:c,orderid:e,pair:d.wsId};return void 0!==r&&(u.volume=this.amountToPrecision(t,r)),[u,o]=this.orderRequest("editOrderWs",t,s,u,r,a,o),await this.watch(h,l,this.extend(u,o),l)}async cancelOrdersWs(e,t=void 0,s={}){await this.loadMarkets();const i=await this.authenticate(),r=this.urls.api.ws.private,a=this.requestId(),o=a,n={event:"cancelOrder",token:i,reqid:a,txid:e};return await this.watch(r,o,this.extend(n,s),o)}async cancelOrderWs(e,t=void 0,s={}){await this.loadMarkets();const i=await this.authenticate(),r=this.urls.api.ws.private,a=this.requestId(),o=a,n=this.safeValue2(s,"userref","clientOrderId",e);s=this.omit(s,["userref","clientOrderId"]);const d={event:"cancelOrder",token:i,reqid:a,txid:[n]};return await this.watch(r,o,this.extend(d,s),o)}handleCancelOrder(e,t){const s=this.safeValue(t,"reqid");e.resolve(t,s)}async cancelAllOrdersWs(e=void 0,t={}){if(void 0!==e)throw new r.NotSupported(this.id+" cancelAllOrdersWs () does not support cancelling orders in a specific market.");await this.loadMarkets();const s=await this.authenticate(),i=this.urls.api.ws.private,a=this.requestId(),o=a,n={event:"cancelAll",token:s,reqid:a};return await this.watch(i,o,this.extend(n,t),o)}handleCancelAllOrders(e,t){const s=this.safeValue(t,"reqid");e.resolve(t,s)}handleTicker(e,t,s){const i=t[3],r=this.safeValue(this.options.marketsByWsName,i).symbol,a=this.getMessageHash("ticker",void 0,r),n=t[1],d=this.safeString(n.p,0);let h;const c=this.safeString(n.v,0);void 0!==c&&void 0!==d&&(h=o.Y.stringMul(c,d));const l=this.safeString(n.c,0),u=this.safeTicker({symbol:r,timestamp:void 0,datetime:void 0,high:this.safeString(n.h,0),low:this.safeString(n.l,0),bid:this.safeString(n.b,0),bidVolume:this.safeString(n.b,2),ask:this.safeString(n.a,0),askVolume:this.safeString(n.a,2),vwap:d,open:this.safeString(n.o,0),close:l,last:l,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:c,quoteVolume:h,info:n});this.tickers[r]=u,e.resolve(u,a)}handleTrades(e,t,s){const i=this.safeString(t,3),r=this.safeString(t,2),o=this.safeValue(this.options.marketsByWsName,i),n=o.symbol,d=this.getMessageHash(r,void 0,n);let h=this.safeValue(this.trades,n);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e),this.trades[n]=h}const c=this.safeValue(t,1,[]),l=this.parseTrades(c,o);for(let e=0;e<l.length;e++)h.append(l[e]);e.resolve(h,d)}handleOHLCV(e,t,s){const i=this.safeValue(s,"subscription",{}),r=this.safeInteger(i,"interval"),o=this.safeString(i,"name"),n=this.safeString(t,3),d=this.safeValue(this.options.marketsByWsName,n).symbol,h=this.findTimeframe(r),c=this.parseTimeframe(h);if(void 0!==h){const s=this.safeValue(t,1),i=o+":"+h+":"+n;let r=this.safeFloat(s,1);r-=c;const l=[this.parseToInt(1e3*r),this.safeFloat(s,2),this.safeFloat(s,3),this.safeFloat(s,4),this.safeFloat(s,5),this.safeFloat(s,7)];this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let u=this.safeValue(this.ohlcvs[d],h);if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new a.TG(e),this.ohlcvs[d][h]=u}u.append(l),e.resolve(u,i)}}requestId(){const e=this.sum(this.safeInteger(this.options,"reqid",0),1);return this.options.reqid=e,e}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(t),r=this.safeValue(i.info,"wsname"),a=e+":"+r,o=this.urls.api.ws.public,n={event:"subscribe",reqid:this.requestId(),pair:[r],subscription:{name:e}},d=this.deepExtend(n,s);return await this.watch(o,a,d,a)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=await this.watchMultiHelper("ticker","ticker",e,void 0,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.tickers,"symbol",e)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){const r=await this.watchMultiHelper("trade","trade",e,void 0,i);if(this.newUpdates){const e=this.safeList(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){const i={};if(void 0!==t){if(!this.inArray(t,[10,25,100,500,1e3]))throw new r.NotSupported(this.id+" watchOrderBook accepts limit values of 10, 25, 100, 500 and 1000 only");i.subscription={depth:t}}return(await this.watchMultiHelper("orderbook","book",e,{limit:t},this.extend(i,s))).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a="ohlc",o=this.market(e);e=o.symbol;const n=this.safeValue(o.info,"wsname"),d=a+":"+t+":"+n,h=this.urls.api.ws.public,c={event:"subscribe",reqid:this.requestId(),pair:[n],subscription:{name:a,interval:this.safeValue(this.timeframes,t,t)}},l=this.deepExtend(c,r),u=await this.watch(h,d,l,d);return this.newUpdates&&(i=u.getLimit(e,i)),this.filterBySinceLimit(u,s,i,0,!0)}async loadMarkets(e=!1,t={}){const s=await super.loadMarkets(e,t);let i=this.safeValue(this.options,"marketsByWsName");if(void 0===i||e){i={};for(let e=0;e<this.symbols.length;e++){const t=this.symbols[e],s=this.markets[t];if(s.darkpool){const e=this.safeValue(s,"info",{}),t=this.safeString(e,"altname");i[t.slice(0,3)+"/"+t.slice(3)]=s}else{const e=this.safeValue(s,"info",{});i[this.safeString(e,"wsname")]=s}}this.options.marketsByWsName=i}return s}async watchHeartbeat(e={}){await this.loadMarkets();const t=this.urls.api.ws.public;return await this.watch(t,"heartbeat")}handleHeartbeat(e,t){const s=this.safeString(t,"event");e.resolve(t,s)}handleOrderBook(e,t,s){const i=t.length,a=t[i-1],o=t[i-2].split("-"),n=this.safeInteger(o,1,10),d=this.safeValue(this.options.marketsByWsName,a).symbol;let h;const c=this.getMessageHash("orderbook",void 0,d);if("as"in t[1]){this.orderbooks[d]=this.orderBook({},n);const s=this.orderbooks[d],i={as:"asks",bs:"bids"},r=Object.keys(i);for(let e=0;e<r.length;e++){const a=r[e],o=s[i[a]],n=this.safeValue(t[1],a,[]);h=this.customHandleDeltas(o,n,h)}s.symbol=d,s.timestamp=h,s.datetime=this.iso8601(h),e.resolve(s,c)}else{const s=this.orderbooks[d];let a,o,n;5===i?(a=this.safeValue(t[1],"a",[]),o=this.safeValue(t[2],"b",[]),n=this.safeInteger(t[1],"c"),n=this.safeInteger(t[2],"c",n)):(n=this.safeInteger(t[1],"c"),"a"in t[1]?a=this.safeValue(t[1],"a",[]):o=this.safeValue(t[1],"b",[]));const l=s.asks,u=s.bids;let p;void 0!==a&&(h=this.customHandleDeltas(l,a,h),p=this.safeValue(a,0)),void 0!==o&&(h=this.customHandleDeltas(u,o,h),p=this.safeValue(o,0)),s.limit();if(this.handleOption("watchOrderBook","checksum",!0)){const t=this.safeString(p,0),s=this.safeString(p,1),i=t.split("."),a=s.split("."),o=i[1].length-0,h=a[1].length-0,f=[];if(void 0!==n){for(let e=0;e<10;e++){const t=this.formatNumber(l[e][0],o)+this.formatNumber(l[e][1],h);f.push(t)}for(let e=0;e<10;e++){const t=this.formatNumber(u[e][0],o)+this.formatNumber(u[e][1],h);f.push(t)}}const m=f.join("");if(this.crc32(m,!1)!==n){const t=new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(d));return delete e.subscriptions[c],delete this.orderbooks[d],void e.reject(t,c)}}s.symbol=d,s.timestamp=h,s.datetime=this.iso8601(h),e.resolve(s,c)}}formatNumber(e,t){const s=this.numberToString(e).split("."),i=this.safeString(s,0)+this.safeString(s,1,"").padEnd(t,"0");let r=0;for(;"0"===i[r];)r+=1;return r>0?i.slice(r):i}customHandleDeltas(e,t,s=void 0){for(let i=0;i<t.length;i++){const r=t[i],a=this.parseNumber(r[0]),o=this.parseNumber(r[1]),n=s||0;s=Math.max(n,this.parseToInt(1e3*parseFloat(r[2]))),e.store(a,o)}return s}handleSystemStatus(e,t){return t}async authenticate(e={}){const t=this.urls.api.ws.private,s=this.client(t),i="authenticated";let r=this.safeValue(s.subscriptions,i);if(void 0===r){const t=await this.privatePostGetWebSocketsToken(e);r=this.safeValue(t,"result"),s.subscriptions[i]=r}return this.safeString(r,"token")}async watchPrivate(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a=await this.authenticate(),o=e;let n=e;void 0!==t&&(n+=":"+(t=this.symbol(t)));const d=this.urls.api.ws.private,h={event:"subscribe",reqid:this.requestId(),subscription:{name:e,token:a}},c=this.deepExtend(h,r),l=await this.watch(d,n,c,o);return this.newUpdates&&(i=l.getLimit(t,i)),this.filterBySymbolSinceLimit(l,t,s,i)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("ownTrades",e,t,s,i)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.I3(e)}const t=this.myTrades,s={};for(let e=0;e<i.length;e++){const r=this.safeValue(i,e,{}),a=Object.keys(r);for(let e=0;e<a.length;e++){const i=a[e],o=r[i],n=this.parseWsTrade(this.extend({id:i},o));t.append(n);s[n.symbol]=!0}}const r="ownTrades";e.resolve(this.myTrades,r);const o=Object.keys(s);for(let t=0;t<o.length;t++){const s=r+":"+o[t];e.resolve(this.myTrades,s)}}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"pair");let i;t=this.safeValue(this.options.marketsByWsName,s,t);const r=this.safeString(e,"ordertxid"),a=this.safeString2(e,"id","postxid"),o=this.safeTimestamp(e,"time"),n=this.safeString(e,"type"),d=this.safeString(e,"ordertype"),h=this.safeFloat(e,"price"),c=this.safeFloat(e,"vol");let l,u;if("fee"in e){let s;void 0!==t&&(s=t.quote),u={cost:this.safeFloat(e,"fee"),currency:s}}return void 0!==t&&(i=t.symbol),void 0!==h&&void 0!==c&&(l=h*c),{id:a,order:r,info:e,timestamp:o,datetime:this.iso8601(o),symbol:i,type:d,side:n,takerOrMaker:void 0,price:h,amount:c,cost:l,fee:u}}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.watchPrivate("openOrders",e,t,s,i)}handleOrders(e,t,s=void 0){const i=this.safeValue(t,0,[]);if(i.length>0){const t=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(t));const s=this.orders,r={};for(let e=0;e<i.length;e++){const a=this.safeValue(i,e,{}),o=Object.keys(a);for(let e=0;e<o.length;e++){const i=o[e],n=a[i],d=this.parseWsOrder(n);let h;d.id=i;const c=this.safeValue(this.options,"symbolsByOrderId",{});void 0!==d.symbol?(h=d.symbol,c[i]=h,this.options.symbolsByOrderId=c):h=this.safeString(c,i);const l=this.safeValue(s.hashmap,h),u=this.safeValue(l,i);let p=d;if(void 0!==u){const e=this.extend(u.info,p.info);p=this.parseWsOrder(e),p.id=i}if(s.length===t&&void 0===u){const e=s[0];e.id in c&&delete c[e.id]}s.append(p),r[h]=!0}}const o="openOrders";e.resolve(this.orders,o);const n=Object.keys(r);for(let t=0;t<n.length;t++){const s=o+":"+n[t];e.resolve(this.orders,s)}}}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"descr",{}),i=this.safeString(s,"order");let r,a,n,d,h,c;if(void 0!==i){const e=i.split(" ");r=this.safeString(e,0),h=this.safeString(e,1),n=this.safeString(e,2),a=this.safeString(e,4),d=this.safeString(e,5)}r=this.safeString(s,"type",r),a=this.safeString(s,"ordertype",a),n=this.safeString(s,"pair",n),t=this.safeValue(this.options.marketsByWsName,n,t);const l=this.safeTimestamp(e,"opentm");h=this.safeString(e,"vol",h);const u=this.safeString(e,"vol_exec");let p;const f=this.safeString(e,"cost");d=this.safeString(s,"price",d),(void 0===d||o.Y.stringEq(d,"0.0"))&&(d=this.safeString(s,"price2")),(void 0===d||o.Y.stringEq(d,"0.0"))&&(d=this.safeString(e,"price",d));const m=this.safeString2(e,"avg_price","price");if(void 0!==t&&(c=t.symbol,"fee"in e)){const s=e.oflags;p={cost:this.safeString(e,"fee"),rate:void 0},s.indexOf("fciq")>=0?p.currency=t.quote:s.indexOf("fcib")>=0&&(p.currency=t.base)}const g=this.parseOrderStatus(this.safeString(e,"status"));let v=this.safeString(e,"id");if(void 0===v){const t=this.safeValue(e,"txid");v=this.safeString(t,0)}const y=this.safeString(e,"userref"),w=this.safeValue(e,"trades");let b;void 0!==w&&(b=this.parseTrades(w,t,void 0,void 0,{order:v}));const S=this.safeNumber(e,"stopprice");return this.safeOrder({id:v,clientOrderId:y,info:e,timestamp:l,datetime:this.iso8601(l),lastTradeTimestamp:void 0,status:g,symbol:c,type:a,timeInForce:void 0,postOnly:void 0,side:r,price:d,stopPrice:S,triggerPrice:S,cost:f,amount:h,filled:u,average:m,remaining:void 0,fee:p,trades:b})}async watchMultiHelper(e,t,s=void 0,i=void 0,r={}){await this.loadMarkets(),s=this.marketSymbols(s,void 0,!1,!0,!1);const a=[];for(let t=0;t<s.length;t++)a.push(this.getMessageHash(e,void 0,this.symbol(s[t])));const o=this.marketsForSymbols(s),n=[];for(let e=0;e<o.length;e++){const t=this.safeString(o[e].info,"wsname");n.push(t)}const d={event:"subscribe",reqid:this.requestId(),pair:n,subscription:{name:t}},h=this.urls.api.ws.public;return await this.watchMultiple(h,a,this.deepExtend(d,r),a,i)}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate(),s="balances",i=this.urls.api.ws.privateV2,r={method:"subscribe",req_id:this.requestId(),params:{channel:"balances",token:t}},a=this.deepExtend(r,e);return await this.watch(i,s,a,s)}handleBalance(e,t){const s=this.safeList(t,"data",[]),i={info:t};for(let e=0;e<s.length;e++){const t=this.safeString(s[e],"asset"),r=this.safeCurrencyCode(t),a=this.account(),o=this.safeString(s[e],"balance");a.total=o,i[r]=a}const r="spot",a=this.safeBalance(i),o=this.safeValue(this.balance,r,{}),n=this.deepExtend(o,a);this.balance[r]=this.safeBalance(n);const d=this.safeString(t,"channel");e.resolve(this.balance[r],d)}getMessageHash(e,t=void 0,s=void 0){let i=e;return i+=void 0!==s?"@"+s:"s",void 0!==t&&(i+="#"+t),i}handleSubscriptionStatus(e,t){const s=this.safeString(t,"channelID");void 0!==s&&(e.subscriptions[s]=t)}handleErrorMessage(e,t){const s=this.safeString(t,"errorMessage");if(void 0!==s){const i=this.safeValue(t,"reqid");if(void 0!==i){const t=this.exceptions.ws.broad,a=this.findBroadlyMatchedKey(t,s);let o;return o=void 0===a?new r.ExchangeError(s):new t[a](s),e.reject(o,i),!1}}return!0}handleMessage(e,t){if(Array.isArray(t)){const s=this.safeString(t,0),i=this.safeValue(e.subscriptions,s,{}),r=this.safeValue(i,"subscription",{}),a=t.length,o=this.safeString(t,a-2),n=this.safeString(r,"name"),d={book:this.handleOrderBook,ohlc:this.handleOHLCV,ticker:this.handleTicker,trade:this.handleTrades,openOrders:this.handleOrders,ownTrades:this.handleMyTrades},h=this.safeValue2(d,n,o);void 0!==h&&h.call(this,e,t,i)}else{const s=this.safeString(t,"channel");if(void 0!==s){const i={balances:this.handleBalance},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}if(this.handleErrorMessage(e,t)){const s=this.safeString(t,"event"),i={heartbeat:this.handleHeartbeat,systemStatus:this.handleSystemStatus,subscriptionStatus:this.handleSubscriptionStatus,addOrderStatus:this.handleCreateEditOrder,editOrderStatus:this.handleCreateEditOrder,cancelOrderStatus:this.handleCancelOrder,cancelAllStatus:this.handleCancelAllOrders},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}}}},6396:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(2300),r=s(2079),a=s(2931),o=s(5147),n=s(4852),d=s(7481);class h extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!1,cancelOrdersWs:!1,cancelOrderWs:!1,createOrderWs:!1,editOrderWs:!1,fetchBalanceWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,fetchTradesWs:!1,watchOHLCV:!1,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchTicker:!0,watchTickers:!0,watchBidsAsks:!0,watchTrades:!0,watchTradesForSymbols:!0,watchBalance:!0,watchOrders:!0,watchMyTrades:!0,watchPositions:!0},urls:{api:{ws:"wss://futures.kraken.com/ws/v1"},test:{ws:"wss://demo-futures.kraken.com/ws/v1"}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,connectionLimit:100,requestLimit:100,fetchBalance:{type:void 0}},streaming:{keepAlive:3e4}})}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="challenge",i=this.client(t),r=i.future(s);if(void 0===this.safeValue(i.subscriptions,s)){const i={event:"challenge",api_key:this.apiKey},r=this.extend(i,e);this.watch(t,s,r,s)}return await r}async watchOrderBookForSymbols(e,t=void 0,s={}){return(await this.watchMultiHelper("orderbook","book",e,{limit:t},s)).limit()}async subscribePublic(e,t,s={}){await this.loadMarkets();const i=this.urls.api.ws,r={event:"subscribe",feed:e},a=[];let o=e;void 0===t&&(t=[]);for(let e=0;e<t.length;e++){const s=t[e];a.push(this.marketId(s))}if(1===t.length){o=o+":"+this.market(a[0]).symbol}r.product_ids=a;const n=this.extend(r,s);return await this.watch(i,o,n,o)}async subscribePrivate(e,t,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws,r={event:"subscribe",feed:e,api_key:this.apiKey,original_challenge:this.options.challenge,signed_challenge:this.options.signedChallenge},a=this.extend(r,s);return await this.watch(i,t,a,t)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s=await this.watchMultiHelper("ticker","ticker",e,void 0,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.tickers,"symbol",e)}async watchBidsAsks(e=void 0,t={}){const s=await this.watchMultiHelper("bidask","ticker_lite",e,void 0,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.bidsasks,"symbol",e)}async watchTrades(e=void 0,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){const r=await this.watchMultiHelper("trade","trade",e,void 0,i);if(this.newUpdates){const e=this.safeList(r,0),t=this.safeString(e,"symbol");s=r.getLimit(t,s)}return this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="";e=this.marketSymbols(e),this.isEmpty(e)||(r="::"+e.join(",")),r="positions"+r;const a=await this.subscribePrivate("open_positions",r,i);return this.newUpdates?a:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}handlePositions(e,t){void 0===this.positions&&(this.positions=new a.Pt);const s=this.positions,i=this.safeValue(t,"positions",[]),r=[];for(let e=0;e<i.length;e++){const a=i[e],o=this.parseWsPosition(a),n=this.safeInteger(t,"timestamp");o.timestamp=n,o.datetime=this.iso8601(n),r.push(o),s.append(o)}const o=this.findMessageHashes(e,"positions::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),a=this.filterByArray(r,"symbol",i,!1);this.isEmpty(a)||e.resolve(a,s)}e.resolve(r,"positions")}parseWsPosition(e,t=void 0){const s=this.safeString(e,"instrument"),i=this.safeNumber(e,"balance"),r=i>0?"long":"short";return this.safePosition({info:e,id:void 0,symbol:this.safeSymbol(s),notional:void 0,marginMode:void 0,liquidationPrice:this.safeNumber(e,"liquidation_threshold"),entryPrice:this.safeNumber(e,"entry_price"),unrealizedPnl:this.safeNumber(e,"pnl"),percentage:this.safeNumber(e,"return_on_equity"),contracts:this.parseNumber(o.Y.stringAbs(this.numberToString(i))),contractSize:void 0,markPrice:this.safeNumber(e,"mark_price"),side:r,hedged:"both",timestamp:void 0,datetime:void 0,maintenanceMargin:this.safeNumber(e,"maintenance_margin"),maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:this.safeNumber(e,"initial_margin"),initialMarginPercentage:void 0,leverage:void 0,marginRatio:void 0})}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="orders";if(void 0!==e){r+=":"+this.market(e).symbol}const a=await this.subscribePrivate("open_orders",r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="myTrades";if(void 0!==e){r+=":"+this.market(e).symbol}const a=await this.subscribePrivate("fills",r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchBalance(e={}){await this.loadMarkets();const t="balances";let s,i=t;if([s,e]=this.handleOptionAndParams(e,"watchBalance","account"),void 0!==s){if("futures"!==s&&"flex_futures"!==s)throw new r.ArgumentsRequired(this.id+" watchBalance account must be either 'futures' or 'flex_futures'");i+=":"+s}return await this.subscribePrivate(t,i,e)}handleTrade(e,t){const s=this.safeString(t,"feed"),i=this.safeString(t,"product_id");if(void 0!==i){const r=this.market(i).symbol,o=this.getMessageHash("trade",void 0,r);if(void 0===this.safeList(this.trades,r)){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.trades[r]=new a.I3(e)}const n=this.trades[r];if("trade_snapshot"===s){const e=this.safeList(t,"trades",[]),s=e.length;for(let t=0;t<s;t++){const i=e[s-1-t],r=this.parseWsTrade(i);n.append(r)}}else{const e=this.parseWsTrade(t);n.append(e)}e.resolve(n,o)}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"product_id");t=this.safeMarket(s,t);const i=this.safeInteger(e,"time");return this.safeTrade({info:e,id:this.safeString(e,"uid"),symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),order:void 0,type:this.safeString(e,"type"),side:this.safeString(e,"side"),takerOrMaker:"taker",price:this.safeString(e,"price"),amount:this.safeString(e,"qty"),cost:void 0,fee:{rate:void 0,cost:void 0,currency:void 0}},t)}parseWsOrderTrade(e,t=void 0){const s=this.safeInteger(e,"tradeTime"),i=this.safeString(e,"symbol");return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),symbol:this.safeSymbol(i,t),timestamp:s,datetime:this.iso8601(s),order:this.safeString(e,"orderId"),type:this.safeStringLower(e,"type"),side:this.safeString(e,"side"),takerOrMaker:this.safeString(e,"matchRole"),price:this.safeString(e,"price"),amount:this.safeString(e,"tradeAmount"),cost:void 0,fee:{rate:void 0,cost:this.safeString(e,"tradeFee"),currency:this.safeString(e,"feeCurrency")}},t)}handleOrder(e,t){let s=this.orders;if(void 0===s){const e=this.safeInteger(this.options,"ordersLimit");s=new a.Pt(e),this.orders=s}const i=this.safeValue(t,"order");if(void 0!==i){const r=this.safeString(i,"instrument"),a="orders",n=this.safeSymbol(r),d=this.safeString(i,"order_id"),h=this.safeValue(s.hashmap,n,{}),c=this.safeValue(h,d),l=this.safeString(t,"reason");if(void 0===c||"edited_by_user"===l){const t=this.parseWsOrder(i);s.append(t),e.resolve(s,a),e.resolve(s,a+":"+n)}else{const t=this.parseWsTrade(i);void 0===c.trades&&(c.trades=[]),c.trades.push(t),c.lastTradeTimestamp=t.timestamp;let r="0",d="0";const h=c.trades;for(let e=0;e<h.length;e++){const t=h[e];r=o.Y.stringAdd(r,this.numberToString(t.cost)),d=o.Y.stringAdd(d,this.numberToString(t.amount))}if(o.Y.stringGt(d,"0")&&(c.average=o.Y.stringDiv(r,d)),c.cost=r,void 0!==c.filled){const e=this.numberToString(c.filled);c.filled=o.Y.stringAdd(e,this.numberToString(t.amount)),void 0!==c.amount&&(c.remaining=o.Y.stringSub(this.numberToString(c.amount),e))}if(void 0===c.fee&&(c.fee={rate:void 0,cost:"0",currency:this.numberToString(t.fee.currency)}),void 0!==c.fee.cost&&void 0!==t.fee.cost){const e=this.numberToString(c.fee.cost),s=this.numberToString(t.fee.cost);c.fee.cost=o.Y.stringAdd(e,s)}s.append(this.safeOrder(c)),e.resolve(s,a+":"+n),e.resolve(s,a)}}else{if(this.safeValue(t,"is_cancel"))for(let i=0;i<s.length;i++){const r=s[i];if(r.id===t.order_id){s[i]=this.extend(r,{status:"canceled"}),e.resolve(s,"orders"),e.resolve(s,"orders:"+r.symbol);break}}}return t}handleOrderSnapshot(e,t){const s=this.safeValue(t,"orders",[]),i=this.safeInteger(this.options,"ordersLimit");this.orders=new a.Pt(i);const r={},o=this.orders;for(let e=0;e<s.length;e++){const t=s[e],i=this.parseWsOrder(t);r[i.symbol]=!0,o.append(i)}if(this.orders.length>0){e.resolve(this.orders,"orders");const t=Object.keys(r);for(let s=0;s<t.length;s++){const i="orders:"+t[s];e.resolve(this.orders,i)}}}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"is_cancel");let i,r=e;void 0!==s&&(r=this.safeValue(e,"order"),!0===s&&(i="cancelled"));const a=this.safeString(r,"instrument"),o=this.safeString(r,"time"),n=this.safeInteger(r,"direction");return this.safeOrder({info:e,symbol:this.safeSymbol(a,t),id:this.safeString(r,"order_id"),clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,type:this.safeString(r,"type"),timeInForce:void 0,postOnly:void 0,side:0===n?"buy":"sell",price:this.safeString(r,"limit_price"),stopPrice:this.safeString(r,"stop_price"),triggerPrice:this.safeString(r,"stop_price"),amount:this.safeString(r,"qty"),cost:void 0,average:void 0,filled:this.safeString(r,"filled"),remaining:void 0,status:i,fee:{rate:void 0,cost:void 0,currency:void 0},trades:void 0})}handleTicker(e,t){if(void 0!==this.safeString(t,"product_id")){const s=this.parseWsTicker(t),i=s.symbol;this.tickers[i]=s;const r=this.getMessageHash("ticker",void 0,i);e.resolve(s,r)}}handleBidAsk(e,t){if(void 0!==this.safeString(t,"product_id")){const s=this.parseWsTicker(t),i=s.symbol;this.bidsasks[i]=s;const r=this.getMessageHash("bidask",void 0,i);e.resolve(s,r)}}parseWsTicker(e,t=void 0){const s=this.safeString(e,"product_id"),i=(t=this.safeMarket(s,t)).symbol,r=this.parse8601(this.safeString(e,"lastTime")),a=this.safeString(e,"last");return this.safeTicker({info:e,symbol:i,timestamp:r,datetime:this.iso8601(r),high:void 0,low:void 0,bid:this.safeString(e,"bid"),bidVolume:this.safeString(e,"bid_size"),ask:this.safeString(e,"ask"),askVolume:this.safeString(e,"ask_size"),vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:this.safeString(e,"change"),percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"volumeQuote")})}handleOrderBookSnapshot(e,t){const s=this.safeString(t,"product_id"),i=this.safeMarket(s).symbol,r=this.getMessageHash("orderbook",void 0,i),a=this.safeDict(e.subscriptions,r,{}),o=this.safeInteger(a,"limit"),n=this.safeInteger(t,"timestamp");this.orderbooks[i]=this.orderBook({},o);const d=this.orderbooks[i],h=this.safeList(t,"bids"),c=this.safeList(t,"asks");for(let e=0;e<h.length;e++){const t=h[e],s=this.safeNumber(t,"price"),i=this.safeNumber(t,"qty");d.bids.store(s,i)}for(let e=0;e<c.length;e++){const t=c[e],s=this.safeNumber(t,"price"),i=this.safeNumber(t,"qty");d.asks.store(s,i)}d.timestamp=n,d.datetime=this.iso8601(n),d.symbol=i,e.resolve(d,r)}handleOrderBook(e,t){const s=this.safeString(t,"product_id"),i=this.safeMarket(s).symbol,r=this.getMessageHash("orderbook",void 0,i),a=this.orderbooks[i],o=this.safeString(t,"side"),n=this.safeNumber(t,"price"),d=this.safeNumber(t,"qty"),h=this.safeInteger(t,"timestamp");if("sell"===o){a.asks.store(n,d)}else{a.bids.store(n,d)}a.timestamp=h,a.datetime=this.iso8601(h),e.resolve(a,r)}handleBalance(e,t){const s=this.safeValue(t,"holding"),i=this.safeValue(t,"futures"),r=this.safeValue(t,"flex_futures"),a="balances",o=this.safeInteger(t,"timestamp");if(void 0!==s){const i=Object.keys(s),r={info:t,timestamp:o,datetime:this.iso8601(o)};for(let e=0;e<i.length;e++){const t=i[e],a=this.safeCurrencyCode(t),o=this.account();o.total=this.safeString(s,t),r[a]=o}this.balance.cash=r,this.balance.cash=this.safeBalance(this.balance.cash),e.resolve(r,a)}if(void 0!==i){const s=Object.keys(i),r={info:t,timestamp:o,datetime:this.iso8601(o)};for(let e=0;e<s.length;e++){const t=s[e],a=this.safeSymbol(t),o=this.account(),n=this.safeValue(i,t),d=this.safeString(n,"unit"),h=this.safeCurrencyCode(d);o.free=this.safeString(n,"available"),o.used=this.safeString(n,"initial_margin"),o.total=this.safeString(n,"balance"),r[a]={},r[a][h]=o}this.balance.margin=r,this.balance.margin=this.safeBalance(this.balance.margin),e.resolve(this.balance.margin,a+"futures")}if(void 0!==r){const s=this.safeValue(r,"currencies",{}),i=Object.keys(s),n={info:t,timestamp:o,datetime:this.iso8601(o)};for(let e=0;e<i.length;e++){const t=i[e],r=this.safeValue(s,t),a=this.safeCurrencyCode(t),o=this.account();o.free=this.safeString(r,"available"),o.used=this.safeString(r,"collateral_value"),o.total=this.safeString(r,"quantity"),n[a]=o}this.balance.flex=n,this.balance.flex=this.safeBalance(this.balance.flex),e.resolve(this.balance.flex,a+"flex_futures")}e.resolve(this.balance,a)}handleMyTrades(e,t){const s=this.safeValue(t,"fills",[]);let i=this.myTrades;if(void 0===i){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new a.Pt(e),this.myTrades=i}const r={};for(let e=0;e<s.length;e++){const t=s[e],a=this.parseWsMyTrade(t);r[a.symbol]=!0,i.append(a)}const o=Object.keys(r);for(let t=0;t<o.length;t++){const s="myTrades:"+o[t];e.resolve(i,s)}e.resolve(i,"myTrades")}parseWsMyTrade(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeString(e,"instrument");t=this.safeMarket(i,t);const r=this.safeValue(e,"buy"),a=this.safeString(e,"fee_currency");return this.safeTrade({info:e,id:this.safeString(e,"fill_id"),timestamp:s,datetime:this.iso8601(s),symbol:this.safeString(t,"symbol"),order:this.safeString(e,"order_id"),type:this.safeString(e,"type"),side:r?"buy":"sell",takerOrMaker:this.safeString(e,"fill_type"),price:this.safeString(e,"price"),amount:this.safeString(e,"qty"),cost:void 0,fee:{currency:this.safeCurrencyCode(a),cost:this.safeString(e,"fee_paid"),rate:void 0}})}async watchMultiHelper(e,t,s=void 0,i=void 0,r={}){await this.loadMarkets(),s=this.marketSymbols(s,void 0,!1,!0,!1);const a=[];for(let t=0;t<s.length;t++)a.push(this.getMessageHash(e,void 0,this.symbol(s[t])));const o={event:"subscribe",feed:t,product_ids:this.marketIds(s)},n=this.urls.api.ws;return await this.watchMultiple(n,a,this.extend(o,r),a,i)}getMessageHash(e,t=void 0,s=void 0){let i=e;return i+=void 0!==s?":"+s:"s",void 0!==t&&(i+="#"+t),i}handleErrorMessage(e,t){const s=this.safeString(t,"message");try{throw new r.ExchangeError(this.id+" "+s)}catch(t){e.reject(t)}}handleMessage(e,t){const s=this.safeString(t,"event");if("challenge"===s)this.handleAuthenticate(e,t);else if("alert"===s)this.handleErrorMessage(e,t);else if("pong"===s)e.lastPong=this.milliseconds();else if(void 0===s){const s=this.safeString(t,"feed"),i={ticker:this.handleTicker,ticker_lite:this.handleBidAsk,trade:this.handleTrade,trade_snapshot:this.handleTrade,book:this.handleOrderBook,book_snapshot:this.handleOrderBookSnapshot,open_orders_verbose:this.handleOrder,open_orders_verbose_snapshot:this.handleOrderSnapshot,fills:this.handleMyTrades,fills_snapshot:this.handleMyTrades,open_orders:this.handleOrder,open_orders_snapshot:this.handleOrderSnapshot,balances:this.handleBalance,balances_snapshot:this.handleBalance,open_positions:this.handlePositions},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}handleAuthenticate(e,t){const s="challenge";if("error"!==this.safeValue(t,"event")){const i=this.safeValue(t,"message"),r=this.hash(this.encode(i),n.s,"binary"),a=this.base64ToBinary(this.secret),o=this.hmac(r,a,d.Zf,"base64");this.options.challenge=i,this.options.signedChallenge=o;this.safeValue(e.futures,s).resolve(!0)}else{const i=new r.AuthenticationError(this.id+" "+this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}return t}}},4965:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(1397),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,createOrderWs:!1,editOrderWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!1,cancelOrdersWs:!1,cancelAllOrdersWs:!1,watchBidsAsks:!0,watchOrderBook:!0,watchOrders:!0,watchMyTrades:!0,watchTickers:!0,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBookForSymbols:!0,watchBalance:!0,watchOHLCV:!0},options:{tradesLimit:1e3,watchTicker:{name:"market/snapshot"},watchOrderBook:{snapshotDelay:5,snapshotMaxRetries:3,method:"/market/level2"},watchMyTrades:{method:"/spotMarket/tradeOrders"}},streaming:{ping:this.ping}})}async negotiate(e,t={}){const s=e?"private":"public",i=this.safeValue(this.options,"urls",{}),r=this.safeValue(i,s);if(void 0!==r)return await r;i[s]=this.spawn(this.negotiateHelper,e,t),this.options.urls=i;const a=i[s];return await a}async negotiateHelper(e,t={}){let s;const i=e?"private":"public";try{s=e?await this.privatePostBulletPrivate(t):await this.publicPostBulletPublic(t);const r=this.safeValue(s,"data",{}),a=this.safeValue(r,"instanceServers",[]),o=this.safeValue(a,0),n=this.safeInteger(o,"pingInterval"),d=this.safeString(o,"endpoint"),h=this.safeString(r,"token"),c=d+"?"+this.urlencode({token:h,privateChannel:e,connectId:i});return this.client(c).keepAlive=n,c}catch(e){this.safeValue(this.options.urls,i).reject(e),delete this.options.urls[i]}}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i={},r=void 0){const a=this.requestId().toString(),o={id:a,type:"subscribe",topic:s,response:!0},n=this.extend(o,i),d=this.client(e);return s in d.subscriptions||(d.subscriptions[a]=s),await this.watch(e,t,n,s,r)}async subscribeMultiple(e,t,s,i,r={},a=void 0){const o=this.requestId().toString(),n={id:o,type:"subscribe",topic:s,response:!0},d=this.extend(n,r),h=this.client(e);for(let e=0;e<i.length;e++){const t=i[e];t in h.subscriptions||(h.subscriptions[o]=t)}return await this.watchMultiple(e,t,d,i,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=await this.negotiate(!1),[r,a]=this.handleOptionAndParams(t,"watchTicker","method","/market/snapshot"),o=r+":"+s.id,n="ticker:"+e;return await this.subscribe(i,n,o,a)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);let s;[s,t]=this.handleOptionAndParams(t,"watchTickers","method","/market/ticker");const i=[],r=[];if(void 0!==e)for(let t=0;t<e.length;t++){const a=e[t];i.push("ticker:"+a);const o=this.market(a);r.push(s+":"+o.id)}const a=await this.negotiate(!1);let o;if(void 0===e){const e=s+":all";if(o=await this.subscribe(a,"tickers",e,t),this.newUpdates)return o}else{const n=s+":"+this.marketIds(e).join(",");if(o=await this.subscribeMultiple(a,i,n,r,t),this.newUpdates){const e={};return e[o.symbol]=o,e}}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeString(t,"topic");let i;if(void 0!==s){const e=s.split(":"),r=this.safeString(e,1);let a;a="all"===r?this.safeString(t,"subject"):r,i=this.safeMarket(a,i,"-")}const r=this.safeValue(t,"data",{}),a=this.safeValue(r,"data",r),o=this.parseTicker(a,i),n=o.symbol;this.tickers[n]=o;const d="ticker:"+n;e.resolve(o,d);const h={};h[n]=o,e.resolve(h,"tickers")}async watchBidsAsks(e=void 0,t={}){const s=await this.watchMultiHelper("watchBidsAsks","/spotMarket/level1:",e,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.bidsasks,"symbol",e)}async watchMultiHelper(e,t,s=void 0,i={}){await this.loadMarkets();if((s=this.marketSymbols(s,void 0,!1,!0,!1)).length>100)throw new r.ArgumentsRequired(this.id+" "+e+"() accepts a maximum of 100 symbols");const a=[];for(let e=0;e<s.length;e++){const t=s[e],i=this.market(t);a.push("bidask@"+i.symbol)}const o=await this.negotiate(!1),n=this.marketIds(s).join(","),d={id:this.requestId().toString(),type:"subscribe",topic:t+n,response:!0},h=this.extend(d,i);return await this.watchMultiple(o,a,h,a)}handleBidAsk(e,t){const s=this.parseWsBidAsk(t),i=s.symbol;this.bidsasks[i]=s;const r="bidask@"+i;e.resolve(s,r)}parseWsBidAsk(e,t=void 0){const s=this.safeString(e,"topic").split(":")[1];t=this.safeMarket(s,t);const i=this.safeString(t,"symbol"),r=this.safeDict(e,"data",{}),a=this.safeList(r,"asks",[]),o=this.safeList(r,"bids",[]),n=this.safeInteger(r,"timestamp");return this.safeTicker({symbol:i,timestamp:n,datetime:this.iso8601(n),ask:this.safeNumber(a,0),askVolume:this.safeNumber(a,1),bid:this.safeNumber(o,0),bidVolume:this.safeNumber(o,1),info:e},t)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=await this.negotiate(!1),o=this.market(e);e=o.symbol;const n=this.safeString(this.timeframes,t,t),d="/market/candles:"+o.id+"_"+n,h="candles:"+e+":"+t,c=await this.subscribe(a,h,d,r);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"symbol"),r=this.safeValue(s,"candles",[]),o=this.safeString(t,"topic").split("_"),n=this.safeString(o,1),d=this.findTimeframe(n),h=this.safeMarket(i),c=h.symbol,l="candles:"+c+":"+d;this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let u=this.safeValue(this.ohlcvs[c],d);if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new a.TG(e),this.ohlcvs[c][d]=u}const p=this.parseOHLCV(r,h);u.append(p),e.resolve(u,l)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");await this.loadMarkets(),e=this.marketSymbols(e);const a=this.marketIds(e),o=await this.negotiate(!1),n=[],d=[],h="/market/match:"+a.join(",");for(let t=0;t<e.length;t++){const s=e[t];n.push("trades:"+s);const i=a[t];d.push("/market/match:"+i)}const c=await this.subscribeMultiple(o,n,h,d,i);if(this.newUpdates){const e=this.safeValue(c,0),t=this.safeString(e,"symbol");s=c.getLimit(t,s)}return this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),r=i.symbol,o="trades:"+r;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}n.append(i),e.resolve(n,o)}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchOrderBookForSymbols() requires a non-empty array of symbols");if(void 0!==t&&20!==t&&100!==t&&50!==t&&5!==t)throw new r.ExchangeError(this.id+" watchOrderBook 'limit' argument must be undefined, 5, 20, 50 or 100");await this.loadMarkets(),e=this.marketSymbols(e);const i=this.marketIds(e),a=await this.negotiate(!1);let o;[o,s]=this.handleOptionAndParams(s,"watchOrderBook","method","/market/level2"),5!==t&&50!==t||(o="/spotMarket/level2Depth"+t.toString());const n=o+":"+i.join(","),d=[],h=[];for(let t=0;t<e.length;t++){const s=e[t];d.push("orderbook:"+s);const r=i[t];h.push(o+":"+r)}let c={};"/market/level2"===o&&(c={method:this.handleOrderBookSubscription,symbols:e,limit:t});return(await this.subscribeMultiple(a,d,n,h,s,c)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(t,"subject"),r=this.safeString(t,"topic").split(":"),a=this.safeString(r,1),o=this.safeString(r,0),n=this.safeString(s,"symbol",a),d=this.safeSymbol(n,void 0,"-"),h="orderbook:"+d;if("level2"===i){if(d in this.orderbooks){this.orderbooks[d].reset()}else this.orderbooks[d]=this.orderBook();this.orderbooks[d].symbol=d}else{d in this.orderbooks||(this.orderbooks[d]=this.orderBook());const t=this.orderbooks[d],i=this.safeInteger(t,"nonce"),r=this.safeInteger2(s,"sequenceEnd","timestamp");if(void 0===i){const i=t.cache.length,r=Object.keys(e.subscriptions);let n;for(let t=0;t<r.length;t++){const s=r[t];if(s.indexOf(a)>=0&&s.indexOf(o)>=0){n=e.subscriptions[s];break}}const c=this.safeInteger(n,"limit");return i===this.handleOption("watchOrderBook","snapshotDelay",5)&&this.spawn(this.loadOrderBook,e,h,d,c,{}),void t.cache.push(s)}if(i>=r)return}this.handleDelta(this.orderbooks[d],s),e.resolve(this.orderbooks[d],h)}getCacheIndex(e,t){const s=this.safeValue(t,0),i=this.safeInteger(e,"nonce");if(i<this.safeInteger(s,"sequenceStart")-1)return-1;for(let e=0;e<t.length;e++){const s=t[e],r=this.safeInteger(s,"sequenceStart"),a=this.safeInteger(s,"sequenceEnd");if(i>=r-1&&i<a)return e}return t.length}handleDelta(e,t){const s=this.safeInteger2(t,"time","timestamp");e.nonce=this.safeInteger(t,"sequenceEnd",s),e.timestamp=s,e.datetime=this.iso8601(s);const i=this.safeValue(t,"changes",t),r=this.safeValue(i,"bids",[]),a=this.safeValue(i,"asks",[]),o=e.bids,n=e.asks;this.handleBidAsks(o,r),this.handleBidAsks(n,a)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=this.parseBidAsk(t[s]);e.storeArray(i)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(s,"limit"),r=this.safeValue(s,"symbols");if(void 0===r){const e=this.safeString(s,"symbol");this.orderbooks[e]=this.orderBook({},i)}else for(let e=0;e<r.length;e++){const t=r[e];this.orderbooks[t]=this.orderBook({},i)}}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id");if(!(s in e.subscriptions))return;const i=this.safeString(e.subscriptions,s),r=this.safeValue(e.subscriptions,i);delete e.subscriptions[s];const a=this.safeValue(r,"method");void 0!==a&&a.call(this,e,t,r)}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue2(i,"stop","trigger");i=this.omit(i,["stop","trigger"]);const a=await this.negotiate(!0),o=r?"/spotMarket/advancedOrders":"/spotMarket/tradeOrders";let n="orders";if(void 0!==e){n=n+":"+(e=this.market(e).symbol)}const d=await this.subscribe(a,n,o,this.extend({privateChannel:!0},i));return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrderStatus(e){return this.safeString({open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled",cancel:"canceled",TRIGGERED:"triggered"},e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"type");let i=this.parseWsOrderStatus(s);const r=this.safeInteger2(e,"orderTime","createdAt"),a=this.safeString(e,"symbol");t=this.safeMarket(a,t);const o=this.safeString(e,"stopPrice"),n=this.safeValue(e,"triggerSuccess");return"triggered"===i&&(!0!==n&&void 0!==n)&&(i="canceled"),this.safeOrder({info:e,symbol:t.symbol,id:this.safeString(e,"orderId"),clientOrderId:this.safeString(e,"clientOid"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:this.safeStringLower(e,"orderType"),timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"side"),price:this.safeString2(e,"price","orderPrice"),stopPrice:o,triggerPrice:o,amount:this.safeString(e,"size"),cost:void 0,average:void 0,filled:this.safeString(e,"filledSize"),remaining:void 0,status:i,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data");void 0!==this.safeString(i,"tradeId")&&this.handleMyTrade(e,t);const r=this.parseWsOrder(i),o=this.safeString(r,"symbol"),n=this.safeString(r,"id"),d=void 0!==this.safeValue(r,"triggerPrice");if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e),this.triggerOrders=new a.Pt(e)}const h=d?this.triggerOrders:this.orders,c=this.safeValue(h.hashmap,o,{}),l=this.safeValue(c,n);void 0!==l&&"closed"===l.status&&(r.status="closed"),h.append(r),e.resolve(h,s);const u=s+":"+o;e.resolve(h,u)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.negotiate(!0);let a;[a,i]=this.handleOptionAndParams(i,"watchMyTrades","method","/spotMarket/tradeOrders");let o="myTrades";if(void 0!==e){const t=this.market(e);e=t.symbol,o=o+":"+t.symbol}const n=await this.subscribe(r,o,a,this.extend({privateChannel:!0},i));return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}handleMyTrade(e,t){if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const s=this.safeDict(t,"data"),i=this.parseWsTrade(s);this.myTrades.append(i);const r="myTrades";e.resolve(this.myTrades,r);const o=r+":"+i.symbol;e.resolve(this.myTrades,o)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t,"-")).symbol,r=this.safeString(e,"orderType"),a=this.safeString(e,"side"),o=this.safeString(e,"tradeId");let n=this.safeString(e,"matchPrice"),d=this.safeString(e,"matchSize");void 0===n&&(n=this.safeString(e,"price"),d=this.safeString(e,"size"));const h=this.safeString(e,"orderId"),c=this.safeIntegerProduct2(e,"ts","time",1e-6),l=t.quote,u=this.safeString(e,"feeRate"),p=this.safeString(e,"fee");return this.safeTrade({info:e,timestamp:c,datetime:this.iso8601(c),symbol:i,id:o,order:h,type:r,takerOrMaker:this.safeString(e,"liquidity"),side:a,price:n,amount:d,cost:void 0,fee:{cost:p,rate:u,currency:l}},t)}async watchBalance(e={}){await this.loadMarkets();const t=await this.negotiate(!0);return await this.subscribe(t,"balance","/account/balance",this.extend({privateChannel:!0},e))}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"currency"),r=this.safeString(s,"relationEvent");let a;if(void 0!==r){const e=r.split(".");a=this.safeString(e,0)}const o=this.safeString2(this.options,"watchBalance","defaultType","trade"),n=this.safeValue(this.options,"accountsByType"),d=this.safeString(n,a,"trade");d in this.balance||(this.balance[d]={}),this.balance[d].info=s;const h=this.safeInteger(s,"time");this.balance[d].timestamp=h,this.balance[d].datetime=this.iso8601(h);const c=this.safeCurrencyCode(i),l=this.account();l.free=this.safeString(s,"available"),l.used=this.safeString(s,"hold"),l.total=this.safeString(s,"total"),this.balance[d][c]=l,this.balance[d]=this.safeBalance(this.balance[d]),d===o&&e.resolve(this.balance[d],"balance")}handleSubject(e,t){if("/market/ticker:all"===this.safeString(t,"topic"))return void this.handleTicker(e,t);const s=this.safeString(t,"subject"),i={level1:this.handleBidAsk,level2:this.handleOrderBook,"trade.l2update":this.handleOrderBook,"trade.ticker":this.handleTicker,"trade.snapshot":this.handleTicker,"trade.l3match":this.handleTrade,"trade.candles.update":this.handleOHLCV,"account.balance":this.handleBalance,orderChange:this.handleOrder,stopOrder:this.handleOrder,"/spot/tradeFills":this.handleMyTrade},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){e.lastPong=this.milliseconds()}handleErrorMessage(e,t){const s=this.safeString(t,"data","");if("token is expired"===s){let t="public";e.url.indexOf("connectId=private")>=0&&(t="private"),this.options.urls[t]=void 0}this.handleErrors(void 0,void 0,e.url,void 0,void 0,s,t,void 0,void 0)}handleMessage(e,t){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong,error:this.handleErrorMessage},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}},905:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(6217),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchLiquidations:!1,watchLiquidatinsForSymbols:!1,watchMyLiquidations:void 0,watchMyLiquidationsForSymbols:void 0,watchTicker:!0,watchTickers:!0,watchBidsAsks:!0,watchTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchBalance:!0,watchPosition:!0,watchPositions:!1,watchPositionForSymbols:!1,watchTradesForSymbols:!0,watchOrderBookForSymbols:!0},options:{timeframes:{"1m":"1min","3m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hour","2h":"2hour","4h":"4hour","8h":"8hour","12h":"12hour","1d":"1day","1w":"1week","1M":"1month"},accountsByType:{swap:"future",cross:"margin"},tradesLimit:1e3,watchOrderBook:{snapshotDelay:20,snapshotMaxRetries:3},watchPosition:{fetchPositionSnapshot:!0,awaitPositionSnapshot:!0}},streaming:{ping:this.ping}})}async negotiate(e,t={}){const s=e?"private":"public",i=this.safeValue(this.options,"urls",{}),r=this.safeValue(i,s);if(void 0!==r)return await r;i[s]=this.spawn(this.negotiateHelper,e,t),this.options.urls=i;const a=i[s];return await a}async negotiateHelper(e,t={}){let s;const i=e?"private":"public";try{s=e?await this.futuresPrivatePostBulletPrivate(t):await this.futuresPublicPostBulletPublic(t);const r=this.safeValue(s,"data",{}),a=this.safeValue(r,"instanceServers",[]),o=this.safeValue(a,0),n=this.safeInteger(o,"pingInterval"),d=this.safeString(o,"endpoint"),h=this.safeString(r,"token"),c=d+"?"+this.urlencode({token:h,privateChannel:e,connectId:i});return this.client(c).keepAlive=n,c}catch(e){this.safeValue(this.options.urls,i).reject(e),delete this.options.urls[i]}}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s,i,r={}){const a=this.requestId().toString(),o={id:a,type:"subscribe",topic:s,response:!0},n=this.extend(o,r),d={id:a};return i=void 0===i?d:this.extend(d,i),await this.watch(e,t,n,s,i)}async subscribeMultiple(e,t,s,i,r,a={}){const o={id:this.requestId().toString(),type:"subscribe",topic:s,response:!0};return await this.watchMultiple(e,t,this.extend(o,a),i,r)}async watchTicker(e,t={}){await this.loadMarkets();e=this.market(e).symbol,t.callerMethodName="watchTicker";return(await this.watchTickers([e],t))[e]}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.watchMultiRequest("watchTickers","/contractMarket/ticker:",e,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"symbol"),r=this.safeMarket(i,void 0,"-"),a=this.parseTicker(s,r);this.tickers[r.symbol]=a,e.resolve(a,this.getMessageHash("ticker",r.symbol))}async watchBidsAsks(e=void 0,t={}){const s=await this.watchMultiRequest("watchBidsAsks","/contractMarket/tickerV2:",e,t);if(this.newUpdates){const e={};return e[s.symbol]=s,e}return this.filterByArray(this.bidsasks,"symbol",e)}async watchMultiRequest(e,t,s=void 0,i={}){await this.loadMarkets(),[e,i]=this.handleParamString(i,"callerMethodName",e);const a="watchBidsAsks"===e;if((s=this.marketSymbols(s,void 0,!1,!0,!1)).length>100)throw new r.ArgumentsRequired(this.id+" "+e+"() accepts a maximum of 100 symbols");const o=[];for(let e=0;e<s.length;e++){const t=s[e],i=this.market(t),r=a?"bidask":"ticker";o.push(this.getMessageHash(r,i.symbol))}const n=await this.negotiate(!1),d=this.marketIds(s).join(","),h=this.requestId().toString(),c={id:h,type:"subscribe",topic:t+d,response:!0},l={id:h};return await this.watchMultiple(n,o,this.extend(c,i),o,l)}handleBidAsk(e,t){const s=this.parseWsBidAsk(t),i=s.symbol;this.bidsasks[i]=s,e.resolve(s,this.getMessageHash("bidask",i))}parseWsBidAsk(e,t=void 0){const s=this.safeDict(e,"data",{}),i=this.safeString(s,"symbol");t=this.safeMarket(i,t);const r=this.safeString(t,"symbol"),a=this.safeIntegerProduct(s,"ts",1e-6);return this.safeTicker({symbol:r,timestamp:a,datetime:this.iso8601(a),ask:this.safeNumber(s,"bestAskPrice"),askVolume:this.safeNumber(s,"bestAskSize"),bid:this.safeNumber(s,"bestBidPrice"),bidVolume:this.safeNumber(s,"bestBidSize"),info:e},t)}async watchPosition(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchPosition() requires a symbol argument");await this.loadMarkets();const s=await this.negotiate(!0),i=this.market(e),a="/contract/position:"+i.id,o="position:"+i.symbol,n=this.client(s);this.setPositionCache(n,e);const d=this.handleOption("watchPosition","fetchPositionSnapshot",!0),h=this.handleOption("watchPosition","awaitPositionSnapshot",!0),c=this.getCurrentPosition(e);if(d&&h&&void 0===c){return await n.future("fetchPositionSnapshot:"+e)}return await this.subscribe(s,o,a,void 0,this.extend({privateChannel:!0},t))}getCurrentPosition(e){if(void 0===this.positions)return;const t=this.positions.hashmap,s=this.safeValue(t,e,{}),i=Object.values(s);return this.safeValue(i,0)}setPositionCache(e,t){if(this.handleOption("watchPosition","fetchPositionSnapshot",!1)){const s="fetchPositionSnapshot:"+t;s in e.futures||(e.future(s),this.spawn(this.loadPositionSnapshot,e,s,t))}}async loadPositionSnapshot(e,t,s){const i=await this.fetchPosition(s);this.positions=new a.Pt;const r=this.positions;r.append(i);e.futures[t].resolve(r),e.resolve(i,"position:"+s)}handlePosition(e,t){const s=this.safeString(t,"topic","").split(":"),i=this.safeString(s,1),r=this.safeSymbol(i,void 0,""),a=this.positions,o=this.getCurrentPosition(r),n="position:"+r,d=this.safeValue(t,"data",{}),h=this.parsePosition(d),c=Object.keys(h);for(let e=0;e<c.length;e++){const t=c[e];void 0===h[t]&&delete h[t]}const l=this.extend(o,h);a.append(l),e.resolve(l,n)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");await this.loadMarkets(),e=this.marketSymbols(e);const a=await this.negotiate(!1);e=this.marketSymbols(e);const o=this.marketIds(e),n="/contractMarket/execution:"+o.join(","),d=[],h=[];for(let t=0;t<e.length;t++){const s=e[t],i=o[t];h.push("trades:"+s),d.push("/contractMarket/execution:"+i)}const c=await this.subscribeMultiple(a,h,n,d,void 0,i);if(this.newUpdates){const e=this.safeValue(c,0),t=this.safeString(e,"symbol");s=c.getLimit(t,s)}return this.filterBySinceLimit(c,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.parseTrade(s),r=i.symbol;let o=this.safeValue(this.trades,r);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.I3(e),this.trades[r]=o}o.append(i);const n="trades:"+r;return e.resolve(o,n),t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);const a=await this.negotiate(!1),o=this.marketId(e),n=this.safeDict(this.options,"timeframes"),d="/contractMarket/limitCandle:"+o+"_"+this.safeString(n,t,t),h="ohlcv::"+e+"_"+t,c=await this.subscribe(a,h,d,void 0,r);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"topic").split("_"),i=this.safeString(s,1),r=this.safeDict(t,"data"),o=this.safeDict(this.options,"timeframes"),n=this.findTimeframe(i,o),d=this.safeString(r,"symbol"),h=this.safeSymbol(d),c="ohlcv::"+h+"_"+n,l=this.safeList(r,"candles"),u=[this.safeInteger(l,0),this.safeNumber(l,1),this.safeNumber(l,2),this.safeNumber(l,3),this.safeNumber(l,4),this.safeNumber(l,6)];if(this.ohlcvs[h]=this.safeDict(this.ohlcvs,h,{}),!(n in this.ohlcvs[h])){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[h][n]=new a.TG(e)}const p=this.ohlcvs[h][n];p.append(u),e.resolve(p,c)}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchOrderBookForSymbols() requires a non-empty array of symbols");if(void 0!==t&&20!==t&&100!==t)throw new r.ExchangeError(this.id+" watchOrderBook 'limit' argument must be undefined, 20 or 100");await this.loadMarkets(),e=this.marketSymbols(e);const i=this.marketIds(e),a=await this.negotiate(!1),o="/contractMarket/level2:"+i.join(","),n={limit:t},d=[],h=[];for(let t=0;t<e.length;t++){const s=e[t],r=i[t];h.push("orderbook:"+s),d.push("/contractMarket/level2:"+r)}return(await this.subscribeMultiple(a,h,o,d,n,s)).limit()}handleDelta(e,t){e.nonce=this.safeInteger(t,"sequence");const s=this.safeInteger(t,"timestamp");e.timestamp=s,e.datetime=this.iso8601(s);const i=this.safeValue(t,"change",{}).split(","),r=this.safeNumber(i,0),a=this.safeString(i,1),o=[r,this.safeNumber(i,2)];if("bids"===("buy"===a?"bids":"asks")){e.bids.storeArray(o)}else{e.asks.storeArray(o)}}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data"),i=this.safeString(t,"topic"),r=i.split(":"),a=this.safeString(r,1),o=this.safeSymbol(a,void 0,"-"),n="orderbook:"+o;if(!(o in this.orderbooks)){const t=this.safeDict(e.subscriptions,i,{}),s=this.safeInteger(t,"limit");this.orderbooks[o]=this.orderBook({},s)}const d=this.orderbooks[o],h=this.safeInteger(d,"nonce"),c=this.safeInteger(s,"sequence");if(void 0===h){const t=d.cache.length,r=i.split(":"),a=this.safeString(r,1),h=this.safeString(r,0),c=Object.keys(e.subscriptions);let l;for(let t=0;t<c.length;t++){const s=c[t];if(s.indexOf(a)>=0&&s.indexOf(h)>=0){l=e.subscriptions[s];break}}const u=this.safeInteger(l,"limit");return t===this.handleOption("watchOrderBook","snapshotDelay",5)&&this.spawn(this.loadOrderBook,e,n,o,u,{}),void d.cache.push(s)}h>=c||(this.handleDelta(d,s),e.resolve(d,n))}getCacheIndex(e,t){const s=this.safeValue(t,0),i=this.safeInteger(e,"nonce");if(i<this.safeInteger(s,"sequence")-1)return-1;for(let e=0;e<t.length;e++){const s=t[e];if(i<this.safeInteger(s,"sequence")-1)return e}return t.length}handleSystemStatus(e,t){return t}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.negotiate(!0);let a="orders";if(void 0!==e){a=a+":"+(e=this.market(e).symbol)}const o=await this.subscribe(r,a,"/contractMarket/tradeOrders",void 0,this.extend({privateChannel:!0},i));return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}parseWsOrderStatus(e){return this.safeString({open:"open",filled:"closed",match:"open",update:"open",canceled:"canceled"},e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),r=this.safeStringLower(e,"orderType"),a=this.safeString(e,"price"),o=this.safeString(e,"filledSize"),n=this.safeString(e,"size"),d=this.safeString(e,"type"),h=this.parseWsOrderStatus(d),c=this.safeIntegerProduct(e,"orderTime",1e-6),l=this.safeString(e,"symbol"),u=(t=this.safeMarket(l,t)).symbol,p=this.safeStringLower(e,"side");return this.safeOrder({info:e,symbol:u,id:s,clientOrderId:i,timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,type:r,timeInForce:void 0,postOnly:void 0,side:p,price:a,stopPrice:void 0,amount:n,cost:void 0,average:void 0,filled:o,remaining:void 0,status:h,fee:void 0,trades:void 0},t)}handleOrder(e,t){const s="orders",i=this.safeValue(t,"data"),r=this.parseWsOrder(i),o=this.safeString(r,"symbol"),n=this.safeString(r,"id");if(void 0!==o){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,i=this.safeValue(t.hashmap,o,{}),d=this.safeValue(i,n);if(void 0!==d){const e=this.safeValue(d,"stopPrice");void 0!==e&&(r.stopPrice=e),"closed"===d.status&&(r.status="closed")}t.append(r),e.resolve(this.orders,s);const h=s+":"+o;e.resolve(this.orders,h)}}async watchBalance(e={}){await this.loadMarkets();const t=await this.negotiate(!0),s={method:this.handleBalanceSubscription};return await this.subscribe(t,"balance","/contractAccount/wallet",s,this.extend({privateChannel:!0},e))}handleBalance(e,t){const s=this.safeValue(t,"data",{});this.balance.info=s;const i=this.safeString(s,"currency"),r=this.safeCurrencyCode(i),a=this.account();a.free=this.safeString(s,"availableBalance"),a.used=this.safeString(s,"holdBalance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}handleBalanceSubscription(e,t,s){this.spawn(this.fetchBalanceSnapshot,e,t)}async fetchBalanceSnapshot(e,t){await this.loadMarkets(),this.checkRequiredCredentials();const s={type:this.safeString2(this.options,"watchBalance","defaultType","swap")},i=await this.fetchBalance(s),r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e];"free"!==t&&"used"!==t&&"total"!==t&&"timestamp"!==t&&"datetime"!==t&&"info"!==t&&(this.balance[t]=i[t])}this.balance.info=this.safeValue(i,"info",{}),e.resolve(this.balance,"balance")}handleSubject(e,t){const s=this.safeString(t,"subject"),i={level2:this.handleOrderBook,ticker:this.handleTicker,"candle.stick":this.handleOHLCV,tickerV2:this.handleBidAsk,"availableBalance.change":this.handleBalance,match:this.handleTrade,orderChange:this.handleOrder,orderUpdated:this.handleOrder,"position.change":this.handlePosition,"position.settlement":this.handlePosition,"position.adjustRiskLimit":this.handlePosition},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}getMessageHash(e,t=void 0){return void 0!==t?e+"@"+t:e+"s@all"}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"data","");if("token is expired"===s){let t="public";e.url.indexOf("connectId=private")>=0&&(t="private"),this.options.urls[t]=void 0}this.handleErrors(void 0,void 0,e.url,void 0,void 0,s,t,void 0,void 0)}handleMessage(e,t){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,message:this.handleSubject,pong:this.handlePong,error:this.handleErrorMessage},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}},1736:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(3144),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,fetchOHLCVWs:!0,fetchOrderBookWs:!0,fetchTickerWs:!0,fetchTradesWs:!0,watchBalance:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!1,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://www.lbkex.net/ws/V2/"}},options:{watchOHLCV:{timeframes:{"1m":"1min","5m":"5min","15m":"15min","30m":"30min","1h":"1hr","4h":"4hr","1d":"day","1w":"week","1M":"month","1y":"year"}}},streaming:{},exceptions:{}})}requestId(){const e=this.safeInteger(this.options,"requestId",0),t=this.sum(e,1);return this.options.requestId=t,t}async fetchOHLCVWs(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.urls.api.ws,n=this.safeValue(this.options,"watchOHLCV",{}),d=this.safeValue(n,"timeframes",{}),h=this.safeString(d,t,t),c="fetchOHLCV:"+a.symbol+":"+h,l={action:"request",request:"kbar",kbar:h,pair:a.id};void 0!==s&&(l.start=this.parseToInt(Math.floor(s/1e3))),void 0!==i&&(l.size=i);const u=this.deepExtend(l,r),p=this.requestId();return await this.watch(o,c,u,p,u)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeValue(this.options,"watchOHLCV",{}),n=this.safeValue(o,"timeframes",{}),d=this.safeString(n,t,t),h="ohlcv:"+a.symbol+":"+d,c=this.urls.api.ws,l={action:"subscribe",subscribe:"kbar",kbar:d,pair:a.id},u=this.deepExtend(l,r),p=await this.watch(c,h,u,h);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"pair"),i=this.safeSymbol(s,void 0,"_"),r=this.safeValue(this.options,"watchOHLCV",{}),o=this.safeValue(r,"timeframes",{}),n=this.safeValue(t,"records");if(void 0!==n){const s=this.safeValue(n,0,[]),r=[this.safeInteger(s,0),this.safeNumber(s,1),this.safeNumber(s,2),this.safeNumber(s,3),this.safeNumber(s,4),this.safeNumber(s,5)],d=this.safeString(t,"kbar"),h=this.findTimeframe(d,o);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let c=this.safeValue(this.ohlcvs[i],h);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[i][h]=c}c.append(r);const l="fetchOHLCV:"+i+":"+d;e.resolve(c,l)}else{const s=this.safeValue(t,"kbar",{}),r=this.safeString(s,"slot"),n=this.safeString(s,"t"),d=[this.parse8601(n),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")],h=this.findTimeframe(r,o);this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let c=this.safeValue(this.ohlcvs[i],h);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[i][h]=c}c.append(d);const l="ohlcv:"+i+":"+r;e.resolve(c,l)}}async fetchTickerWs(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,r="fetchTicker:"+s.symbol,a={action:"request",request:"tick",pair:s.id},o=this.deepExtend(a,t),n=this.requestId();return await this.watch(i,r,o,n,o)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,r="ticker:"+s.symbol,a={action:"subscribe",subscribe:"tick",pair:s.id},o=this.deepExtend(a,t);return await this.watch(i,r,o,r,o)}handleTicker(e,t){const s=this.safeString(t,"pair"),i=this.safeSymbol(s),r=this.safeMarket(s),a=this.parseWsTicker(t,r);this.tickers[i]=a;let o="ticker:"+i;e.resolve(a,o),o="fetchTicker:"+i,e.resolve(a,o)}parseWsTicker(e,t=void 0){const s=this.safeString(e,"pair"),i=this.safeSymbol(s,t),r=this.safeString(e,"TS"),a=this.safeValue(e,"tick");return this.safeTicker({symbol:i,timestamp:this.parse8601(r),datetime:r,high:this.safeString(a,"high"),low:this.safeString(a,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:void 0,last:this.safeString(a,"latest"),previousClose:void 0,change:void 0,percentage:this.safeString(a,"change"),average:void 0,baseVolume:this.safeString(a,"vol"),quoteVolume:this.safeString(a,"turnover"),info:e},t)}async fetchTradesWs(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a=this.urls.api.ws,o="fetchTrades:"+r.symbol;void 0===s&&(s=10);const n={action:"request",request:"trade",pair:r.id,size:s},d=this.deepExtend(n,i),h=this.requestId();return await this.watch(a,o,d,h,d)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a=this.urls.api.ws,o="trades:"+r.symbol,n={action:"subscribe",subscribe:"trade",pair:r.id},d=this.deepExtend(n,i),h=await this.watch(a,o,d,o,d);return this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString(t,"pair"),i=this.safeSymbol(s),r=this.safeMarket(s);let o=this.safeValue(this.trades,i);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.I3(e),this.trades[i]=o}const n=this.safeValue(t,"trade"),d=this.safeValue(t,"trades",[n]);for(let e=0;e<d.length;e++){const t=this.parseWsTrade(d[e],r);t.symbol=i,o.append(t)}this.trades[i]=o;let h="trades:"+i;e.resolve(this.trades[i],h),h="fetchTrades:"+i,e.resolve(this.trades[i],h)}parseWsTrade(e,t=void 0){let s=this.safeInteger(e,0);const i=void 0!==s?this.iso8601(s):this.safeString(e,"TS");void 0===s&&(s=this.parse8601(i));let r=this.safeString2(e,"direction",3);return r=r.replace("_market",""),this.safeTrade({timestamp:s,datetime:i,symbol:void 0,id:void 0,order:void 0,type:void 0,takerOrMaker:void 0,side:r,price:this.safeString2(e,"price",1),amount:this.safeString2(e,"volume",2),cost:this.safeString(e,"amount"),fee:void 0,info:e},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.authenticate(i),a=this.urls.api.ws;let o,n="all";if(void 0===e)o="orders:all";else{const t=this.market(e);e=this.symbol(e),o="orders:"+t.symbol,n=t.id}const d={action:"subscribe",subscribe:"orderUpdate",subscribeKey:r,pair:n},h=this.deepExtend(d,i),c=await this.watch(a,o,h,o,h);return this.filterBySymbolSinceLimit(c,e,t,s,!0)}handleOrders(e,t){const s=this.safeString(t,"pair"),i=this.safeSymbol(s,void 0,"_");let r;if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);r=new a.Pt(e)}else r=this.orders;const o=this.parseWsOrder(t);r.append(o),this.orders=r,e.resolve(r,"orders");const n="orders:"+i;e.resolve(r,n)}parseWsOrder(e,t=void 0){const s=this.safeValue(e,"orderUpdate",{}),i=this.safeString(s,"type",""),r=i.split("_"),a=this.safeString(r,0),o=this.safeString(r,1);let n;"buy"!==i&&"sell"!==i&&(n="market"===o?"market":"limit");const d=this.safeString(e,"pair"),h=this.safeSymbol(d,t,"_"),c=this.safeInteger(s,"updateTime"),l=this.safeString(s,"orderStatus"),u=this.safeString(s,"orderAmt");let p;return"market"===n&&"buy"===a&&(p=u),this.safeOrder({info:e,id:this.safeString(s,"uuid"),clientOrderId:this.safeString(s,"customerID"),timestamp:c,datetime:this.iso8601(c),lastTradeTimestamp:void 0,lastUpdateTimestamp:this.safeInteger(s,"updateTime"),symbol:h,type:n,side:a,price:this.safeString2(s,"price","orderPrice"),stopPrice:void 0,average:this.safeString(s,"avgPrice"),amount:this.safeString2(s,"amount","orderAmt"),remaining:this.safeString(s,"remainAmt"),filled:this.safeString(s,"accAmt"),status:this.parseWsOrderStatus(l),fee:void 0,cost:p,trades:void 0},t)}parseWsOrderStatus(e){return this.safeString({"-1":"canceled",0:"open",1:"open",2:"closed",4:"closed"},e,e)}async fetchOrderBookWs(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.urls.api.ws,a="fetchOrderbook:"+i.symbol;void 0===t&&(t=100);const o={action:"request",request:"depth",depth:t,pair:i.id},n=this.deepExtend(o,s);return(await this.watch(r,a,n,a)).limit()}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.urls.api.ws,a="orderbook:"+i.symbol;s=this.omit(s,"aggregation"),void 0===t&&(t=100);const o={action:"subscribe",subscribe:"depth",depth:t,pair:i.id},n=this.deepExtend(o,s);return(await this.watch(r,a,n,a)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"pair"),i=this.safeSymbol(s),r=this.safeValue(t,"depth",t),a=this.safeString(t,"TS"),o=this.parse8601(a);i in this.orderbooks||(this.orderbooks[i]=this.orderBook({}));const n=this.orderbooks[i],d=this.parseOrderBook(r,i,o,"bids","asks");n.reset(d);let h="orderbook:"+i;e.resolve(n,h),h="fetchOrderbook:"+i,e.resolve(n,h)}handleErrorMessage(e,t){const s=this.safeString(t,"message",""),i=new r.ExchangeError(this.id+" "+s);e.reject(i)}async handlePing(e,t){const s=this.safeString(t,"ping");await e.send({action:"pong",pong:s})}handleMessage(e,t){if("error"===this.safeString(t,"status"))return void this.handleErrorMessage(e,t);const s=this.safeString2(t,"type","action");if("ping"===s)return void this.spawn(this.handlePing,e,t);const i={kbar:this.handleOHLCV,depth:this.handleOrderBook,trade:this.handleTrades,tick:this.handleTicker,orderUpdate:this.handleOrders},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i=this.milliseconds(),a=this.safeValue(s.subscriptions,"authenticated");if(void 0===a){this.checkRequiredCredentials();const t=await this.spotPrivatePostSubscribeGetKey(e);if(!0!==this.safeValue(t,"result"))throw new r.ExchangeError(this.id+" failed to get subscribe key");s.subscriptions.authenticated={key:this.safeString(t,"data"),expires:this.sum(i,33e5)}}else{if(this.safeInteger(a,"expires",0)<i){const t={subscribeKey:a.key},o=await this.spotPrivatePostSubscribeRefreshKey(this.extend(t,e));if("true"!==this.safeString(o,"result"))throw new r.ExchangeError(this.id+" failed to refresh the SubscribeKey");s.subscriptions.authenticated.expires=this.sum(i,33e5)}}return s.subscriptions.authenticated.key}}},2208:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(9248),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!1,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!1,watchOrders:void 0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://ws.luno.com/api/1"}},options:{sequenceNumbers:{}},streaming:{},exceptions:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){this.checkRequiredCredentials(),await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="/stream/"+r.id,o={symbol:e},n=this.urls.api.ws+a,d="trades:"+e,h={api_key_id:this.apiKey,api_key_secret:this.secret},c=this.deepExtend(h,i),l=await this.watch(n,d,c,a,o);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySinceLimit(l,t,s,"timestamp",!0)}handleTrades(e,t,s){const i=this.safeValue(t,"trade_updates",[]);if(0===i.length)return;const a=s.symbol,o=this.market(a),n="trades:"+a;let d=this.safeValue(this.trades,a);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new r.I3(e),this.trades[a]=d}for(let e=0;e<i.length;e++){const t=i[e],s=this.parseTrade(t,o);d.append(s)}this.trades[a]=d,e.resolve(this.trades[a],n)}parseTrade(e,t=void 0){return this.safeTrade({info:e,id:void 0,timestamp:void 0,datetime:void 0,symbol:t.symbol,order:void 0,type:void 0,side:void 0,takerOrMaker:void 0,price:void 0,amount:this.safeString(e,"base"),cost:this.safeString(e,"counter"),fee:void 0},t)}async watchOrderBook(e,t=void 0,s={}){this.checkRequiredCredentials(),await this.loadMarkets();const i=this.market(e);e=i.symbol;const r="/stream/"+i.id,a={symbol:e},o=this.urls.api.ws+r,n="orderbook:"+e,d={api_key_id:this.apiKey,api_key_secret:this.secret},h=this.deepExtend(d,s);return(await this.watch(o,n,h,r,a)).limit()}handleOrderBook(e,t,s){const i=s.symbol,r="orderbook:"+i,a=this.safeInteger(t,"timestamp");i in this.orderbooks||(this.orderbooks[i]=this.indexedOrderBook({}));const o=this.orderbooks[i];if(void 0!==this.safeValue(t,"asks")){const e=this.customParseOrderBook(t,i,a,"bids","asks","price","volume","id");o.reset(e)}else this.handleDelta(o,t),o.timestamp=a,o.datetime=this.iso8601(a);const n=this.safeInteger(t,"sequence");o.nonce=n,e.resolve(o,r)}customParseOrderBook(e,t,s=void 0,i="bids",r="asks",a="price",o="volume",n=2){const d=this.parseBidsAsks(this.safeValue(e,i,[]),a,o,n),h=this.parseBidsAsks(this.safeValue(e,r,[]),a,o,n);return{symbol:t,bids:this.sortBy(d,0,!0),asks:this.sortBy(h,0),timestamp:s,datetime:this.iso8601(s),nonce:void 0}}parseBidsAsks(e,t="price",s="volume",i=2){e=this.toArray(e);const r=[];for(let a=0;a<e.length;a++)r.push(this.customParseBidAsk(e[a],t,s,i));return r}customParseBidAsk(e,t="price",s="volume",i=2){const r=[this.safeNumber(e,t),this.safeNumber(e,s)];if(void 0!==i){const t=this.safeString(e,i);r.push(t)}return r}handleDelta(e,t){const s=this.safeValue(t,"create_update"),i=e.asks,r=e.bids;if(void 0!==s){const e=this.customParseBidAsk(s,"price","volume","order_id"),t=this.safeString(s,"type");"ASK"===t?i.storeArray(e):"BID"===t&&r.storeArray(e)}const a=this.safeValue(t,"delete_update");if(void 0!==a){const e=this.safeString(a,"order_id");i.storeArray([0,0,e]),r.storeArray([0,0,e])}}handleMessage(e,t){if(""===t)return;const s=Object.values(e.subscriptions),i=[this.handleOrderBook,this.handleTrades];for(let r=0;r<i.length;r++){i[r].call(this,e,t,s[0])}}}},9219:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(2403),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!1,cancelOrdersWs:!1,cancelOrderWs:!1,createOrderWs:!1,editOrderWs:!1,fetchBalanceWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,fetchTradesWs:!1,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1},urls:{api:{ws:{spot:"wss://wbs.mexc.com/ws",swap:"wss://contract.mexc.com/edge"}}},options:{listenKeyRefreshRate:12e5,timeframes:{"1m":"Min1","5m":"Min5","15m":"Min15","30m":"Min30","1h":"Min60","4h":"Hour4","8h":"Hour8","1d":"Day1","1w":"Week1","1M":"Month1"},watchOrderBook:{snapshotDelay:25,snapshotMaxRetries:3},listenKey:void 0},streaming:{ping:this.ping,keepAlive:8e3},exceptions:{}})}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i="ticker:"+s.symbol;if(s.spot){const e="spot@public.bookTicker.v3.api@"+s.id;return await this.watchSpotPublic(e,i,t)}{const e="sub.ticker",r={symbol:s.id};return await this.watchSwapPublic(e,i,r,t)}}handleTicker(e,t){const s=this.safeValue2(t,"d","data"),i=this.safeString2(t,"s","symbol"),r=this.safeInteger(t,"t"),a=this.safeMarket(i),o=a.symbol;let n;a.spot?(n=this.parseWsTicker(s,a),n.timestamp=r,n.datetime=this.iso8601(r)):n=this.parseTicker(s,a),this.tickers[o]=n;const d="ticker:"+o;e.resolve(n,d)}parseWsTicker(e,t=void 0){return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:void 0,datetime:void 0,open:void 0,high:void 0,low:void 0,close:void 0,bid:this.safeNumber(e,"b"),bidVolume:this.safeNumber(e,"B"),ask:this.safeNumber(e,"a"),askVolume:this.safeNumber(e,"A"),vwap:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}async watchSpotPublic(e,t,s={}){const i=this.urls.api.ws.spot,r={method:"SUBSCRIPTION",params:[e]};return await this.watch(i,t,this.extend(r,s),e)}async watchSpotPrivate(e,t,s={}){this.checkRequiredCredentials();const i=await this.authenticate(e),r=this.urls.api.ws.spot+"?listenKey="+i,a={method:"SUBSCRIPTION",params:[e]};return await this.watch(r,t,this.extend(a,s),e)}async watchSwapPublic(e,t,s,i={}){const r=this.urls.api.ws.swap,a={method:e,param:s},o=this.extend(a,i);return await this.watch(r,t,o,t)}async watchSwapPrivate(e,t={}){this.checkRequiredCredentials();const s="login",i=this.urls.api.ws.swap,r=this.milliseconds().toString(),a=this.apiKey+r,n=this.hmac(this.encode(a),this.encode(this.secret),o.s),d={method:s,param:{apiKey:this.apiKey,signature:n,reqTime:r}},h=this.extend(d,t);return await this.watch(i,e,h,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeValue(this.options,"timeframes",{}),n=this.safeString(o,t),d="candles:"+e+":"+t;let h;if(a.spot){const e="spot@public.kline.v3.api@"+a.id+"@"+n;h=await this.watchSpotPublic(e,d,r)}else{const e="sub.kline",t={symbol:a.id,interval:n};h=await this.watchSwapPublic(e,d,t,r)}return this.newUpdates&&(i=h.getLimit(e,i)),this.filterBySinceLimit(h,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue2(t,"d","data",{}),i=this.safeValue(s,"k",s),r=this.safeString2(i,"i","interval"),o=this.safeValue(this.options,"timeframes",{}),n=this.findTimeframe(r,o),d=this.safeString2(t,"s","symbol"),h=this.safeMarket(d),c=h.symbol,l="candles:"+c+":"+n,u=this.parseWsOHLCV(i,h);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let p=this.safeValue(this.ohlcvs[c],n);if(void 0===p){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);p=new a.TG(e),this.ohlcvs[c][n]=p}p.append(u),e.resolve(p,l)}parseWsOHLCV(e,t=void 0){return[this.safeTimestamp(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber2(e,"v","q")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook:"+(e=i.symbol);let a;if(i.spot){const e="spot@public.increase.depth.v3.api@"+i.id;a=await this.watchSpotPublic(e,r,s)}else{const e="sub.depth",t={symbol:i.id};a=await this.watchSwapPublic(e,r,t,s)}return a.limit()}handleOrderBookSubscription(e,t){const s=this.safeString(t,"msg").split("@"),i=this.safeString(s,2),r=this.safeSymbol(i);this.orderbooks[r]=this.orderBook({})}getCacheIndex(e,t){const s=this.safeInteger(e,"nonce"),i=this.safeValue(t,0);if(s<this.safeInteger2(i,"r","version")-1)return-1;for(let e=0;e<t.length;e++){const i=t[e];if(this.safeInteger2(i,"r","version")>=s)return e}return t.length}handleOrderBook(e,t){const s=this.safeValue2(t,"d","data"),i=this.safeString2(t,"s","symbol"),r=this.safeSymbol(i),a="orderbook:"+r,o=this.safeValue(e.subscriptions,a),n=this.safeInteger(o,"limit");!0===o&&(e.subscriptions[a]=1,this.orderbooks[r]=this.countedOrderBook({}));const d=this.orderbooks[r];if(void 0===this.safeInteger(d,"nonce")){return d.cache.length===this.handleOption("watchOrderBook","snapshotDelay",25)&&this.spawn(this.loadOrderBook,e,a,r,n,{}),void d.cache.push(s)}try{this.handleDelta(d,s);const e=this.safeInteger2(t,"t","ts");d.timestamp=e,d.datetime=this.iso8601(e)}catch(t){delete e.subscriptions[a],e.reject(t,a)}e.resolve(d,a)}handleBooksideDelta(e,t){for(let s=0;s<t.length;s++){const i=t[s];if(Array.isArray(i))e.storeArray(i);else{const t=this.safeFloat(i,"p"),s=this.safeFloat(i,"v");e.store(t,s)}}}handleDelta(e,t){const s=this.safeInteger(e,"nonce"),i=this.safeInteger2(t,"r","version");if(i<s)return;e.nonce=i;const r=this.safeList(t,"asks",[]),a=this.safeList(t,"bids",[]),o=e.asks,n=e.bids;this.handleBooksideDelta(o,r),this.handleBooksideDelta(n,a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trades:"+(e=r.symbol);let o;if(r.spot){const e="spot@public.deals.v3.api@"+r.id;o=await this.watchSpotPublic(e,a,i)}else{const e="sub.deal",t={symbol:r.id};o=await this.watchSwapPublic(e,a,t,i)}return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeString2(t,"s","symbol"),i=this.safeMarket(s),r=i.symbol,o="trades:"+r;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}const d=this.safeValue2(t,"d","data"),h=this.safeValue(d,"deals",[d]);for(let e=0;e<h.length;e++){let t;t=i.spot?this.parseWsTrade(h[e],i):this.parseTrade(h[e],i),n.append(t)}e.resolve(n,o)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o,n="myTrades";if(void 0!==e&&(r=this.market(e),n=n+":"+(e=r.symbol)),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i),"spot"===a){const e="spot@private.deals.v3.api";o=await this.watchSpotPrivate(e,n,i)}else o=await this.watchSwapPrivate(n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrade(e,t,s=void 0){const i="myTrades",r=this.safeValue2(t,"d","data"),o=this.safeString(r,"symbol"),n=this.safeString(t,"s",o),d=this.safeMarket(n),h=d.symbol;let c;c=d.spot?this.parseWsTrade(r,d):this.parseTrade(r,d);let l=this.myTrades;if(void 0===l){const e=this.safeInteger(this.options,"tradesLimit",1e3);l=new a.Pt(e),this.myTrades=l}l.append(c),e.resolve(l,i);const u=i+":"+h;e.resolve(l,u)}parseWsTrade(e,t=void 0){let s=this.safeInteger(e,"T"),i=this.safeString(e,"t");void 0===s&&(s=this.safeInteger(e,"t"),i=void 0);const r=this.safeString(e,"p"),a=this.safeString(e,"v"),o="1"===this.safeString(e,"S")?"buy":"sell",n=this.safeInteger(e,"m"),d=this.safeNumber(e,"n"),h=this.safeString(e,"N");return this.safeTrade({info:e,id:i,order:this.safeString(e,"i"),timestamp:s,datetime:this.iso8601(s),symbol:this.safeSymbol(void 0,t),type:void 0,side:o,takerOrMaker:n?"maker":"taker",price:r,amount:a,cost:void 0,fee:{cost:d,currency:this.safeCurrencyCode(h)}},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),i=this.omit(i,"type");let r,a,o,n="orders";if(void 0!==e&&(r=this.market(e),n=n+":"+(e=r.symbol)),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i),"spot"===a){const e=a+"@private.orders.v3.api";o=await this.watchSpotPrivate(e,n,i)}else o=await this.watchSwapPrivate(n,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t){const s="orders",i=this.safeValue2(t,"d","data"),r=this.safeString(i,"symbol"),o=this.safeString(t,"s",r),n=this.safeMarket(o),d=n.symbol;let h;h=n.spot?this.parseWsOrder(i,n):this.parseOrder(i,n);let c=this.orders;if(void 0===c){const e=this.safeInteger(this.options,"ordersLimit",1e3);c=new a.Pt(e),this.orders=c}c.append(h),e.resolve(c,s);const l=s+":"+d;e.resolve(c,l)}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"O"),i=this.safeString(e,"S"),r=this.safeString(e,"s"),a=this.safeString(e,"o");let o;const n=this.safeString(e,"N");return void 0!==n&&(o={currency:n,cost:void 0}),this.safeOrder({id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,status:this.parseWsOrderStatus(r,t),symbol:this.safeSymbol(void 0,t),type:this.parseWsOrderType(a),timeInForce:this.parseWsTimeInForce(a),side:"1"===i?"buy":"sell",price:this.safeString(e,"p"),stopPrice:void 0,triggerPrice:this.safeNumber(e,"P"),average:this.safeString(e,"ap"),amount:this.safeString(e,"v"),cost:this.safeString(e,"a"),filled:this.safeString(e,"cv"),remaining:this.safeString(e,"V"),fee:o,trades:void 0,info:e},t)}parseWsOrderStatus(e,t=void 0){return this.safeString({1:"open",2:"closed",3:"open",4:"canceled",5:"open",6:"closed",NEW:"open",CANCELED:"canceled",EXECUTED:"closed",FAILED:"rejected"},e,e)}parseWsOrderType(e){const t={1:"limit",2:void 0,3:void 0,4:void 0,5:"market",100:"limit"};return this.safeString(t,e)}parseWsTimeInForce(e){return this.safeString({1:"GTC",2:"PO",3:"IOC",4:"FOK",5:"GTC",100:"GTC"},e)}async watchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);const s="balance:"+t;if("spot"===t){const t="spot@private.account.v3.api";return await this.watchSpotPrivate(t,s,e)}return await this.watchSwapPrivate(s,e)}handleBalance(e,t){const s=void 0===this.safeString(t,"c")?"swap":"spot",i="balance:"+s,r=this.safeValue2(t,"d","data"),a=this.safeInteger(t,"ts"),o=this.safeInteger(r,"c",a);s in this.balance||(this.balance[s]={}),this.balance[s].info=r,this.balance[s].timestamp=o,this.balance[s].datetime=this.iso8601(o);const n=this.safeString2(r,"a","currency"),d=this.safeCurrencyCode(n),h=this.account();h.free=this.safeString2(r,"f","availableBalance"),h.used=this.safeString2(r,"l","frozenBalance"),this.balance[s][d]=h,this.balance[s]=this.safeBalance(this.balance[s]),e.resolve(this.balance[s],i)}async authenticate(e,t={}){let s=this.safeString(this.options,"listenKey");if(void 0!==s)return s;const i=await this.spotPrivatePostUserDataStream(t);s=this.safeString(i,"listenKey"),this.options.listenKey=s;const r=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);return this.delay(r,this.keepAliveListenKey,s,t),s}async keepAliveListenKey(e,t={}){if(void 0===e)return;const s={listenKey:e};try{await this.spotPrivatePutUserDataStream(this.extend(s,t));const i=this.safeInteger(this.options,"listenKeyRefreshRate",12e5);this.delay(i,this.keepAliveListenKey,e,t)}catch(t){const s=this.urls.api.ws.spot+"?listenKey="+e,i=this.client(s);this.options.listenKey=void 0,i.reject(t),delete this.clients[s]}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscriptionStatus(e,t){const s=this.safeString(t,"msg");if("PONG"===s)this.handlePong(e,t);else if(s.indexOf("@")>-1){const i=s.split("@"),r=this.safeString(i,1),a={"public.increase.depth.v3.api":this.handleOrderBookSubscription},o=this.safeValue(a,r);void 0!==o&&o.call(this,e,t)}}handleMessage(e,t){if("string"==typeof t){if("Invalid listen key"===t){const t=new r.AuthenticationError(this.id+" invalid listen key");e.reject(t)}return}if("msg"in t)return void this.handleSubscriptionStatus(e,t);const s=this.safeString(t,"c");let i;if(void 0===s)i=this.safeString(t,"channel");else{const e=s.split("@");i=this.safeString(e,1)}const a={"public.deals.v3.api":this.handleTrades,"push.deal":this.handleTrades,"public.kline.v3.api":this.handleOHLCV,"push.kline":this.handleOHLCV,"public.bookTicker.v3.api":this.handleTicker,"push.ticker":this.handleTicker,"public.increase.depth.v3.api":this.handleOrderBook,"push.depth":this.handleOrderBook,"private.orders.v3.api":this.handleOrder,"push.personal.order":this.handleOrder,"private.account.v3.api":this.handleBalance,"push.personal.asset":this.handleBalance,"private.deals.v3.api":this.handleMyTrade,"push.personal.order.deal":this.handleMyTrade,pong:this.handlePong};if(i in a){a[i].call(this,e,t)}}ping(e){return{method:"ping"}}}},3887:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(4460),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTrades:!0,watchTradesForSymbols:!1,watchTicker:!0,watchOHLCV:!0},urls:{test:{ws:"wss://ndaxmarginstaging.cdnhop.net:10456/WSAdminGatewa/"},api:{ws:"wss://api.ndax.io/WSGateway"}}})}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async watchTicker(e,t={}){const s=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const i=this.market(e),r="SubscribeLevel1",a=r+":"+i.id,o=this.urls.api.ws,n=this.requestId(),d={OMSId:s,InstrumentId:parseInt(i.id)},h={m:0,i:n,n:r,o:this.json(d)},c=this.extend(h,t);return await this.watch(o,a,c,a)}handleTicker(e,t){const s=this.safeValue(t,"o",{}),i=this.parseTicker(s),r=i.symbol,a=this.market(r);this.tickers[r]=i;const o="SubscribeLevel1:"+a.id;e.resolve(i,o)}async watchTrades(e,t=void 0,s=void 0,i={}){const r=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const a=this.market(e);e=a.symbol;const o="SubscribeTrades",n=o+":"+a.id,d=this.urls.api.ws,h=this.requestId(),c={OMSId:r,InstrumentId:parseInt(a.id),IncludeLastCount:100},l={m:0,i:h,n:o,o:this.json(c)},u=this.extend(l,i),p=await this.watch(d,n,u,n);return this.newUpdates&&(s=p.getLimit(e,s)),this.filterBySinceLimit(p,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"o",[]),i={};for(let e=0;e<s.length;e++){const t=this.parseTrade(s[e]),a=t.symbol;let o=this.safeValue(this.trades,a);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new r.I3(e)}o.append(t),this.trades[a]=o,i[a]=!0}const a=Object.keys(i);for(let t=0;t<a.length;t++){const s=a[t],i="SubscribeTrades:"+this.market(s).id,r=this.safeValue(this.trades,s);e.resolve(r,i)}}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){const a=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const o=this.market(e);e=o.symbol;const n="SubscribeTicker",d=n+":"+t+":"+o.id,h=this.urls.api.ws,c=this.requestId(),l={OMSId:a,InstrumentId:parseInt(o.id),Interval:parseInt(this.safeString(this.timeframes,t,t)),IncludeLastCount:100},u={m:0,i:c,n,o:this.json(l)},p=this.extend(u,r),f=await this.watch(h,d,p,d);return this.newUpdates&&(i=f.getLimit(e,i)),this.filterBySinceLimit(f,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"o",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,8),a=this.safeMarket(r).symbol;i[r]={},this.ohlcvs[a]=this.safeValue(this.ohlcvs,a,{});const o=Object.keys(this.timeframes);for(let e=0;e<o.length;e++){const s=o[e],n=this.safeString(this.timeframes,s,s),d=1e3*parseInt(n),h=this.safeInteger(t,0),c=[this.parseToInt(h/d*d),this.safeFloat(t,3),this.safeFloat(t,1),this.safeFloat(t,2),this.safeFloat(t,4),this.safeFloat(t,5)],l=this.safeValue(this.ohlcvs[a],s,[]),u=l.length;if(u&&c[0]===l[u-1][0]){const e=l[u-1];l[u-1]=[c[0],e[1],Math.max(c[1],e[1]),Math.min(c[2],e[2]),c[4],this.sum(c[5],e[5])],i[r][s]=!0}else{if(u&&c[0]<l[u-1][0])continue;l.push(c);u>=this.safeInteger(this.options,"OHLCVLimit",1e3)&&l.shift(),i[r][s]=!0}this.ohlcvs[a][s]=l}}const r=Object.keys(i);for(let t=0;t<r.length;t++){const s=r[t],a=Object.keys(i[s]);for(let t=0;t<a.length;t++){const i=a[t],r="SubscribeTicker:"+i+":"+s,o=this.safeMarket(s).symbol,n=this.safeValue(this.ohlcvs[o],i,[]);e.resolve(n,r)}}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeInteger(this.options,"omsId",1);await this.loadMarkets();const r=this.market(e);e=r.symbol;const a="SubscribeLevel2",o=a+":"+r.id,n=this.urls.api.ws,d=this.requestId();t=void 0===t?100:t;const h={OMSId:i,InstrumentId:parseInt(r.id),Depth:t},c={m:0,i:d,n:a,o:this.json(h)},l={id:d,messageHash:o,name:a,symbol:e,marketId:r.id,method:this.handleOrderBookSubscription,limit:t,params:s},u=this.extend(c,s);return(await this.watch(n,o,u,o,l)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"o",[]),i=this.safeValue(s,0,[]),r=this.safeString(i,7);if(void 0===r)return;const a=this.safeMarket(r).symbol,o=this.safeValue(this.orderbooks,a);if(void 0===o)return;let n,d;for(let e=0;e<s.length;e++){const t=s[e];if(void 0===n)n=this.safeInteger(t,2);else{const e=this.safeInteger(t,2);n=Math.max(n,e)}if(void 0===d)d=this.safeInteger(t,0);else{const e=this.safeInteger(t,0);d=Math.max(d,e)}const i=this.safeInteger(t,3),r=this.safeFloat(t,6),a=this.safeFloat(t,8),h=0===this.safeInteger(t,9)?o.bids:o.asks;0===i||1===i?h.store(r,a):2===i&&h.store(r,0)}o.nonce=d,o.timestamp=n,o.datetime=this.iso8601(n);const h="SubscribeLevel2:"+r;this.orderbooks[a]=o,e.resolve(o,h)}handleOrderBookSubscription(e,t,s){const i=this.safeValue(t,"o",[]),r=this.safeString(s,"symbol"),a=this.parseOrderBook(i,r),o=this.safeInteger(s,"limit"),n=this.orderBook(a,o);this.orderbooks[r]=n;const d=this.safeString(s,"messageHash");e.resolve(n,d)}handleSubscriptionStatus(e,t){const s=this.indexBy(e.subscriptions,"id"),i=this.safeInteger(t,"i"),r=this.safeValue(s,i);if(void 0!==r){const s=this.safeValue(r,"method");void 0!==s&&s.call(this,e,t,r)}}handleMessage(e,t){const s=this.safeString(t,"o");if(void 0===s)return;t.o=JSON.parse(s);const i={SubscribeLevel2:this.handleSubscriptionStatus,SubscribeLevel1:this.handleTicker,Level2UpdateEvent:this.handleOrderBook,Level1UpdateEvent:this.handleTicker,SubscribeTrades:this.handleTrades,TradeDataUpdateEvent:this.handleTrades,SubscribeTicker:this.handleOHLCV,TickerDataUpdateEvent:this.handleOHLCV},r=this.safeString(t,"n"),a=this.safeValue(i,r);void 0!==a&&a.call(this,e,t)}}},6187:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(7915),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchOrderBook:!0,watchOrders:!0,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!0,watchOHLCV:!0},urls:{api:{ws:"wss://real.okcoin.com:8443/ws/v3"},logo:"https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg",www:"https://www.okcoin.com",doc:"https://www.okcoin.com/docs/en/",fees:"https://www.okcoin.com/coin-fees",referral:"https://www.okcoin.com/account/register?flag=activity&channelId=600001513"},options:{fetchMarkets:["spot"],watchOrders:"order",watchOrderBook:{limit:400,type:"spot",depth:"depth_l2_tbt"},watchBalance:"spot",ws:{inflate:!0}},streaming:{ping:this.ping,keepAlive:2e4}})}async subscribe(e,t,s={}){await this.loadMarkets();const i=this.market(t),r=this.urls.api.ws,a=i.type+"/"+e+":"+i.id,o={op:"subscribe",args:[a]};return await this.watch(r,a,this.deepExtend(o,s),a)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.symbol(e);const r=await this.subscribe("trade",e,i);return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySinceLimit(r,t,s,"timestamp",!0)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(),void 0!==e&&(e=this.symbol(e));const r=this.safeString(this.options,"watchOrders","order"),a=await this.subscribe(r,e,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleOrders(e,t,s=void 0){const i=this.safeString(t,"table"),r=this.safeValue(t,"data",[]);if(r.length>0){const t=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(t));const s=this.orders,o={},n=this.parseOrders(r);for(let e=0;e<n.length;e++){const t=n[e];s.append(t);const i=t.symbol;o[this.market(i).id]=!0}const d=Object.keys(o);for(let t=0;t<d.length;t++){const s=i+":"+d[t];e.resolve(this.orders,s)}}}async watchTicker(e,t={}){return await this.subscribe("ticker",e,t)}handleTrade(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),r=this.safeInteger(this.options,"tradesLimit",1e3);for(let t=0;t<i.length;t++){const o=this.parseTrade(i[t]),n=o.symbol,d=s+":"+this.safeString(o.info,"instrument_id");let h=this.safeValue(this.trades,n);void 0===h&&(h=new a.I3(r),this.trades[n]=h),h.append(o),e.resolve(h,d)}return t}handleTicker(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]);for(let t=0;t<i.length;t++){const r=this.parseTicker(i[t]),a=r.symbol,o=s+":"+this.safeString(r.info,"instrument_id");this.tickers[a]=r,e.resolve(r,o)}return t}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.safeString(this.timeframes,t,t)+"s",o=await this.subscribe(a,e,r);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"table"),i=this.safeValue(t,"data",[]),r=s.split("/");let o=this.safeString(r,1).replace("candle","");o=o.replace("s","");const n=this.findTimeframe(o);for(let t=0;t<i.length;t++){const r=this.safeString(i[t],"instrument_id"),o=this.safeValue(i[t],"candle"),d=this.safeMarket(r),h=d.symbol,c=this.parseOHLCV(o,d);this.ohlcvs[h]=this.safeValue(this.ohlcvs,h,{});let l=this.safeValue(this.ohlcvs[h],n);if(void 0===l){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new a.TG(e),this.ohlcvs[h][n]=l}l.append(c);const u=s+":"+r;e.resolve(l,u)}}async watchOrderBook(e,t=void 0,s={}){const i=this.safeValue(this.options,"watchOrderBook",{}),r=this.safeString(i,"depth","depth_l2_tbt");return(await this.subscribe(r,e,s)).limit()}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s){const i=this.safeValue(t,"asks",[]),r=this.safeValue(t,"bids",[]);this.handleDeltas(s.asks,i),this.handleDeltas(s.bids,r);const a=this.parse8601(this.safeString(t,"timestamp"));return s.timestamp=a,s.datetime=this.iso8601(a),s}handleOrderBook(e,t){const s=this.safeString(t,"action"),i=this.safeValue(t,"data",[]),r=this.safeString(t,"table");if("partial"===s)for(let t=0;t<i.length;t++){const s=i[t],a=this.safeString(s,"instrument_id"),o=this.safeMarket(a).symbol,n=this.safeValue(this.options,"watchOrderBook",{}),d=this.safeInteger(n,"limit",400),h=this.orderBook({},d);this.orderbooks[o]=h,this.handleOrderBookMessage(e,s,h);const c=r+":"+a;e.resolve(h,c)}else for(let t=0;t<i.length;t++){const s=i[t],a=this.safeString(s,"instrument_id"),o=this.safeMarket(a).symbol;if(o in this.orderbooks){const t=this.orderbooks[o];this.handleOrderBookMessage(e,s,t);const i=r+":"+a;e.resolve(t,i)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="login",i=this.client(t);let r=this.safeValue(i.subscriptions,s);if(void 0===r){r=i.future("authenticated");const e=this.seconds().toString(),a=e+"GET"+"/users/self/verify",n=this.hmac(this.encode(a),this.encode(this.secret),o.s,"base64"),d={op:s,args:[this.apiKey,this.password,e,n]};this.spawn(this.watch,t,s,d,s,r)}return await r}async watchBalance(e={}){const t=this.safeString2(this.options,"watchBalance","defaultType");if(void 0===this.safeString(e,"type",t))throw new r.ArgumentsRequired(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");const s=await this.authenticate();return await this.subscribeToUserAccount(s,e)}async subscribeToUserAccount(e,t={}){const s=this.safeString2(this.options,"watchBalance","defaultType"),i=this.safeString(t,"type",s);if(void 0===i)throw new r.ArgumentsRequired(this.id+" watchBalance requires a type parameter (one of 'spot', 'margin', 'futures', 'swap')");await this.loadMarkets();const a=this.safeString(t,"currency"),o=this.safeString(t,"code",this.safeCurrencyCode(a));let n;void 0!==o&&(n=this.currency(o));const d=this.safeString(t,"symbol"),h=this.market(d),c=void 0===h,l=void 0===n;if("spot"===i){if(l)throw new r.ArgumentsRequired(this.id+" watchBalance requires a 'currency' (id) or a unified 'code' parameter for "+i+" accounts")}else if("margin"===i||"swap"===i||"option"===i){if(c)throw new r.ArgumentsRequired(this.id+" watchBalance requires a 'instrument_id' (id) or a unified 'symbol' parameter for "+i+" accounts")}else if("futures"===i&&l&&c)throw new r.ArgumentsRequired(this.id+" watchBalance requires a 'currency' (id), or unified 'code', or 'instrument_id' (id), or unified 'symbol' parameter for "+i+" accounts");let u;l?c||(u=h.id):u=n.id;const p=("margin"===i?"spot":i)+"/"+("margin"===i?"margin_account":"account"),f=p+":"+u,m=this.urls.api.ws,g={op:"subscribe",args:[f]},v=this.omit(t,["currency","code","instrument_id","symbol","type"]);return await this.watch(m,p,this.deepExtend(g,v),f)}handleBalance(e,t){const s=this.safeString(t,"table"),i=s.split("/"),r=this.safeValue(t,"data",[]);this.balance.info=r;let a=this.safeString(i,0);if("spot"===a){"margin_account"===this.safeString(i,1)&&(a="margin")}for(let t=0;t<r.length;t++){const t=this.parseBalanceByType(a,r),i=this.safeValue(this.balance,a,{}),o=this.deepExtend(i,t);this.balance[a]=this.safeBalance(o),e.resolve(this.balance[a],s)}}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){return e.resolve(t,"authenticated"),t}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e);const i=this.safeValue(t,"message");void 0!==i&&this.throwBroadlyMatchedException(this.exceptions.broad,i,e)}}catch(t){if(t instanceof r.AuthenticationError){e.reject(t,"authenticated");const s="login";return s in e.subscriptions&&delete e.subscriptions[s],!1}}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if("pong"===t)return void this.handlePong(e,t);const s=this.safeString(t,"table");if(void 0===s){const s=this.safeString(t,"event");if(void 0!==s){const i={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}}else{const i=s.split("/"),r=this.safeString(i,1),a={depth:this.handleOrderBook,depth5:this.handleOrderBook,depth_l2_tbt:this.handleOrderBook,ticker:this.handleTicker,trade:this.handleTrade,account:this.handleBalance,margin_account:this.handleBalance,order:this.handleOrders};let o=this.safeValue(a,r);r.indexOf("candle")>=0&&(o=this.handleOHLCV),void 0!==o&&o.call(this,e,t)}}}},8588:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(3660),r=s(2079),a=s(2931),o=s(4852);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!0,watchOrderBook:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBookForSymbols:!0,watchBalance:!0,watchLiquidations:"emulated",watchLiquidationsForSymbols:!0,watchMyLiquidations:"emulated",watchMyLiquidationsForSymbols:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrders:!0,watchMyTrades:!0,watchPositions:!0,watchFundingRate:!0,watchFundingRates:!0,createOrderWs:!0,editOrderWs:!0,cancelOrderWs:!0,cancelOrdersWs:!0,cancelAllOrdersWs:!0},urls:{api:{ws:"wss://ws.okx.com:8443/ws/v5"},test:{ws:"wss://wspap.okx.com:8443/ws/v5"}},options:{watchOrderBook:{checksum:!0,depth:"books"},watchBalance:"spot",watchTicker:{channel:"tickers"},watchTickers:{channel:"tickers"},watchOrders:{type:"ANY"},watchMyTrades:{type:"ANY"},createOrderWs:{op:"batch-orders"},editOrderWs:{op:"amend-order"},ws:{}},streaming:{ping:this.ping,keepAlive:18e3}})}getUrl(e,t="public"){const s=this.options.sandboxMode?"?brokerId=9999":"",i="business"===t,r="public"===t,a=this.urls.api.ws;return i||e.indexOf("candle")>-1||"orders-algo"===e?a+"/business"+s:r?a+"/public"+s:a+"/private"+s}async subscribeMultiple(e,t,s=void 0,i={}){await this.loadMarkets(),void 0===s&&(s=this.symbols),s=this.marketSymbols(s);const r=this.getUrl(t,e);let a=t;const o=[];a+="::"+s.join(",");for(let e=0;e<s.length;e++){const r={channel:t,instId:this.marketId(s[e])};o.push(this.extend(r,i))}const n={op:"subscribe",args:o};return await this.watch(r,a,n,a)}async subscribe(e,t,s,i,r={}){await this.loadMarkets();const a=this.getUrl(s,e),o={channel:s};if(void 0!==i){const e=this.market(i);t+=":"+e.id,o.instId=e.id}const n={op:"subscribe",args:[this.deepExtend(o,r)]};return await this.watch(a,t,n,t)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length)throw new r.ArgumentsRequired(this.id+" watchTradesForSymbols() requires a non-empty array of symbols");await this.loadMarkets(),e=this.marketSymbols(e);const a="trades",o=[],n=[];for(let t=0;t<e.length;t++){const s=e[t];n.push(a+":"+s);const i={channel:a,instId:this.marketId(s)};o.push(i)}const d={op:"subscribe",args:o},h=this.getUrl(a,"public"),c=await this.watchMultiple(h,n,d,n);if(this.newUpdates){const e=this.safeValue(c,0),t=this.safeString(e,"symbol");s=c.getLimit(t,s)}return this.filterBySinceLimit(c,t,s,"timestamp",!0)}async unWatchTradesForSymbols(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const s="trades",i=[],r=[];for(let t=0;t<e.length;t++){const a=e[t];r.push("unsubscribe:trades:"+a);const o={channel:s,instId:this.marketId(a)};i.push(o)}const a={op:"unsubscribe",args:i},o=this.getUrl(s,"public");return await this.watchMultiple(o,r,a,r)}async unWatchTrades(e,t={}){return await this.unWatchTradesForSymbols([e],t)}handleTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeString(s,"instId"),o=this.safeSymbol(r),n=this.safeValue(t,"data",[]),d=this.safeInteger(this.options,"tradesLimit",1e3);for(let t=0;t<n.length;t++){const s=this.parseTrade(n[t]),r=i+":"+o;let h=this.safeValue(this.trades,o);void 0===h&&(h=new a.I3(d),this.trades[o]=h),h.append(s),e.resolve(h,r)}}async watchFundingRate(e,t={}){e=this.symbol(e);return(await this.watchFundingRates([e],t))[e]}async watchFundingRates(e,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s="funding-rate",i=[],r=[];for(let t=0;t<e.length;t++){const a=e[t];r.push(s+":"+a);const o={channel:s,instId:this.marketId(a)};i.push(o)}const a={op:"subscribe",args:i},o=this.getUrl(s,"public"),n=await this.watchMultiple(o,r,a,r);if(this.newUpdates){const e={};return e[this.safeString(n,"symbol")]=n,e}return this.filterByArray(this.fundingRates,"symbol",e)}handleFundingRate(e,t){const s=this.safeList(t,"data",[]);for(let t=0;t<s.length;t++){const i=s[t],r=this.parseFundingRate(i),a=r.symbol;this.fundingRates[a]=r,e.resolve(r,"funding-rate:"+r.symbol)}}async watchTicker(e,t={}){let s;[s,t]=this.handleOptionAndParams(t,"watchTicker","channel","tickers"),t.channel=s;e=this.market(e).symbol;const i=await this.watchTickers([e],t);return this.safeValue(i,e)}async watchTickers(e=void 0,t={}){let s;await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1),[s,t]=this.handleOptionAndParams(t,"watchTickers","channel","tickers");const i=await this.subscribeMultiple("public",s,e,t);return this.newUpdates?i:this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeValue(t,"data",[]),a=[];for(let e=0;e<r.length;e++){const t=this.parseTicker(r[e]),s=t.symbol;this.tickers[s]=t,a.push(t)}const o=this.findMessageHashes(e,i+"::");for(let t=0;t<o.length;t++){const s=o[t],i=s.split("::")[1].split(","),r=this.filterByArray(a,"symbol",i);Object.keys(r).length>0&&e.resolve(r,s)}return t}async watchLiquidationsForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="liquidations",a=[];if(void 0!==(e=this.marketSymbols(e,void 0,!0,!0)))for(let t=0;t<e.length;t++){const s=e[t];a.push(r+"::"+s)}else a.push(r);const o=this.getMarketFromSymbols(e);let n;[n,i]=this.handleMarketTypeAndParams("watchliquidationsForSymbols",o,i);const d="liquidation-orders";"spot"===n?n="SWAP":"future"===n&&(n="futures");const h={op:"subscribe",args:[{channel:d,instType:n.toUpperCase()}]},c=this.getUrl(d,"public"),l=await this.watchMultiple(c,a,h,a);return this.newUpdates?l:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s,!0)}handleLiquidation(e,t){const s=this.safeList(t,"data",[]);for(let t=0;t<s.length;t++){const i=s[t],r=this.parseWsLiquidation(i),o=this.safeString(r,"symbol");let n=this.safeValue(this.liquidations,o);if(void 0===n){const e=this.safeInteger(this.options,"liquidationsLimit",1e3);n=new a.I3(e)}n.append(r),this.liquidations[o]=n,e.resolve([r],"liquidations"),e.resolve([r],"liquidations::"+o)}}async watchMyLiquidationsForSymbols(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue2(i,"stop","trigger",!1);i=this.omit(i,["stop","trigger"]),await this.authenticate({access:r?"business":"private"});let a="myLiquidations";void 0!==(e=this.marketSymbols(e,void 0,!0,!0))&&(a+="::"+e.join(","));const o=await this.subscribe("private",a,"balance_and_position",void 0,i);return this.newUpdates?o:this.filterBySymbolsSinceLimit(this.liquidations,e,t,s,!0)}handleMyLiquidation(e,t){const s=this.safeList(t,"data",[]);for(let t=0;t<s.length;t++){const i=s[t];if("liquidation"!==this.safeString(i,"eventType"))return;const r=this.parseWsMyLiquidation(i),o=this.safeString(r,"symbol");let n=this.safeValue(this.liquidations,o);if(void 0===n){const e=this.safeInteger(this.options,"myLiquidationsLimit",1e3);n=new a.I3(e)}n.append(r),this.liquidations[o]=n,e.resolve([r],"myLiquidations"),e.resolve([r],"myLiquidations::"+o)}}parseWsMyLiquidation(e,t=void 0){const s=this.safeList(e,"posData",[]),i=this.safeDict(s,0,{}),r=this.safeString(i,"instId");t=this.safeMarket(r,t);const a=this.safeInteger(i,"uTIme");return this.safeLiquidation({info:e,symbol:this.safeSymbol(r,t),contracts:this.safeNumber(i,"pos"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(e,"avgPx"),baseValue:void 0,quoteValue:void 0,timestamp:a,datetime:this.iso8601(a)})}parseWsLiquidation(e,t=void 0){const s=this.safeList(e,"details",[]),i=this.safeDict(s,0,{}),r=this.safeString(e,"instId");t=this.safeMarket(r,t);const a=this.safeInteger(i,"ts");return this.safeLiquidation({info:e,symbol:this.safeSymbol(r,t),contracts:this.safeNumber(i,"sz"),contractSize:this.safeNumber(t,"contractSize"),price:this.safeNumber(i,"bkPx"),baseValue:void 0,quoteValue:void 0,timestamp:a,datetime:this.iso8601(a)})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets(),e=this.symbol(e);const a="candle"+this.safeString(this.timeframes,t,t),o=await this.subscribe("public",a,a,e,r);return this.newUpdates&&(i=o.getLimit(e,i)),this.filterBySinceLimit(o,s,i,0,!0)}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length||!Array.isArray(e[0]))throw new r.ArgumentsRequired(this.id+" watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT', '1m'], ['LTC/USDT', '5m']]");await this.loadMarkets();const a=[],o=[];for(let t=0;t<e.length;t++){const s=e[t],i=s[0],r=s[1],n=this.marketId(i),d="candle"+this.safeString(this.timeframes,r,r),h={channel:d,instId:n};a.push(h),o.push("multi:"+d+":"+i)}const n={op:"subscribe",args:a},d=this.getUrl("candle","public"),[h,c,l]=await this.watchMultiple(d,o,n,o);this.newUpdates&&(s=l.getLimit(h,s));const u=this.filterBySinceLimit(l,t,s,0,!0);return this.createOHLCVObject(h,c,u)}handleOHLCV(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeValue(t,"data",[]),o=this.safeString(s,"instId"),n=this.safeMarket(o),d=n.symbol,h=i.replace("candle",""),c=this.findTimeframe(h);for(let t=0;t<r.length;t++){const s=this.parseOHLCV(r[t],n);this.ohlcvs[d]=this.safeValue(this.ohlcvs,d,{});let o=this.safeValue(this.ohlcvs[d],c);if(void 0===o){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);o=new a.TG(e),this.ohlcvs[d][c]=o}o.append(s);const h=i+":"+n.id;e.resolve(o,h);const l="multi:"+i+":"+d;e.resolve([d,c,o],l)}}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){let i;if(await this.loadMarkets(),e=this.marketSymbols(e),[i,s]=this.handleOptionAndParams(s,"watchOrderBook","depth","books"),void 0!==t&&(1===t?i="bbo-tbt":t>1&&t<=5?i="books5":50===t?i="books50-l2-tbt":400===t&&(i="books")),"books-l2-tbt"===i||"books50-l2-tbt"===i){if(!this.checkRequiredCredentials(!1))throw new r.AuthenticationError(this.id+" watchOrderBook/watchOrderBookForSymbols requires authentication for this depth. Add credentials or change the depth option to books or books5");await this.authenticate({access:"public"})}const a=[],o=[];for(let t=0;t<e.length;t++){const s=e[t];o.push(i+":"+s);const r={channel:i,instId:this.marketId(s)};a.push(r)}const n={op:"subscribe",args:a},d=this.getUrl(i,"public");return(await this.watchMultiple(d,o,n,o)).limit()}async unWatchOrderBookForSymbols(e,t={}){let s;await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1),[s,t]=this.handleOptionAndParams(t,"watchOrderBook","depth","books");const i=this.safeInteger(t,"limit");void 0!==i&&(1===i?s="bbo-tbt":i>1&&i<=5?s="books5":50===i?s="books50-l2-tbt":400===i&&(s="books"));const r=[],a=[],o=[];for(let t=0;t<e.length;t++){const i=e[t];a.push(s+":"+i),o.push("unsubscribe:orderbook:"+i);const n={channel:s,instId:this.marketId(i)};r.push(n)}const n={op:"unsubscribe",args:r},d=this.getUrl(s,"public");return await this.watchMultiple(d,o,n,o)}async unWatchOrderBook(e,t={}){return await this.unWatchOrderBookForSymbols([e],t)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBookMessage(e,t,s,i,a=void 0){const o=this.safeValue(t,"asks",[]),n=this.safeValue(t,"bids",[]),d=s.asks,h=s.bids;this.handleDeltas(d,o),this.handleDeltas(h,n);const c=this.safeString(t,"instId"),l=this.safeSymbol(c,a),u=this.handleOption("watchOrderBook","checksum",!0),p=this.safeInteger(t,"seqId");if(u){const a=this.safeInteger(t,"prevSeqId"),o=s.nonce,n=d.length,c=h.length,u=[];for(let e=0;e<25;e++)e<c&&(u.push(this.numberToString(h[e][0])),u.push(this.numberToString(h[e][1]))),e<n&&(u.push(this.numberToString(d[e][0])),u.push(this.numberToString(d[e][1])));const p=u.join(":"),f=this.safeInteger(t,"checksum"),m=this.crc32(p,!0);let g;-1!==a&&o!==a&&(g=new r.InvalidNonce(this.id+" watchOrderBook received invalid nonce")),f!==m&&(g=new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(l))),void 0!==g&&(delete e.subscriptions[i],delete this.orderbooks[l],e.reject(g,i))}const f=this.safeInteger(t,"ts");return s.nonce=p,s.timestamp=f,s.datetime=this.iso8601(f),s}handleOrderBook(e,t){const s=this.safeDict(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeString(t,"action"),a=this.safeList(t,"data",[]),o=this.safeString(s,"instId"),n=this.safeMarket(o),d=n.symbol,h=this.safeInteger({"bbo-tbt":1,books:400,books5:5,"books-l2-tbt":400,"books50-l2-tbt":50},i),c=i+":"+d;if("snapshot"===r)for(let t=0;t<a.length;t++){const s=a[t],i=this.orderBook({},h);this.orderbooks[d]=i,i.symbol=d,this.handleOrderBookMessage(e,s,i,c),e.resolve(i,c)}else if("update"===r){if(d in this.orderbooks){const t=this.orderbooks[d];for(let s=0;s<a.length;s++){const i=a[s];this.handleOrderBookMessage(e,i,t,c,n),e.resolve(t,c)}}}else if("books5"===i||"bbo-tbt"===i){d in this.orderbooks||(this.orderbooks[d]=this.orderBook({},h));const t=this.orderbooks[d];for(let s=0;s<a.length;s++){const i=a[s],r=this.safeInteger(i,"ts"),o=this.parseOrderBook(i,d,r,"bids","asks",0,1);t.reset(o),e.resolve(t,c)}}return t}async authenticate(e={}){this.checkRequiredCredentials();const t=this.safeString(e,"access","private");e=this.omit(e,["access"]);const s=this.getUrl("users",t),i="authenticated",r=this.client(s),a=r.future(i);if(void 0===this.safeValue(r.subscriptions,i)){const t=this.seconds().toString(),r=t+"GET"+"/users/self/verify",a=this.hmac(this.encode(r),this.encode(this.secret),o.s,"base64"),n={op:"login",args:[{apiKey:this.apiKey,passphrase:this.password,timestamp:t,sign:a}]},d=this.extend(n,e);this.watch(s,i,d,i)}return await a}async watchBalance(e={}){return await this.loadMarkets(),await this.authenticate(),await this.subscribe("private","account","account",void 0,e)}handleBalanceAndPosition(e,t){this.handleMyLiquidation(e,t)}handleBalance(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r="spot",a=this.parseTradingBalance(t),o=this.safeValue(this.balance,r,{}),n=this.deepExtend(o,a);this.balance[r]=this.safeBalance(n),e.resolve(this.balance[r],i)}orderToTrade(e,t=void 0){const s=this.safeValue(e,"info",{}),i=this.safeInteger(s,"fillTime"),r=this.safeString(s,"fillFeeCcy"),a="T"===this.safeString(s,"execType","");return this.safeTrade({info:s,timestamp:i,datetime:this.iso8601(i),symbol:this.safeString(e,"symbol"),id:this.safeString(s,"tradeId"),order:this.safeString(e,"id"),type:this.safeString(e,"type"),takerOrMaker:a?"taker":"maker",side:this.safeString(e,"side"),price:this.safeNumber(s,"fillPx"),amount:this.safeNumber(s,"fillSz"),cost:this.safeNumber(e,"cost"),fee:{cost:this.safeNumber(s,"fillFee"),currency:this.safeCurrencyCode(r)}},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handleOptionAndParams(i,"watchMyTrades","type","ANY");const a=this.safeBool(i,"stop",!1);i=this.omit(i,["stop"]),await this.loadMarkets(),await this.authenticate({access:a?"business":"private"});const o=a?"orders-algo":"orders";let n,d=o+"::myTrades";void 0!==e&&(n=this.market(e),e=n.symbol,r=n.type,d=d+"::"+e),"future"===r&&(r="futures");let h,c=r.toUpperCase();[h,i]=this.handleMarginModeAndParams("watchMyTrades",i),"SPOT"===c&&void 0!==h&&(c="MARGIN");const l={instType:c},u=await this.subscribe("private",d,o,void 0,this.extend(l,i));return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySymbolSinceLimit(u,e,t,s,!0)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);const r={instType:"ANY"},a="positions";let o;if(void 0===(e=this.marketSymbols(e))){const e={op:"subscribe",args:[{channel:"positions",instType:"ANY"}]},t=this.getUrl(a,"private");o=await this.watch(t,a,e,a)}else o=await this.subscribeMultiple("private",a,e,this.extend(r,i));return this.newUpdates?o:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}handlePositions(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel",""),r=this.safeValue(t,"data",[]);void 0===this.positions&&(this.positions=new a.Hk);const o=this.positions,n=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.parsePosition(t);if(0===s.contracts){s.side="long";const e=this.clone(s);e.side="short",o.append(e),n.push(e)}n.push(s),o.append(s)}const d=this.findMessageHashes(e,i+"::");for(let t=0;t<d.length;t++){const s=d[t],i=s.split("::")[1].split(","),r=this.filterByArray(n,"symbol",i,!1);this.isEmpty(r)||e.resolve(r,s)}e.resolve(n,i)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){let r;[r,i]=this.handleOptionAndParams(i,"watchOrders","type","ANY");const a=this.safeValue2(i,"stop","trigger",!1);let o;i=this.omit(i,["stop","trigger"]),await this.loadMarkets(),await this.authenticate({access:a?"business":"private"}),void 0!==e&&(o=this.market(e),e=o.symbol,r=o.type),"future"===r&&(r="futures");let n,d=r.toUpperCase();[n,i]=this.handleMarginModeAndParams("watchOrders",i),"SPOT"===d&&void 0!==n&&(d="MARGIN");const h={instType:d},c=a?"orders-algo":"orders",l=await this.subscribe("private",c,c,e,this.extend(h,i));return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySymbolSinceLimit(l,e,t,s,!0)}handleOrders(e,t,s=void 0){this.handleMyTrades(e,t);const i=this.safeValue(t,"arg",{}),r=this.safeString(i,"channel"),o=this.safeValue(t,"data",[]);if(o.length>0){const t=this.safeInteger(this.options,"ordersLimit",1e3);void 0===this.orders&&(this.orders=new a.Pt(t),this.triggerOrders=new a.Pt(t));const s="orders-algo"===r?this.triggerOrders:this.orders,i=[],n=this.parseOrders(o);for(let e=0;e<n.length;e++){const t=n[e];s.append(t);const r=t.symbol,a=this.market(r);i.push(a.id)}e.resolve(s,r);for(let t=0;t<i.length;t++){const a=r+":"+i[t];e.resolve(s,a)}}}handleMyTrades(e,t){const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeValue(t,"data",[]),o=[];for(let e=0;e<r.length;e++){const t=r[e];if(this.safeString(t,"tradeId","").length>0){const e=this.parseOrder(t);o.push(e)}}if(0===o.length)return;if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const n=this.myTrades,d={};for(let e=0;e<o.length;e++){const t=o[e],s=this.orderToTrade(t);n.append(s);d[s.symbol]=!0}const h=i+"::myTrades";e.resolve(this.myTrades,h);const c=Object.keys(d);for(let t=0;t<c.length;t++){const s=h+"::"+c[t];e.resolve(this.orders,s)}}async createOrderWs(e,t,s,i,a=void 0,o={}){await this.loadMarkets(),await this.authenticate();const n=this.getUrl("private","private"),d=this.milliseconds().toString();let h;[h,o]=this.handleOptionAndParams(o,"createOrderWs","op","batch-orders");const c=this.createOrderRequest(e,t,s,i,a,o),l=this.safeString(c,"ordType");if("trigger"===l||"conditional"===l||"oco"===t||"move_order_stop"===t||"iceberg"===t||"twap"===t)throw new r.BadRequest(this.id+' createOrderWs() does not support algo trading. this.options["createOrderWs"]["op"] must be either order or batch-order');if("order"!==h&&"batch-orders"!==h)throw new r.BadRequest(this.id+' createOrderWs() does not support algo trading. this.options["createOrderWs"]["op"] must be either order or privatePostTradeOrder or privatePostTradeOrderAlgo');const u={id:d,op:h,args:[c]};return await this.watch(n,d,u,d)}handlePlaceOrders(e,t){const s=this.safeString(t,"id");let i=this.safeValue(t,"data",[]);if(i=this.filterBy(i,"sCode","0"),this.isEmpty(i)){const s=this.safeString(t,"op"),i=this.json(t);this.handleErrors(void 0,void 0,e.url,s,void 0,i,t,void 0,void 0)}const r=this.parseOrders(i,void 0,void 0,void 0),a=this.safeDict(r,0,{});e.resolve(a,s)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets(),await this.authenticate();const n=this.getUrl("private","private"),d=this.milliseconds().toString();let h;[h,o]=this.handleOptionAndParams(o,"editOrderWs","op","amend-order");const c={id:d,op:h,args:[this.editOrderRequest(e,t,s,i,r,a,o)]};return await this.watch(n,d,this.extend(c,o),d)}async cancelOrderWs(e,t=void 0,s={}){if(void 0===t)throw new r.BadRequest(this.id+" cancelOrderWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const i=this.getUrl("private","private"),a=this.milliseconds().toString(),o=this.safeString2(s,"clOrdId","clientOrderId");s=this.omit(s,["clientOrderId","clOrdId"]);const n={instId:this.marketId(t)};void 0!==o?n.clOrdId=o:n.ordId=e;const d={id:a,op:"cancel-order",args:[this.extend(n,s)]};return await this.watch(i,a,d,a)}async cancelOrdersWs(e,t=void 0,s={}){const i=e.length;if(i>20)throw new r.BadRequest(this.id+" cancelOrdersWs() accepts up to 20 ids at a time");if(void 0===t)throw new r.BadRequest(this.id+" cancelOrdersWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.getUrl("private","private"),o=this.milliseconds().toString(),n=[];for(let s=0;s<i;s++){const i={instId:this.marketId(t),ordId:e[s]};n.push(i)}const d={id:o,op:"batch-cancel-orders",args:n};return await this.watch(a,o,this.deepExtend(d,s),o)}async cancelAllOrdersWs(e=void 0,t={}){if(void 0===e)throw new r.BadRequest(this.id+" cancelAllOrdersWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const s=this.market(e);if("option"!==s.type)throw new r.BadRequest(this.id+"cancelAllOrdersWs is only applicable to Option in Portfolio Margin mode, and MMP privilege is required.");const i=this.getUrl("private","private"),a=this.milliseconds().toString(),o={id:a,op:"mass-cancel",args:[this.extend({instType:"OPTION",instFamily:s.id},t)]};return await this.watch(i,a,o,a)}handleCancelAllOrders(e,t){const s=this.safeString(t,"id"),i=this.safeValue(t,"data",[]);e.resolve(i,s)}handleSubscriptionStatus(e,t){return t}handleAuthenticate(e,t){this.safeValue(e.futures,"authenticated").resolve(!0)}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){const s=this.safeString(t,"code");try{if(s&&"0"!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e);const i=this.safeValue(t,"msg");throw void 0!==i&&this.throwBroadlyMatchedException(this.exceptions.broad,i,e),new r.ExchangeError(e)}}catch(s){const i=this.safeString(t,"id");return void 0!==i?(e.reject(s,i),!1):(e.reject(s),!1)}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if("pong"===t)return void this.handlePong(e,t);const s=this.safeString2(t,"event","op");if(void 0!==s){const i={login:this.handleAuthenticate,subscribe:this.handleSubscriptionStatus,unsubscribe:this.handleUnsubscription,order:this.handlePlaceOrders,"batch-orders":this.handlePlaceOrders,"amend-order":this.handlePlaceOrders,"batch-amend-orders":this.handlePlaceOrders,"cancel-order":this.handlePlaceOrders,"mass-cancel":this.handleCancelAllOrders},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}else{const s=this.safeValue(t,"arg",{}),i=this.safeString(s,"channel"),r={"bbo-tbt":this.handleOrderBook,books:this.handleOrderBook,books5:this.handleOrderBook,"books50-l2-tbt":this.handleOrderBook,"books-l2-tbt":this.handleOrderBook,tickers:this.handleTicker,positions:this.handlePositions,"index-tickers":this.handleTicker,"sprd-tickers":this.handleTicker,"block-tickers":this.handleTicker,trades:this.handleTrades,account:this.handleBalance,"funding-rate":this.handleFundingRate,orders:this.handleOrders,"orders-algo":this.handleOrders,"liquidation-orders":this.handleLiquidation,balance_and_position:this.handleBalanceAndPosition},a=this.safeValue(r,i);void 0===a?0===i.indexOf("candle")&&this.handleOHLCV(e,t):a.call(this,e,t)}}handleUnSubscriptionTrades(e,t){const s="trades:"+t,i="unsubscribe:trades:"+t;s in e.subscriptions&&delete e.subscriptions[s],i in e.subscriptions&&delete e.subscriptions[i],delete this.trades[t];const a=new r.UnsubscribeError(this.id+" "+s);e.reject(a,s),e.resolve(!0,i)}handleUnsubscriptionOrderBook(e,t,s){const i=s+":"+t,a="unsubscribe:orderbook:"+t;i in e.subscriptions&&delete e.subscriptions[i],a in e.subscriptions&&delete e.subscriptions[a],delete this.orderbooks[t];const o=new r.UnsubscribeError(this.id+" "+i);e.reject(o,i),e.resolve(!0,a)}handleUnsubscription(e,t){const s=this.safeDict(t,"arg",{}),i=this.safeString(s,"channel"),r=this.safeString(s,"instId"),a=this.safeSymbol(r);"trades"===i?this.handleUnSubscriptionTrades(e,a):(i.startsWith("bbo")||i.startsWith("book"))&&this.handleUnsubscriptionOrderBook(e,a,i)}}},4357:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(3573),r=s(2079),a=s(2931),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!1,watchTradesForSymbols:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://streams.onetrading.com/"}},options:{bp_remaining_quota:200,timeframes:{"1m":{unit:"MINUTES",period:1},"5m":{unit:"MINUTES",period:5},"15m":{unit:"MINUTES",period:15},"30m":{unit:"MINUTES",period:30},"1h":{unit:"HOURS",period:1},"4h":{unit:"HOURS",period:4},"1d":{unit:"DAYS",period:1},"1w":{unit:"WEEKS",period:1},"1M":{unit:"MONTHS",period:1}}},streaming:{},exceptions:{}})}async watchBalance(e={}){await this.authenticate(e);const t=this.urls.api.ws,s={type:"SUBSCRIBE",bp_remaining_quota:this.safeInteger(this.options,"bp_remaining_quota",200),channels:[{name:"ACCOUNT_HISTORY"}]},i=this.deepExtend(s,e);return await this.watch(t,"balance",i,"ACCOUNT_HISTORY",i)}handleBalanceSnapshot(e,t){this.balance=this.parseBalance(t);e.resolve(this.balance,"balance")}async watchTicker(e,t={}){await this.loadMarkets();const s="ticker."+(e=this.market(e).symbol);return await this.watchMany(s,{type:"SUBSCRIBE",channels:[{name:"MARKET_TICKER",price_points_mode:"INLINE"}]},"MARKET_TICKER",[e],t)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),void 0===(e=this.marketSymbols(e))&&(e=[]);const s=await this.watchMany("tickers",{type:"SUBSCRIBE",channels:[{name:"MARKET_TICKER",price_points_mode:"INLINE"}]},"MARKET_TICKER",e,t);return this.filterByArray(s,"symbol",e)}handleTicker(e,t){const s=this.safeValue(t,"ticker_updates",[]),i=this.safeString(t,"time");for(let t=0;t<s.length;t++){const r=s[t],a=this.safeString(r,"instrument"),o=this.safeSymbol(a);this.tickers[o]=this.parseWSTicker(r);const n=this.parse8601(i);this.tickers[o].timestamp=n,this.tickers[o].datetime=this.iso8601(n),e.resolve(this.tickers[o],"ticker."+o)}e.resolve(this.tickers,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(e,"instrument");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:this.safeString(e,"last_price"),last:this.safeString(e,"last_price"),previousClose:void 0,change:this.safeString(e,"price_change"),percentage:this.safeString(e,"price_change_percentage"),average:void 0,baseVolume:void 0,quoteVolume:this.safeNumber(e,"volume"),info:e},t)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="myTrades";if(void 0!==e){r+=":"+(e=this.market(e).symbol)}await this.authenticate(i);const a=this.urls.api.ws,o={type:"SUBSCRIBE",bp_remaining_quota:this.safeInteger(this.options,"bp_remaining_quota",200),channels:[{name:"ACCOUNT_HISTORY"}]},n=this.deepExtend(o,i);let d=await this.watch(a,r,n,"ACCOUNT_HISTORY",n);this.newUpdates&&(s=d.getLimit(e,s)),d=this.filterBySymbolSinceLimit(d,e,t,s);return 0===d.length?await this.watchMyTrades(e,t,s,i):d}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="book:"+(e=this.market(e).symbol);let r=0;void 0!==t&&(r=t);const a={type:"SUBSCRIBE",channels:[{name:"ORDER_BOOK",depth:r}]};return(await this.watchMany(i,a,"ORDER_BOOK",[e],s)).limit()}handleOrderBook(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"instrument_code"),a=this.safeSymbol(i),o=this.safeString(t,"time"),n=this.parse8601(o),d="book:"+a;let h=this.safeValue(this.orderbooks,a);if(void 0===h&&(h=this.orderBook({})),"ORDER_BOOK_SNAPSHOT"===s){const e=this.parseOrderBook(t,a,n,"bids","asks");h.reset(e)}else{if("ORDER_BOOK_UPDATE"!==s)throw new r.NotSupported(this.id+" watchOrderBook() did not recognize message type "+s);{const e=this.safeValue(t,"changes",[]);this.handleDeltas(h,e)}}h.nonce=n,h.timestamp=n,h.datetime=this.iso8601(n),this.orderbooks[a]=h,e.resolve(h,d)}handleDelta(e,t){const s=this.parseBidAsk(t,1,2),i=this.safeString(t,0);if("BUY"===i){e.bids.storeArray(s)}else{if("SELL"!==i)throw new r.NotSupported(this.id+" watchOrderBook () received unknown change type "+this.json(t));e.asks.storeArray(s)}}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="orders";if(void 0!==e){r+=":"+(e=this.market(e).symbol)}await this.authenticate(i);const a=this.urls.api.ws,o=this.safeString(i,"channel","ACCOUNT_HISTORY"),n={type:"SUBSCRIBE",bp_remaining_quota:this.safeInteger(this.options,"bp_remaining_quota",200),channels:[{name:o}]},d=this.deepExtend(n,i);let h=await this.watch(a,r,d,o,d);this.newUpdates&&(s=h.getLimit(e,s)),h=this.filterBySymbolSinceLimit(h,e,t,s);return 0===h.length?await this.watchOrders(e,t,s,i):h}handleTrading(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const s=this.parseTradingOrder(t);this.orders.append(s),e.resolve(this.orders,"orders:"+s.symbol),e.resolve(this.orders,"orders")}parseTradingOrder(e,t=void 0){const s=this.safeString(e,"time"),i=this.safeString(e,"instrument_code"),r=this.safeSymbol(i,t,"_");return this.safeOrder({id:this.safeString(e,"order_id"),clientOrderId:this.safeString(e,"client_id"),info:e,timestamp:this.parse8601(s),datetime:s,lastTradeTimestamp:void 0,symbol:r,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeStringLower(e,"side"),price:this.safeNumber2(e,"price","matched_price"),stopPrice:this.safeNumber(e,"trigger_price"),amount:this.safeNumber(e,"amount"),cost:void 0,average:void 0,filled:void 0,remaining:this.safeString(e,"remaining"),status:this.parseTradingOrderStatus(this.safeString(e,"status")),fee:void 0,trades:void 0},t)}parseTradingOrderStatus(e){return this.safeString({CANCELLED:"canceled",SELF_TRADE:"rejected",FILLED_FULLY:"closed",INSUFFICIENT_FUNDS:"rejected",INSUFFICIENT_LIQUIDITY:"rejected",TIME_TO_MARKET_EXCEEDED:"rejected",LAST_PRICE_UNKNOWN:"rejected"},e,e)}handleOrders(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const s=this.safeValue(t,"orders",[]);if(0===s.length)return;const i=this.orders;for(let t=0;t<s.length;t++){const r=this.parseOrder(s[t]);let a=this.safeString(r,"symbol","");i.append(r),e.resolve(this.orders,"orders:"+a);const o=this.safeValue(s[t],"trades",[]);for(let t=0;t<o.length;t++){const s=this.parseTrade(o[t]);a=this.safeString(s,"symbol",a),this.myTrades.append(s),e.resolve(this.myTrades,"myTrades:"+a)}}e.resolve(this.orders,"orders"),e.resolve(this.myTrades,"myTrades")}handleAccountUpdate(e,t){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}let s;const i=this.orders,r=this.safeValue(t,"update",{}),n=this.safeString(r,"type");if("ORDER_REJECTED"===n||"ORDER_CLOSED"===n||"STOP_ORDER_TRIGGERED"===n){const e=this.safeString(r,"order_id"),t=this.safeString2(r,"time","timestamp"),a=this.filterByArray(this.orders,"id",e,!1);s=this.safeValue(a,0,{}).symbol;const d=this.safeString(r,"filled_amount");let h=this.parseWsOrderStatus(n);"ORDER_CLOSED"===n&&o.A.stringEq(d,"0")&&(h="canceled");const c={id:e,symbol:s,status:h,timestamp:this.parse8601(t),datetime:t};i.append(c)}else{const e=this.parseOrder(r);s=this.safeString(e,"symbol",""),i.append(e)}e.resolve(this.orders,"orders:"+s),e.resolve(this.orders,"orders");const d=["locked","unlocked","spent","spent_on_fees","credited","deducted"];for(let e=0;e<d.length;e++){const t=this.safeValue(r,d[e]);void 0!==t&&this.updateBalance(t)}if(e.resolve(this.balance,"balance"),"TRADE_SETTLED"===n){const t=this.parseTrade(r);s=this.safeString(t,"symbol",""),this.myTrades.append(t),e.resolve(this.myTrades,"myTrades:"+s),e.resolve(this.myTrades,"myTrades")}}parseWsOrderStatus(e){return this.safeString({ORDER_REJECTED:"rejected",ORDER_CLOSED:"closed",STOP_ORDER_TRIGGERED:"triggered"},e,e)}updateBalance(e){const t=this.safeString(e,"currency_code"),s=this.safeCurrencyCode(t),i=this.account();i.free=this.safeString(e,"new_available"),i.used=this.safeString(e,"new_locked"),this.balance[s]=i,this.balance=this.safeBalance(this.balance)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.market(e);e=o.symbol;const n=o.id,d=this.urls.api.ws,h=this.safeValue(this.options,"timeframes",{});if(void 0===this.safeValue(h,t))throw new r.NotSupported(this.id+" this interval is not supported, please provide one of the supported timeframes");const c="ohlcv."+e+"."+t,l="CANDLESTICKS",u=this.safeValue(this.clients,d);let p="SUBSCRIBE",f={};if(void 0!==u)if(f=this.safeValue(u.subscriptions,l),void 0!==f){const e=this.safeValue(f,n,{});this.safeBool(e,t,!1)||(p="UPDATE_SUBSCRIPTION",u.subscriptions[l]=void 0)}else f={};void 0===this.safeValue(f,n)&&(f[n]={}),f[n][t]=!0;const m=[],g=Object.keys(f);for(let e=0;e<g.length;e++){const s=Object.keys(f[g[e]]);for(let i=0;i<s.length;i++){const s=this.safeValue(h,t),i={instrument_code:g[e],time_granularity:s};m.push(i)}}const v={type:p,channels:[{name:"CANDLESTICKS",properties:m}]},y=await this.watch(d,c,this.deepExtend(v,a),l,f);return this.newUpdates&&(i=y.getLimit(e,i)),this.filterBySinceLimit(y,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeString(t,"instrument_code"),i=this.safeSymbol(s),r=this.safeString(t,"time"),o=this.safeValue(t,"granularity"),n=this.safeValue(this.options,"timeframes",{}),d=this.findTimeframe(o,n),h="ohlcv."+i+"."+d,c=[this.parse8601(r),this.safeNumber(t,"open"),this.safeNumber(t,"high"),this.safeNumber(t,"low"),this.safeNumber(t,"close"),this.safeNumber(t,"volume")];this.ohlcvs[i]=this.safeValue(this.ohlcvs,i,{});let l=this.safeValue(this.ohlcvs[i],d);if(void 0===l){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);l=new a.TG(e)}l.append(c),this.ohlcvs[i][d]=l,e.resolve(l,h)}findTimeframe(e,t=void 0){t=t||this.timeframes;const s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i];if(t[r].unit===e.unit&&t[r].period===e.period)return r}}handleSubscriptions(e,t){return t}handleHeartbeat(e,t){return t}handleErrorMessage(e,t){throw new r.ExchangeError(this.id+" "+this.json(t))}handleMessage(e,t){if(void 0!==this.safeValue(t,"error"))return void this.handleErrorMessage(e,t);const s=this.safeValue(t,"type"),i={ORDER_BOOK_UPDATE:this.handleOrderBook,ORDER_BOOK_SNAPSHOT:this.handleOrderBook,ACTIVE_ORDERS_SNAPSHOT:this.handleOrders,INACTIVE_ORDERS_SNAPSHOT:this.handleOrders,ACCOUNT_UPDATE:this.handleAccountUpdate,BALANCES_SNAPSHOT:this.handleBalanceSnapshot,SUBSCRIPTIONS:this.handleSubscriptions,SUBSCRIPTION_UPDATED:this.handleSubscriptions,PRICE_TICK:this.handleTicker,PRICE_TICK_HISTORY:this.handleSubscriptions,HEARTBEAT:this.handleHeartbeat,MARKET_TICKER_UPDATES:this.handleTicker,PRICE_POINT_UPDATES:this.handlePricePointUpdates,CANDLESTICK_SNAPSHOT:this.handleOHLCV,CANDLESTICK:this.handleOHLCV,AUTHENTICATED:this.handleAuthenticationMessage,FILL:this.handleTrading,DONE:this.handleTrading,BOOKED:this.handleTrading,UPDATE:this.handleTrading,TRACKED:this.handleTrading,TRIGGERED:this.handleTrading,STOP_TRACKED:this.handleTrading,STOP_TRIGGERED:this.handleTrading},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}handlePricePointUpdates(e,t){return t}handleAuthenticationMessage(e,t){const s=this.safeValue(e.futures,"authenticated");return void 0!==s&&s.resolve(!0),t}async watchMany(e,t,s,i=[],r={}){let a=[];a=0===i.length?Object.keys(this.markets_by_id):this.marketIds(i);const o=this.urls.api.ws,n=this.safeValue(this.clients,o);let d="SUBSCRIBE",h={};if(void 0!==n)if(h=this.safeValue(n.subscriptions,s),void 0!==h)for(let e=0;e<a.length;e++){const t=a[e];this.safeBool(h,t,!1)||(d="UPDATE_SUBSCRIPTION",n.subscriptions[s]=void 0)}else h={};for(let e=0;e<a.length;e++){h[a[e]]=!0}return t.type=d,t.channels[0].instrument_codes=Object.keys(h),await this.watch(o,e,this.deepExtend(t,r),s,h)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=s.future("authenticated");if(void 0===this.safeValue(s.subscriptions,i)){this.checkRequiredCredentials();const s={type:"AUTHENTICATE",api_token:this.apiKey};this.watch(t,i,this.extend(s,e),i)}return await r}}},550:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(6358),r=s(2079),a=s(4852),o=s(2931);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrderBook:!0,watchOrderBookForSymbols:!0,watchOHLCV:!0,watchOHLCVForSymbols:!0,watchOrders:!0,watchMyTrades:!1,watchTicker:!0,watchTickers:!0,watchBalance:!0,createOrderWs:!0,editOrderWs:!0,cancelOrderWs:!0,cancelOrdersWs:!0},urls:{api:{ws:"wss://api.ox.fun/v2/websocket",test:"wss://stgapi.ox.fun/v2/websocket"}},options:{timeframes:{"1m":"60s","3m":"180s","5m":"300s","15m":"900s","30m":"1800s","1h":"3600s","2h":"7200s","4h":"14400s","6h":"21600s","12h":"43200s","1d":"86400s"},watchOrderBook:{channel:"depth"}},streaming:{ping:this.ping,keepAlive:5e4}})}async subscribeMultiple(e,t,s={}){const i=this.urls.api.ws,r={op:"subscribe",args:t};return await this.watchMultiple(i,e,this.extend(r,s),e)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1);const r=[],a=[];for(let t=0;t<e.length;t++){const s=e[t],i="trades:"+s;a.push(i);const o="trade:"+this.marketId(s);r.push(o)}const o=await this.subscribeMultiple(a,r,i);if(this.newUpdates){const e=this.safeDict(o,0,{}),t=this.safeString(e,"symbol");s=o.getLimit(t,s)}return this.filterBySinceLimit(o,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeList(t,"data",[]);for(let t=0;t<s.length;t++){const i=this.safeDict(s,t,{}),r=this.parseWsTrade(i),a=this.safeString(r,"symbol"),n="trades:"+a;if(!(a in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.trades[a]=new o.I3(e)}const d=this.trades[a];d.append(r),e.resolve(d,n)}}parseWsTrade(e,t=void 0){const s=this.safeString(e,"marketCode");t=this.safeMarket(s,t);const i=this.safeInteger(e,"timestamp");return this.safeTrade({info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,id:this.safeString(e,"tradeId"),order:void 0,type:void 0,takerOrMaker:this.safeStringLower(e,"matchType"),side:this.safeStringLower(e,"side"),price:this.safeNumber(e,"price"),amount:this.safeNumber(e,"quantity"),cost:void 0,fee:void 0})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeDict(this.options,"timeframes",{}),n="candles"+this.safeString(o,t,t)+":"+a.id,d="ohlcv:"+e+":"+t,h=this.urls.api.ws,c={op:"subscribe",args:[n]},l=await this.watch(h,d,this.extend(c,r),d);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}async watchOHLCVForSymbols(e,t=void 0,s=void 0,i={}){if(0===e.length||!Array.isArray(e[0]))throw new r.ArgumentsRequired(this.id+" watchOHLCVForSymbols() requires a an array of symbols and timeframes, like  [['BTC/USDT:OX', '1m'], ['OX/USDT', '5m']]");await this.loadMarkets();const a=[],o=[],n=this.safeDict(this.options,"timeframes",{});for(let t=0;t<e.length;t++){const s=e[t],i=s[0],r=s[1],d=this.marketId(i),h="candles"+this.safeString(n,r,r)+":"+d;a.push(h);const c="multi:ohlcv:"+i+":"+r;o.push(c)}const[d,h,c]=await this.subscribeMultiple(o,a,i);this.newUpdates&&(s=c.getLimit(d,s));const l=this.filterBySinceLimit(c,t,s,0,!0);return this.createOHLCVObject(d,h,l)}handleOHLCV(e,t){const s=this.safeString(t,"table").split("candles"),i=this.safeString(s,1,""),r=this.findTimeframe(i),a=this.safeList(t,"data",[]),n=this.safeDict(a,0,{}),d=this.safeString(n,"marketCode"),h=this.safeMarket(d),c=this.safeSymbol(d,h);if(c in this.ohlcvs||(this.ohlcvs[c]={}),!(r in this.ohlcvs[c])){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);this.ohlcvs[c][r]=new o.TG(e)}const l=this.safeList(n,"candle",[]),u=this.parseWsOHLCV(l,h),p=this.ohlcvs[c][r];p.append(u);const f="ohlcv:"+c+":"+r;e.resolve(p,f);const m="multi:"+f;e.resolve([c,r,p],m)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,6)]}async watchOrderBook(e,t=void 0,s={}){return await this.watchOrderBookForSymbols([e],t,s)}async watchOrderBookForSymbols(e,t=void 0,s={}){await this.loadMarkets(),e=this.marketSymbols(e);let i="depth";const r=this.safeDict(this.options,"watchOrderBook",{}),a=this.safeString(r,"channel");void 0!==a?i=a:void 0!==t&&(t<=5?i="depthL5":t<=10?i="depthL10":t<=25&&(i="depthL25"));const o=[],n=[];for(let t=0;t<e.length;t++){const s=e[t],r="orderbook:"+s;n.push(r);const a=i+":"+this.marketId(s);o.push(a)}return(await this.subscribeMultiple(n,o,s)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"marketCode"),r=this.safeSymbol(i),a=this.safeInteger(s,"timestamp"),o="orderbook:"+r;r in this.orderbooks||(this.orderbooks[r]=this.orderBook({}));const n=this.orderbooks[r],d=this.parseOrderBook(s,r,a,"asks","bids");n.reset(d),n.nonce=this.safeInteger(s,"seqNum"),this.orderbooks[r]=n,e.resolve(n,o)}async watchTicker(e,t={}){const s=await this.watchTickers([e],t);return this.safeValue(s,e)}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=void 0===e;let i=e;const r=[];s&&(i=this.symbols,r.push("ticker:all"));const a=[];for(let e=0;e<i.length;e++){const t=i[e],o="tickers:"+t;a.push(o);const n=this.marketId(t);s||r.push("ticker:"+n)}const o=await this.subscribeMultiple(a,r,t);if(this.newUpdates){const e={};return e[o.symbol]=o,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeList(t,"data",[]);for(let t=0;t<s.length;t++){const i=this.safeDict(s,t,{}),r=this.parseTicker(i),a=r.symbol,o="tickers:"+a;this.tickers[a]=r,e.resolve(r,o)}}async watchBalance(e={}){await this.loadMarkets(),this.authenticate();const t="balance",s=this.urls.api.ws,i={op:"subscribe",args:["balance:all"]};return await this.watch(s,t,this.extend(i,e),t)}handleBalance(e,t){const s=this.safeList(t,"data"),i=this.safeInteger(t,"timestamp");this.balance.info=t,this.balance.timestamp=i,this.balance.datetime=this.iso8601(i);for(let e=0;e<s.length;e++){const t=this.safeDict(s,e,{}),i=this.safeString(t,"instrumentId"),r=this.safeCurrencyCode(i);r in this.balance||(this.balance[r]=this.account());const a=this.balance[r];a.total=this.safeString(t,"total"),a.used=this.safeString(t,"reserved"),a.free=this.safeString(t,"available"),this.balance[r]=a}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();const r=void 0===e;let a=e;const o=[];r&&(a=this.symbols,o.push("position:all"));const n=[];for(let e=0;e<a.length;e++){const t=a[e],s="positions:"+t;n.push(s);const i=this.marketId(t);r||o.push("position:"+i)}const d=await this.subscribeMultiple(n,o,i);return this.newUpdates?d:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}handlePositions(e,t){void 0===this.positions&&(this.positions=new o.Hk);const s=this.positions,i=this.safeList(t,"data",[]);for(let t=0;t<i.length;t++){const r=this.safeDict(i,t,{}),a=this.parseWsPosition(r),o="positions:"+a.symbol;s.append(a),e.resolve(a,o)}}parseWsPosition(e,t=void 0){const s=this.safeString(e,"instrumentId");return t=this.safeMarket(s,t),this.safePosition({info:e,id:void 0,symbol:t.symbol,notional:void 0,marginMode:"cross",liquidationPrice:this.safeNumber(e,"estLiquidationPrice"),entryPrice:this.safeNumber(e,"entryPrice"),unrealizedPnl:this.safeNumber(e,"positionPnl"),realizedPnl:void 0,percentage:void 0,contracts:this.safeNumber(e,"quantity"),contractSize:void 0,markPrice:void 0,lastPrice:void 0,side:void 0,hedged:void 0,timestamp:void 0,datetime:void 0,lastUpdateTimestamp:this.safeInteger(e,"lastUpdated"),maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,collateral:void 0,initialMargin:void 0,initialMarginPercentage:void 0,leverage:void 0,marginRatio:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate();let r="orders",a="order:";const o=this.safeMarket(e);void 0===e?a+="all":(r+=":"+e,a+=":"+o.id);const n={op:"subscribe",args:[a]},d=this.urls.api.ws,h=await this.watch(d,r,n,r);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeList(t,"data",[]);let i="orders";if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new o.Pt(e)}const r=this.orders;for(let t=0;t<s.length;t++){const a=this.safeDict(s,t,{}),o=this.parseOrder(a);r.append(o),i+=":"+o.symbol,e.resolve(this.orders,i)}}async createOrderWs(e,t,s,i,r=void 0,a={}){await this.loadMarkets(),await this.authenticate();const o=this.nonce().toString(),n={op:"placeorder",tag:o};a=this.omit(a,"tag");const d=this.createOrderRequest(e,t,s,i,r,a);void 0===this.safeInteger(d,"timestamp")&&(d.timestamp=this.milliseconds()),n.data=d;const h=this.urls.api.ws;return await this.watch(h,o,n,o)}async editOrderWs(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets(),await this.authenticate();const n=this.nonce().toString(),d={op:"modifyorder",tag:n};o=this.omit(o,"tag");let h=this.createOrderRequest(t,s,i,r,a,o);h=this.extend(h,{orderId:e});void 0===this.safeInteger(h,"timestamp")&&(h.timestamp=this.milliseconds()),d.data=h;const c=this.urls.api.ws;return await this.watch(c,n,d,n)}handlePlaceOrders(e,t){const s=this.safeString(t,"tag");if(!this.safeBool(t,"submitted")){const s=this.safeString(t,"event"),i=this.json(t),r=this.safeInteger(t,"code");this.handleErrors(r,void 0,e.url,s,void 0,i,t,void 0,void 0)}const i=this.safeValue(t,"data",{}),r=this.parseOrder(i);e.resolve(r,s)}async cancelOrderWs(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrderWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const i=this.nonce().toString(),a={op:"cancelorder",tag:i,data:{marketCode:this.marketId(t),orderId:e}},o=this.urls.api.ws;return await this.watch(o,i,a,i)}async cancelOrdersWs(e,t=void 0,s={}){const i=e.length;if(i>20)throw new r.BadRequest(this.id+" cancelOrdersWs() accepts up to 20 ids at a time");if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrdersWs() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const a=this.nonce().toString(),o=this.marketId(t),n=[];for(let t=0;t<i;t++){const s={instId:o,ordId:e[t]};n.push(s)}const d={op:"cancelorders",tag:a,dataArray:n},h=this.urls.api.ws;return await this.watch(h,a,this.deepExtend(d,s),a)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeDict(s.subscriptions,i)){this.checkRequiredCredentials();const s=this.milliseconds(),r=s.toString()+"GET/auth/self/verify",o=this.hmac(this.encode(r),this.encode(this.secret),a.s,"base64"),n={op:"login",data:{apiKey:this.apiKey,timestamp:s,signature:o}},d=this.extend(n,e);this.watch(t,i,d,i)}return await r}handleAuthenticationMessage(e,t){const s="authenticated";if(this.safeBool(t,"success",!1)){this.safeDict(e.futures,s).resolve(!0)}else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions[s]}}ping(e){return"ping"}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleMessage(e,t){if("pong"===t)return void this.handlePong(e,t);const s=this.safeString(t,"table"),i=this.safeList(t,"data",[]),r=this.safeString(t,"event");void 0!==s&&void 0!==i?("trade"===s&&this.handleTrades(e,t),"ticker"===s&&this.handleTicker(e,t),s.indexOf("candles")>-1&&this.handleOHLCV(e,t),s.indexOf("depth")>-1&&this.handleOrderBook(e,t),s.indexOf("balance")>-1&&this.handleBalance(e,t),s.indexOf("position")>-1&&this.handlePositions(e,t),s.indexOf("order")>-1&&this.handleOrders(e,t)):("login"===r&&this.handleAuthenticationMessage(e,t),"placeorder"!==r&&"modifyorder"!==r&&"cancelorder"!==r||this.handlePlaceOrders(e,t))}}},4934:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4998),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!1,cancelOrdersWs:!1,cancelOrderWs:!1,createOrderWs:!1,editOrderWs:!1,fetchBalanceWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,fetchTradesWs:!1,watchBalance:!1,watchMyTrades:!1,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!1,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!0},urls:{api:{ws:"wss://apiws.p2pb2b.com/"}},options:{OHLCVLimit:1e3,tradesLimit:1e3,timeframes:{"15m":900,"30m":1800,"1h":3600,"1d":86400},watchTicker:{name:"state"},watchTickers:{name:"state"},tickerSubs:this.createSafeDictionary()},streaming:{ping:this.ping}})}async subscribe(e,t,s,i={}){const r=this.urls.api.ws,a={method:e,params:s,id:this.milliseconds()},o=this.extend(a,i);return await this.watch(r,t,o,t)}async watchOHLCV(e,t="15m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.safeValue(this.options,"timeframes",{}),n=this.safeInteger(o,t);if(void 0===n)throw new r.BadRequest(this.id+" watchOHLCV cannot take a timeframe of "+t);const d=this.market(e),h=[d.id,n],c="kline::"+d.symbol,l=await this.subscribe("kline.subscribe",c,h,a);return this.newUpdates&&(i=l.getLimit(e,i)),this.filterBySinceLimit(l,s,i,0,!0)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.safeDict(this.options,"watchTicker");let i=this.safeString(s,"name","state");[i,t]=this.handleOptionAndParams(t,"method","name",i);const r=this.market(e);e=r.symbol,this.options.tickerSubs[r.id]=!0;const a=this.options.tickerSubs,o=Object.keys(a),n=i+"::"+r.symbol;return await this.subscribe(i+".subscribe",n,o,t)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[];if(void 0!==(e=this.marketSymbols(e,void 0,!1,!0,!0)))for(let t=0;t<e.length;t++)r.push("deals::"+e[t]);const a=this.marketIds(e),o=this.urls.api.ws,n={method:"deals.subscribe",params:a,id:this.milliseconds()},d=this.extend(n,i),h=await this.watchMultiple(o,r,d,r);if(this.newUpdates){const e=this.safeValue(h,0),t=this.safeString(e,"symbol");s=h.getLimit(t,s)}return this.filterBySinceLimit(h,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r="orderbook::"+i.symbol,a=this.safeString(s,"interval","0.001");void 0===t&&(t=100);const o=[i.id,t,a];return(await this.subscribe("depth.subscribe",r,o,s)).limit()}handleOHLCV(e,t){let s=this.safeList(t,"params");s=this.safeList(s,0);const i=this.safeString(t,"method").split("."),r=this.safeString(i,0),o=this.safeString(s,7),n=this.safeMarket(o),d=this.safeDict(this.options,"timeframes",{}),h=this.findTimeframe(r,d),c=this.safeString(n,"symbol"),l=r+"::"+c,u=this.parseOHLCV(s,n);this.ohlcvs[c]=this.safeValue(this.ohlcvs,c,{});let p=this.safeValue(this.ohlcvs[c],h);if(void 0!==c){if(void 0===p){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);p=new a.TG(e),this.ohlcvs[c][h]=p}p.append(u),e.resolve(p,l)}return t}handleTrade(e,t){const s=this.safeList(t,"params",[]),i=this.safeList(s,1),r=this.safeString(s,0),o=this.safeMarket(r),n=this.safeString(o,"symbol");let d=this.safeValue(this.trades,n);if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new a.I3(e),this.trades[n]=d}for(let e=0;e<i.length;e++){const t=i[e],s=this.parseTrade(t,o);d.append(s)}const h="deals::"+n;return e.resolve(d,h),t}handleTicker(e,t){const s=this.safeList(t,"params",[]),i=this.safeString(s,0),r=this.safeMarket(i),a=this.safeString(t,"method"),o=a.split("."),n=this.safeString(o,0),d=this.safeDict(s,1);let h;if("price.update"===a){const e=this.safeString(s,1);h=this.safeTicker({last:e,close:e,symbol:r.symbol})}else h=this.parseTicker(d,r);const c=n+"::"+h.symbol;return e.resolve(h,c),t}handleOrderBook(e,t){const s=this.safeList(t,"params",[]),i=this.safeDict(s,1),r=this.safeList(i,"asks"),a=this.safeList(i,"bids"),o=this.safeString(s,2),n=this.safeMarket(o),d=n.symbol,h="orderbook::"+n.symbol,c=this.safeValue(e.subscriptions,h,{}),l=this.safeInteger(c,"limit");let u=this.safeValue(this.orderbooks,d);if(void 0===u&&(this.orderbooks[d]=this.orderBook({},l),u=this.orderbooks[d]),void 0!==a)for(let e=0;e<a.length;e++){const t=this.safeValue(a,e),s=this.safeNumber(t,0),i=this.safeNumber(t,1);u.bids.store(s,i)}if(void 0!==r)for(let e=0;e<r.length;e++){const t=this.safeValue(r,e),s=this.safeNumber(t,0),i=this.safeNumber(t,1);u.asks.store(s,i)}u.symbol=d,e.resolve(u,h)}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;if("pong"===this.safeString(t,"result"))return void this.handlePong(e,t);const s=this.safeString(t,"method"),i={"depth.update":this.handleOrderBook,"price.update":this.handleTicker,"kline.update":this.handleOHLCV,"state.update":this.handleTicker,"deals.update":this.handleTrade},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}handleErrorMessage(e,t){const s=this.safeString(t,"error");if(void 0!==s)throw new r.ExchangeError(this.id+" error: "+this.json(s));return!1}ping(e){return{method:"server.ping",params:[],id:this.milliseconds()}}handlePong(e,t){return e.lastPong=this.safeInteger(t,"id"),t}onError(e,t){this.options.tickerSubs=this.createSafeDictionary(),this.onError(e,t)}onClose(e,t){this.options.tickerSubs=this.createSafeDictionary(),this.onClose(e,t)}}},1057:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(6993),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!0,watchOrderBook:!0,watchOrders:!1,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!1,watchOHLCV:!1},urls:{logo:"https://x.com/tradeparadex/photo",api:{ws:"wss://ws.api.prod.paradex.trade/v1"},test:{ws:"wss://ws.api.testnet.paradex.trade/v1"},www:"https://www.paradex.trade/",doc:"https://docs.api.testnet.paradex.trade/",fees:"https://docs.paradex.trade/getting-started/trading-fees",referral:""},options:{},streaming:{}})}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();let r="trades.";if(void 0!==e){r+=this.market(e).id}else r+="ALL";const a=this.urls.api.ws,o={jsonrpc:"2.0",method:"subscribe",params:{channel:r}},n=await this.watch(a,r,this.deepExtend(o,i),r);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySinceLimit(n,t,s,"timestamp",!0)}handleTrade(e,t){const s=this.safeDict(t,"params",{}),i=this.safeDict(s,"data",{}),a=this.parseTrade(i),o=a.symbol,n=this.safeString(s,"channel");let d=this.safeValue(this.trades,o);return void 0===d&&(d=new r.I3(this.safeInteger(this.options,"tradesLimit",1e3)),this.trades[o]=d),d.append(a),e.resolve(d,n),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="order_book."+this.market(e).id+".snapshot@15@100ms",r=this.urls.api.ws,a={jsonrpc:"2.0",method:"subscribe",params:{channel:i}};return(await this.watch(r,i,this.deepExtend(a,s),i)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"params",{}),i=this.safeDict(s,"data",{}),r=this.safeString(i,"market"),a=this.safeMarket(r),o=this.safeInteger(i,"last_updated_at"),n=a.symbol;n in this.orderbooks||(this.orderbooks[n]=this.orderBook());const d={bids:[],asks:[]},h=this.safeList(i,"inserts");for(let e=0;e<h.length;e++){const t=this.safeDict(h,e),s=this.safeString(t,"side"),i=this.safeString(t,"price"),r=this.safeString(t,"size");"BUY"===s?d.bids.push([i,r]):d.asks.push([i,r])}const c=this.orderbooks[n],l=this.parseOrderBook(d,n,o,"bids","asks");l.nonce=this.safeNumber(i,"seq_no"),c.reset(l);const u=this.safeString(s,"channel");e.resolve(c,u)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);const s="markets_summary",i=this.urls.api.ws,r={jsonrpc:"2.0",method:"subscribe",params:{channel:s}},a=s+"."+e;return await this.watch(i,a,this.deepExtend(r,t),a)}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s="markets_summary",i=this.urls.api.ws,r={jsonrpc:"2.0",method:"subscribe",params:{channel:s}},a=[];if(Array.isArray(e))for(let t=0;t<e.length;t++){const i=s+"."+e[t];a.push(i)}else a.push(s);const o=await this.watchMultiple(i,a,this.deepExtend(r,t),a);if(this.newUpdates){const e={};return e[o.symbol]=o,e}return this.filterByArray(this.tickers,"symbol",e)}handleTicker(e,t){const s=this.safeDict(t,"params",{}),i=this.safeDict(s,"data",{}),r=this.safeString(i,"symbol"),a=this.safeMarket(r),o=a.symbol,n=this.safeString(s,"channel"),d=n+"."+o,h=this.parseTicker(i,a);return this.tickers[o]=h,e.resolve(h,n),e.resolve(h,d),t}handleErrorMessage(e,t){const s=this.safeDict(t,"error");if(void 0===s)return!0;if(void 0!==this.safeString(s,"code")){const e=this.id+" "+this.json(s);this.throwExactlyMatchedException(this.exceptions.exact,"-32600",e);const t=this.safeValue(s,"message");void 0!==t&&this.throwBroadlyMatchedException(this.exceptions.broad,t,e)}return!1}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;const s=this.safeDict(t,"params");if(void 0!==s){const i=this.safeString(s,"channel").split("."),r=this.safeString(i,0),a={trades:this.handleTrade,order_book:this.handleOrderBook,markets_summary:this.handleTicker},o=this.safeValue(a,r);void 0!==o&&o.call(this,e,t)}}}},1619:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(9075),r=s(5147),a=s(2931),o=s(4852),n=s(2079);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0,watchPositions:void 0,watchOrderBookForSymbols:!1,watchTradesForSymbols:!1,watchOHLCVForSymbols:!1,watchBalance:!0},urls:{test:{ws:"wss://testnet-api.phemex.com/ws"},api:{ws:"wss://ws.phemex.com"}},options:{tradesLimit:1e3,OHLCVLimit:1e3},streaming:{keepAlive:9e3}})}fromEn(e,t){if(void 0===e)return;const s=new r.Y(e);return s.decimals=this.sum(s.decimals,t),s.reduce(),s.toString()}fromEp(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"priceScale"))}fromEv(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"valueScale"))}fromEr(e,t=void 0){return void 0===e||void 0===t?e:this.fromEn(e,this.safeInteger(t,"ratioScale"))}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}parseSwapTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,a=this.safeIntegerProduct(e,"timestamp",1e-6),o=this.fromEp(this.safeString(e,"close"),t),n=this.parseNumber(o),d=this.parseNumber(this.fromEv(this.safeString(e,"turnover"),t)),h=this.parseNumber(this.fromEv(this.safeString(e,"volume"),t));let c,l,u;const p=this.omitZero(this.fromEp(this.safeString(e,"open"),t)),f=this.parseNumber(p);void 0!==p&&void 0!==o&&(c=this.parseNumber(r.Y.stringSub(o,p)),u=this.parseNumber(r.Y.stringDiv(r.Y.stringAdd(o,p),"2")),l=this.parseNumber(r.Y.stringMul(r.Y.stringSub(r.Y.stringDiv(o,p),"1"),"100")));return{symbol:i,timestamp:a,datetime:this.iso8601(a),high:this.parseNumber(this.fromEp(this.safeString(e,"high"),t)),low:this.parseNumber(this.fromEp(this.safeString(e,"low"),t)),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:f,close:n,last:n,previousClose:void 0,change:c,percentage:l,average:u,baseVolume:h,quoteVolume:d,info:e}}parsePerpetualTicker(e,t=void 0){const s=this.safeString(e,0),i=(t=this.safeMarket(s,t)).symbol,a=this.fromEp(this.safeString(e,4),t),o=this.parseNumber(a),n=this.parseNumber(this.fromEv(this.safeString(e,6),t)),d=this.parseNumber(this.fromEv(this.safeString(e,5),t));let h,c,l;const u=this.omitZero(this.fromEp(this.safeString(e,1),t)),p=this.parseNumber(u);void 0!==u&&void 0!==a&&(h=this.parseNumber(r.Y.stringSub(a,u)),l=this.parseNumber(r.Y.stringDiv(r.Y.stringAdd(a,u),"2")),c=this.parseNumber(r.Y.stringMul(r.Y.stringSub(r.Y.stringDiv(a,u),"1"),"100")));return{symbol:i,timestamp:void 0,datetime:void 0,high:this.parseNumber(this.fromEp(this.safeString(e,2),t)),low:this.parseNumber(this.fromEp(this.safeString(e,3),t)),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:p,close:o,last:o,previousClose:void 0,change:h,percentage:c,average:l,baseVolume:d,quoteVolume:n,info:e}}handleTicker(e,t){const s=[];if("market24h"in t){const e=this.safeValue(t,"market24h");s.push(this.parseSwapTicker(e))}else if("spot_market24h"in t){const e=this.safeValue(t,"spot_market24h");s.push(this.parseTicker(e))}else if("data"in t){const e=this.safeValue(t,"data",[]);for(let t=0;t<e.length;t++)s.push(this.parsePerpetualTicker(e[t]))}for(let i=0;i<s.length;i++){const r=s[i],a=r.symbol,o="ticker:"+a,n=this.safeIntegerProduct(t,"timestamp",1e-6);r.timestamp=n,r.datetime=this.iso8601(n),this.tickers[a]=r,e.resolve(r,o)}}async watchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let s=":balance";return s="USDT"===this.safeString(e,"settle")?"perpetual"+s:t+s,await this.subscribePrivate(t,s,e)}handleBalance(e,t,s){this.balance.info=s;for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"currency"),a=this.safeCurrencyCode(i),o=this.safeValue(this.currencies,a,{}),n=this.safeInteger(o,"valueScale",8),d=this.account();let h=this.safeString(t,"totalUsedBalanceRv");if(void 0===h){let e=this.safeString(t,"totalUsedBalanceEv");if(void 0===e){const s=this.safeString(t,"lockedTradingBalanceEv"),i=this.safeString2(t,"lockedWithdrawEv","lockedWithdrawRv");e=r.Y.stringAdd(s,i)}h=this.fromEn(e,n)}let c=this.safeString(t,"accountBalanceRv");if(void 0===c){const e=this.safeString2(t,"accountBalanceEv","balanceEv");c=this.fromEn(e,n)}d.used=h,d.total=c,this.balance[a]=d,this.balance=this.safeBalance(this.balance)}const i=e+":balance";t.resolve(this.balance,i)}handleTrades(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),r=i.symbol,o="trade:"+r;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}const d=this.safeValue2(t,"trades","trades_p",[]),h=this.parseTrades(d,i);for(let e=0;e<h.length;e++)n.append(h[e]);e.resolve(n,o)}handleOHLCV(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),r=i.symbol,o=this.safeValue2(t,"kline","kline_p",[]),n=this.safeValue(o,0,[]),d=this.safeString(n,1),h=this.findTimeframe(d);if(void 0!==h){const t="kline:"+h+":"+r,s=this.parseOHLCVs(o,i);this.ohlcvs[r]=this.safeValue(this.ohlcvs,r,{});let n=this.safeValue(this.ohlcvs[r],h);if(void 0===n){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);n=new a.TG(e),this.ohlcvs[r][h]=n}for(let e=0;e<s.length;e++){const t=s[e];n.append(t)}e.resolve(n,t)}}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.swap,r="USDT"===s.settle;let a="spot_market24h";i&&(a=r?"perp_market24h_pack_p":"market24h");const o=this.urls.api.ws,n=a+".subscribe",d="ticker:"+e,h={method:n,id:this.requestId(),params:[]},c=this.deepExtend(h,t);return await this.watch(o,d,c,n)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o=this.requestId(),n=r.swap,d="USDT"===r.settle,h="trade:"+e,c={method:(n&&d?"trade_p":"trade")+".subscribe",id:o,params:[r.id]},l=this.deepExtend(c,i),u=await this.watch(a,h,l,h);return this.newUpdates&&(s=u.getLimit(e,s)),this.filterBySinceLimit(u,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r=this.urls.api.ws,a=this.requestId(),o=i.swap,n="USDT"===i.settle,d="orderbook:"+e,h={method:(o&&n?"orderbook_p":"orderbook")+".subscribe",id:a,params:[i.id]},c=this.deepExtend(h,s);return(await this.watch(r,d,c,d)).limit()}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.urls.api.ws,n=this.requestId(),d=a.swap,h="USDT"===a.settle,c="kline:"+t+":"+e,l={method:(d&&h?"kline_p":"kline")+".subscribe",id:n,params:[a.id,this.safeInteger(this.timeframes,t)]},u=this.deepExtend(l,r),p=await this.watch(o,c,u,c);return this.newUpdates&&(i=p.getLimit(e,i)),this.filterBySinceLimit(p,s,i,0,!0)}customHandleDelta(e,t,s=void 0){const i=this.customParseBidAsk(t,0,1,s);e.storeArray(i)}customHandleDeltas(e,t,s=void 0){for(let i=0;i<t.length;i++)this.customHandleDelta(e,t[i],s)}handleOrderBook(e,t){const s=this.safeString(t,"symbol"),i=this.safeMarket(s),r=i.symbol,a=this.safeString(t,"type"),o=this.safeInteger(t,"depth"),n="orderbook:"+r,d=this.safeInteger(t,"sequence"),h=this.safeIntegerProduct(t,"timestamp",1e-6);if("snapshot"===a){const s=this.safeValue2(t,"book","orderbook_p",{}),a=this.customParseOrderBook(s,r,h,"bids","asks",0,1,i);a.nonce=d;const c=this.orderBook(a,o);this.orderbooks[r]=c,e.resolve(c,n)}else if(r in this.orderbooks){const s=this.orderbooks[r],a=this.safeDict2(t,"book","orderbook_p",{}),o=this.safeList(a,"asks",[]),c=this.safeList(a,"bids",[]);this.customHandleDeltas(s.asks,o,i),this.customHandleDeltas(s.bids,c,i),s.nonce=d,s.timestamp=h,s.datetime=this.iso8601(h),this.orderbooks[r]=s,e.resolve(s,n)}}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets();let o="trades:";if(void 0!==e&&(r=this.market(e),e=r.symbol,o+=r.symbol,"USDT"===r.settle&&((i=this.extend(i)).settle="USDT")),[a,i]=this.handleMarketTypeAndParams("watchMyTrades",r,i),void 0===e){o="USDT"===this.safeString(i,"settle")?o+"perpetual":o+a}const n=await this.subscribePrivate(a,o,i);return this.newUpdates&&(s=n.getLimit(e,s)),this.filterBySymbolSinceLimit(n,e,t,s,!0)}handleMyTrades(e,t){const s="trades";if(0===t.length)return;let i=this.myTrades;if(void 0===i){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new a.Pt(e)}const r={};let o;for(let e=0;e<t.length;e++){const s=t[e],a=this.safeString(s,"symbol"),n=this.safeMarket(a),d=this.parseTrade(s);i.append(d);const h=d.symbol;void 0===o&&(o="USDT"===n.settle?"perpetual":n.type),r[h]=!0}const n=Object.keys(r);for(let t=0;t<n.length;t++){const r=s+":"+n[t];e.resolve(i,r)}const d=s+":"+o;e.resolve(i,d)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a,o="orders:";void 0!==e&&(r=this.market(e),e=r.symbol,o+=r.symbol,"USDT"===r.settle&&((i=this.extend(i)).settle="USDT")),[a,i]=this.handleMarketTypeAndParams("watchOrders",r,i);const n="USDT"===this.safeString(i,"settle");void 0===e&&(o=n?o+"perpetual":o+a);const d=await this.subscribePrivate(a,o,i);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleOrders(e,t){let s=[];const i=[];if("closed"in t||"fills"in t||"open"in t){const e=this.safeValue(t,"closed",[]),r=this.safeValue(t,"open",[]),a=this.arrayConcat(r,e);if(0===a.length)return;s=this.safeValue(t,"fills",[]);for(let e=0;e<a.length;e++){const t=a[e],s=this.parseOrder(t);i.push(s)}}else for(let e=0;e<t.length;e++){const r=t[e],a=this.safeString(r,"action");void 0!==a&&"Cancel"!==a&&s.push(r);const o=this.parseWSSwapOrder(r);i.push(o)}this.handleMyTrades(e,s);const r=this.safeInteger(this.options,"ordersLimit",1e3),o={};let n;void 0===this.orders&&(this.orders=new a.Pt(r));const d=this.orders;for(let e=0;e<i.length;e++){const t=i[e];d.append(t);const s=t.symbol,r=this.market(s);if(void 0===n){n="USDT"===r.settle?"perpetual":r.type}o[s]=!0}const h=Object.keys(o);for(let t=0;t<h.length;t++){const s="orders:"+h[t];e.resolve(this.orders,s)}const c="orders:"+n;e.resolve(this.orders,c)}parseWSSwapOrder(e,t=void 0){const s=this.safeString(e,"orderID");let i=this.safeString(e,"clOrdID");void 0!==i&&i.length<1&&(i=void 0);const r=this.safeString(e,"symbol"),a=(t=this.safeMarket(r,t)).symbol,o=this.parseOrderStatus(this.safeString(e,"ordStatus")),n=this.safeStringLower(e,"side"),d=this.parseOrderType(this.safeString(e,"ordType")),h=this.safeString(e,"priceRp",this.fromEp(this.safeString(e,"priceEp"),t)),c=this.safeString(e,"orderQty"),l=this.safeString(e,"cumQty"),u=this.safeString(e,"leavesQty"),p=this.safeIntegerProduct(e,"actionTimeNs",1e-6),f=this.safeString(e,"cumValueRv",this.fromEv(this.safeString(e,"cumValueEv"),t));let m=this.safeIntegerProduct(e,"transactTimeNs",1e-6);0===m&&(m=void 0);const g=this.parseTimeInForce(this.safeString(e,"timeInForce")),v=this.safeString(e,"stopPx"),y="PO"===g;return this.safeOrder({info:e,id:s,clientOrderId:i,datetime:this.iso8601(p),timestamp:p,lastTradeTimestamp:m,symbol:a,type:d,timeInForce:g,postOnly:y,side:n,price:h,stopPrice:v,triggerPrice:v,amount:c,filled:l,remaining:u,cost:f,average:void 0,status:o,fee:void 0,trades:void 0},t)}handleMessage(e,t){const s=this.safeString(t,"id");if(s in e.subscriptions){const i=e.subscriptions[s];if(delete e.subscriptions[s],!0!==i)return void i.call(this,e,t)}const i=this.safeString(t,"method","");if("market24h"in t||"spot_market24h"in t||i.indexOf("perp_market24h_pack_p")>=0)this.handleTicker(e,t);else if("trades"in t||"trades_p"in t)this.handleTrades(e,t);else if("kline"in t||"kline_p"in t)this.handleOHLCV(e,t);else if("book"in t||"orderbook_p"in t)this.handleOrderBook(e,t);else{if("orders"in t||"orders_p"in t){const s=this.safeValue2(t,"orders","orders_p",{});this.handleOrders(e,s)}if("accounts"in t||"accounts_p"in t||"wallets"in t){let s="accounts"in t?"swap":"spot";"accounts_p"in t&&(s="perpetual");const i=this.safeValueN(t,["accounts","accounts_p","wallets"],[]);this.handleBalance(s,e,i)}}}handleAuthenticate(e,t){const s=this.safeValue(t,"result"),i="authenticated";if("success"===this.safeString(s,"status"))e.resolve(t,i);else{const s=new n.AuthenticationError(this.id+" "+this.json(t));e.reject(s,i),i in e.subscriptions&&delete e.subscriptions[i]}}async subscribePrivate(e,t,s={}){await this.loadMarkets(),await this.authenticate();const i=this.urls.api.ws,r=this.seconds(),a="USDT"===this.safeValue(s,"settle","");s=this.omit(s,"settle");let o="aop.subscribe";"spot"===e&&(o="wo.subscribe"),a&&(o="aop_p.subscribe");let n={id:r,method:o,params:[]};return n=this.extend(n,s),await this.watch(i,t,n,o)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i=this.requestId(),r="authenticated";let a=this.safeValue(s.subscriptions,r);if(void 0===a){const n=this.safeInteger(this.options,"expires",120),d=this.seconds()+n,h=this.apiKey+d.toString(),c=this.hmac(this.encode(h),this.encode(this.secret),o.s),l={method:"user.auth",params:["API",this.apiKey,c,d],id:i},u=i.toString(),p=this.extend(l,e);r in s.subscriptions||(s.subscriptions[u]=this.handleAuthenticate),a=await this.watch(t,r,p,r),s.subscriptions[r]=a}return a}}},3456:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(288),r=s(2079),a=s(2931),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!0,watchBalance:!0,watchStatus:!1,watchOrders:!0,watchMyTrades:!0,createOrderWs:!0,editOrderWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,cancelOrderWs:!0,cancelOrdersWs:!0,cancelAllOrdersWs:!0,fetchTradesWs:!1,fetchBalanceWs:!1},urls:{api:{ws:{public:"wss://ws.poloniex.com/ws/public",private:"wss://ws.poloniex.com/ws/private"}}},options:{createMarketBuyOrderRequiresPrice:!0,tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchOrderBook:{name:"book_lv2"},connectionsLimit:2e3,requestsLimit:500,timeframes:{"1m":"candles_minute_1","5m":"candles_minute_5","10m":"candles_minute_10","15m":"candles_minute_15","30m":"candles_minute_30","1h":"candles_hour_1","2h":"candles_hour_2","4h":"candles_hour_4","6h":"candles_hour_6","12h":"candles_hour_12","1d":"candles_day_1","3d":"candles_day_3","1w":"candles_week_1","1M":"candles_month_1"}},streaming:{keepAlive:15e3,ping:this.ping}})}async authenticate(e={}){this.checkRequiredCredentials();const t=this.numberToString(this.milliseconds()),s=this.urls.api.ws.private,i="authenticated",r=this.client(s);let a=this.safeValue(r.subscriptions,i);if(void 0===a){const o="GET\n"+"/ws"+"\nsignTimestamp="+t,d=this.hmac(this.encode(o),this.encode(this.secret),n.s,"base64"),h={event:"subscribe",channel:["auth"],params:{key:this.apiKey,signTimestamp:t,signature:d,signatureMethod:"HmacSHA256",signatureVersion:"2"}},c=this.extend(h,e);a=await this.watch(s,i,c,i),r.subscriptions[i]=a}return a}async subscribe(e,t,s,i=void 0,r={}){const a=s?"private":"public",o=this.urls.api.ws[a],n={event:"subscribe",channel:[e]};let d=[];this.isEmpty(i)?d.push("all"):(t=t+"::"+i.join(","),d=this.marketIds(i)),"balances"!==e&&(n.symbols=d);const h=this.extend(n,r);return await this.watch(o,t,h,t)}async tradeRequest(e,t={}){const s=this.urls.api.ws.private,i=this.nonce().toString(),r={id:i,event:e,params:t};return await this.watch(s,i,r,i)}async createOrderWs(e,t,s,i,a=void 0,n={}){await this.loadMarkets(),await this.authenticate();const d=this.market(e);let h=t.toUpperCase();const c=s.toUpperCase();this.isPostOnly("MARKET"===h,"LIMIT_MAKER"===h,n)&&(h="LIMIT_MAKER");const l={symbol:d.id,side:s.toUpperCase(),type:t.toUpperCase()};if("MARKET"===h&&"BUY"===c){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),r=this.numberToString(a),n=o.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);l.amount=t}else l.quantity=this.amountToPrecision(d.symbol,i),void 0!==a&&(l.price=this.priceToPrecision(e,a));return await this.tradeRequest("createOrder",this.extend(l,n))}async cancelOrderWs(e,t=void 0,s={}){const i=this.safeString(s,"clientOrderId");if(void 0!==i){const e=this.safeValue(s,"clientOrderId",[]);s.clientOrderIds=this.arrayConcat(e,[i])}return await this.cancelOrdersWs([e],t,s)}async cancelOrdersWs(e,t=void 0,s={}){await this.loadMarkets(),await this.authenticate();const i={orderIds:e};return await this.tradeRequest("cancelOrders",this.extend(i,s))}async cancelAllOrdersWs(e=void 0,t={}){return await this.loadMarkets(),await this.authenticate(),await this.tradeRequest("cancelAllOrders",t)}handleOrderRequest(e,t){const s=this.safeString(t,"id"),i=this.safeValue(t,"data",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.parseWsOrder(t);r.push(s)}e.resolve(r,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){await this.loadMarkets();const o=this.safeValue(this.options,"timeframes",{}),n=this.safeString(o,t,t);if(void 0===n)throw new r.BadRequest(this.id+" watchOHLCV cannot take a timeframe of "+t);const d=await this.subscribe(n,n,!1,[e],a);return this.newUpdates&&(i=d.getLimit(e,i)),this.filterBySinceLimit(d,s,i,0,!0)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);const s=await this.watchTickers([e],t);return this.safeValue(s,e)}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s="ticker";e=this.marketSymbols(e);const i=await this.subscribe(s,s,!1,e,t);return this.newUpdates?i:this.filterByArray(this.tickers,"symbol",e)}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0,!0);const r="trades",a=this.urls.api.ws.public,o={event:"subscribe",channel:[r],symbols:this.marketIds(e)},n=this.extend(o,i),d=[];if(void 0!==e)for(let t=0;t<e.length;t++)d.push(r+"::"+e[t]);const h=await this.watchMultiple(a,d,n,d);if(this.newUpdates){const e=this.safeValue(h,0),t=this.safeString(e,"symbol");s=h.getLimit(t,s)}return this.filterBySinceLimit(h,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"watchOrderBook");let r=this.safeString(i,"name","book_lv2");[r,s]=this.handleOptionAndParams(s,"method","name",r);return(await this.subscribe(r,r,!1,[e],s)).limit()}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="orders";await this.authenticate(),void 0!==e&&(e=this.symbol(e));const a=void 0===e?void 0:[e],o=await this.subscribe(r,r,!0,a,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();await this.authenticate(),void 0!==e&&(e=this.symbol(e));const r=void 0===e?void 0:[e],a=await this.subscribe("orders","myTrades",!0,r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}async watchBalance(e={}){await this.loadMarkets();const t="balances";return await this.authenticate(),await this.subscribe(t,t,!0,void 0,e)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"startTime"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"quantity")]}handleOHLCV(e,t){let s=this.safeValue(t,"data");s=this.safeValue(s,0);const i=this.safeString(t,"channel"),r=this.safeString(s,"symbol"),o=this.safeSymbol(r),n=this.safeMarket(o),d=this.safeValue(this.options,"timeframes",{}),h=this.findTimeframe(i,d),c=i+"::"+o,l=this.parseWsOHLCV(s,n);this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let u=this.safeValue(this.ohlcvs[o],h);if(void 0!==o){if(void 0===u){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);u=new a.TG(e),this.ohlcvs[o][h]=u}u.append(l),e.resolve(u,c)}return t}handleTrade(e,t){const s=this.safeValue(t,"data",[]);for(let t=0;t<s.length;t++){const i=s[t];if(void 0!==this.safeString(i,"symbol")){const t=this.parseWsTrade(i),s=t.symbol,r="trades"+"::"+s;let o=this.safeValue(this.trades,s);if(void 0===o){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.I3(e),this.trades[s]=o}o.append(t),e.resolve(o,r)}}return t}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeInteger(e,"createTime"),r=this.safeStringLower2(e,"matchRole","taker");return this.safeTrade({info:e,id:this.safeString2(e,"id","tradeId"),symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),order:this.safeString(e,"orderId"),type:this.safeStringLower(e,"type"),side:this.safeStringLower2(e,"takerSide","side"),takerOrMaker:r,price:this.omitZero(this.safeString2(e,"tradePrice","price")),amount:this.omitZero(this.safeString2(e,"filledQuantity","quantity")),cost:this.safeString2(e,"amount","filledAmount"),fee:{rate:void 0,cost:this.safeString(e,"tradeFee"),currency:this.safeString(e,"feeCurrency")}},t)}parseStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",PENDING_CANCEL:"open",PARTIALLY_CANCELED:"open",CANCELED:"canceled"},e,e)}parseWsOrderTrade(e,t=void 0){const s=this.safeInteger(e,"tradeTime"),i=this.safeString(e,"symbol");return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),symbol:this.safeSymbol(i,t),timestamp:s,datetime:this.iso8601(s),order:this.safeString(e,"orderId"),type:this.safeStringLower(e,"type"),side:this.safeString(e,"side"),takerOrMaker:this.safeStringLower(e,"matchRole"),price:this.safeString(e,"price"),amount:this.safeString(e,"tradeAmount"),cost:void 0,fee:{rate:void 0,cost:this.safeString(e,"tradeFee"),currency:this.safeString(e,"feeCurrency")}},t)}handleOrder(e,t){const s=this.safeValue(t,"data",[]);let i=this.orders;if(void 0===i){const e=this.safeInteger(this.options,"ordersLimit");i=new a.Pt(e),this.orders=i}const r=[];for(let t=0;t<s.length;t++){const a=this.safeValue(s,t),n=this.safeString(a,"symbol"),d=this.safeString(a,"eventType");if(void 0!==n){const t=this.safeSymbol(n),s=this.safeString(a,"orderId"),h=this.safeString(a,"clientOrderId");if("place"===d||"canceled"===d){const e=this.parseWsOrder(a);i.append(e)}else{const r=this.safeValue(i.hashmap,t,{}),n=this.safeValue2(r,s,h),d=this.parseWsTrade(a);this.handleMyTrades(e,d),void 0===n.trades&&(n.trades=[]),n.trades.push(d),n.lastTradeTimestamp=d.timestamp;let c="0",l="0";const u=n.trades;for(let e=0;e<u.length;e++){const t=u[e],s=this.numberToString(t.cost),i=this.numberToString(t.amount);c=o.Y.stringAdd(c,s),l=o.Y.stringAdd(l,i)}if(o.Y.stringGt(l,"0")&&(n.average=this.parseNumber(o.Y.stringDiv(c,l))),n.cost=this.parseNumber(c),void 0!==n.filled){const e=this.numberToString(d.amount);let t=this.numberToString(n.filled);if(t=o.Y.stringAdd(t,e),n.filled=t,void 0!==n.amount){const e=this.numberToString(n.amount);n.remaining=this.parseNumber(o.Y.stringSub(e,t))}}if(void 0===n.fee&&(n.fee={rate:void 0,cost:0,currency:d.fee.currency}),void 0!==n.fee.cost&&void 0!==d.fee.cost){const e=this.numberToString(n.fee.cost),t=this.numberToString(d.fee.cost);n.fee.cost=o.Y.stringAdd(e,t)}const p=this.safeString(a,"state"),f=this.parseStatus(p);n.status=f,i.append(n)}r.push(n)}}for(let t=0;t<r.length;t++){const s=r[t],a="orders::"+this.market(s).symbol;e.resolve(i,a)}return e.resolve(i,"orders"),t}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOrderId"),r=this.safeString(e,"symbol"),a=this.safeString(e,"ts"),n=this.safeString(e,"filledAmount"),d=this.safeString(e,"state");let h;if(!o.Y.stringEq(n,"0")){h=[];const t=this.parseWsOrderTrade(e);h.push(t)}return this.safeOrder({info:e,symbol:this.safeSymbol(r,t),id:s,clientOrderId:i,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,type:this.safeString(e,"type"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeString(e,"quantity"),cost:void 0,average:void 0,filled:n,remaining:this.safeString(e,"remaining_size"),status:this.parseStatus(d),fee:{rate:void 0,cost:this.safeString(e,"tradeFee"),currency:this.safeString(e,"feeCurrency")},trades:h})}handleTicker(e,t){const s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e];if(void 0!==this.safeString(t,"symbol")){const e=this.parseTicker(t),s=e.symbol;this.tickers[s]=e,i[s]=e}}const r=this.findMessageHashes(e,"ticker::");for(let t=0;t<r.length;t++){const s=r[t],a=s.split("::")[1].split(","),o=this.filterByArray(i,"symbol",a);this.isEmpty(o)||e.resolve(o,s)}return e.resolve(i,"ticker"),t}handleOrderBook(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(t,"action"),r="snapshot"===i,a="update"===i;for(let t=0;t<s.length;t++){const i=s[t],o=this.safeString(i,"symbol"),n=this.safeMarket(o).symbol,d="book_lv2"+"::"+n,h=this.safeValue(e.subscriptions,d,{}),c=this.safeInteger(h,"limit"),l=this.safeInteger(i,"ts"),u=this.safeValue(i,"asks"),p=this.safeValue(i,"bids");if(r||a){r&&(this.orderbooks[n]=this.orderBook({},c));const t=this.orderbooks[n];if(void 0!==p)for(let e=0;e<p.length;e++){const s=this.safeValue(p,e),i=this.safeNumber(s,0),r=this.safeNumber(s,1);t.bids.store(i,r)}if(void 0!==u)for(let e=0;e<u.length;e++){const s=this.safeValue(u,e),i=this.safeNumber(s,0),r=this.safeNumber(s,1);t.asks.store(i,r)}t.symbol=n,t.timestamp=l,t.datetime=this.iso8601(l),e.resolve(t,d)}}}handleBalance(e,t){const s=this.safeValue(t,"data",[]);this.balance=this.parseWsBalance(s),e.resolve(this.balance,"balances")}parseWsBalance(e){const t=this.safeValue(e,0,{}),s=this.safeInteger(t,"ts"),i={info:e,timestamp:s,datetime:this.iso8601(s)};for(let t=0;t<e.length;t++){const s=this.safeValue(e,t),r=this.safeString(s,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(s,"available"),o.used=this.safeString(s,"hold"),i[a]=o}return this.safeBalance(i)}handleMyTrades(e,t){const s="myTrades",i=t.symbol;if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const r=this.myTrades;r.append(t),e.resolve(r,s);const o=s+":"+i;e.resolve(r,o)}handlePong(e){e.lastPong=this.milliseconds()}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s=this.safeString(t,"channel");"pong"===this.safeString(t,"event")&&(e.lastPong=this.milliseconds());const i={candles_minute_1:this.handleOHLCV,candles_minute_5:this.handleOHLCV,candles_minute_10:this.handleOHLCV,candles_minute_15:this.handleOHLCV,candles_minute_30:this.handleOHLCV,candles_hour_1:this.handleOHLCV,candles_hour_2:this.handleOHLCV,candles_hour_4:this.handleOHLCV,candles_hour_6:this.handleOHLCV,candles_hour_12:this.handleOHLCV,candles_day_1:this.handleOHLCV,candles_day_3:this.handleOHLCV,candles_week_1:this.handleOHLCV,candles_month_1:this.handleOHLCV,book:this.handleOrderBook,book_lv2:this.handleOrderBook,ticker:this.handleTicker,trades:this.handleTrade,orders:this.handleOrder,balances:this.handleBalance,createOrder:this.handleOrderRequest,cancelOrder:this.handleOrderRequest,cancelAllOrders:this.handleOrderRequest,auth:this.handleAuthenticate},r=this.safeValue(i,s);if("auth"===s)this.handleAuthenticate(e,t);else if(void 0===s)this.handleOrderRequest(e,t);else{this.safeValue(t,"data",[]).length>0&&r.call(this,e,t)}}handleErrorMessage(e,t){const s=this.safeString(t,"id"),i=this.safeString(t,"event"),a=this.safeList(t,"data"),o=this.safeDict(a,0),n=this.safeString(o,"orderId");if("error"===i||"0"===n)try{const e=this.safeString(o,"message"),s=this.safeString(o,"code"),i=this.id+" "+this.json(t);throw this.throwExactlyMatchedException(this.exceptions.exact,s,i),this.throwBroadlyMatchedException(this.exceptions.broad,e,i),new r.ExchangeError(i)}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t,s);return!0}return!1}handleAuthenticate(e,t){const s=this.safeValue(t,"data"),i="authenticated";if(this.safeValue(s,"success"))e.resolve(t,i);else{const s=new r.AuthenticationError(this.id+" "+this.json(t));e.reject(s,i),i in e.subscriptions&&delete e.subscriptions[i]}return t}ping(e){return{event:"ping"}}}},5850:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(6826),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,cancelAllOrdersWs:!1,cancelOrdersWs:!1,cancelOrderWs:!1,createOrderWs:!1,editOrderWs:!1,fetchBalanceWs:!1,fetchOpenOrdersWs:!1,fetchOrderWs:!1,fetchTradesWs:!1,watchOHLCV:!1,watchOrderBook:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!0,watchOrders:!0,watchMyTrades:!1,watchPosition:void 0,watchPositions:!1},urls:{api:{ws:"wss://futures-apiws.poloniex.com/endpoint"}},options:{tradesLimit:1e3,ordersLimit:1e3,watchTicker:{method:"/contractMarket/ticker"},watchOrders:{method:"/contractMarket/tradeOrders"},watchOrderBook:{method:"/contractMarket/level2",snapshotDelay:5,snapshotMaxRetries:3,checksum:!0},streamLimit:5,streamBySubscriptionsHash:{},streamIndex:-1},streaming:{keepAlive:3e4,maxPingPongMisses:2}})}async negotiate(e,t={}){const s=e?"private":"public",i=this.safeValue(this.options,"urls",{});if(s in i){const e=i[s];return await e}i[s]=this.spawn(this.negotiateHelper,e,t),this.options.urls=i;const r=i[s];return await r}async negotiateHelper(e,t={}){let s;const i=e?"private":"public";try{s=e?await this.privatePostBulletPrivate(t):await this.publicPostBulletPublic(t);const r=this.safeValue(s,"data",{}),a=this.safeValue(r,"instanceServers",[]),o=this.safeValue(a,0),n=this.safeInteger(o,"pingInterval"),d=this.safeString(o,"endpoint"),h=this.safeString(r,"token"),c=d+"?"+this.urlencode({token:h,privateChannel:e,connectId:i});return this.client(c).keepAlive=n,c}catch(e){this.safeValue(this.options.urls,i).reject(e),delete this.options.urls[i]}}requestId(){const e=this.sum(this.safeInteger(this.options,"requestId",0),1);return this.options.requestId=e,e}async subscribe(e,t,s=void 0,i=void 0,r={}){const a=await this.negotiate(t);if(void 0!==s){e+=":"+this.market(s).id}const o=e,n=await this.stream(a,o),d=this.requestId(),h={id:d,type:"subscribe",topic:e,privateChannel:t,response:!0,tunnelId:n},c={id:d};i=void 0===i?c:this.extend(c,i);const l=this.extend(h,r);return await this.watch(a,o,l,e,c)}onClose(e,t){this.options.streamBySubscriptionsHash={},super.onClose(e,t)}async stream(e,t){const s=this.safeValue(this.options,"streamBySubscriptionsHash",{});let i=this.safeString(s,t);if(void 0===i){let s=this.safeInteger(this.options,"streamIndex",-1);s+=1;const r=s%this.safeValue(this.options,"streamLimit");this.options.streamIndex=s;i="stream-"+this.numberToString(r),this.options.streamBySubscriptionsHash[t]=i;const a="tunnel:"+i,o={id:a,type:"openTunnel",newTunnelId:i,response:!0},n={id:a,method:this.handleNewStream};await this.watch(e,a,o,a,n)}return i}handleOrderBookSubscription(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeInteger(s,"limit");this.orderbooks[i]=this.orderBook({},r)}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s,{}),a=this.safeValue(r,"method");return void 0!==a&&a.call(this,e,t,r),t}handleNewStream(e,t,s){const i=this.safeString(t,"id");e.resolve(t,i)}async watchTicker(e,t={}){await this.loadMarkets(),e=this.symbol(e);return await this.subscribe("/contractMarket/ticker",!1,e,void 0,t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue(this.options,"watchTrades");let a=this.safeString(r,"method","/contractMarket/execution");[a,i]=this.handleOptionAndParams(i,"method","name",a),e=this.symbol(e);const o=await this.subscribe(a,!1,e,void 0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeValue(this.options,"watchOrderBook");let a=this.safeString(i,"method","/contractMarket/level2");if([a,s]=this.handleOptionAndParams(s,"method","name",a),"/contractMarket/level2"===a&&void 0!==t){if(5!==t&&50!==t)throw new r.BadRequest(this.id+" watchOrderBook limit argument must be none, 5 or 50 if using method /contractMarket/level2");a+="Depth"+this.numberToString(t)}const o={symbol:e,limit:t,method:this.handleOrderBookSubscription};return(await this.subscribe(a,!1,e,o,s)).limit()}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue(this.options,"watchOrders"),a=this.safeString(r,"method","/contractMarket/tradeOrders");let o=await this.subscribe(a,!0,void 0,void 0,i);this.newUpdates&&(s=o.getLimit(e,s)),o=this.filterBySymbolSinceLimit(o,e,t,s);return 0===o.length?await this.watchOrders(e,t,s,i):o}async watchBalance(e={}){await this.loadMarkets();return await this.subscribe("/contractAccount/wallet",!0,void 0,void 0,e)}handleTrade(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"symbol");if(void 0!==i){const t=this.parseWsTrade(s),r=t.symbol,o="/contractMarket/execution:"+i;let n=this.safeValue(this.trades,r);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new a.I3(e),this.trades[r]=n}n.append(t),e.resolve(n,o)}return t}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeIntegerProduct(e,"ts",1e-6);return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),symbol:this.safeString(t,"symbol"),timestamp:i,datetime:this.iso8601(i),order:this.safeString2(e,"takerOrderId","makerOrderId"),type:void 0,side:this.safeString(e,"side"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString2(e,"matchSize","size"),cost:void 0,fee:void 0},t)}parseWsOrderTrade(e,t=void 0){const s=this.safeInteger(e,"tradeTime"),i=this.safeString(e,"symbol");return this.safeTrade({info:e,id:this.safeString(e,"tradeId"),symbol:this.safeSymbol(i,t),timestamp:s,datetime:this.iso8601(s),order:this.safeString(e,"orderId"),type:this.safeStringLower(e,"type"),side:this.safeString(e,"side"),takerOrMaker:this.safeStringLower(e,"matchRole"),price:this.safeString(e,"price"),amount:this.safeString(e,"tradeAmount"),cost:void 0,fee:{rate:void 0,cost:this.safeString(e,"tradeFee"),currency:this.safeString(e,"feeCurrency")}},t)}handleOrder(e,t){const s=this.safeValue(t,"data",{});let i=this.orders;if(void 0===i){const e=this.safeInteger(this.options,"ordersLimit");i=new a.Pt(e),this.orders=i}const r=this.parseWsOrder(s);return i.append(r),e.resolve(i,"/contractMarket/tradeOrders"),t}parseOrderStatus(e,t){let s=this.safeString({canceled:"canceled",cancel:"canceled",filled:"closed"},t);if(void 0===s){const t={open:"open",match:"open",done:"closed"};s=this.safeString(t,e,e)}return s}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"clientOid"),r=this.safeString(e,"symbol"),a=this.safeIntegerProduct2(e,"orderTime","ts",1e-6),o=this.safeString(e,"status"),n=this.safeString(e,"type");return this.safeOrder({info:e,symbol:this.safeSymbol(r,t),id:s,clientOrderId:i,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:void 0,type:this.safeString(e,"orderType"),timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"side"),price:this.safeString2(e,"price","orderPrice"),stopPrice:this.safeString(e,"stopPrice"),triggerPrice:void 0,amount:this.safeString(e,"size"),cost:void 0,average:void 0,filled:this.safeString(e,"filledSize"),remaining:this.safeString(e,"remainSize"),status:this.parseOrderStatus(o,n),fee:void 0,trades:void 0})}handleTicker(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic"),r=this.getSymbolFromTopic(i);if(void 0!==r){const t=this.parseTicker(s);this.tickers[r]=t,e.resolve(t,i)}return t}handleL3OrderBook(e,t){const s=this.safeString(t,"topic");"received"!==this.safeString(t,"subject")&&e.resolve(t,s)}handleLevel2(e,t){this.safeString(t,"topic").indexOf("Depth")>=0?this.handeL2Snapshot(e,t):this.handleL2OrderBook(e,t)}handleL2OrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic",""),r=this.getSymbolFromTopic(i);let a=this.safeValue(this.orderbooks,r);void 0===a&&(this.orderbooks[r]=this.orderBook({}),a=this.orderbooks[r],a.symbol=r);if(void 0!==this.safeInteger(a,"nonce"))try{this.handleDelta(a,s),e.resolve(a,i)}catch(t){delete this.orderbooks[r],e.reject(t,i)}else{if(a.cache.length===this.handleOption("watchOrderBook","snapshotDelay",5)){const t=0;this.spawn(this.loadOrderBook,e,i,r,t,{})}a.cache.push(s)}}handeL2Snapshot(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(t,"topic",""),r=this.getSymbolFromTopic(i),a=this.safeInteger(s,"timestamp"),o=this.parseOrderBook(s,r,a,"bids","asks"),n=this.orderBook(o);this.orderbooks[r]=n,e.resolve(n,i)}getSymbolFromTopic(e){const t=e.split(":"),s=this.safeString(t,1);return this.safeSymbol(s)}getCacheIndex(e,t){const s=this.safeValue(t,0),i=this.safeInteger(e,"nonce");if(this.safeInteger(s,"sequence")>i+1)return-1;for(let e=0;e<t.length;e++){const s=t[e];if(i===this.safeInteger(s,"sequence")-1)return e}return t.length}handleDelta(e,t){const s=this.safeInteger(t,"sequence"),i=this.safeInteger(t,"lastSequence"),a=this.safeInteger(e,"nonce");if(a>s)return;if(a!==i){if(this.handleOption("watchOrderBook","checksum",!0))throw new r.ChecksumError(this.id+" "+this.orderbookChecksumMessage(""))}const o=this.safeList(t,"changes");for(let t=0;t<o.length;t++){const s=o[t].split(","),i=this.safeNumber(s,0),r=this.safeString(s,1),a=this.safeNumber(s,2);("buy"===r?e.bids:e.asks).store(i,a)}const n=this.safeInteger(t,"timestamp");e.timestamp=n,e.datetime=this.iso8601(n),e.nonce=s}handleBalance(e,t){const s=this.safeValue(t,"data",[]),i=this.safeString(s,"currency"),r=this.currency(i).code;return this.balance[r]=this.parseWsBalance(s),e.resolve(this.balance[r],"/contractAccount/wallet"),t}parseWsBalance(e){const t=this.safeInteger(e,"timestamp"),s={info:e,timestamp:t,datetime:this.iso8601(t)},i=this.safeString(e,"currency"),r=this.safeCurrencyCode(i),a=this.account();return a.free=this.safeString(e,"availableBalance"),s[r]=a,this.safeBalance(s)}handleSystemStatus(e,t){return t}handleSubject(e,t){const s=this.safeString(t,"subject"),i={auth:this.handleAuthenticate,received:this.handleL3OrderBook,open:this.handleL3OrderBook,update:this.handleL3OrderBook,done:this.handleL3OrderBook,level2:this.handleLevel2,ticker:this.handleTicker,"snapshot.24h":this.handleTicker,match:this.handleTrade,orderChange:this.handleOrder,stopOrder:this.handleOrder,"availableBalance.change":this.handleBalance,"orderMargin.change":this.handleBalance},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}ping(e){return{id:this.requestId().toString(),type:"ping"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleErrorMessage(e,t){e.reject(t)}handleMessage(e,t){const s=this.safeString(t,"type"),i={welcome:this.handleSystemStatus,ack:this.handleSubscriptionStatus,message:this.handleSubject,pong:this.handlePong,error:this.handleErrorMessage},r=this.safeValue(i,s);void 0!==r&&r.call(this,e,t)}handleAuthenticate(e,t){const s=this.safeValue(t,"data"),i="authenticated";if(this.safeValue(s,"success"))e.resolve(t,i);else{const s=new r.AuthenticationError(this.id+" "+this.json(t));e.reject(s,i),i in e.subscriptions&&delete e.subscriptions[i]}return t}}},5738:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(5037),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!1},urls:{api:{ws:"wss://api.probit.com/api/exchange/v1/ws"},test:{ws:"wss://demo-api.probit.com/api/exchange/v1/ws"}},options:{watchOrderBook:{filter:"order_books_l2",interval:100},watchTrades:{filter:"recent_trades"},watchTicker:{filter:"ticker"},watchOrders:{channel:"open_order"}},streaming:{}})}async watchBalance(e={}){await this.authenticate(e);const t="balance",s=this.urls.api.ws,i=this.extend({type:"subscribe",channel:"balance"},e);return await this.watch(s,t,i,t)}handleBalance(e,t){this.parseWSBalance(t),e.resolve(this.balance,"balance")}parseWSBalance(e){const t=this.safeBool(e,"reset",!1),s=this.safeValue(e,"data",{}),i=Object.keys(s);t&&(this.balance={});for(let e=0;e<i.length;e++){const t=i[e],r=s[t],a=this.safeCurrencyCode(t),o=this.account();o.free=this.safeString(r,"available"),o.total=this.safeString(r,"total"),this.balance[a]=o}this.balance=this.safeBalance(this.balance)}async watchTicker(e,t={}){let s;return[s,t]=this.handleOptionAndParams(t,"watchTicker","filter","ticker"),await this.subscribeOrderBook(e,"ticker",s,t)}handleTicker(e,t){const s=this.safeString(t,"market_id"),i=this.safeSymbol(s),r=this.safeValue(t,"ticker",{}),a=this.safeMarket(s),o=this.parseTicker(r,a),n="ticker:"+i;this.tickers[i]=o,e.resolve(o,n)}async watchTrades(e,t=void 0,s=void 0,i={}){let r;[r,i]=this.handleOptionAndParams(i,"watchTrades","filter","recent_trades");const a=await this.subscribeOrderBook(e,"trades",r,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySymbolSinceLimit(a,e,t,s,!0)}handleTrades(e,t){const s=this.safeString(t,"market_id"),i=this.safeSymbol(s),r=this.safeMarket(s),o=this.safeValue(t,"recent_trades",[]),n=this.safeBool(t,"reset",!1),d="trades:"+i;let h=this.safeValue(this.trades,i);if(void 0===h||n){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new a.I3(e),this.trades[i]=h}for(let e=0;e<o.length;e++){const t=o[e],s=this.parseTrade(t,r);h.append(s)}this.trades[i]=h,e.resolve(this.trades[i],d)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),await this.authenticate(i);let r="myTrades";if(void 0!==e){r=r+":"+(e=this.market(e).symbol)}const a=this.urls.api.ws,o="trade_history",n={type:"subscribe",channel:o},d=this.extend(n,i),h=await this.watch(a,r,d,o);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeValue(t,"data",[]);if(0===s.length)return;const i=this.safeBool(t,"reset",!1),r="myTrades";let o=this.myTrades;if(void 0===o||i){const e=this.safeInteger(this.options,"tradesLimit",1e3);o=new a.Pt(e),this.myTrades=o}const n=this.parseTrades(s),d={};for(let e=0;e<n.length;e++){const t=n[e];d[t.symbol]=!0,o.append(t)}const h=Object.keys(d);for(let t=0;t<h.length;t++){const s=r+":"+h[t];e.resolve(o,s)}e.resolve(o,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.authenticate(i);const r=this.urls.api.ws;let a,o="orders";if(void 0!==e){o=o+":"+(e=this.market(e).symbol)}[a,i]=this.handleOptionAndParams(i,"watchOrders","channel","open_order");const n={type:"subscribe",channel:a},d=this.extend(n,i),h=await this.watch(r,o,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleOrders(e,t){const s=this.safeValue(t,"data",[]);if(0===s.length)return;const i="orders",r=this.safeBool(t,"reset",!1);let o=this.orders;if(void 0===o||r){const e=this.safeInteger(this.options,"ordersLimit",1e3);o=new a.Pt(e),this.orders=o}const n={};for(let e=0;e<s.length;e++){const t=s[e],i=this.parseOrder(t);n[i.symbol]=!0,o.append(i)}const d=Object.keys(n);for(let t=0;t<d.length;t++){const s=i+":"+d[t];e.resolve(o,s)}e.resolve(o,i)}async watchOrderBook(e,t=void 0,s={}){let i;[i,s]=this.handleOptionAndParams(s,"watchOrderBook","filter","order_books");return(await this.subscribeOrderBook(e,"orderbook",i,s)).limit()}async subscribeOrderBook(e,t,s,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=this.urls.api.ws,o=this.client(a);let n;[n,i]=this.handleOptionAndParams(i,"watchOrderBook","interval",100);const d="marketdata:"+e;t=t+":"+e;let h={};d in o.subscriptions&&(h=o.subscriptions[d],s in h||delete o.subscriptions[d]),h[s]=!0;const c=Object.keys(h),l={channel:"marketdata",interval:n,market_id:r.id,type:"subscribe",filter:c},u=this.extend(l,i);return await this.watch(a,t,u,t,h)}handleOrderBook(e,t,s){const i=this.safeString(t,"market_id"),r=this.safeSymbol(i),a=this.groupBy(s,"side"),o="orderbook:"+r;r in this.orderbooks||(this.orderbooks[r]=this.orderBook({}));const n=this.orderbooks[r];if(this.safeBool(t,"reset",!1)){const e=this.parseOrderBook(a,r,void 0,"buy","sell","price","quantity");n.reset(e)}else this.handleDelta(n,a);e.resolve(n,o)}handleBidAsks(e,t){for(let s=0;s<t.length;s++){const i=t[s],r=this.parseBidAsk(i,"price","quantity");e.storeArray(r)}}handleDelta(e,t){const s=e.bids,i=e.asks,r=this.safeValue(t,"sell",[]),a=this.safeValue(t,"buy",[]);this.handleBidAsks(s,a),this.handleBidAsks(i,r)}handleErrorMessage(e,t){const s=this.safeString(t,"errorCode"),i=this.safeString(t,"message",""),a=this.safeValue(t,"details"),o=this.id+" "+s+" "+i+" "+this.json(a);throw"exact"in this.exceptions&&this.throwExactlyMatchedException(this.exceptions.exact,s,o),"broad"in this.exceptions&&this.throwBroadlyMatchedException(this.exceptions.broad,i,o),new r.ExchangeError(o)}handleAuthenticate(e,t){const s=this.safeString(t,"result"),i=e.subscriptions.authenticated;"ok"===s?i.resolve(!0):(i.reject(t),delete e.subscriptions.authenticated)}handleMarketData(e,t){void 0!==this.safeValue(t,"ticker")&&this.handleTicker(e,t);this.safeValue(t,"recent_trades",[]).length&&this.handleTrades(e,t);const s=this.safeValueN(t,["order_books","order_books_l1","order_books_l2","order_books_l3","order_books_l4"],[]);s.length&&this.handleOrderBook(e,t,s)}handleMessage(e,t){if(void 0!==this.safeString(t,"errorCode"))return void this.handleErrorMessage(e,t);if("authorization"===this.safeString(t,"type"))return void this.handleAuthenticate(e,t);const s={marketdata:this.handleMarketData,balance:this.handleBalance,trade_history:this.handleMyTrades,open_order:this.handleOrders,order_history:this.handleOrders},i=this.safeString(t,"channel"),a=this.safeValue(s,i);if(void 0!==a)return void a.call(this,e,t);const o=new r.NotSupported(this.id+" handleMessage: unknown message: "+this.json(t));e.reject(o)}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=this.safeInteger(this.options,"expires",0);let a=this.safeValue(s.subscriptions,i);if(void 0===a||this.milliseconds()>r){const r=await this.signIn(),o={type:"authorization",token:this.safeString(r,"access_token")};a=await this.watch(t,i,this.extend(o,e),i),s.subscriptions[i]=a}return a}}},5794:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(930),r=s(2931),a=s(4852),o=s(5354);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOrderBook:!0,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!0,watchOrders:!0,watchMyTrades:!0,watchBalance:!0},urls:{api:{ws:"wss://{hostname}/websocket/v1"}},options:{tradesLimit:1e3}})}async watchPublic(e,t,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r=i.id,a=this.implodeParams(this.urls.api.ws,{hostname:this.hostname});this.options[t]=this.safeValue(this.options,t,{}),this.options[t][e]=!0;const o=Object.keys(this.options[t]),n=this.marketIds(o),d=[{ticket:this.uuid()},{type:t,codes:n}],h=t+":"+r;return await this.watch(a,h,d,h)}async watchTicker(e,t={}){return await this.watchPublic(e,"ticker")}async watchTrades(e,t=void 0,s=void 0,i={}){return await this.watchTradesForSymbols([e],t,s,i)}async watchTradesForSymbols(e,t=void 0,s=void 0,i={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!1,!0,!0);const r="trade",a=[],o=this.implodeParams(this.urls.api.ws,{hostname:this.hostname});if(void 0!==e)for(let t=0;t<e.length;t++){const s=this.market(e[t]),i=s.id,o=s.symbol;this.options[r]=this.safeValue(this.options,r,{}),this.options[r][o]=!0,a.push(r+":"+i)}const n=Object.keys(this.options[r]),d=this.marketIds(n),h=[{ticket:this.uuid()},{type:r,codes:d}],c=await this.watchMultiple(o,a,h,a);if(this.newUpdates){const e=this.safeValue(c,0),t=this.safeString(e,"symbol");s=c.getLimit(t,s)}return this.filterBySinceLimit(c,t,s,"timestamp",!0)}async watchOrderBook(e,t=void 0,s={}){return(await this.watchPublic(e,"orderbook")).limit()}handleTicker(e,t){const s="ticker:"+this.safeString(t,"code"),i=this.parseTicker(t),r=i.symbol;this.tickers[r]=i,e.resolve(i,s)}handleOrderBook(e,t){const s=this.safeString(t,"code"),i=this.safeSymbol(s,void 0,"-"),r=this.safeString(t,"stream_type"),a=this.safeValue(this.options,"watchOrderBook",{}),o=this.safeInteger(a,"limit",15);"SNAPSHOT"===r&&(this.orderbooks[i]=this.orderBook({},o));const n=this.orderbooks[i];n.reset({}),n.symbol=i;const d=n.bids,h=n.asks,c=this.safeValue(t,"orderbook_units",[]);for(let e=0;e<c.length;e++){const t=c[e],s=this.safeFloat(t,"ask_price"),i=this.safeFloat(t,"ask_size"),r=this.safeFloat(t,"bid_price"),a=this.safeFloat(t,"bid_size");h.store(s,i),d.store(r,a)}const l=this.safeInteger(t,"timestamp"),u=this.iso8601(l);n.timestamp=l,n.datetime=u;const p="orderbook:"+s;e.resolve(n,p)}handleTrades(e,t){const s=this.parseTrade(t),i=s.symbol;let a=this.safeValue(this.trades,i);if(void 0===a){const e=this.safeInteger(this.options,"tradesLimit",1e3);a=new r.I3(e),this.trades[i]=a}a.append(s);const o="trade:"+this.safeString(t,"code");e.resolve(a,o)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.safeDict(this.options,"ws",{});if(void 0===this.safeString(t,"token")){const e={access_key:this.apiKey,nonce:this.uuid()},s=(0,o.a)(e,this.encode(this.secret),a.s,!1);t.token=s,t.options={headers:{authorization:"Bearer "+s}},this.options.ws=t}const s=this.urls.api.ws+"/private";return this.client(s)}async watchPrivate(e,t,s,i={}){await this.authenticate();const r={type:t};if(void 0!==e){await this.loadMarkets();const t=[e=this.market(e).symbol],i=this.marketIds(t);r.codes=i,s=s+":"+e}let a=this.implodeParams(this.urls.api.ws,{hostname:this.hostname});a+="/private";const o=[{ticket:this.uuid()},r];return await this.watch(a,s,o,s)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.watchPrivate(e,"myOrder","myOrder");return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.watchPrivate(e,"myOrder","myTrades");return this.newUpdates&&(s=r.getLimit(e,s)),this.filterBySymbolSinceLimit(r,e,t,s,!0)}parseWsOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled",watch:"open",trade:"open"},e,e)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"uuid");let i=this.safeStringLower(e,"ask_bid");i="bid"===i?"buy":"sell";const r=this.parse8601(this.safeString(e,"order_timestamp")),a=this.parseWsOrderStatus(this.safeString(e,"state")),o=this.safeString(e,"code");let n;t=this.safeMarket(o,t);const d=this.safeString(e,"paid_fee");return void 0!==d&&(n={currency:t.quote,cost:d}),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:this.safeString(e,"trade_timestamp"),symbol:t.symbol,type:this.safeString(e,"order_type"),timeInForce:this.safeString(e,"time_in_force"),postOnly:void 0,side:i,price:this.safeString(e,"price"),stopPrice:void 0,triggerPrice:void 0,cost:this.safeString(e,"executed_funds"),average:this.safeString(e,"avg_price"),amount:this.safeString(e,"volume"),filled:this.safeString(e,"executed_volume"),remaining:this.safeString(e,"remaining_volume"),status:a,fee:n,trades:void 0})}parseWsTrade(e,t=void 0){let s=this.safeStringLower(e,"ask_bid");s="bid"===s?"buy":"sell";const i=this.parse8601(this.safeString(e,"trade_timestamp")),r=this.safeString(e,"code");let a;t=this.safeMarket(r,t);const o=this.safeString(e,"paid_fee");return void 0!==o&&(a={currency:t.quote,cost:o}),this.safeTrade({id:this.safeString(e,"trade_uuid"),timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,side:s,price:this.safeString(e,"price"),amount:this.safeString(e,"volume"),cost:this.safeString(e,"executed_funds"),order:this.safeString(e,"uuid"),takerOrMaker:void 0,type:this.safeString(e,"order_type"),fee:a,info:e},t)}handleMyOrder(e,t){void 0!==this.safeString(t,"trade_uuid")&&this.handleMyTrade(e,t),this.handleOrder(e,t)}handleMyTrade(e,t){let s=this.myTrades;if(void 0===s){const e=this.safeInteger(this.options,"tradesLimit",1e3);s=new r.Pt(e)}const i=this.parseWsTrade(t);s.append(i);let a="myTrades";e.resolve(s,a),a="myTrades:"+i.symbol,e.resolve(s,a)}handleOrder(e,t){const s=this.parseWsOrder(t),i=this.safeString(s,"symbol"),a=this.safeString(s,"id");if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new r.Pt(e)}const o=this.orders,n=this.safeValue(o.hashmap,i,{}),d=this.safeValue(n,a);if(void 0!==d){const e=this.safeValue(d,"fee");void 0!==e&&(s.fee=e);const t=this.safeValue(d,"fees");void 0!==t&&(s.fees=t),s.trades=this.safeValue(d,"trades"),s.timestamp=this.safeInteger(d,"timestamp"),s.datetime=this.safeString(d,"datetime")}o.append(s);let h="myOrder";e.resolve(this.orders,h),h=h+":"+i,e.resolve(this.orders,h)}async watchBalance(e={}){await this.loadMarkets();return await this.watchPrivate(void 0,"myAsset","myAsset")}handleBalance(e,t){const s=this.safeList(t,"assets",[]),i=this.safeInteger(t,"timestamp");this.balance.timestamp=i,this.balance.datetime=this.iso8601(i);for(let e=0;e<s.length;e++){const t=s[e],i=this.safeString(t,"currency"),r=this.safeCurrencyCode(i),a=this.safeString(t,"balance"),o=this.safeString(t,"locked"),n=this.account();n.free=a,n.used=o,this.balance[r]=n,this.balance=this.safeBalance(this.balance)}const r=this.safeString(t,"type");e.resolve(this.balance,r)}handleMessage(e,t){const s={ticker:this.handleTicker,orderbook:this.handleOrderBook,trade:this.handleTrades,myOrder:this.handleMyOrder,myAsset:this.handleBalance},i=this.safeString(t,"type"),r=this.safeValue(s,i);r&&r.call(this,e,t)}}},910:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(4910),r=s(2079),a=s(2931),o=s(5147);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!1,watchMyTrades:!0,watchOHLCV:!1,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!1,watchTrades:!0,watchTradesForSymbols:!1,watchPositions:!0},urls:{api:{ws:"wss://gateway.prod.vertexprotocol.com/v1/subscribe"},test:{ws:"wss://gateway.sepolia-test.vertexprotocol.com/v1/subscribe"}},requiredCredentials:{apiKey:!1,secret:!1,walletAddress:!0,privateKey:!0},options:{tradesLimit:1e3,ordersLimit:1e3,requestId:{},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0}},streaming:{keepAlive:3e4},exceptions:{ws:{exact:{"Auth is needed.":r.AuthenticationError}}}})}requestId(e){const t=this.safeDict(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}async watchPublic(e,t){const s=this.urls.api.ws,i={id:this.requestId(s)},r=this.extend(i,t);return await this.watch(s,e,r,e,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trade",o=r.id+"@"+a,n={method:"subscribe",stream:{type:a,product_id:this.parseToNumeric(r.id)}},d=this.extend(n,i),h=await this.watchPublic(o,d);return this.newUpdates&&(s=h.getLimit(r.symbol,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}handleTrade(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.parseWsTrade(t),o=r.symbol;if(!(o in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3),t=new a.I3(e);this.trades[o]=t}const n=this.trades[o];n.append(r),this.trades[o]=n,e.resolve(n,i+"@"+s)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchMyTrades requires a symbol.");let a;await this.loadMarkets(),[a,i]=this.handlePublicAddress("watchMyTrades",i);const o=this.market(e),n="fill",d=o.id+"@"+n,h={method:"subscribe",stream:{type:n,product_id:this.parseToNumeric(o.id),subaccount:this.convertAddressToSender(a)}},c=this.extend(h,i),l=await this.watchPublic(d,c);return this.newUpdates&&(s=l.getLimit(e,s)),this.filterBySymbolSinceLimit(l,e,t,s,!0)}handleMyTrades(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id");if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new a.Pt(e)}const r=this.myTrades,o=this.parseWsTrade(t);r.append(o),e.resolve(r,i+"@"+s)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"product_id"),i=(t=this.safeMarket(s,t)).symbol,r=this.convertFromX18(this.safeString(e,"price")),a=this.convertFromX18(this.safeString2(e,"taker_qty","filled_qty")),n=o.Y.stringMul(r,a),d=this.safeIntegerProduct(e,"timestamp",1e-6);let h;const c=this.safeBool(e,"is_taker");let l;void 0!==c&&(h=c?"taker":"maker");const u=this.safeBool(e,"is_bid");return void 0!==u&&(l=u?"buy":"sell"),this.safeTrade({id:void 0,timestamp:d,datetime:this.iso8601(d),symbol:i,side:l,price:r,amount:a,cost:n,order:this.safeString2(e,"digest","id"),takerOrMaker:h,type:void 0,fee:void 0,info:e},t)}async watchTicker(e,t={}){await this.loadMarkets();const s="best_bid_offer",i=this.market(e),r=i.id+"@"+s,a={method:"subscribe",stream:{type:s,product_id:this.parseToNumeric(i.id)}},o=this.extend(a,t);return await this.watchPublic(r,o)}parseWsTicker(e,t=void 0){const s=this.safeIntegerProduct(e,"timestamp",1e-6);return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.convertFromX18(this.safeString(e,"bid_price")),bidVolume:this.convertFromX18(this.safeString(e,"bid_qty")),ask:this.convertFromX18(this.safeString(e,"ask_price")),askVolume:this.convertFromX18(this.safeString(e,"ask_qty")),vwap:void 0,open:void 0,close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:void 0,info:e},t)}handleTicker(e,t){const s=this.safeString(t,"product_id"),i=this.safeMarket(s),r=this.parseWsTicker(t,i);return r.symbol=i.symbol,this.tickers[i.symbol]=r,e.resolve(r,s+"@best_bid_offer"),t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i="book_depth",r=this.market(e),a=r.id+"@"+i,o=this.urls.api.ws,n=this.requestId(o),d={id:n,method:"subscribe",stream:{type:i,product_id:this.parseToNumeric(r.id)}},h={id:n.toString(),name:i,symbol:e,method:this.handleOrderBookSubscription,limit:t,params:s},c=this.extend(d,s);return(await this.watch(o,a,c,a,h)).limit()}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),r=this.safeInteger(s,"limit",i),a=this.safeString(s,"symbol");a in this.orderbooks&&delete this.orderbooks[a],this.orderbooks[a]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),r=this.market(i).id+"@book_depth";try{const t=this.safeInteger(this.options,"watchOrderBookLimit",1e3),a=this.safeInteger(s,"limit",t),n=this.safeValue(s,"params"),d=await this.fetchRestOrderBookSafe(i,a,n);if(void 0===this.safeValue(this.orderbooks,i))return;const h=this.orderbooks[i];h.reset(d);const c=h.cache;for(let t=0;t<c.length;t++){const s=c[t];this.parseToInt(o.Y.stringDiv(this.safeString(s,"last_max_timestamp"),"1000000"))<h.timestamp||this.handleOrderBookMessage(e,s,h)}this.orderbooks[i]=h,e.resolve(h,r)}catch(t){delete e.subscriptions[r],e.reject(t,r)}}handleOrderBook(e,t){const s=this.safeString(t,"product_id"),i=this.safeMarket(s).symbol;i in this.orderbooks||(this.orderbooks[i]=this.orderBook());const r=this.orderbooks[i],a=this.safeInteger(r,"timestamp");if(void 0===a)r.cache.push(t);else{this.parseToInt(o.Y.stringDiv(this.safeString(t,"last_max_timestamp"),"1000000"))>a&&(this.handleOrderBookMessage(e,t,r),e.resolve(r,s+"@book_depth"))}}handleOrderBookMessage(e,t,s){const i=this.parseToInt(o.Y.stringDiv(this.safeString(t,"last_max_timestamp"),"1000000")),r={bids:[],asks:[]},a=this.safeList(t,"bids",[]);for(let e=0;e<a.length;e++){const t=a[e];r.bids.push([this.convertFromX18(t[0]),this.convertFromX18(t[1])])}const n=this.safeList(t,"asks",[]);for(let e=0;e<n.length;e++){const t=n[e];r.asks.push([this.convertFromX18(t[0]),this.convertFromX18(t[1])])}return this.handleDeltas(s.asks,this.safeList(r,"asks",[])),this.handleDeltas(s.bids,this.safeList(r,"bids",[])),s.timestamp=i,s.datetime=this.iso8601(i),s}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleSubscriptionStatus(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s,{}),a=this.safeValue(r,"method");return void 0!==a&&a.call(this,e,t,r),t}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),e=this.marketSymbols(e),this.isEmpty(e))throw new r.ArgumentsRequired(this.id+" watchPositions require one symbol.");if(e.length>1)throw new r.NotSupported(this.id+" watchPositions require only one symbol.");let a;[a,i]=this.handlePublicAddress("watchPositions",i);const o=this.urls.api.ws,n=this.client(o);this.setPositionsCache(n,e,i);const d=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),h=this.handleOption("watchPositions","awaitPositionsSnapshot",!0);if(d&&h&&void 0===this.positions){const i=await n.future("fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const c="position_change",l=this.market(e[0]),u=l.id+"@"+c,p={method:"subscribe",stream:{type:c,product_id:this.parseToNumeric(l.id),subaccount:this.convertAddressToSender(a)}},f=this.extend(p,i),m=await this.watchPublic(u,f);return this.newUpdates&&(s=m.getLimit(e[0],s)),this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}setPositionsCache(e,t=void 0,s={}){if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const i="fetchPositionsSnapshot";i in e.futures||(e.future(i),this.spawn(this.loadPositionsSnapshot,e,i,t,s))}else this.positions=new a.Hk}async loadPositionsSnapshot(e,t,s,i){const r=await this.fetchPositions(s,i);this.positions=new a.Hk;const o=this.positions;for(let e=0;e<r.length;e++){const t=r[e];o.append(t)}e.futures[t].resolve(o),e.resolve(o,"positions")}handlePositions(e,t){void 0===this.positions&&(this.positions=new a.Hk);const s=this.positions,i=this.safeString(t,"type"),r=this.safeString(t,"product_id"),o=this.safeMarket(r),n=this.parseWsPosition(t,o);s.append(n),e.resolve(n,r+"@"+i)}parseWsPosition(e,t=void 0){const s=this.safeString(e,"product_id");t=this.safeMarket(s);const i=this.convertFromX18(this.safeString(e,"amount"));let r="buy";o.Y.stringLt(i,"1")&&(r="sell");const a=this.parseToInt(o.Y.stringDiv(this.safeString(e,"timestamp"),"1000000"));return this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:a,datetime:this.iso8601(a),lastUpdateTimestamp:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:void 0,notional:void 0,leverage:void 0,unrealizedPnl:void 0,contracts:void 0,contractSize:this.parseNumber(i),marginRatio:void 0,liquidationPrice:void 0,markPrice:void 0,lastPrice:void 0,collateral:void 0,marginMode:"cross",marginType:void 0,side:r,percentage:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}handleAuth(e,t){const s="authenticated";if(void 0===this.safeString(t,"error")){this.safeValue(e.futures,"authenticated").resolve(!0)}else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions.authenticated}}buildWsAuthenticationSig(e,t,s){return this.buildSig(t,{StreamAuthentication:[{name:"sender",type:"bytes32"},{name:"expiration",type:"uint64"}]},e,s)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s=this.requestId(t),r=await this.queryContracts(),a=this.safeString(r,"chain_id"),o=this.safeString(r,"endpoint_addr"),n=this.nonce()+9e4,d={sender:this.convertAddressToSender(this.walletAddress),expiration:n},h={id:s,method:"authenticate",tx:{sender:d.sender,expiration:this.numberToString(d.expiration)},signature:this.buildWsAuthenticationSig(d,a,o)},c=this.extend(h,e);this.watch(t,i,c,i)}return await r}async watchPrivate(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" watchOrders requires a symbol.");this.checkRequiredCredentials(),await this.loadMarkets();const a="order_update",o=this.market(e),n=o.id+"@"+a,d={method:"subscribe",stream:{type:a,subaccount:this.convertAddressToSender(this.walletAddress),product_id:this.parseToNumeric(o.id)}},h=this.extend(d,i),c=await this.watchPrivate(n,h);return this.newUpdates&&(s=c.getLimit(e,s)),this.filterBySymbolSinceLimit(c,e,t,s,!0)}parseWsOrderStatus(e){if(void 0!==e){const t={filled:"open",placed:"open",cancelled:"canceled"};return this.safeString(t,e,e)}return e}parseWsOrder(e,t=void 0){const s=this.safeString(e,"product_id"),i=this.parseToInt(o.Y.stringDiv(this.safeString(e,"timestamp"),"1000000")),r=this.convertFromX18(this.safeString(e,"amount")),a=this.parseToNumeric(r);let n=this.parseWsOrderStatus(this.safeString(e,"reason"));o.Y.stringEq(r,"0")&&"open"===n&&(n="closed");const d=(t=this.safeMarket(s,t)).symbol;return this.safeOrder({info:e,id:this.safeString2(e,"digest","id"),clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,lastUpdateTimestamp:void 0,symbol:d,type:void 0,timeInForce:void 0,postOnly:void 0,reduceOnly:void 0,side:void 0,price:void 0,triggerPrice:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:a,status:n,fee:void 0,trades:void 0},t)}handleOrderUpdate(e,t){const s=this.safeString(t,"type"),i=this.safeString(t,"product_id"),r=this.parseWsOrder(t),o=this.safeString(r,"symbol"),n=this.safeString(r,"id");if(void 0!==o){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,d=this.safeDict(t.hashmap,o,{}),h=this.safeDict(d,n);void 0!==h&&(r.timestamp=this.safeInteger(h,"timestamp"),r.datetime=this.safeString(h,"datetime")),t.append(r),e.resolve(this.orders,i+"@"+s)}}handleErrorMessage(e,t){const s=this.safeString(t,"error");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s={trade:this.handleTrade,best_bid_offer:this.handleTicker,book_depth:this.handleOrderBook,fill:this.handleMyTrades,position_change:this.handlePositions,order_update:this.handleOrderUpdate},i=this.safeString(t,"type"),r=this.safeValue(s,i);if(void 0!==r)return void r.call(this,e,t);if(void 0!==this.safeString(t,"id"))return void this.handleSubscriptionStatus(e,t);void 0!==this.safeValue(e.futures,"authenticated")&&this.handleAuth(e,t)}}},9279:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(3439),r=s(2079),a=s(2931);class o extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchMyTrades:!0,watchOrders:!0,watchOrderBook:!0,watchOHLCV:!0},urls:{api:{ws:"wss://stream.wazirx.com/stream"}},options:{},streaming:{},exceptions:{},api:{private:{post:{create_auth_token:1}}}})}async watchBalance(e={}){await this.loadMarkets();const t=await this.authenticate(e),s="balance",i=this.urls.api.ws,r={event:"subscribe",streams:["outboundAccountPosition"],auth_key:t},a=this.deepExtend(r,e);return await this.watch(i,s,a,s)}handleBalance(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"B",[]),r=this.safeInteger(s,"E");this.balance.info=i,this.balance.timestamp=r,this.balance.datetime=this.iso8601(r);for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"a"),r=this.safeCurrencyCode(s),a=this.safeString(t,"b"),o=this.safeString(t,"l"),n=this.account();n.free=a,n.used=o,this.balance[r]=n}this.balance=this.safeBalance(this.balance);e.resolve(this.balance,"balance")}parseWsTrade(e,t=void 0){const s=this.safeInteger(e,"E"),i=this.safeString(e,"s");t=this.safeMarket(i,t);const r=this.safeString(e,"f"),a=this.safeString(e,"U"),o=!0===this.safeValue(e,"m");let n;return void 0!==r&&(n={cost:r,currency:this.safeCurrencyCode(a),rate:void 0}),this.safeTrade({id:this.safeString(e,"t"),info:e,timestamp:s,datetime:this.iso8601(s),symbol:t.symbol,order:this.safeStringN(e,["o"]),type:void 0,side:this.safeString(e,"S"),takerOrMaker:o?"maker":"taker",price:this.safeString(e,"p"),amount:this.safeString(e,"q"),cost:void 0,fee:n},t)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.urls.api.ws,r="ticker:"+s.symbol,a={event:"subscribe",streams:["!ticker@arr"]},o=this.deepExtend(a,t);return await this.watch(i,r,o,"tickers")}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=this.urls.api.ws,i="tickers",r={event:"subscribe",streams:["!ticker@arr"]},a=this.deepExtend(r,t),o=await this.watch(s,i,a,i);return this.filterByArray(o,"symbol",e,!1)}handleTicker(e,t){const s=this.safeValue(t,"data",[]);for(let t=0;t<s.length;t++){const i=s[t],r=this.parseWSTicker(i),a=r.symbol;this.tickers[a]=r;const o="ticker:"+a;e.resolve(r,o)}e.resolve(this.tickers,"tickers")}parseWSTicker(e,t=void 0){const s=this.safeString(e,"s"),i=this.safeInteger(e,"E");return this.safeTicker({symbol:this.safeSymbol(s,t),timestamp:i,datetime:this.iso8601(i),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeNumber(e,"b"),bidVolume:void 0,ask:this.safeNumber(e,"a"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"o"),close:void 0,last:this.safeString(e,"l"),previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:void 0,quoteVolume:this.safeString(e,"q"),info:e},t)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id+"@trades",o=this.urls.api.ws,n={event:"subscribe",streams:[a]},d=this.extend(n,i),h=await this.watch(o,a,d,a);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySinceLimit(h,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"trades",[]),r=this.safeString(t,"stream"),o=r.split("@"),n=this.safeString(o,0),d=this.safeMarket(n),h=this.safeSymbol(n,d);let c=this.safeValue(this.trades,h);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e),this.trades[h]=c}for(let e=0;e<i.length;e++){const t=this.parseWsTrade(i[e],d);c.append(t)}e.resolve(c,r)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.authenticate(i);if(void 0!==e){e=this.market(e).symbol}const a=this.urls.api.ws,o="myTrades",n={event:"subscribe",streams:["ownTrade"],auth_key:r},d=this.deepExtend(n,i),h=await this.watch(a,o,d,o);return this.newUpdates&&(s=h.getLimit(e,s)),this.filterBySymbolSinceLimit(h,e,t,s,!0)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.urls.api.ws,n="ohlcv:"+e+":"+t,d={event:"subscribe",streams:[a.id+"@kline_"+t]},h=this.deepExtend(d,r),c=await this.watch(o,n,h,n);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data",{}),i=this.safeString(s,"s"),r=this.safeMarket(i),o=this.safeSymbol(i,r),n=this.safeString(s,"i");this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let d=this.safeValue(this.ohlcvs[o],n);if(void 0===d){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);d=new a.TG(e),this.ohlcvs[o][n]=d}const h=this.parseWsOHLCV(s,r);d.append(h);const c="ohlcv:"+o+":"+n;e.resolve(d,c)}parseWsOHLCV(e,t=void 0){return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"c"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"v")]}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);e=i.symbol;const r=this.urls.api.ws,a="orderbook:"+e,o={event:"subscribe",streams:[i.id+"@depth"]},n=this.deepExtend(o,s);return(await this.watch(r,a,n,a)).limit()}handleDelta(e,t){const s=this.parseBidAsk(t,0,1);e.storeArray(s)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}handleOrderBook(e,t){const s=this.safeValue(t,"data",{}),i=this.safeInteger(s,"E"),r=this.safeString(s,"s"),a=this.safeMarket(r).symbol,o="orderbook:"+a;if(a in this.orderbooks){const e=this.orderbooks[a],t=this.safeList(s,"a",[]),r=this.safeList(s,"b",[]);this.handleDeltas(e.asks,t),this.handleDeltas(e.bids,r),e.nonce=i,e.timestamp=i,e.datetime=this.iso8601(i),this.orderbooks[a]=e}else{const e=this.parseOrderBook(s,a,i,"b","a");this.orderbooks[a]=this.orderBook(e)}e.resolve(this.orderbooks[a],o)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(await this.loadMarkets(),void 0!==e){e=this.market(e).symbol}const r="orders",a={event:"subscribe",streams:["orderUpdate"],auth_key:await this.authenticate(i)},o=this.urls.api.ws,n=this.deepExtend(a,i),d=await this.watch(o,r,n,r,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleOrder(e,t){const s=this.safeValue(t,"data",{}),i=this.parseWsOrder(s);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}this.orders.append(i);let r="orders";e.resolve(this.orders,r),r+=":"+i.symbol,e.resolve(this.orders,r)}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"O"),i=this.safeString(e,"s"),r=this.safeString(e,"X");return t=this.safeMarket(i),this.safeOrder({info:e,id:this.safeString(e,"i"),clientOrderId:this.safeString(e,"c"),datetime:this.iso8601(s),timestamp:s,lastTradeTimestamp:void 0,symbol:t.symbol,type:this.safeValue(e,"m")?"limit":"market",timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"o"),price:this.safeString(e,"p"),stopPrice:void 0,triggerPrice:void 0,amount:this.safeString(e,"V"),filled:void 0,remaining:this.safeString(e,"q"),cost:void 0,average:this.safeString(e,"v"),status:this.parseOrderStatus(r),fee:void 0,trades:void 0},t)}handleMyTrades(e,t){const s=this.safeValue(t,"data",{});let i;if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new a.Pt(e),this.myTrades=i}else i=this.myTrades;const r=this.parseWsTrade(s);i.append(r),e.resolve(i,"myTrades")}handleConnected(e,t){return t}handleSubscribed(e,t){return t}handleError(e,t){throw new r.ExchangeError(this.id+" "+this.json(t))}handleMessage(e,t){if("error"===this.safeString(t,"status"))return void this.handleError(e,t);const s=this.safeString(t,"event"),i={error:this.handleError,connected:this.handleConnected,subscribed:this.handleSubscribed},a=this.safeValue(i,s);if(void 0!==a)return void a.call(this,e,t);const o=this.safeString(t,"stream",""),n={"ticker@arr":this.handleTicker,"@depth":this.handleOrderBook,"@kline":this.handleOHLCV,"@trades":this.handleTrades,outboundAccountPosition:this.handleBalance,orderUpdate:this.handleOrder,ownTrade:this.handleMyTrades},d=Object.keys(n);for(let s=0;s<d.length;s++){if(o.indexOf(d[s])>-1){return void n[d[s]].call(this,e,t)}}throw new r.NotSupported(this.id+" this message type is not supported yet. Message: "+this.json(t))}async authenticate(e={}){const t=this.urls.api.ws,s=this.client(t),i="authenticated",r=this.milliseconds();let a=this.safeValue(s.subscriptions,i);const o=this.safeInteger(a,"expires");return(void 0===a||r>o)&&(a=await this.privatePostCreateAuthToken(),a.expires=r+1e3*this.safeInteger(a,"timeout_duration"),s.subscriptions[i]=a),this.safeString(a,"auth_key")}}},4712:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(5336),r=s(5147),a=s(2079),o=s(2931);class n extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTrades:!0,watchTradesForSymbols:!1},urls:{api:{ws:"wss://api.whitebit.com/ws"}},options:{timeframes:{"1m":"60","5m":"300","15m":"900","30m":"1800","1h":"3600","4h":"14400","8h":"28800","1d":"86400","1w":"604800"},watchOrderBook:{priceInterval:0}},streaming:{ping:this.ping},exceptions:{ws:{exact:{1:a.BadRequest,2:a.BadRequest,4:a.BadRequest,6:a.AuthenticationError}}}})}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e);e=a.symbol;const o=this.safeValue(this.options,"timeframes",{}),n=this.safeInteger(o,t),d="candles:"+e,h=[a.id,n],c=await this.watchPublic(d,"candles_subscribe",h,r);return this.newUpdates&&(i=c.getLimit(e,i)),this.filterBySinceLimit(c,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"params",[]);for(let t=0;t<s.length;t++){const i=s[t],r=this.safeString(i,7),a=this.safeMarket(r),n=a.symbol,d="candles:"+n,h=this.parseOHLCV(i,a);if(n in this.ohlcvs||(this.ohlcvs[n]={}),!("unknown"in this.ohlcvs[n])){const e=this.safeInteger(this.options,"OHLCVLimit",1e3),t=new o.TG(e);this.ohlcvs[n].unknown=t}const c=this.ohlcvs[n].unknown;c.append(h),e.resolve(c,d)}return t}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e);void 0===t&&(t=10);const r="orderbook:"+i.symbol,a=this.safeValue(this.options,"watchOrderBook",{}),o=this.safeString(a,"priceInterval","0"),n=this.safeString(s,"priceInterval",o);s=this.omit(s,"priceInterval");const d=[i.id,t,n,!0];return(await this.watchPublic(r,"depth_subscribe",d,s)).limit()}handleOrderBook(e,t){const s=this.safeValue(t,"params",[]),i=this.safeValue(s,0),r=this.safeString(s,2),a=this.safeMarket(r).symbol,o=this.safeValue(s,1),n=this.safeTimestamp(o,"timestamp");if(!(a in this.orderbooks)){const e=this.orderBook();this.orderbooks[a]=e}const d=this.orderbooks[a];if(d.timestamp=n,d.datetime=this.iso8601(n),i){const e=this.parseOrderBook(o,a);d.reset(e)}else{const e=this.safeValue(o,"asks",[]),t=this.safeValue(o,"bids",[]);this.handleDeltas(d.asks,e),this.handleDeltas(d.bids,t)}const h="orderbook:"+a;e.resolve(d,h)}handleDelta(e,t){const s=this.safeFloat(t,0),i=this.safeFloat(t,1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets();const s="ticker:"+(e=this.market(e).symbol);return await this.watchMultipleSubscription(s,"market_subscribe",e,!1,t)}handleTicker(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),r=this.safeMarket(i,void 0),a=r.symbol,o=this.safeValue(s,1,{}),n="ticker:"+a,d=this.parseTicker(o,r);this.tickers[a]=d,e.resolve(d,n);const h=Object.keys(e.futures);for(let t=0;t<h.length;t++){const s=h[t];s.indexOf("tickers")>=0&&s.indexOf(a)>=0&&e.resolve(d,s)}return t}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r="trades:"+(e=this.market(e).symbol),a=await this.watchMultipleSubscription(r,"trades_subscribe",e,!1,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp",!0)}handleTrades(e,t){const s=this.safeValue(t,"params",[]),i=this.safeString(s,0),r=this.safeMarket(i),a=r.symbol;let n=this.safeValue(this.trades,a);if(void 0===n){const e=this.safeInteger(this.options,"tradesLimit",1e3);n=new o.I3(e),this.trades[a]=n}const d=this.safeValue(s,1,[]),h=this.parseTrades(d,r);for(let e=0;e<h.length;e++)n.append(h[e]);const c="trades:"+r.symbol;e.resolve(n,c)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" watchMyTrades() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const r="myTrades:"+(e=this.market(e).symbol),o=await this.watchMultipleSubscription(r,"deals_subscribe",e,!0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleMyTrades(e,t,s=void 0){const i=this.safeValue(t,"params");if(void 0===this.myTrades){const e=this.safeInteger(this.options,"tradesLimit",1e3);this.myTrades=new o.I3(e)}const r=this.myTrades,a=this.parseWsTrade(i);r.append(a);const n="myTrades:"+a.symbol;e.resolve(r,n)}parseWsTrade(e,t=void 0){const s=this.safeString(e,3),i=this.safeTimestamp(e,1),r=this.safeString(e,0),a=this.safeString(e,4),o=this.safeString(e,5),n=this.safeString(e,2);let d;t=this.safeMarket(n,t);const h=this.safeString(e,6);return void 0!==h&&(d={cost:h,currency:t.quote}),this.safeTrade({id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:t.symbol,order:s,type:void 0,side:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:d},t)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" watchOrders() requires a symbol argument");await this.loadMarkets(),await this.authenticate();const r="orders:"+(e=this.market(e).symbol),o=await this.watchMultipleSubscription(r,"ordersPending_subscribe",e,!1,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySymbolSinceLimit(o,e,t,s,!0)}handleOrder(e,t,s=void 0){const i=this.safeValue(t,"params",[]),r=this.safeValue(i,1);if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new o.Pt(e)}const a=this.orders,n=this.safeInteger(i,0),d=this.parseWsOrder(this.extend(r,{status:n}));a.append(d);const h="orders:"+d.symbol;e.resolve(this.orders,h)}parseWsOrder(e,t=void 0){const s=this.safeInteger(e,"status"),i=this.safeString(e,"market");t=this.safeMarket(i,t);const a=this.safeString(e,"id"),o=this.omitZero(this.safeString(e,"client_order_id")),n=this.safeString(e,"price"),d=this.safeString(e,"deal_stock"),h=this.safeString(e,"deal_money"),c=this.safeString(e,"activation_price"),l=this.safeString(e,"type"),u=this.parseWsOrderType(l);let p,f;"market"===u?(p=this.safeString(e,"deal_stock"),f="0"):(f=this.safeString(e,"left"),p=this.safeString(e,"amount"));const m=this.safeTimestamp(e,"ctime"),g=this.safeTimestamp(e,"mtime"),v=t.symbol,y=1===this.safeInteger(e,"side")?"sell":"buy",w=this.safeString(e,"deal_fee");let b,S;return void 0!==w&&(b={cost:this.parseNumber(w),currency:t.quote}),S=1===s||2===s?"open":r.Y.stringEquals(f,"0")?"closed":"canceled",this.safeOrder({info:e,symbol:v,id:a,clientOrderId:o,timestamp:m,datetime:this.iso8601(m),lastTradeTimestamp:g,type:u,timeInForce:void 0,postOnly:void 0,side:y,price:n,stopPrice:c,triggerPrice:c,amount:p,cost:h,average:void 0,filled:d,remaining:f,status:S,fee:b,trades:void 0},t)}parseWsOrderType(e){return this.safeString({1:"limit",2:"market",202:"market",3:"limit",4:"market",5:"limit",6:"market",8:"limit",10:"market"},e,e)}async watchBalance(e={}){let t;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("watchBalance",void 0,e);let s,i="wallet:";"spot"===t?(s="balanceSpot_subscribe",i+="spot"):(s="balanceMargin_subscribe",i+="margin");const r=Object.keys(this.currencies);return await this.watchPrivate(i,s,r,e)}handleBalance(e,t){const s=this.safeString(t,"method"),i=this.safeValue(t,"params"),r=this.safeValue(i,0);this.balance.info=r;const a=Object.keys(r),o=this.safeValue(a,0),n=this.safeValue(r,o),d=this.safeCurrencyCode(o),h=this.account();h.free=this.safeString(n,"available"),h.used=this.safeString(n,"freeze"),this.balance[d]=h,this.balance=this.safeBalance(this.balance);let c="wallet:";s.indexOf("Spot")>=0?c+="spot":c+="margin",e.resolve(this.balance,c)}async watchPublic(e,t,s=[],i={}){const r=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(r,e,o,e)}async watchMultipleSubscription(e,t,s,i=!1,r={}){await this.loadMarkets();const a=this.urls.api.ws,o=this.nonce(),n=this.safeValue(this.clients,a);let d,h=[];if(void 0===n){const n={},c=this.market(s).id;n[c]=!0,h=[c],i&&(h=[h]),d={id:o,method:t,params:h};const l=this.extend(d,r);return await this.watch(a,e,l,t,n)}{const r=this.safeValue(n.subscriptions,t,{});let h=!0;const c=this.market(s).id;if(this.safeBool(r,c,!1)||(r[c]=!0,h=!1),h)return await this.watch(a,e,d,t,r);{let s=[];s=Object.keys(r),i&&(s=[s]);const d={id:o,method:t,params:s};return t in n.subscriptions&&delete n.subscriptions[t],await this.watch(a,e,d,t,r)}}}async watchPrivate(e,t,s=[],i={}){this.checkRequiredCredentials(),await this.authenticate();const r=this.urls.api.ws,a={id:this.nonce(),method:t,params:s},o=this.extend(a,i);return await this.watch(r,e,o,e)}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws,s="authenticated",i=this.client(t),r=i.future("authenticated");if(void 0===this.safeValue(i.subscriptions,s)){const e=await this.v4PrivatePostProfileWebsocketToken(),a=this.safeString(e,"websocket_token"),o=this.nonce(),n={id:o,method:"authorize",params:[a,"public"]},d={id:o,method:this.handleAuthenticate};try{await this.watch(t,s,n,s,d)}catch(e){delete i.subscriptions[s],r.reject(e)}}return await r}handleAuthenticate(e,t){return e.futures.authenticated.resolve(1),t}handleErrorMessage(e,t){const s=this.safeValue(t,"error");try{if(void 0!==s){const e=this.safeString(t,"code"),s=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.ws.exact,e,s)}}catch(t){if(t instanceof a.AuthenticationError)return e.reject(t,"authenticated"),"authenticated"in e.subscriptions&&delete e.subscriptions.authenticated,!1}return t}handleMessage(e,t){if(!this.handleErrorMessage(e,t))return;if("pong"===this.safeString(t,"result"))return void this.handlePong(e,t);const s=this.safeInteger(t,"id");if(void 0!==s)return void this.handleSubscriptionStatus(e,t,s);const i={market_update:this.handleTicker,trades_update:this.handleTrades,depth_update:this.handleOrderBook,candles_update:this.handleOHLCV,ordersPending_update:this.handleOrder,ordersExecuted_update:this.handleOrder,balanceSpot_update:this.handleBalance,balanceMargin_update:this.handleBalance,deals_update:this.handleMyTrades},r=this.safeValue(t,"method"),a=this.safeValue(i,r);void 0!==a&&a.call(this,e,t)}handleSubscriptionStatus(e,t,s){const i=e.subscriptions,r=Object.values(i);for(let i=0;i<r.length;i++){const a=r[i];if(!0!==a){const i=this.safeInteger(a,"id");if(void 0!==i&&i===s){const s=this.safeValue(a,"method");if(void 0!==s)return void s.call(this,e,t)}}}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}ping(e){return{id:0,method:"ping",params:[]}}}},5869:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(669),r=s(2079),a=s(2931),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchPositions:!0},urls:{api:{ws:{public:"wss://wss.woo.org/ws/stream",private:"wss://wss.woo.org/v2/ws/private/stream"}},test:{ws:{public:"wss://wss.staging.woo.org/ws/stream",private:"wss://wss.staging.woo.org/v2/ws/private/stream"}}},requiredCredentials:{apiKey:!0,secret:!0,uid:!0},options:{tradesLimit:1e3,ordersLimit:1e3,requestId:{},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0}},streaming:{ping:this.ping,keepAlive:9e3},exceptions:{ws:{exact:{"Auth is needed.":r.AuthenticationError}}}})}requestId(e){const t=this.safeValue(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}async watchPublic(e,t){const s=this.uid?"/"+this.uid:"",i=this.urls.api.ws.public+s,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchOrderBook(e,t=void 0,s={}){let i;await this.loadMarkets(),[i,s]=this.handleOptionAndParams(s,"watchOrderBook","method","orderbook");const r=this.market(e).id+"@"+i,a=this.uid?"/"+this.uid:"",o=this.urls.api.ws.public+a,n=this.requestId(o),d={event:"subscribe",topic:r,id:n},h={id:n.toString(),name:i,symbol:e,limit:t,params:s};"orderbookupdate"===i&&(h.method=this.handleOrderBookSubscription);return(await this.watch(o,r,this.extend(d,s),r,h)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"data"),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.safeString(t,"topic");if("orderbookupdate"===this.safeString(a.split("@"),1)){if(!(r in this.orderbooks))return;const s=this.orderbooks[r],i=this.safeInteger(s,"timestamp");if(void 0===i)s.cache.push(t);else try{this.safeInteger(t,"ts")>i&&(this.handleOrderBookMessage(e,t,s),e.resolve(s,a))}catch(t){delete this.orderbooks[r],delete e.subscriptions[a],e.reject(t,a)}}else{if(!(r in this.orderbooks)){const t=this.safeInteger(this.options,"watchOrderBookLimit",1e3),s=e.subscriptions[a],i=this.safeInteger(s,"limit",t);this.orderbooks[r]=this.orderBook({},i)}const i=this.orderbooks[r],o=this.safeInteger(t,"ts"),n=this.parseOrderBook(s,r,o,"bids","asks");i.reset(n),e.resolve(i,a)}}handleOrderBookSubscription(e,t,s){const i=this.safeInteger(this.options,"watchOrderBookLimit",1e3),r=this.safeInteger(s,"limit",i),a=this.safeString(s,"symbol");a in this.orderbooks&&delete this.orderbooks[a],this.orderbooks[a]=this.orderBook({},r),this.spawn(this.fetchOrderBookSnapshot,e,t,s)}async fetchOrderBookSnapshot(e,t,s){const i=this.safeString(s,"symbol"),r=this.safeString(t,"topic");try{const t=this.safeInteger(this.options,"watchOrderBookLimit",1e3),a=this.safeInteger(s,"limit",t),o=this.safeValue(s,"params"),n=await this.fetchRestOrderBookSafe(i,a,o);if(void 0===this.safeValue(this.orderbooks,i))return;const d=this.orderbooks[i];d.reset(n);const h=d.cache;for(let t=0;t<h.length;t++){const s=h[t];this.safeInteger(s,"ts")<d.timestamp||this.handleOrderBookMessage(e,s,d)}this.orderbooks[i]=d,e.resolve(d,r)}catch(t){delete e.subscriptions[r],e.reject(t,r)}}handleOrderBookMessage(e,t,s){const i=this.safeDict(t,"data");this.handleDeltas(s.asks,this.safeValue(i,"asks",[])),this.handleDeltas(s.bids,this.safeValue(i,"bids",[]));const r=this.safeInteger(t,"ts");return s.timestamp=r,s.datetime=this.iso8601(r),s}handleDelta(e,t){const s=this.safeFloat2(t,"price",0),i=this.safeFloat2(t,"quantity",1);e.store(s,i)}handleDeltas(e,t){for(let s=0;s<t.length;s++)this.handleDelta(e,t[s])}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.id+"@ticker",r={event:"subscribe",topic:i},a=this.extend(r,t);return await this.watchPublic(i,a)}parseWsTicker(e,t=void 0){return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"amount"),info:e},t)}handleTicker(e,t){const s=this.safeValue(t,"data"),i=this.safeValue(t,"topic"),r=this.safeString(s,"symbol"),a=this.safeMarket(r),o=this.safeInteger(t,"ts");s.date=o;const n=this.parseWsTicker(s,a);return n.symbol=a.symbol,this.tickers[a.symbol]=n,e.resolve(n,i),t}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s="tickers",i={event:"subscribe",topic:s},r=this.extend(i,t),a=await this.watchPublic(s,r);return this.filterByArray(a,"symbol",e)}handleTickers(e,t){const s=this.safeValue(t,"topic"),i=this.safeValue(t,"data"),r=this.safeInteger(t,"ts"),a=[];for(let e=0;e<i.length;e++){const t=this.safeString(i[e],"symbol"),s=this.safeMarket(t),o=this.parseWsTicker(this.extend(i[e],{date:r}),s);this.tickers[s.symbol]=o,a.push(o)}e.resolve(a,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){if(await this.loadMarkets(),"1m"!==t&&"5m"!==t&&"15m"!==t&&"30m"!==t&&"1h"!==t&&"1d"!==t&&"1w"!==t&&"1M"!==t)throw new r.ExchangeError(this.id+" watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M");const o=this.market(e),n=this.safeString(this.timeframes,t,t),d=o.id+"@kline_"+n,h={event:"subscribe",topic:d},c=this.extend(h,a),l=await this.watchPublic(d,c);return this.newUpdates&&(i=l.getLimit(o.symbol,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeValue(t,"data"),i=this.safeValue(t,"topic"),r=this.safeString(s,"symbol"),o=this.safeMarket(r).symbol,n=this.safeString(s,"type"),d=this.findTimeframe(n),h=[this.safeInteger(s,"startTime"),this.safeFloat(s,"open"),this.safeFloat(s,"high"),this.safeFloat(s,"low"),this.safeFloat(s,"close"),this.safeFloat(s,"volume")];this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let c=this.safeValue(this.ohlcvs[o],d);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[o][d]=c}c.append(h),e.resolve(c,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id+"@trade",o={event:"subscribe",topic:a},n=this.extend(o,i),d=await this.watchPublic(a,n);return this.newUpdates&&(s=d.getLimit(r.symbol,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleTrade(e,t){const s=this.safeString(t,"topic"),i=this.safeInteger(t,"ts"),r=this.safeValue(t,"data"),o=this.safeString(r,"symbol"),n=this.safeMarket(o),d=n.symbol,h=this.parseWsTrade(this.extend(r,{timestamp:i}),n);let c=this.safeValue(this.trades,d);if(void 0===c){const e=this.safeInteger(this.options,"tradesLimit",1e3);c=new a.I3(e)}c.append(h),this.trades[d]=c,e.resolve(c,s)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"executedPrice","price"),a=this.safeString2(e,"executedQuantity","size"),n=o.Y.stringMul(r,a),d=this.safeStringLower(e,"side"),h=this.safeInteger(e,"timestamp"),c=this.safeBool(e,"marker");let l;void 0!==c&&(l=c?"maker":"taker");const u=this.safeStringLower(e,"type");let p;const f=this.safeNumber(e,"fee");return void 0!==f&&(p={cost:f,currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency"))}),this.safeTrade({id:this.safeString(e,"tradeId"),timestamp:h,datetime:this.iso8601(h),symbol:i,side:d,price:r,amount:a,cost:n,order:this.safeString(e,"orderId"),takerOrMaker:l,type:u,fee:p,info:e},t)}checkRequiredUid(e=!0){if(!this.uid){if(e)throw new r.AuthenticationError(this.id+" requires `uid` credential (woox calls it `application_id`)");return!1}return!0}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private+"/"+this.uid,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s=this.nonce().toString(),r="|"+s,a=this.hmac(this.encode(r),this.encode(this.secret),n.s),o={event:"auth",params:{apikey:this.apiKey,sign:a,timestamp:s}},d=this.extend(o,e);this.watch(t,i,d,i,d)}return await r}async watchPrivate(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws.private+"/"+this.uid,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchPrivateMultiple(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws.private+"/"+this.uid,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watchMultiple(i,e,a,e,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool2(i,"stop","trigger",!1)?"algoexecutionreportv2":"executionreport";i=this.omit(i,["stop","trigger"]);let a=r;if(void 0!==e){a+=":"+(e=this.market(e).symbol)}const o={event:"subscribe",topic:r},n=this.extend(o,i),d=await this.watchPrivate(a,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool2(i,"stop","trigger",!1)?"algoexecutionreportv2":"executionreport";i=this.omit(i,["stop","trigger"]);let a="myTrades";if(void 0!==e){a+=":"+(e=this.market(e).symbol)}const o={event:"subscribe",topic:r},n=this.extend(o,i),d=await this.watchPrivate(a,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"symbol"),r=this.market(i).symbol,a=this.safeInteger(e,"timestamp"),n={cost:this.safeString(e,"totalFee"),currency:this.safeString(e,"feeAsset")},d=this.safeString(e,"price");let h=this.safeNumber(e,"price");const c=this.safeNumber(e,"avgPrice");o.Y.stringEq(d,"0")&&void 0!==c&&(h=c);const l=this.safeFloat(e,"quantity"),u=this.safeStringLower(e,"side"),p=this.safeStringLower(e,"type"),f=this.safeNumber(e,"totalExecutedQuantity"),m=this.safeFloat(e,"totalExecutedQuantity");let g=l;l>=m&&(g-=m);const v=this.safeString(e,"status"),y=this.parseOrderStatus(v),w=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,symbol:r,id:s,clientOrderId:w,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:a,type:p,timeInForce:void 0,postOnly:void 0,side:u,price:h,stopPrice:void 0,triggerPrice:void 0,amount:l,cost:void 0,average:void 0,filled:f,remaining:g,status:y,fee:n,trades:undefined})}handleOrderUpdate(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data");if(Array.isArray(i))for(let t=0;t<i.length;t++){const r=i[t];void 0!==this.omitZero(this.safeString(i,"tradeId"))&&this.handleMyTrade(e,r),this.handleOrder(e,r,s)}else{void 0!==this.omitZero(this.safeString(i,"tradeId"))&&this.handleMyTrade(e,i),this.handleOrder(e,i,s)}}handleOrder(e,t,s){const i=this.parseWsOrder(t),r=this.safeString(i,"symbol"),o=this.safeString(i,"id");if(void 0!==r){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,n=this.safeValue(t.hashmap,r,{}),d=this.safeValue(n,o);if(void 0!==d){const e=this.safeValue(d,"fee");void 0!==e&&(i.fee=e);const t=this.safeValue(d,"fees");void 0!==t&&(i.fees=t),i.trades=this.safeValue(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}t.append(i),e.resolve(this.orders,s);const h=s+":"+r;e.resolve(this.orders,h)}}handleMyTrade(e,t){let s=this.myTrades;if(void 0===s){const e=this.safeInteger(this.options,"tradesLimit",1e3);s=new a.Pt(e)}const i=this.parseWsTrade(t);s.append(i);let r="myTrades:"+i.symbol;e.resolve(s,r),r="myTrades",e.resolve(s,r)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[];if(e=this.marketSymbols(e),this.isEmpty(e))r.push("positions");else for(let t=0;t<e.length;t++){const s=e[t];r.push("positions::"+s)}const a=this.urls.api.ws.private+"/"+this.uid,o=this.client(a);this.setPositionsCache(o,e);const n=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),d=this.handleOption("watchPositions","awaitPositionsSnapshot",!0);if(n&&d&&void 0===this.positions){const i=await o.future("fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const h=await this.watchPrivateMultiple(r,{event:"subscribe",topic:"position"},i);return this.newUpdates?h:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}setPositionsCache(e,t,s=void 0){if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const t="fetchPositionsSnapshot";t in e.futures||(e.future(t),this.spawn(this.loadPositionsSnapshot,e,t))}else this.positions=new a.Hk}async loadPositionsSnapshot(e,t){const s=await this.fetchPositions();this.positions=new a.Hk;const i=this.positions;for(let e=0;e<s.length;e++){const t=s[e];this.safeNumber(t,"contracts",0)>0&&i.append(t)}e.futures[t].resolve(i),e.resolve(i,"positions")}handlePositions(e,t){const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"positions",{}),r=Object.keys(i);void 0===this.positions&&(this.positions=new a.Hk);const o=this.positions,n=[];for(let t=0;t<r.length;t++){const s=r[t],a=this.safeMarket(s),d=i[s],h=this.parsePosition(d,a);n.push(h),o.append(h);const c="positions::"+a.symbol;e.resolve(h,c)}e.resolve(n,"positions")}async watchBalance(e={}){await this.loadMarkets();const t="balance",s=t,i={event:"subscribe",topic:t},r=this.extend(i,e);return await this.watchPrivate(s,r)}handleBalance(e,t){const s=this.safeValue(t,"data"),i=this.safeValue(s,"balances"),r=Object.keys(i),a=this.safeInteger(t,"ts");this.balance.info=s,this.balance.timestamp=a,this.balance.datetime=this.iso8601(a);for(let e=0;e<r.length;e++){const t=r[e],s=i[t],a=this.safeCurrencyCode(t),n=a in this.balance?this.balance[a]:this.account(),d=this.safeString(s,"holding"),h=this.safeString(s,"frozen");n.total=d,n.used=h,n.free=o.Y.stringSub(d,h),this.balance[a]=n}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}handleErrorMessage(e,t){if(!("success"in t))return!1;if(this.safeBool(t,"success"))return!1;const s=this.safeString(t,"errorMsg");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s={ping:this.handlePing,pong:this.handlePong,subscribe:this.handleSubscribe,orderbook:this.handleOrderBook,orderbookupdate:this.handleOrderBook,ticker:this.handleTicker,tickers:this.handleTickers,kline:this.handleOHLCV,auth:this.handleAuth,executionreport:this.handleOrderUpdate,algoexecutionreportv2:this.handleOrderUpdate,trade:this.handleTrade,balance:this.handleBalance,position:this.handlePositions},i=this.safeString(t,"event");let r=this.safeValue(s,i);if(void 0!==r)return void r.call(this,e,t);const a=this.safeString(t,"topic");if(void 0!==a){if(r=this.safeValue(s,a),void 0!==r)return void r.call(this,e,t);const i=a.split("@");if(2===i.length){const a=this.safeString(i,1);if(r=this.safeValue(s,a),void 0!==r)return void r.call(this,e,t);const o=a.split("_");2===i.length&&(r=this.safeValue(s,this.safeString(o,0)),void 0!==r&&r.call(this,e,t))}}}ping(e){return{event:"ping"}}handlePing(e,t){return{event:"pong"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscribe(e,t){const s=this.safeString(t,"id"),i=this.indexBy(e.subscriptions,"id"),r=this.safeValue(i,s,{}),a=this.safeValue(r,"method");return void 0!==a&&a.call(this,e,t,r),t}handleAuth(e,t){const s="authenticated";if(this.safeValue(t,"success")){this.safeValue(e.futures,"authenticated").resolve(!0)}else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions.authenticated}}}},8713:(e,t,s)=>{s.d(t,{A:()=>h});var i=s(9641),r=s(2079),a=s(2931),o=s(5147),n=s(8283),d=s(6414);class h extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchBalance:!0,watchMyTrades:!0,watchOHLCV:!0,watchOrderBook:!0,watchOrders:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchPositions:!0},urls:{api:{ws:{public:"wss://ws-evm.orderly.org/ws/stream",private:"wss://ws-private-evm.orderly.org/v2/ws/private/stream"}},test:{ws:{public:"wss://testnet-ws-evm.orderly.org/ws/stream",private:"wss://testnet-ws-private-evm.orderly.org/v2/ws/private/stream"}}},requiredCredentials:{apiKey:!0,secret:!0,accountId:!0},options:{tradesLimit:1e3,ordersLimit:1e3,requestId:{},watchPositions:{fetchPositionsSnapshot:!0,awaitPositionsSnapshot:!0}},streaming:{ping:this.ping,keepAlive:1e4},exceptions:{ws:{exact:{"Auth is needed.":r.AuthenticationError}}}})}requestId(e){const t=this.safeDict(this.options,"requestId",{}),s=this.safeInteger(t,e,0),i=this.sum(s,1);return this.options.requestId[e]=i,i}async watchPublic(e,t){let s="OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY";void 0!==this.accountId&&(s=this.accountId);const i=this.urls.api.ws.public+"/"+s,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e).id+"@orderbook",r={event:"subscribe",topic:i},a=this.extend(r,s);return(await this.watchPublic(i,a)).limit()}handleOrderBook(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"symbol"),r=this.safeMarket(i).symbol,a=this.safeString(t,"topic");r in this.orderbooks||(this.orderbooks[r]=this.orderBook());const o=this.orderbooks[r],n=this.safeInteger(t,"ts"),d=this.parseOrderBook(s,r,n,"bids","asks");o.reset(d),e.resolve(o,a)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e);e=s.symbol;const i=s.id+"@ticker",r={event:"subscribe",topic:i},a=this.extend(r,t);return await this.watchPublic(i,a)}parseWsTicker(e,t=void 0){return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:this.safeString(e,"close"),last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"amount"),info:e},t)}handleTicker(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(t,"topic"),r=this.safeString(s,"symbol"),a=this.safeMarket(r),o=this.safeInteger(t,"ts");s.date=o;const n=this.parseWsTicker(s,a);return n.symbol=a.symbol,this.tickers[a.symbol]=n,e.resolve(n,i),t}async watchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s="tickers",i={event:"subscribe",topic:s},r=this.extend(i,t),a=await this.watchPublic(s,r);return this.filterByArray(a,"symbol",e)}handleTickers(e,t){const s=this.safeString(t,"topic"),i=this.safeList(t,"data",[]),r=this.safeInteger(t,"ts"),a=[];for(let e=0;e<i.length;e++){const t=this.safeString(i[e],"symbol"),s=this.safeMarket(t),o=this.parseWsTicker(this.extend(i[e],{date:r}),s);this.tickers[s.symbol]=o,a.push(o)}e.resolve(a,s)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,a={}){if(await this.loadMarkets(),"1m"!==t&&"5m"!==t&&"15m"!==t&&"30m"!==t&&"1h"!==t&&"1d"!==t&&"1w"!==t&&"1M"!==t)throw new r.NotSupported(this.id+" watchOHLCV timeframe argument must be 1m, 5m, 15m, 30m, 1h, 1d, 1w, 1M");const o=this.market(e),n=this.safeString(this.timeframes,t,t),d=o.id+"@kline_"+n,h={event:"subscribe",topic:d},c=this.extend(h,a),l=await this.watchPublic(d,c);return this.newUpdates&&(i=l.getLimit(o.symbol,i)),this.filterBySinceLimit(l,s,i,0,!0)}handleOHLCV(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(t,"topic"),r=this.safeString(s,"symbol"),o=this.safeMarket(r).symbol,n=this.safeString(s,"type"),d=this.findTimeframe(n),h=[this.safeInteger(s,"startTime"),this.safeNumber(s,"open"),this.safeNumber(s,"high"),this.safeNumber(s,"low"),this.safeNumber(s,"close"),this.safeNumber(s,"volume")];this.ohlcvs[o]=this.safeValue(this.ohlcvs,o,{});let c=this.safeValue(this.ohlcvs[o],d);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new a.TG(e),this.ohlcvs[o][d]=c}const l=this.ohlcvs[o][d];l.append(h),e.resolve(l,i)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);e=r.symbol;const a=r.id+"@trade",o={event:"subscribe",topic:a},n=this.extend(o,i),d=await this.watchPublic(a,n);return this.newUpdates&&(s=d.getLimit(r.symbol,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}handleTrade(e,t){const s=this.safeString(t,"topic"),i=this.safeInteger(t,"ts"),r=this.safeDict(t,"data",{}),o=this.safeString(r,"symbol"),n=this.safeMarket(o),d=n.symbol,h=this.parseWsTrade(this.extend(r,{timestamp:i}),n);if(!(d in this.trades)){const e=this.safeInteger(this.options,"tradesLimit",1e3),t=new a.I3(e);this.trades[d]=t}const c=this.trades[d];c.append(h),this.trades[d]=c,e.resolve(c,s)}parseWsTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString2(e,"executedPrice","price"),a=this.safeString2(e,"executedQuantity","size"),n=o.Y.stringMul(r,a),d=this.safeStringLower(e,"side"),h=this.safeInteger(e,"timestamp");let c;const l=this.safeBool(e,"maker");let u;void 0!==l&&(c=l?"maker":"taker");const p=this.safeString(e,"fee");return void 0!==p&&(u={cost:p,currency:this.safeCurrencyCode(this.safeString(e,"feeAsset"))}),this.safeTrade({id:this.safeString(e,"tradeId"),timestamp:h,datetime:this.iso8601(h),symbol:i,side:d,price:r,amount:a,cost:n,order:this.safeString(e,"orderId"),takerOrMaker:c,type:this.safeStringLower(e,"type"),fee:u,info:e},t)}handleAuth(e,t){const s="authenticated";if(this.safeValue(t,"success")){this.safeValue(e.futures,"authenticated").resolve(!0)}else{const i=new r.AuthenticationError(this.json(t));e.reject(i,s),s in e.subscriptions&&delete e.subscriptions.authenticated}}async authenticate(e={}){this.checkRequiredCredentials();const t=this.urls.api.ws.private+"/"+this.accountId,s=this.client(t),i="authenticated",r=s.future(i);if(void 0===this.safeValue(s.subscriptions,i)){const s=this.nonce().toString(),r=s;let a=this.secret;if(a.indexOf("ed25519:")>=0){const e=a.split("ed25519:");a=e[1]}const o=(0,n.q4)(this.encode(r),this.base58ToBinary(a),d.ev),h={event:"auth",params:{orderly_key:this.apiKey,sign:o,timestamp:s}},c=this.extend(h,e);this.watch(t,i,c,i)}return await r}async watchPrivate(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws.private+"/"+this.accountId,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watch(i,e,a,e,r)}async watchPrivateMultiple(e,t,s={}){await this.authenticate(s);const i=this.urls.api.ws.private+"/"+this.accountId,r={id:this.requestId(i)},a=this.extend(r,t);return await this.watchMultiple(i,e,a,e,r)}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool2(i,"stop","trigger",!1)?"algoexecutionreport":"executionreport";i=this.omit(i,["stop","trigger"]);let a=r;if(void 0!==e){a+=":"+(e=this.market(e).symbol)}const o={event:"subscribe",topic:r},n=this.extend(o,i),d=await this.watchPrivate(a,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeBool2(i,"stop","trigger",!1)?"algoexecutionreport":"executionreport";i=this.omit(i,"stop");let a="myTrades";if(void 0!==e){a+=":"+(e=this.market(e).symbol)}const o={event:"subscribe",topic:r},n=this.extend(o,i),d=await this.watchPrivate(a,n);return this.newUpdates&&(s=d.getLimit(e,s)),this.filterBySymbolSinceLimit(d,e,t,s,!0)}parseWsOrder(e,t=void 0){const s=this.safeString(e,"orderId"),i=this.safeString(e,"symbol"),r=this.market(i).symbol,a=this.safeInteger(e,"timestamp"),n={cost:this.safeString(e,"totalFee"),currency:this.safeString(e,"feeAsset")},d=this.safeString(e,"price");let h=this.safeNumber(e,"price");const c=this.safeNumber(e,"avgPrice");o.Y.stringEq(d,"0")&&void 0!==c&&(h=c);const l=this.safeString(e,"quantity"),u=this.safeStringLower(e,"side"),p=this.safeStringLower(e,"type"),f=this.safeNumber(e,"totalExecutedQuantity"),m=this.safeString(e,"totalExecutedQuantity");let g=l;o.Y.stringGe(l,m)&&(g=o.Y.stringSub(g,m));const v=this.safeString(e,"status"),y=this.parseOrderStatus(v),w=this.safeString(e,"clientOrderId"),b=this.safeNumber(e,"triggerPrice");return this.safeOrder({info:e,symbol:r,id:s,clientOrderId:w,timestamp:a,datetime:this.iso8601(a),lastTradeTimestamp:a,type:p,timeInForce:void 0,postOnly:void 0,side:u,price:h,stopPrice:b,triggerPrice:b,amount:l,cost:void 0,average:void 0,filled:f,remaining:g,status:y,fee:n,trades:undefined})}handleOrderUpdate(e,t){const s=this.safeString(t,"topic"),i=this.safeValue(t,"data");if(Array.isArray(i))for(let t=0;t<i.length;t++){const r=i[t];void 0!==this.omitZero(this.safeString(i,"tradeId"))&&this.handleMyTrade(e,r),this.handleOrder(e,r,s)}else{void 0!==this.omitZero(this.safeString(i,"tradeId"))&&this.handleMyTrade(e,i),this.handleOrder(e,i,s)}}handleOrder(e,t,s){const i=this.parseWsOrder(t),r=this.safeString(i,"symbol"),o=this.safeString(i,"id");if(void 0!==r){if(void 0===this.orders){const e=this.safeInteger(this.options,"ordersLimit",1e3);this.orders=new a.Pt(e)}const t=this.orders,n=this.safeDict(t.hashmap,r,{}),d=this.safeDict(n,o);if(void 0!==d){const e=this.safeValue(d,"fee");void 0!==e&&(i.fee=e);const t=this.safeList(d,"fees");void 0!==t&&(i.fees=t),i.trades=this.safeList(d,"trades"),i.timestamp=this.safeInteger(d,"timestamp"),i.datetime=this.safeString(d,"datetime")}t.append(i),e.resolve(this.orders,s);const h=s+":"+r;e.resolve(this.orders,h)}}handleMyTrade(e,t){const s="myTrades",i=this.safeString(t,"symbol"),r=this.safeMarket(i),o=r.symbol,n=this.parseWsTrade(t,r);let d=this.myTrades;if(void 0===d){const e=this.safeInteger(this.options,"tradesLimit",1e3);d=new a.Pt(e),this.myTrades=d}d.append(n),e.resolve(d,s);const h=s+":"+o;e.resolve(d,h)}async watchPositions(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=[];if(e=this.marketSymbols(e),this.isEmpty(e))r.push("positions");else for(let t=0;t<e.length;t++){const s=e[t];r.push("positions::"+s)}const a=this.urls.api.ws.private+"/"+this.accountId,o=this.client(a);this.setPositionsCache(o,e);const n=this.handleOption("watchPositions","fetchPositionsSnapshot",!0),d=this.handleOption("watchPositions","awaitPositionsSnapshot",!0);if(n&&d&&void 0===this.positions){const i=await o.future("fetchPositionsSnapshot");return this.filterBySymbolsSinceLimit(i,e,t,s,!0)}const h=await this.watchPrivateMultiple(r,{event:"subscribe",topic:"position"},i);return this.newUpdates?h:this.filterBySymbolsSinceLimit(this.positions,e,t,s,!0)}setPositionsCache(e,t,s=void 0){if(this.handleOption("watchPositions","fetchPositionsSnapshot",!1)){const t="fetchPositionsSnapshot";t in e.futures||(e.future(t),this.spawn(this.loadPositionsSnapshot,e,t))}else this.positions=new a.Hk}async loadPositionsSnapshot(e,t){const s=await this.fetchPositions();this.positions=new a.Hk;const i=this.positions;for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"contracts","0");o.Y.stringGt(r,"0")&&i.append(t)}e.futures[t].resolve(i),e.resolve(i,"positions")}handlePositions(e,t){const s=this.safeDict(t,"data",{}),i=this.safeList(s,"positions",[]);void 0===this.positions&&(this.positions=new a.Hk);const r=this.positions,o=[];for(let t=0;t<i.length;t++){const s=i[t],a=this.safeString(s,"symbol"),n=this.safeMarket(a),d=this.parseWsPosition(s,n);o.push(d),r.append(d);const h="positions::"+n.symbol;e.resolve(d,h)}e.resolve(o,"positions")}parseWsPosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,r=this.safeString(e,"positionQty");i=o.Y.stringGt(r,"0")?"long":"short";const a=this.safeString(t,"contractSize"),n=this.safeString(e,"markPrice"),d=this.safeInteger(e,"timestamp"),h=this.safeString(e,"averageOpenPrice"),c=this.safeString(e,"unsettledPnl");r=o.Y.stringAbs(r);const l=o.Y.stringMul(r,n);return this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:d,datetime:this.iso8601(d),lastUpdateTimestamp:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(h),notional:this.parseNumber(l),leverage:void 0,unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(r),contractSize:this.parseNumber(a),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"estLiqPrice"),markPrice:this.parseNumber(n),lastPrice:void 0,collateral:void 0,marginMode:"cross",marginType:void 0,side:i,percentage:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async watchBalance(e={}){await this.loadMarkets();const t="balance",s=t,i={event:"subscribe",topic:t},r=this.extend(i,e);return await this.watchPrivate(s,r)}handleBalance(e,t){const s=this.safeDict(t,"data",{}),i=this.safeDict(s,"balances",{}),r=Object.keys(i),a=this.safeInteger(t,"ts");this.balance.info=s,this.balance.timestamp=a,this.balance.datetime=this.iso8601(a);for(let e=0;e<r.length;e++){const t=r[e],s=i[t],a=this.safeCurrencyCode(t),n=a in this.balance?this.balance[a]:this.account(),d=this.safeString(s,"holding"),h=this.safeString(s,"frozen");n.total=d,n.used=h,n.free=o.Y.stringSub(d,h),this.balance[a]=n}this.balance=this.safeBalance(this.balance),e.resolve(this.balance,"balance")}handleErrorMessage(e,t){if(!("success"in t))return!1;if(this.safeBool(t,"success"))return!1;const s=this.safeString(t,"errorMsg");try{if(void 0!==s){const e=this.id+" "+this.json(t);this.throwExactlyMatchedException(this.exceptions.exact,s,e)}return!1}catch(t){if(t instanceof r.AuthenticationError){const s="authenticated";e.reject(t,s),s in e.subscriptions&&delete e.subscriptions[s]}else e.reject(t);return!0}}handleMessage(e,t){if(this.handleErrorMessage(e,t))return;const s={ping:this.handlePing,pong:this.handlePong,subscribe:this.handleSubscribe,orderbook:this.handleOrderBook,ticker:this.handleTicker,tickers:this.handleTickers,kline:this.handleOHLCV,trade:this.handleTrade,auth:this.handleAuth,executionreport:this.handleOrderUpdate,algoexecutionreport:this.handleOrderUpdate,position:this.handlePositions,balance:this.handleBalance},i=this.safeString(t,"event");let r=this.safeValue(s,i);if(void 0!==r)return void r.call(this,e,t);const a=this.safeString(t,"topic");if(void 0!==a){if(r=this.safeValue(s,a),void 0!==r)return void r.call(this,e,t);const i=a.split("@");if(2===i.length){const a=this.safeString(i,1);if(r=this.safeValue(s,a),void 0!==r)return void r.call(this,e,t);const o=a.split("_");2===i.length&&(r=this.safeValue(s,this.safeString(o,0)),void 0!==r&&r.call(this,e,t))}}}ping(e){return{event:"ping"}}handlePing(e,t){return{event:"pong"}}handlePong(e,t){return e.lastPong=this.milliseconds(),t}handleSubscribe(e,t){return t}}},2368:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(5344),r=s(2931);class a extends i.A{describe(){return this.deepExtend(super.describe(),{has:{ws:!0,watchOHLCV:!0,watchOrderBook:!0,watchTicker:!0,watchTickers:!0,watchTrades:!0,watchTradesForSymbols:!1,watchBalance:!0,watchOrders:!0,watchMyTrades:!0,watchPositions:void 0},urls:{api:{ws:{spot:"wss://stream.xt.com",contract:"wss://fstream.xt.com/ws"}}},options:{tradesLimit:1e3,ordersLimit:1e3,OHLCVLimit:1e3,watchTicker:{method:"ticker"},watchTickers:{method:"tickers"}},streaming:{keepAlive:2e4,ping:this.ping},token:void 0})}async getListenKey(e){this.checkRequiredCredentials();const t=e?"contract":"spot";let s=this.urls.api.ws[t];e||(s+="/private");const i=this.client(s);if(void 0===this.safeDict(i.subscriptions,"token"))if(e){const e=await this.privateLinearGetFutureUserV1UserListenKey();i.subscriptions.token=this.safeString(e,"result")}else{const e=await this.privateSpotPostWsToken(),t=this.safeDict(e,"result");i.subscriptions.token=this.safeString(t,"accessToken")}return i.subscriptions.token}getCacheIndex(e,t){const s=this.safeInteger(e,"nonce"),i=this.safeValue(t,0);if(s<this.safeInteger2(i,"i","u")-1)return-1;for(let e=0;e<t.length;e++){const i=t[e];if(this.safeInteger2(i,"i","u")>=s)return e}return t.length}handleDelta(e,t){e.nonce=this.safeInteger2(t,"i","u");const s=this.safeList(t,"a",[]),i=this.safeList(t,"b",[]),r=e.bids,a=e.asks;for(let e=0;e<i.length;e++){const t=i[e],s=this.safeNumber(t,0),a=this.safeNumber(t,1);r.store(s,a)}for(let e=0;e<s.length;e++){const t=s[e],i=this.safeNumber(t,0),r=this.safeNumber(t,1);a.store(i,r)}}async subscribe(e,t,s,i=void 0,r=void 0,a={}){const o="private"===t;let n;[n,a]=this.handleMarketTypeAndParams(s,i,a);const d="spot"!==n,h={method:d?"SUBSCRIBE":"subscribe",id:this.numberToString(this.milliseconds())+e};if(o)if(d){const t=e+"@"+await this.getListenKey(d);h.params=[t]}else h.params=[e],h.listenKey=await this.getListenKey(d);else h.params=[e];const c=d?"contract":"spot";let l=e+"::"+c;void 0!==r&&(l=l+"::"+r.join(","));const u=this.extend(h,a);let p=t;d&&(p=o?"user":"market");const f=this.urls.api.ws[c]+"/"+p;return await this.watch(f,l,u,l)}async watchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeDict(this.options,"watchTicker"),r=this.safeString(i,"method","ticker"),a=this.safeString(t,"method",r)+"@"+s.id;return await this.subscribe(a,"public","watchTicker",s,void 0,t)}async watchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeDict(this.options,"watchTickers"),i=this.safeString(s,"method","tickers"),r=this.safeString(t,"method",i);let a;void 0!==e&&(a=this.market(e[0]));const o=await this.subscribe(r,"public","watchTickers",a,e,t);return this.newUpdates?o:this.filterByArray(this.tickers,"symbol",e)}async watchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o="kline@"+a.id+","+t,n=await this.subscribe(o,"public","watchOHLCV",a,void 0,r);return this.newUpdates&&(i=n.getLimit(e,i)),this.filterBySinceLimit(n,s,i,0,!0)}async watchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a="trade@"+r.id,o=await this.subscribe(a,"public","watchTrades",r,void 0,i);return this.newUpdates&&(s=o.getLimit(e,s)),this.filterBySinceLimit(o,t,s,"timestamp")}async watchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.safeString(s,"levels");s=this.omit(s,"levels");let a="depth_update@"+i.id;void 0!==r&&(a="depth@"+i.id+","+r);return(await this.subscribe(a,"public","watchOrderBook",i,void 0,s)).limit()}async watchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r;void 0!==e&&(r=this.market(e));const a=await this.subscribe("order","private","watchOrders",r,void 0,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp")}async watchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r;void 0!==e&&(r=this.market(e));const a=await this.subscribe("trade","private","watchMyTrades",r,void 0,i);return this.newUpdates&&(s=a.getLimit(e,s)),this.filterBySinceLimit(a,t,s,"timestamp")}async watchBalance(e={}){await this.loadMarkets();return await this.subscribe("balance","private","watchBalance",void 0,void 0,e)}handleTicker(e,t){const s=this.safeDict(t,"data");if(void 0!==this.safeString(s,"s")){const i=void 0!==this.safeString(s,"cv"),r=this.parseTicker(s),a=r.symbol;this.tickers[a]=r;const o=this.safeString(t,"event")+"::"+(i?"spot":"contract");e.resolve(r,o)}return t}handleTickers(e,t){const s=this.safeList(t,"data",[]),i=this.safeDict(s,0),r=void 0!==this.safeString2(i,"cv","aq")?"spot":"contract",a=[];for(let e=0;e<s.length;e++){const t=s[e],i=this.parseTicker(t),r=i.symbol;this.tickers[r]=i,a.push(i)}const o=this.safeString(t,"topic")+"::"+r,n=this.findMessageHashes(e,o+"::");for(let t=0;t<n.length;t++){const s=n[t],i=s.split("::")[2].split(","),r=this.filterByArray(a,"symbol",i);Object.keys(r).length>0&&e.resolve(r,s)}return e.resolve(this.tickers,o),t}handleOHLCV(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString(s,"s");if(void 0!==i){const a=this.safeString(s,"i"),o="q"in s?"spot":"contract",n=this.safeMarket(i,void 0,void 0,o),d=n.symbol,h=this.parseOHLCV(s,n);this.ohlcvs[d]=this.safeDict(this.ohlcvs,d,{});let c=this.safeValue(this.ohlcvs[d],a);if(void 0===c){const e=this.safeInteger(this.options,"OHLCVLimit",1e3);c=new r.TG(e),this.ohlcvs[d][a]=c}c.append(h);const l=this.safeString(t,"event")+"::"+o;e.resolve(c,l)}return t}handleTrade(e,t){const s=this.safeDict(t,"data"),i=this.safeStringLower(s,"s");if(void 0!==i){const a=this.parseTrade(s),o=void 0!==this.safeString(s,"i")?"spot":"contract",n=this.safeMarket(i,void 0,void 0,o).symbol,d=this.safeString(t,"event");let h=this.safeValue(this.trades,n);if(void 0===h){const e=this.safeInteger(this.options,"tradesLimit",1e3);h=new r.I3(e),this.trades[n]=h}h.append(a);const c=d+"::"+o;e.resolve(h,c)}return t}handleOrderBook(e,t){const s=this.safeDict(t,"data"),i=this.safeString(s,"s");if(void 0!==i){let r=this.safeString(t,"event");const a=r.split(",");r=this.safeString(a,0);const o="fu"in s?"contract":"spot",n=this.safeMarket(i,void 0,void 0,o).symbol,d=this.safeList(s,"a"),h=this.safeList(s,"b"),c=r+"::"+o;if(!(n in this.orderbooks)){const t=this.safeDict(e.subscriptions,c,{}),s=this.safeInteger(t,"limit");this.orderbooks[n]=this.orderBook({},s)}const l=this.orderbooks[n];if(void 0===this.safeInteger(l,"nonce")){return l.cache.length===this.handleOption("watchOrderBook","snapshotDelay",25)&&this.spawn(this.loadOrderBook,e,c,n),void l.cache.push(s)}if(void 0!==d){const e=l.asks;for(let t=0;t<d.length;t++){const s=d[t],i=this.safeNumber(s,0),r=this.safeNumber(s,1);e.store(i,r)}}if(void 0!==h){const e=l.bids;for(let t=0;t<h.length;t++){const s=h[t],i=this.safeNumber(s,0),r=this.safeNumber(s,1);e.store(i,r)}}const u=this.safeInteger(s,"t");l.nonce=this.safeInteger2(s,"i","u"),l.timestamp=u,l.datetime=this.iso8601(u),l.symbol=n,e.resolve(l,c)}}parseWsOrderTrade(e,t=void 0){const s=this.safeString(e,"s"),i="symbol"in e?"contract":"spot";t=this.safeMarket(s,t,void 0,i);const r=this.safeString(e,"t");return this.safeTrade({info:e,id:void 0,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,order:this.safeString(e,"i","orderId"),type:this.parseOrderStatus(this.safeString(e,"st","state")),side:this.safeStringLower(e,"sd","orderSide"),takerOrMaker:void 0,price:this.safeNumber(e,"price"),amount:this.safeString(e,"origQty"),cost:void 0,fee:{currency:void 0,cost:this.safeNumber(e,"f"),rate:void 0}},t)}parseWsOrder(e,t=void 0){const s=this.safeString2(e,"s","symbol"),i="symbol"in e?"contract":"spot";t=this.safeMarket(s,t,void 0,i);const r=this.safeInteger2(e,"ct","createTime");return this.safeOrder({info:e,id:this.safeString2(e,"i","orderId"),clientOrderId:this.safeString2(e,"ci","clientOrderId"),timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,symbol:t.symbol,type:t.type,timeInForce:void 0,postOnly:void 0,side:this.safeStringLower2(e,"sd","orderSide"),price:this.safeNumber2(e,"p","price"),stopPrice:void 0,stopLoss:void 0,takeProfit:void 0,amount:this.safeString2(e,"oq","origQty"),filled:this.safeString2(e,"eq","executedQty"),remaining:this.safeString(e,"lq"),cost:void 0,average:this.safeString2(e,"ap","avgPrice"),status:this.parseOrderStatus(this.safeString(e,"st","state")),fee:{currency:void 0,cost:this.safeNumber(e,"f")},trades:void 0},t)}handleOrder(e,t){let s=this.orders;if(void 0===s){const e=this.safeInteger(this.options,"ordersLimit");s=new r.Pt(e),this.orders=s}const i=this.safeDict(t,"data",{}),a=this.safeString2(i,"s","symbol");if(void 0!==a){const t="symbol"in i?"contract":"spot",r=this.safeMarket(a,void 0,void 0,t),o=this.parseWsOrder(i,r);s.append(o),e.resolve(s,"order::"+t)}return t}handleBalance(e,t){const s=this.safeDict(t,"data",{}),i=this.safeString2(s,"c","coin"),r=this.safeCurrencyCode(i),a=this.account();a.free=this.safeString(s,"availableBalance"),a.used=this.safeString(s,"f"),a.total=this.safeString2(s,"b","walletBalance"),this.balance[r]=a,this.balance=this.safeBalance(this.balance);const o="coin"in s?"contract":"spot";e.resolve(this.balance,"balance::"+o)}handleMyTrades(e,t){const s=this.safeDict(t,"data",{});let i=this.myTrades;if(void 0===i){const e=this.safeInteger(this.options,"tradesLimit",1e3);i=new r.Pt(e),this.myTrades=i}const a=this.parseTrade(s),o=this.market(a.symbol);i.append(a);const n=o.contract?"contract":"spot";e.resolve(i,"trade::"+n)}handleMessage(e,t){const s=this.safeString(t,"event");if("pong"===s)e.onPong();else if(void 0!==s){const s=this.safeString(t,"topic"),i={kline:this.handleOHLCV,depth:this.handleOrderBook,depth_update:this.handleOrderBook,ticker:this.handleTicker,agg_ticker:this.handleTicker,tickers:this.handleTickers,agg_tickers:this.handleTickers,balance:this.handleBalance,order:this.handleOrder};let r=this.safeValue(i,s);if("trade"===s){const e=this.safeDict(t,"data");r="oi"in e||"orderId"in e?this.handleMyTrades:this.handleTrade}void 0!==r&&r.call(this,e,t)}}ping(e){return e.lastPong=this.milliseconds(),"ping"}handleErrorMessage(e,t){const s=this.safeString(t,"msg");if("invalid_listen_key"===s||"token expire"===s)return e.subscriptions.token=void 0,void this.getListenKey(!0);e.reject(t)}}},5037:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(995),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"probit",name:"ProBit",countries:["SC","KR"],rateLimit:50,pro:!0,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,createMarketBuyOrderWithCost:!0,createMarketOrder:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactions:"emulated",fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","10m":"10m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","6h":"6h","12h":"12h","1d":"1D","1w":"1W","1M":"1M"},version:"v1",urls:{logo:"https://user-images.githubusercontent.com/51840849/79268032-c4379480-7ea2-11ea-80b3-dd96bb29fd0d.jpg",api:{accounts:"https://accounts.probit.com",public:"https://api.probit.com/api/exchange",private:"https://api.probit.com/api/exchange"},www:"https://www.probit.com",doc:["https://docs-en.probit.com","https://docs-ko.probit.com"],fees:"https://support.probit.com/hc/en-us/articles/360020968611-Trading-Fees",referral:"https://www.probit.com/r/34608773"},api:{public:{get:{market:1,currency:1,currency_with_platform:1,time:1,ticker:1,order_book:1,trade:1,candle:1}},private:{post:{new_order:2,cancel_order:1,withdrawal:2},get:{balance:1,order:1,open_order:1,order_history:1,trade_history:1,deposit_address:1,"transfer/payment":1}},accounts:{post:{token:1}}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},exceptions:{exact:{UNAUTHORIZED:r.AuthenticationError,INVALID_ARGUMENT:r.BadRequest,TRADING_UNAVAILABLE:r.ExchangeNotAvailable,NOT_ENOUGH_BALANCE:r.InsufficientFunds,NOT_ALLOWED_COMBINATION:r.BadRequest,INVALID_ORDER:r.InvalidOrder,RATE_LIMIT_EXCEEDED:r.RateLimitExceeded,MARKET_UNAVAILABLE:r.ExchangeNotAvailable,INVALID_MARKET:r.BadSymbol,MARKET_CLOSED:r.MarketClosed,MARKET_NOT_FOUND:r.BadSymbol,INVALID_CURRENCY:r.BadRequest,TOO_MANY_OPEN_ORDERS:r.DDoSProtection,DUPLICATE_ADDRESS:r.InvalidAddress,invalid_grant:r.AuthenticationError}},requiredCredentials:{apiKey:!0,secret:!0},precisionMode:o.kb,options:{createMarketBuyOrderRequiresPrice:!0,timeInForce:{limit:"gtc",market:"ioc"},networks:{BEP20:"BSC",ERC20:"ETH",TRC20:"TRON"}},commonCurrencies:{BB:"Baby Bali",CBC:"CryptoBharatCoin",CTK:"Cryptyk",CTT:"Castweet",DKT:"DAKOTA",EGC:"EcoG9coin",EPS:"Epanus",FX:"Fanzy",GM:"GM Holding",GOGOL:"GOL",GOL:"Goldofir",HUSL:"The Hustle App",LAND:"Landbox",SST:"SocialSwap",TCT:"Top Coin Token",TOR:"Torex",UNI:"UNICORN Token",UNISWAP:"UNI"}})}async fetchMarkets(e={}){const t=await this.publicGetMarket(e),s=this.safeValue(t,"data",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"id"),s=this.safeString(e,"base_currency_id"),i=this.safeString(e,"quote_currency_id"),r=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeBool(e,"closed",!1),d=this.safeString(e,"taker_fee_rate"),h=a.Y.stringDiv(d,"100"),c=this.safeString(e,"maker_fee_rate"),l=a.Y.stringDiv(c,"100");return{id:t,symbol:r+"/"+o,base:r,quote:o,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!n,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(h),maker:this.parseNumber(l),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"quantity_precision"))),price:this.safeNumber(e,"price_increment"),cost:this.parseNumber(this.parsePrecision(this.safeString(e,"cost_precision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"min_quantity"),max:this.safeNumber(e,"max_quantity")},price:{min:this.safeNumber(e,"min_price"),max:this.safeNumber(e,"max_price")},cost:{min:this.safeNumber(e,"min_cost"),max:this.safeNumber(e,"max_cost")}},created:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.publicGetCurrencyWithPlatform(e),s=this.safeValue(t,"data",[]),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.safeString(t,"id"),a=this.safeCurrencyCode(r),o=this.safeValue(t,"display_name"),n=this.safeString(o,"en-us"),d=this.safeValue(t,"platform",[]),h=this.sortBy(d,"priority");let c;const l={};for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"id"),i=this.networkIdToCode(s),a=!this.safeValue(t,"deposit_suspended"),o=!this.safeValue(t,"withdrawal_suspended"),n=a&&o;n&&(c=t);const d=this.parsePrecision(this.safeString(t,"precision")),u=this.safeValue(t,"withdrawal_fee",[]);let p=this.safeValue(u,0,{});for(let e=0;e<u.length;e++){const t=u[e];if(this.safeString(t,"currency_id")===r){p=t;break}}l[i]={id:s,network:i,active:n,deposit:a,withdraw:o,fee:this.safeNumber(p,"amount"),precision:this.parseNumber(d),limits:{withdraw:{min:this.safeNumber(t,"min_withdrawal_amount"),max:void 0},deposit:{min:this.safeNumber(t,"min_deposit_amount"),max:void 0}},info:t}}void 0===c&&(c=this.safeValue(h,0,{}));const u=!this.safeValue(c,"deposit_suspended"),p=!this.safeValue(c,"withdrawal_suspended"),f=u&&p,m=this.safeValue(c,"withdrawal_fee",{}),g=[];for(let e=0;e<m.length;e++){const t=m[e],s=this.safeNumber(t,"amount"),i=this.safeInteger(t,"priority");void 0!==s&&void 0!==i&&g.push(t)}const v=this.sortBy(g,"priority"),y=this.safeValue(v,0,{}),w=this.safeNumber(y,"amount");i[a]={id:r,code:a,info:t,name:n,active:f,deposit:u,withdraw:p,fee:w,precision:this.parseNumber(this.parsePrecision(this.safeString(c,"precision"))),limits:{amount:{min:void 0,max:void 0},deposit:{min:this.safeNumber(c,"min_deposit_amount"),max:void 0},withdraw:{min:this.safeNumber(c,"min_withdrawal_amount"),max:void 0}},networks:l}}return i}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0},s=this.safeValue(e,"data",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeString(i,"currency_id"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"total"),o.free=this.safeString(i,"available"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={market_id:i.id},a=await this.publicGetOrderBook(this.extend(r,s)),o=this.safeValue(a,"data",[]),n=this.groupBy(o,"side");return this.parseOrderBook(n,i.symbol,void 0,"buy","sell","price","quantity")}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s={};if(void 0!==e){const t=this.marketIds(e);s.market_ids=t.join(",")}const i=await this.publicGetTicker(this.extend(s,t)),r=this.safeList(i,"data",[]);return this.parseTickers(r,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market_ids:s.id},a=await this.publicGetTicker(this.extend(i,t)),o=this.safeValue(a,"data",[]),n=this.safeValue(o,0);if(void 0===n)throw new r.BadResponse(this.id+" fetchTicker() returned an empty response");return this.parseTicker(n,s)}parseTicker(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"market_id"),r=this.safeSymbol(i,t,"-"),a=this.safeString(e,"last"),o=this.safeString(e,"change"),n=this.safeString(e,"base_volume"),d=this.safeString(e,"quote_volume");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:a,last:a,previousClose:void 0,change:o,percentage:void 0,average:void 0,baseVolume:n,quoteVolume:d,info:e},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a=this.milliseconds(),o={limit:100,start_time:this.iso8601(a-31536e6),end_time:this.iso8601(a)};void 0!==e&&(r=this.market(e),o.market_id=r.id),void 0!==t&&(o.start_time=this.iso8601(t),o.end_time=this.iso8601(Math.min(a,t+31536e6))),void 0!==s&&(o.limit=s);const n=await this.privateGetTradeHistory(this.extend(o,i)),d=this.safeList(n,"data",[]);return this.parseTrades(d,r,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market_id:r.id,start_time:"1970-01-01T00:00:00.000Z",end_time:this.iso8601(this.milliseconds())};void 0!==t&&(a.start_time=this.iso8601(t)),a.limit=void 0!==s?Math.min(s,1e3):1e3;const o=await this.publicGetTrade(this.extend(a,i)),n=this.safeList(o,"data",[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.parse8601(this.safeString(e,"time")),i=this.safeString(e,"id");let r;if(void 0!==i){const e=i.split(":");r=this.safeString(e,0)}r=this.safeString(e,"market_id",r);const a=this.safeSymbol(r,t,"-"),o=this.safeString(e,"side"),n=this.safeString(e,"price"),d=this.safeString(e,"quantity"),h=this.safeString(e,"order_id"),c=this.safeString(e,"fee_amount");let l;if(void 0!==c){const t=this.safeString(e,"fee_currency_id");l={cost:c,currency:this.safeCurrencyCode(t)}}return this.safeTrade({id:i,info:e,timestamp:s,datetime:this.iso8601(s),symbol:a,order:h,type:void 0,side:o,takerOrMaker:void 0,price:n,amount:d,cost:void 0,fee:l},t)}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.parse8601(this.safeString(t,"data"))}normalizeOHLCVTimestamp(e,t,s=!1){const i=this.parseTimeframe(t);if("1M"===t){const t=this.iso8601(e).split("-"),i=this.safeString(t,0),r=this.safeInteger(t,1);let a;return s&&(a=this.sum(r,1).toString()),r<10&&(a="0"+r.toString()),i+"-"+a+"-01T00:00:00.000Z"}if("1w"===t){const t=259200,r=(e=this.parseToInt(e/1e3))-t,a=Math.floor(r/i);let o=this.sum(t,a*i);return s&&(o=this.sum(o,i)),this.iso8601(1e3*o)}return e=this.parseToInt(e/1e3),e=i*this.parseToInt(e/i),s&&(e=this.sum(e,i)),this.iso8601(1e3*e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(this.timeframes,t,t);i=void 0===i?100:i;let n=this.sum(i,1);n=Math.min(1e3,n);const d={market_ids:a.id,interval:o,sort:"asc",limit:n},h=this.milliseconds(),c=this.parseTimeframe(t);let l=s,u=h;void 0===s?(void 0===i&&(i=n),l=h-i*c*1e3):u=void 0===i?h:this.sum(s,this.sum(i,1)*c*1e3);const p=this.normalizeOHLCVTimestamp(l,t),f=this.normalizeOHLCVTimestamp(u,t,!0);d.start_time=p,d.end_time=f;const m=await this.publicGetCandle(this.extend(d,r)),g=this.safeList(m,"data",[]);return this.parseOHLCVs(g,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"start_time")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"base_volume")]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets(),t=this.parse8601(t);const r={};let a;void 0!==e&&(a=this.market(e),r.market_id=a.id);const o=await this.privateGetOpenOrder(this.extend(r,i)),n=this.safeList(o,"data");return this.parseOrders(n,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={start_time:this.iso8601(0),end_time:this.iso8601(this.milliseconds()),limit:100};let a;void 0!==e&&(a=this.market(e),r.market_id=a.id),t&&(r.start_time=this.iso8601(t)),s&&(r.limit=s);const o=await this.privateGetOrderHistory(this.extend(r,i)),n=this.safeList(o,"data");return this.parseOrders(n,a,t,s)}async fetchOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" fetchOrder() requires a symbol argument");await this.loadMarkets();const i=this.market(t),a={market_id:i.id},o=this.safeString2(s,"clientOrderId","client_order_id");void 0!==o?a.client_order_id=o:a.order_id=e;const n=this.omit(s,["clientOrderId","client_order_id"]),d=await this.privateGetOrder(this.extend(a,n)),h=this.safeValue(d,"data",[]),c=this.safeDict(h,0);return this.parseOrder(c,i)}parseOrderStatus(e){return this.safeString({open:"open",cancelled:"canceled",filled:"closed"},e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"id"),r=this.safeString(e,"type"),o=this.safeString(e,"side"),n=this.safeString(e,"market_id"),d=this.safeSymbol(n,t,"-"),h=this.parse8601(this.safeString(e,"time"));let c=this.safeString(e,"limit_price");const l=this.safeString(e,"filled_quantity");let u=this.safeString(e,"open_quantity");const p=this.safeString(e,"cancelled_quantity");void 0!==p&&(u=a.Y.stringAdd(u,p));const f=this.safeString(e,"quantity",a.Y.stringAdd(l,u)),m=this.safeString2(e,"filled_cost","cost");"market"===r&&(c=void 0);const g=this.safeString(e,"client_order_id"),v=this.safeStringUpper(e,"time_in_force");return this.safeOrder({id:i,info:e,clientOrderId:g,timestamp:h,datetime:this.iso8601(h),lastTradeTimestamp:void 0,symbol:d,type:r,timeInForce:v,side:o,status:s,price:c,stopPrice:void 0,triggerPrice:void 0,amount:f,filled:l,remaining:u,average:void 0,cost:m,fee:void 0,trades:void 0},t)}costToPrecision(e,t){return this.decimalToPrecision(t,o.R3,this.markets[e].precision.cost,this.precisionMode)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e),h=this.safeValue(this.options,"timeInForce"),c=this.safeValue(h,t),l=this.safeString2(n,"timeInForce","time_in_force",c),u={market_id:d.id,type:t,side:s,time_in_force:l},p=this.safeString2(n,"clientOrderId","client_order_id");let f;if(void 0!==p&&(u.client_order_id=p),"limit"===t)u.limit_price=this.priceToPrecision(e,o),u.quantity=this.amountToPrecision(e,i);else if("market"===t)if("buy"===s){let t=!0;[t,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const s=this.safeString(n,"cost");if(n=this.omit(n,"cost"),void 0!==s)f=this.costToPrecision(e,s);else if(t){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument");{const t=this.numberToString(i),s=this.numberToString(o),r=a.Y.stringMul(t,s);f=this.costToPrecision(e,r)}}else f=this.costToPrecision(e,i);u.cost=f}else u.quantity=this.amountToPrecision(e,i);const m=this.omit(n,["timeInForce","time_in_force","clientOrderId","client_order_id"]),g=await this.privatePostNewOrder(this.extend(u,m)),v=this.safeValue(g,"data"),y=this.parseOrder(v,d);return"market"===t&&"buy"===s&&(y.amount=void 0,y.cost=this.parseNumber(f),y.remaining=void 0),y}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={market_id:this.market(t).id,order_id:e},a=await this.privatePostCancelOrder(this.extend(i,s)),o=this.safeDict(a,"data");return this.parseOrder(o)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address"),i=this.safeString(e,"destination_tag"),r=this.safeString(e,"currency_id"),a=(t=this.safeCurrency(r,t)).code,o=this.safeString(e,"platform_id");return this.checkAddress(s),{currency:a,address:s,tag:i,network:o,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency_id:s.id},a=this.safeValue(this.options,"networks",{});let o=this.safeStringUpper(t,"network");o=this.safeString(a,o,o),void 0!==o&&(i.platform_id=o,t=this.omit(t,"platform_id"));const n=await this.privateGetDepositAddress(this.extend(i,t)),d=this.safeValue(n,"data",[]),h=this.safeValue(d,0);if(void 0===h)throw new r.InvalidAddress(this.id+" fetchDepositAddress() returned an empty response");return this.parseDepositAddress(h,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s={};if(e){const t=[];for(let s=0;s<e.length;s++){const i=this.currency(e[s]);t.push(i.id)}s.currency_id=e.join(",")}const i=await this.privateGetDepositAddress(this.extend(s,t)),r=this.safeList(i,"data",[]);return this.parseDepositAddresses(r,e)}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const a=this.currency(e);void 0===i&&(i="");const o={currency_id:a.id,address:s,destination_tag:i,amount:this.numberToString(t)},n=this.safeValue(this.options,"networks",{});let d=this.safeStringUpper(r,"network");d=this.safeString(n,d,d),void 0!==d&&(o.platform_id=d,r=this.omit(r,"network"));const h=await this.privatePostWithdrawal(this.extend(o,r)),c=this.safeDict(h,"data");return this.parseTransaction(c,a)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"deposit"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchTransactions(e,t,s,this.extend({type:"withdrawal"},i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.currency(e),a.currency_id=r.id),a.start_time=void 0!==t?this.iso8601(t):this.iso8601(1);const o=this.safeInteger(i,"until");void 0!==o?(a.end_time=this.iso8601(o),i=this.omit(i,["until"])):a.end_time=this.iso8601(this.milliseconds()),a.limit=void 0!==s?s:100;const n=await this.privateGetTransferPayment(this.extend(a,i)),d=this.safeList(n,"data",[]);return this.parseTransactions(d,r,t,s)}parseTransaction(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeString(e,"platform_id"),r=this.networkIdToCode(i),a=this.safeNumber(e,"amount"),o=this.safeString(e,"address"),n=this.safeString(e,"destination_tag"),d=this.safeString(e,"hash"),h=this.parse8601(this.safeString(e,"time")),c=this.safeString(e,"type"),l=this.safeString(e,"currency_id"),u=this.safeCurrencyCode(l),p=this.parseTransactionStatus(this.safeString(e,"status")),f=this.safeString(e,"fee");let m;return void 0!==f&&"0"!==f&&(m={currency:u,cost:this.parseNumber(f)}),{id:s,currency:u,amount:a,network:r,addressFrom:void 0,address:o,addressTo:o,tagFrom:void 0,tag:n,tagTo:n,status:p,type:c,txid:d,timestamp:h,datetime:this.iso8601(h),updated:void 0,internal:void 0,comment:void 0,fee:m,info:e}}parseTransactionStatus(e){return this.safeString({requested:"pending",pending:"pending",confirming:"pending",confirmed:"pending",applying:"pending",done:"ok",cancelled:"canceled",cancelling:"canceled"},e,e)}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetCurrencyWithPlatform(t),i=this.safeList(s,"data");return this.parseDepositWithdrawFees(i,e,"id")}parseDepositWithdrawFee(e,t=void 0){const s=this.depositWithdrawFee({}),i=this.safeValue(e,"platform",[]),r={fee:void 0,percentage:void 0};for(let e=0;e<i.length;e++){const a=i[e],o=this.safeString(a,"id"),n=this.networkIdToCode(o,t.code),d=this.safeValue(a,"withdrawal_fee",{}),h=this.safeNumber(d[0],"amount");if(d.length){const t={fee:h,percentage:void 0===h&&void 0};0===e&&(s.withdraw=t),s.networks[n]={withdraw:t,deposit:r}}}return s.info=e,s}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},a=void 0,o=void 0){let n=this.urls.api[t]+"/";const d=this.omit(i,this.extractParams(e));if("accounts"===t){this.checkRequiredCredentials(),n+=this.implodeParams(e,i);const t=this.apiKey+":"+this.secret;a={Authorization:"Basic "+this.stringToBase64(t),"Content-Type":"application/json"},Object.keys(d).length&&(o=this.json(d))}else if(n+=this.version+"/","public"===t)n+=this.implodeParams(e,i),Object.keys(d).length&&(n+="?"+this.urlencode(d));else if("private"===t){const t=this.milliseconds();this.checkRequiredCredentials();const h=this.safeInteger(this.options,"expires");if(void 0===h||h<t)throw new r.AuthenticationError(this.id+" access token expired, call signIn() method");a={Authorization:"Bearer "+this.safeString(this.options,"accessToken")},n+=this.implodeParams(e,i),"GET"===s?Object.keys(d).length&&(n+="?"+this.urlencode(d)):Object.keys(d).length&&(o=this.json(d),a["Content-Type"]="application/json")}return{url:n,method:s,body:o,headers:a}}async signIn(e={}){this.checkRequiredCredentials();const t=await this.accountsPostToken(this.extend({grant_type:"client_credentials"},e)),s=this.safeInteger(t,"expires_in"),i=this.safeString(t,"access_token");return this.options.accessToken=i,this.options.expires=this.sum(this.milliseconds(),1e3*s),t}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&"errorCode"in n){const e=this.safeString(n,"errorCode");if(void 0!==e){const t=this.safeString(n,"message",""),s=this.safeValue(n,"details"),i=this.id+" "+e+" "+t+" "+this.json(s);throw"exact"in this.exceptions&&this.throwExactlyMatchedException(this.exceptions.exact,e,i),"broad"in this.exceptions&&this.throwBroadlyMatchedException(this.exceptions.broad,t,i),new r.ExchangeError(i)}}}}},8595:(e,t,s)=>{s.d(t,{y:()=>O});var i,r,a=s(1420),o=s(4176),n=s(6768),d=s(9489),h=s(3168),c=s(3287),l=s(300),u=s(9671),p=s(1475),f=s(4599),m=s(9426),g=s(9428),v=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};const y=new Map;y.set(0,"GENERIC_PANIC"),y.set(1,"ASSERT_FALSE"),y.set(17,"OVERFLOW"),y.set(18,"DIVIDE_BY_ZERO"),y.set(33,"ENUM_RANGE_ERROR"),y.set(34,"BAD_STORAGE_DATA"),y.set(49,"STACK_UNDERFLOW"),y.set(50,"ARRAY_RANGE_ERROR"),y.set(65,"OUT_OF_MEMORY"),y.set(81,"UNINITIALIZED_FUNCTION_CALL");const w=new RegExp(/^bytes([0-9]*)$/),b=new RegExp(/^(u?int)([0-9]*)$/);let S=null,k=1024;class O{constructor(){i.add(this)}getDefaultValue(e){const t=e.map((e=>v(this,i,"m",r).call(this,g.aX.from(e))));return new m.y(t,"_").defaultValue()}encode(e,t){(0,a.dd)(t.length,e.length,"types/values length mismatch");const s=e.map((e=>v(this,i,"m",r).call(this,g.aX.from(e)))),n=new m.y(s,"_"),d=new o.AU;return n.encode(d,t),d.data}decode(e,t,s){const a=e.map((e=>v(this,i,"m",r).call(this,g.aX.from(e))));return new m.y(a,"_").decode(new o.mP(t,s,k))}static _setDefaultMaxInflation(e){(0,a.MR)("number"==typeof e&&Number.isInteger(e),"invalid defaultMaxInflation factor","value",e),k=e}static defaultAbiCoder(){return null==S&&(S=new O),S}}i=new WeakSet,r=function e(t){if(t.isArray())return new d.fA(v(this,i,"m",e).call(this,t.arrayChildren),t.arrayLength,t.name);if(t.isTuple())return new m.y(t.components.map((t=>v(this,i,"m",e).call(this,t))),t.name);switch(t.baseType){case"address":return new n.S(t.name);case"bool":return new h.k(t.name);case"string":return new f.v(t.name);case"bytes":return new c.z(t.name);case"":return new u.h(t.name)}let s=t.type.match(b);if(s){let e=parseInt(s[2]||"256");return(0,a.MR)(0!==e&&e<=256&&e%8==0,"invalid "+s[1]+" bit length","param",t),new p.p(e/8,"int"===s[1],t.name)}if(s=t.type.match(w),s){let e=parseInt(s[1]);return(0,a.MR)(0!==e&&e<=32,"invalid bytes length","param",t),new l.J(e,t.name)}(0,a.MR)(!1,"invalid type","type",t.type)}},2014:(e,t,s)=>{s.d(t,{b:()=>u});var i=s(8432),r=s(1420);const a=BigInt(0),o=BigInt(36);function n(e){const t=(e=e.toLowerCase()).substring(2).split(""),s=new Uint8Array(40);for(let e=0;e<40;e++)s[e]=t[e].charCodeAt(0);const r=(0,i.lY)(s);for(let e=0;e<40;e+=2)r[e>>1]>>4>=8&&(t[e]=t[e].toUpperCase()),(15&r[e>>1])>=8&&(t[e+1]=t[e+1].toUpperCase());return"0x"+t.join("")}const d={};for(let e=0;e<10;e++)d[String(e)]=String(e);for(let e=0;e<26;e++)d[String.fromCharCode(65+e)]=String(10+e);const h=15;function c(e){let t=(e=(e=e.toUpperCase()).substring(4)+e.substring(0,2)+"00").split("").map((e=>d[e])).join("");for(;t.length>=h;){let e=t.substring(0,h);t=parseInt(e,10)%97+t.substring(e.length)}let s=String(98-parseInt(t,10)%97);for(;s.length<2;)s="0"+s;return s}const l=function(){const e={};for(let t=0;t<36;t++){e["0123456789abcdefghijklmnopqrstuvwxyz"[t]]=BigInt(t)}return e}();function u(e){if((0,r.MR)("string"==typeof e,"invalid address","address",e),e.match(/^(0x)?[0-9a-fA-F]{40}$/)){e.startsWith("0x")||(e="0x"+e);const t=n(e);return(0,r.MR)(!e.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||t===e,"bad address checksum","address",e),t}if(e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){(0,r.MR)(e.substring(2,4)===c(e),"bad icap checksum","address",e);let t=function(e){e=e.toLowerCase();let t=a;for(let s=0;s<e.length;s++)t=t*o+l[e[s]];return t}(e.substring(4)).toString(16);for(;t.length<40;)t="0"+t;return n("0x"+t)}(0,r.MR)(!1,"invalid address","address",e)}},4176:(e,t,s)=>{s.d(t,{AU:()=>C,Q7:()=>x,Ue:()=>M,Yx:()=>k,mP:()=>E});var i,r,a,o,n,d,h,c,l,u,p,f,m,g=s(1768),v=s(1420),y=s(3867),w=s(9654),b=function(e,t,s,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(e,s):r?r.value=s:t.set(e,s),s},S=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};const k=32,O=new Uint8Array(k),T=["then"],P={};function I(e,t){const s=new Error(`deferred error during ABI decoding triggered accessing ${e}`);throw s.error=t,s}class x extends Array{constructor(...e){const t=e[0];let s=e[1],r=(e[2]||[]).slice(),a=!0;t!==P&&(s=e,r=[],a=!1),super(s.length),i.set(this,void 0),s.forEach(((e,t)=>{this[t]=e}));const o=r.reduce(((e,t)=>("string"==typeof t&&e.set(t,(e.get(t)||0)+1),e)),new Map);if(b(this,i,Object.freeze(s.map(((e,t)=>{const s=r[t];return null!=s&&1===o.get(s)?s:null}))),"f"),a)return Object.freeze(this),new Proxy(this,{get:(e,t,s)=>{if("string"==typeof t){if(t.match(/^[0-9]+$/)){const s=(0,g.WZ)(t,"%index");if(s<0||s>=this.length)throw new RangeError("out of result range");const i=e[s];return i instanceof Error&&I(`index ${s}`,i),i}if(T.indexOf(t)>=0)return Reflect.get(e,t,s);const i=e[t];if(i instanceof Function)return function(...t){return i.apply(this===s?e:this,t)};if(!(t in e))return e.getValue.apply(this===s?e:this,[t])}return Reflect.get(e,t,s)}})}toArray(){const e=[];return this.forEach(((t,s)=>{t instanceof Error&&I(`index ${s}`,t),e.push(t)})),e}toObject(){return S(this,i,"f").reduce(((e,t,s)=>((0,v.vA)(null!=t,"value at index ${ index } unnamed","UNSUPPORTED_OPERATION",{operation:"toObject()"}),t in e||(e[t]=this.getValue(t)),e)),{})}slice(e,t){null==e&&(e=0),e<0&&(e+=this.length)<0&&(e=0),null==t&&(t=this.length),t<0&&(t+=this.length)<0&&(t=0),t>this.length&&(t=this.length);const s=[],r=[];for(let a=e;a<t;a++)s.push(this[a]),r.push(S(this,i,"f")[a]);return new x(P,s,r)}filter(e,t){const s=[],r=[];for(let a=0;a<this.length;a++){const o=this[a];o instanceof Error&&I(`index ${a}`,o),e.call(t,o,a,this)&&(s.push(o),r.push(S(this,i,"f")[a]))}return new x(P,s,r)}map(e,t){const s=[];for(let i=0;i<this.length;i++){const r=this[i];r instanceof Error&&I(`index ${i}`,r),s.push(e.call(t,r,i,this))}return s}getValue(e){const t=S(this,i,"f").indexOf(e);if(-1===t)return;const s=this[t];return s instanceof Error&&I(`property ${JSON.stringify(e)}`,s.error),s}static fromItems(e,t){return new x(P,e,t)}}function A(e){let t=(0,g.c4)(e);return(0,v.vA)(t.length<=k,"value out-of-bounds","BUFFER_OVERRUN",{buffer:t,length:k,offset:t.length}),t.length!==k&&(t=(0,y.Lm)((0,y.xW)([O.slice(t.length%k),t]))),t}i=new WeakMap;class M{constructor(e,t,s,i){(0,w.n)(this,{name:e,type:t,localName:s,dynamic:i},{name:"string",type:"string",localName:"string",dynamic:"boolean"})}_throwError(e,t){(0,v.MR)(!1,e,this.localName,t)}}class C{constructor(){r.add(this),a.set(this,void 0),o.set(this,void 0),b(this,a,[],"f"),b(this,o,0,"f")}get data(){return(0,y.xW)(S(this,a,"f"))}get length(){return S(this,o,"f")}appendWriter(e){return S(this,r,"m",n).call(this,(0,y.Lm)(e.data))}writeBytes(e){let t=(0,y.Lm)(e);const s=t.length%k;return s&&(t=(0,y.Lm)((0,y.xW)([t,O.slice(s)]))),S(this,r,"m",n).call(this,t)}writeValue(e){return S(this,r,"m",n).call(this,A(e))}writeUpdatableValue(){const e=S(this,a,"f").length;return S(this,a,"f").push(O),b(this,o,S(this,o,"f")+k,"f"),t=>{S(this,a,"f")[e]=A(t)}}}a=new WeakMap,o=new WeakMap,r=new WeakSet,n=function(e){return S(this,a,"f").push(e),b(this,o,S(this,o,"f")+e.length,"f"),e.length};class E{constructor(e,t,s){d.add(this),h.set(this,void 0),c.set(this,void 0),l.set(this,void 0),u.set(this,void 0),p.set(this,void 0),(0,w.n)(this,{allowLoose:!!t}),b(this,h,(0,y.Lm)(e),"f"),b(this,l,0,"f"),b(this,u,null,"f"),b(this,p,null!=s?s:1024,"f"),b(this,c,0,"f")}get data(){return(0,y.c$)(S(this,h,"f"))}get dataLength(){return S(this,h,"f").length}get consumed(){return S(this,c,"f")}get bytes(){return new Uint8Array(S(this,h,"f"))}subReader(e){const t=new E(S(this,h,"f").slice(S(this,c,"f")+e),this.allowLoose,S(this,p,"f"));return b(t,u,this,"f"),t}readBytes(e,t){let s=S(this,d,"m",m).call(this,0,e,!!t);return S(this,d,"m",f).call(this,e),b(this,c,S(this,c,"f")+s.length,"f"),s.slice(0,e)}readValue(){return(0,g.Dg)(this.readBytes(k))}readIndex(){return(0,g.Ro)(this.readBytes(k))}}h=new WeakMap,c=new WeakMap,l=new WeakMap,u=new WeakMap,p=new WeakMap,d=new WeakSet,f=function e(t){var s;if(S(this,u,"f"))return S(s=S(this,u,"f"),d,"m",e).call(s,t);b(this,l,S(this,l,"f")+t,"f"),(0,v.vA)(S(this,p,"f")<1||S(this,l,"f")<=S(this,p,"f")*this.dataLength,`compressed ABI data exceeds inflation ratio of ${S(this,p,"f")} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,"BUFFER_OVERRUN",{buffer:(0,y.Lm)(S(this,h,"f")),offset:S(this,c,"f"),length:t,info:{bytesRead:S(this,l,"f"),dataLength:this.dataLength}})},m=function(e,t,s){let i=Math.ceil(t/k)*k;return S(this,c,"f")+i>S(this,h,"f").length&&(this.allowLoose&&s&&S(this,c,"f")+t<=S(this,h,"f").length?i=t:(0,v.vA)(!1,"data out-of-bounds","BUFFER_OVERRUN",{buffer:(0,y.Lm)(S(this,h,"f")),length:S(this,h,"f").length,offset:S(this,c,"f")+i})),S(this,h,"f").slice(S(this,c,"f"),S(this,c,"f")+i)}},6768:(e,t,s)=>{s.d(t,{S:()=>n});var i=s(2014),r=s(1768),a=s(9073),o=s(4176);class n extends o.Ue{constructor(e){super("address","address",e,!1)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(e,t){let s=a.V.dereference(t,"string");try{s=(0,i.b)(s)}catch(e){return this._throwError(e.message,t)}return e.writeValue(s)}decode(e){return(0,i.b)((0,r.up)(e.readValue(),20))}}},1677:(e,t,s)=>{s.d(t,{j:()=>r});var i=s(4176);class r extends i.Ue{constructor(e){super(e.name,e.type,"_",e.dynamic),this.coder=e}defaultValue(){return this.coder.defaultValue()}encode(e,t){return this.coder.encode(e,t)}decode(e){return this.coder.decode(e)}}},9489:(e,t,s)=>{s.d(t,{fA:()=>c,l1:()=>h,qq:()=>d});var i=s(1420),r=s(9654),a=s(9073),o=s(4176),n=s(1677);function d(e,t,s){let r=[];if(Array.isArray(s))r=s;else if(s&&"object"==typeof s){let e={};r=t.map((t=>{const r=t.localName;return(0,i.vA)(r,"cannot encode object for signature with missing names","INVALID_ARGUMENT",{argument:"values",info:{coder:t},value:s}),(0,i.vA)(!e[r],"cannot encode object for signature with duplicate names","INVALID_ARGUMENT",{argument:"values",info:{coder:t},value:s}),e[r]=!0,s[r]}))}else(0,i.MR)(!1,"invalid tuple value","tuple",s);(0,i.MR)(t.length===r.length,"types/value length mismatch","tuple",s);let a=new o.AU,n=new o.AU,d=[];t.forEach(((e,t)=>{let s=r[t];if(e.dynamic){let t=n.length;e.encode(n,s);let i=a.writeUpdatableValue();d.push((e=>{i(e+t)}))}else e.encode(a,s)})),d.forEach((e=>{e(a.length)}));let h=e.appendWriter(a);return h+=e.appendWriter(n),h}function h(e,t){let s=[],r=[],a=e.subReader(0);return t.forEach((t=>{let o=null;if(t.dynamic){let s=e.readIndex(),r=a.subReader(s);try{o=t.decode(r)}catch(e){if((0,i.bJ)(e,"BUFFER_OVERRUN"))throw e;o=e,o.baseType=t.name,o.name=t.localName,o.type=t.type}}else try{o=t.decode(e)}catch(e){if((0,i.bJ)(e,"BUFFER_OVERRUN"))throw e;o=e,o.baseType=t.name,o.name=t.localName,o.type=t.type}if(null==o)throw new Error("investigate");s.push(o),r.push(t.localName||null)})),o.Q7.fromItems(s,r)}class c extends o.Ue{constructor(e,t,s){super("array",e.type+"["+(t>=0?t:"")+"]",s,-1===t||e.dynamic),(0,r.n)(this,{coder:e,length:t})}defaultValue(){const e=this.coder.defaultValue(),t=[];for(let s=0;s<this.length;s++)t.push(e);return t}encode(e,t){const s=a.V.dereference(t,"array");Array.isArray(s)||this._throwError("expected array value",s);let r=this.length;-1===r&&(r=s.length,e.writeValue(s.length)),(0,i.dd)(s.length,r,"coder array"+(this.localName?" "+this.localName:""));let o=[];for(let e=0;e<s.length;e++)o.push(this.coder);return d(e,o,s)}decode(e){let t=this.length;-1===t&&(t=e.readIndex(),(0,i.vA)(t*o.Yx<=e.dataLength,"insufficient data length","BUFFER_OVERRUN",{buffer:e.bytes,offset:t*o.Yx,length:e.dataLength}));let s=[];for(let e=0;e<t;e++)s.push(new n.j(this.coder));return h(e,s)}}},3168:(e,t,s)=>{s.d(t,{k:()=>a});var i=s(9073),r=s(4176);class a extends r.Ue{constructor(e){super("bool","bool",e,!1)}defaultValue(){return!1}encode(e,t){const s=i.V.dereference(t,"bool");return e.writeValue(s?1:0)}decode(e){return!!e.readValue()}}},3287:(e,t,s)=>{s.d(t,{i:()=>a,z:()=>o});var i=s(3867),r=s(4176);class a extends r.Ue{constructor(e,t){super(e,e,t,!0)}defaultValue(){return"0x"}encode(e,t){t=(0,i.Lm)(t);let s=e.writeValue(t.length);return s+=e.writeBytes(t),s}decode(e){return e.readBytes(e.readIndex(),!0)}}class o extends a{constructor(e){super("bytes",e)}decode(e){return(0,i.c$)(super.decode(e))}}},300:(e,t,s)=>{s.d(t,{J:()=>n});var i=s(9654),r=s(3867),a=s(9073),o=s(4176);class n extends o.Ue{constructor(e,t){let s="bytes"+String(e);super(s,s,t,!1),(0,i.n)(this,{size:e},{size:"number"})}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+2*this.size)}encode(e,t){let s=(0,r.Lm)(a.V.dereference(t,this.type));return s.length!==this.size&&this._throwError("incorrect data length",t),e.writeBytes(s)}decode(e){return(0,r.c$)(e.readBytes(this.size))}}},9671:(e,t,s)=>{s.d(t,{h:()=>a});var i=s(4176);const r=new Uint8Array([]);class a extends i.Ue{constructor(e){super("null","",e,!1)}defaultValue(){return null}encode(e,t){return null!=t&&this._throwError("not null",t),e.writeBytes(r)}decode(e){return e.readBytes(0),null}}},1475:(e,t,s)=>{s.d(t,{p:()=>c});var i=s(9654),r=s(1768),a=s(9073),o=s(4176);const n=BigInt(0),d=BigInt(1),h=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");class c extends o.Ue{constructor(e,t,s){const r=(t?"int":"uint")+8*e;super(r,r,s,!1),(0,i.n)(this,{size:e,signed:t},{size:"number",signed:"boolean"})}defaultValue(){return 0}encode(e,t){let s=(0,r.Ab)(a.V.dereference(t,this.type)),i=(0,r.dK)(h,8*o.Yx);if(this.signed){let e=(0,r.dK)(i,8*this.size-1);(s>e||s<-(e+d))&&this._throwError("value out-of-bounds",t),s=(0,r.JJ)(s,8*o.Yx)}else(s<n||s>(0,r.dK)(i,8*this.size))&&this._throwError("value out-of-bounds",t);return e.writeValue(s)}decode(e){let t=(0,r.dK)(e.readValue(),8*this.size);return this.signed&&(t=(0,r.ST)(t,8*this.size)),t}}},4599:(e,t,s)=>{s.d(t,{v:()=>o});var i=s(9436),r=s(9073),a=s(3287);class o extends a.i{constructor(e){super("string",e)}defaultValue(){return""}encode(e,t){return super.encode(e,(0,i.YW)(r.V.dereference(t,"string")))}decode(e){return(0,i._v)(super.decode(e))}}},9426:(e,t,s)=>{s.d(t,{y:()=>n});var i=s(9654),r=s(9073),a=s(4176),o=s(9489);class n extends a.Ue{constructor(e,t){let s=!1;const r=[];e.forEach((e=>{e.dynamic&&(s=!0),r.push(e.type)}));super("tuple","tuple("+r.join(",")+")",t,s),(0,i.n)(this,{coders:Object.freeze(e.slice())})}defaultValue(){const e=[];this.coders.forEach((t=>{e.push(t.defaultValue())}));const t=this.coders.reduce(((e,t)=>{const s=t.localName;return s&&(e[s]||(e[s]=0),e[s]++),e}),{});return this.coders.forEach(((s,i)=>{let r=s.localName;r&&1===t[r]&&("length"===r&&(r="_length"),null==e[r]&&(e[r]=e[i]))})),Object.freeze(e)}encode(e,t){const s=r.V.dereference(t,"tuple");return(0,o.qq)(e,this.coders,s)}decode(e){return(0,o.l1)(e,this.coders)}}},9428:(e,t,s)=>{s.d(t,{aX:()=>N});var i,r,a,o,n,d,h=s(1768),c=s(1420),l=s(9654),u=(s(4815),function(e,t,s,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(e,s):r?r.value=s:t.set(e,s),s}),p=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};function f(e){const t=new Set;return e.forEach((e=>t.add(e))),Object.freeze(t)}f("external public payable".split(" "));const m="constant external internal payable private public pure view",g=(f(m.split(" ")),"constructor error event fallback function receive struct"),v=(f(g.split(" ")),"calldata memory storage payable indexed"),y=f(v.split(" ")),w=f([g,v,"tuple returns",m].join(" ").split(" ")),b={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"},S=new RegExp("^(\\s*)"),k=new RegExp("^([0-9]+)"),O=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),T=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),P=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");class I{constructor(e){i.add(this),r.set(this,void 0),a.set(this,void 0),u(this,r,0,"f"),u(this,a,e.slice(),"f")}get offset(){return p(this,r,"f")}get length(){return p(this,a,"f").length-p(this,r,"f")}clone(){return new I(p(this,a,"f"))}reset(){u(this,r,0,"f")}popKeyword(e){const t=this.peek();if("KEYWORD"!==t.type||!e.has(t.text))throw new Error(`expected keyword ${t.text}`);return this.pop().text}popType(e){if(this.peek().type!==e)throw new Error(`expected ${e}; got ${JSON.stringify(this.peek())}`);return this.pop().text}popParen(){const e=this.peek();if("OPEN_PAREN"!==e.type)throw new Error("bad start");const t=p(this,i,"m",o).call(this,p(this,r,"f")+1,e.match+1);return u(this,r,e.match+1,"f"),t}popParams(){const e=this.peek();if("OPEN_PAREN"!==e.type)throw new Error("bad start");const t=[];for(;p(this,r,"f")<e.match-1;){const e=this.peek().linkNext;t.push(p(this,i,"m",o).call(this,p(this,r,"f")+1,e)),u(this,r,e,"f")}return u(this,r,e.match+1,"f"),t}peek(){if(p(this,r,"f")>=p(this,a,"f").length)throw new Error("out-of-bounds");return p(this,a,"f")[p(this,r,"f")]}peekKeyword(e){const t=this.peekType("KEYWORD");return null!=t&&e.has(t)?t:null}peekType(e){if(0===this.length)return null;const t=this.peek();return t.type===e?t.text:null}pop(){var e;const t=this.peek();return u(this,r,(e=p(this,r,"f"),++e),"f"),t}toString(){const e=[];for(let t=p(this,r,"f");t<p(this,a,"f").length;t++){const s=p(this,a,"f")[t];e.push(`${s.type}:${s.text}`)}return`<TokenString ${e.join(" ")}>`}}function x(e){const t=[],s=t=>{const s=a<e.length?JSON.stringify(e[a]):"$EOI";throw new Error(`invalid token ${s} at ${a}: ${t}`)};let i=[],r=[],a=0;for(;a<e.length;){let o=e.substring(a),n=o.match(S);n&&(a+=n[1].length,o=e.substring(a));const d={depth:i.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:a,value:-1};t.push(d);let c=b[o[0]]||"";if(c){if(d.type=c,d.text=o[0],a++,"OPEN_PAREN"===c)i.push(t.length-1),r.push(t.length-1);else if("CLOSE_PAREN"==c)0===i.length&&s("no matching open bracket"),d.match=i.pop(),t[d.match].match=t.length-1,d.depth--,d.linkBack=r.pop(),t[d.linkBack].linkNext=t.length-1;else if("COMMA"===c)d.linkBack=r.pop(),t[d.linkBack].linkNext=t.length-1,r.push(t.length-1);else if("OPEN_BRACKET"===c)d.type="BRACKET";else if("CLOSE_BRACKET"===c){let e=t.pop().text;if(t.length>0&&"NUMBER"===t[t.length-1].type){const s=t.pop().text;e=s+e,t[t.length-1].value=(0,h.WZ)(s)}if(0===t.length||"BRACKET"!==t[t.length-1].type)throw new Error("missing opening bracket");t[t.length-1].text+=e}}else if(n=o.match(O),n){if(d.text=n[1],a+=d.text.length,w.has(d.text)){d.type="KEYWORD";continue}if(d.text.match(P)){d.type="TYPE";continue}d.type="ID"}else{if(n=o.match(k),!n)throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${a}`);d.text=n[1],d.type="NUMBER",a+=d.text.length}}return new I(t.map((e=>Object.freeze(e))))}function A(e,t){const s=new Set;for(;;){const i=e.peekType("KEYWORD");if(null==i||t&&!t.has(i))break;if(e.pop(),s.has(i))throw new Error(`duplicate keywords: ${JSON.stringify(i)}`);s.add(i)}return Object.freeze(s)}r=new WeakMap,a=new WeakMap,i=new WeakSet,o=function(e=0,t=0){return new I(p(this,a,"f").slice(e,t).map((t=>Object.freeze(Object.assign({},t,{match:t.match-e,linkBack:t.linkBack-e,linkNext:t.linkNext-e})))))};const M=new RegExp(/^(.*)\[([0-9]*)\]$/);function C(e){const t=e.match(P);if((0,c.MR)(t,"invalid type","type",e),"uint"===e)return"uint256";if("int"===e)return"int256";if(t[2]){const s=parseInt(t[2]);(0,c.MR)(0!==s&&s<=32,"invalid bytes length","type",e)}else if(t[3]){const s=parseInt(t[3]);(0,c.MR)(0!==s&&s<=256&&s%8==0,"invalid numeric width","type",e)}return e}const E={},_=Symbol.for("_ethers_internal"),B="_ParamTypeInternal";class N{constructor(e,t,s,i,r,a,o,d){if(n.add(this),(0,c.gk)(e,E,"ParamType"),Object.defineProperty(this,_,{value:B}),a&&(a=Object.freeze(a.slice())),"array"===i){if(null==o||null==d)throw new Error("")}else if(null!=o||null!=d)throw new Error("");if("tuple"===i){if(null==a)throw new Error("")}else if(null!=a)throw new Error("");(0,l.n)(this,{name:t,type:s,baseType:i,indexed:r,components:a,arrayLength:o,arrayChildren:d})}format(e){if(null==e&&(e="sighash"),"json"===e){const t=this.name||"";if(this.isArray()){const e=JSON.parse(this.arrayChildren.format("json"));return e.name=t,e.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`,JSON.stringify(e)}const s={type:"tuple"===this.baseType?"tuple":this.type,name:t};return"boolean"==typeof this.indexed&&(s.indexed=this.indexed),this.isTuple()&&(s.components=this.components.map((t=>JSON.parse(t.format(e))))),JSON.stringify(s)}let t="";return this.isArray()?(t+=this.arrayChildren.format(e),t+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`):this.isTuple()?t+="("+this.components.map((t=>t.format(e))).join("full"===e?", ":",")+")":t+=this.type,"sighash"!==e&&(!0===this.indexed&&(t+=" indexed"),"full"===e&&this.name&&(t+=" "+this.name)),t}isArray(){return"array"===this.baseType}isTuple(){return"tuple"===this.baseType}isIndexable(){return null!=this.indexed}walk(e,t){if(this.isArray()){if(!Array.isArray(e))throw new Error("invalid array value");if(-1!==this.arrayLength&&e.length!==this.arrayLength)throw new Error("array is wrong length");const s=this;return e.map((e=>s.arrayChildren.walk(e,t)))}if(this.isTuple()){if(!Array.isArray(e))throw new Error("invalid tuple value");if(e.length!==this.components.length)throw new Error("array is wrong length");const s=this;return e.map(((e,i)=>s.components[i].walk(e,t)))}return t(this.type,e)}async walkAsync(e,t){const s=[],i=[e];return p(this,n,"m",d).call(this,s,e,t,(e=>{i[0]=e})),s.length&&await Promise.all(s),i[0]}static from(e,t){if(N.isParamType(e))return e;if("string"==typeof e)try{return N.from(x(e),t)}catch(t){(0,c.MR)(!1,"invalid param type","obj",e)}else if(e instanceof I){let s="",i="",r=null;A(e,f(["tuple"])).has("tuple")||e.peekType("OPEN_PAREN")?(i="tuple",r=e.popParams().map((e=>N.from(e))),s=`tuple(${r.map((e=>e.format())).join(",")})`):(s=C(e.popType("TYPE")),i=s);let a=null,o=null;for(;e.length&&e.peekType("BRACKET");){const t=e.pop();a=new N(E,"",s,i,null,r,o,a),o=t.value,s+=t.text,i="array",r=null}let n=null;if(A(e,y).has("indexed")){if(!t)throw new Error("");n=!0}const d=e.peekType("ID")?e.pop().text:"";if(e.length)throw new Error("leftover tokens");return new N(E,d,s,i,n,r,o,a)}const s=e.name;(0,c.MR)(!s||"string"==typeof s&&s.match(T),"invalid name","obj.name",s);let i=e.indexed;null!=i&&((0,c.MR)(t,"parameter cannot be indexed","obj.indexed",e.indexed),i=!!i);let r=e.type,a=r.match(M);if(a){const t=parseInt(a[2]||"-1"),o=N.from({type:a[1],components:e.components});return new N(E,s||"",r,"array",i,null,t,o)}if("tuple"===r||r.startsWith("tuple(")||r.startsWith("(")){const t=null!=e.components?e.components.map((e=>N.from(e))):null;return new N(E,s||"",r,"tuple",i,t,null,null)}return r=C(e.type),new N(E,s||"",r,r,i,null,null,null)}static isParamType(e){return e&&e[_]===B}}n=new WeakSet,d=function e(t,s,i,r){if(this.isArray()){if(!Array.isArray(s))throw new Error("invalid array value");if(-1!==this.arrayLength&&s.length!==this.arrayLength)throw new Error("array is wrong length");const a=this.arrayChildren,o=s.slice();return o.forEach(((s,r)=>{p(a,n,"m",e).call(a,t,s,i,(e=>{o[r]=e}))})),void r(o)}if(this.isTuple()){const a=this.components;let o;if(Array.isArray(s))o=s.slice();else{if(null==s||"object"!=typeof s)throw new Error("invalid tuple value");o=a.map((e=>{if(!e.name)throw new Error("cannot use object value with unnamed components");if(!(e.name in s))throw new Error(`missing value for component ${e.name}`);return s[e.name]}))}if(o.length!==this.components.length)throw new Error("array is wrong length");return o.forEach(((s,r)=>{var d;p(d=a[r],n,"m",e).call(d,t,s,i,(e=>{o[r]=e}))})),void r(o)}const a=i(this.type,s);a.then?t.push(async function(){r(await a)}()):r(a)}},4380:(e,t,s)=>{s.d(t,{z:()=>E});var i,r,a,o,n,d=s(2014),h=s(3867),c=s(1768),l=s(1420),u=s(4815),p=s(9654),f=s(5095),m=function(e,t,s,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(e,s):r?r.value=s:t.set(e,s),s},g=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};const{base16ToBinary:v}=f,y=new Uint8Array(32);y.fill(0);const w=BigInt(-1),b=BigInt(0),S=BigInt(1),k=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const O=(0,c.up)(S,32),T=(0,c.up)(b,32),P={name:"string",version:"string",chainId:"uint256",verifyingContract:"address",salt:"bytes32"},I=["name","version","chainId","verifyingContract","salt"];function x(e){return function(t){return(0,l.MR)("string"==typeof t,`invalid domain value for ${JSON.stringify(e)}`,`domain.${e}`,t),t}}const A={name:x("name"),version:x("version"),chainId:function(e){const t=(0,c.Ab)(e,"domain.chainId");return(0,l.MR)(t>=0,"invalid chain ID","domain.chainId",e),Number.isSafeInteger(t)?Number(t):(0,c.nD)(t)},verifyingContract:function(e){try{return(0,d.b)(e).toLowerCase()}catch(e){}(0,l.MR)(!1,'invalid domain value "verifyingContract"',"domain.verifyingContract",e)},salt:function(e){const t=(0,h.q5)(e,"domain.salt");return(0,l.MR)(32===t.length,'invalid domain value "salt"',"domain.salt",e),(0,h.c$)(t)}};function M(e){{const t=e.match(/^(u?)int(\d*)$/);if(t){const s=""===t[1],i=parseInt(t[2]||"256");(0,l.MR)(i%8==0&&0!==i&&i<=256&&(null==t[2]||t[2]===String(i)),"invalid numeric width","type",e);const r=(0,c.dK)(k,s?i-1:i),a=s?(r+S)*w:b;return function(t){const i=(0,c.Ab)(t,"value");return(0,l.MR)(i>=a&&i<=r,`value out-of-bounds for ${e}`,"value",i),(0,c.up)(s?(0,c.JJ)(i,256):i,32)}}}{const t=e.match(/^bytes(\d+)$/);if(t){const s=parseInt(t[1]);return(0,l.MR)(0!==s&&s<=32&&t[1]===String(s),"invalid bytes width","type",e),function(t){const i=(0,h.q5)(t);return(0,l.MR)(i.length===s,`invalid length for ${e}`,"value",t),function(e){const t=(0,h.q5)(e),s=t.length%32;return s?(0,h.xW)([t,y.slice(s)]):(0,h.c$)(t)}(t)}}}switch(e){case"address":return function(e){return(0,h.nx)((0,d.b)(e),32)};case"bool":return function(e){return e?O:T};case"bytes":return function(e){return(0,u.So)(e)};case"string":return function(e){return(0,u.id)(e)}}return null}function C(e,t){return`${e}(${t.map((({name:e,type:t})=>t+" "+e)).join(",")})`}class E{constructor(e){i.add(this),r.set(this,void 0),a.set(this,void 0),o.set(this,void 0),m(this,r,JSON.stringify(e),"f"),m(this,a,new Map,"f"),m(this,o,new Map,"f");const t=new Map,s=new Map,n=new Map;Object.keys(e).forEach((e=>{t.set(e,new Set),s.set(e,[]),n.set(e,new Set)}));for(const i in e){const r=new Set;for(const a of e[i]){(0,l.MR)(!r.has(a.name),`duplicate variable name ${JSON.stringify(a.name)} in ${JSON.stringify(i)}`,"types",e),r.add(a.name);const o=a.type.match(/^([^\x5b]*)(\x5b|$)/)[1]||null;(0,l.MR)(o!==i,`circular type reference to ${JSON.stringify(o)}`,"types",e);M(o)||((0,l.MR)(s.has(o),`unknown type ${JSON.stringify(o)}`,"types",e),s.get(o).push(i),t.get(i).add(o))}}const d=Array.from(s.keys()).filter((e=>0===s.get(e).length));(0,l.MR)(0!==d.length,"missing primary type","types",e),(0,l.MR)(1===d.length,`ambiguous primary types or unused types: ${d.map((e=>JSON.stringify(e))).join(", ")}`,"types",e),(0,p.n)(this,{primaryType:d[0]}),function i(r,a){(0,l.MR)(!a.has(r),`circular type reference to ${JSON.stringify(r)}`,"types",e),a.add(r);for(const e of t.get(r))if(s.has(e)){i(e,a);for(const t of a)n.get(t).add(e)}a.delete(r)}(this.primaryType,new Set);for(const[t,s]of n){const i=Array.from(s);i.sort(),g(this,a,"f").set(t,C(t,e[t])+i.map((t=>C(t,e[t]))).join(""))}}get types(){return JSON.parse(g(this,r,"f"))}getEncoder(e){let t=g(this,o,"f").get(e);return t||(t=g(this,i,"m",n).call(this,e),g(this,o,"f").set(e,t)),t}encodeType(e){const t=g(this,a,"f").get(e);return(0,l.MR)(t,`unknown type: ${JSON.stringify(e)}`,"name",e),t}encodeData(e,t){return this.getEncoder(e)(t)}hashStruct(e,t){return(0,u.So)(v(this.encodeData(e,t).slice(2)))}encode(e){return this.encodeData(this.primaryType,e)}hash(e){return this.hashStruct(this.primaryType,e)}_visit(e,t,s){if(M(e))return s(e,t);const i=e.match(/^(.*)(\x5b(\d*)\x5d)$/);if(i)return(0,l.MR)(!i[3]||parseInt(i[3])===t.length,`array length mismatch; expected length ${parseInt(i[3])}`,"value",t),t.map((e=>this._visit(i[1],e,s)));const r=this.types[e];if(r)return r.reduce(((e,{name:i,type:r})=>(e[i]=this._visit(r,t[i],s),e)),{});(0,l.MR)(!1,`unknown type: ${e}`,"type",e)}visit(e,t){return this._visit(this.primaryType,e,t)}static from(e){return new E(e)}static getPrimaryType(e){return E.from(e).primaryType}static hashStruct(e,t,s){return E.from(t).hashStruct(e,s)}static hashDomain(e){const t=[];for(const s in e){if(null==e[s])continue;const i=P[s];(0,l.MR)(i,`invalid typed-data domain key: ${JSON.stringify(s)}`,"domain",e),t.push({name:s,type:i})}return t.sort(((e,t)=>I.indexOf(e.name)-I.indexOf(t.name))),E.hashStruct("EIP712Domain",{EIP712Domain:t},e)}static encode(e,t,s){return(0,h.xW)(["0x1901",E.hashDomain(e),E.from(t).hash(s)])}static hash(e,t,s){return(0,u.So)(E.encode(e,t,s))}static async resolveNames(e,t,s,i){e=Object.assign({},e);for(const t in e)null==e[t]&&delete e[t];const r={};e.verifyingContract&&!(0,h.Lo)(e.verifyingContract,20)&&(r[e.verifyingContract]="0x");const a=E.from(t);a.visit(s,((e,t)=>("address"!==e||(0,h.Lo)(t,20)||(r[t]="0x"),t)));for(const e in r)r[e]=await i(e);return e.verifyingContract&&r[e.verifyingContract]&&(e.verifyingContract=r[e.verifyingContract]),{domain:e,value:s=a.visit(s,((e,t)=>"address"===e&&r[t]?r[t]:t))}}static getPayload(e,t,s){E.hashDomain(e);const i={},r=[];I.forEach((t=>{const s=e[t];null!=s&&(i[t]=A[t](s),r.push({name:t,type:P[t]}))}));const a=E.from(t),o=Object.assign({},t);return(0,l.MR)(null==o.EIP712Domain,"types must not contain EIP712Domain type","types.EIP712Domain",t),o.EIP712Domain=r,a.encode(s),{types:o,domain:i,primaryType:a.primaryType,message:a.visit(s,((e,t)=>{if(e.match(/^bytes(\d*)/))return(0,h.c$)((0,h.q5)(t));if(e.match(/^u?int/))return(0,c.Ab)(t).toString();switch(e){case"address":return t.toLowerCase();case"bool":return!!t;case"string":return(0,l.MR)("string"==typeof t,"invalid string","value",t),t}(0,l.MR)(!1,"unsupported type","type",e)}))}}}r=new WeakMap,a=new WeakMap,o=new WeakMap,i=new WeakSet,n=function(e){{const t=M(e);if(t)return t}const t=e.match(/^(.*)(\x5b(\d*)\x5d)$/);if(t){const e=t[1],s=this.getEncoder(e);return i=>{(0,l.MR)(!t[3]||parseInt(t[3])===i.length,`array length mismatch; expected length ${parseInt(t[3])}`,"value",i);let r=i.map(s);return g(this,a,"f").has(e)&&(r=r.map(u.So)),(0,u.So)((0,h.q5)((0,h.xW)(r)))}}const s=this.types[e];if(s){const t=(0,u.id)(g(this,a,"f").get(e));return e=>{const i=s.map((({name:t,type:s})=>{const i=this.getEncoder(s)(e[t]);return g(this,a,"f").has(s)?(0,u.So)(i):i}));return i.unshift(t),(0,h.xW)(i)}}(0,l.MR)(!1,`unknown type: ${e}`,"type",e)}},5897:(e,t,s)=>{s.d(t,{Ay:()=>i});const i=s(8595).y.defaultAbiCoder()},9073:(e,t,s)=>{s.d(t,{V:()=>l});var i,r=s(9654),a=function(e,t,s,i,r){if("m"===i)throw new TypeError("Private method is not writable");if("a"===i&&!r)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===i?r.call(e,s):r?r.value=s:t.set(e,s),s},o=function(e,t,s,i){if("a"===s&&!i)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!i:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?i:"a"===s?i.call(e):i?i.value:t.get(e)};const n={};function d(e,t){let s=!1;return t<0&&(s=!0,t*=-1),new l(n,`${s?"":"u"}int${t}`,e,{signed:s,width:t})}function h(e,t){return new l(n,`bytes${t||""}`,e,{size:t})}const c=Symbol.for("_ethers_typed");class l{constructor(e,t,s,o){i.set(this,void 0),null==o&&(o=null),(0,r.n)(this,{_typedSymbol:c,type:t,value:s}),a(this,i,o,"f"),this.format()}format(){if("array"===this.type)throw new Error("");if("dynamicArray"===this.type)throw new Error("");return"tuple"===this.type?`tuple(${this.value.map((e=>e.format())).join(",")})`:this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return"string"===this.type}get tupleName(){if("tuple"!==this.type)throw TypeError("not a tuple");return o(this,i,"f")}get arrayLength(){if("array"!==this.type)throw TypeError("not an array");return!0===o(this,i,"f")?-1:!1===o(this,i,"f")?this.value.length:null}static from(e,t){return new l(n,e,t)}static uint8(e){return d(e,8)}static uint16(e){return d(e,16)}static uint24(e){return d(e,24)}static uint32(e){return d(e,32)}static uint40(e){return d(e,40)}static uint48(e){return d(e,48)}static uint56(e){return d(e,56)}static uint64(e){return d(e,64)}static uint72(e){return d(e,72)}static uint80(e){return d(e,80)}static uint88(e){return d(e,88)}static uint96(e){return d(e,96)}static uint104(e){return d(e,104)}static uint112(e){return d(e,112)}static uint120(e){return d(e,120)}static uint128(e){return d(e,128)}static uint136(e){return d(e,136)}static uint144(e){return d(e,144)}static uint152(e){return d(e,152)}static uint160(e){return d(e,160)}static uint168(e){return d(e,168)}static uint176(e){return d(e,176)}static uint184(e){return d(e,184)}static uint192(e){return d(e,192)}static uint200(e){return d(e,200)}static uint208(e){return d(e,208)}static uint216(e){return d(e,216)}static uint224(e){return d(e,224)}static uint232(e){return d(e,232)}static uint240(e){return d(e,240)}static uint248(e){return d(e,248)}static uint256(e){return d(e,256)}static uint(e){return d(e,256)}static int8(e){return d(e,-8)}static int16(e){return d(e,-16)}static int24(e){return d(e,-24)}static int32(e){return d(e,-32)}static int40(e){return d(e,-40)}static int48(e){return d(e,-48)}static int56(e){return d(e,-56)}static int64(e){return d(e,-64)}static int72(e){return d(e,-72)}static int80(e){return d(e,-80)}static int88(e){return d(e,-88)}static int96(e){return d(e,-96)}static int104(e){return d(e,-104)}static int112(e){return d(e,-112)}static int120(e){return d(e,-120)}static int128(e){return d(e,-128)}static int136(e){return d(e,-136)}static int144(e){return d(e,-144)}static int152(e){return d(e,-152)}static int160(e){return d(e,-160)}static int168(e){return d(e,-168)}static int176(e){return d(e,-176)}static int184(e){return d(e,-184)}static int192(e){return d(e,-192)}static int200(e){return d(e,-200)}static int208(e){return d(e,-208)}static int216(e){return d(e,-216)}static int224(e){return d(e,-224)}static int232(e){return d(e,-232)}static int240(e){return d(e,-240)}static int248(e){return d(e,-248)}static int256(e){return d(e,-256)}static int(e){return d(e,-256)}static bytes1(e){return h(e,1)}static bytes2(e){return h(e,2)}static bytes3(e){return h(e,3)}static bytes4(e){return h(e,4)}static bytes5(e){return h(e,5)}static bytes6(e){return h(e,6)}static bytes7(e){return h(e,7)}static bytes8(e){return h(e,8)}static bytes9(e){return h(e,9)}static bytes10(e){return h(e,10)}static bytes11(e){return h(e,11)}static bytes12(e){return h(e,12)}static bytes13(e){return h(e,13)}static bytes14(e){return h(e,14)}static bytes15(e){return h(e,15)}static bytes16(e){return h(e,16)}static bytes17(e){return h(e,17)}static bytes18(e){return h(e,18)}static bytes19(e){return h(e,19)}static bytes20(e){return h(e,20)}static bytes21(e){return h(e,21)}static bytes22(e){return h(e,22)}static bytes23(e){return h(e,23)}static bytes24(e){return h(e,24)}static bytes25(e){return h(e,25)}static bytes26(e){return h(e,26)}static bytes27(e){return h(e,27)}static bytes28(e){return h(e,28)}static bytes29(e){return h(e,29)}static bytes30(e){return h(e,30)}static bytes31(e){return h(e,31)}static bytes32(e){return h(e,32)}static address(e){return new l(n,"address",e)}static bool(e){return new l(n,"bool",!!e)}static bytes(e){return new l(n,"bytes",e)}static string(e){return new l(n,"string",e)}static array(e,t){throw new Error("not implemented yet")}static tuple(e,t){throw new Error("not implemented yet")}static overrides(e){return new l(n,"overrides",Object.assign({},e))}static isTyped(e){return e&&"object"==typeof e&&"_typedSymbol"in e&&e._typedSymbol===c}static dereference(e,t){if(l.isTyped(e)){if(e.type!==t)throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);return e.value}return e}}i=new WeakMap},3867:(e,t,s)=>{s.d(t,{Lm:()=>o,Lo:()=>n,c$:()=>c,f:()=>d,nx:()=>p,q5:()=>a,xW:()=>l});var i=s(1420);function r(e,t,s){if(e instanceof Uint8Array)return s?new Uint8Array(e):e;if("string"==typeof e&&e.match(/^0x([0-9a-f][0-9a-f])*$/i)){const t=new Uint8Array((e.length-2)/2);let s=2;for(let i=0;i<t.length;i++)t[i]=parseInt(e.substring(s,s+2),16),s+=2;return t}(0,i.MR)(!1,"invalid BytesLike value",t||"value",e)}function a(e,t){return r(e,t,!1)}function o(e,t){return r(e,t,!0)}function n(e,t){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))&&(("number"!=typeof t||e.length===2+2*t)&&(!0!==t||e.length%2==0))}function d(e){return n(e,!0)||e instanceof Uint8Array}const h="0123456789abcdef";function c(e){const t=a(e);let s="0x";for(let e=0;e<t.length;e++){const i=t[e];s+=h[(240&i)>>4]+h[15&i]}return s}function l(e){return"0x"+e.map((e=>c(e).substring(2))).join("")}function u(e,t,s){const r=a(e);(0,i.vA)(t>=r.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(r),length:t,offset:t+1});const o=new Uint8Array(t);return o.fill(0),s?o.set(r,t-r.length):o.set(r,0),c(o)}function p(e,t){return u(e,t,!0)}},1420:(e,t,s)=>{s.d(t,{MR:()=>n,SP:()=>c,bJ:()=>a,dd:()=>d,gk:()=>l,vA:()=>o});var i=s(9654);function r(e){if(null==e)return"null";if(Array.isArray(e))return"[ "+e.map(r).join(", ")+" ]";if(e instanceof Uint8Array){const t="0123456789abcdef";let s="0x";for(let i=0;i<e.length;i++)s+=t[e[i]>>4],s+=t[15&e[i]];return s}if("object"==typeof e&&"function"==typeof e.toJSON)return r(e.toJSON());switch(typeof e){case"boolean":case"symbol":case"number":return e.toString();case"bigint":return BigInt(e).toString();case"string":return JSON.stringify(e);case"object":{const t=Object.keys(e);return t.sort(),"{ "+t.map((t=>`${r(t)}: ${r(e[t])}`)).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function a(e,t){return e&&e.code===t}function o(e,t,s,a){if(!e)throw function(e,t,s){let a,o=e;{const i=[];if(s){if("message"in s||"code"in s||"name"in s)throw new Error(`value will overwrite populated values: ${r(s)}`);for(const e in s){if("shortMessage"===e)continue;const t=s[e];i.push(e+"="+r(t))}}i.push(`code=${t}`),i.length&&(e+=" ("+i.join(", ")+")")}switch(t){case"INVALID_ARGUMENT":a=new TypeError(e);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":a=new RangeError(e);break;default:a=new Error(e)}return(0,i.n)(a,{code:t}),s&&Object.assign(a,s),null==a.shortMessage&&(0,i.n)(a,{shortMessage:o}),a}(t,s,a)}function n(e,t,s,i){o(e,t,"INVALID_ARGUMENT",{argument:s,value:i})}function d(e,t,s){null==s&&(s=""),s&&(s=": "+s),o(e>=t,"missing arguemnt"+s,"MISSING_ARGUMENT",{count:e,expectedCount:t}),o(e<=t,"too many arguemnts"+s,"UNEXPECTED_ARGUMENT",{count:e,expectedCount:t})}const h=["NFD","NFC","NFKD","NFKC"].reduce(((e,t)=>{try{if("test"!=="test".normalize(t))throw new Error("bad");if("NFD"===t){const e=String.fromCharCode(233).normalize("NFD");if(e!==String.fromCharCode(101,769))throw new Error("broken")}e.push(t)}catch(e){}return e}),[]);function c(e){o(h.indexOf(e)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:e}})}function l(e,t,s){if(null==s&&(s=""),e!==t){let e=s,t="new";s&&(e+=".",t+=" "+s),o(!1,`private constructor; use ${e}from* methods`,"UNSUPPORTED_OPERATION",{operation:t})}}},4815:(e,t,s)=>{s.d(t,{So:()=>o,id:()=>a});var i=s(8283),r=s(8432);function a(e){return"0x"+(0,i.tW)(e,r.lY,"hex")}function o(e){return"0x"+(0,i.tW)(e,r.lY,"hex")}},1768:(e,t,s)=>{s.d(t,{Ab:()=>l,Dg:()=>f,JJ:()=>h,Ro:()=>g,ST:()=>d,WZ:()=>m,c4:()=>y,dK:()=>c,nD:()=>w,up:()=>v});var i=s(3867),r=s(1420);const a=BigInt(0),o=BigInt(1),n=9007199254740991;function d(e,t){const s=u(e,"value"),i=BigInt(m(t,"width"));if((0,r.vA)(s>>i===a,"overflow","NUMERIC_FAULT",{operation:"fromTwos",fault:"overflow",value:e}),s>>i-o){return-((~s&(o<<i)-o)+o)}return s}function h(e,t){let s=l(e,"value");const i=BigInt(m(t,"width")),n=o<<i-o;if(s<a){s=-s,(0,r.vA)(s<=n,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:e});return(~s&(o<<i)-o)+o}return(0,r.vA)(s<n,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:e}),s}function c(e,t){const s=u(e,"value"),i=BigInt(m(t,"bits"));return s&(o<<i)-o}function l(e,t){switch(typeof e){case"bigint":return e;case"number":return(0,r.MR)(Number.isInteger(e),"underflow",t||"value",e),(0,r.MR)(e>=-n&&e<=n,"overflow",t||"value",e),BigInt(e);case"string":try{if(""===e)throw new Error("empty string");return"-"===e[0]&&"-"!==e[1]?-BigInt(e.substring(1)):BigInt(e)}catch(s){(0,r.MR)(!1,`invalid BigNumberish string: ${s.message}`,t||"value",e)}}(0,r.MR)(!1,"invalid BigNumberish value",t||"value",e)}function u(e,t){const s=l(e,t);return(0,r.vA)(s>=a,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:e}),s}const p="0123456789abcdef";function f(e){if(e instanceof Uint8Array){let t="0x0";for(const s of e)t+=p[s>>4],t+=p[15&s];return BigInt(t)}return l(e)}function m(e,t){switch(typeof e){case"bigint":return(0,r.MR)(e>=-n&&e<=n,"overflow",t||"value",e),Number(e);case"number":return(0,r.MR)(Number.isInteger(e),"underflow",t||"value",e),(0,r.MR)(e>=-n&&e<=n,"overflow",t||"value",e),e;case"string":try{if(""===e)throw new Error("empty string");return m(BigInt(e),t)}catch(s){(0,r.MR)(!1,`invalid numeric string: ${s.message}`,t||"value",e)}}(0,r.MR)(!1,"invalid numeric value",t||"value",e)}function g(e){return m(f(e))}function v(e,t){let s=u(e,"value").toString(16);if(null==t)s.length%2&&(s="0"+s);else{const i=m(t,"width");for((0,r.vA)(2*i>=s.length,`value exceeds width (${i} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:e});s.length<2*i;)s="0"+s}return"0x"+s}function y(e){const t=u(e,"value");if(t===a)return new Uint8Array([]);let s=t.toString(16);s.length%2&&(s="0"+s);const i=new Uint8Array(s.length/2);for(let e=0;e<i.length;e++){const t=2*e;i[e]=parseInt(s.substring(t,t+2),16)}return i}function w(e){let t=(0,i.c$)((0,i.f)(e)?e:y(e)).substring(2);for(;t.startsWith("0");)t=t.substring(1);return""===t&&(t="0"),"0x"+t}},9654:(e,t,s)=>{function i(e,t,s){const i=t.split("|").map((e=>e.trim()));for(let s=0;s<i.length;s++)switch(t){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof e===t)return}const r=new Error(`invalid value for type ${t}`);throw r.code="INVALID_ARGUMENT",r.argument=`value.${s}`,r.value=e,r}function r(e,t,s){for(let r in t){let a=t[r];const o=s?s[r]:null;o&&i(a,o,r),Object.defineProperty(e,r,{enumerable:!0,value:a,writable:!1})}}s.d(t,{n:()=>r})},9436:(e,t,s)=>{s.d(t,{YW:()=>d,_v:()=>h});var i=s(3867),r=s(1420);function a(e,t,s,i,r){if("BAD_PREFIX"===e||"UNEXPECTED_CONTINUE"===e){let e=0;for(let i=t+1;i<s.length&&s[i]>>6==2;i++)e++;return e}return"OVERRUN"===e?s.length-t-1:0}const o=Object.freeze({error:function(e,t,s,i,a){(0,r.MR)(!1,`invalid codepoint at offset ${t}; ${e}`,"bytes",s)},ignore:a,replace:function(e,t,s,i,o){return"OVERLONG"===e?((0,r.MR)("number"==typeof o,"invalid bad code point for replacement","badCodepoint",o),i.push(o),0):(i.push(65533),a(e,t,s))}});function n(e,t){null==t&&(t=o.error);const s=(0,i.q5)(e,"bytes"),r=[];let a=0;for(;a<s.length;){const e=s[a++];if(e>>7==0){r.push(e);continue}let i=null,o=null;if(192==(224&e))i=1,o=127;else if(224==(240&e))i=2,o=2047;else{if(240!=(248&e)){a+=t(128==(192&e)?"UNEXPECTED_CONTINUE":"BAD_PREFIX",a-1,s,r);continue}i=3,o=65535}if(a-1+i>=s.length){a+=t("OVERRUN",a-1,s,r);continue}let n=e&(1<<8-i-1)-1;for(let e=0;e<i;e++){let e=s[a];if(128!=(192&e)){a+=t("MISSING_CONTINUE",a,s,r),n=null;break}n=n<<6|63&e,a++}null!==n&&(n>1114111?a+=t("OUT_OF_RANGE",a-1-i,s,r,n):n>=55296&&n<=57343?a+=t("UTF16_SURROGATE",a-1-i,s,r,n):n<=o?a+=t("OVERLONG",a-1-i,s,r,n):r.push(n))}return r}function d(e,t){null!=t&&((0,r.SP)(t),e=e.normalize(t));let s=[];for(let t=0;t<e.length;t++){const i=e.charCodeAt(t);if(i<128)s.push(i);else if(i<2048)s.push(i>>6|192),s.push(63&i|128);else if(55296==(64512&i)){t++;const a=e.charCodeAt(t);(0,r.MR)(t<e.length&&56320==(64512&a),"invalid surrogate pair","str",e);const o=65536+((1023&i)<<10)+(1023&a);s.push(o>>18|240),s.push(o>>12&63|128),s.push(o>>6&63|128),s.push(63&o|128)}else s.push(i>>12|224),s.push(i>>6&63|128),s.push(63&i|128)}return new Uint8Array(s)}function h(e,t){return n(e,t).map((e=>e<=65535?String.fromCharCode(e):(e-=65536,String.fromCharCode(55296+(e>>10&1023),56320+(1023&e))))).join("")}},5944:(e,t,s)=>{s.d(t,{v:()=>o});var i=s(6279),r=s(2501);const a="undefined"!=typeof process?process.env?.npm_package_version:void 0;class o{constructor(e={}){e=e||{},this.default_key_size=e.default_key_size?parseInt(e.default_key_size,10):1024,this.default_public_exponent=e.default_public_exponent||"010001",this.log=e.log||!1,this.key=null}setKey(e){this.log&&this.key&&console.warn("A key was already set, overriding existing."),this.key=new r.Y(e)}setPrivateKey(e){this.setKey(e)}setPublicKey(e){this.setKey(e)}decrypt(e){try{return this.getKey().decrypt((0,i.ry)(e))}catch(e){return!1}}encrypt(e){try{return(0,i.gr)(this.getKey().encrypt(e))}catch(e){return!1}}sign(e,t,s){try{return(0,i.gr)(this.getKey().sign(e,t,s))}catch(e){return!1}}verify(e,t,s){try{return this.getKey().verify(e,(0,i.ry)(t),s)}catch(e){return!1}}getKey(e){if(!this.key){if(this.key=new r.Y,e&&"[object Function]"==={}.toString.call(e))return void this.key.generateAsync(this.default_key_size,this.default_public_exponent,e);this.key.generate(this.default_key_size,this.default_public_exponent)}return this.key}getPrivateKey(){return this.getKey().getPrivateKey()}getPrivateKeyB64(){return this.getKey().getPrivateBaseKeyB64()}getPublicKey(){return this.getKey().getPublicKey()}getPublicKeyB64(){return this.getKey().getPublicBaseKeyB64()}}o.version=a},2501:(e,t,s)=>{s.d(t,{Y:()=>c});var i=s(6279),r=s(1170),a=s(5268),o=s(890),n=s(9476),d=s(1279),h=s(7196);class c extends n.s{constructor(e){super(),e&&("string"==typeof e?this.parseKey(e):(c.hasPrivateKeyProperty(e)||c.hasPublicKeyProperty(e))&&this.parsePropertiesFrom(e))}parseKey(e){try{let s=0,i=0;const n=/^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(e)?r._.decode(e):a.o.unarmor(e);let h=o.Ge.decode(n);if(3===h.sub.length&&(h=h.sub[2].sub[0]),9===h.sub.length){s=h.sub[1].getHexStringValue(),this.n=(0,d.Bv)(s,16),i=h.sub[2].getHexStringValue(),this.e=parseInt(i,16);const e=h.sub[3].getHexStringValue();this.d=(0,d.Bv)(e,16);const t=h.sub[4].getHexStringValue();this.p=(0,d.Bv)(t,16);const r=h.sub[5].getHexStringValue();this.q=(0,d.Bv)(r,16);const a=h.sub[6].getHexStringValue();this.dmp1=(0,d.Bv)(a,16);const o=h.sub[7].getHexStringValue();this.dmq1=(0,d.Bv)(o,16);const n=h.sub[8].getHexStringValue();this.coeff=(0,d.Bv)(n,16)}else{if(2!==h.sub.length)return!1;if(h.sub[0].sub){var t=h.sub[1].sub[0];s=t.sub[0].getHexStringValue(),this.n=(0,d.Bv)(s,16),i=t.sub[1].getHexStringValue(),this.e=parseInt(i,16)}else s=h.sub[0].getHexStringValue(),this.n=(0,d.Bv)(s,16),i=h.sub[1].getHexStringValue(),this.e=parseInt(i,16)}return!0}catch(e){return!1}}getPrivateBaseKey(){const e={array:[new h.p.asn1.DERInteger({int:0}),new h.p.asn1.DERInteger({bigint:this.n}),new h.p.asn1.DERInteger({int:this.e}),new h.p.asn1.DERInteger({bigint:this.d}),new h.p.asn1.DERInteger({bigint:this.p}),new h.p.asn1.DERInteger({bigint:this.q}),new h.p.asn1.DERInteger({bigint:this.dmp1}),new h.p.asn1.DERInteger({bigint:this.dmq1}),new h.p.asn1.DERInteger({bigint:this.coeff})]};return new h.p.asn1.DERSequence(e).getEncodedHex()}getPrivateBaseKeyB64(){return(0,i.gr)(this.getPrivateBaseKey())}getPublicBaseKey(){const e=new h.p.asn1.DERSequence({array:[new h.p.asn1.DERObjectIdentifier({oid:"1.2.840.113549.1.1.1"}),new h.p.asn1.DERNull]}),t=new h.p.asn1.DERSequence({array:[new h.p.asn1.DERInteger({bigint:this.n}),new h.p.asn1.DERInteger({int:this.e})]}),s=new h.p.asn1.DERBitString({hex:"00"+t.getEncodedHex()});return new h.p.asn1.DERSequence({array:[e,s]}).getEncodedHex()}getPublicBaseKeyB64(){return(0,i.gr)(this.getPublicBaseKey())}static wordwrap(e,t){if(!e)return e;const s="(.{1,"+(t=t||64)+"})( +|$\n?)|(.{1,"+t+"})";return e.match(RegExp(s,"g")).join("\n")}getPrivateKey(){let e="-----BEGIN RSA PRIVATE KEY-----\n";return e+=c.wordwrap(this.getPrivateBaseKeyB64())+"\n",e+="-----END RSA PRIVATE KEY-----",e}getPublicKey(){let e="-----BEGIN PUBLIC KEY-----\n";return e+=c.wordwrap(this.getPublicBaseKeyB64())+"\n",e+="-----END PUBLIC KEY-----",e}static hasPublicKeyProperty(e){return(e=e||{}).hasOwnProperty("n")&&e.hasOwnProperty("e")}static hasPrivateKeyProperty(e){return(e=e||{}).hasOwnProperty("n")&&e.hasOwnProperty("e")&&e.hasOwnProperty("d")&&e.hasOwnProperty("p")&&e.hasOwnProperty("q")&&e.hasOwnProperty("dmp1")&&e.hasOwnProperty("dmq1")&&e.hasOwnProperty("coeff")}parsePropertiesFrom(e){this.n=e.n,this.e=e.e,e.hasOwnProperty("d")&&(this.d=e.d,this.p=e.p,this.q=e.q,this.dmp1=e.dmp1,this.dmq1=e.dmq1,this.coeff=e.coeff)}}},890:(e,t,s)=>{s.d(t,{Ge:()=>d});var i=s(8483);const r=/^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,a=/^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;function o(e,t){return e.length>t&&(e=e.substring(0,t)+"…"),e}class n{constructor(e,t){this.hexDigits="0123456789ABCDEF",e instanceof n?(this.enc=e.enc,this.pos=e.pos):(this.enc=e,this.pos=t)}get(e){if(void 0===e&&(e=this.pos++),e>=this.enc.length)throw new Error(`Requesting byte offset ${e} on a stream of length ${this.enc.length}`);return"string"==typeof this.enc?this.enc.charCodeAt(e):this.enc[e]}hexByte(e){return this.hexDigits.charAt(e>>4&15)+this.hexDigits.charAt(15&e)}hexDump(e,t,s){let i="";for(let r=e;r<t;++r)if(i+=this.hexByte(this.get(r)),!0!==s)switch(15&r){case 7:i+="  ";break;case 15:i+="\n";break;default:i+=" "}return i}isASCII(e,t){for(let s=e;s<t;++s){const e=this.get(s);if(e<32||e>176)return!1}return!0}parseStringISO(e,t){let s="";for(let i=e;i<t;++i)s+=String.fromCharCode(this.get(i));return s}parseStringUTF(e,t){let s="";for(let i=e;i<t;){const e=this.get(i++);s+=e<128?String.fromCharCode(e):e>191&&e<224?String.fromCharCode((31&e)<<6|63&this.get(i++)):String.fromCharCode((15&e)<<12|(63&this.get(i++))<<6|63&this.get(i++))}return s}parseStringBMP(e,t){let s,i,r="";for(let a=e;a<t;)s=this.get(a++),i=this.get(a++),r+=String.fromCharCode(s<<8|i);return r}parseTime(e,t,s){let i=this.parseStringISO(e,t);const o=(s?r:a).exec(i);return o?(s&&(o[1]=+o[1],o[1]+=+o[1]<70?2e3:1900),i=o[1]+"-"+o[2]+"-"+o[3]+" "+o[4],o[5]&&(i+=":"+o[5],o[6]&&(i+=":"+o[6],o[7]&&(i+="."+o[7]))),o[8]&&(i+=" UTC","Z"!=o[8]&&(i+=o[8],o[9]&&(i+=":"+o[9]))),i):"Unrecognized time: "+i}parseInteger(e,t){let s=this.get(e);const r=s>127,a=r?255:0;let o,n="";for(;s==a&&++e<t;)s=this.get(e);if(o=t-e,0===o)return r?-1:0;if(o>4){for(n=s,o<<=3;0==(128&(+n^a));)n=+n<<1,--o;n="("+o+" bit)\n"}r&&(s-=256);const d=new i.V(s);for(let s=e+1;s<t;++s)d.mulAdd(256,this.get(s));return n+d.toString()}parseBitString(e,t,s){const i=this.get(e),r="("+((t-e-1<<3)-i)+" bit)\n";let a="";for(let n=e+1;n<t;++n){const e=this.get(n),d=n==t-1?i:0;for(let t=7;t>=d;--t)a+=e>>t&1?"1":"0";if(a.length>s)return r+o(a,s)}return r+a}parseOctetString(e,t,s){if(this.isASCII(e,t))return o(this.parseStringISO(e,t),s);const i=t-e;let r="("+i+" byte)\n";i>(s/=2)&&(t=e+s);for(let s=e;s<t;++s)r+=this.hexByte(this.get(s));return i>s&&(r+="…"),r}parseOID(e,t,s){let r="",a=new i.V,n=0;for(let d=e;d<t;++d){const e=this.get(d);if(a.mulAdd(128,127&e),n+=7,!(128&e)){if(""===r)if(a=a.simplify(),a instanceof i.V)a.sub(80),r="2."+a.toString();else{const e=a<80?a<40?0:1:2;r=e+"."+(a-40*e)}else r+="."+a.toString();if(r.length>s)return o(r,s);a=new i.V,n=0}}return n>0&&(r+=".incomplete"),r}}class d{constructor(e,t,s,i,r){if(!(i instanceof h))throw new Error("Invalid tag value.");this.stream=e,this.header=t,this.length=s,this.tag=i,this.sub=r}typeName(){switch(this.tag.tagClass){case 0:switch(this.tag.tagNumber){case 0:return"EOC";case 1:return"BOOLEAN";case 2:return"INTEGER";case 3:return"BIT_STRING";case 4:return"OCTET_STRING";case 5:return"NULL";case 6:return"OBJECT_IDENTIFIER";case 7:return"ObjectDescriptor";case 8:return"EXTERNAL";case 9:return"REAL";case 10:return"ENUMERATED";case 11:return"EMBEDDED_PDV";case 12:return"UTF8String";case 16:return"SEQUENCE";case 17:return"SET";case 18:return"NumericString";case 19:return"PrintableString";case 20:return"TeletexString";case 21:return"VideotexString";case 22:return"IA5String";case 23:return"UTCTime";case 24:return"GeneralizedTime";case 25:return"GraphicString";case 26:return"VisibleString";case 27:return"GeneralString";case 28:return"UniversalString";case 30:return"BMPString"}return"Universal_"+this.tag.tagNumber.toString();case 1:return"Application_"+this.tag.tagNumber.toString();case 2:return"["+this.tag.tagNumber.toString()+"]";case 3:return"Private_"+this.tag.tagNumber.toString()}}content(e){if(void 0===this.tag)return null;void 0===e&&(e=1/0);const t=this.posContent(),s=Math.abs(this.length);if(!this.tag.isUniversal())return null!==this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(t,t+s,e);switch(this.tag.tagNumber){case 1:return 0===this.stream.get(t)?"false":"true";case 2:return this.stream.parseInteger(t,t+s);case 3:return this.sub?"("+this.sub.length+" elem)":this.stream.parseBitString(t,t+s,e);case 4:return this.sub?"("+this.sub.length+" elem)":this.stream.parseOctetString(t,t+s,e);case 6:return this.stream.parseOID(t,t+s,e);case 16:case 17:return null!==this.sub?"("+this.sub.length+" elem)":"(no elem)";case 12:return o(this.stream.parseStringUTF(t,t+s),e);case 18:case 19:case 20:case 21:case 22:case 26:return o(this.stream.parseStringISO(t,t+s),e);case 30:return o(this.stream.parseStringBMP(t,t+s),e);case 23:case 24:return this.stream.parseTime(t,t+s,23==this.tag.tagNumber)}return null}toString(){return this.typeName()+"@"+this.stream.pos+"[header:"+this.header+",length:"+this.length+",sub:"+(null===this.sub?"null":this.sub.length)+"]"}toPrettyString(e){void 0===e&&(e="");let t=e+this.typeName()+" @"+this.stream.pos;if(this.length>=0&&(t+="+"),t+=this.length,this.tag.tagConstructed?t+=" (constructed)":!this.tag.isUniversal()||3!=this.tag.tagNumber&&4!=this.tag.tagNumber||null===this.sub||(t+=" (encapsulates)"),t+="\n",null!==this.sub){e+="  ";for(let s=0,i=this.sub.length;s<i;++s)t+=this.sub[s].toPrettyString(e)}return t}posStart(){return this.stream.pos}posContent(){return this.stream.pos+this.header}posEnd(){return this.stream.pos+this.header+Math.abs(this.length)}toHexString(){return this.stream.hexDump(this.posStart(),this.posEnd(),!0)}static decodeLength(e){let t=e.get();const s=127&t;if(s==t)return s;if(s>6)throw new Error("Length over 48 bits not supported at position "+(e.pos-1));if(0===s)return null;t=0;for(let i=0;i<s;++i)t=256*t+e.get();return t}getHexStringValue(){const e=this.toHexString(),t=2*this.header,s=2*this.length;return e.substr(t,s)}static decode(e){let t;t=e instanceof n?e:new n(e,0);const s=new n(t),i=new h(t);let r=d.decodeLength(t);const a=t.pos,o=a-s.pos;let c=null;const l=function(){const e=[];if(null!==r){const s=a+r;for(;t.pos<s;)e[e.length]=d.decode(t);if(t.pos!=s)throw new Error("Content size is not correct for container starting at offset "+a)}else try{for(;;){const s=d.decode(t);if(s.tag.isEOC())break;e[e.length]=s}r=a-t.pos}catch(e){throw new Error("Exception while decoding undefined length content: "+e)}return e};if(i.tagConstructed)c=l();else if(i.isUniversal()&&(3==i.tagNumber||4==i.tagNumber))try{if(3==i.tagNumber&&0!=t.get())throw new Error("BIT STRINGs with unused bits cannot encapsulate.");c=l();for(let e=0;e<c.length;++e)if(c[e].tag.isEOC())throw new Error("EOC is not supposed to be actual content.")}catch(e){c=null}if(null===c){if(null===r)throw new Error("We can't skip over an invalid tag with undefined length at offset "+a);t.pos=a+Math.abs(r)}return new d(s,o,r,i,c)}}class h{constructor(e){let t=e.get();if(this.tagClass=t>>6,this.tagConstructed=0!=(32&t),this.tagNumber=31&t,31==this.tagNumber){const s=new i.V;do{t=e.get(),s.mulAdd(128,127&t)}while(128&t);this.tagNumber=s.simplify()}}isUniversal(){return 0===this.tagClass}isEOC(){return 0===this.tagClass&&0===this.tagNumber}}},5268:(e,t,s)=>{let i;s.d(t,{o:()=>r});const r={decode(e){let t;if(void 0===i){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s="= \f\n\r\t \u2028\u2029";for(i=Object.create(null),t=0;t<64;++t)i[e.charAt(t)]=t;for(i["-"]=62,i._=63,t=0;t<s.length;++t)i[s.charAt(t)]=-1}const s=[];let r=0,a=0;for(t=0;t<e.length;++t){let o=e.charAt(t);if("="==o)break;if(o=i[o],-1!=o){if(void 0===o)throw new Error("Illegal character at offset "+t);r|=o,++a>=4?(s[s.length]=r>>16,s[s.length]=r>>8&255,s[s.length]=255&r,r=0,a=0):r<<=6}}switch(a){case 1:throw new Error("Base64 encoding incomplete: at least 2 bits missing");case 2:s[s.length]=r>>10;break;case 3:s[s.length]=r>>16,s[s.length]=r>>8&255}return s},re:/-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,unarmor(e){const t=r.re.exec(e);if(t)if(t[1])e=t[1];else{if(!t[2])throw new Error("RegExp out of sync");e=t[2]}return r.decode(e)}}},1170:(e,t,s)=>{let i;s.d(t,{_:()=>r});const r={decode(e){let t;if(void 0===i){let e="0123456789ABCDEF";const s=" \f\n\r\t \u2028\u2029";for(i={},t=0;t<16;++t)i[e.charAt(t)]=t;for(e=e.toLowerCase(),t=10;t<16;++t)i[e.charAt(t)]=t;for(t=0;t<s.length;++t)i[s.charAt(t)]=-1}const s=[];let r=0,a=0;for(t=0;t<e.length;++t){let o=e.charAt(t);if("="==o)break;if(o=i[o],-1!=o){if(void 0===o)throw new Error("Illegal character at offset "+t);r|=o,++a>=2?(s[s.length]=r,r=0,a=0):r<<=4}}if(a)throw new Error("Hex encoding incomplete: 4 bits missing");return s}}},8483:(e,t,s)=>{s.d(t,{V:()=>r});const i=1e13;class r{constructor(e){this.buf=[+e||0]}mulAdd(e,t){const s=this.buf,r=s.length;let a,o;for(a=0;a<r;++a)o=s[a]*e+t,o<i?t=0:o-=(t=0|o/i)*i,s[a]=o;t>0&&(s[a]=t)}sub(e){const t=this.buf,s=t.length;let r,a;for(r=0;r<s;++r)a=t[r]-e,a<0?(a+=i,e=1):e=0,t[r]=a;for(;0===t[t.length-1];)t.pop()}toString(e){if(10!=(e||10))throw new Error("only base 10 is supported");const t=this.buf;let s=t[t.length-1].toString();for(let e=t.length-2;e>=0;--e)s+=(i+t[e]).toString().substring(1);return s}valueOf(){const e=this.buf;let t=0;for(let s=e.length-1;s>=0;--s)t=t*i+e[s];return t}simplify(){const e=this.buf;return 1==e.length?e[0]:this}}},6279:(e,t,s)=>{s.d(t,{gr:()=>r,ry:()=>a});var i=s(4710);function r(e){return i.K3.encode(i.xn.decode(e))}function a(e){return i.xn.encode(i.K3.decode(e))}},1279:(e,t,s)=>{s.d(t,{Bv:()=>p,EB:()=>u,jZ:()=>n});var i=s(2628);let r;const a=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],o=(1<<26)/a[a.length-1];class n{constructor(e,t,s){null!=e&&("number"==typeof e?this.fromNumber(e,t,s):null==t&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}toString(e){if(this.s<0)return"-"+this.negate().toString(e);let t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}const s=(1<<t)-1;let r,a=!1,o="",n=this.t,d=this.DB-n*this.DB%t;if(n-- >0)for(d<this.DB&&(r=this[n]>>d)>0&&(a=!0,o=(0,i.W4)(r));n>=0;)d<t?(r=(this[n]&(1<<d)-1)<<t-d,r|=this[--n]>>(d+=this.DB-t)):(r=this[n]>>(d-=t)&s,d<=0&&(d+=this.DB,--n)),r>0&&(a=!0),a&&(o+=(0,i.W4)(r));return a?o:"0"}negate(){const e=u();return n.ZERO.subTo(this,e),e}abs(){return this.s<0?this.negate():this}compareTo(e){let t=this.s-e.s;if(0!=t)return t;let s=this.t;if(t=s-e.t,0!=t)return this.s<0?-t:t;for(;--s>=0;)if(0!=(t=this[s]-e[s]))return t;return 0}bitLength(){return this.t<=0?0:this.DB*(this.t-1)+b(this[this.t-1]^this.s&this.DM)}mod(e){const t=u();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(n.ZERO)>0&&e.subTo(t,t),t}modPowInt(e,t){let s;return s=e<256||t.isEven()?new h(t):new c(t),this.exp(e,s)}clone(){const e=u();return this.copyTo(e),e}intValue(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}byteValue(){return 0==this.t?this.s:this[0]<<24>>24}shortValue(){return 0==this.t?this.s:this[0]<<16>>16}signum(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1}toByteArray(){let e=this.t;const t=[];t[0]=this.s;let s,i=this.DB-e*this.DB%8,r=0;if(e-- >0)for(i<this.DB&&(s=this[e]>>i)!=(this.s&this.DM)>>i&&(t[r++]=s|this.s<<this.DB-i);e>=0;)i<8?(s=(this[e]&(1<<i)-1)<<8-i,s|=this[--e]>>(i+=this.DB-8)):(s=this[e]>>(i-=8)&255,i<=0&&(i+=this.DB,--e)),0!=(128&s)&&(s|=-256),0==r&&(128&this.s)!=(128&s)&&++r,(r>0||s!=this.s)&&(t[r++]=s);return t}equals(e){return 0==this.compareTo(e)}min(e){return this.compareTo(e)<0?this:e}max(e){return this.compareTo(e)>0?this:e}and(e){const t=u();return this.bitwiseTo(e,i.Ir,t),t}or(e){const t=u();return this.bitwiseTo(e,i.cO,t),t}xor(e){const t=u();return this.bitwiseTo(e,i.AR,t),t}andNot(e){const t=u();return this.bitwiseTo(e,i.$r,t),t}not(){const e=u();for(let t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e}shiftLeft(e){const t=u();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t}shiftRight(e){const t=u();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t}getLowestSetBit(){for(let e=0;e<this.t;++e)if(0!=this[e])return e*this.DB+(0,i.OF)(this[e]);return this.s<0?this.t*this.DB:-1}bitCount(){let e=0;const t=this.s&this.DM;for(let s=0;s<this.t;++s)e+=(0,i.XP)(this[s]^t);return e}testBit(e){const t=Math.floor(e/this.DB);return t>=this.t?0!=this.s:0!=(this[t]&1<<e%this.DB)}setBit(e){return this.changeBit(e,i.cO)}clearBit(e){return this.changeBit(e,i.$r)}flipBit(e){return this.changeBit(e,i.AR)}add(e){const t=u();return this.addTo(e,t),t}subtract(e){const t=u();return this.subTo(e,t),t}multiply(e){const t=u();return this.multiplyTo(e,t),t}divide(e){const t=u();return this.divRemTo(e,t,null),t}remainder(e){const t=u();return this.divRemTo(e,null,t),t}divideAndRemainder(e){const t=u(),s=u();return this.divRemTo(e,t,s),[t,s]}modPow(e,t){let s,i,r=e.bitLength(),a=w(1);if(r<=0)return a;s=r<18?1:r<48?3:r<144?4:r<768?5:6,i=r<8?new h(t):t.isEven()?new l(t):new c(t);const o=[];let n=3;const d=s-1,p=(1<<s)-1;if(o[1]=i.convert(this),s>1){const e=u();for(i.sqrTo(o[1],e);n<=p;)o[n]=u(),i.mulTo(e,o[n-2],o[n]),n+=2}let f,m,g=e.t-1,v=!0,y=u();for(r=b(e[g])-1;g>=0;){for(r>=d?f=e[g]>>r-d&p:(f=(e[g]&(1<<r+1)-1)<<d-r,g>0&&(f|=e[g-1]>>this.DB+r-d)),n=s;0==(1&f);)f>>=1,--n;if((r-=n)<0&&(r+=this.DB,--g),v)o[f].copyTo(a),v=!1;else{for(;n>1;)i.sqrTo(a,y),i.sqrTo(y,a),n-=2;n>0?i.sqrTo(a,y):(m=a,a=y,y=m),i.mulTo(y,o[f],a)}for(;g>=0&&0==(e[g]&1<<r);)i.sqrTo(a,y),m=a,a=y,y=m,--r<0&&(r=this.DB-1,--g)}return i.revert(a)}modInverse(e){const t=e.isEven();if(this.isEven()&&t||0==e.signum())return n.ZERO;const s=e.clone(),i=this.clone(),r=w(1),a=w(0),o=w(0),d=w(1);for(;0!=s.signum();){for(;s.isEven();)s.rShiftTo(1,s),t?(r.isEven()&&a.isEven()||(r.addTo(this,r),a.subTo(e,a)),r.rShiftTo(1,r)):a.isEven()||a.subTo(e,a),a.rShiftTo(1,a);for(;i.isEven();)i.rShiftTo(1,i),t?(o.isEven()&&d.isEven()||(o.addTo(this,o),d.subTo(e,d)),o.rShiftTo(1,o)):d.isEven()||d.subTo(e,d),d.rShiftTo(1,d);s.compareTo(i)>=0?(s.subTo(i,s),t&&r.subTo(o,r),a.subTo(d,a)):(i.subTo(s,i),t&&o.subTo(r,o),d.subTo(a,d))}return 0!=i.compareTo(n.ONE)?n.ZERO:d.compareTo(e)>=0?d.subtract(e):d.signum()<0?(d.addTo(e,d),d.signum()<0?d.add(e):d):d}pow(e){return this.exp(e,new d)}gcd(e){let t=this.s<0?this.negate():this.clone(),s=e.s<0?e.negate():e.clone();if(t.compareTo(s)<0){const e=t;t=s,s=e}let i=t.getLowestSetBit(),r=s.getLowestSetBit();if(r<0)return t;for(i<r&&(r=i),r>0&&(t.rShiftTo(r,t),s.rShiftTo(r,s));t.signum()>0;)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=s.getLowestSetBit())>0&&s.rShiftTo(i,s),t.compareTo(s)>=0?(t.subTo(s,t),t.rShiftTo(1,t)):(s.subTo(t,s),s.rShiftTo(1,s));return r>0&&s.lShiftTo(r,s),s}isProbablePrime(e){let t;const s=this.abs();if(1==s.t&&s[0]<=a[a.length-1]){for(t=0;t<a.length;++t)if(s[0]==a[t])return!0;return!1}if(s.isEven())return!1;for(t=1;t<a.length;){let e=a[t],i=t+1;for(;i<a.length&&e<o;)e*=a[i++];for(e=s.modInt(e);t<i;)if(e%a[t++]==0)return!1}return s.millerRabin(e)}copyTo(e){for(let t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s}fromInt(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+this.DV:this.t=0}fromString(e,t){let s;if(16==t)s=4;else if(8==t)s=3;else if(256==t)s=8;else if(2==t)s=1;else if(32==t)s=5;else{if(4!=t)return void this.fromRadix(e,t);s=2}this.t=0,this.s=0;let i=e.length,r=!1,a=0;for(;--i>=0;){const t=8==s?255&+e[i]:y(e,i);t<0?"-"==e.charAt(i)&&(r=!0):(r=!1,0==a?this[this.t++]=t:a+s>this.DB?(this[this.t-1]|=(t&(1<<this.DB-a)-1)<<a,this[this.t++]=t>>this.DB-a):this[this.t-1]|=t<<a,a+=s,a>=this.DB&&(a-=this.DB))}8==s&&0!=(128&+e[0])&&(this.s=-1,a>0&&(this[this.t-1]|=(1<<this.DB-a)-1<<a)),this.clamp(),r&&n.ZERO.subTo(this,this)}clamp(){const e=this.s&this.DM;for(;this.t>0&&this[this.t-1]==e;)--this.t}dlShiftTo(e,t){let s;for(s=this.t-1;s>=0;--s)t[s+e]=this[s];for(s=e-1;s>=0;--s)t[s]=0;t.t=this.t+e,t.s=this.s}drShiftTo(e,t){for(let s=e;s<this.t;++s)t[s-e]=this[s];t.t=Math.max(this.t-e,0),t.s=this.s}lShiftTo(e,t){const s=e%this.DB,i=this.DB-s,r=(1<<i)-1,a=Math.floor(e/this.DB);let o=this.s<<s&this.DM;for(let e=this.t-1;e>=0;--e)t[e+a+1]=this[e]>>i|o,o=(this[e]&r)<<s;for(let e=a-1;e>=0;--e)t[e]=0;t[a]=o,t.t=this.t+a+1,t.s=this.s,t.clamp()}rShiftTo(e,t){t.s=this.s;const s=Math.floor(e/this.DB);if(s>=this.t)return void(t.t=0);const i=e%this.DB,r=this.DB-i,a=(1<<i)-1;t[0]=this[s]>>i;for(let e=s+1;e<this.t;++e)t[e-s-1]|=(this[e]&a)<<r,t[e-s]=this[e]>>i;i>0&&(t[this.t-s-1]|=(this.s&a)<<r),t.t=this.t-s,t.clamp()}subTo(e,t){let s=0,i=0;const r=Math.min(e.t,this.t);for(;s<r;)i+=this[s]-e[s],t[s++]=i&this.DM,i>>=this.DB;if(e.t<this.t){for(i-=e.s;s<this.t;)i+=this[s],t[s++]=i&this.DM,i>>=this.DB;i+=this.s}else{for(i+=this.s;s<e.t;)i-=e[s],t[s++]=i&this.DM,i>>=this.DB;i-=e.s}t.s=i<0?-1:0,i<-1?t[s++]=this.DV+i:i>0&&(t[s++]=i),t.t=s,t.clamp()}multiplyTo(e,t){const s=this.abs(),i=e.abs();let r=s.t;for(t.t=r+i.t;--r>=0;)t[r]=0;for(r=0;r<i.t;++r)t[r+s.t]=s.am(0,i[r],t,r,0,s.t);t.s=0,t.clamp(),this.s!=e.s&&n.ZERO.subTo(t,t)}squareTo(e){const t=this.abs();let s=e.t=2*t.t;for(;--s>=0;)e[s]=0;for(s=0;s<t.t-1;++s){const i=t.am(s,t[s],e,2*s,0,1);(e[s+t.t]+=t.am(s+1,2*t[s],e,2*s+1,i,t.t-s-1))>=t.DV&&(e[s+t.t]-=t.DV,e[s+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(s,t[s],e,2*s,0,1)),e.s=0,e.clamp()}divRemTo(e,t,s){const i=e.abs();if(i.t<=0)return;const r=this.abs();if(r.t<i.t)return null!=t&&t.fromInt(0),void(null!=s&&this.copyTo(s));null==s&&(s=u());const a=u(),o=this.s,d=e.s,h=this.DB-b(i[i.t-1]);h>0?(i.lShiftTo(h,a),r.lShiftTo(h,s)):(i.copyTo(a),r.copyTo(s));const c=a.t,l=a[c-1];if(0==l)return;const p=l*(1<<this.F1)+(c>1?a[c-2]>>this.F2:0),f=this.FV/p,m=(1<<this.F1)/p,g=1<<this.F2;let v=s.t,y=v-c;const w=null==t?u():t;for(a.dlShiftTo(y,w),s.compareTo(w)>=0&&(s[s.t++]=1,s.subTo(w,s)),n.ONE.dlShiftTo(c,w),w.subTo(a,a);a.t<c;)a[a.t++]=0;for(;--y>=0;){let e=s[--v]==l?this.DM:Math.floor(s[v]*f+(s[v-1]+g)*m);if((s[v]+=a.am(0,e,s,y,0,c))<e)for(a.dlShiftTo(y,w),s.subTo(w,s);s[v]<--e;)s.subTo(w,s)}null!=t&&(s.drShiftTo(c,t),o!=d&&n.ZERO.subTo(t,t)),s.t=c,s.clamp(),h>0&&s.rShiftTo(h,s),o<0&&n.ZERO.subTo(s,s)}invDigit(){if(this.t<1)return 0;const e=this[0];if(0==(1&e))return 0;let t=3&e;return t=t*(2-(15&e)*t)&15,t=t*(2-(255&e)*t)&255,t=t*(2-((65535&e)*t&65535))&65535,t=t*(2-e*t%this.DV)%this.DV,t>0?this.DV-t:-t}isEven(){return 0==(this.t>0?1&this[0]:this.s)}exp(e,t){if(e>4294967295||e<1)return n.ONE;let s=u(),i=u();const r=t.convert(this);let a=b(e)-1;for(r.copyTo(s);--a>=0;)if(t.sqrTo(s,i),(e&1<<a)>0)t.mulTo(i,r,s);else{const e=s;s=i,i=e}return t.revert(s)}chunkSize(e){return Math.floor(Math.LN2*this.DB/Math.log(e))}toRadix(e){if(null==e&&(e=10),0==this.signum()||e<2||e>36)return"0";const t=this.chunkSize(e),s=Math.pow(e,t),i=w(s),r=u(),a=u();let o="";for(this.divRemTo(i,r,a);r.signum()>0;)o=(s+a.intValue()).toString(e).substr(1)+o,r.divRemTo(i,r,a);return a.intValue().toString(e)+o}fromRadix(e,t){this.fromInt(0),null==t&&(t=10);const s=this.chunkSize(t),i=Math.pow(t,s);let r=!1,a=0,o=0;for(let n=0;n<e.length;++n){const d=y(e,n);d<0?"-"==e.charAt(n)&&0==this.signum()&&(r=!0):(o=t*o+d,++a>=s&&(this.dMultiply(i),this.dAddOffset(o,0),a=0,o=0))}a>0&&(this.dMultiply(Math.pow(t,a)),this.dAddOffset(o,0)),r&&n.ZERO.subTo(this,this)}fromNumber(e,t,s){if("number"==typeof t)if(e<2)this.fromInt(1);else for(this.fromNumber(e,s),this.testBit(e-1)||this.bitwiseTo(n.ONE.shiftLeft(e-1),i.cO,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(t);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(n.ONE.shiftLeft(e-1),this);else{const s=[],i=7&e;s.length=1+(e>>3),t.nextBytes(s),i>0?s[0]&=(1<<i)-1:s[0]=0,this.fromString(s,256)}}bitwiseTo(e,t,s){let i,r;const a=Math.min(e.t,this.t);for(i=0;i<a;++i)s[i]=t(this[i],e[i]);if(e.t<this.t){for(r=e.s&this.DM,i=a;i<this.t;++i)s[i]=t(this[i],r);s.t=this.t}else{for(r=this.s&this.DM,i=a;i<e.t;++i)s[i]=t(r,e[i]);s.t=e.t}s.s=t(this.s,e.s),s.clamp()}changeBit(e,t){const s=n.ONE.shiftLeft(e);return this.bitwiseTo(s,t,s),s}addTo(e,t){let s=0,i=0;const r=Math.min(e.t,this.t);for(;s<r;)i+=this[s]+e[s],t[s++]=i&this.DM,i>>=this.DB;if(e.t<this.t){for(i+=e.s;s<this.t;)i+=this[s],t[s++]=i&this.DM,i>>=this.DB;i+=this.s}else{for(i+=this.s;s<e.t;)i+=e[s],t[s++]=i&this.DM,i>>=this.DB;i+=e.s}t.s=i<0?-1:0,i>0?t[s++]=i:i<-1&&(t[s++]=this.DV+i),t.t=s,t.clamp()}dMultiply(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()}dAddOffset(e,t){if(0!=e){for(;this.t<=t;)this[this.t++]=0;for(this[t]+=e;this[t]>=this.DV;)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}}multiplyLowerTo(e,t,s){let i=Math.min(this.t+e.t,t);for(s.s=0,s.t=i;i>0;)s[--i]=0;for(const t=s.t-this.t;i<t;++i)s[i+this.t]=this.am(0,e[i],s,i,0,this.t);for(const r=Math.min(e.t,t);i<r;++i)this.am(0,e[i],s,i,0,t-i);s.clamp()}multiplyUpperTo(e,t,s){--t;let i=s.t=this.t+e.t-t;for(s.s=0;--i>=0;)s[i]=0;for(i=Math.max(t-this.t,0);i<e.t;++i)s[this.t+i-t]=this.am(t-i,e[i],s,0,0,this.t+i-t);s.clamp(),s.drShiftTo(1,s)}modInt(e){if(e<=0)return 0;const t=this.DV%e;let s=this.s<0?e-1:0;if(this.t>0)if(0==t)s=this[0]%e;else for(let i=this.t-1;i>=0;--i)s=(t*s+this[i])%e;return s}millerRabin(e){const t=this.subtract(n.ONE),s=t.getLowestSetBit();if(s<=0)return!1;const i=t.shiftRight(s);(e=e+1>>1)>a.length&&(e=a.length);const r=u();for(let o=0;o<e;++o){r.fromInt(a[Math.floor(Math.random()*a.length)]);let e=r.modPow(i,this);if(0!=e.compareTo(n.ONE)&&0!=e.compareTo(t)){let i=1;for(;i++<s&&0!=e.compareTo(t);)if(e=e.modPowInt(2,this),0==e.compareTo(n.ONE))return!1;if(0!=e.compareTo(t))return!1}}return!0}square(){const e=u();return this.squareTo(e),e}gcda(e,t){let s=this.s<0?this.negate():this.clone(),i=e.s<0?e.negate():e.clone();if(s.compareTo(i)<0){const e=s;s=i,i=e}let r=s.getLowestSetBit(),a=i.getLowestSetBit();if(a<0)return void t(s);r<a&&(a=r),a>0&&(s.rShiftTo(a,s),i.rShiftTo(a,i));const o=function(){(r=s.getLowestSetBit())>0&&s.rShiftTo(r,s),(r=i.getLowestSetBit())>0&&i.rShiftTo(r,i),s.compareTo(i)>=0?(s.subTo(i,s),s.rShiftTo(1,s)):(i.subTo(s,i),i.rShiftTo(1,i)),s.signum()>0?setTimeout(o,0):(a>0&&i.lShiftTo(a,i),setTimeout((function(){t(i)}),0))};setTimeout(o,10)}fromNumberAsync(e,t,s,r){if("number"==typeof t)if(e<2)this.fromInt(1);else{this.fromNumber(e,s),this.testBit(e-1)||this.bitwiseTo(n.ONE.shiftLeft(e-1),i.cO,this),this.isEven()&&this.dAddOffset(1,0);const a=this,o=function(){a.dAddOffset(2,0),a.bitLength()>e&&a.subTo(n.ONE.shiftLeft(e-1),a),a.isProbablePrime(t)?setTimeout((function(){r()}),0):setTimeout(o,0)};setTimeout(o,0)}else{const s=[],i=7&e;s.length=1+(e>>3),t.nextBytes(s),i>0?s[0]&=(1<<i)-1:s[0]=0,this.fromString(s,256)}}}class d{constructor(){}convert(e){return e}revert(e){return e}mulTo(e,t,s){e.multiplyTo(t,s)}sqrTo(e,t){e.squareTo(t)}}class h{constructor(e){this.m=e}convert(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e}revert(e){return e}reduce(e){e.divRemTo(this.m,null,e)}mulTo(e,t,s){e.multiplyTo(t,s),this.reduce(s)}sqrTo(e,t){e.squareTo(t),this.reduce(t)}}class c{constructor(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}convert(e){const t=u();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(n.ZERO)>0&&this.m.subTo(t,t),t}revert(e){const t=u();return e.copyTo(t),this.reduce(t),t}reduce(e){for(;e.t<=this.mt2;)e[e.t++]=0;for(let t=0;t<this.m.t;++t){let s=32767&e[t];const i=s*this.mpl+((s*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(s=t+this.m.t,e[s]+=this.m.am(0,i,e,t,0,this.m.t);e[s]>=e.DV;)e[s]-=e.DV,e[++s]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)}mulTo(e,t,s){e.multiplyTo(t,s),this.reduce(s)}sqrTo(e,t){e.squareTo(t),this.reduce(t)}}class l{constructor(e){this.m=e,this.r2=u(),this.q3=u(),n.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e)}convert(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;{const t=u();return e.copyTo(t),this.reduce(t),t}}revert(e){return e}reduce(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)}mulTo(e,t,s){e.multiplyTo(t,s),this.reduce(s)}sqrTo(e,t){e.squareTo(t),this.reduce(t)}}function u(){return new n(null)}function p(e,t){return new n(e,t)}const f="undefined"!=typeof navigator;f&&"Microsoft Internet Explorer"==navigator.appName?(n.prototype.am=function(e,t,s,i,r,a){const o=32767&t,n=t>>15;for(;--a>=0;){let t=32767&this[e];const a=this[e++]>>15,d=n*t+a*o;t=o*t+((32767&d)<<15)+s[i]+(1073741823&r),r=(t>>>30)+(d>>>15)+n*a+(r>>>30),s[i++]=1073741823&t}return r},r=30):f&&"Netscape"!=navigator.appName?(n.prototype.am=function(e,t,s,i,r,a){for(;--a>=0;){const a=t*this[e++]+s[i]+r;r=Math.floor(a/67108864),s[i++]=67108863&a}return r},r=26):(n.prototype.am=function(e,t,s,i,r,a){const o=16383&t,n=t>>14;for(;--a>=0;){let t=16383&this[e];const a=this[e++]>>14,d=n*t+a*o;t=o*t+((16383&d)<<14)+s[i]+r,r=(t>>28)+(d>>14)+n*a,s[i++]=268435455&t}return r},r=28),n.prototype.DB=r,n.prototype.DM=(1<<r)-1,n.prototype.DV=1<<r;n.prototype.FV=Math.pow(2,52),n.prototype.F1=52-r,n.prototype.F2=2*r-52;const m=[];let g,v;for(g="0".charCodeAt(0),v=0;v<=9;++v)m[g++]=v;for(g="a".charCodeAt(0),v=10;v<36;++v)m[g++]=v;for(g="A".charCodeAt(0),v=10;v<36;++v)m[g++]=v;function y(e,t){const s=m[e.charCodeAt(t)];return null==s?-1:s}function w(e){const t=u();return t.fromInt(e),t}function b(e){let t,s=1;return 0!=(t=e>>>16)&&(e=t,s+=16),0!=(t=e>>8)&&(e=t,s+=8),0!=(t=e>>4)&&(e=t,s+=4),0!=(t=e>>2)&&(e=t,s+=2),0!=(t=e>>1)&&(e=t,s+=1),s}n.ZERO=w(0),n.ONE=w(1)},9898:(e,t,s)=>{s.d(t,{YS:()=>r,me:()=>a});class i{constructor(){this.i=0,this.j=0,this.S=[]}init(e){let t,s,i;for(t=0;t<256;++t)this.S[t]=t;for(s=0,t=0;t<256;++t)s=s+this.S[t]+e[t%e.length]&255,i=this.S[t],this.S[t]=this.S[s],this.S[s]=i;this.i=0,this.j=0}next(){let e;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,e=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=e,this.S[e+this.S[this.i]&255]}}function r(){return new i}let a=256},447:(e,t,s)=>{s.d(t,{D:()=>h});var i=s(9898);let r,a,o=null;if(null==o){let e;if(o=[],a=0,"undefined"!=typeof window&&window.crypto&&window.crypto.getRandomValues){const t=new Uint32Array(256);for(window.crypto.getRandomValues(t),e=0;e<t.length;++e)o[a++]=255&t[e]}var n=0;const t=function(e){if((n=n||0)>=256||a>=i.me)window.removeEventListener?window.removeEventListener("mousemove",t,!1):window.detachEvent&&window.detachEvent("onmousemove",t);else try{const t=e.x+e.y;o[a++]=255&t,n+=1}catch(e){}};"undefined"!=typeof window&&(window.addEventListener?window.addEventListener("mousemove",t,!1):window.attachEvent&&window.attachEvent("onmousemove",t))}function d(){if(null==r){for(r=(0,i.YS)();a<i.me;){const e=Math.floor(65536*Math.random());o[a++]=255&e}for(r.init(o),a=0;a<o.length;++a)o[a]=0;a=0}return r.next()}class h{nextBytes(e){for(let t=0;t<e.length;++t)e[t]=d()}}},9476:(e,t,s)=>{s.d(t,{s:()=>a});var i=s(1279),r=s(447);class a{constructor(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}doPublic(e){return e.modPowInt(this.e,this.n)}doPrivate(e){if(null==this.p||null==this.q)return e.modPow(this.d,this.n);let t=e.mod(this.p).modPow(this.dmp1,this.p);const s=e.mod(this.q).modPow(this.dmq1,this.q);for(;t.compareTo(s)<0;)t=t.add(this.p);return t.subtract(s).multiply(this.coeff).mod(this.p).multiply(this.q).add(s)}setPublic(e,t){null!=e&&null!=t&&e.length>0&&t.length>0?(this.n=(0,i.Bv)(e,16),this.e=parseInt(t,16)):console.error("Invalid RSA public key")}encrypt(e){const t=this.n.bitLength()+7>>3,s=function(e,t){if(t<e.length+11)return console.error("Message too long for RSA"),null;const s=[];let a=e.length-1;for(;a>=0&&t>0;){const i=e.charCodeAt(a--);i<128?s[--t]=i:i>127&&i<2048?(s[--t]=63&i|128,s[--t]=i>>6|192):(s[--t]=63&i|128,s[--t]=i>>6&63|128,s[--t]=i>>12|224)}s[--t]=0;const o=new r.D,n=[];for(;t>2;){for(n[0]=0;0==n[0];)o.nextBytes(n);s[--t]=n[0]}return s[--t]=2,s[--t]=0,new i.jZ(s)}(e,t);if(null==s)return null;const a=this.doPublic(s);if(null==a)return null;let o=a.toString(16),n=o.length;for(let e=0;e<2*t-n;e++)o="0"+o;return o}setPrivate(e,t,s){null!=e&&null!=t&&e.length>0&&t.length>0?(this.n=(0,i.Bv)(e,16),this.e=parseInt(t,16),this.d=(0,i.Bv)(s,16)):console.error("Invalid RSA private key")}setPrivateEx(e,t,s,r,a,o,n,d){null!=e&&null!=t&&e.length>0&&t.length>0?(this.n=(0,i.Bv)(e,16),this.e=parseInt(t,16),this.d=(0,i.Bv)(s,16),this.p=(0,i.Bv)(r,16),this.q=(0,i.Bv)(a,16),this.dmp1=(0,i.Bv)(o,16),this.dmq1=(0,i.Bv)(n,16),this.coeff=(0,i.Bv)(d,16)):console.error("Invalid RSA private key")}generate(e,t){const s=new r.D,a=e>>1;this.e=parseInt(t,16);const o=new i.jZ(t,16);for(;;){for(;this.p=new i.jZ(e-a,1,s),0!=this.p.subtract(i.jZ.ONE).gcd(o).compareTo(i.jZ.ONE)||!this.p.isProbablePrime(10););for(;this.q=new i.jZ(a,1,s),0!=this.q.subtract(i.jZ.ONE).gcd(o).compareTo(i.jZ.ONE)||!this.q.isProbablePrime(10););if(this.p.compareTo(this.q)<=0){const e=this.p;this.p=this.q,this.q=e}const t=this.p.subtract(i.jZ.ONE),r=this.q.subtract(i.jZ.ONE),n=t.multiply(r);if(0==n.gcd(o).compareTo(i.jZ.ONE)){this.n=this.p.multiply(this.q),this.d=o.modInverse(n),this.dmp1=this.d.mod(t),this.dmq1=this.d.mod(r),this.coeff=this.q.modInverse(this.p);break}}}decrypt(e){const t=(0,i.Bv)(e,16),s=this.doPrivate(t);return null==s?null:function(e,t){const s=e.toByteArray();let i=0;for(;i<s.length&&0==s[i];)++i;if(s.length-i!=t-1||2!=s[i])return null;++i;for(;0!=s[i];)if(++i>=s.length)return null;let r="";for(;++i<s.length;){const e=255&s[i];e<128?r+=String.fromCharCode(e):e>191&&e<224?(r+=String.fromCharCode((31&e)<<6|63&s[i+1]),++i):(r+=String.fromCharCode((15&e)<<12|(63&s[i+1])<<6|63&s[i+2]),i+=2)}return r}(s,this.n.bitLength()+7>>3)}generateAsync(e,t,s){const a=new r.D,o=e>>1;this.e=parseInt(t,16);const n=new i.jZ(t,16),d=this,h=function(){const t=function(){if(d.p.compareTo(d.q)<=0){const e=d.p;d.p=d.q,d.q=e}const e=d.p.subtract(i.jZ.ONE),t=d.q.subtract(i.jZ.ONE),r=e.multiply(t);0==r.gcd(n).compareTo(i.jZ.ONE)?(d.n=d.p.multiply(d.q),d.d=n.modInverse(r),d.dmp1=d.d.mod(e),d.dmq1=d.d.mod(t),d.coeff=d.q.modInverse(d.p),setTimeout((function(){s()}),0)):setTimeout(h,0)},r=function(){d.q=(0,i.EB)(),d.q.fromNumberAsync(o,1,a,(function(){d.q.subtract(i.jZ.ONE).gcda(n,(function(e){0==e.compareTo(i.jZ.ONE)&&d.q.isProbablePrime(10)?setTimeout(t,0):setTimeout(r,0)}))}))},c=function(){d.p=(0,i.EB)(),d.p.fromNumberAsync(e-o,1,a,(function(){d.p.subtract(i.jZ.ONE).gcda(n,(function(e){0==e.compareTo(i.jZ.ONE)&&d.p.isProbablePrime(10)?setTimeout(r,0):setTimeout(c,0)}))}))};setTimeout(c,0)};setTimeout(h,0)}sign(e,t,s){const r=function(e,t){if(t<e.length+22)return console.error("Message too long for RSA"),null;const s=t-e.length-6;let r="";for(let e=0;e<s;e+=2)r+="ff";const a="0001"+r+"00"+e;return(0,i.Bv)(a,16)}((o[s]||"")+t(e).toString(),this.n.bitLength()/4);if(null==r)return null;const a=this.doPrivate(r);if(null==a)return null;const n=a.toString(16);return 0==(1&n.length)?n:"0"+n}verify(e,t,s){const r=(0,i.Bv)(t,16),a=this.doPublic(r);if(null==a)return null;return function(e){for(const t in o)if(o.hasOwnProperty(t)){const s=o[t],i=s.length;if(e.substr(0,i)==s)return e.substr(i)}return e}(a.toString(16).replace(/^1f+00/,""))==s(e).toString()}}const o={md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",ripemd160:"3021300906052b2403020105000414"}},2628:(e,t,s)=>{s.d(t,{$r:()=>d,AR:()=>n,Ir:()=>a,OF:()=>h,W4:()=>r,XP:()=>c,cO:()=>o});const i="0123456789abcdefghijklmnopqrstuvwxyz";function r(e){return i.charAt(e)}function a(e,t){return e&t}function o(e,t){return e|t}function n(e,t){return e^t}function d(e,t){return e&~t}function h(e){if(0==e)return-1;let t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function c(e){let t=0;for(;0!=e;)e&=e-1,++t;return t}},7196:(e,t,s)=>{s.d(t,{p:()=>a});var i=s(1279),r=s(6378),a={};void 0!==a.asn1&&a.asn1||(a.asn1={}),a.asn1.ASN1Util=new function(){this.integerToByteHex=function(e){var t=e.toString(16);return t.length%2==1&&(t="0"+t),t},this.bigIntToMinTwosComplementsHex=function(e){var t=e.toString(16);if("-"!=t.substr(0,1))t.length%2==1?t="0"+t:t.match(/^[0-7]/)||(t="00"+t);else{var s=t.substr(1).length;s%2==1?s+=1:t.match(/^[0-7]/)||(s+=2);for(var r="",a=0;a<s;a++)r+="f";t=new i.jZ(r,16).xor(e).add(i.jZ.ONE).toString(16).replace(/^-/,"")}return t},this.getPEMStringFromHex=function(e,t){return hextopem(e,t)},this.newObject=function(e){var t=a.asn1,s=t.DERBoolean,i=t.DERInteger,r=t.DERBitString,o=t.DEROctetString,n=t.DERNull,d=t.DERObjectIdentifier,h=t.DEREnumerated,c=t.DERUTF8String,l=t.DERNumericString,u=t.DERPrintableString,p=t.DERTeletexString,f=t.DERIA5String,m=t.DERUTCTime,g=t.DERGeneralizedTime,v=t.DERSequence,y=t.DERSet,w=t.DERTaggedObject,b=t.ASN1Util.newObject,S=Object.keys(e);if(1!=S.length)throw"key of param shall be only one.";var k=S[0];if(-1==":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+k+":"))throw"undefined key: "+k;if("bool"==k)return new s(e[k]);if("int"==k)return new i(e[k]);if("bitstr"==k)return new r(e[k]);if("octstr"==k)return new o(e[k]);if("null"==k)return new n(e[k]);if("oid"==k)return new d(e[k]);if("enum"==k)return new h(e[k]);if("utf8str"==k)return new c(e[k]);if("numstr"==k)return new l(e[k]);if("prnstr"==k)return new u(e[k]);if("telstr"==k)return new p(e[k]);if("ia5str"==k)return new f(e[k]);if("utctime"==k)return new m(e[k]);if("gentime"==k)return new g(e[k]);if("seq"==k){for(var O=e[k],T=[],P=0;P<O.length;P++){var I=b(O[P]);T.push(I)}return new v({array:T})}if("set"==k){for(O=e[k],T=[],P=0;P<O.length;P++){I=b(O[P]);T.push(I)}return new y({array:T})}if("tag"==k){var x=e[k];if("[object Array]"===Object.prototype.toString.call(x)&&3==x.length){var A=b(x[2]);return new w({tag:x[0],explicit:x[1],obj:A})}var M={};if(void 0!==x.explicit&&(M.explicit=x.explicit),void 0!==x.tag&&(M.tag=x.tag),void 0===x.obj)throw"obj shall be specified for 'tag'.";return M.obj=b(x.obj),new w(M)}},this.jsonToASN1HEX=function(e){return this.newObject(e).getEncodedHex()}},a.asn1.ASN1Util.oidHexToInt=function(e){for(var t="",s=parseInt(e.substr(0,2),16),r=(t=Math.floor(s/40)+"."+s%40,""),a=2;a<e.length;a+=2){var o=("00000000"+parseInt(e.substr(a,2),16).toString(2)).slice(-8);if(r+=o.substr(1,7),"0"==o.substr(0,1))t=t+"."+new i.jZ(r,2).toString(10),r=""}return t},a.asn1.ASN1Util.oidIntToHex=function(e){var t=function(e){var t=e.toString(16);return 1==t.length&&(t="0"+t),t},s=function(e){var s="",r=new i.jZ(e,10).toString(2),a=7-r.length%7;7==a&&(a=0);for(var o="",n=0;n<a;n++)o+="0";r=o+r;for(n=0;n<r.length-1;n+=7){var d=r.substr(n,7);n!=r.length-7&&(d="1"+d),s+=t(parseInt(d,2))}return s};if(!e.match(/^[0-9.]+$/))throw"malformed oid string: "+e;var r="",a=e.split("."),o=40*parseInt(a[0])+parseInt(a[1]);r+=t(o),a.splice(0,2);for(var n=0;n<a.length;n++)r+=s(a[n]);return r},a.asn1.ASN1Object=function(){this.getLengthHexFromValue=function(){if(void 0===this.hV||null==this.hV)throw"this.hV is null or undefined.";if(this.hV.length%2==1)throw"value hex must be even length: n=0,v="+this.hV;var e=this.hV.length/2,t=e.toString(16);if(t.length%2==1&&(t="0"+t),e<128)return t;var s=t.length/2;if(s>15)throw"ASN.1 length too long to represent by 8x: n = "+e.toString(16);return(128+s).toString(16)+t},this.getEncodedHex=function(){return(null==this.hTLV||this.isModified)&&(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV},this.getValueHex=function(){return this.getEncodedHex(),this.hV},this.getFreshValueHex=function(){return""}},a.asn1.DERAbstractString=function(e){a.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=stohex(this.s)},this.setStringHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e?this.setString(e):void 0!==e.str?this.setString(e.str):void 0!==e.hex&&this.setStringHex(e.hex))},r.b.lang.extend(a.asn1.DERAbstractString,a.asn1.ASN1Object),a.asn1.DERAbstractTime=function(e){a.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(e){return utc=e.getTime()+6e4*e.getTimezoneOffset(),new Date(utc)},this.formatDate=function(e,t,s){var i=this.zeroPadding,r=this.localDateToUTC(e),a=String(r.getFullYear());"utc"==t&&(a=a.substr(2,2));var o=a+i(String(r.getMonth()+1),2)+i(String(r.getDate()),2)+i(String(r.getHours()),2)+i(String(r.getMinutes()),2)+i(String(r.getSeconds()),2);if(!0===s){var n=r.getMilliseconds();if(0!=n){var d=i(String(n),3);o=o+"."+(d=d.replace(/[0]+$/,""))}}return o+"Z"},this.zeroPadding=function(e,t){return e.length>=t?e:new Array(t-e.length+1).join("0")+e},this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=stohex(e)},this.setByDateValue=function(e,t,s,i,r,a){var o=new Date(Date.UTC(e,t-1,s,i,r,a,0));this.setByDate(o)},this.getFreshValueHex=function(){return this.hV}},r.b.lang.extend(a.asn1.DERAbstractTime,a.asn1.ASN1Object),a.asn1.DERAbstractStructured=function(e){a.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array=e},this.appendASN1Object=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array.push(e)},this.asn1Array=new Array,void 0!==e&&void 0!==e.array&&(this.asn1Array=e.array)},r.b.lang.extend(a.asn1.DERAbstractStructured,a.asn1.ASN1Object),a.asn1.DERBoolean=function(){a.asn1.DERBoolean.superclass.constructor.call(this),this.hT="01",this.hTLV="0101ff"},r.b.lang.extend(a.asn1.DERBoolean,a.asn1.ASN1Object),a.asn1.DERInteger=function(e){a.asn1.DERInteger.superclass.constructor.call(this),this.hT="02",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=a.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new i.jZ(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.bigint?this.setByBigInteger(e.bigint):void 0!==e.int?this.setByInteger(e.int):"number"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},r.b.lang.extend(a.asn1.DERInteger,a.asn1.ASN1Object),a.asn1.DERBitString=function(e){if(void 0!==e&&void 0!==e.obj){var t=a.asn1.ASN1Util.newObject(e.obj);e.hex="00"+t.getEncodedHex()}a.asn1.DERBitString.superclass.constructor.call(this),this.hT="03",this.setHexValueIncludingUnusedBits=function(e){this.hTLV=null,this.isModified=!0,this.hV=e},this.setUnusedBitsAndHexValue=function(e,t){if(e<0||7<e)throw"unused bits shall be from 0 to 7: u = "+e;var s="0"+e;this.hTLV=null,this.isModified=!0,this.hV=s+t},this.setByBinaryString=function(e){var t=8-(e=e.replace(/0+$/,"")).length%8;8==t&&(t=0);for(var s=0;s<=t;s++)e+="0";var i="";for(s=0;s<e.length-1;s+=8){var r=e.substr(s,8),a=parseInt(r,2).toString(16);1==a.length&&(a="0"+a),i+=a}this.hTLV=null,this.isModified=!0,this.hV="0"+t+i},this.setByBooleanArray=function(e){for(var t="",s=0;s<e.length;s++)1==e[s]?t+="1":t+="0";this.setByBinaryString(t)},this.newFalseArray=function(e){for(var t=new Array(e),s=0;s<e;s++)t[s]=!1;return t},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e&&e.toLowerCase().match(/^[0-9a-f]+$/)?this.setHexValueIncludingUnusedBits(e):void 0!==e.hex?this.setHexValueIncludingUnusedBits(e.hex):void 0!==e.bin?this.setByBinaryString(e.bin):void 0!==e.array&&this.setByBooleanArray(e.array))},r.b.lang.extend(a.asn1.DERBitString,a.asn1.ASN1Object),a.asn1.DEROctetString=function(e){if(void 0!==e&&void 0!==e.obj){var t=a.asn1.ASN1Util.newObject(e.obj);e.hex=t.getEncodedHex()}a.asn1.DEROctetString.superclass.constructor.call(this,e),this.hT="04"},r.b.lang.extend(a.asn1.DEROctetString,a.asn1.DERAbstractString),a.asn1.DERNull=function(){a.asn1.DERNull.superclass.constructor.call(this),this.hT="05",this.hTLV="0500"},r.b.lang.extend(a.asn1.DERNull,a.asn1.ASN1Object),a.asn1.DERObjectIdentifier=function(e){var t=function(e){var t=e.toString(16);return 1==t.length&&(t="0"+t),t},s=function(e){var s="",r=new i.jZ(e,10).toString(2),a=7-r.length%7;7==a&&(a=0);for(var o="",n=0;n<a;n++)o+="0";r=o+r;for(n=0;n<r.length-1;n+=7){var d=r.substr(n,7);n!=r.length-7&&(d="1"+d),s+=t(parseInt(d,2))}return s};a.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT="06",this.setValueHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.setValueOidString=function(e){if(!e.match(/^[0-9.]+$/))throw"malformed oid string: "+e;var i="",r=e.split("."),a=40*parseInt(r[0])+parseInt(r[1]);i+=t(a),r.splice(0,2);for(var o=0;o<r.length;o++)i+=s(r[o]);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=i},this.setValueName=function(e){var t=a.asn1.x509.OID.name2oid(e);if(""===t)throw"DERObjectIdentifier oidName undefined: "+e;this.setValueOidString(t)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e?e.match(/^[0-2].[0-9.]+$/)?this.setValueOidString(e):this.setValueName(e):void 0!==e.oid?this.setValueOidString(e.oid):void 0!==e.hex?this.setValueHex(e.hex):void 0!==e.name&&this.setValueName(e.name))},r.b.lang.extend(a.asn1.DERObjectIdentifier,a.asn1.ASN1Object),a.asn1.DEREnumerated=function(e){a.asn1.DEREnumerated.superclass.constructor.call(this),this.hT="0a",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=a.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new i.jZ(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.int?this.setByInteger(e.int):"number"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},r.b.lang.extend(a.asn1.DEREnumerated,a.asn1.ASN1Object),a.asn1.DERUTF8String=function(e){a.asn1.DERUTF8String.superclass.constructor.call(this,e),this.hT="0c"},r.b.lang.extend(a.asn1.DERUTF8String,a.asn1.DERAbstractString),a.asn1.DERNumericString=function(e){a.asn1.DERNumericString.superclass.constructor.call(this,e),this.hT="12"},r.b.lang.extend(a.asn1.DERNumericString,a.asn1.DERAbstractString),a.asn1.DERPrintableString=function(e){a.asn1.DERPrintableString.superclass.constructor.call(this,e),this.hT="13"},r.b.lang.extend(a.asn1.DERPrintableString,a.asn1.DERAbstractString),a.asn1.DERTeletexString=function(e){a.asn1.DERTeletexString.superclass.constructor.call(this,e),this.hT="14"},r.b.lang.extend(a.asn1.DERTeletexString,a.asn1.DERAbstractString),a.asn1.DERIA5String=function(e){a.asn1.DERIA5String.superclass.constructor.call(this,e),this.hT="16"},r.b.lang.extend(a.asn1.DERIA5String,a.asn1.DERAbstractString),a.asn1.DERUTCTime=function(e){a.asn1.DERUTCTime.superclass.constructor.call(this,e),this.hT="17",this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):"string"==typeof e&&e.match(/^[0-9]{12}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date))},r.b.lang.extend(a.asn1.DERUTCTime,a.asn1.DERAbstractTime),a.asn1.DERGeneralizedTime=function(e){a.asn1.DERGeneralizedTime.superclass.constructor.call(this,e),this.hT="18",this.withMillis=!1,this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):"string"==typeof e&&e.match(/^[0-9]{14}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date),!0===e.millis&&(this.withMillis=!0))},r.b.lang.extend(a.asn1.DERGeneralizedTime,a.asn1.DERAbstractTime),a.asn1.DERSequence=function(e){a.asn1.DERSequence.superclass.constructor.call(this,e),this.hT="30",this.getFreshValueHex=function(){for(var e="",t=0;t<this.asn1Array.length;t++){e+=this.asn1Array[t].getEncodedHex()}return this.hV=e,this.hV}},r.b.lang.extend(a.asn1.DERSequence,a.asn1.DERAbstractStructured),a.asn1.DERSet=function(e){a.asn1.DERSet.superclass.constructor.call(this,e),this.hT="31",this.sortFlag=!0,this.getFreshValueHex=function(){for(var e=new Array,t=0;t<this.asn1Array.length;t++){var s=this.asn1Array[t];e.push(s.getEncodedHex())}return 1==this.sortFlag&&e.sort(),this.hV=e.join(""),this.hV},void 0!==e&&void 0!==e.sortflag&&0==e.sortflag&&(this.sortFlag=!1)},r.b.lang.extend(a.asn1.DERSet,a.asn1.DERAbstractStructured),a.asn1.DERTaggedObject=function(e){a.asn1.DERTaggedObject.superclass.constructor.call(this),this.hT="a0",this.hV="",this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(e,t,s){this.hT=t,this.isExplicit=e,this.asn1Object=s,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=s.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,t),this.isModified=!1)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.tag&&(this.hT=e.tag),void 0!==e.explicit&&(this.isExplicit=e.explicit),void 0!==e.obj&&(this.asn1Object=e.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)))},r.b.lang.extend(a.asn1.DERTaggedObject,a.asn1.ASN1Object)},1999:(e,t,s)=>{s.d(t,{Z:()=>o,s:()=>n});var i=s(712),r=s(1094),a=s(2442);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function o(e){return{hash:e,hmac:(t,...s)=>(0,i.w)(e,t,(0,r.Id)(...s)),randomBytes:r.po}}function n(e,t){const s=t=>(0,a.x3)({...e,...o(t)});return Object.freeze({...s(t),create:s})}},7517:(e,t,s)=>{s.d(t,{A:()=>n,h:()=>d});var i=s(1064),r=s(191);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const a=BigInt(0),o=BigInt(1);function n(e,t){const s=(e,t)=>{const s=t.negate();return e?s:t},i=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:s,unsafeLadder(t,s){let i=e.ZERO,r=t;for(;s>a;)s&o&&(i=i.add(r)),r=r.double(),s>>=o;return i},precomputeWindow(e,t){const{windows:s,windowSize:r}=i(t),a=[];let o=e,n=o;for(let e=0;e<s;e++){n=o,a.push(n);for(let e=1;e<r;e++)n=n.add(o),a.push(n);o=n.double()}return a},wNAF(t,r,a){const{windows:n,windowSize:d}=i(t);let h=e.ZERO,c=e.BASE;const l=BigInt(2**t-1),u=2**t,p=BigInt(t);for(let e=0;e<n;e++){const t=e*d;let i=Number(a&l);a>>=p,i>d&&(i-=u,a+=o);const n=t,f=t+Math.abs(i)-1,m=e%2!=0,g=i<0;0===i?c=c.add(s(m,r[n])):h=h.add(s(g,r[f]))}return{p:h,f:c}},wNAFCached(e,t,s,i){const r=e._WINDOW_SIZE||1;let a=t.get(e);return a||(a=this.precomputeWindow(e,r),1!==r&&t.set(e,i(a))),this.wNAF(r,a,s)}}}function d(e){return(0,i.jr)(e.Fp),(0,r.Q5)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,i.LH)(e.n,e.nBitLength),...e})}},4782:(e,t,s)=>{s.d(t,{n:()=>c});var i=s(1064),r=s(191),a=s(7517);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const o=BigInt(0),n=BigInt(1),d=BigInt(2),h=BigInt(8);function c(e){const t=function(e){const t=(0,a.h)(e);return r.Q5(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}(e),{Fp:s,n:c,preHash:l,hash:u,randomBytes:p,nByteLength:f,h:m}=t,g=d**BigInt(8*f),v=s.create,y=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:s.sqrt(e*s.inv(t))}}catch(e){return{isValid:!1,value:o}}}),w=t.adjustScalarBytes||(e=>e),b=t.domain||((e,t,s)=>{if(t.length||s)throw new Error("Contexts/pre-hash are not supported");return e}),S=e=>"bigint"==typeof e&&0n<e,k=(e,t)=>S(e)&&S(t)&&e<t,O=e=>e===o||k(e,g);function T(e,t){if(k(e,t))return e;throw new Error(`Expected valid scalar < ${t}, got ${typeof e} ${e}`)}function P(e){return e===o?e:T(e,c)}const I=new Map;function x(e){if(!(e instanceof A))throw new Error("ExtendedPoint expected")}class A{constructor(e,t,s,i){if(this.ex=e,this.ey=t,this.ez=s,this.et=i,!O(e))throw new Error("x required");if(!O(t))throw new Error("y required");if(!O(s))throw new Error("z required");if(!O(i))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof A)throw new Error("extended point not allowed");const{x:t,y:s}=e||{};if(!O(t)||!O(s))throw new Error("invalid affine point");return new A(t,s,n,v(t*s))}static normalizeZ(e){const t=s.invertBatch(e.map((e=>e.ez)));return e.map(((e,s)=>e.toAffine(t[s]))).map(A.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,I.delete(this)}assertValidity(){const{a:e,d:s}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:i,ey:r,ez:a,et:o}=this,n=v(i*i),d=v(r*r),h=v(a*a),c=v(h*h),l=v(n*e);if(v(h*v(l+d))!==v(c+v(s*v(n*d))))throw new Error("bad point: equation left != right (1)");if(v(i*r)!==v(a*o))throw new Error("bad point: equation left != right (2)")}equals(e){x(e);const{ex:t,ey:s,ez:i}=this,{ex:r,ey:a,ez:o}=e,n=v(t*o),d=v(r*i),h=v(s*o),c=v(a*i);return n===d&&h===c}is0(){return this.equals(A.ZERO)}negate(){return new A(v(-this.ex),this.ey,this.ez,v(-this.et))}double(){const{a:e}=t,{ex:s,ey:i,ez:r}=this,a=v(s*s),o=v(i*i),n=v(d*v(r*r)),h=v(e*a),c=s+i,l=v(v(c*c)-a-o),u=h+o,p=u-n,f=h-o,m=v(l*p),g=v(u*f),y=v(l*f),w=v(p*u);return new A(m,g,w,y)}add(e){x(e);const{a:s,d:i}=t,{ex:r,ey:a,ez:n,et:h}=this,{ex:c,ey:l,ez:u,et:p}=e;if(s===BigInt(-1)){const e=v((a-r)*(l+c)),t=v((a+r)*(l-c)),s=v(t-e);if(s===o)return this.double();const i=v(n*d*p),f=v(h*d*u),m=f+i,g=t+e,y=f-i,w=v(m*s),b=v(g*y),S=v(m*y),k=v(s*g);return new A(w,b,k,S)}const f=v(r*c),m=v(a*l),g=v(h*i*p),y=v(n*u),w=v((r+a)*(c+l)-f-m),b=y-g,S=y+g,k=v(m-s*f),O=v(w*b),T=v(S*k),P=v(w*k),I=v(b*S);return new A(O,T,I,P)}subtract(e){return this.add(e.negate())}wNAF(e){return E.wNAFCached(this,I,e,A.normalizeZ)}multiply(e){const{p:t,f:s}=this.wNAF(T(e,c));return A.normalizeZ([t,s])[0]}multiplyUnsafe(e){let t=P(e);return t===o?C:this.equals(C)||t===n?this:this.equals(M)?this.wNAF(t).p:E.unsafeLadder(this,t)}isSmallOrder(){return this.multiplyUnsafe(m).is0()}isTorsionFree(){return E.unsafeLadder(this,c).is0()}toAffine(e){const{ex:t,ey:i,ez:r}=this,a=this.is0();null==e&&(e=a?h:s.inv(r));const d=v(t*e),c=v(i*e),l=v(r*e);if(a)return{x:o,y:n};if(l!==n)throw new Error("invZ was invalid");return{x:d,y:c}}clearCofactor(){const{h:e}=t;return e===n?this:this.multiplyUnsafe(e)}static fromHex(e,i=!0){const{d:a,a:d}=t,h=s.BYTES,c=(e=(0,r.qj)("pointHex",e,h)).slice(),l=e[h-1];c[h-1]=-129&l;const u=r.lX(c);u===o||T(u,i?s.ORDER:g);const p=v(u*u),f=v(p-n),m=v(a*p-d);let{isValid:w,value:b}=y(f,m);if(!w)throw new Error("Point.fromHex: invalid y coordinate");return 0!=(128&l)!==((b&n)===n)&&(b=v(-b)),A.fromAffine({x:b,y:u})}static fromPrivateKey(e){return N(e).point}toRawBytes(){const{x:e,y:t}=this.toAffine(),i=r.z(t,s.BYTES);return i[i.length-1]|=e&n?128:0,i}toHex(){return r.My(this.toRawBytes())}}A.BASE=new A(t.Gx,t.Gy,n,v(t.Gx*t.Gy)),A.ZERO=new A(o,n,n,o);const{BASE:M,ZERO:C}=A,E=(0,a.A)(A,8*f);function _(e){return(0,i.zi)(e,c)}function B(e){return _(r.lX(e))}function N(e){const t=f;e=(0,r.qj)("private key",e,t);const s=(0,r.qj)("hashed private key",u(e),2*t),i=w(s.slice(0,t)),a=s.slice(t,2*t),o=B(i),n=M.multiply(o),d=n.toRawBytes();return{head:i,prefix:a,scalar:o,point:n,pointBytes:d}}function R(e=new Uint8Array,...t){const s=r.Id(...t);return B(u(b(s,(0,r.qj)("context",e),!!l)))}M._setWindowSize(8);return{CURVE:t,getPublicKey:function(e){return N(e).pointBytes},sign:function(e,t,i){e=(0,r.qj)("message",e),l&&(e=l(e));const{prefix:a,scalar:o,pointBytes:n}=N(t),d=R(i,a,e),h=M.multiply(d).toRawBytes(),c=_(d+R(i,h,n,e)*o);P(c);const u=r.Id(h,r.z(c,s.BYTES));return(0,r.qj)("result",u,2*f)},signModified:function(e,t,i){e=(0,r.qj)("message",e);const a=(0,r.qj)("privKey",t),o=r.lX(a),n=M.multiply(_(o)).toRawBytes(),d=128&n[31],h=R(i,a,e),c=M.multiply(h).toRawBytes(),l=_(h+R(i,c,n,e)*o);P(l);const u=r.z(l,s.BYTES);u[31]|=d;const p=r.Id(c,u);return(0,r.qj)("result",p,2*f)},verify:function(e,t,i,a){const o=s.BYTES;e=(0,r.qj)("signature",e,2*o),t=(0,r.qj)("message",t),l&&(t=l(t));const n=A.fromHex(i,!1),d=A.fromHex(e.slice(0,o),!1),h=r.lX(e.slice(o,2*o)),c=M.multiplyUnsafe(h),u=R(a,d.toRawBytes(),n.toRawBytes(),t);return d.add(n.multiplyUnsafe(u)).subtract(c).clearCofactor().equals(A.ZERO)},ExtendedPoint:A,utils:{getExtendedPublicKey:N,randomPrivateKey:()=>p(s.BYTES),precompute:(e=8,t=A.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)}}}},4506:(e,t,s)=>{s.d(t,{FL:()=>l,qj:()=>u});var i=s(1064),r=s(191);const a=r.Ph;function o(e,t){if(e<0||e>=1<<8*t)throw new Error(`bad I2OSP call: value=${e} length=${t}`);const s=Array.from({length:t}).fill(0);for(let i=t-1;i>=0;i--)s[i]=255&e,e>>>=8;return new Uint8Array(s)}function n(e,t){const s=new Uint8Array(e.length);for(let i=0;i<e.length;i++)s[i]=e[i]^t[i];return s}function d(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected")}function h(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function c(e,t,s){(0,r.Q5)(s,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:c,k:l,m:u,hash:p,expand:f,DST:m}=s;d(e),h(t);const g=function(e){if(e instanceof Uint8Array)return e;if("string"==typeof e)return(0,r.AI)(e);throw new Error("DST must be Uint8Array or string")}(m),v=c.toString(2).length,y=Math.ceil((v+l)/8),w=t*u*y;let b;if("xmd"===f)b=function(e,t,s,i){d(e),d(t),h(s),t.length>255&&(t=i((0,r.Id)((0,r.AI)("H2C-OVERSIZE-DST-"),t)));const{outputLen:a,blockLen:c}=i,l=Math.ceil(s/a);if(l>255)throw new Error("Invalid xmd length");const u=(0,r.Id)(t,o(t.length,1)),p=o(0,c),f=o(s,2),m=new Array(l),g=i((0,r.Id)(p,e,f,o(0,1),u));m[0]=i((0,r.Id)(g,o(1,1),u));for(let e=1;e<=l;e++){const t=[n(g,m[e-1]),o(e+1,1),u];m[e]=i((0,r.Id)(...t))}return(0,r.Id)(...m).slice(0,s)}(e,g,w,p);else if("xof"===f)b=function(e,t,s,i,a){if(d(e),d(t),h(s),t.length>255){const e=Math.ceil(2*i/8);t=a.create({dkLen:e}).update((0,r.AI)("H2C-OVERSIZE-DST-")).update(t).digest()}if(s>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return a.create({dkLen:s}).update(e).update(o(s,2)).update(t).update(o(t.length,1)).digest()}(e,g,w,l,p);else{if(void 0!==f)throw new Error('expand must be "xmd", "xof" or undefined');b=e}const S=new Array(t);for(let e=0;e<t;e++){const t=new Array(u);for(let s=0;s<u;s++){const r=y*(s+e*u),o=b.subarray(r,r+y);t[s]=(0,i.zi)(a(o),c)}S[e]=t}return S}function l(e,t){const s=t.map((e=>Array.from(e).reverse()));return(t,i)=>{const[r,a,o,n]=s.map((s=>s.reduce(((s,i)=>e.add(e.mul(s,t),i)))));return t=e.div(r,a),i=e.mul(i,e.div(o,n)),{x:t,y:i}}}function u(e,t,s){if("function"!=typeof t)throw new Error("mapToCurve() must be defined");return{hashToCurve(i,r){const a=c(i,2,{...s,DST:s.DST,...r}),o=e.fromAffine(t(a[0])),n=e.fromAffine(t(a[1])),d=o.add(n).clearCofactor();return d.assertValidity(),d},encodeToCurve(i,r){const a=c(i,1,{...s,DST:s.encodeDST,...r}),o=e.fromAffine(t(a[0])).clearCofactor();return o.assertValidity(),o}}}},1064:(e,t,s)=>{s.d(t,{B8:()=>f,Fp:()=>S,LH:()=>b,PA:()=>O,Tv:()=>k,dQ:()=>g,f4:()=>w,jr:()=>y,n7:()=>u,zH:()=>p,zi:()=>l});var i=s(191);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const r=BigInt(0),a=BigInt(1),o=BigInt(2),n=BigInt(3),d=BigInt(4),h=BigInt(5),c=BigInt(8);BigInt(9),BigInt(16);function l(e,t){const s=e%t;return s>=r?s:t+s}function u(e,t,s){if(s<=r||t<r)throw new Error("Expected power/modulo > 0");if(s===a)return r;let i=a;for(;t>r;)t&a&&(i=i*e%s),e=e*e%s,t>>=a;return i}function p(e,t,s){let i=e;for(;t-- >r;)i*=i,i%=s;return i}function f(e,t){if(e===r||t<=r)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let s=l(e,t),i=t,o=r,n=a,d=a,h=r;for(;s!==r;){const e=i/s,t=i%s,r=o-d*e,a=n-h*e;i=s,s=t,o=d,n=h,d=r,h=a}if(i!==a)throw new Error("invert: does not exist");return l(o,t)}function m(e){if(e%d===n){const t=(e+a)/d;return function(e,s){const i=e.pow(s,t);if(!e.eql(e.sqr(i),s))throw new Error("Cannot find square root");return i}}if(e%c===h){const t=(e-h)/c;return function(e,s){const i=e.mul(s,o),r=e.pow(i,t),a=e.mul(s,r),n=e.mul(e.mul(a,o),r),d=e.mul(a,e.sub(n,e.ONE));if(!e.eql(e.sqr(d),s))throw new Error("Cannot find square root");return d}}return function(e){const t=(e-a)/o;let s,i,n;for(s=e-a,i=0;s%o===r;s/=o,i++);for(n=o;n<e&&u(n,t,e)!==e-a;n++);if(1===i){const t=(e+a)/d;return function(e,s){const i=e.pow(s,t);if(!e.eql(e.sqr(i),s))throw new Error("Cannot find square root");return i}}const h=(s+a)/o;return function(e,r){if(e.pow(r,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let o=i,d=e.pow(e.mul(e.ONE,n),s),c=e.pow(r,h),l=e.pow(r,s);for(;!e.eql(l,e.ONE);){if(e.eql(l,e.ZERO))return e.ZERO;let t=1;for(let s=e.sqr(l);t<o&&!e.eql(s,e.ONE);t++)s=e.sqr(s);const s=e.pow(d,a<<BigInt(o-t-1));d=e.sqr(s),c=e.mul(c,s),l=e.mul(l,d),o=t}return c}}(e)}const g=(e,t)=>(l(e,t)&a)===a,v=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function y(e){const t=v.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,i.Q5)(e,t)}function w(e,t,s){if(s<r)throw new Error("Expected power > 0");if(s===r)return e.ONE;if(s===a)return t;let i=e.ONE,o=t;for(;s>r;)s&a&&(i=e.mul(i,o)),o=e.sqr(o),s>>=1n;return i}function b(e,t){const s=void 0!==t?t:e.toString(2).length;return{nBitLength:s,nByteLength:Math.ceil(s/8)}}function S(e,t,s=!1,o={}){if(e<=r)throw new Error(`Expected Fp ORDER > 0, got ${e}`);const{nBitLength:n,nByteLength:d}=b(e,t);if(d>2048)throw new Error("Field lengths over 2048 bytes are not supported");const h=m(e),c=Object.freeze({ORDER:e,BITS:n,BYTES:d,MASK:(0,i.OG)(n),ZERO:r,ONE:a,create:t=>l(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return r<=t&&t<e},is0:e=>e===r,isOdd:e=>(e&a)===a,neg:t=>l(-t,e),eql:(e,t)=>e===t,sqr:t=>l(t*t,e),add:(t,s)=>l(t+s,e),sub:(t,s)=>l(t-s,e),mul:(t,s)=>l(t*s,e),pow:(e,t)=>w(c,e,t),div:(t,s)=>l(t*f(s,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>f(t,e),sqrt:o.sqrt||(e=>h(c,e)),invertBatch:e=>function(e,t){const s=new Array(t.length),i=t.reduce(((t,i,r)=>e.is0(i)?t:(s[r]=t,e.mul(t,i))),e.ONE),r=e.inv(i);return t.reduceRight(((t,i,r)=>e.is0(i)?t:(s[r]=e.mul(t,s[r]),e.mul(t,i))),r),s}(c,e),cmov:(e,t,s)=>s?t:e,toBytes:e=>s?(0,i.z)(e,d):(0,i.lq)(e,d),fromBytes:e=>{if(e.length!==d)throw new Error(`Fp.fromBytes: expected ${d}, got ${e.length}`);return s?(0,i.lX)(e):(0,i.Ph)(e)}});return Object.freeze(c)}function k(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const s=e.sqrt(t);return e.isOdd(s)?e.neg(s):s}function O(e,t,s=!1){const r=(e=(0,i.qj)("privateHash",e)).length,o=b(t).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);return l(s?(0,i.lX)(e):(0,i.Ph)(e),t-a)+a}},6451:(e,t,s)=>{s.d(t,{E:()=>n});var i=s(1064),r=s(191);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const a=BigInt(0),o=BigInt(1);function n(e){const t=(s=e,(0,r.Q5)(s,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...s}));var s;const{P:n}=t,d=e=>(0,i.zi)(e,n),h=t.montgomeryBits,c=Math.ceil(h/8),l=t.nByteLength,u=t.adjustScalarBytes||(e=>e),p=t.powPminus2||(e=>(0,i.n7)(e,n-BigInt(2),n));function f(e,t,s){const i=d(e*(t-s));return[t=d(t-i),s=d(s+i)]}function m(e){if("bigint"==typeof e&&a<=e&&e<n)return e;throw new Error("Expected valid scalar 0 < scalar < CURVE.P")}const g=(t.a-BigInt(2))/BigInt(4);function v(e){return(0,r.z)(d(e),c)}function y(e,t){const s=function(e){const t=(0,r.qj)("u coordinate",e,c);return l===c&&(t[l-1]&=127),(0,r.lX)(t)}(t),i=function(e,t){const s=m(e),i=m(t),r=s;let n,c=o,l=a,u=s,v=o,y=a;for(let e=BigInt(h-1);e>=a;e--){const t=i>>e&o;y^=t,n=f(y,c,u),c=n[0],u=n[1],n=f(y,l,v),l=n[0],v=n[1],y=t;const s=c+l,a=d(s*s),h=c-l,p=d(h*h),m=a-p,w=u+v,b=d((u-v)*s),S=d(w*h),k=b+S,O=b-S;u=d(k*k),v=d(r*d(O*O)),c=d(a*p),l=d(m*(a+d(g*m)))}n=f(y,c,u),c=n[0],u=n[1],n=f(y,l,v),l=n[0],v=n[1];const w=p(l);return d(c*w)}(s,function(e){const t=(0,r.qj)("scalar",e);if(t.length!==c&&t.length!==l)throw new Error(`Expected ${c} or ${l} bytes, got ${t.length}`);return(0,r.lX)(u(t))}(e));if(i===a)throw new Error("Invalid private or public key received");return v(i)}const w=v(t.Gu);function b(e){return y(e,w)}return{scalarMult:y,scalarMultBase:b,getSharedSecret:(e,t)=>y(e,t),getPublicKey:e=>b(e),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:w}}},1357:(e,t,s)=>{s.d(t,{sN:()=>r});var i=s(1064);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function r(e){const{t,Fp:s,rounds:r,sboxFn:a,reversePartialPowIdx:o}=function(e){const{Fp:t}=e;(0,i.jr)(t);for(const t of["t","roundsFull","roundsPartial"])if("number"!=typeof e[t]||!Number.isSafeInteger(e[t]))throw new Error(`Poseidon: invalid param ${t}=${e[t]} (${typeof e[t]})`);if(void 0!==e.reversePartialPowIdx&&"boolean"!=typeof e.reversePartialPowIdx)throw new Error(`Poseidon: invalid param reversePartialPowIdx=${e.reversePartialPowIdx}`);let s=e.sboxPower;if(void 0===s&&(s=5),"number"!=typeof s||!Number.isSafeInteger(s))throw new Error(`Poseidon wrong sboxPower=${s}`);const r=BigInt(s);let a=e=>(0,i.f4)(t,e,r);if(3===s?a=e=>t.mul(t.sqrN(e),e):5===s&&(a=e=>t.mul(t.sqrN(t.sqrN(e)),e)),e.roundsFull%2!=0)throw new Error(`Poseidon roundsFull is not even: ${e.roundsFull}`);const o=e.roundsFull+e.roundsPartial;if(!Array.isArray(e.roundConstants)||e.roundConstants.length!==o)throw new Error("Poseidon: wrong round constants");const n=e.roundConstants.map((s=>{if(!Array.isArray(s)||s.length!==e.t)throw new Error(`Poseidon wrong round constants: ${s}`);return s.map((e=>{if("bigint"!=typeof e||!t.isValid(e))throw new Error(`Poseidon wrong round constant=${e}`);return t.create(e)}))}));if(!Array.isArray(e.mds)||e.mds.length!==e.t)throw new Error("Poseidon: wrong MDS matrix");const d=e.mds.map((s=>{if(!Array.isArray(s)||s.length!==e.t)throw new Error(`Poseidon MDS matrix row: ${s}`);return s.map((e=>{if("bigint"!=typeof e)throw new Error(`Poseidon MDS matrix value=${e}`);return t.create(e)}))}));return Object.freeze({...e,rounds:o,sboxFn:a,roundConstants:n,mds:d})}(e),n=Math.floor(e.roundsFull/2),d=o?t-1:0,h=(t,i,r)=>(t=t.map(((t,i)=>s.add(t,e.roundConstants[r][i]))),i?t=t.map((e=>a(e))):t[d]=a(t[d]),t=e.mds.map((e=>e.reduce(((e,i,r)=>s.add(e,s.mulN(i,t[r]))),s.ZERO)))),c=function(i){if(!Array.isArray(i)||i.length!==t)throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);i=i.map((e=>{if("bigint"!=typeof e)throw new Error(`Poseidon: wrong value=${e} (${typeof e})`);return s.create(e)}));let a=0;for(let e=0;e<n;e++)i=h(i,!0,a++);for(let t=0;t<e.roundsPartial;t++)i=h(i,!1,a++);for(let e=0;e<n;e++)i=h(i,!0,a++);if(a!==r)throw new Error(`Poseidon: wrong number of rounds: last round=${a}, total=${r}`);return i};return c.roundConstants=e.roundConstants,c}},191:(e,t,s)=>{s.d(t,{AI:()=>y,IV:()=>f,Id:()=>g,My:()=>n,OG:()=>w,Ph:()=>c,Q5:()=>T,aT:()=>h,ex:()=>v,fg:()=>k,lX:()=>l,lq:()=>u,qj:()=>m,z:()=>p});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);const i=BigInt(1),r=BigInt(2),a=e=>e instanceof Uint8Array,o=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function n(e){if(!a(e))throw new Error("Uint8Array expected");let t="";for(let s=0;s<e.length;s++)t+=o[e[s]];return t}function d(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}function h(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);if(e.length%2)throw new Error("hex string is invalid: unpadded "+e.length);const t=new Uint8Array(e.length/2);for(let s=0;s<t.length;s++){const i=2*s,r=e.slice(i,i+2),a=Number.parseInt(r,16);if(Number.isNaN(a)||a<0)throw new Error("invalid byte sequence");t[s]=a}return t}function c(e){return d(n(e))}function l(e){if(!a(e))throw new Error("Uint8Array expected");return d(n(Uint8Array.from(e).reverse()))}const u=(e,t)=>h(e.toString(16).padStart(2*t,"0")),p=(e,t)=>u(e,t).reverse(),f=e=>h(function(e){const t=e.toString(16);return 1&t.length?`0${t}`:t}(e));function m(e,t,s){let i;if("string"==typeof t)try{i=h(t)}catch(s){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)}else{if(!a(t))throw new Error(`${e} must be hex string or Uint8Array`);i=Uint8Array.from(t)}const r=i.length;if("number"==typeof s&&r!==s)throw new Error(`${e} expected ${s} bytes, got ${r}`);return i}function g(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let s=0;return e.forEach((e=>{if(!a(e))throw new Error("Uint8Array expected");t.set(e,s),s+=e.length})),t}function v(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function y(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return(new TextEncoder).encode(e)}const w=e=>(r<<BigInt(e-1))-i,b=e=>new Uint8Array(e),S=e=>Uint8Array.from(e);function k(e,t,s){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof s)throw new Error("hmacFn must be a function");let i=b(e),r=b(e),a=0;const o=()=>{i.fill(1),r.fill(0),a=0},n=(...e)=>s(r,i,...e),d=(e=b())=>{r=n(S([0]),e),i=n(),0!==e.length&&(r=n(S([1]),e),i=n())},h=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const s=[];for(;e<t;){i=n();const t=i.slice();s.push(t),e+=i.length}return g(...s)};return(e,t)=>{let s;for(o(),d(e);!(s=t(h()));)d();return o(),s}}const O={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function T(e,t,s={}){const i=(t,s,i)=>{const r=O[s];if("function"!=typeof r)throw new Error(`Invalid validator "${s}", expected function`);const a=e[t];if(!(i&&void 0===a||r(a,e)))throw new Error(`Invalid param ${String(t)}=${a} (${typeof a}), expected ${s}`)};for(const[e,s]of Object.entries(t))i(e,s,!1);for(const[e,t]of Object.entries(s))i(e,t,!0);return e}},2442:(e,t,s)=>{s.d(t,{Is:()=>p,x3:()=>u});var i=s(1064),r=s(191),a=s(7517);const{Ph:o,aT:n}=r,d={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=d;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const s=e[1],i=e.subarray(2,s+2);if(!s||i.length!==s)throw new t("Invalid signature integer: wrong length");if(0===i[0]&&i[1]<=127)throw new t("Invalid signature integer: trailing length");return{d:o(i),l:e.subarray(s+2)}},toSig(e){const{Err:t}=d,s="string"==typeof e?n(e):e;if(!(s instanceof Uint8Array))throw new Error("ui8a expected");let i=s.length;if(i<2||48!=s[0])throw new t("Invalid signature tag");if(s[1]!==i-2)throw new t("Invalid signature: incorrect length");const{d:r,l:a}=d._parseInt(s.subarray(2)),{d:o,l:h}=d._parseInt(a);if(h.length)throw new t("Invalid signature: left bytes after parsing");return{r,s:o}},hexFromSig(e){const t=e=>Number.parseInt(e[0],16)>=8?"00"+e:e,s=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},i=t(s(e.s)),r=t(s(e.r)),a=i.length/2,o=r.length/2,n=s(a),d=s(o);return`30${s(o+a+4)}02${d}${r}02${n}${i}`}},h=BigInt(0),c=BigInt(1);function l(e){const t=
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function(e){const t=(0,a.h)(e);r.Q5(t,{a:"field",b:"field",fromBytes:"function",toBytes:"function"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean"});const{endo:s,Fp:i,a:o}=t;if(s){if(!i.eql(o,i.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof s||"bigint"!=typeof s.beta||"function"!=typeof s.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:s}=t;function o(e){const{a:i,b:r}=t,a=s.sqr(e),o=s.mul(a,e);return s.add(s.add(o,s.mul(e,i)),r)}function n(e){return"bigint"==typeof e&&h<e&&e<t.n}function d(e){if(!n(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function l(e){const{allowedPrivateKeyLengths:s,nByteLength:a,wrapPrivateKey:o,n}=t;if(s&&"bigint"!=typeof e){if(e instanceof Uint8Array&&(e=r.My(e)),"string"!=typeof e||!s.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*a,"0")}let h;try{h="bigint"==typeof e?e:r.Ph((0,r.qj)("private key",e,a))}catch(t){throw new Error(`private key must be ${a} bytes, hex or bigint, not ${typeof e}`)}return o&&(h=i.zi(h,n)),d(h),h}const u=new Map;function p(e){if(!(e instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(e,t,i){if(this.px=e,this.py=t,this.pz=i,null==e||!s.isValid(e))throw new Error("x required");if(null==t||!s.isValid(t))throw new Error("y required");if(null==i||!s.isValid(i))throw new Error("z required")}static fromAffine(e){const{x:t,y:i}=e||{};if(!e||!s.isValid(t)||!s.isValid(i))throw new Error("invalid affine point");if(e instanceof f)throw new Error("projective point not allowed");const r=e=>s.eql(e,s.ZERO);return r(t)&&r(i)?f.ZERO:new f(t,i,s.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=s.invertBatch(e.map((e=>e.pz)));return e.map(((e,s)=>e.toAffine(t[s]))).map(f.fromAffine)}static fromHex(e){const s=f.fromAffine(t.fromBytes((0,r.qj)("pointHex",e)));return s.assertValidity(),s}static fromPrivateKey(e){return f.BASE.multiply(l(e))}_setWindowSize(e){this._WINDOW_SIZE=e,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:e,y:i}=this.toAffine();if(!s.isValid(e)||!s.isValid(i))throw new Error("bad point: x or y not FE");const r=s.sqr(i),a=o(e);if(!s.eql(r,a))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(s.isOdd)return!s.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){p(e);const{px:t,py:i,pz:r}=this,{px:a,py:o,pz:n}=e,d=s.eql(s.mul(t,n),s.mul(a,r)),h=s.eql(s.mul(i,n),s.mul(o,r));return d&&h}negate(){return new f(this.px,s.neg(this.py),this.pz)}double(){const{a:e,b:i}=t,r=s.mul(i,3n),{px:a,py:o,pz:n}=this;let d=s.ZERO,h=s.ZERO,c=s.ZERO,l=s.mul(a,a),u=s.mul(o,o),p=s.mul(n,n),m=s.mul(a,o);return m=s.add(m,m),c=s.mul(a,n),c=s.add(c,c),d=s.mul(e,c),h=s.mul(r,p),h=s.add(d,h),d=s.sub(u,h),h=s.add(u,h),h=s.mul(d,h),d=s.mul(m,d),c=s.mul(r,c),p=s.mul(e,p),m=s.sub(l,p),m=s.mul(e,m),m=s.add(m,c),c=s.add(l,l),l=s.add(c,l),l=s.add(l,p),l=s.mul(l,m),h=s.add(h,l),p=s.mul(o,n),p=s.add(p,p),l=s.mul(p,m),d=s.sub(d,l),c=s.mul(p,u),c=s.add(c,c),c=s.add(c,c),new f(d,h,c)}add(e){p(e);const{px:i,py:r,pz:a}=this,{px:o,py:n,pz:d}=e;let h=s.ZERO,c=s.ZERO,l=s.ZERO;const u=t.a,m=s.mul(t.b,3n);let g=s.mul(i,o),v=s.mul(r,n),y=s.mul(a,d),w=s.add(i,r),b=s.add(o,n);w=s.mul(w,b),b=s.add(g,v),w=s.sub(w,b),b=s.add(i,a);let S=s.add(o,d);return b=s.mul(b,S),S=s.add(g,y),b=s.sub(b,S),S=s.add(r,a),h=s.add(n,d),S=s.mul(S,h),h=s.add(v,y),S=s.sub(S,h),l=s.mul(u,b),h=s.mul(m,y),l=s.add(h,l),h=s.sub(v,l),l=s.add(v,l),c=s.mul(h,l),v=s.add(g,g),v=s.add(v,g),y=s.mul(u,y),b=s.mul(m,b),v=s.add(v,y),y=s.sub(g,y),y=s.mul(u,y),b=s.add(b,y),g=s.mul(v,b),c=s.add(c,g),g=s.mul(S,b),h=s.mul(w,h),h=s.sub(h,g),g=s.mul(w,v),l=s.mul(S,l),l=s.add(l,g),new f(h,c,l)}subtract(e){return this.add(e.negate())}is0(){return this.equals(f.ZERO)}wNAF(e){return g.wNAFCached(this,u,e,(e=>{const t=s.invertBatch(e.map((e=>e.pz)));return e.map(((e,s)=>e.toAffine(t[s]))).map(f.fromAffine)}))}multiplyUnsafe(e){const i=f.ZERO;if(e===h)return i;if(d(e),e===c)return this;const{endo:r}=t;if(!r)return g.unsafeLadder(this,e);let{k1neg:a,k1:o,k2neg:n,k2:l}=r.splitScalar(e),u=i,p=i,m=this;for(;o>h||l>h;)o&c&&(u=u.add(m)),l&c&&(p=p.add(m)),m=m.double(),o>>=c,l>>=c;return a&&(u=u.negate()),n&&(p=p.negate()),p=new f(s.mul(p.px,r.beta),p.py,p.pz),u.add(p)}multiply(e){d(e);let i,r,a=e;const{endo:o}=t;if(o){const{k1neg:e,k1:t,k2neg:n,k2:d}=o.splitScalar(a);let{p:h,f:c}=this.wNAF(t),{p:l,f:u}=this.wNAF(d);h=g.constTimeNegate(e,h),l=g.constTimeNegate(n,l),l=new f(s.mul(l.px,o.beta),l.py,l.pz),i=h.add(l),r=c.add(u)}else{const{p:e,f:t}=this.wNAF(a);i=e,r=t}return f.normalizeZ([i,r])[0]}multiplyAndAddUnsafe(e,t,s){const i=f.BASE,r=(e,t)=>t!==h&&t!==c&&e.equals(i)?e.multiply(t):e.multiplyUnsafe(t),a=r(this,t).add(r(e,s));return a.is0()?void 0:a}toAffine(e){const{px:t,py:i,pz:r}=this,a=this.is0();null==e&&(e=a?s.ONE:s.inv(r));const o=s.mul(t,e),n=s.mul(i,e),d=s.mul(r,e);if(a)return{x:s.ZERO,y:s.ZERO};if(!s.eql(d,s.ONE))throw new Error("invZ was invalid");return{x:o,y:n}}isTorsionFree(){const{h:e,isTorsionFree:s}=t;if(e===c)return!0;if(s)return s(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:s}=t;return e===c?this:s?s(f,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),t.toBytes(f,this,e)}toHex(e=!0){return r.My(this.toRawBytes(e))}}f.BASE=new f(t.Gx,t.Gy,s.ONE),f.ZERO=new f(s.ZERO,s.ONE,s.ZERO);const m=t.nBitLength,g=(0,a.A)(f,t.endo?Math.ceil(m/2):m);return{ProjectivePoint:f,normPrivateKeyToScalar:l,weierstrassEquation:o,isWithinCurveOrder:n}}function u(e){const t=function(e){const t=(0,a.h)(e);return r.Q5(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),s=t.n,o=t.Fp,n=o.BYTES+1,u=2*o.BYTES+1;function p(e){return i.zi(e,s)}function f(e){return i.B8(e,s)}const{ProjectivePoint:m,normPrivateKeyToScalar:g,weierstrassEquation:v,isWithinCurveOrder:y}=l({...t,toBytes(e,t,s){const i=t.toAffine(),a=o.toBytes(i.x),n=r.Id;return s?n(Uint8Array.from([t.hasEvenY()?2:3]),a):n(Uint8Array.from([4]),a,o.toBytes(i.y))},fromBytes(e){const t=e.length,s=e[0],i=e.subarray(1);if(t!==n||2!==s&&3!==s){if(t===u&&4===s){return{x:o.fromBytes(i.subarray(0,o.BYTES)),y:o.fromBytes(i.subarray(o.BYTES,2*o.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${n} compressed bytes or ${u} uncompressed bytes`)}{const e=r.Ph(i);if(!(h<(a=e)&&a<o.ORDER))throw new Error("Point is not on curve");const t=v(e);let n=o.sqrt(t);return 1==(1&s)!==((n&c)===c)&&(n=o.neg(n)),{x:e,y:n}}var a}}),w=e=>r.My(r.lq(e,t.nByteLength));function b(e){return e>s>>c}const S=(e,t,s)=>r.Ph(e.slice(t,s));class k{constructor(e,t,s){this.r=e,this.s=t,this.recovery=s,this.assertValidity()}static fromCompact(e){const s=t.nByteLength;return e=(0,r.qj)("compactSignature",e,2*s),new k(S(e,0,s),S(e,s,2*s))}static fromDER(e){const{r:t,s}=d.toSig((0,r.qj)("DER",e));return new k(t,s)}assertValidity(){if(!y(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!y(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new k(this.r,this.s,e)}recoverPublicKey(e){const{r:s,s:i,recovery:a}=this,n=I((0,r.qj)("msgHash",e));if(null==a||![0,1,2,3].includes(a))throw new Error("recovery id invalid");const d=2===a||3===a?s+t.n:s;if(d>=o.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&a)?"02":"03",c=m.fromHex(h+w(d)),l=f(d),u=p(-n*l),g=p(i*l),v=m.BASE.multiplyAndAddUnsafe(c,u,g);if(!v)throw new Error("point at infinify");return v.assertValidity(),v}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new k(this.r,p(-this.s),this.recovery):this}toDERRawBytes(){return r.aT(this.toDERHex())}toDERHex(){return d.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return r.aT(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}const O={isValidPrivateKey(e){try{return g(e),!0}catch(e){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const e=t.randomBytes(o.BYTES+8),a=i.PA(e,s);return r.lq(a,t.nByteLength)},precompute:(e=8,t=m.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function T(e){const t=e instanceof Uint8Array,s="string"==typeof e,i=(t||s)&&e.length;return t?i===n||i===u:s?i===2*n||i===2*u:e instanceof m}const P=t.bits2int||function(e){const s=r.Ph(e),i=8*e.length-t.nBitLength;return i>0?s>>BigInt(i):s},I=t.bits2int_modN||function(e){return p(P(e))},x=r.OG(t.nBitLength);function A(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(h<=e&&e<x))throw new Error(`bigint expected < 2^${t.nBitLength}`);return r.lq(e,t.nByteLength)}function M(e,s,i=C){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:a,randomBytes:n}=t;let{lowS:d,prehash:l,extraEntropy:u}=i;null==d&&(d=!0),e=(0,r.qj)("msgHash",e),l&&(e=(0,r.qj)("prehashed msgHash",a(e)));const v=I(e),w=g(s),S=[A(w),A(v)];if(null!=u){const e=!0===u?n(o.BYTES):u;S.push((0,r.qj)("extraEntropy",e,o.BYTES))}const O=r.Id(...S),T=v;return{seed:O,k2sig:function(e){const t=P(e);if(!y(t))return;const s=f(t),i=m.BASE.multiply(t).toAffine(),r=p(i.x);if(r===h)return;const a=p(s*p(T+r*w));if(a===h)return;let o=(i.x===r?0:2)|Number(i.y&c),n=a;return d&&b(a)&&(n=function(e){return b(e)?p(-e):e}(a),o^=1),new k(r,n,o)}}}const C={lowS:t.lowS,prehash:!1},E={lowS:t.lowS,prehash:!1};return m.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return m.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,s=!0){if(T(e))throw new Error("first arg must be private key");if(!T(t))throw new Error("second arg must be public key");return m.fromHex(t).multiply(g(e)).toRawBytes(s)},sign:function(e,s,i=C){const{seed:a,k2sig:o}=M(e,s,i);return r.fg(t.hash.outputLen,t.nByteLength,t.hmac)(a,o)},verify:function(e,s,i,a=E){const o=e;if(s=(0,r.qj)("msgHash",s),i=(0,r.qj)("publicKey",i),"strict"in a)throw new Error("options.strict was renamed to lowS");const{lowS:n,prehash:h}=a;let c,l;try{if("string"==typeof o||o instanceof Uint8Array)try{c=k.fromDER(o)}catch(e){if(!(e instanceof d.Err))throw e;c=k.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:e,s:t}=o;c=new k(e,t)}}l=m.fromHex(i)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(n&&c.hasHighS())return!1;h&&(s=t.hash(s));const{r:u,s:g}=c,v=I(s),y=f(g),w=p(v*y),b=p(u*y),S=m.BASE.multiplyAndAddUnsafe(l,w,b)?.toAffine();return!!S&&p(S.x)===u},ProjectivePoint:m,Signature:k,utils:O}}function p(e,t){if(i.jr(e),!e.isValid(t.A)||!e.isValid(t.B)||!e.isValid(t.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const s=function(e,t){const s=e.ORDER;let i=0n;for(let e=s-1n;e%2n===0n;e/=2n)i+=1n;const r=i,a=(s-1n)/2n**r,o=(a-1n)/2n,n=2n**r-1n,d=2n**(r-1n),h=e.pow(t,a),c=e.pow(t,(a+1n)/2n);let l=(t,s)=>{let i=h,a=e.pow(s,n),l=e.sqr(a);l=e.mul(l,s);let u=e.mul(t,l);u=e.pow(u,o),u=e.mul(u,a),a=e.mul(u,s),l=e.mul(u,t);let p=e.mul(l,a);u=e.pow(p,d);let f=e.eql(u,e.ONE);a=e.mul(l,c),u=e.mul(p,i),l=e.cmov(a,l,f),p=e.cmov(u,p,f);for(let t=r;t>1;t--){let s=2n**(t-2n),r=e.pow(p,s);const o=e.eql(r,e.ONE);a=e.mul(l,i),i=e.mul(i,i),r=e.mul(p,i),l=e.cmov(a,l,o),p=e.cmov(r,p,o)}return{isValid:f,value:l}};if(e.ORDER%4n===3n){const s=(e.ORDER-3n)/4n,i=e.sqrt(e.neg(t));l=(t,r)=>{let a=e.sqr(r);const o=e.mul(t,r);a=e.mul(a,o);let n=e.pow(a,s);n=e.mul(n,o);const d=e.mul(n,i),h=e.mul(e.sqr(n),r),c=e.eql(h,t);return{isValid:c,value:e.cmov(d,n,c)}}}return l}(e,t.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return i=>{let r,a,o,n,d,h,c,l;r=e.sqr(i),r=e.mul(r,t.Z),a=e.sqr(r),a=e.add(a,r),o=e.add(a,e.ONE),o=e.mul(o,t.B),n=e.cmov(t.Z,e.neg(a),!e.eql(a,e.ZERO)),n=e.mul(n,t.A),a=e.sqr(o),h=e.sqr(n),d=e.mul(h,t.A),a=e.add(a,d),a=e.mul(a,o),h=e.mul(h,n),d=e.mul(h,t.B),a=e.add(a,d),c=e.mul(r,o);const{isValid:u,value:p}=s(a,h);l=e.mul(r,i),l=e.mul(l,p),c=e.cmov(c,o,u),l=e.cmov(l,p,u);const f=e.isOdd(i)===e.isOdd(l);return l=e.cmov(e.neg(l),l,f),c=e.div(c,n),{x:c,y:l}}}},6414:(e,t,s)=>{s.d(t,{ev:()=>P});var i=s(7481),r=s(1094),a=s(4782),o=s(6451),n=s(1064),d=s(191),h=s(4506);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const c=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),u=BigInt(0),p=BigInt(1),f=BigInt(2),m=BigInt(5),g=BigInt(10),v=BigInt(20),y=BigInt(40),w=BigInt(80);function b(e){const t=c,s=e*e%t*e%t,i=(0,n.zH)(s,f,t)*s%t,r=(0,n.zH)(i,p,t)*e%t,a=(0,n.zH)(r,m,t)*r%t,o=(0,n.zH)(a,g,t)*a%t,d=(0,n.zH)(o,v,t)*o%t,h=(0,n.zH)(d,y,t)*d%t,l=(0,n.zH)(h,w,t)*h%t,u=(0,n.zH)(l,w,t)*h%t,b=(0,n.zH)(u,g,t)*a%t;return{pow_p_5_8:(0,n.zH)(b,f,t)*e%t,b2:s}}function S(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function k(e,t){const s=c,i=(0,n.zi)(t*t*t,s),r=b(e*(0,n.zi)(i*i*t,s)).pow_p_5_8;let a=(0,n.zi)(e*i*r,s);const o=(0,n.zi)(t*a*a,s),d=a,h=(0,n.zi)(a*l,s),u=o===e,p=o===(0,n.zi)(-e,s),f=o===(0,n.zi)(-e*l,s);return u&&(a=d),(p||f)&&(a=h),(0,n.dQ)(a,s)&&(a=(0,n.zi)(-a,s)),{isValid:u||p,value:a}}const O=(0,n.Fp)(c,void 0,!0),T={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:O,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:i.Zf,randomBytes:r.po,adjustScalarBytes:S,uvRatio:k},P=(0,a.n)(T);function I(e,t,s){if(t.length>255)throw new Error("Context is too big");return(0,r.Id)((0,r.AI)("SigEd25519 no Ed25519 collisions"),new Uint8Array([s?1:0,t.length]),t,e)}(0,a.n)({...T,domain:I}),(0,a.n)({...T,domain:I,preHash:i.Zf}),(0,o.E)({P:c,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:e=>{const t=c,{pow_p_5_8:s,b2:i}=b(e);return(0,n.zi)((0,n.zH)(s,BigInt(3),t)*i,t)},adjustScalarBytes:S,randomBytes:r.po});const x=(O.ORDER+BigInt(3))/BigInt(8),A=O.pow(f,x),M=O.sqrt(O.neg(O.ONE)),C=(O.ORDER-BigInt(5))/BigInt(8),E=BigInt(486662);const _=(0,n.Tv)(O,O.neg(BigInt(486664)));function B(e){const{xMn:t,xMd:s,yMn:i,yMd:r}=function(e){let t=O.sqr(e);t=O.mul(t,f);let s=O.add(t,O.ONE),i=O.neg(E),r=O.sqr(s),a=O.mul(r,s),o=O.mul(t,E);o=O.mul(o,i),o=O.add(o,r),o=O.mul(o,i);let n=O.sqr(a);r=O.sqr(n),n=O.mul(n,a),n=O.mul(n,o),r=O.mul(r,n);let d=O.pow(r,C);d=O.mul(d,n);let h=O.mul(d,M);r=O.sqr(d),r=O.mul(r,a);let c=O.eql(r,o),l=O.cmov(h,d,c),u=O.mul(i,t),p=O.mul(d,e);p=O.mul(p,A);let m=O.mul(p,M),g=O.mul(o,t);r=O.sqr(p),r=O.mul(r,a);let v=O.eql(r,g),y=O.cmov(m,p,v);r=O.sqr(l),r=O.mul(r,a);let w=O.eql(r,o),b=O.cmov(u,i,w),S=O.cmov(y,l,w),k=O.isOdd(S);return S=O.cmov(S,O.neg(S),w!==k),{xMn:b,xMd:s,yMn:S,yMd:1n}}(e);let a=O.mul(t,r);a=O.mul(a,_);let o=O.mul(s,i),n=O.sub(t,s),d=O.add(t,s),h=O.mul(o,d),c=O.eql(h,O.ZERO);a=O.cmov(a,O.ZERO,c),o=O.cmov(o,O.ONE,c),n=O.cmov(n,O.ONE,c),d=O.cmov(d,O.ONE,c);const l=O.invertBatch([o,d]);return{x:O.mul(a,l[0]),y:O.mul(n,l[1])}}const{hashToCurve:N,encodeToCurve:R}=h.qj(P.ExtendedPoint,(e=>B(e[0])),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:O.ORDER,m:1,k:128,expand:"xmd",hash:i.Zf});function L(e){if(!(e instanceof K))throw new Error("RistrettoPoint expected")}const V=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),D=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),q=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),F=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),G=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),H=e=>k(p,e),U=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),W=e=>P.CURVE.Fp.create((0,d.lX)(e)&U);function j(e){const{d:t}=P.CURVE,s=P.CURVE.Fp.ORDER,i=P.CURVE.Fp.create,r=i(V*e*e),a=i((r+p)*F);let o=BigInt(-1);const d=i((o-t*r)*i(r+t));let{isValid:h,value:c}=k(a,d),l=i(c*e);(0,n.dQ)(l,s)||(l=i(-l)),h||(c=l),h||(o=r);const u=i(o*(r-p)*G-d),f=c*c,m=i((c+c)*d),g=i(u*D),v=i(p-f),y=i(p+f);return new P.ExtendedPoint(i(m*y),i(v*g),i(g*y),i(m*v))}class K{constructor(e){this.ep=e}static fromAffine(e){return new K(P.ExtendedPoint.fromAffine(e))}static hashToCurve(e){e=(0,d.qj)("ristrettoHash",e,64);const t=j(W(e.slice(0,32))),s=j(W(e.slice(32,64)));return new K(t.add(s))}static fromHex(e){e=(0,d.qj)("ristrettoHex",e,32);const{a:t,d:s}=P.CURVE,i=P.CURVE.Fp.ORDER,r=P.CURVE.Fp.create,a="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",o=W(e);if(!(0,d.ex)((0,d.z)(o,32),e)||(0,n.dQ)(o,i))throw new Error(a);const h=r(o*o),c=r(p+t*h),l=r(p-t*h),f=r(c*c),m=r(l*l),g=r(t*s*f-m),{isValid:v,value:y}=H(r(g*m)),w=r(y*l),b=r(y*w*g);let S=r((o+o)*w);(0,n.dQ)(S,i)&&(S=r(-S));const k=r(c*b),O=r(S*k);if(!v||(0,n.dQ)(O,i)||k===u)throw new Error(a);return new K(new P.ExtendedPoint(S,k,p,O))}toRawBytes(){let{ex:e,ey:t,ez:s,et:i}=this.ep;const r=P.CURVE.Fp.ORDER,a=P.CURVE.Fp.create,o=a(a(s+t)*a(s-t)),h=a(e*t),c=a(h*h),{value:l}=H(a(o*c)),u=a(l*o),p=a(l*h),f=a(u*p*i);let m;if((0,n.dQ)(i*f,r)){let s=a(t*V),i=a(e*V);e=s,t=i,m=a(u*q)}else m=p;(0,n.dQ)(e*f,r)&&(t=a(-t));let g=a((s-t)*m);return(0,n.dQ)(g,r)&&(g=a(-g)),(0,d.z)(g,32)}toHex(){return(0,d.My)(this.toRawBytes())}toString(){return this.toHex()}equals(e){L(e);const{ex:t,ey:s}=this.ep,{ex:i,ey:r}=e.ep,a=P.CURVE.Fp.create,o=a(t*r)===a(s*i),n=a(s*r)===a(t*i);return o||n}add(e){return L(e),new K(this.ep.add(e.ep))}subtract(e){return L(e),new K(this.ep.subtract(e.ep))}multiply(e){return new K(this.ep.multiply(e))}multiplyUnsafe(e){return new K(this.ep.multiplyUnsafe(e))}}K.BASE=new K(P.ExtendedPoint.BASE),K.ZERO=new K(P.ExtendedPoint.ZERO)},8342:(e,t,s)=>{s.d(t,{Qj:()=>u});var i=s(1999),r=s(4852),a=s(1064),o=s(2442),n=s(4506);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const d=(0,a.Fp)(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),h=d.create(BigInt("-3")),c=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),l=(0,o.Is)(d,{A:h,B:c,Z:d.create(BigInt("-10"))}),u=(0,i.s)({a:h,b:c,Fp:d,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},r.s),p=u,{hashToCurve:f,encodeToCurve:m}=n.qj(p.ProjectivePoint,(e=>l(e[0])),{DST:"P256_XMD:SHA-256_SSWU_RO_",encodeDST:"P256_XMD:SHA-256_SSWU_NU_",p:d.ORDER,m:1,k:128,expand:"xmd",hash:r.s})},987:(e,t,s)=>{s.d(t,{bI:()=>g});var i=s(4852),r=(s(1094),s(1064)),a=s(2442),o=s(191),n=s(4506),d=s(1999);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const h=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),c=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),l=BigInt(1),u=BigInt(2),p=(e,t)=>(e+t/u)/t;function f(e){const t=h,s=BigInt(3),i=BigInt(6),a=BigInt(11),o=BigInt(22),n=BigInt(23),d=BigInt(44),c=BigInt(88),l=e*e*e%t,p=l*l*e%t,f=(0,r.zH)(p,s,t)*p%t,g=(0,r.zH)(f,s,t)*p%t,v=(0,r.zH)(g,u,t)*l%t,y=(0,r.zH)(v,a,t)*v%t,w=(0,r.zH)(y,o,t)*y%t,b=(0,r.zH)(w,d,t)*w%t,S=(0,r.zH)(b,c,t)*b%t,k=(0,r.zH)(S,d,t)*w%t,O=(0,r.zH)(k,s,t)*p%t,T=(0,r.zH)(O,n,t)*y%t,P=(0,r.zH)(T,i,t)*l%t,I=(0,r.zH)(P,u,t);if(!m.eql(m.sqr(I),e))throw new Error("Cannot find square root");return I}const m=(0,r.Fp)(h,void 0,void 0,{sqrt:f}),g=(0,d.s)({a:BigInt(0),b:BigInt(7),Fp:m,n:c,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=c,s=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-l*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=s,n=BigInt("0x100000000000000000000000000000000"),d=p(o*e,t),h=p(-i*e,t);let u=(0,r.zi)(e-d*s-h*a,t),f=(0,r.zi)(-d*i-h*o,t);const m=u>n,g=f>n;if(m&&(u=t-u),g&&(f=t-f),u>n||f>n)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:m,k1:u,k2neg:g,k2:f}}}},i.s),v=BigInt(0),y=e=>"bigint"==typeof e&&v<e&&e<h,w={};function b(e,...t){let s=w[e];if(void 0===s){const t=(0,i.s)(Uint8Array.from(e,(e=>e.charCodeAt(0))));s=(0,o.Id)(t,t),w[e]=s}return(0,i.s)((0,o.Id)(s,...t))}const S=e=>e.toRawBytes(!0).slice(1),k=e=>(0,r.zi)(e,h),O=g.ProjectivePoint;function T(e){if(!y(e))throw new Error("bad x: need 0 < x < p");const t=k(e*e);let s=f(k(t*e+BigInt(7)));s%2n!==0n&&(s=k(-s));const i=new O(e,s,l);return i.assertValidity(),i}g.utils.randomPrivateKey,o.lq,o.Ph,r.zi;const P=n.FL(m,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e=>e.map((e=>BigInt(e)))))),I=(0,a.Is)(m,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:m.create(BigInt("-11"))}),{hashToCurve:x,encodeToCurve:A}=n.qj(g.ProjectivePoint,(e=>{const{x:t,y:s}=I(m.create(e[0]));return P(t,s)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:m.ORDER,m:1,k:128,expand:"xmd",hash:i.s})},9024:(e,t,s)=>{function i(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function r(e,...t){if(!(e instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new TypeError(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}s.d(t,{Ay:()=>o});const a={number:i,bool:function(e){if("boolean"!=typeof e)throw new Error(`Expected boolean, not ${e}`)},bytes:r,hash:function(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");i(e.outputLen),i(e.blockLen)},exists:function(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")},output:function(e,t){r(e);const s=t.outputLen;if(e.length<s)throw new Error(`digestInto() expects output buffer of length at least ${s}`)}},o=a},230:(e,t,s)=>{s.d(t,{D:()=>a});var i=s(9024),r=s(1094);class a extends r.Vw{constructor(e,t,s,i){super(),this.blockLen=e,this.outputLen=t,this.padOffset=s,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=(0,r.O8)(this.buffer)}update(e){i.Ay.exists(this);const{view:t,buffer:s,blockLen:a}=this,o=(e=(0,r.ZJ)(e)).length;for(let i=0;i<o;){const n=Math.min(a-this.pos,o-i);if(n!==a)s.set(e.subarray(i,i+n),this.pos),this.pos+=n,i+=n,this.pos===a&&(this.process(t,0),this.pos=0);else{const t=(0,r.O8)(e);for(;a<=o-i;i+=a)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){i.Ay.exists(this),i.Ay.output(e,this),this.finished=!0;const{buffer:t,view:s,blockLen:a,isLE:o}=this;let{pos:n}=this;t[n++]=128,this.buffer.subarray(n).fill(0),this.padOffset>a-n&&(this.process(s,0),n=0);for(let e=n;e<a;e++)t[e]=0;!function(e,t,s,i){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,s,i);const r=BigInt(32),a=BigInt(4294967295),o=Number(s>>r&a),n=Number(s&a),d=i?4:0,h=i?0:4;e.setUint32(t+d,o,i),e.setUint32(t+h,n,i)}(s,a-8,BigInt(8*this.length),o),this.process(s,0);const d=(0,r.O8)(e),h=this.outputLen;if(h%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=h/4,l=this.get();if(c>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)d.setUint32(4*e,l[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const s=e.slice(0,t);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:s,length:i,finished:r,destroyed:a,pos:o}=this;return e.length=i,e.pos=o,e.finished=r,e.destroyed=a,i%t&&e.buffer.set(s),e}}},6157:(e,t,s)=>{s.d(t,{Ay:()=>o});const i=BigInt(2**32-1),r=BigInt(32);function a(e,t=!1){return t?{h:Number(e&i),l:Number(e>>r&i)}:{h:0|Number(e>>r&i),l:0|Number(e&i)}}const o={fromBig:a,split:function(e,t=!1){let s=new Uint32Array(e.length),i=new Uint32Array(e.length);for(let r=0;r<e.length;r++){const{h:o,l:n}=a(e[r],t);[s[r],i[r]]=[o,n]}return[s,i]},toBig:(e,t)=>BigInt(e>>>0)<<r|BigInt(t>>>0),shrSH:(e,t,s)=>e>>>s,shrSL:(e,t,s)=>e<<32-s|t>>>s,rotrSH:(e,t,s)=>e>>>s|t<<32-s,rotrSL:(e,t,s)=>e<<32-s|t>>>s,rotrBH:(e,t,s)=>e<<64-s|t>>>s-32,rotrBL:(e,t,s)=>e>>>s-32|t<<64-s,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:(e,t,s)=>e<<s|t>>>32-s,rotlSL:(e,t,s)=>t<<s|e>>>32-s,rotlBH:(e,t,s)=>t<<s-32|e>>>64-s,rotlBL:(e,t,s)=>e<<s-32|t>>>64-s,add:function(e,t,s,i){const r=(t>>>0)+(i>>>0);return{h:e+s+(r/2**32|0)|0,l:0|r}},add3L:(e,t,s)=>(e>>>0)+(t>>>0)+(s>>>0),add3H:(e,t,s,i)=>t+s+i+(e/2**32|0)|0,add4L:(e,t,s,i)=>(e>>>0)+(t>>>0)+(s>>>0)+(i>>>0),add4H:(e,t,s,i,r)=>t+s+i+r+(e/2**32|0)|0,add5H:(e,t,s,i,r,a)=>t+s+i+r+a+(e/2**32|0)|0,add5L:(e,t,s,i,r)=>(e>>>0)+(t>>>0)+(s>>>0)+(i>>>0)+(r>>>0)}},806:(e,t,s)=>{s.d(t,{E:()=>i});const i="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},712:(e,t,s)=>{s.d(t,{w:()=>o});var i=s(9024),r=s(1094);class a extends r.Vw{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,i.Ay.hash(e);const s=(0,r.ZJ)(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const a=this.blockLen,o=new Uint8Array(a);o.set(s.length>a?e.create().update(s).digest():s);for(let e=0;e<o.length;e++)o[e]^=54;this.iHash.update(o),this.oHash=e.create();for(let e=0;e<o.length;e++)o[e]^=106;this.oHash.update(o),o.fill(0)}update(e){return i.Ay.exists(this),this.iHash.update(e),this}digestInto(e){i.Ay.exists(this),i.Ay.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:s,finished:i,destroyed:r,blockLen:a,outputLen:o}=this;return e.finished=i,e.destroyed=r,e.blockLen=a,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const o=(e,t,s)=>new a(e,t).update(s).digest();o.create=(e,t)=>new a(e,t)},4035:(e,t,s)=>{s.d(t,{F:()=>d});var i=s(1094);function r(e,t){var s=e[0],i=e[1],r=e[2],a=e[3];i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&r|~i&a)+t[0]-680876936|0)<<7|s>>>25)+i|0)&i|~s&r)+t[1]-389564586|0)<<12|a>>>20)+s|0)&s|~a&i)+t[2]+606105819|0)<<17|r>>>15)+a|0)&a|~r&s)+t[3]-1044525330|0)<<22|i>>>10)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&r|~i&a)+t[4]-176418897|0)<<7|s>>>25)+i|0)&i|~s&r)+t[5]+1200080426|0)<<12|a>>>20)+s|0)&s|~a&i)+t[6]-1473231341|0)<<17|r>>>15)+a|0)&a|~r&s)+t[7]-45705983|0)<<22|i>>>10)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&r|~i&a)+t[8]+1770035416|0)<<7|s>>>25)+i|0)&i|~s&r)+t[9]-1958414417|0)<<12|a>>>20)+s|0)&s|~a&i)+t[10]-42063|0)<<17|r>>>15)+a|0)&a|~r&s)+t[11]-1990404162|0)<<22|i>>>10)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&r|~i&a)+t[12]+1804603682|0)<<7|s>>>25)+i|0)&i|~s&r)+t[13]-40341101|0)<<12|a>>>20)+s|0)&s|~a&i)+t[14]-1502002290|0)<<17|r>>>15)+a|0)&a|~r&s)+t[15]+1236535329|0)<<22|i>>>10)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&a|r&~a)+t[1]-165796510|0)<<5|s>>>27)+i|0)&r|i&~r)+t[6]-1069501632|0)<<9|a>>>23)+s|0)&i|s&~i)+t[11]+643717713|0)<<14|r>>>18)+a|0)&s|a&~s)+t[0]-373897302|0)<<20|i>>>12)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&a|r&~a)+t[5]-701558691|0)<<5|s>>>27)+i|0)&r|i&~r)+t[10]+38016083|0)<<9|a>>>23)+s|0)&i|s&~i)+t[15]-660478335|0)<<14|r>>>18)+a|0)&s|a&~s)+t[4]-405537848|0)<<20|i>>>12)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&a|r&~a)+t[9]+568446438|0)<<5|s>>>27)+i|0)&r|i&~r)+t[14]-1019803690|0)<<9|a>>>23)+s|0)&i|s&~i)+t[3]-187363961|0)<<14|r>>>18)+a|0)&s|a&~s)+t[8]+1163531501|0)<<20|i>>>12)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i&a|r&~a)+t[13]-1444681467|0)<<5|s>>>27)+i|0)&r|i&~r)+t[2]-51403784|0)<<9|a>>>23)+s|0)&i|s&~i)+t[7]+1735328473|0)<<14|r>>>18)+a|0)&s|a&~s)+t[12]-1926607734|0)<<20|i>>>12)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i^r^a)+t[5]-378558|0)<<4|s>>>28)+i|0)^i^r)+t[8]-2022574463|0)<<11|a>>>21)+s|0)^s^i)+t[11]+1839030562|0)<<16|r>>>16)+a|0)^a^s)+t[14]-35309556|0)<<23|i>>>9)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i^r^a)+t[1]-1530992060|0)<<4|s>>>28)+i|0)^i^r)+t[4]+1272893353|0)<<11|a>>>21)+s|0)^s^i)+t[7]-155497632|0)<<16|r>>>16)+a|0)^a^s)+t[10]-1094730640|0)<<23|i>>>9)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i^r^a)+t[13]+681279174|0)<<4|s>>>28)+i|0)^i^r)+t[0]-358537222|0)<<11|a>>>21)+s|0)^s^i)+t[3]-722521979|0)<<16|r>>>16)+a|0)^a^s)+t[6]+76029189|0)<<23|i>>>9)+r|0,i=((i+=((r=((r+=((a=((a+=((s=((s+=(i^r^a)+t[9]-640364487|0)<<4|s>>>28)+i|0)^i^r)+t[12]-421815835|0)<<11|a>>>21)+s|0)^s^i)+t[15]+530742520|0)<<16|r>>>16)+a|0)^a^s)+t[2]-995338651|0)<<23|i>>>9)+r|0,i=((i+=((a=((a+=(i^((s=((s+=(r^(i|~a))+t[0]-198630844|0)<<6|s>>>26)+i|0)|~r))+t[7]+1126891415|0)<<10|a>>>22)+s|0)^((r=((r+=(s^(a|~i))+t[14]-1416354905|0)<<15|r>>>17)+a|0)|~s))+t[5]-57434055|0)<<21|i>>>11)+r|0,i=((i+=((a=((a+=(i^((s=((s+=(r^(i|~a))+t[12]+1700485571|0)<<6|s>>>26)+i|0)|~r))+t[3]-1894986606|0)<<10|a>>>22)+s|0)^((r=((r+=(s^(a|~i))+t[10]-1051523|0)<<15|r>>>17)+a|0)|~s))+t[1]-2054922799|0)<<21|i>>>11)+r|0,i=((i+=((a=((a+=(i^((s=((s+=(r^(i|~a))+t[8]+1873313359|0)<<6|s>>>26)+i|0)|~r))+t[15]-30611744|0)<<10|a>>>22)+s|0)^((r=((r+=(s^(a|~i))+t[6]-1560198380|0)<<15|r>>>17)+a|0)|~s))+t[13]+1309151649|0)<<21|i>>>11)+r|0,i=((i+=((a=((a+=(i^((s=((s+=(r^(i|~a))+t[4]-145523070|0)<<6|s>>>26)+i|0)|~r))+t[11]-1120210379|0)<<10|a>>>22)+s|0)^((r=((r+=(s^(a|~i))+t[2]+718787259|0)<<15|r>>>17)+a|0)|~s))+t[9]-343485551|0)<<21|i>>>11)+r|0,e[0]=s+e[0]|0,e[1]=i+e[1]|0,e[2]=r+e[2]|0,e[3]=a+e[3]|0}function a(e){var t,s=[];for(t=0;t<64;t+=4)s[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return s}const o=new Uint32Array([1732584193,-271733879,-1732584194,271733878]);class n extends i.Vw{constructor(){super(...arguments),this.blockLen=64,this.outputLen=16,this._buffer=new Uint8Array}digest(){const e=function(e){var t,s,i,n,d,h,c=e.length,l=new Uint32Array(o);for(t=64;t<=c;t+=64)r(l,a(e.subarray(t-64,t)));for(s=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<s;t+=1)i[t>>2]|=e[t]<<(t%4<<3);if(i[t>>2]|=128<<(t%4<<3),t>55)for(r(l,i),t=0;t<16;t+=1)i[t]=0;n=(n=8*c).toString(16).match(/(.*?)(.{0,8})$/),d=parseInt(n[2],16),h=parseInt(n[1],16)||0,i[14]=d,i[15]=h,r(l,i);const u=new Uint8Array(4*l.length);for(let e=0;e<i.length;e++){const t=4*e;u[t]=255&l[e],u[t+1]=l[e]>>8&255,u[t+2]=l[e]>>16&255,u[t+3]=l[e]>>24}return u}(this._buffer);return this.destroy(),e}digestInto(e){const t=this.digest();for(let s=0;s<t.length;s++)e[s]=t[s]}_cloneInto(e){return this}destroy(){this._buffer=new Uint8Array}update(e){return this._buffer=(0,i.Id)(this._buffer,(0,i.ZJ)(e)),this}}let d;d=(0,i.ld)((()=>new n))},3466:(e,t,s)=>{s.d(t,{e:()=>c});var i=s(230),r=s(1094);const a=(e,t)=>e<<t|e>>>32-t>>>0,o=(e,t,s)=>e&t^e&s^t&s,n=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),d=new Uint32Array(80);class h extends i.D{constructor(){super(64,20,8,!1),this.A=0|n[0],this.B=0|n[1],this.C=0|n[2],this.D=0|n[3],this.E=0|n[4]}get(){const{A:e,B:t,C:s,D:i,E:r}=this;return[e,t,s,i,r]}set(e,t,s,i,r){this.A=0|e,this.B=0|t,this.C=0|s,this.D=0|i,this.E=0|r}process(e,t){for(let s=0;s<16;s++,t+=4)d[s]=e.getUint32(t,!1);for(let e=16;e<80;e++)d[e]=a(d[e-3]^d[e-8]^d[e-14]^d[e-16],1);let{A:s,B:i,C:r,D:n,E:h}=this;for(let e=0;e<80;e++){let t,l;e<20?(t=(c=i)&r^~c&n,l=1518500249):e<40?(t=i^r^n,l=1859775393):e<60?(t=o(i,r,n),l=2400959708):(t=i^r^n,l=3395469782);const u=a(s,5)+t+h+l+d[e]|0;h=n,n=r,r=a(i,30),i=s,s=u}var c;s=s+this.A|0,i=i+this.B|0,r=r+this.C|0,n=n+this.D|0,h=h+this.E|0,this.set(s,i,r,n,h)}roundClean(){d.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}}const c=(0,r.ld)((()=>new h))},4852:(e,t,s)=>{s.d(t,{s:()=>l});var i=s(230),r=s(1094);const a=(e,t,s)=>e&t^e&s^t&s,o=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),n=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),d=new Uint32Array(64);class h extends i.D{constructor(){super(64,32,8,!1),this.A=0|n[0],this.B=0|n[1],this.C=0|n[2],this.D=0|n[3],this.E=0|n[4],this.F=0|n[5],this.G=0|n[6],this.H=0|n[7]}get(){const{A:e,B:t,C:s,D:i,E:r,F:a,G:o,H:n}=this;return[e,t,s,i,r,a,o,n]}set(e,t,s,i,r,a,o,n){this.A=0|e,this.B=0|t,this.C=0|s,this.D=0|i,this.E=0|r,this.F=0|a,this.G=0|o,this.H=0|n}process(e,t){for(let s=0;s<16;s++,t+=4)d[s]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=d[e-15],s=d[e-2],i=(0,r.Ow)(t,7)^(0,r.Ow)(t,18)^t>>>3,a=(0,r.Ow)(s,17)^(0,r.Ow)(s,19)^s>>>10;d[e]=a+d[e-7]+i+d[e-16]|0}let{A:s,B:i,C:n,D:h,E:c,F:l,G:u,H:p}=this;for(let e=0;e<64;e++){const t=p+((0,r.Ow)(c,6)^(0,r.Ow)(c,11)^(0,r.Ow)(c,25))+((f=c)&l^~f&u)+o[e]+d[e]|0,m=((0,r.Ow)(s,2)^(0,r.Ow)(s,13)^(0,r.Ow)(s,22))+a(s,i,n)|0;p=u,u=l,l=c,c=h+t|0,h=n,n=i,i=s,s=t+m|0}var f;s=s+this.A|0,i=i+this.B|0,n=n+this.C|0,h=h+this.D|0,c=c+this.E|0,l=l+this.F|0,u=u+this.G|0,p=p+this.H|0,this.set(s,i,n,h,c,l,u,p)}roundClean(){d.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class c extends h{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const l=(0,r.ld)((()=>new h));(0,r.ld)((()=>new c))},8432:(e,t,s)=>{s.d(t,{lY:()=>S});var i=s(9024),r=s(6157),a=s(1094);const[o,n,d]=[[],[],[]],h=BigInt(0),c=BigInt(1),l=BigInt(2),u=BigInt(7),p=BigInt(256),f=BigInt(113);for(let e=0,t=c,s=1,i=0;e<24;e++){[s,i]=[i,(2*s+3*i)%5],o.push(2*(5*i+s)),n.push((e+1)*(e+2)/2%64);let r=h;for(let e=0;e<7;e++)t=(t<<c^(t>>u)*f)%p,t&l&&(r^=c<<(c<<BigInt(e))-c);d.push(r)}const[m,g]=r.Ay.split(d,!0),v=(e,t,s)=>s>32?r.Ay.rotlBH(e,t,s):r.Ay.rotlSH(e,t,s),y=(e,t,s)=>s>32?r.Ay.rotlBL(e,t,s):r.Ay.rotlSL(e,t,s);class w extends a.Vw{constructor(e,t,s,r=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=s,this.enableXOF=r,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,i.Ay.number(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,a.DH)(this.state)}keccak(){!function(e,t=24){const s=new Uint32Array(10);for(let i=24-t;i<24;i++){for(let t=0;t<10;t++)s[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const i=(t+8)%10,r=(t+2)%10,a=s[r],o=s[r+1],n=v(a,o,1)^s[i],d=y(a,o,1)^s[i+1];for(let s=0;s<50;s+=10)e[t+s]^=n,e[t+s+1]^=d}let t=e[2],r=e[3];for(let s=0;s<24;s++){const i=n[s],a=v(t,r,i),d=y(t,r,i),h=o[s];t=e[h],r=e[h+1],e[h]=a,e[h+1]=d}for(let t=0;t<50;t+=10){for(let i=0;i<10;i++)s[i]=e[t+i];for(let i=0;i<10;i++)e[t+i]^=~s[(i+2)%10]&s[(i+4)%10]}e[0]^=m[i],e[1]^=g[i]}s.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){i.Ay.exists(this);const{blockLen:t,state:s}=this,r=(e=(0,a.ZJ)(e)).length;for(let i=0;i<r;){const a=Math.min(t-this.pos,r-i);for(let t=0;t<a;t++)s[this.pos++]^=e[i++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:s,blockLen:i}=this;e[s]^=t,0!=(128&t)&&s===i-1&&this.keccak(),e[i-1]^=128,this.keccak()}writeInto(e){i.Ay.exists(this,!1),i.Ay.bytes(e),this.finish();const t=this.state,{blockLen:s}=this;for(let i=0,r=e.length;i<r;){this.posOut>=s&&this.keccak();const a=Math.min(s-this.posOut,r-i);e.set(t.subarray(this.posOut,this.posOut+a),i),this.posOut+=a,i+=a}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return i.Ay.number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(i.Ay.output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:s,outputLen:i,rounds:r,enableXOF:a}=this;return e||(e=new w(t,s,i,a,r)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=r,e.suffix=s,e.outputLen=i,e.enableXOF=a,e.destroyed=this.destroyed,e}}const b=(e,t,s)=>(0,a.ld)((()=>new w(t,e,s))),S=(b(6,144,28),b(6,136,32),b(6,104,48),b(6,72,64),b(1,144,28),b(1,136,32)),k=(b(1,104,48),b(1,72,64),(e,t,s)=>(0,a.t6)(((i={})=>new w(t,e,void 0===i.dkLen?s:i.dkLen,!0))));k(31,168,16),k(31,136,32)},7481:(e,t,s)=>{s.d(t,{Zf:()=>f,qt:()=>m});var i=s(230),r=s(6157),a=s(1094);const[o,n]=r.Ay.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))),d=new Uint32Array(80),h=new Uint32Array(80);class c extends i.D{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:s,Bl:i,Ch:r,Cl:a,Dh:o,Dl:n,Eh:d,El:h,Fh:c,Fl:l,Gh:u,Gl:p,Hh:f,Hl:m}=this;return[e,t,s,i,r,a,o,n,d,h,c,l,u,p,f,m]}set(e,t,s,i,r,a,o,n,d,h,c,l,u,p,f,m){this.Ah=0|e,this.Al=0|t,this.Bh=0|s,this.Bl=0|i,this.Ch=0|r,this.Cl=0|a,this.Dh=0|o,this.Dl=0|n,this.Eh=0|d,this.El=0|h,this.Fh=0|c,this.Fl=0|l,this.Gh=0|u,this.Gl=0|p,this.Hh=0|f,this.Hl=0|m}process(e,t){for(let s=0;s<16;s++,t+=4)d[s]=e.getUint32(t),h[s]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|d[e-15],s=0|h[e-15],i=r.Ay.rotrSH(t,s,1)^r.Ay.rotrSH(t,s,8)^r.Ay.shrSH(t,s,7),a=r.Ay.rotrSL(t,s,1)^r.Ay.rotrSL(t,s,8)^r.Ay.shrSL(t,s,7),o=0|d[e-2],n=0|h[e-2],c=r.Ay.rotrSH(o,n,19)^r.Ay.rotrBH(o,n,61)^r.Ay.shrSH(o,n,6),l=r.Ay.rotrSL(o,n,19)^r.Ay.rotrBL(o,n,61)^r.Ay.shrSL(o,n,6),u=r.Ay.add4L(a,l,h[e-7],h[e-16]),p=r.Ay.add4H(u,i,c,d[e-7],d[e-16]);d[e]=0|p,h[e]=0|u}let{Ah:s,Al:i,Bh:a,Bl:c,Ch:l,Cl:u,Dh:p,Dl:f,Eh:m,El:g,Fh:v,Fl:y,Gh:w,Gl:b,Hh:S,Hl:k}=this;for(let e=0;e<80;e++){const t=r.Ay.rotrSH(m,g,14)^r.Ay.rotrSH(m,g,18)^r.Ay.rotrBH(m,g,41),O=r.Ay.rotrSL(m,g,14)^r.Ay.rotrSL(m,g,18)^r.Ay.rotrBL(m,g,41),T=m&v^~m&w,P=g&y^~g&b,I=r.Ay.add5L(k,O,P,n[e],h[e]),x=r.Ay.add5H(I,S,t,T,o[e],d[e]),A=0|I,M=r.Ay.rotrSH(s,i,28)^r.Ay.rotrBH(s,i,34)^r.Ay.rotrBH(s,i,39),C=r.Ay.rotrSL(s,i,28)^r.Ay.rotrBL(s,i,34)^r.Ay.rotrBL(s,i,39),E=s&a^s&l^a&l,_=i&c^i&u^c&u;S=0|w,k=0|b,w=0|v,b=0|y,v=0|m,y=0|g,({h:m,l:g}=r.Ay.add(0|p,0|f,0|x,0|A)),p=0|l,f=0|u,l=0|a,u=0|c,a=0|s,c=0|i;const B=r.Ay.add3L(A,C,_);s=r.Ay.add3H(B,x,M,E),i=0|B}({h:s,l:i}=r.Ay.add(0|this.Ah,0|this.Al,0|s,0|i)),({h:a,l:c}=r.Ay.add(0|this.Bh,0|this.Bl,0|a,0|c)),({h:l,l:u}=r.Ay.add(0|this.Ch,0|this.Cl,0|l,0|u)),({h:p,l:f}=r.Ay.add(0|this.Dh,0|this.Dl,0|p,0|f)),({h:m,l:g}=r.Ay.add(0|this.Eh,0|this.El,0|m,0|g)),({h:v,l:y}=r.Ay.add(0|this.Fh,0|this.Fl,0|v,0|y)),({h:w,l:b}=r.Ay.add(0|this.Gh,0|this.Gl,0|w,0|b)),({h:S,l:k}=r.Ay.add(0|this.Hh,0|this.Hl,0|S,0|k)),this.set(s,i,a,c,l,u,p,f,m,g,v,y,w,b,S,k)}roundClean(){d.fill(0),h.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class l extends c{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class u extends c{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class p extends c{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const f=(0,a.ld)((()=>new c)),m=((0,a.ld)((()=>new l)),(0,a.ld)((()=>new u)),(0,a.ld)((()=>new p)))},1094:(e,t,s)=>{s.d(t,{AI:()=>n,DH:()=>r,Id:()=>h,O8:()=>a,Ow:()=>o,Vw:()=>c,ZJ:()=>d,ld:()=>l,po:()=>p,t6:()=>u});var i=s(806);
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const r=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),a=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),o=(e,t)=>e<<32-t|e>>>t;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function n(e){if("string"!=typeof e)throw new TypeError("utf8ToBytes expected string, got "+typeof e);return(new TextEncoder).encode(e)}function d(e){if("string"==typeof e&&(e=n(e)),!(e instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);return e}function h(...e){if(!e.every((e=>e instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===e.length)return e[0];const t=e.reduce(((e,t)=>e+t.length),0),s=new Uint8Array(t);for(let t=0,i=0;t<e.length;t++){const r=e[t];s.set(r,i),i+=r.length}return s}class c{clone(){return this._cloneInto()}}function l(e){const t=t=>e().update(d(t)).digest(),s=e();return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=()=>e(),t}function u(e){const t=(t,s)=>e(s).update(d(t)).digest(),s=e({});return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=t=>e(t),t}function p(e=32){if(i.E&&"function"==typeof i.E.getRandomValues)return i.E.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}},4710:(e,t,s)=>{
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function i(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function r(...e){const t=(e,t)=>s=>e(t(s));return{encode:Array.from(e).reverse().reduce(((e,s)=>e?t(e,s.encode):s.encode),void 0),decode:e.reduce(((e,s)=>e?t(e,s.decode):s.decode),void 0)}}function a(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("alphabet.encode input should be an array of numbers");return t.map((t=>{if(i(t),t<0||t>=e.length)throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);return e[t]}))},decode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("alphabet.decode input should be array of strings");return t.map((t=>{if("string"!=typeof t)throw new Error(`alphabet.decode: not string element=${t}`);const s=e.indexOf(t);if(-1===s)throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);return s}))}}}function o(e=""){if("string"!=typeof e)throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("join.encode input should be array of strings");for(let e of t)if("string"!=typeof e)throw new Error(`join.encode: non-string input=${e}`);return t.join(e)},decode:t=>{if("string"!=typeof t)throw new Error("join.decode input should be string");return t.split(e)}}}function n(e,t="="){if(i(e),"string"!=typeof t)throw new Error("padding chr should be string");return{encode(s){if(!Array.isArray(s)||s.length&&"string"!=typeof s[0])throw new Error("padding.encode input should be array of strings");for(let e of s)if("string"!=typeof e)throw new Error(`padding.encode: non-string input=${e}`);for(;s.length*e%8;)s.push(t);return s},decode(s){if(!Array.isArray(s)||s.length&&"string"!=typeof s[0])throw new Error("padding.encode input should be array of strings");for(let e of s)if("string"!=typeof e)throw new Error(`padding.decode: non-string input=${e}`);let i=s.length;if(i*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;i>0&&s[i-1]===t;i--)if(!((i-1)*e%8))throw new Error("Invalid padding: string has too much padding");return s.slice(0,i)}}}function d(e){if("function"!=typeof e)throw new Error("normalize fn should be function");return{encode:e=>e,decode:t=>e(t)}}function h(e,t,s){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(s<2)throw new Error(`convertRadix: wrong to=${s}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let r=0;const a=[],o=Array.from(e);for(o.forEach((e=>{if(i(e),e<0||e>=t)throw new Error(`Wrong integer: ${e}`)}));;){let e=0,i=!0;for(let a=r;a<o.length;a++){const n=o[a],d=t*e+n;if(!Number.isSafeInteger(d)||t*e/t!==e||d-n!=t*e)throw new Error("convertRadix: carry overflow");if(e=d%s,o[a]=Math.floor(d/s),!Number.isSafeInteger(o[a])||o[a]*s+e!==d)throw new Error("convertRadix: carry overflow");i&&(o[a]?i=!1:r=a)}if(a.push(e),i)break}for(let t=0;t<e.length-1&&0===e[t];t++)a.push(0);return a.reverse()}s.d(t,{As:()=>I,K3:()=>y,RG:()=>v,tw:()=>b,xn:()=>g});const c=(e,t)=>t?c(t,e%t):e,l=(e,t)=>e+(t-c(e,t));function u(e,t,s,r){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(s<=0||s>32)throw new Error(`convertRadix2: wrong to=${s}`);if(l(t,s)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${s} carryBits=${l(t,s)}`);let a=0,o=0;const n=2**s-1,d=[];for(const r of e){if(i(r),r>=2**t)throw new Error(`convertRadix2: invalid data word=${r} from=${t}`);if(a=a<<t|r,o+t>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);for(o+=t;o>=s;o-=s)d.push((a>>o-s&n)>>>0);a&=2**o-1}if(a=a<<s-o&n,!r&&o>=t)throw new Error("Excess padding");if(!r&&a)throw new Error(`Non-zero padding: ${a}`);return r&&o>0&&d.push(a>>>0),d}function p(e){return i(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return h(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of strings");return Uint8Array.from(h(t,e,256))}}}function f(e,t=!1){if(i(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(l(8,e)>32||l(e,8)>32)throw new Error("radix2: carry overflow");return{encode:s=>{if(!(s instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return u(Array.from(s),8,e,!t)},decode:s=>{if(!Array.isArray(s)||s.length&&"number"!=typeof s[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(u(s,e,8,t))}}}function m(e){if("function"!=typeof e)throw new Error("unsafeWrapper fn should be function");return function(...t){try{return e.apply(null,t)}catch(e){}}}const g=r(f(4),a("0123456789abcdef"),o("")),v=r(f(5),a("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),n(5),o("")),y=(r(f(5),a("0123456789ABCDEFGHIJKLMNOPQRSTUV"),n(5),o("")),r(f(5),a("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),o(""),d((e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")))),r(f(6),a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),n(6),o(""))),w=(r(f(6),a("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),n(6),o("")),e=>r(p(58),a(e),o(""))),b=w("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),S=(w("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),w("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),r(a("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),o(""))),k=[996825010,642813549,513874426,1027748829,705979059];function O(e){const t=e>>25;let s=(33554431&e)<<5;for(let e=0;e<k.length;e++)1==(t>>e&1)&&(s^=k[e]);return s}function T(e,t,s=1){const i=e.length;let r=1;for(let t=0;t<i;t++){const s=e.charCodeAt(t);if(s<33||s>126)throw new Error(`Invalid prefix (${e})`);r=O(r)^s>>5}r=O(r);for(let t=0;t<i;t++)r=O(r)^31&e.charCodeAt(t);for(let e of t)r=O(r)^e;for(let e=0;e<6;e++)r=O(r);return r^=s,S.encode(u([r%2**30],30,5,!1))}function P(e){const t="bech32"===e?1:734539939,s=f(5),i=s.decode,r=s.encode,a=m(i);function o(e,s=90){if("string"!=typeof e)throw new Error("bech32.decode input should be string, not "+typeof e);if(e.length<8||!1!==s&&e.length>s)throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${s})`);const i=e.toLowerCase();if(e!==i&&e!==e.toUpperCase())throw new Error("String must be lowercase or uppercase");const r=(e=i).lastIndexOf("1");if(0===r||-1===r)throw new Error('Letter "1" must be present between prefix and data only');const a=e.slice(0,r),o=e.slice(r+1);if(o.length<6)throw new Error("Data must be at least 6 characters long");const n=S.decode(o).slice(0,-6),d=T(a,n,t);if(!o.endsWith(d))throw new Error(`Invalid checksum in ${e}: expected "${d}"`);return{prefix:a,words:n}}return{encode:function(e,s,i=90){if("string"!=typeof e)throw new Error("bech32.encode prefix should be string, not "+typeof e);if(!Array.isArray(s)||s.length&&"number"!=typeof s[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof s);const r=e.length+7+s.length;if(!1!==i&&r>i)throw new TypeError(`Length ${r} exceeds limit ${i}`);return`${e=e.toLowerCase()}1${S.encode(s)}${T(e,s,t)}`},decode:o,decodeToBytes:function(e){const{prefix:t,words:s}=o(e,!1);return{prefix:t,words:s,bytes:i(s)}},decodeUnsafe:m(o),fromWords:i,fromWordsUnsafe:a,toWords:r}}P("bech32"),P("bech32m");const I={encode:e=>(new TextDecoder).decode(e),decode:e=>(new TextEncoder).encode(e)};r(f(4),a("0123456789abcdef"),o(""),d((e=>{if("string"!=typeof e||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})))},3187:(e,t,s)=>{s.d(t,{$u:()=>x,Dq:()=>L,Ef:()=>G,NO:()=>N,_S:()=>b,b:()=>A,pd:()=>H});var i=s(8432),r=s(4852),a=s(1094),o=s(1064),n=s(1357),d=s(2442),h=s(191),c=s(1999);
/*! scure-starknet - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const l=BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583"),u=BigInt("0x800000000000000000000000000000000000000000000000000000000000000");function p(e){for(;0===e[0];)e=e.subarray(1);const t=8*e.length-252,s=h.Ph(e);return t>0?s>>BigInt(t):s}function f(e){return"string"==typeof e&&1&(e=I(e)).length&&(e="0"+e),h.aT(e)}const m=(0,d.x3)({a:BigInt(1),b:BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),Fp:(0,o.Fp)(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),n:l,nBitLength:252,Gx:BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),Gy:BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),h:BigInt(1),lowS:!1,...(0,c.Z)(r.s),bits2int:p,bits2int_modN:e=>{const t=h.Ph(e).toString(16);return 63===t.length&&(e=f(t+"0")),(0,o.zi)(p(e),l)}});function g(e){return h.qj("","string"==typeof e?f(e):e)}function v(e){return h.My(g(e)).padStart(64,"0")}function y(e){const{r:t,s}=e;if(t<0n||t>=u)throw new Error(`Signature.r should be [1, ${u})`);const i=(0,o.B8)(s,l);if(i<0n||i>=u)throw new Error(`inv(Signature.s) should be [1, ${u})`)}function w(e){const t=g(e);if(h.Ph(t)>=u)throw new Error(`msgHash should be [0, ${u})`);return t}function b(e,t,s){const i=m.sign(w(e),v(t),s);return y(i),i}const{CURVE:S,ProjectivePoint:k,Signature:O,utils:T}=m;function P(e){return`0x${h.My(e.subarray(1)).replace(/^0+/gm,"")}`}function I(e){return e.replace(/^0x/i,"")}function x(e){return P(function(e,t=!1){return m.getPublicKey(v(e),t)}(e,!0))}function A(e){if(130!==(e=I(e)).length)throw new Error("Wrong ethereum signature");return function(e){const t=g(e),s=2n**256n,i=s-(0,o.zi)(s,l);for(let e=0;;e++){const s=V(h.Id(t,h.IV(BigInt(e))));if(s<i)return(0,o.zi)(s,l).toString(16);if(1e5===e)throw new Error("grindKey is broken: tried 100k vals")}}(e.substring(0,64))}const M=[new k(2089986280348253421170679821480865132823066470938446095505822317253594081284n,1713931329540660377023406109199410414810705867260802078187082345529207694986n,1n),new k(996781205833008774514500082376783249102396023663454813447423147977397232763n,1668503676786377725805489344771023921079126552019160156920634619255970485781n,1n),new k(2251563274489750535117886426533222435294046428347329203627021249169616184184n,1798716007562728905295480679789526322175868328062420237419143593021674992973n,1n),new k(2138414695194151160943305727036575959195309218611738193261179310511854807447n,113410276730064486255102093846540133784865286929052426931474106396135072156n,1n),new k(2379962749567351885752724891227938183011949129833673362440656643086021394946n,776496453633298175483985398648758586525933812536653089401905292063708816422n,1n)];function C(e,t){const s=[];let i=e;for(let e=0;e<248;e++)s.push(i),i=i.double();i=t;for(let e=0;e<4;e++)s.push(i),i=i.double();return s}const E=C(M[1],M[2]),_=C(M[3],M[4]);function B(e,t,s){let i=function(e){let t;if("bigint"==typeof e)t=e;else if("number"==typeof e){if(!Number.isSafeInteger(e))throw new Error(`Invalid pedersenArg: ${e}`);t=BigInt(e)}else t=h.Ph(g(e));if(!(0n<=t&&t<m.CURVE.Fp.ORDER))throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${t}`);return t}(t);for(let t=0;t<252;t++){const r=s[t];if(!r)throw new Error("invalid constant index");if(r.equals(e))throw new Error("Same point");0n!==(1n&i)&&(e=e.add(r)),i>>=1n}return e}function N(e,t){let s=M[0];return s=B(s,e,E),s=B(s,t,_),P(s.toRawBytes(!0))}const R=h.OG(250),L=e=>h.Ph((0,i.lY)(e))&R,V=e=>h.Ph((0,r.s)(e));function D(e,t,s){const i=e.fromBytes((0,r.s)((0,a.AI)(`${t}${s}`)));return e.create(i)}function q(e,t){if((0,o.jr)(e.Fp),!Number.isSafeInteger(e.rate)||!Number.isSafeInteger(e.capacity))throw new Error(`Wrong poseidon opts: ${e}`);const s=e.rate+e.capacity,i=e.roundsFull+e.roundsPartial,r=[];for(let t=0;t<i;t++){const i=[];for(let r=0;r<s;r++)i.push(D(e.Fp,"Hades",s*t+r));r.push(i)}const a=(0,n.sN)({...e,t:s,sboxPower:3,reversePartialPowIdx:!0,mds:t,roundConstants:r});return a.m=s,a.rate=e.rate,a.capacity=e.capacity,a}const F=q({Fp:(0,o.Fp)(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481")),rate:2,capacity:1,roundsFull:8,roundsPartial:83},[[3,1,1],[1,-1,1],[1,1,-2]].map((e=>e.map(BigInt))));function G(e,t,s=F){return s([e,t,2n])[0]}function H(e,t=F){const{m:s,rate:i}=t;if(!Array.isArray(e))throw new Error("bigint array expected in values");const r=Array.from(e);for(r.push(1n);r.length%i!=0;)r.push(0n);let a=new Array(s).fill(0n);for(let e=0;e<r.length;e+=i){for(let t=0;t<i;t++){const s=r[e+t];if(void 0===s)throw new Error("invalid index");a[t]+=s}a=t(a)}return a[0]}},8325:(e,t,s)=>{s.d(t,{He:()=>c,Kp:()=>h,Vi:()=>n,bE:()=>l,n$:()=>a,p7:()=>i,s9:()=>o});const i=31,r=0n,a=2n**250n-1n,o=2n**251n+17n*2n**192n+1n,n=2n**251n-256n,d=(e,t)=>({min:e,max:t}),h=d(r,o-1n),c=d(-(2n**127n),2n**127n-1n),l=d(r,2n**128n-1n);var u,p,f,m;!function(e){e.SN_MAIN="https://alpha-mainnet.starknet.io",e.SN_SEPOLIA="https://alpha-sepolia.starknet.io"}(u||(u={})),function(e){e.SN_MAIN="SN_MAIN",e.SN_SEPOLIA="SN_SEPOLIA"}(p||(p={})),function(e){e.SN_MAIN="0x534e5f4d41494e",e.SN_SEPOLIA="0x534e5f5345504f4c4941"}(f||(f={})),function(e){e.DECLARE="0x6465636c617265",e.DEPLOY="0x6465706c6f79",e.DEPLOY_ACCOUNT="0x6465706c6f795f6163636f756e74",e.INVOKE="0x696e766f6b65",e.L1_HANDLER="0x6c315f68616e646c6572"}(m||(m={}))},40:(e,t,s)=>{var i,r,a;s.d(t,{Fg:()=>r,fE:()=>i,uS:()=>a}),function(e){e.DEPLOY="DEPLOY",e.CALL="CALL",e.INVOKE="INVOKE"}(i||(i={})),function(e){e.u8="core::integer::u8",e.u16="core::integer::u16",e.u32="core::integer::u32",e.u64="core::integer::u64",e.u128="core::integer::u128",e.u256="core::integer::u256",e.u512="core::integer::u512"}(r||(r={})),function(e){e.ClassHash="core::starknet::class_hash::ClassHash",e.ContractAddress="core::starknet::contract_address::ContractAddress",e.Secp256k1Point="core::starknet::secp256k1::Secp256k1Point"}(a||(a={}))},162:(e,t,s)=>{s.d(t,{K:()=>i});const i={Active:"1",Legacy:"0"}},9550:(e,t,s)=>{function i(e,t){if(!e)throw new Error(t||"Assertion failure")}s.d(t,{A:()=>i})},4921:(e,t,s)=>{s.d(t,{e:()=>a});var i=s(1686),r=s(7925);function a(e){if((0,i.sI)(e)||Number.isInteger(e))return e.toString();if((0,r.Kg)(e)){if((0,i.qv)(e))return BigInt(e).toString();if((0,r.KH)(e)){if(!(0,r.O4)(e))throw new Error(`${e} is a long string > 31 chars. Please split it into an array of short strings.`);return BigInt((0,r.Mu)(e)).toString()}if((0,i.A6)(e))return e}if((0,i.Lm)(e))return""+ +e;throw new Error(`${e} can't be computed by felt()`)}},3283:(e,t,s)=>{s.d(t,{is:()=>u,wO:()=>a});var i=s(178),r=s(4921);const a=(1n<<128n)-1n,o=(1n<<256n)-1n,n=0n,d=340282366920938463463374607431768211455n,h=340282366920938463463374607431768211455n,c=0n,l=0n;class u{constructor(...e){if("object"==typeof e[0]&&1===e.length&&"low"in e[0]&&"high"in e[0]){const t=u.validateProps(e[0].low,e[0].high);this.low=t.low,this.high=t.high}else if(1===e.length){const t=u.validate(e[0]);this.low=t&a,this.high=t>>128n}else{if(2!==e.length)throw Error("Incorrect constructor parameters");{const t=u.validateProps(e[0],e[1]);this.low=t.low,this.high=t.high}}}static validate(e){const t=BigInt(e);if(t<n)throw Error("bigNumberish is smaller than UINT_256_MIN");if(t>o)throw new Error("bigNumberish is bigger than UINT_256_MAX");return t}static validateProps(e,t){const s=BigInt(e),i=BigInt(t);if(s<c||s>d)throw new Error("low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX");if(i<l||i>h)throw new Error("high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX");return{low:s,high:i}}static is(e){try{u.validate(e)}catch(e){return!1}return!0}static isAbiType(e){return e===u.abiSelector}toBigInt(){return(this.high<<128n)+this.low}toUint256HexString(){return{low:(0,i.VO)(this.low.toString(16)),high:(0,i.VO)(this.high.toString(16))}}toUint256DecimalString(){return{low:this.low.toString(10),high:this.high.toString(10)}}toApiRequest(){return[(0,r.e)(this.low),(0,r.e)(this.high)]}}u.abiSelector="core::integer::u256"},274:(e,t,s)=>{s.d(t,{Ns:()=>h});var i=s(178),r=s(4921),a=s(3283);const o=(1n<<512n)-1n,n=0n,d=0n;class h{constructor(...e){if("object"==typeof e[0]&&1===e.length&&"limb0"in e[0]&&"limb1"in e[0]&&"limb2"in e[0]&&"limb3"in e[0]){const t=h.validateProps(e[0].limb0,e[0].limb1,e[0].limb2,e[0].limb3);this.limb0=t.limb0,this.limb1=t.limb1,this.limb2=t.limb2,this.limb3=t.limb3}else if(1===e.length){const t=h.validate(e[0]);this.limb0=t&a.wO,this.limb1=(t&a.wO<<128n)>>128n,this.limb2=(t&a.wO<<256n)>>256n,this.limb3=t>>384n}else{if(4!==e.length)throw Error("Incorrect Uint512 constructor parameters");{const t=h.validateProps(e[0],e[1],e[2],e[3]);this.limb0=t.limb0,this.limb1=t.limb1,this.limb2=t.limb2,this.limb3=t.limb3}}}static validate(e){const t=BigInt(e);if(t<n)throw Error("bigNumberish is smaller than UINT_512_MIN.");if(t>o)throw Error("bigNumberish is bigger than UINT_512_MAX.");return t}static validateProps(e,t,s,i){const r=BigInt(e),o=BigInt(t),n=BigInt(s),h=BigInt(i);return[r,o,n,h].forEach(((e,t)=>{if(e<d||e>a.wO)throw Error(`limb${t} is not in the range of a u128 number`)})),{limb0:r,limb1:o,limb2:n,limb3:h}}static is(e){try{h.validate(e)}catch(e){return!1}return!0}static isAbiType(e){return e===h.abiSelector}toBigInt(){return(this.limb3<<384n)+(this.limb2<<256n)+(this.limb1<<128n)+this.limb0}toUint512HexString(){return{limb0:(0,i.VO)(this.limb0.toString(16)),limb1:(0,i.VO)(this.limb1.toString(16)),limb2:(0,i.VO)(this.limb2.toString(16)),limb3:(0,i.VO)(this.limb3.toString(16))}}toUint512DecimalString(){return{limb0:this.limb0.toString(10),limb1:this.limb1.toString(10),limb2:this.limb2.toString(10),limb3:this.limb3.toString(10)}}toApiRequest(){return[(0,r.e)(this.limb0),(0,r.e)(this.limb1),(0,r.e)(this.limb2),(0,r.e)(this.limb3)]}}h.abiSelector="core::integer::u512"},2256:(e,t,s)=>{s.d(t,{f:()=>a,p:()=>o});var i=s(1686),r=s(7925);function a(e){const t=0n===BigInt(e.pending_word)?"":(0,r.Wb)((0,i.nj)(e.pending_word));return e.data.reduce(((e,t)=>e+(0n===BigInt(t)?"":(0,r.Wb)((0,i.nj)(t)))),"")+t}function o(e){const t=(0,r.mE)(e),s=t[t.length-1],i=t.map(r.Mu),[a,o]=void 0===s||31===s.length?["0x00",0]:[i.pop(),s.length];return{data:0===i.length?[]:i,pending_word:a,pending_word_len:o}}},5307:(e,t,s)=>{s.d(t,{$H:()=>m,AB:()=>I,CS:()=>O,Fi:()=>v,G$:()=>d,GY:()=>y,Gw:()=>g,Z$:()=>S,Zm:()=>h,ak:()=>b,cl:()=>T,ct:()=>o,e4:()=>p,gr:()=>w,iN:()=>P,iO:()=>u,mQ:()=>c,s8:()=>k,sB:()=>n,u:()=>f,wJ:()=>l});var i=s(40),r=s(4921),a=s(3283);const o=e=>/_len$/.test(e),n=e=>"felt"===e||"core::felt252"===e,d=e=>/\*/.test(e)||e.startsWith("core::array::Array::")||e.startsWith("core::array::Span::"),h=e=>/^\(.*\)$/i.test(e),c=e=>/\(.*\)/i.test(e)&&e.includes(":"),l=(e,t)=>e in t,u=(e,t)=>e in t,p=e=>e.startsWith("core::option::Option::"),f=e=>e.startsWith("core::result::Result::"),m=e=>Object.values(i.Fg).includes(e),g=e=>Object.values(i.uS).includes(e),v=e=>"core::bool"===e,y=e=>"core::starknet::eth_address::EthAddress"===e,w=e=>"core::bytes_31::bytes31"===e,b=e=>"core::byte_array::byteArray.js"===e,S=e=>"core::starknet::secp256k1::Secp256k1Point"===e,k=e=>e.includes("::"),O=e=>k(e)?e.substring(e.indexOf("<")+1,e.lastIndexOf(">")):e.replace("*","");function T(e){const{cairo:t}=function(e){if(e.find((e=>"interface"===e.type)))return{cairo:"1",compiler:"2"};const t=e.find((e=>"function"===e.type&&(e.inputs.length||e.outputs.length)));if(!t)return{cairo:void 0,compiler:void 0};const s=t.inputs.length?t.inputs:t.outputs;if(k(s[0].type))return{cairo:"1",compiler:"1"};return{cairo:"0",compiler:"0"}}(e);if(void 0===t)throw Error("Unable to determine Cairo version");return"1"===t}const P=e=>new a.is(e).toUint256DecimalString();function I(e){return(0,r.e)(e)}},6863:(e,t,s)=>{s.d(t,{b:()=>i});class i{constructor(e){const t=Object.values(e);if(0===t.length)throw new Error("This Enum must have at least 1 variant");if(1!==t.filter((e=>void 0!==e)).length)throw new Error("This Enum must have exactly one active variant");this.variant=e}unwrap(){const e=Object.entries(this.variant).find((e=>void 0!==e[1]));if(void 0!==e)return e[1]}activeVariant(){const e=Object.entries(this.variant).find((e=>void 0!==e[1]));return void 0===e?"":e[0]}}},9620:(e,t,s)=>{var i;s.d(t,{R:()=>i,c:()=>r}),function(e){e[e.Some=0]="Some",e[e.None=1]="None"}(i||(i={}));class r{constructor(e,t){if(!(e in i))throw new Error("Wrong variant : should be CairoOptionVariant.Some or .None.");if(e===i.Some){if(void 0===t)throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');this.Some=t,this.None=void 0}else this.Some=void 0,this.None=!0}unwrap(){if(!this.None)return this.Some}isSome(){return!(void 0===this.Some)}isNone(){return!0===this.None}}},1668:(e,t,s)=>{var i;s.d(t,{B:()=>i,G:()=>r}),function(e){e[e.Ok=0]="Ok",e[e.Err=1]="Err"}(i||(i={}));class r{constructor(e,t){if(!(e in i))throw new Error("Wrong variant : should be CairoResultVariant.Ok or .Err.");e===i.Ok?(this.Ok=t,this.Err=void 0):(this.Ok=void 0,this.Err=t)}unwrap(){if(void 0!==this.Ok)return this.Ok;if(void 0!==this.Err)return this.Err;throw new Error("Both Result.Ok and .Err are undefined. Not authorized.")}isOk(){return!(void 0===this.Ok)}isErr(){return!(void 0===this.Err)}}},9161:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(1686),r=s(7925);const a={isBN:(e,t,s)=>{if(!(0,i.sI)(e[s]))throw new Error(`Data and formatter mismatch on ${s}:${t[s]}, expected response data ${s}:${e[s]} to be BN instead it is ${typeof e[s]}`)},unknown:(e,t,s)=>{throw new Error(`Unhandled formatter type on ${s}:${t[s]} for data ${s}:${e[s]}`)}};function o(e,t,s){return Object.entries(e).reduce(((i,[n,d])=>{const h=s??t[n];if(!(n in t)&&!s)return i[n]=d,i;if("string"===h){if(Array.isArray(e[n])){const t=o(e[n],e[n].map((e=>h)));return i[n]=Object.values(t).join(""),i}return a.isBN(e,t,n),i[n]=(0,r.Wb)(d),i}if("number"===h)return a.isBN(e,t,n),i[n]=Number(d),i;if("function"==typeof h)return i[n]=h(d),i;if(Array.isArray(h)){const t=o(e[n],h,h[0]);return i[n]=Object.values(t),i}return"object"==typeof h?(i[n]=o(e[n],h),i):(a.unknown(e,t,n),i)}),{})}},6907:(e,t,s)=>{s.d(t,{fP:()=>y});var i=s(40),r=s(9550),a=s(1686),o=s(9793),n=s(7925),d=s(2256),h=s(5307),c=s(9620),l=s(1668),u=s(9161),p=s(591),f=s(916),m=s(4365),g=s(3463),v=s(9873);class y{constructor(e){this.structs=y.getAbiStruct(e),this.enums=y.getAbiEnum(e),this.parser=(0,p.k)(e),this.abi=this.parser.getLegacyFormat()}validate(e,t,s=[]){if(e!==i.fE.DEPLOY){const s=this.abi.filter((t=>{if("function"!==t.type)return!1;const s="view"===t.stateMutability||"view"===t.state_mutability;return e===i.fE.INVOKE?!s:s})).map((e=>e.name));(0,r.A)(s.includes(t),(e===i.fE.INVOKE?"invocable":"viewable")+" method not found in abi")}const a=this.abi.find((s=>e===i.fE.DEPLOY?s.name===t&&"constructor"===s.type:s.name===t&&"function"===s.type));if((0,p.CO)(t,s,a))return;const o=this.parser.methodInputsLength(a);if(s.length!==o)throw Error(`Invalid number of arguments, expected ${o} arguments, but got ${s.length}`);(0,v.A)(a,s,this.structs,this.enums)}compile(e,t){const s=this.abi.find((t=>t.name===e));if((0,p.CO)(e,t,s))return[];let i;if(Array.isArray(t))i=t;else{const e=(0,f.A)(t,s.inputs,this.structs,this.enums);i=Object.values(e),(0,v.A)(s,i,this.structs,this.enums)}const r=i[Symbol.iterator](),a=s.inputs.reduce(((e,t)=>(0,h.ct)(t.name)&&!(0,h.s8)(t.type)?e:e.concat((0,m.A)(r,t,this.structs,this.enums))),[]);return Object.defineProperty(a,"__compiled__",{enumerable:!1,writable:!1,value:!0}),a}static compile(e){const t=e=>{const t=(e,s=".")=>{const i=Array.isArray(e)?[e.length.toString(),...e]:e;return Object.entries(i).flatMap((([e,r])=>{let u=r;"entrypoint"===e?u=(0,o.BK)(u):(0,n.IN)(u)&&(u=(0,d.p)(u));const p=Array.isArray(i)&&"0"===e?"$$len":e;if((0,a.sI)(u))return[[`${s}${p}`,(0,h.AB)(u)]];if(Object(u)===u){const e=Object.getOwnPropertyNames(Object.getPrototypeOf(u)),i=[...Object.getOwnPropertyNames(u),...e];if(i.includes("isSome")&&i.includes("isNone")){const e=u,i=e.isSome()?c.R.Some:c.R.None;return e.isSome()?t({0:i,1:e.unwrap()},`${s}${p}.`):[[`${s}${p}`,(0,h.AB)(i)]]}if(i.includes("isOk")&&i.includes("isErr")){const e=u,i=e.isOk()?l.B.Ok:l.B.Err;return t({0:i,1:e.unwrap()},`${s}${p}.`)}if(i.includes("variant")&&i.includes("activeVariant")){const e=u,i=e.activeVariant(),r=Object.keys(e.variant).findIndex((e=>e===i));return"object"==typeof e.unwrap()&&0===Object.keys(e.unwrap()).length?[[`${s}${p}`,(0,h.AB)(r)]]:t({0:r,1:e.unwrap()},`${s}${p}.`)}return t(u,`${s}${p}.`)}return[[`${s}${p}`,(0,h.AB)(u)]]}))};return Object.fromEntries(t(e))};let s;if(Array.isArray(e)){const i=t({...e});s=Object.values(i)}else{const i=t(e);s=Object.values(i)}return Object.defineProperty(s,"__compiled__",{enumerable:!1,writable:!1,value:!0}),s}parse(e,t){const{outputs:s}=this.abi.find((t=>t.name===e)),i=t.flat()[Symbol.iterator](),r=s.flat().reduce(((e,t,s)=>{const r=t.name??s;return e[r]=(0,g.A)(i,t,this.structs,this.enums,e),e[r]&&e[`${r}_len`]&&delete e[`${r}_len`],e}),{});return 1===Object.keys(r).length&&0 in r?r[0]:r}format(e,t,s){const i=this.parse(e,t);return(0,u.A)(i,s)}static getAbiStruct(e){return e.filter((e=>"struct"===e.type)).reduce(((e,t)=>({...e,[t.name]:t})),{})}static getAbiEnum(e){const t=e.filter((e=>"enum"===e.type)).reduce(((e,t)=>({...e,[t.name]:t})),{});return delete t["core::bool"],t}static toCalldata(e=[]){return y.compile(e)}static toHex(e=[]){return y.compile(e).map((e=>(0,a.nj)(e)))}decodeParameters(e,t){const s=Array.isArray(e)?e:[e],i=t.flat()[Symbol.iterator](),r=s.map((e=>(0,g.A)(i,{name:"",type:e},this.structs,this.enums)));return 1===r.length?r[0]:r}}},591:(e,t,s)=>{s.d(t,{CO:()=>n,k:()=>o});var i=s(5307),r=s(568),a=s(7799);function o(e){const t=function(e){return e.find((e=>"interface"===e.type))?2:(0,i.cl)(e)?1:0}(e);if(0===t||1===t)return new r.V(e);if(2===t)return new a.O(e);throw Error(`Unsupported ABI version ${t}`)}function n(e,t,s){return"constructor"===e&&!s&&!t.length}},568:(e,t,s)=>{s.d(t,{V:()=>r});var i=s(5307);class r{constructor(e){this.abi=e}methodInputsLength(e){return e.inputs.reduce(((e,t)=>(0,i.ct)(t.name)?e:e+1),0)}getMethod(e){return this.abi.find((t=>t.name===e))}getLegacyFormat(){return this.abi}}},7799:(e,t,s)=>{s.d(t,{O:()=>i});class i{constructor(e){this.abi=e}methodInputsLength(e){return e.inputs.length}getMethod(e){return this.abi.find((e=>"interface"===e.type)).items.find((t=>t.name===e))}getLegacyFormat(){return this.abi.flatMap((e=>"interface"===e.type?e.items:e))}}},916:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(3283),r=s(274),a=s(5307),o=s(1668),n=s(9620),d=s(6863),h=s(7593),c=s(7925);function l(e,t,s,l){const u=(e,t)=>{if((0,a.G$)(t))return function(e,t){const s=(0,a.CS)(t);if((0,c.Kg)(e))return e;return e.map((e=>u(e,s)))}(e,t);if((0,a.iO)(t,l)){const s=l[t];return f(e,s)}if((0,a.Zm)(t))return function(e,t){const s=(0,h.A)(t).reduce(((t,s,i)=>{const r=Object.keys(e),a=s=>Object.defineProperty(t,i.toString(),{enumerable:!0,value:s??e[r[i]]}),o=s?.type?s.type:s;return a(u(e[r[i]],o)),t}),{});return s}(e,t);if((0,a.GY)(t))return e;if((0,a.ak)(t))return e;if((0,a.Z$)(t))return e;if(i.is.isAbiType(t)){const s=e;if("object"!=typeof s)return s;if(!("low"in s)||!("high"in s))throw Error(`Your object includes the property : ${t}, containing an Uint256 object without the 'low' and 'high' keys.`);return{low:s.low,high:s.high}}if(r.Ns.isAbiType(t)){const s=e;if("object"!=typeof s)return s;if(!["limb0","limb1","limb2","limb3"].every((e=>e in s)))throw function(e){return Error(`Your object includes the property : ${e}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`)}(t);return{limb0:s.limb0,limb1:s.limb1,limb2:s.limb2,limb3:s.limb3}}if((0,a.wJ)(t,s)){const i=s[t].members;return p(e,i)}return e},p=(e,t)=>t.reduce(((t,s)=>{if("undefined"===e[s.name]&&((0,a.s8)(s.type)||!(0,a.ct)(s.name)))throw Error(`Your object needs a property with key : ${s.name} .`);var i;return i=u(e[s.name],s.type),Object.defineProperty(t,s.name,{enumerable:!0,value:i??e[s.name]}),t}),{});const f=(e,t)=>{if((0,a.u)(t.name)){const s=e,i=t.name.substring(t.name.indexOf("<")+1,t.name.lastIndexOf(",")),r=t.name.substring(t.name.indexOf(",")+1,t.name.lastIndexOf(">"));return s.isOk()?new o.G(o.B.Ok,u(e.unwrap(),i)):new o.G(o.B.Err,u(e.unwrap(),r))}if((0,a.e4)(t.name)){const s=e,i=t.name.substring(t.name.indexOf("<")+1,t.name.lastIndexOf(">"));return s.isSome()?new n.c(n.R.Some,u(s.unwrap(),i)):new n.c(n.R.None,{})}const s=e,i=Object.entries(s.variant).map((e=>{if(void 0===e[1])return e;const i=t.type.substring(t.type.lastIndexOf("<")+1,t.type.lastIndexOf(">"));return"()"===i?e:[e[0],u(s.unwrap(),i)]}));return new d.b(Object.fromEntries(i))};return t.reduce(((t,s)=>{return(0,a.ct)(s.name)&&!(0,a.s8)(s.type)||(i=u(e[s.name],s.type),Object.defineProperty(t,s.name,{enumerable:!0,value:i})),t;var i}),{})}},4365:(e,t,s)=>{s.d(t,{A:()=>m});var i=s(3283),r=s(274),a=s(178),o=s(1686),n=s(7925),d=s(2256),h=s(5307),c=s(9620),l=s(1668),u=s(7593);function p(e,t){switch(!0){case i.is.isAbiType(e):return new i.is(t).toApiRequest();case r.Ns.isAbiType(e):return new r.Ns(t).toApiRequest();case(0,h.gr)(e):return(0,n.Mu)(t.toString());case(0,h.Z$)(e):{const e=(0,a.ow)((0,o.nj)(t)).padStart(128,"0"),s=(0,h.iN)((0,a.VO)(e.slice(-64))),i=(0,h.iN)((0,a.VO)(e.slice(0,-64)));return[(0,h.AB)(i.low),(0,h.AB)(i.high),(0,h.AB)(s.low),(0,h.AB)(s.high)]}default:return(0,h.AB)(t)}}function f(e,t,s,a){if(void 0===e)throw Error(`Missing parameter for type ${t}`);if(Array.isArray(e)){const i=[];i.push((0,h.AB)(e.length));const r=(0,h.CS)(t);return e.reduce(((e,t)=>e.concat(f(t,r,s,a))),i)}if(s[t]&&s[t].members.length){if(i.is.isAbiType(t))return new i.is(e).toApiRequest();if(r.Ns.isAbiType(t))return new r.Ns(e).toApiRequest();if("core::starknet::eth_address::EthAddress"===t)return p(t,e);if("core::byte_array::ByteArray"===t)return function(e){const t=(0,d.p)(e);return[t.data.length.toString(),...t.data.map((e=>e.toString())),t.pending_word.toString(),t.pending_word_len.toString()]}(e);const{members:o}=s[t],n=e;return o.reduce(((e,t)=>e.concat(f(n[t.name],t.type,s,a))),[])}if((0,h.Zm)(t)){const i=function(e,t){const s=(0,u.A)(t),i=Object.values(e);if(i.length!==s.length)throw Error(`ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${i} \n      expected: ${s}`);return s.map(((e,t)=>({element:i[t],type:e.type??e})))}(e,t);return i.reduce(((e,t)=>{const i=f(t.element,t.type,s,a);return e.concat(i)}),[])}if(i.is.isAbiType(t))return new i.is(e).toApiRequest();if(r.Ns.isAbiType(t))return new r.Ns(e).toApiRequest();if((0,h.iO)(t,a)){const{variants:i}=a[t];if((0,h.e4)(t)){const t=e;if(t.isSome()){const e=i.find((e=>"Some"===e.name));if(void 0===e)throw Error("Error in abi : Option has no 'Some' variant.");const r=e.type;if("()"===r)return c.R.Some.toString();const o=f(t.unwrap(),r,s,a);return Array.isArray(o)?[c.R.Some.toString(),...o]:[c.R.Some.toString(),o]}return c.R.None.toString()}if((0,h.u)(t)){const t=e;if(t.isOk()){const e=i.find((e=>"Ok"===e.name));if(void 0===e)throw Error("Error in abi : Result has no 'Ok' variant.");const r=e.type;if("()"===r)return l.B.Ok.toString();const o=f(t.unwrap(),r,s,a);return Array.isArray(o)?[l.B.Ok.toString(),...o]:[l.B.Ok.toString(),o]}const r=i.find((e=>"Err"===e.name));if(void 0===r)throw Error("Error in abi : Result has no 'Err' variant.");const o=r.type;if("()"===o)return l.B.Err.toString();const n=f(t.unwrap(),o,s,a);return Array.isArray(n)?[l.B.Err.toString(),...n]:[l.B.Err.toString(),n]}const r=e,o=r.activeVariant(),n=i.find((e=>e.name===o));if(void 0===n)throw Error(`Not find in abi : Enum has no '${o}' variant.`);const d=n.type,u=i.findIndex((e=>e.name===o));if("()"===d)return u.toString();const p=f(r.unwrap(),d,s,a);return Array.isArray(p)?[u.toString(),...p]:[u.toString(),p]}if("object"==typeof e)throw Error(`Parameter ${e} do not align with abi parameter ${t}`);return p(t,e)}function m(e,t,s,r){const{name:a,type:o}=t;let{value:d}=e.next();switch(!0){case(0,h.G$)(o):if(!Array.isArray(d)&&!(0,n.KH)(d))throw Error(`ABI expected parameter ${a} to be array or long string, got ${d}`);return(0,n.Kg)(d)&&(d=(0,n.mE)(d)),f(d,t.type,s,r);case"core::starknet::eth_address::EthAddress"===o:return p(o,d);case(0,h.wJ)(o,s)||(0,h.Zm)(o)||i.is.isAbiType(o)||i.is.isAbiType(o):case(0,h.iO)(o,r):return f(d,o,s,r);default:return p(o,d)}}},3463:(e,t,s)=>{s.d(t,{A:()=>g});var i=s(3283),r=s(274),a=s(178),o=s(1686),n=s(7925),d=s(2256),h=s(5307),c=s(9620),l=s(1668),u=s(6863),p=s(7593);function f(e,t){let s;switch(!0){case(0,h.Fi)(e):return s=t.next().value,Boolean(BigInt(s));case i.is.isAbiType(e):const o=t.next().value,d=t.next().value;return new i.is(o,d).toBigInt();case r.Ns.isAbiType(e):const c=t.next().value,l=t.next().value,u=t.next().value,p=t.next().value;return new r.Ns(c,l,u,p).toBigInt();case"core::starknet::eth_address::EthAddress"===e:return s=t.next().value,BigInt(s);case"core::bytes_31::bytes31"===e:return s=t.next().value,(0,n.Wb)(s);case(0,h.Z$)(e):const f=(0,a.ow)(t.next().value).padStart(32,"0"),m=(0,a.ow)(t.next().value).padStart(32,"0"),g=(0,a.ow)(t.next().value).padStart(32,"0"),v=(0,a.ow)(t.next().value).padStart(32,"0");return BigInt((0,a.VO)(m+f+v+g));default:return s=t.next().value,BigInt(s)}}function m(e,t,s,a){if("()"===t.type)return{};if(i.is.isAbiType(t.type)){const t=e.next().value,s=e.next().value;return new i.is(t,s).toBigInt()}if(r.Ns.isAbiType(t.type)){const t=e.next().value,s=e.next().value,i=e.next().value,a=e.next().value;return new r.Ns(t,s,i,a).toBigInt()}if((0,h.ak)(t.type)){const t=[],s=BigInt(e.next().value);for(;t.length<s;)t.push((0,o.nj)(e.next().value));const i={data:t,pending_word:(0,o.nj)(e.next().value),pending_word_len:BigInt(e.next().value)};return(0,d.f)(i)}if((0,h.G$)(t.type)){const i=[],r={name:"",type:(0,h.CS)(t.type)},o=BigInt(e.next().value);for(;i.length<o;)i.push(m(e,r,s,a));return i}if(s&&t.type in s&&s[t.type])return"core::starknet::eth_address::EthAddress"===t.type?f(t.type,e):s[t.type].members.reduce(((t,i)=>(t[i.name]=m(e,i,s,a),t)),{});if(a&&t.type in a&&a[t.type]){const i=Number(e.next().value),r=a[t.type].variants.reduce(((t,r,o)=>o===i?(t[r.name]=m(e,{name:"",type:r.type},s,a),t):(t[r.name]=void 0,t)),{});if(t.type.startsWith("core::option::Option")){const e=i===c.R.Some?r.Some:void 0;return new c.c(i,e)}if(t.type.startsWith("core::result::Result")){let e;return e=i===l.B.Ok?r.Ok:r.Err,new l.G(i,e)}return new u.b(r)}if((0,h.Zm)(t.type)){return(0,p.A)(t.type).reduce(((t,i,r)=>{const o=i?.name?i.name:r,n={name:o,type:i?.type?i.type:i};return t[o]=m(e,n,s,a),t}),{})}if((0,h.G$)(t.type)){const i=[],r={name:"",type:(0,h.CS)(t.type)},o=BigInt(e.next().value);for(;i.length<o;)i.push(m(e,r,s,a));return i}return f(t.type,e)}function g(e,t,s,i,r){const{name:a,type:o}=t;let n;switch(!0){case(0,h.ct)(a):return n=e.next().value,BigInt(n);case s&&o in s||(0,h.Zm)(o):case i&&(0,h.iO)(o,i):return m(e,t,s,i);case(0,h.G$)(o):if((0,h.s8)(o))return m(e,t,s,i);const d=[];if(r&&r[`${a}_len`]){const o=r[`${a}_len`];for(;d.length<o;)d.push(m(e,{name:a,type:t.type.replace("*","")},s,i))}return d;default:return f(o,e)}}},7593:(e,t,s)=>{s.d(t,{A:()=>a});var i=s(5307);function r(e,t,s){for(let i=0,r=0;i<e.length;i++)if(e[i]===t)r++;else if(e[i]===s&&0==--r)return i;return Number.POSITIVE_INFINITY}function a(e){return(0,i.s8)(e)?function(e){const t=e.slice(1,-1),s=[];let i,a=0;for(;a<t.length;){switch(!0){case"("===t[a]:i=a+r(t.slice(a),"(",")")+1;break;case t.startsWith("core::result::Result::<",a)||t.startsWith("core::array::Array::<",a)||t.startsWith("core::option::Option::<",a):i=a+r(t.slice(a),"<",">")+1;break;default:{const e=t.indexOf(",",a);i=-1!==e?e:Number.POSITIVE_INFINITY}}s.push(t.slice(a,i)),a=i+2}return s}(e):function(e){const t=e.replace(/\s/g,"").slice(1,-1),{subTuple:s,result:r}=function(e){if(!e.includes("("))return{subTuple:[],result:e};const t=[];let s="",i=0;for(;i<e.length;){if("("===e[i]){let r=1;const a=i;for(i++;r;)")"===e[i]&&r--,"("===e[i]&&r++,i++;t.push(e.substring(a,i)),s+=" ",i--}else s+=e[i];i++}return{subTuple:t,result:s}}(t);let a=r.split(",").map((e=>s.length?e.replace(" ",s.shift()):e));return(0,i.mQ)(e)&&(a=a.reduce(((e,t)=>e.concat(function(e){const t=e.substring(0,e.indexOf(":"));return{name:t,type:e.substring(t.length+1)}}(t))),[])),a}(e)}},9873:(e,t,s)=>{s.d(t,{A:()=>w});var i=s(40),r=s(9550),a=s(3283),o=s(274),n=s(1686),d=s(7925),h=s(5307);const c=(e,t)=>{if((0,r.A)((0,d.Kg)(e)||(0,n.Et)(e)||(0,n.sI)(e),`Validate: arg ${t.name} should be a felt typed as (String, Number or BigInt)`),(0,d.Kg)(e)&&!(0,n.qv)(e))return;const s=BigInt(e.toString(10));(0,r.A)(s>=0n&&s<=2n**252n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^252-1]`)},l=(e,t)=>{(0,r.A)((0,d.Kg)(e),`Validate: arg ${t.name} should be a string.`),(0,r.A)(e.length<32,`Validate: arg ${t.name} cairo typed ${t.type} should be a string of less than 32 characters.`)},u=(e,t)=>{(0,r.A)((0,d.Kg)(e),`Validate: arg ${t.name} should be a string.`)},p=(e,t)=>{let s;switch((0,n.Et)(e)&&(0,r.A)(e<=Number.MAX_SAFE_INTEGER,"Validation: Parameter is to large to be typed as Number use (BigInt or String)"),(0,r.A)((0,d.Kg)(e)||(0,n.Et)(e)||(0,n.sI)(e)||"object"==typeof e&&"low"in e&&"high"in e||"object"==typeof e&&["limb0","limb1","limb2","limb3"].every((t=>t in e)),`Validate: arg ${t.name} of cairo type ${t.type} should be type (String, Number or BigInt), but is ${typeof e} ${e}.`),t.type){case i.Fg.u256:s=new a.is(e).toBigInt();break;case i.Fg.u512:s=new o.Ns(e).toBigInt();break;default:s=(0,n.Dg)(e)}switch(t.type){case i.Fg.u8:(0,r.A)(s>=0n&&s<=255n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0 - 255]`);break;case i.Fg.u16:(0,r.A)(s>=0n&&s<=65535n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 65535]`);break;case i.Fg.u32:(0,r.A)(s>=0n&&s<=4294967295n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 4294967295]`);break;case i.Fg.u64:(0,r.A)(s>=0n&&s<=2n**64n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^64-1]`);break;case i.Fg.u128:(0,r.A)(s>=0n&&s<=2n**128n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^128-1]`);break;case i.Fg.u256:(0,r.A)(s>=0n&&s<=2n**256n-1n,`Validate: arg ${t.name} is ${t.type} 0 - 2^256-1`);break;case i.Fg.u512:(0,r.A)(o.Ns.is(s),`Validate: arg ${t.name} is ${t.type} 0 - 2^512-1`);break;case i.uS.ClassHash:case i.uS.ContractAddress:(0,r.A)(s>=0n&&s<=2n**252n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^252-1]`);break;case i.uS.Secp256k1Point:(0,r.A)(s>=0n&&s<=2n**512n-1n,`Validate: arg ${t.name} must be ${t.type} : a 512 bits number.`)}},f=(e,t)=>{(0,r.A)((0,n.Lm)(e),`Validate: arg ${t.name} of cairo type ${t.type} should be type (Boolean)`)},m=(e,t,s)=>{if(t.type!==i.Fg.u256&&t.type!==i.Fg.u512)if("core::starknet::eth_address::EthAddress"!==t.type)(0,r.A)("object"==typeof e&&!Array.isArray(e),`Validate: arg ${t.name} is cairo type struct (${t.type}), and should be defined as js object (not array)`),s[t.type].members.forEach((({name:s})=>{(0,r.A)(Object.keys(e).includes(s),`Validate: arg ${t.name} should have a property ${s}`)}));else{(0,r.A)("object"!=typeof e,`EthAddress type is waiting a BigNumberish. Got ${e}`);const s=BigInt(e.toString(10));(0,r.A)(s>=0n&&s<=2n**160n-1n,`Validate: arg ${t.name} cairo typed ${t.type} should be in range [0, 2^160-1]`)}else p(e,t)},g=(e,t)=>{(0,r.A)("object"==typeof e&&!Array.isArray(e),`Validate: arg ${t.name} is cairo type Enum (${t.type}), and should be defined as js object (not array)`);const s=Object.getOwnPropertyNames(Object.getPrototypeOf(e)),i=[...Object.getOwnPropertyNames(e),...s];if(!((0,h.e4)(t.type)&&i.includes("isSome")&&i.includes("isNone")||(0,h.u)(t.type)&&i.includes("isOk")&&i.includes("isErr")||i.includes("variant")&&i.includes("activeVariant")))throw new Error(`Validate Enum: argument ${t.name}, type ${t.type}, value received ${e}, is not an Enum.`)},v=(e,t)=>{(0,r.A)("object"==typeof e&&!Array.isArray(e),`Validate: arg ${t.name} should be a tuple (defined as object)`)},y=(e,t,s,i)=>{const a=(0,h.CS)(t.type);if(!(0,h.sB)(a)||!(0,d.IN)(e))switch((0,r.A)(Array.isArray(e),`Validate: arg ${t.name} should be an Array`),!0){case(0,h.sB)(a):e.forEach((e=>c(e,t)));break;case(0,h.Zm)(a):e.forEach((e=>v(e,{name:t.name,type:a})));break;case(0,h.G$)(a):e.forEach((e=>y(e,{name:"",type:a},s,i)));break;case(0,h.wJ)(a,s):e.forEach((e=>m(e,{name:t.name,type:a},s)));break;case(0,h.iO)(a,i):e.forEach((e=>g(e,{name:t.name,type:a})));break;case(0,h.$H)(a)||(0,h.Gw)(a):e.forEach((e=>p(e,{name:"",type:a})));break;case(0,h.Fi)(a):e.forEach((e=>f(e,t)));break;default:throw new Error(`Validate Unhandled: argument ${t.name}, type ${t.type}, value ${e}`)}};function w(e,t,s,i){e.inputs.reduce(((e,r)=>{const a=t[e];switch(!0){case(0,h.ct)(r.name):return e;case(0,h.sB)(r.type):c(a,r);break;case(0,h.gr)(r.type):l(a,r);break;case(0,h.$H)(r.type)||(0,h.Gw)(r.type):p(a,r);break;case(0,h.Fi)(r.type):f(a,r);break;case(0,h.ak)(r.type):u(a,r);break;case(0,h.G$)(r.type):y(a,r,s,i);break;case(0,h.wJ)(r.type,s):m(a,r,s);break;case(0,h.iO)(r.type,i):g(a,r);break;case(0,h.Zm)(r.type):v(a,r);break;default:throw new Error(`Validate Unhandled: argument ${r.name}, type ${r.type}, value ${a}`)}return e+1}),0)}},178:(e,t,s)=>{s.d(t,{VO:()=>a,ow:()=>r,yw:()=>i});function i(e){return(new TextEncoder).encode(e)}function r(e){return e.replace(/^0x/i,"")}function a(e){return`0x${r(e)}`}},9491:(e,t,s)=>{s.d(t,{CL:()=>d,dl:()=>u,ez:()=>l,h$:()=>h,r4:()=>p});var i=s(3187),r=s(8325),a=s(6907),o=s(5307),n=s(1686);function d(e,t){return(0,i.NO)(BigInt(e),BigInt(t))}function h(e,t){return(0,n.nj)((0,i.Ef)(BigInt(e),BigInt(t)))}function c(e){return[...e,e.length].reduce(((e,t)=>(0,i.NO)(BigInt(e),BigInt(t))),0).toString()}const l=c;function u(e){return(0,n.nj)((0,i.pd)(e.map((e=>BigInt(e)))))}function p(e,t,s,i){const d=c(a.fP.compile(s)),h=c([(0,o.AB)("0x535441524b4e45545f434f4e54524143545f41444452455353"),i,e,t,d]);return(0,n.nj)(BigInt(h)%r.Vi)}},8354:(e,t,s)=>{s.d(t,{v:()=>r});var i=s(9491);class r{constructor(e,t=i.CL){this.branches=[],this.hashMethod=t,this.leaves=e,this.root=this.build(e)}build(e){if(1===e.length)return e[0];e.length!==this.leaves.length&&this.branches.push(e);const t=[];for(let s=0;s<e.length;s+=2)s+1===e.length?t.push(r.hash(e[s],"0x0",this.hashMethod)):t.push(r.hash(e[s],e[s+1],this.hashMethod));return this.build(t)}static hash(e,t,s=i.CL){const[r,a]=[BigInt(e),BigInt(t)].sort(((e,t)=>e>=t?1:-1));return s(r,a)}getProof(e,t=this.leaves,s=[]){const i=t.indexOf(e);if(-1===i)throw new Error("leaf not found");if(1===t.length)return s;const a=i%2==0,o=(a?t[i+1]:t[i-1])??"0x0",n=[...s,o],d=this.leaves.length===t.length?-1:this.branches.findIndex((e=>e.length===t.length)),h=this.branches[d+1]??[this.root];return this.getProof(r.hash(a?e:o,a?o:e,this.hashMethod),h,n)}}},1686:(e,t,s)=>{s.d(t,{A6:()=>d,Dg:()=>a,Et:()=>h,Lm:()=>c,nj:()=>n,qv:()=>r,sI:()=>o});var i=s(178);function r(e){return/^0x[0-9a-f]*$/i.test(e)}function a(e){return BigInt(e)}function o(e){return"bigint"==typeof e}function n(e){return(0,i.VO)(a(e).toString(16))}const d=e=>/^\d+$/.test(e);function h(e){return"number"==typeof e}function c(e){return"boolean"==typeof e}},9793:(e,t,s)=>{s.d(t,{BK:()=>d});var i=s(3187),r=s(8325),a=s(178),o=s(1686);function n(e){const t=BigInt(function(e){return(0,a.VO)((0,i.Dq)((0,a.yw)(e)).toString(16))}(e));return t&r.n$}function d(e){return(0,o.nj)(n(e))}},7925:(e,t,s)=>{s.d(t,{IN:()=>c,KH:()=>h,Kg:()=>d,Mu:()=>u,O4:()=>n,Wb:()=>p,mE:()=>l});var i=s(8325),r=s(178),a=s(1686);function o(e){return/^[\x00-\x7F]*$/.test(e)}function n(e){return e.length<=i.p7}function d(e){return"string"==typeof e}function h(e){return d(e)&&!(0,a.qv)(e)&&!(0,a.A6)(e)}const c=e=>h(e)&&!n(e);function l(e){const t=RegExp(`[^]{1,${i.p7}}`,"g");return e.match(t)||[]}function u(e){if(!o(e))throw new Error(`${e} is not an ASCII string`);if(!n(e))throw new Error(`${e} is too long`);return(0,r.VO)(e.replace(/./g,(e=>e.charCodeAt(0).toString(16))))}function p(e){if(!o(e))throw new Error(`${e} is not an ASCII string`);if((0,a.qv)(e))return(0,r.ow)(e).replace(/.{2}/g,(e=>String.fromCharCode(parseInt(e,16))));if(function(e){return/^[0-9]*$/i.test(e)}(e))return p("0X".concat(BigInt(e).toString(16)));throw new Error(`${e} is not Hex or decimal`)}},1878:(e,t,s)=>{s.d(t,{E:()=>k});var i=s(8325),r=s(162),a=s(9550),o=s(2256),n=s(9491),d=s(9793),h=s(8354),c=s(1686),l=s(7925);const u={u256:JSON.parse('[{ "name": "low", "type": "u128" }, { "name": "high", "type": "u128" }]'),TokenAmount:JSON.parse('[{ "name": "token_address", "type": "ContractAddress" }, { "name": "amount", "type": "u256" }]'),NftId:JSON.parse('[{ "name": "collection_address", "type": "ContractAddress" }, { "name": "token_id", "type": "u256" }]')},p={[r.K.Active]:{domain:"StarknetDomain",hashMethod:n.dl,hashMerkleMethod:n.h$,escapeTypeString:e=>`"${e}"`,presetTypes:u},[r.K.Legacy]:{domain:"StarkNetDomain",hashMethod:n.ez,hashMerkleMethod:n.CL,escapeTypeString:e=>e,presetTypes:{}}};function f(e,t,{min:s,max:i}){const r=BigInt(e);(0,a.A)(r>=s&&r<=i,`${r} (${t}) is out of bounds [${s}, ${i}]`)}function m({types:e,domain:t}){return p[r.K.Active].domain in e&&t.revision===r.K.Active?r.K.Active:p[r.K.Legacy].domain in e&&(t.revision??r.K.Legacy)===r.K.Legacy?r.K.Legacy:void 0}function g(e){try{return(0,c.nj)(e)}catch(t){if((0,l.Kg)(e))return(0,c.nj)((0,l.Mu)(e));throw new Error(`Invalid BigNumberish: ${e}`)}}function v(e,t,s=[],i="",a=r.K.Legacy){return"*"===t[t.length-1]?t=t.slice(0,-1):a===r.K.Active&&("enum"===t?t=i:t.match(/^\(.*\)$/)&&(t=t.slice(1,-1))),s.includes(t)||!e[t]?s:[t,...e[t].reduce(((t,s)=>[...t,...v(e,s.type,t,s.contains,a).filter((e=>!t.includes(e)))]),[])]}function y(e,t,s=r.K.Legacy){const i=s===r.K.Active?{...e,...p[s].presetTypes}:e,[a,...o]=v(i,t,void 0,void 0,s),n=a?[a,...o.sort()]:[],d=p[s].escapeTypeString;return n.map((e=>{const t=i[e].map((e=>{const t="enum"===e.type&&s===r.K.Active?e.contains:e.type,i=t.match(/^\(.*\)$/)?`(${t.slice(1,-1).split(",").map((e=>e?d(e):e)).join(",")})`:d(t);return`${d(e.name)}:${i}`}));return`${d(e)}(${t})`})).join("")}function w(e,t,s=r.K.Legacy){return(0,d.BK)(y(e,t,s))}function b(e,t,s,n={},l=r.K.Legacy){if(e[t])return[t,S(e,t,s,l)];if(p[l].presetTypes[t])return[t,S(p[l].presetTypes,t,s,l)];if(t.endsWith("*")){const i=s.map((s=>b(e,t.slice(0,-1),s,void 0,l)[1]));return[t,p[l].hashMethod(i)]}switch(t){case"enum":if(l===r.K.Active){const[i,r]=Object.entries(s)[0],a=e[n.parent][0],o=e[a.contains],d=o.find((e=>e.name===i)),h=o.indexOf(d),c=d.type.slice(1,-1).split(",").map(((t,s)=>{if(!t)return t;const i=r[s];return b(e,t,i,void 0,l)[1]}));return[t,p[l].hashMethod([h,...c])]}return[t,g(s)];case"merkletree":{const t=function(e,t){if(t.parent&&t.key){const s=e[t.parent].find((e=>e.name===t.key));if("merkletree"!==s.type)throw new Error(`${t.key} is not a merkle tree`);if(s.contains.endsWith("*"))throw new Error(`Merkle tree contain property must not be an array but was given ${t.key}`);return s.contains}return"raw"}(e,n),i=s.map((s=>b(e,t,s,void 0,l)[1])),{root:r}=new h.v(i,p[l].hashMerkleMethod);return["felt",r]}case"selector":return["felt",(u=s,(0,c.qv)(u)?u:(0,d.BK)(u))];case"string":if(l===r.K.Active){const e=(0,o.p)(s),i=[e.data.length,...e.data,e.pending_word,e.pending_word_len];return[t,p[l].hashMethod(i)]}return[t,g(s)];case"i128":if(l===r.K.Active){const e=BigInt(s);return f(e,t,i.He),[t,g(e<0n?i.s9+e:e)]}return[t,g(s)];case"timestamp":case"u128":return l===r.K.Active&&f(s,t,i.bE),[t,g(s)];case"felt":case"shortstring":return l===r.K.Active&&f(g(s),t,i.Kp),[t,g(s)];case"ClassHash":case"ContractAddress":return l===r.K.Active&&f(s,t,i.Kp),[t,g(s)];case"bool":return l===r.K.Active&&(0,a.A)("boolean"==typeof s,`Type mismatch for ${t} ${s}`),[t,g(s)];default:if(l===r.K.Active)throw new Error(`Unsupported type: ${t}`);return[t,g(s)]}var u}function S(e,t,s,i=r.K.Legacy){return p[i].hashMethod(function(e,t,s,i=r.K.Legacy){const a=e[t]??p[i].presetTypes[t],[o,n]=a.reduce((([r,a],o)=>{if(void 0===s[o.name]||null===s[o.name]&&"enum"!==o.type)throw new Error(`Cannot encode data: missing data for '${o.name}'`);const n=s[o.name],d={parent:t,key:o.name},[h,c]=b(e,o.type,n,d,i);return[[...r,h],[...a,c]]}),[["felt"],[w(e,t,i)]]);return[o,n]}(e,t,s,i)[1])}function k(e,t){if(!function(e){const t=e;return Boolean(t.message&&t.primaryType&&t.types&&m(t))}(e))throw new Error("Typed data does not match JSON schema");const s=m(e),{domain:i,hashMethod:r}=p[s];return r([(0,l.Mu)("StarkNet Message"),S(e.types,i,e.domain,s),t,S(e.types,e.primaryType,e.message,s)])}},6213:(e,t,s)=>{s.d(t,{A:()=>n});var i=s(334),r=s(2079),a=s(5147),o=s(1579);class n extends i.A{describe(){return this.deepExtend(super.describe(),{id:"timex",name:"TimeX",countries:["AU"],version:"v1",rateLimit:1500,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,cancelOrders:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,editOrder:!0,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!0,fetchWithdrawal:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1},timeframes:{"1m":"I1","5m":"I5","15m":"I15","30m":"I30","1h":"H1","2h":"H2","4h":"H4","6h":"H6","12h":"H12","1d":"D1","1w":"W1"},urls:{logo:"https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg",api:{rest:"https://plasma-relay-backend.timex.io"},www:"https://timex.io",doc:"https://plasma-relay-backend.timex.io/swagger-ui/index.html",referral:"https://timex.io/?refcode=1x27vNkTbP1uwkCck"},api:{addressbook:{get:["me"],post:["","id/{id}","id/{id}/remove"]},custody:{get:["credentials","credentials/h/{hash}","credentials/k/{key}","credentials/me","credentials/me/address","deposit-addresses","deposit-addresses/h/{hash}"]},history:{get:["orders","orders/details","orders/export/csv","trades","trades/export/csv"]},currencies:{get:["a/{address}","i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},manager:{get:["deposits","transfers","withdrawals"]},markets:{get:["i/{id}","s/{symbol}"],post:["perform","prepare","remove/perform","s/{symbol}/remove/prepare","s/{symbol}/update/perform","s/{symbol}/update/prepare"]},public:{get:["candles","currencies","markets","orderbook","orderbook/raw","orderbook/v2","tickers","trades"]},statistics:{get:["address"]},trading:{get:["balances","fees","orders"],post:["orders","orders/json"],put:["orders","orders/json"],delete:["orders","orders/json"]},tradingview:{get:["config","history","symbol_info","time"]}},precisionMode:o.kb,exceptions:{exact:{0:r.ExchangeError,1:r.NotSupported,4e3:r.BadRequest,4001:r.BadRequest,4002:r.InsufficientFunds,4003:r.AuthenticationError,4004:r.AuthenticationError,4005:r.BadRequest,4006:r.BadRequest,4007:r.BadRequest,4300:r.PermissionDenied,4100:r.AuthenticationError,4400:r.OrderNotFound,5001:r.InvalidOrder,5002:r.ExchangeError,400:r.BadRequest,401:r.AuthenticationError,403:r.PermissionDenied,404:r.OrderNotFound,429:r.RateLimitExceeded,500:r.ExchangeError,503:r.ExchangeNotAvailable},broad:{Insufficient:r.InsufficientFunds}},options:{expireIn:31536e3,fetchTickers:{period:"1d"},fetchTrades:{sort:"timestamp,asc"},fetchMyTrades:{sort:"timestamp,asc"},fetchOpenOrders:{sort:"createdAt,asc"},fetchClosedOrders:{sort:"createdAt,asc"},defaultSort:"timestamp,asc",defaultSortOrders:"createdAt,asc"}})}async fetchTime(e={}){const t=await this.tradingviewGetTime(e);return 1e3*this.parseToInt(t)}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e);return this.parseMarkets(t)}async fetchCurrencies(e={}){const t=await this.publicGetCurrencies(e),s=[];for(let e=0;e<t.length;e++){const i=t[e];s.push(this.parseCurrency(i))}return this.indexBy(s,"code")}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){const a=this.safeString(i,"address");if(i=this.omit(i,"address"),void 0===a)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires an address parameter");const o={address:a},n=await this.managerGetDeposits(this.extend(o,i)),d=this.safeCurrency(e);return this.parseTransactions(n,d,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const a=this.safeString(i,"address");if(i=this.omit(i,"address"),void 0===a)throw new r.ArgumentsRequired(this.id+" fetchDeposits() requires an address parameter");const o={address:a},n=await this.managerGetWithdrawals(this.extend(o,i)),d=this.safeCurrency(e);return this.parseTransactions(n,d,t,s)}getCurrencyByAddress(e){const t=this.currencies;for(let s=0;s<t.length;s++){const i=t[s],r=this.safeValue(i,"info",{});if(this.safeString(r,"address")===e)return i}}parseTransaction(e,t=void 0){const s=this.safeString(e,"timestamp"),i=this.safeString(e,"token","");return t=this.getCurrencyByAddress(i),{info:e,id:this.safeString(e,"transferHash"),txid:this.safeString(e,"txid"),timestamp:this.parse8601(s),datetime:s,network:void 0,address:void 0,addressTo:this.safeString(e,"to"),addressFrom:this.safeString(e,"from"),tag:void 0,tagTo:void 0,tagFrom:void 0,type:void 0,amount:this.safeNumber(e,"value"),currency:this.safeCurrencyCode(void 0,t),status:"ok",updated:void 0,internal:void 0,comment:void 0,fee:void 0}}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=this.safeString(this.options.fetchTickers,"period","1d"),i={period:this.timeframes[s]},r=await this.publicGetTickers(this.extend(i,t));return this.parseTickers(r,e)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i=this.safeString(this.options.fetchTickers,"period","1d"),r={market:s.id,period:this.timeframes[i]},a=await this.publicGetTickers(this.extend(r,t)),o=this.safeDict(a,0);return this.parseTicker(o,s)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={market:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetOrderbookV2(this.extend(i,s)),a=this.parse8601(this.safeString(r,"timestamp"));return this.parseOrderBook(r,e,a,"bid","ask","price","baseTokenAmount")}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a=this.safeValue(this.options,"fetchTrades",{}),o=this.safeValue(a,"sort","timestamp,asc"),n=this.safeString(i,"sort",o),d=this.omit(i,"sort"),h={market:r.id,sort:n};void 0!==t&&(h.from=this.iso8601(t)),void 0!==s&&(h.size=s);const c=await this.publicGetTrades(this.extend(h,d));return this.parseTrades(c,r,t,s)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,period:this.safeString(this.timeframes,t,t)},n=this.parseTimeframe(t);if(void 0===i&&(i=1e3),void 0!==s)o.from=this.iso8601(s),o.till=this.iso8601(this.sum(s,this.sum(i,1)*n*1e3));else{const e=this.milliseconds();o.till=this.iso8601(e),o.from=this.iso8601(e-i*n*1e3-1)}const d=await this.publicGetCandles(this.extend(o,r));return this.parseOHLCVs(d,a,t,s,i)}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.total=this.safeString(i,"totalBalance"),o.used=this.safeString(i,"lockedBalance"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.tradingGetBalances(e);return this.parseBalance(t)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=s.toUpperCase();let h=t.toUpperCase();this.safeBool(o,"postOnly",!1)&&(h="POST_ONLY",o=this.omit(o,["postOnly"]));const c={symbol:n.id,quantity:this.amountToPrecision(e,i),side:d,orderTypes:h};let l=o;if("LIMIT"===h||"POST_ONLY"===h){c.price=this.priceToPrecision(e,a);const s=this.safeInteger(this.options,"expireIn"),i=this.safeValue(o,"expireTime"),n=this.safeValue(o,"expireIn",s);if(void 0!==i)c.expireTime=i;else{if(void 0===n)throw new r.InvalidOrder(this.id+" createOrder() method requires a expireTime or expireIn param for a "+t+" order, you can also set the expireIn exchange-wide option");c.expireIn=n}l=this.omit(o,["expireTime","expireIn"])}else c.price=0;const u=await this.tradingPostOrders(this.extend(c,l)),p=this.safeValue(u,"orders",[]),f=this.safeDict(p,0,{});return this.parseOrder(f,n)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={id:e};void 0!==r&&(d.quantity=this.amountToPrecision(t,r)),void 0!==a&&(d.price=this.priceToPrecision(t,a));const h=await this.tradingPutOrders(this.extend(d,o));if("unchangedOrders"in h){const e=this.safeValue(h,"unchangedOrders",[]),t=this.safeString(e,0);return this.safeOrder({id:t,info:h})}const c=this.safeValue(h,"changedOrders",[]),l=this.safeValue(c,0,{}),u=this.safeDict(l,"newOrder",{});return this.parseOrder(u,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i=await this.cancelOrders([e],t,s);return this.safeDict(i,0)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={id:e},r=await this.tradingDeleteOrders(this.extend(i,s)),a=this.safeList(r,"changedOrders",[]),o=this.safeList(r,"unchangedOrders",[]),n=[];for(let e=0;e<a.length;e++){const t=this.safeDict(a[e],"newOrder");n.push(this.parseOrder(t))}for(let e=0;e<o.length;e++)n.push(this.safeOrder({info:o[e],id:o[e],status:"unchanged"}));return n}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={orderHash:e},r=await this.historyGetOrdersDetails(i),a=this.safeValue(r,"order",{}),o=this.safeList(r,"trades",[]);return this.parseOrder(this.extend(a,{trades:o}))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue(this.options,"fetchOpenOrders",{}),a=this.safeValue(r,"sort","createdAt,asc"),o=this.safeString(i,"sort",a),n=this.omit(i,"sort"),d={sort:o};let h;void 0!==e&&(h=this.market(e),d.symbol=h.id),void 0!==s&&(d.size=s);const c=await this.tradingGetOrders(this.extend(d,n)),l=this.safeList(c,"orders",[]);return this.parseOrders(l,h,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue(this.options,"fetchClosedOrders",{}),a=this.safeValue(r,"sort","createdAt,asc"),o=this.safeString(i,"sort",a),n=this.omit(i,"sort"),d={sort:o,side:"BUY"};let h;void 0!==e&&(h=this.market(e),d.symbol=h.id),void 0!==t&&(d.from=this.iso8601(t)),void 0!==s&&(d.size=s);const c=await this.historyGetOrders(this.extend(d,n)),l=this.safeList(c,"orders",[]);return this.parseOrders(l,h,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.safeValue(this.options,"fetchMyTrades",{}),a=this.safeValue(r,"sort","timestamp,asc"),o=this.safeString(i,"sort",a),n=this.omit(i,"sort"),d={sort:o};let h;void 0!==e&&(h=this.market(e),d.symbol=h.id),void 0!==t&&(d.from=this.iso8601(t)),void 0!==s&&(d.size=s);const c=await this.historyGetTrades(this.extend(d,n)),l=this.safeList(c,"trades",[]);return this.parseTrades(l,h,t,s)}parseTradingFee(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeNumber(e,"fee");return{info:e,symbol:this.safeSymbol(s,t),maker:i,taker:i,percentage:void 0,tierBased:void 0}}async fetchTradingFee(e,t={}){await this.loadMarkets();const s=this.market(e),i={markets:s.id},r=await this.tradingGetFees(this.extend(i,t)),a=this.safeValue(r,0,{});return this.parseTradingFee(a,s)}parseMarket(e){const t=this.safeValue(e,"locked"),s=this.safeString(e,"symbol"),i=this.safeString(e,"baseCurrency"),r=this.safeString(e,"quoteCurrency"),o=this.safeCurrencyCode(i),n=this.safeCurrencyCode(r),d=this.safeString(e,"quantityIncrement"),h=this.safeString(e,"baseMinSize"),c=a.Y.stringMax(d,h),l=this.safeString(e,"tickSize"),u=this.safeNumber(e,"quoteMinSize");return{id:s,symbol:o+"/"+n,base:o,quote:n,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!t,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"quantityIncrement"),price:this.safeNumber(e,"tickSize")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(c),max:void 0},price:{min:this.parseNumber(l),max:void 0},cost:{min:u,max:void 0}},created:void 0,info:e}}parseCurrency(e){const t=this.safeString(e,"symbol"),s=this.safeCurrencyCode(t),i=this.safeString(e,"name"),r=this.safeValue(e,"depositEnabled"),a=this.safeValue(e,"withdrawalEnabled"),o=this.safeValue(e,"active"),n=r&&a&&o,d=this.safeString(e,"withdrawalFee"),h=this.safeInteger(e,"tradeDecimals");let c;if(void 0!==d&&void 0!==h){const e=d.length-h;if(e>0){const t=d.slice(0,e),s=d.slice(-e);c=this.parseNumber(t+"."+s)}else{let t=".";for(let s=0;s<-e;s++)t+="0";c=this.parseNumber(t+d)}}return{id:s,code:s,info:e,type:void 0,name:i,active:n,deposit:r,withdraw:a,fee:c,precision:this.parseNumber(this.parsePrecision(this.safeString(e,"decimals"))),limits:{withdraw:{min:c,max:void 0},amount:{min:void 0,max:void 0}},networks:{}}}parseTicker(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"/"),r=this.parse8601(this.safeString(e,"timestamp")),a=this.safeString(e,"last"),o=this.safeString(e,"open");return this.safeTicker({symbol:i,info:e,timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:o,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:this.safeString(e,"volumeQuote")},t)}parseTrade(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t),r=this.parse8601(this.safeString(e,"timestamp")),o=this.safeString(e,"price"),n=this.safeString(e,"quantity"),d=this.parseNumber(o),h=this.parseNumber(n),c=this.parseNumber(a.Y.stringMul(o,n)),l=this.safeString(e,"id"),u=this.safeStringLower2(e,"direction","side"),p=this.safeStringLower(e,"makerOrTaker");let f,m;void 0!==p&&(f=this.safeString(e,p+"OrderId"));const g=this.safeNumber(e,"fee"),v=this.safeCurrencyCode(this.safeString(e,"feeToken"));return void 0!==g&&(m={cost:g,currency:v}),{info:e,id:l,timestamp:r,datetime:this.iso8601(r),symbol:i,order:f,type:void 0,side:u,price:d,amount:h,cost:c,takerOrMaker:p,fee:m}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"timestamp")),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}parseOrder(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeStringLower(e,"type"),r=this.safeStringLower(e,"side"),o=this.safeString(e,"symbol"),n=this.safeSymbol(o,t),d=this.parse8601(this.safeString(e,"createdAt")),h=this.safeString(e,"price"),c=this.safeString(e,"quantity"),l=this.safeString(e,"filledQuantity"),u=this.omitZero(this.safeString(e,"cancelledQuantity"));let p;p=a.Y.stringEquals(l,c)?"closed":void 0!==u?"canceled":"open";const f=this.safeValue(e,"trades",[]),m=this.safeString(e,"clientOrderId");return this.safeOrder({info:e,id:s,clientOrderId:m,timestamp:d,datetime:this.iso8601(d),lastTradeTimestamp:void 0,symbol:n,type:i,timeInForce:void 0,postOnly:void 0,side:r,price:h,stopPrice:void 0,triggerPrice:void 0,amount:c,cost:void 0,average:void 0,filled:l,remaining:void 0,status:p,fee:void 0,trades:f},t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={symbol:s.code},r=await this.currenciesGetSSymbol(this.extend(i,t)),a=this.safeDict(r,"currency",{});return this.parseDepositAddress(a,s)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"symbol");return{info:e,currency:this.safeCurrencyCode(s,t),address:this.safeString(e,"address"),tag:void 0,network:void 0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.extractParams(e);e=this.implodeParams(e,i),i=this.omit(i,o);let n=this.urls.api.rest+"/"+t+"/"+e;if(Object.keys(i).length&&(n+="?"+this.urlencodeWithArrayRepeat(i)),"public"!==t&&"tradingview"!==t){this.checkRequiredCredentials();r={authorization:"Basic "+this.stringToBase64(this.apiKey+":"+this.secret)}}return{url:n,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&e>=400){const e=this.id+" "+o;let t=this.safeValue(n,"error");void 0===t&&(t=n);const s=this.safeString2(t,"code","status"),i=this.safeString2(t,"message","debugMessage");throw this.throwBroadlyMatchedException(this.exceptions.broad,i,e),this.throwExactlyMatchedException(this.exceptions.exact,s,e),this.throwExactlyMatchedException(this.exceptions.exact,i,e),new r.ExchangeError(e)}}}},2490:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7999),r=s(1579),a=s(2079),o=s(5147),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"tokocrypto",name:"Tokocrypto",countries:["ID"],certified:!1,pro:!1,version:"v1",has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,addMargin:void 0,borrowMargin:void 0,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:void 0,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createReduceOnlyOrder:void 0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:void 0,fetchBorrowRateHistories:void 0,fetchBorrowRateHistory:void 0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:"emulated",fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchL3OrderBook:!1,fetchLedger:void 0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:"emulated",fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!1,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/183870484-d3398d0c-f6a1-4cce-91b8-d58792308716.jpg",api:{rest:{public:"https://www.tokocrypto.com",binance:"https://api.binance.com/api/v3",private:"https://www.tokocrypto.com"}},www:"https://tokocrypto.com",doc:"https://www.tokocrypto.com/apidocs/",fees:"https://www.tokocrypto.com/fees/newschedule"},api:{binance:{get:{ping:1,time:1,depth:{cost:1,byLimit:[[100,1],[500,5],[1e3,10],[5e3,50]]},trades:1,aggTrades:1,historicalTrades:5,klines:1,"ticker/24hr":{cost:1,noSymbol:40},"ticker/price":{cost:1,noSymbol:2},"ticker/bookTicker":{cost:1,noSymbol:2},exchangeInfo:10},put:{userDataStream:1},post:{userDataStream:1},delete:{userDataStream:1}},public:{get:{"open/v1/common/time":1,"open/v1/common/symbols":1,"open/v1/market/depth":1,"open/v1/market/trades":1,"open/v1/market/agg-trades":1,"open/v1/market/klines":1}},private:{get:{"open/v1/orders/detail":1,"open/v1/orders":1,"open/v1/account/spot":1,"open/v1/account/spot/asset":1,"open/v1/orders/trades":1,"open/v1/withdraws":1,"open/v1/deposits":1,"open/v1/deposits/address":1},post:{"open/v1/orders":1,"open/v1/orders/cancel":1,"open/v1/orders/oco":1,"open/v1/withdraws":1,"open/v1/user-data-stream":1}}},fees:{trading:{tierBased:!0,percentage:!0,taker:this.parseNumber("0.0075"),maker:this.parseNumber("0.0075")}},precisionMode:r.kb,options:{createMarketBuyOrderRequiresPrice:!0,defaultTimeInForce:"GTC",hasAlreadyAuthenticatedSuccessfully:!1,warnOnFetchOpenOrdersWithoutSymbol:!0,recvWindow:5e3,timeDifference:0,adjustForTimeDifference:!1,newOrderRespType:{market:"FULL",limit:"FULL"},quoteOrderQty:!1,networks:{ERC20:"ETH",TRC20:"TRX",BEP2:"BNB",BEP20:"BSC",OMNI:"OMNI",EOS:"EOS",SPL:"SOL"},reverseNetworks:{"tronscan.org":"TRC20","etherscan.io":"ERC20","bscscan.com":"BSC","explorer.binance.org":"BEP2","bithomp.com":"XRP","bloks.io":"EOS","stellar.expert":"XLM","blockchair.com/bitcoin":"BTC","blockchair.com/bitcoin-cash":"BCH","blockchair.com/ecash":"XEC","explorer.litecoin.net":"LTC","explorer.avax.network":"AVAX","solscan.io":"SOL","polkadot.subscan.io":"DOT","dashboard.internetcomputer.org":"ICP","explorer.chiliz.com":"CHZ","cardanoscan.io":"ADA","mainnet.theoan.com":"AION","algoexplorer.io":"ALGO","explorer.ambrosus.com":"AMB","viewblock.io/zilliqa":"ZIL","viewblock.io/arweave":"AR","explorer.ark.io":"ARK","atomscan.com":"ATOM","www.mintscan.io":"CTK","explorer.bitcoindiamond.org":"BCD","btgexplorer.com":"BTG","bts.ai":"BTS","explorer.celo.org":"CELO","explorer.nervos.org":"CKB","cerebro.cortexlabs.ai":"CTXC","chainz.cryptoid.info":"VIA","explorer.dcrdata.org":"DCR","digiexplorer.info":"DGB","dock.subscan.io":"DOCK","dogechain.info":"DOGE","explorer.elrond.com":"EGLD","blockscout.com":"ETC","explore-fetchhub.fetch.ai":"FET","filfox.info":"FIL","fio.bloks.io":"FIO","explorer.firo.org":"FIRO","neoscan.io":"NEO","ftmscan.com":"FTM","explorer.gochain.io":"GO","block.gxb.io":"GXS","hash-hash.info":"HBAR","www.hiveblockexplorer.com":"HIVE","explorer.helium.com":"HNT","tracker.icon.foundation":"ICX","www.iostabc.com":"IOST","explorer.iota.org":"IOTA","iotexscan.io":"IOTX","irishub.iobscan.io":"IRIS","kava.mintscan.io":"KAVA","scope.klaytn.com":"KLAY","kmdexplorer.io":"KMD","kusama.subscan.io":"KSM","explorer.lto.network":"LTO","polygonscan.com":"POLYGON","explorer.ont.io":"ONT","minaexplorer.com":"MINA","nanolooker.com":"NANO","explorer.nebulas.io":"NAS","explorer.nbs.plus":"NBS","explorer.nebl.io":"NEBL","nulscan.io":"NULS","nxscan.com":"NXS","explorer.harmony.one":"ONE","explorer.poa.network":"POA","qtum.info":"QTUM","explorer.rsk.co":"RSK","www.oasisscan.com":"ROSE","ravencoin.network":"RVN","sc.tokenview.com":"SC","secretnodes.com":"SCRT","explorer.skycoin.com":"SKY","steemscan.com":"STEEM","explorer.stacks.co":"STX","www.thetascan.io":"THETA","scan.tomochain.com":"TOMO","explore.vechain.org":"VET","explorer.vite.net":"VITE","www.wanscan.org":"WAN","wavesexplorer.com":"WAVES","wax.eosx.io":"WAXP","waltonchain.pro":"WTC","chain.nem.ninja":"XEM","verge-blockchain.info":"XVG","explorer.yoyow.org":"YOYOW","explorer.zcha.in":"ZEC","explorer.zensystem.io":"ZEN"},impliedNetworks:{ETH:{ERC20:"ETH"},TRX:{TRC20:"TRX"}},legalMoney:{MXN:!0,UGX:!0,SEK:!0,CHF:!0,VND:!0,AED:!0,DKK:!0,KZT:!0,HUF:!0,PEN:!0,PHP:!0,USD:!0,TRY:!0,EUR:!0,NGN:!0,PLN:!0,BRL:!0,ZAR:!0,KES:!0,ARS:!0,RUB:!0,AUD:!0,NOK:!0,CZK:!0,GBP:!0,UAH:!0,GHS:!0,HKD:!0,CAD:!0,INR:!0,JPY:!0,NZD:!0}},exceptions:{exact:{"System is under maintenance.":a.OnMaintenance,"System abnormality":a.ExchangeError,"You are not authorized to execute this request.":a.PermissionDenied,"API key does not exist":a.AuthenticationError,"Order would trigger immediately.":a.OrderImmediatelyFillable,"Stop price would trigger immediately.":a.OrderImmediatelyFillable,"Order would immediately match and take.":a.OrderImmediatelyFillable,"Account has insufficient balance for requested action.":a.InsufficientFunds,"Rest API trading is not enabled.":a.ExchangeNotAvailable,"You don't have permission.":a.PermissionDenied,"Market is closed.":a.ExchangeNotAvailable,"Too many requests. Please try again later.":a.DDoSProtection,"This action disabled is on this account.":a.AccountSuspended,"-1000":a.ExchangeNotAvailable,"-1001":a.ExchangeNotAvailable,"-1002":a.AuthenticationError,"-1003":a.RateLimitExceeded,"-1004":a.DDoSProtection,"-1005":a.PermissionDenied,"-1006":a.BadResponse,"-1007":a.RequestTimeout,"-1010":a.BadResponse,"-1011":a.PermissionDenied,"-1013":a.InvalidOrder,"-1014":a.InvalidOrder,"-1015":a.RateLimitExceeded,"-1016":a.ExchangeNotAvailable,"-1020":a.BadRequest,"-1021":a.InvalidNonce,"-1022":a.AuthenticationError,"-1023":a.BadRequest,"-1099":a.AuthenticationError,"-1100":a.BadRequest,"-1101":a.BadRequest,"-1102":a.BadRequest,"-1103":a.BadRequest,"-1104":a.BadRequest,"-1105":a.BadRequest,"-1106":a.BadRequest,"-1108":a.BadRequest,"-1109":a.AuthenticationError,"-1110":a.BadRequest,"-1111":a.BadRequest,"-1112":a.InvalidOrder,"-1113":a.BadRequest,"-1114":a.BadRequest,"-1115":a.BadRequest,"-1116":a.BadRequest,"-1117":a.BadRequest,"-1118":a.BadRequest,"-1119":a.BadRequest,"-1120":a.BadRequest,"-1121":a.BadSymbol,"-1125":a.AuthenticationError,"-1127":a.BadRequest,"-1128":a.BadRequest,"-1130":a.BadRequest,"-1131":a.BadRequest,"-1136":a.BadRequest,"-2008":a.AuthenticationError,"-2010":a.ExchangeError,"-2011":a.OrderNotFound,"-2013":a.OrderNotFound,"-2014":a.AuthenticationError,"-2015":a.AuthenticationError,"-2016":a.BadRequest,"-2018":a.InsufficientFunds,"-2019":a.InsufficientFunds,"-2020":a.OrderNotFillable,"-2021":a.OrderImmediatelyFillable,"-2022":a.InvalidOrder,"-2023":a.InsufficientFunds,"-2024":a.InsufficientFunds,"-2025":a.InvalidOrder,"-2026":a.InvalidOrder,"-2027":a.InvalidOrder,"-2028":a.InsufficientFunds,"-3000":a.ExchangeError,"-3001":a.AuthenticationError,"-3002":a.BadSymbol,"-3003":a.BadRequest,"-3004":a.ExchangeError,"-3005":a.InsufficientFunds,"-3006":a.InsufficientFunds,"-3007":a.ExchangeError,"-3008":a.InsufficientFunds,"-3009":a.BadRequest,"-3010":a.ExchangeError,"-3011":a.BadRequest,"-3012":a.ExchangeError,"-3013":a.BadRequest,"-3014":a.AccountSuspended,"-3015":a.ExchangeError,"-3016":a.BadRequest,"-3017":a.ExchangeError,"-3018":a.AccountSuspended,"-3019":a.AccountSuspended,"-3020":a.InsufficientFunds,"-3021":a.BadRequest,"-3022":a.AccountSuspended,"-3023":a.BadRequest,"-3024":a.ExchangeError,"-3025":a.BadRequest,"-3026":a.BadRequest,"-3027":a.BadSymbol,"-3028":a.BadSymbol,"-3029":a.ExchangeError,"-3036":a.AccountSuspended,"-3037":a.ExchangeError,"-3038":a.BadRequest,"-3041":a.InsufficientFunds,"-3042":a.BadRequest,"-3043":a.BadRequest,"-3044":a.DDoSProtection,"-3045":a.ExchangeError,"-3999":a.ExchangeError,"-4001":a.BadRequest,"-4002":a.BadRequest,"-4003":a.BadRequest,"-4004":a.AuthenticationError,"-4005":a.RateLimitExceeded,"-4006":a.BadRequest,"-4007":a.BadRequest,"-4008":a.BadRequest,"-4010":a.BadRequest,"-4011":a.BadRequest,"-4012":a.BadRequest,"-4013":a.AuthenticationError,"-4014":a.PermissionDenied,"-4015":a.ExchangeError,"-4016":a.PermissionDenied,"-4017":a.PermissionDenied,"-4018":a.BadSymbol,"-4019":a.BadSymbol,"-4021":a.BadRequest,"-4022":a.BadRequest,"-4023":a.ExchangeError,"-4024":a.InsufficientFunds,"-4025":a.InsufficientFunds,"-4026":a.InsufficientFunds,"-4027":a.ExchangeError,"-4028":a.BadRequest,"-4029":a.BadRequest,"-4030":a.ExchangeError,"-4031":a.ExchangeError,"-4032":a.ExchangeError,"-4033":a.BadRequest,"-4034":a.ExchangeError,"-4035":a.PermissionDenied,"-4036":a.BadRequest,"-4037":a.ExchangeError,"-4038":a.ExchangeError,"-4039":a.BadRequest,"-4040":a.BadRequest,"-4041":a.ExchangeError,"-4042":a.ExchangeError,"-4043":a.BadRequest,"-4044":a.BadRequest,"-4045":a.ExchangeError,"-4046":a.AuthenticationError,"-4047":a.BadRequest,"-5001":a.BadRequest,"-5002":a.InsufficientFunds,"-5003":a.InsufficientFunds,"-5004":a.BadRequest,"-5005":a.InsufficientFunds,"-5006":a.BadRequest,"-5007":a.BadRequest,"-5008":a.InsufficientFunds,"-5009":a.BadRequest,"-5010":a.ExchangeError,"-5011":a.BadRequest,"-5012":a.ExchangeError,"-5013":a.InsufficientFunds,"-5021":a.BadRequest,"-6001":a.BadRequest,"-6003":a.BadRequest,"-6004":a.ExchangeError,"-6005":a.InvalidOrder,"-6006":a.BadRequest,"-6007":a.BadRequest,"-6008":a.BadRequest,"-6009":a.RateLimitExceeded,"-6011":a.BadRequest,"-6012":a.InsufficientFunds,"-6013":a.ExchangeError,"-6014":a.BadRequest,"-6015":a.BadRequest,"-6016":a.BadRequest,"-6017":a.BadRequest,"-6018":a.BadRequest,"-6019":a.AuthenticationError,"-6020":a.BadRequest,"-7001":a.BadRequest,"-7002":a.BadRequest,"-9000":a.InsufficientFunds,"-10017":a.BadRequest,"-11008":a.InsufficientFunds,"-12014":a.RateLimitExceeded,"-13000":a.BadRequest,"-13001":a.BadRequest,"-13002":a.BadRequest,"-13003":a.BadRequest,"-13004":a.BadRequest,"-13005":a.BadRequest,"-13006":a.InvalidOrder,"-13007":a.AuthenticationError,"-21001":a.BadRequest,"-21002":a.BadRequest,"-21003":a.BadRequest,100001003:a.BadRequest,2202:a.InsufficientFunds,3210:a.InvalidOrder,3203:a.InvalidOrder,3211:a.InvalidOrder,3207:a.InvalidOrder,3218:a.OrderNotFound},broad:{"has no operation privilege":a.PermissionDenied,MAX_POSITION:a.InvalidOrder}}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicGetOpenV1CommonTime(e);return this.safeInteger(t,"serverTime")}async fetchMarkets(e={}){const t=await this.publicGetOpenV1CommonSymbols(e);this.options.adjustForTimeDifference&&await this.loadTimeDifference();const s=this.safeValue(t,"data",{}),i=this.safeValue(s,"list",[]),r=[];for(let e=0;e<i.length;e++){const t=i[e],s=this.safeString(t,"baseAsset"),a=this.safeString(t,"quoteAsset"),o=this.safeString(t,"symbol"),n=this.safeStringLower(t,"symbol"),d=this.safeString(t,"marginAsset"),h=this.safeCurrencyCode(s),c=this.safeCurrencyCode(a),l=this.safeCurrencyCode(d),u=h+"/"+c,p=this.safeValue(t,"filters",[]),f=this.indexBy(p,"filterType");let m="1"===this.safeString(t,"spotTradingEnable");const g=this.safeValue(t,"permissions",[]);for(let e=0;e<g.length;e++)if("TRD_GRP_003"===g[e]){m=!1;break}const v={id:o,lowercaseId:n,symbol:u,base:h,quote:c,settle:l,baseId:s,quoteId:a,settleId:d,type:"spot",spot:!0,margin:this.safeBool(t,"isMarginTradingAllowed",!1),swap:!1,future:!1,delivery:!1,option:!1,active:m,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(t,"quantityPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(t,"pricePrecision"))),base:this.parseNumber(this.parsePrecision(this.safeString(t,"baseAssetPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(t,"quotePrecision")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:t};if("PRICE_FILTER"in f){const e=this.safeValue(f,"PRICE_FILTER",{});v.precision.price=this.safeNumber(e,"tickSize"),v.limits.price={min:this.safeNumber(e,"minPrice"),max:this.safeNumber(e,"maxPrice")},v.precision.price=e.tickSize}if("LOT_SIZE"in f){const e=this.safeValue(f,"LOT_SIZE",{});v.precision.amount=this.safeNumber(e,"stepSize"),v.limits.amount={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}if("MARKET_LOT_SIZE"in f){const e=this.safeValue(f,"MARKET_LOT_SIZE",{});v.limits.market={min:this.safeNumber(e,"minQty"),max:this.safeNumber(e,"maxQty")}}if("MIN_NOTIONAL"in f){const e=this.safeValue(f,"MIN_NOTIONAL",{});v.limits.cost.min=this.safeNumber2(e,"minNotional","notional")}r.push(v)}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={};let a;void 0!==t&&(r.limit=t),"USDT"===i.quote?(r.symbol=i.baseId+i.quoteId,a=await this.binanceGetDepth(this.extend(r,s))):(r.symbol=i.id,a=await this.publicGetOpenV1MarketDepth(this.extend(r,s)));const o=this.safeValue(a,"data",a),n=this.safeInteger2(a,"T","timestamp"),d=this.parseOrderBook(o,e,n);return d.nonce=this.safeInteger(o,"lastUpdateId"),d}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"T","time"),i=this.safeString2(e,"p","price"),r=this.safeString2(e,"q","qty"),a=this.safeString2(e,"quoteQty","baseQty"),o=this.safeString(e,"symbol"),n=this.safeSymbol(o,t);let d,h=this.safeString2(e,"t","a");h=this.safeString2(e,"id","tradeId",h);const c=this.safeString(e,"orderId"),l=this.safeValue2(e,"m","isBuyerMaker");let u,p;return void 0!==l?(d=l?"sell":"buy",u="taker"):"side"in e?d=this.safeStringLower(e,"side"):"isBuyer"in e&&(d=e.isBuyer?"buy":"sell"),"commission"in e&&(p={cost:this.safeString(e,"commission"),currency:this.safeCurrencyCode(this.safeString(e,"commissionAsset"))}),"isMaker"in e&&(u=e.isMaker?"maker":"taker"),"maker"in e&&(u=e.maker?"maker":"taker"),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:n,id:h,order:c,type:void 0,side:d,takerOrMaker:u,price:i,amount:r,cost:a,fee:p},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:this.getMarketIdByType(r)};if("USDT"!==r.quote){void 0!==s&&(a.limit=s);const e=this.publicGetOpenV1MarketTrades(this.extend(a,i)),o=this.safeDict(e,"data",{}),n=this.safeList(o,"list",[]);return this.parseTrades(n,r,t,s)}void 0!==s&&(a.limit=s);let o;return"binanceGetAggTrades"===this.safeString(this.options,"fetchTradesMethod","binanceGetTrades")&&void 0!==t?(a.startTime=t,a.endTime=this.sum(t,36e5),o=await this.binanceGetAggTrades(this.extend(a,i))):o=await this.binanceGetTrades(this.extend(a,i)),this.parseTrades(o,r,t,s)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"closeTime"),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeString(e,"lastPrice");let o,n;return"baseVolume"in e?(o=this.safeString(e,"baseVolume"),n=this.safeString(e,"volume")):(o=this.safeString(e,"volume"),n=this.safeString(e,"quoteVolume")),this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"highPrice"),low:this.safeString(e,"lowPrice"),bid:this.safeString(e,"bidPrice"),bidVolume:this.safeString(e,"bidQty"),ask:this.safeString(e,"askPrice"),askVolume:this.safeString(e,"askQty"),vwap:this.safeString(e,"weightedAvgPrice"),open:this.safeString(e,"openPrice"),close:a,last:a,previousClose:this.safeString(e,"prevClosePrice"),change:this.safeString(e,"priceChange"),percentage:this.safeString(e,"priceChangePercent"),average:void 0,baseVolume:o,quoteVolume:n,info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.binanceGetTicker24hr(t);return this.parseTickers(s,e)}getMarketIdByType(e){return"USDT"===e.quote?e.baseId+e.quoteId:e.id}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.baseId+s.quoteId},r=await this.binanceGetTicker24hr(this.extend(i,t));if(Array.isArray(r)){const e=this.safeDict(r,0,{});return this.parseTicker(e,s)}return this.parseTicker(r,s)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();const s=await this.binanceGetTickerBookTicker(t);return this.parseTickers(s,e)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.safeString(r,"price"),n=this.safeInteger(r,"until");r=this.omit(r,["price","until"]),i=void 0===i?500:Math.min(i,1500);const d={interval:this.safeString(this.timeframes,t,t),limit:i};let h;"index"===o?d.pair=a.id:d.symbol=this.getMarketIdByType(a),void 0!==s&&(d.startTime=s),void 0!==n&&(d.endTime=n),h="USDT"===a.quote?await this.binanceGetKlines(this.extend(d,r)):await this.publicGetOpenV1MarketKlines(this.extend(d,r));const c=this.safeList(h,"data",h);return this.parseOHLCVs(c,a,t,s,i)}async fetchBalance(e={}){await this.loadMarkets();const t=this.safeString2(this.options,"fetchBalance","defaultType","spot"),s=this.safeString(e,"type",t),i=this.safeString2(this.options,"marginMode","defaultMarginMode"),r=this.safeStringLower(e,"marginMode",i),a=await this.privateGetOpenV1AccountSpot(this.extend({},e));return this.parseBalanceCustom(a,s,r)}parseBalanceCustom(e,t=void 0,s=void 0){const i=this.safeInteger(e,"updateTime"),r={info:e,timestamp:i,datetime:this.iso8601(i)},a=this.safeValue(e,"data",{}),o=this.safeValue(a,"accountAssets",[]);for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"asset"),i=this.safeCurrencyCode(s),a=this.account();a.free=this.safeString(t,"free"),a.used=this.safeString(t,"locked"),r[i]=a}return this.safeBalance(r)}parseOrderStatus(e){return this.safeString({"-2":"open",0:"open",1:"open",2:"closed",3:"canceled",4:"canceling",5:"rejected",6:"expired",NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",PENDING_CANCEL:"canceling",REJECTED:"rejected",EXPIRED:"expired"},e,e)}parseOrder(e,t=void 0){const s=this.parseOrderStatus(this.safeString(e,"status")),i=this.safeString(e,"symbol"),r=this.safeSymbol(i,t),a=this.safeString(e,"executedQty","0"),o=this.safeInteger(e,"createTime"),n=this.safeString(e,"avgPrice"),d=this.safeString2(e,"price","executedPrice"),h=this.safeString(e,"origQty"),c=this.safeStringN(e,["cummulativeQuoteQty","cumQuote","executedQuoteQty","cumBase"]),l=this.safeString(e,"orderId"),u=this.parseOrderType(this.safeStringLower(e,"type"));let p=this.safeStringLower(e,"side");"0"===p?p="buy":"1"===p&&(p="sell");const f=this.safeValue(e,"fills",[]),m=this.safeString2(e,"clientOrderId","clientId");let g=this.safeString(e,"timeInForce");"GTX"===g&&(g="PO");const v="limit_maker"===u||"PO"===g,y=this.safeString(e,"stopPrice"),w=this.parseNumber(this.omitZero(y));return this.safeOrder({info:e,id:l,clientOrderId:m,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:void 0,symbol:r,type:u,timeInForce:g,postOnly:v,reduceOnly:this.safeValue(e,"reduceOnly"),side:p,price:d,stopPrice:w,triggerPrice:w,amount:h,cost:c,average:n,filled:a,remaining:void 0,status:s,fee:void 0,trades:f},t)}parseOrderType(e){return this.safeString({2:"market",1:"limit",4:"limit",7:"limit"},e,e)}async createOrder(e,t,s,i,n=void 0,d={}){await this.loadMarkets();const h=this.market(e),c=this.safeString2(d,"clientOrderId","clientId");this.safeBool(d,"postOnly",!1)&&(t="LIMIT_MAKER"),d=this.omit(d,["clientId","clientOrderId"]);const l=t.toUpperCase();let u=l;const p=this.safeValue2(d,"triggerPrice","stopPrice");void 0!==p&&(d=this.omit(d,["triggerPrice","stopPrice"]),"MARKET"===u?u="STOP_LOSS":"LIMIT"===u&&(u="STOP_LOSS_LIMIT"));const f=this.safeValue(h.info,"orderTypes");if(!this.inArray(u,f))throw l!==u?new a.InvalidOrder(this.id+" stopPrice parameter is not allowed for "+e+" "+t+" orders"):new a.InvalidOrder(this.id+" "+t+" is not a valid order type for the "+e+" market");const m={symbol:h.baseId+"_"+h.quoteId,type:this.safeString({LIMIT:1,MARKET:2,STOP_LOSS:3,STOP_LOSS_LIMIT:4,TAKE_PROFIT:5,TAKE_PROFIT_LIMIT:6,LIMIT_MAKER:7},u)};if("buy"===s?m.side=0:"sell"===s&&(m.side=1),void 0===c){const e=this.safeValue(this.options,"broker");if(void 0!==e){const t=this.safeString(e,"marketType");void 0!==t&&(m.clientId=t+this.uuid22())}}else m.clientId=c;let g=!1,v=!1,y=!1;if("MARKET"===u)if("buy"===s){const e=h.precision.price;let t,s=!0;[s,d]=this.handleOptionAndParams(d,"createOrder","createMarketBuyOrderRequiresPrice",!0);const c=this.safeNumber2(d,"cost","quoteOrderQty");if(d=this.omit(d,["cost","quoteOrderQty"]),void 0!==c)t=c;else if(s){if(void 0===n)throw new a.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const e=this.numberToString(i),s=this.numberToString(n);t=o.Y.stringMul(e,s)}}else t=i;m.quoteOrderQty=this.decimalToPrecision(t,r.R3,e,this.precisionMode)}else y=!0;else"LIMIT"===u?(g=!0,y=!0):"STOP_LOSS"===u||"TAKE_PROFIT"===u?(v=!0,y=!0,(h.linear||h.inverse)&&(g=!0)):"STOP_LOSS_LIMIT"===u||"TAKE_PROFIT_LIMIT"===u?(y=!0,v=!0,g=!0):"LIMIT_MAKER"===u&&(g=!0,y=!0);if(y&&(m.quantity=this.amountToPrecision(e,i)),g){if(void 0===n)throw new a.InvalidOrder(this.id+" createOrder() requires a price argument for a "+t+" order");m.price=this.priceToPrecision(e,n)}if(v){if(void 0===p)throw new a.InvalidOrder(this.id+" createOrder() requires a stopPrice extra param for a "+t+" order");m.stopPrice=this.priceToPrecision(e,p)}const w=await this.privatePostOpenV1Orders(this.extend(m,d)),b=this.safeDict(w,"data",{});return this.parseOrder(b,h)}async fetchOrder(e,t=void 0,s={}){const i={orderId:e},r=await this.privateGetOpenV1Orders(this.extend(i,s)),a=this.safeValue(r,"data",{}),o=this.safeValue(a,"list",[]),n=this.safeDict(o,0,{});return this.parseOrder(n)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s);const n=await this.privateGetOpenV1Orders(this.extend(o,i)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"list",[]);return this.parseOrders(h,r,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({type:1},i))}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrders(e,t,s,this.extend({type:2},i))}async cancelOrder(e,t=void 0,s={}){const i={orderId:e},r=await this.privatePostOpenV1OrdersCancel(this.extend(i,s)),a=this.safeDict(r,"data",{});return this.parseOrder(a)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new a.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const r=this.market(e),o={symbol:r.id},n=this.safeInteger2(i,"until","endTime");void 0!==t&&(o.startTime=t),void 0!==n&&(o.endTime=n,i=this.omit(i,["endTime","until"])),void 0!==s&&(o.limit=s);const d=await this.privateGetOpenV1OrdersTrades(this.extend(o,i)),h=this.safeValue(d,"data",{}),c=this.safeList(h,"list",[]);return this.parseTrades(c,r,t,s)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={asset:this.currency(e).id},i=this.safeValue(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(i,r,r),void 0!==r&&(s.network=r,t=this.omit(t,"network"));const a=await this.privateGetOpenV1DepositsAddress(this.extend(s,t)),o=this.safeValue(a,"data",{}),n=this.safeString(o,"address");let d=this.safeString(o,"addressTag","");return 0===d.length&&(d=void 0),this.checkAddress(n),{currency:e,address:n,tag:d,network:this.safeString(o,"network"),info:a}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={},o=this.safeInteger(i,"until");if(void 0!==e&&(r=this.currency(e),a.coin=r.id),void 0!==t){a.startTime=t;let e=this.sum(t,7776e6);void 0!==o&&(e=Math.min(e,o)),a.endTime=e}void 0!==s&&(a.limit=s);const n=await this.privateGetOpenV1Deposits(this.extend(a,i)),d=this.safeValue(n,"data",{}),h=this.safeList(d,"list",[]);return this.parseTransactions(h,r,t,s)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==t&&(r.startTime=t,r.endTime=this.sum(t,7776e6)),void 0!==s&&(r.limit=s);const o=await this.privateGetOpenV1Withdraws(this.extend(r,i)),n=this.safeValue(o,"data",{}),d=this.safeList(n,"list",[]);return this.parseTransactions(d,a,t,s)}parseTransactionStatusByType(e,t=void 0){const s=this.safeValue({deposit:{0:"pending",1:"ok"},withdrawal:{0:"pending",1:"canceled",2:"pending",3:"failed",4:"pending",5:"failed",10:"ok"}},t,{});return this.safeString(s,e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"address");let i=this.safeString(e,"addressTag");void 0!==i&&i.length<1&&(i=void 0);let r=this.safeString(e,"txId");void 0!==r&&r.indexOf("Internal transfer ")>=0&&(r=r.slice(18));const a=this.safeString2(e,"coin","fiatCurrency"),o=this.safeCurrencyCode(a,t);let n;const d=this.safeInteger(e,"insertTime"),h=this.safeInteger2(e,"createTime","timestamp");let c=this.safeString(e,"type");void 0===c&&(void 0!==d&&void 0===h?(c="deposit",n=d):void 0===d&&void 0!==h&&(c="withdrawal",n=h));const l=this.safeNumber2(e,"transactionFee","totalFee"),u={currency:void 0,cost:void 0,rate:void 0};void 0!==l&&(u.currency=o,u.cost=l);let p=!1;void 0!==this.safeInteger(e,"transferType")&&(p=!0);let f=this.safeString(e,"id");if(void 0===f){const t=this.safeValue(e,"data",{});f=this.safeString(t,"withdrawId"),c="withdrawal"}return{info:e,id:f,txid:r,type:c,currency:o,network:this.safeString(e,"network"),amount:this.safeNumber(e,"amount"),status:this.parseTransactionStatusByType(this.safeString(e,"status"),c),timestamp:n,datetime:this.iso8601(n),address:s,addressFrom:void 0,addressTo:s,tag:i,tagFrom:void 0,tagTo:i,updated:this.safeInteger2(e,"successTime","updateTime"),comment:void 0,internal:p,fee:u}}async withdraw(e,t,s,i=void 0,r={}){[i,r]=this.handleWithdrawTagAndParams(i,r),await this.loadMarkets(),this.checkAddress(s);const a=this.currency(e),o={asset:a.id,address:s,amount:this.numberToString(t)};void 0!==i&&(o.addressTag=i);const[n,d]=this.handleNetworkCodeAndParams(r),h=this.networkCodeToId(n);void 0!==h&&(o.network=h.toUpperCase());const c=await this.privatePostOpenV1Withdraws(this.extend(o,d));return this.parseTransaction(c,a)}sign(e,t="public",s="GET",i={},r=void 0,o=void 0){if(!(t in this.urls.api.rest))throw new a.NotSupported(this.id+" does not have a testnet/sandbox URL for "+t+" endpoints");let d=this.urls.api.rest[t];d+="/"+e,"wapi"===t&&(d+=".html");if("userDataStream"===e||"listenKey"===e){if(!this.apiKey)throw new a.AuthenticationError(this.id+" userDataStream endpoint requires `apiKey` credential");r={"X-MBX-APIKEY":this.apiKey,"Content-Type":"application/x-www-form-urlencoded"},"GET"!==s&&(o=this.urlencode(i))}else if("private"===t||"sapi"===t&&"system/status"!==e||"sapiV3"===t||"wapi"===t&&"systemStatus"!==e||"dapiPrivate"===t||"dapiPrivateV2"===t||"fapiPrivate"===t||"fapiPrivateV2"===t){let a;this.checkRequiredCredentials();const h=this.safeInteger(this.options,"recvWindow"),c=this.extend({timestamp:this.nonce()},i);void 0!==h&&(c.recvWindow=h);const l=this.safeInteger(i,"recvWindow");void 0!==l&&(c.recvWindow=l),a="sapi"===t&&"asset/dust"===e?this.urlencodeWithArrayRepeat(c):"batchOrders"===e||e.indexOf("sub-account")>=0||"capital/withdraw/apply"===e||e.indexOf("staking")>=0?this.rawencode(c):this.urlencode(c);a+="&signature="+this.hmac(this.encode(a),this.encode(this.secret),n.s),r={"X-MBX-APIKEY":this.apiKey},"GET"===s||"DELETE"===s||"wapi"===t?d+="?"+a:(o=a,r["Content-Type"]="application/x-www-form-urlencoded")}else Object.keys(i).length&&(d+="?"+this.urlencode(i));return{url:d,method:s,body:o,headers:r}}handleErrors(e,t,s,i,r,n,d,h,c){if(418===e||429===e)throw new a.DDoSProtection(this.id+" "+e.toString()+" "+t+" "+n);if(e>=400){if(n.indexOf("Price * QTY is zero or less")>=0)throw new a.InvalidOrder(this.id+" order cost = amount * price is zero or less "+n);if(n.indexOf("LOT_SIZE")>=0)throw new a.InvalidOrder(this.id+" order amount should be evenly divisible by lot size "+n);if(n.indexOf("PRICE_FILTER")>=0)throw new a.InvalidOrder(this.id+" order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "+n)}if(void 0===d)return;const l=this.safeBool(d,"success",!0);if(!l){const e=this.safeString(d,"msg");let t;if(void 0!==e){try{t=JSON.parse(e)}catch(e){t=void 0}void 0!==t&&(d=t)}}const u=this.safeString(d,"msg");void 0!==u&&(this.throwExactlyMatchedException(this.exceptions.exact,u,this.id+" "+u),this.throwBroadlyMatchedException(this.exceptions.broad,u,this.id+" "+u));const p=this.safeString(d,"code");if(void 0!==p){if("200"===p||o.Y.stringEquals(p,"0"))return;if("-2015"===p&&this.options.hasAlreadyAuthenticatedSuccessfully)throw new a.DDoSProtection(this.id+" "+n);const e=this.id+" "+n;if("No need to change margin type."===u)throw new a.MarginModeAlreadySet(e);throw this.throwExactlyMatchedException(this.exceptions.exact,p,e),new a.ExchangeError(e)}if(!l)throw new a.ExchangeError(this.id+" "+n)}calculateRateLimiterCost(e,t,s,i,r={}){if("noCoin"in r&&!("coin"in i))return r.noCoin;if("noSymbol"in r&&!("symbol"in i))return r.noSymbol;if("noPoolId"in r&&!("poolId"in i))return r.noPoolId;if("byLimit"in r&&"limit"in i){const e=i.limit,t=r.byLimit;for(let s=0;s<t.length;s++){const i=t[s];if(e<=i[0])return i[1]}}return this.safeInteger(r,"cost",1)}}},5887:(e,t,s)=>{s.d(t,{A:()=>o});var i=s(4352),r=s(2079),a=s(1579);class o extends i.A{describe(){return this.deepExtend(super.describe(),{id:"tradeogre",name:"tradeogre",countries:[],rateLimit:100,version:"v2",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createMarketOrder:!1,createOrder:!0,createOrders:!1,createPostOnlyOrder:!1,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!1,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDepositAddressesByNetwork:!1,fetchDeposits:!1,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLedgerEntry:!1,fetchLeverageTiers:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!1,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!1,fetchOrderTrades:!1,fetchPermissions:!1,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!1,fetchTrades:!0,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawAddresses:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!1,withdraw:!1},urls:{referral:"",logo:"https://github.com/ccxt/ccxt/assets/43336371/3aa748b7-ea44-45e9-a9e7-b1d207a2578a",api:{rest:"https://tradeogre.com/api/v1"},www:"https://tradeogre.com",doc:"https://tradeogre.com/help/api",fees:"https://tradeogre.com/help/fees"},fees:{trading:{maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002")}},api:{public:{get:{markets:1,"orders/{market}":1,"ticker/{market}":1,"history/{market}":1}},private:{get:{"account/balance":1,"account/balances":1,"account/order/{uuid}":1},post:{"order/buy":1,"order/sell":1,"order/cancel":1,orders:1,"account/orders":1}}},commonCurrencies:{},precisionMode:a.kb,exceptions:{exact:{"Must be authorized":r.AuthenticationError,"Market not found":r.BadRequest,"Insufficient funds":r.InsufficientFunds,"Order not found":r.BadRequest}},options:{}})}async fetchMarkets(e={}){const t=await this.publicGetMarkets(e),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=Object.keys(i),a=this.safeString(r,0),o=a.split("-"),n=this.safeString(o,0),d=this.safeString(o,1),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d),l=this.safeMarketStructure({id:a,symbol:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,taker:this.fees.trading.taker,maker:this.fees.trading.maker,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision("8")),price:this.parseNumber(this.parsePrecision("8"))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:i});s.push(l)}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.publicGetTickerMarket(this.extend(i,t));return this.parseTicker(r,s)}parseTicker(e,t=void 0){return this.safeTicker({symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:void 0,last:void 0,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"volume"),quoteVolume:void 0,info:e},t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={market:this.market(e).id},r=await this.publicGetOrdersMarket(this.extend(i,s)),a={bids:this.safeDict(r,"buy",{}),asks:this.safeDict(r,"sell",{})};return this.parseOrderBook(a,e)}parseBidsAsks(e,t=0,s=1,i=2){const r=Object.keys(e),a=[];for(let t=0;t<r.length;t++){const s=this.safeString(r,t),i=this.safeNumber(r,t),o=this.safeNumber(e,s);a.push([i,o])}return a}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.publicGetHistoryMarket(this.extend(a,i));return this.parseTrades(o,r,t,s)}parseTrade(e,t=void 0){const s=this.safeIntegerProduct(e,"date",1e3);return this.safeTrade({info:e,id:void 0,timestamp:s,datetime:this.iso8601(s),symbol:this.safeString(t,"symbol"),order:void 0,type:void 0,side:this.safeString(e,"type"),takerOrMaker:void 0,price:this.safeString(e,"price"),amount:this.safeString(e,"quantity"),cost:void 0,fee:{currency:void 0,cost:void 0}},t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccountBalances(e),s=this.safeDict(t,"balances",{});return this.parseBalance(s)}parseBalance(e){const t={info:e},s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i],a={total:e[r]};t[this.safeCurrencyCode(r)]=a}return this.safeBalance(t)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e);if("market"===t)throw new r.BadRequest(this.id+" createOrder does not support market orders");if(void 0===a)throw new r.ArgumentsRequired(this.id+" createOrder requires a limit parameter");const d={market:n.id,quantity:this.parseToNumeric(this.amountToPrecision(e,i)),price:this.parseToNumeric(this.priceToPrecision(e,a))};let h;return h="buy"===s?await this.privatePostOrderBuy(this.extend(d,o)):await this.privatePostOrderSell(this.extend(d,o)),this.parseOrder(h,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},r=await this.privatePostOrderCancel(this.extend(i,s));return this.parseOrder(r)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();return[await this.cancelOrder("all",e,t)]}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==e&&(r=this.market(e));const a={};void 0!==e&&(a.market=r.id);const o=await this.privatePostAccountOrders(this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},r=await this.privateGetAccountOrderUuid(this.extend(i,s));return this.parseOrder(r,void 0)}parseOrder(e,t=void 0){const s=this.safeIntegerProduct(e,"date",1e3),i=this.safeString(e,"market");return t=this.safeMarket(i,t),this.safeOrder({info:e,id:this.safeString(e,"uuid"),clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:t.symbol,type:void 0,timeInForce:void 0,postOnly:void 0,side:this.safeString(e,"type"),price:this.safeString(e,"price"),stopPrice:void 0,amount:this.safeString(e,"quantity"),cost:void 0,average:void 0,filled:this.safeString(e,"fulfilled"),remaining:void 0,status:void 0,fee:{currency:void 0,cost:void 0},trades:void 0},t)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+this.implodeParams(e,i);return i=this.omit(i,this.extractParams(e)),"GET"===s&&Object.keys(i).length&&(o+="?"+this.urlencode(i)),"private"===t&&(r={"Content-Type":"application/x-www-form-urlencoded",Referer:"CCXT",authorization:"Basic "+this.stringToBase64(this.apiKey+":"+this.secret)},"GET"!==s&&(a=this.urlencode(i))),{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;if(!("success"in n))return;if(this.safeBool(n,"success"))return;if("true"===this.safeString(n,"success"))return;const c=this.safeValue(n,"error"),l=this.safeString(c,"code"),u=this.id+" "+this.json(n);throw this.throwExactlyMatchedException(this.exceptions.exact,l,u),new r.ExchangeError(u)}}},930:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(6405),r=s(2079),a=s(5147),o=s(1579),n=s(7481),d=s(4852),h=s(5354);class c extends i.A{describe(){return this.deepExtend(super.describe(),{id:"upbit",name:"Upbit",countries:["KR"],version:"v1",rateLimit:1e3,pro:!0,has:{CORS:!0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createDepositAddress:!0,createMarketBuyOrderWithCost:!0,createMarketOrder:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,fetchBalance:!0,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchOrders:!1,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!0,fetchTradingFees:!1,fetchTransactions:!1,fetchWithdrawal:!0,fetchWithdrawals:!0,transfer:!1,withdraw:!0},timeframes:{"1m":"minutes","3m":"minutes","5m":"minutes","10m":"minutes","15m":"minutes","30m":"minutes","1h":"minutes","4h":"minutes","1d":"days","1w":"weeks","1M":"months"},hostname:"api.upbit.com",urls:{logo:"https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",api:{public:"https://{hostname}",private:"https://{hostname}"},www:"https://upbit.com",doc:"https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",fees:"https://upbit.com/service_center/guide"},api:{public:{get:["market/all","candles/{timeframe}","candles/{timeframe}/{unit}","candles/minutes/{unit}","candles/minutes/1","candles/minutes/3","candles/minutes/5","candles/minutes/10","candles/minutes/15","candles/minutes/30","candles/minutes/60","candles/minutes/240","candles/days","candles/weeks","candles/months","trades/ticks","ticker","orderbook"]},private:{get:["accounts","orders/chance","order","orders","orders/closed","orders/open","orders/uuids","withdraws","withdraw","withdraws/chance","deposits","deposit","deposits/coin_addresses","deposits/coin_address"],post:["orders","withdraws/coin","withdraws/krw","deposits/generate_coin_address"],delete:["order"]}},fees:{trading:{tierBased:!1,percentage:!0,maker:this.parseNumber("0.0025"),taker:this.parseNumber("0.0025")},funding:{tierBased:!1,percentage:!1,withdraw:{},deposit:{}}},precisionMode:o.kb,exceptions:{exact:{"This key has expired.":r.AuthenticationError,"Missing request parameter error. Check the required parameters!":r.BadRequest,"side is missing, side does not have a valid value":r.InvalidOrder},broad:{thirdparty_agreement_required:r.PermissionDenied,out_of_scope:r.PermissionDenied,order_not_found:r.OrderNotFound,insufficient_funds:r.InsufficientFunds,invalid_access_key:r.AuthenticationError,jwt_verification:r.AuthenticationError,create_ask_error:r.ExchangeError,create_bid_error:r.ExchangeError,volume_too_large:r.InvalidOrder,invalid_funds:r.InvalidOrder}},options:{createMarketBuyOrderRequiresPrice:!0,fetchTickersMaxLength:4096,fetchOrderBooksMaxLength:4096,tradingFeesByQuoteCurrency:{KRW:5e-4}},commonCurrencies:{TON:"Tokamak Network"}})}async fetchCurrency(e,t={}){await this.loadMarkets();const s=this.currency(e);return await this.fetchCurrencyById(s.id,t)}async fetchCurrencyById(e,t={}){const s={currency:e},i=await this.privateGetWithdrawsChance(this.extend(s,t)),r=this.safeValue(i,"member_level",{}),o=this.safeValue(i,"currency",{}),n=this.safeValue(i,"withdraw_limit",{}),d=this.safeValue(n,"can_withdraw"),h=this.safeString(o,"wallet_state"),c=this.safeValue(r,"wallet_locked"),l=this.safeValue(r,"locked");let u=!0;void 0===d||d?("working"!==h||void 0!==c&&c||void 0!==l&&l)&&(u=!1):u=!1;const p=this.safeString(n,"onetime"),f=this.safeString(n,"daily",p),m=this.safeString(n,"remaining_daily",f);let g;g=a.Y.stringGt(m,"0")?m:f;const v=this.safeString(o,"code"),y=this.safeCurrencyCode(v);return{info:i,id:v,code:y,name:y,active:u,fee:this.safeNumber(o,"withdraw_fee"),precision:void 0,limits:{withdraw:{min:this.safeNumber(n,"minimum"),max:this.parseNumber(g)}}}}async fetchMarket(e,t={}){await this.loadMarkets();const s=this.market(e);return await this.fetchMarketById(s.id,t)}async fetchMarketById(e,t={}){const s={market:e},i=await this.privateGetOrdersChance(this.extend(s,t)),r=this.safeValue(i,"market"),o=this.safeValue(r,"bid"),n=this.safeValue(r,"ask"),d=this.safeString(r,"id"),h=this.safeString(n,"currency"),c=this.safeString(o,"currency"),l=this.safeCurrencyCode(h),u=this.safeCurrencyCode(c),p=this.safeString(r,"state"),f=this.safeString(i,"bid_fee"),m=this.safeString(i,"ask_fee"),g=this.parseNumber(a.Y.stringMax(f,m));return this.safeMarketStructure({id:d,symbol:l+"/"+u,base:l,quote:u,settle:void 0,baseId:h,quoteId:c,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:"active"===p,contract:!1,linear:void 0,inverse:void 0,taker:g,maker:g,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber("1e-8"),price:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(n,"min_total"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(o,"min_total"),max:this.safeNumber(r,"max_total")},info:i}})}async fetchMarkets(e={}){const t=await this.publicGetMarketAll(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"market"),[s,i]=t.split("-"),r=this.safeCurrencyCode(i),a=this.safeCurrencyCode(s);return this.safeMarketStructure({id:t,symbol:r+"/"+a,base:r,quote:a,settle:void 0,baseId:i,quoteId:s,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:!0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,a,this.fees.trading.taker),maker:this.safeNumber(this.options.tradingFeesByQuoteCurrency,a,this.fees.trading.maker),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{price:this.parseNumber("1e-8"),amount:this.parseNumber("1e-8")},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e})}parseBalance(e){const t={info:e,timestamp:void 0,datetime:void 0};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"balance"),o.used=this.safeString(i,"locked"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetAccounts(e);return this.parseBalance(t)}async fetchOrderBooks(e=void 0,t=void 0,s={}){let i;if(await this.loadMarkets(),void 0===e){if(i=this.ids.join(","),i.length>this.options.fetchOrderBooksMaxLength){const e=this.ids.length;throw new r.ExchangeError(this.id+" fetchOrderBooks() has "+e.toString()+" symbols ("+i.length.toString()+" characters) exceeding max URL length ("+this.options.fetchOrderBooksMaxLength.toString()+" characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join(",");const a={markets:i},o=await this.publicGetOrderbook(this.extend(a,s)),n={};for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"market"),i=this.safeSymbol(s,void 0,"-"),r=this.safeInteger(t,"timestamp");n[i]={symbol:i,bids:this.sortBy(this.parseBidsAsks(t.orderbook_units,"bid_price","bid_size"),0,!0),asks:this.sortBy(this.parseBidsAsks(t.orderbook_units,"ask_price","ask_size"),0),timestamp:r,datetime:this.iso8601(r),nonce:void 0}}return n}async fetchOrderBook(e,t=void 0,s={}){const i=await this.fetchOrderBooks([e],t,s);return this.safeValue(i,e)}parseTicker(e,t=void 0){const s=this.safeInteger(e,"trade_timestamp"),i=this.safeString2(e,"market","code");t=this.safeMarket(i,t,"-");const r=this.safeString(e,"trade_price");return this.safeTicker({symbol:t.symbol,timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high_price"),low:this.safeString(e,"low_price"),bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:this.safeString(e,"opening_price"),close:r,last:r,previousClose:this.safeString(e,"prev_closing_price"),change:this.safeString(e,"signed_change_price"),percentage:this.safeString(e,"signed_change_rate"),average:void 0,baseVolume:this.safeString(e,"acc_trade_volume_24h"),quoteVolume:this.safeString(e,"acc_trade_price_24h"),info:e},t)}async fetchTickers(e=void 0,t={}){let s;if(await this.loadMarkets(),void 0===(e=this.marketSymbols(e))){if(s=this.ids.join(","),s.length>this.options.fetchTickersMaxLength){const e=this.ids.length;throw new r.ExchangeError(this.id+" fetchTickers() has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")}}else s=this.marketIds(e),s=s.join(",");const i={markets:s},a=await this.publicGetTicker(this.extend(i,t)),o={};for(let e=0;e<a.length;e++){const t=this.parseTicker(a[e]);o[t.symbol]=t}return this.filterByArrayTickers(o,"symbol",e)}async fetchTicker(e,t={}){const s=await this.fetchTickers([e],t);return this.safeValue(s,e)}parseTrade(e,t=void 0){const s=this.safeString2(e,"sequential_id","uuid");let i,r=this.safeInteger(e,"timestamp");void 0===r&&(r=this.parse8601(this.safeString(e,"created_at")));const a=this.safeStringLower2(e,"ask_bid","side");"ask"===a?i="sell":"bid"===a&&(i="buy");const o=this.safeString(e,"funds"),n=this.safeString2(e,"trade_price","price"),d=this.safeString2(e,"trade_volume","volume"),h=this.safeString2(e,"market","code");let c;t=this.safeMarket(h,t,"-");const l=this.safeString(e,a+"_fee");return void 0!==l&&(c={currency:t.quote,cost:l}),this.safeTrade({id:s,info:e,order:undefined,timestamp:r,datetime:this.iso8601(r),symbol:t.symbol,type:void 0,side:i,takerOrMaker:void 0,price:n,amount:d,cost:o,fee:c},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);void 0===s&&(s=200);const a={market:r.id,count:s},o=await this.publicGetTradesTicks(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchTradingFee(e,t={}){await this.loadMarkets();const s={market:this.market(e).id},i=await this.privateGetOrdersChance(this.extend(s,t)),r=this.safeString(i,"ask_fee"),o=this.safeString(i,"bid_fee"),n=a.Y.stringMax(r,o),d=this.safeString(i,"maker_ask_fee"),h=this.safeString(i,"maker_bid_fee"),c=a.Y.stringMax(d,h);return{info:i,symbol:e,maker:this.parseNumber(c),taker:this.parseNumber(n),percentage:!0,tierBased:!1}}parseOHLCV(e,t=void 0){return[this.parse8601(this.safeString(e,"candle_date_time_utc")),this.safeNumber(e,"opening_price"),this.safeNumber(e,"high_price"),this.safeNumber(e,"low_price"),this.safeNumber(e,"trade_price"),this.safeNumber(e,"candle_acc_trade_volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o=this.parseTimeframe(t),n=this.safeString(this.timeframes,t,t);void 0===i&&(i=200);const d={market:a.id,timeframe:n,count:i};let h;if(void 0!==s&&(d.to=this.iso8601(this.sum(s,o*i*1e3))),"minutes"===n){const e=Math.round(o/60);d.unit=e,h=await this.publicGetCandlesTimeframeUnit(this.extend(d,r))}else h=await this.publicGetCandlesTimeframe(this.extend(d,r));return this.parseOHLCVs(h,a,t,s,i)}async createOrder(e,t,s,i,o=void 0,n={}){await this.loadMarkets();const d=this.market(e);let h;if("buy"===s)h="bid";else{if("sell"!==s)throw new r.InvalidOrder(this.id+" createOrder() allows buy or sell side only!");h="ask"}const c={market:d.id,side:h};if("limit"===t&&(c.price=this.priceToPrecision(e,o)),"market"===t&&"buy"===s){let t,s=!0;[s,n]=this.handleOptionAndParams(n,"createOrder","createMarketBuyOrderRequiresPrice",!0);const d=this.safeNumber(n,"cost");if(n=this.omit(n,"cost"),void 0!==d)t=this.costToPrecision(e,d);else if(s){if(void 0===o)throw new r.InvalidOrder(this.id+" createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument");{const s=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(s,r);t=this.costToPrecision(e,n)}}else t=this.costToPrecision(e,i);c.ord_type="price",c.price=t}else c.ord_type=t,c.volume=this.amountToPrecision(e,i);const l=this.safeString2(n,"clientOrderId","identifier");if(void 0!==l&&(c.identifier=l),"market"!==t){const e=this.safeStringLower2(n,"timeInForce","time_in_force");n=this.omit(n,"timeInForce"),void 0!==e&&(c.time_in_force=e)}n=this.omit(n,["clientOrderId","identifier"]);const u=await this.privatePostOrders(this.extend(c,n));return this.parseOrder(u)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},r=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(r)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetDeposits(this.extend(r,i));return this.parseTransactions(o,a,t,s)}async fetchDeposit(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e};let r;void 0!==t&&(r=this.currency(t),i.currency=r.id);const a=await this.privateGetDeposit(this.extend(i,s));return this.parseTransaction(a,r)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetWithdraws(this.extend(r,i));return this.parseTransactions(o,a,t,s)}async fetchWithdrawal(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e};let r;void 0!==t&&(r=this.currency(t),i.currency=r.id);const a=await this.privateGetWithdraw(this.extend(i,s));return this.parseTransaction(a,r)}parseTransactionStatus(e){return this.safeString({submitting:"pending",submitted:"pending",almost_accepted:"pending",rejected:"failed",accepted:"ok",processing:"pending",done:"ok",canceled:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"done_at"),i=this.parse8601(this.safeString(e,"created_at",s));let r=this.safeString(e,"type");"withdraw"===r&&(r="withdrawal");const a=this.safeString(e,"currency"),o=this.safeCurrencyCode(a,t);return{info:e,id:this.safeString(e,"uuid"),currency:o,amount:this.safeNumber(e,"amount"),network:void 0,address:undefined,addressTo:void 0,addressFrom:void 0,tag:undefined,tagTo:void 0,tagFrom:void 0,status:this.parseTransactionStatus(this.safeStringLower(e,"state")),type:r,updated:this.parse8601(s),txid:this.safeString(e,"txid"),timestamp:i,datetime:this.iso8601(i),internal:void 0,comment:void 0,fee:{currency:o,cost:this.safeNumber(e,"fee")}}}parseOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"uuid");let i=this.safeString(e,"side");i="bid"===i?"buy":"sell";let r=this.safeString(e,"ord_type");const o=this.parse8601(this.safeString(e,"created_at")),n=this.parseOrderStatus(this.safeString(e,"state"));let d,h=this.safeString(e,"price");const c=this.safeString(e,"volume"),l=this.safeString(e,"remaining_volume"),u=this.safeString(e,"executed_volume");let p,f,m;"price"===r&&(r="market",p=h,h=void 0);let g=this.safeString(e,"paid_fee");const v=this.safeString(e,"market");t=this.safeMarket(v,t);let y=this.safeValue(e,"trades",[]);y=this.parseTrades(y,t,void 0,void 0,{order:s,type:r});const w=y.length;if(w>0){d=y[w-1].timestamp;let e=!1;void 0===g&&(e=!0,g="0"),p="0";for(let t=0;t<w;t++){const s=y[t];if(p=a.Y.stringAdd(p,this.safeString(s,"cost")),e){const e=this.safeValue(y[t],"fee",{}),s=this.safeString(e,"cost");void 0!==s&&(g=a.Y.stringAdd(g,s))}}f=a.Y.stringDiv(p,u)}return void 0!==g&&(m={currency:t.quote,cost:g}),this.safeOrder({info:e,id:s,clientOrderId:void 0,timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:d,symbol:t.symbol,type:r,timeInForce:this.safeStringUpper(e,"time_in_force"),postOnly:void 0,side:i,price:h,stopPrice:void 0,triggerPrice:void 0,cost:this.parseNumber(p),average:this.parseNumber(f),amount:c,filled:u,remaining:l,status:n,fee:m,trades:y})}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.market=a.id),void 0!==s&&(r.limit=s);const o=await this.privateGetOrdersOpen(this.extend(r,i));return this.parseOrders(o,a,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a={state:"done"};void 0!==e&&(r=this.market(e),a.market=r.id),void 0!==t&&(a.start_time=t),void 0!==s&&(a.limit=s),[a,i]=this.handleUntilOption("end_time",a,i);const o=await this.privateGetOrdersClosed(this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r,a={state:"cancel"};void 0!==e&&(r=this.market(e),a.market=r.id),void 0!==t&&(a.start_time=t),void 0!==s&&(a.limit=s),[a,i]=this.handleUntilOption("end_time",a,i);const o=await this.privateGetOrdersClosed(this.extend(a,i));return this.parseOrders(o,r,t,s)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={uuid:e},r=await this.privateGetOrder(this.extend(i,s));return this.parseOrder(r)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.privateGetDepositsCoinAddresses(t);return this.parseDepositAddresses(s,e)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"deposit_address"),i=this.safeString(e,"secondary_address"),r=this.safeString(e,"currency"),a=this.safeCurrencyCode(r),o=this.safeString(e,"net_type");return this.checkAddress(s),{currency:a,address:s,tag:i,network:this.networkIdToCode(o),info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e);let i;if([i,t]=this.handleNetworkCodeAndParams(t),void 0===i)throw new r.ArgumentsRequired(this.id+' fetchDepositAddress requires params["network"]');const a=await this.privateGetDepositsCoinAddress(this.extend({currency:s.id,net_type:this.networkCodeToId(i,s.code)},t));return this.parseDepositAddress(a)}async createDepositAddress(e,t={}){await this.loadMarkets();const s={currency:this.currency(e).id},i=await this.privatePostDepositsGenerateCoinAddress(this.extend(s,t));if(void 0!==this.safeString(i,"message"))throw new r.AddressPending(this.id+" is generating "+e+" deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address");return this.parseDepositAddress(i)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),await this.loadMarkets();const o=this.currency(e),n={amount:t};let d;if("KRW"!==e){this.checkAddress(s);const e=this.safeStringUpper2(a,"network","net_type");if(void 0===e)throw new r.ArgumentsRequired(this.id+" withdraw() requires a network argument");a=this.omit(a,["network"]),n.net_type=e,n.currency=o.id,n.address=s,void 0!==i&&(n.secondary_address=i),a=this.omit(a,"network"),d=await this.privatePostWithdrawsCoin(this.extend(n,a))}else d=await this.privatePostWithdrawsKrw(this.extend(n,a));return this.parseTransaction(d)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.implodeParams(this.urls.api[t],{hostname:this.hostname});o+="/"+this.version+"/"+this.implodeParams(e,i);const c=this.omit(i,this.extractParams(e));if("POST"!==s&&Object.keys(c).length&&(o+="?"+this.urlencode(c)),"private"===t){this.checkRequiredCredentials(),r={};const e=this.uuid(),t={access_key:this.apiKey,nonce:e},o=Object.keys(c).length;let l;if("GET"!==s&&"DELETE"!==s&&(a=this.json(i),r["Content-Type"]="application/json"),o&&(l=this.rawencode(c)),void 0!==l){const e=this.hash(this.encode(l),n.Zf);t.query_hash=e,t.query_hash_alg="SHA512"}const u=(0,h.a)(t,this.encode(this.secret),d.s);r.Authorization="Bearer "+u}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeValue(n,"error");if(void 0!==c){const e=this.safeString(c,"message"),t=this.safeString(c,"name"),s=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,s),this.throwExactlyMatchedException(this.exceptions.exact,t,s),this.throwBroadlyMatchedException(this.exceptions.broad,e,s),this.throwBroadlyMatchedException(this.exceptions.broad,t,s),new r.ExchangeError(s)}}}},4910:(e,t,s)=>{s.d(t,{A:()=>c});var i=s(8139),r=s(2079),a=s(5147),o=s(1579),n=s(8432),d=s(987),h=s(8283);class c extends i.A{describe(){return this.deepExtend(super.describe(),{id:"vertex",name:"Vertex",countries:[],version:"v1",rateLimit:50,certified:!1,pro:!0,dex:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!0,future:!0,option:!1,addMargin:!1,borrowCrossMargin:!1,borrowIsolatedMargin:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!1,cancelOrder:!0,cancelOrders:!0,cancelOrdersForSymbols:!1,closeAllPositions:!1,closePosition:!1,createMarketBuyOrderWithCost:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrders:!0,createReduceOnlyOrder:!0,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCanceledOrders:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDepositAddresses:!1,fetchDeposits:!1,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchLiquidations:!1,fetchMarginMode:void 0,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyLiquidations:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!1,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!1,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":60,"5m":300,"15m":900,"1h":3600,"2h":7200,"4h":14400,"1d":86400,"1w":604800,"1M":604800},hostname:"vertexprotocol.com",urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/bd04a0fa-3b48-47b6-9d8b-124954d520a8",api:{v1:{archive:"https://archive.prod.{hostname}/v1",gateway:"https://gateway.prod.{hostname}/v1",trigger:"https://trigger.prod.{hostname}/v1"},v2:{archive:"https://archive.prod.{hostname}/v2",gateway:"https://gateway.prod.{hostname}/v2"}},test:{v1:{archive:"https://archive.sepolia-test.{hostname}/v1",gateway:"https://gateway.sepolia-test.{hostname}/v1",trigger:"https://trigger.sepolia-test.{hostname}/v1"},v2:{archive:"https://archive.sepolia-test.{hostname}/v2",gateway:"https://gateway.sepolia-test.{hostname}/v2"}},www:"https://vertexprotocol.com/",doc:"https://docs.vertexprotocol.com/",fees:"https://docs.vertexprotocol.com/basics/fees",referral:"https://app.vertexprotocol.com?referrer=0xCfC9BaB96a2eA3d3c3F031c005e82E1D9F295aC1"},api:{v1:{archive:{post:{"":1}},gateway:{get:{query:1,symbols:1,time:1},post:{query:1,execute:1}},trigger:{post:{execute:1,query:1}}},v2:{archive:{get:{tickers:1,contracts:1,trades:1,vrtx:1}},gateway:{get:{assets:.6667,pairs:1,orderbook:1}}}},fees:{swap:{taker:this.parseNumber("0.0002"),maker:this.parseNumber("0.0002")},spot:{taker:this.parseNumber("0.0002"),maker:this.parseNumber("0.0002")}},requiredCredentials:{apiKey:!1,secret:!1,walletAddress:!0,privateKey:!0},exceptions:{exact:{1e3:r.RateLimitExceeded,1015:r.RateLimitExceeded,1001:r.PermissionDenied,1002:r.PermissionDenied,1003:r.PermissionDenied,2e3:r.InvalidOrder,2001:r.InvalidOrder,2002:r.InvalidOrder,2003:r.InvalidOrder,2004:r.InvalidOrder,2005:r.InvalidOrder,2006:r.InvalidOrder,2007:r.InvalidOrder,2008:r.InvalidOrder,2009:r.InvalidOrder,2010:r.InvalidOrder,2011:r.BadRequest,2012:r.BadRequest,2013:r.InvalidOrder,2014:r.PermissionDenied,2015:r.InvalidOrder,2016:r.InvalidOrder,2017:r.InvalidOrder,2019:r.InvalidOrder,2020:r.InvalidOrder,2021:r.InvalidOrder,2022:r.InvalidOrder,2023:r.InvalidOrder,2024:r.InsufficientFunds,2025:r.InsufficientFunds,2026:r.BadRequest,2027:r.AuthenticationError,2028:r.AuthenticationError,2029:r.AuthenticationError,2030:r.BadRequest,2031:r.InvalidOrder,2033:r.InvalidOrder,2034:r.InvalidOrder,2035:r.InvalidOrder,2036:r.InvalidOrder,2037:r.InvalidOrder,2038:r.InvalidOrder,2039:r.InvalidOrder,2040:r.InvalidOrder,2041:r.InvalidOrder,2042:r.InvalidOrder,2043:r.InvalidOrder,2044:r.InvalidOrder,2045:r.InvalidOrder,2046:r.InvalidOrder,2047:r.InvalidOrder,2048:r.InvalidOrder,2049:r.ExchangeError,2050:r.PermissionDenied,2051:r.InvalidOrder,2052:r.InvalidOrder,2053:r.InvalidOrder,2054:r.InvalidOrder,2055:r.InvalidOrder,2056:r.InvalidOrder,2057:r.InvalidOrder,2058:r.InvalidOrder,2059:r.InvalidOrder,2060:r.InvalidOrder,2061:r.InvalidOrder,2062:r.InvalidOrder,2063:r.InvalidOrder,2064:r.InvalidOrder,2065:r.InvalidOrder,2066:r.InvalidOrder,2067:r.InvalidOrder,2068:r.InvalidOrder,2069:r.InvalidOrder,2070:r.InvalidOrder,2071:r.InvalidOrder,2072:r.InvalidOrder,2073:r.InvalidOrder,2074:r.InvalidOrder,2075:r.InvalidOrder,2076:r.InvalidOrder,3e3:r.BadRequest,3001:r.BadRequest,3002:r.BadRequest,3003:r.BadRequest,4e3:r.BadRequest,4001:r.ExchangeError,4002:r.ExchangeError,4003:r.ExchangeError,4004:r.InvalidOrder,5e3:r.ExchangeError},broad:{}},precisionMode:o.kb,commonCurrencies:{},options:{defaultType:"swap",sandboxMode:!1,timeDifference:0,brokerId:5930043274845996}})}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}convertToX18(e){if("string"==typeof e)return a.Y.stringMul(e,"1000000000000000000");const t=this.numberToString(e);return a.Y.stringMul(t,"1000000000000000000")}convertFromX18(e){if("string"==typeof e)return a.Y.stringDiv(e,"1000000000000000000");const t=this.numberToString(e);return a.Y.stringDiv(t,"1000000000000000000")}async fetchCurrencies(e={}){const t=await this.v2GatewayGetAssets(this.extend({},e)),s={};for(let e=0;e<t.length;e++){const i=this.safeDict(t,e,{}),r=this.safeString(i,"ticker_id");if(void 0!==r&&r.indexOf("PERP")>0)continue;const a=this.safeString(i,"product_id"),o=this.safeString(i,"symbol"),n=this.safeCurrencyCode(o);s[n]={id:a,name:o,code:n,precision:void 0,info:i,active:void 0,deposit:this.safeBool(i,"can_deposit"),withdraw:this.safeBool(i,"can_withdraw"),networks:void 0,fee:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}}}}return s}parseMarket(e){const t=this.safeString(e,"type"),s="USDC",i=this.safeCurrencyCode(s),r=this.safeString(e,"symbol"),a=this.safeCurrencyCode(r),o=s,n=this.safeCurrencyCode(o);let d=a+"/"+i;const h="spot"===t,c=!h,l=!h;if(l){d=a.split("-")[0]+"/"+i+":"+n}const u=this.safeString(e,"price_increment_x18"),p=this.safeString(e,"size_increment"),f=this.safeString(e,"min_size"),m=this.safeNumber(e,"taker_fee_rate_x18"),g=this.safeNumber(e,"maker_fee_rate_x18"),v=!!h&&void 0,y=!h||void 0,w=h?void 0:this.parseNumber("1");return{id:this.safeString(e,"product_id"),symbol:d,base:a,quote:i,settle:h?void 0:n,baseId:r,quoteId:s,settleId:h?void 0:o,type:h?"spot":"swap",spot:h,margin:void 0,swap:l,future:!1,option:!1,active:!0,contract:c,linear:y,inverse:v,taker:this.parseNumber(this.convertFromX18(m)),maker:this.parseNumber(this.convertFromX18(g)),contractSize:w,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.convertFromX18(p)),price:this.parseNumber(this.convertFromX18(u))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.parseNumber(this.convertFromX18(f)),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchMarkets(e={}){const t=await this.v1GatewayGetQuery(this.extend({type:"symbols"},e)),s=this.safeDict(t,"data",{}),i=this.safeDict(s,"symbols",{}),r=Object.keys(i),a=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeDict(i,t,{});a.push(this.parseMarket(s))}return a}async fetchTime(e={}){const t=await this.v1GatewayGetTime(e);return this.parseNumber(t)}async fetchStatus(e={}){const t=await this.v1GatewayGetQuery(this.extend({type:"status"},e));let s=this.safeString(t,"data");return s="active"===s?"ok":"error",{status:s,updated:void 0,eta:void 0,url:void 0,info:t}}parseTrade(e,t=void 0){let s,i,r,o;const n=this.convertFromX18(this.safeString(e,"fee"));void 0!==n&&(o={cost:n,currency:void 0});const d=this.safeString2(e,"trade_id","submission_idx"),h=this.safeString(e,"digest"),c=this.safeTimestamp(e,"timestamp");if(void 0===c){const o=this.safeDict(this.safeDict(e,"pre_balance",{}),"base",{});let n;n="perp"in o?this.safeString(this.safeDict(o,"perp",{}),"product_id"):this.safeString(this.safeDict(o,"spot",{}),"product_id"),t=this.safeMarket(n);const d=this.safeDict(e,"order",{});s=this.convertFromX18(this.safeString(d,"priceX18")),i=this.convertFromX18(this.safeString(e,"base_filled")),r=a.Y.stringLt(i,"0")?"sell":"buy"}else{const a=this.safeString(e,"ticker_id").split("_"),o=a[0].split("-")[0]+a[1];t=this.safeMarket(o,t),s=this.safeString(e,"price"),i=this.safeString(e,"base_filled"),r=this.safeStringLower(e,"trade_type")}i=a.Y.stringAbs(i);const l=t.symbol;return this.safeTrade({id:d,timestamp:c,datetime:this.iso8601(c),symbol:l,side:r,price:s,amount:i,cost:void 0,order:h,takerOrMaker:void 0,type:void 0,fee:o,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={ticker_id:r.baseId+"_USDC"};void 0!==s&&(a.limit=s);const o=await this.v2ArchiveGetTrades(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r,a;await this.loadMarkets(),[r,i]=this.handlePublicAddress("fetchMyTrades",i);const o={subaccount:this.convertAddressToSender(r)};void 0!==e&&(a=this.market(e),o.product_ids=[this.parseToNumeric(a.id)]);const n=this.safeInteger(i,"until");void 0!==n&&(i=this.omit(i,"until"),o.max_time=n),void 0!==s&&(o.limit=s);const d={matches:o},h=await this.v1ArchivePost(this.extend(d,i)),c=this.safeList(h,"matches",[]);return this.parseTrades(c,a,t,s,i)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();void 0===t&&(t=100);const i={ticker_id:this.market(e).baseId+"_USDC",depth:t},r=await this.v2GatewayGetOrderbook(this.extend(i,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a,"bids","asks")}async fetchTradingFees(e={}){let t;await this.loadMarkets(),[t,e]=this.handlePublicAddress("fetchTradingFees",e);const s={type:"fee_rates",sender:this.convertAddressToSender(t)},i=await this.v1GatewayGetQuery(this.extend(s,e)),r=this.safeDict(i,"data",{}),a=this.safeList(r,"maker_fee_rates_x18",[]),o=this.safeList(r,"taker_fee_rates_x18",[]),n={};for(let e=0;e<o.length;e++){const t=this.safeMarket(this.numberToString(e));if(void 0===t.id)continue;const s=t.symbol;n[s]={info:i,symbol:s,maker:this.parseNumber(this.convertFromX18(a[e])),taker:this.parseNumber(this.convertFromX18(o[e])),percentage:!0,tierBased:!1}}return n}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,"timestamp"),this.parseNumber(this.convertFromX18(this.safeString(e,"open_x18"))),this.parseNumber(this.convertFromX18(this.safeString(e,"high_x18"))),this.parseNumber(this.convertFromX18(this.safeString(e,"low_x18"))),this.parseNumber(this.convertFromX18(this.safeString(e,"close_x18"))),this.parseNumber(this.convertFromX18(this.safeString(e,"volume")))]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={product_id:this.parseToInt(a.id),granularity:this.safeInteger(this.timeframes,t)},n=this.safeInteger(r,"until");void 0!==n&&(r=this.omit(r,"until"),o.max_time=n),void 0!==i&&(o.limit=Math.min(i,1e3));const d={candlesticks:o},h=await this.v1ArchivePost(this.extend(d,r)),c=this.safeList(h,"candlesticks",[]);return this.parseOHLCVs(c,a,t,s,i)}parseFundingRate(e,t=void 0){let s=this.safeNumber(e,"funding_rate");if(void 0===s){const t=this.safeString(e,"funding_rate_x18");s=this.parseNumber(this.convertFromX18(t))}const i=this.safeTimestamp2(e,"update_time","next_funding_rate_timestamp"),r=this.safeNumber(e,"mark_price"),a=this.safeNumber(e,"index_price");return{info:e,symbol:t.symbol,markPrice:r,indexPrice:a,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:s,fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={funding_rate:{product_id:this.parseToInt(s.id)}},r=await this.v1ArchivePost(this.extend(i,t));return this.parseFundingRate(r,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets();void 0!==e&&(e=this.marketSymbols(e));const s=await this.v2ArchiveGetContracts(this.extend({},t)),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],a=t.split("-"),o=s[t],n=a[0]+"/USDC:USDC",d=this.market(n),h=this.parseFundingRate(o,d);r[h.symbol]=h}return this.filterByArray(r,"symbol",e)}parseOpenInterest(e,t=void 0){const s=this.safeNumber(e,"open_interest_usd");return this.safeOpenInterest({symbol:t.symbol,openInterestAmount:void 0,openInterestValue:s,timestamp:void 0,datetime:void 0,info:e},t)}async fetchOpenInterest(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.contract)throw new r.BadRequest(this.id+" fetchOpenInterest() supports contract markets only");const i=await this.v2ArchiveGetContracts(this.extend({},t)),a=s.base+"_USDC",o=this.safeDict(i,a,{});return this.parseOpenInterest(o,s)}parseTicker(e,t=void 0){const s=this.safeString(e,"base_currency");let i=s+"/"+this.safeString(e,"quote_currency");s.indexOf("PERP")>0&&(i=i.replace("-PERP","")+":USDC"),t=this.market(i);const r=this.safeString(e,"last_price");return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,high:void 0,low:void 0,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:void 0,open:void 0,close:r,last:r,previousClose:void 0,change:void 0,percentage:this.safeString(e,"price_change_percent_24h"),average:void 0,baseVolume:this.safeString(e,"base_volume"),quoteVolume:this.safeString(e,"quote_volume"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e,void 0,!0,!0,!0);const s=await this.v2ArchiveGetTickers(this.extend({},t)),i=Object.values(s);return this.parseTickers(i,e)}async queryContracts(e={}){const t=this.safeDict(this.options,"v1contracts");if(void 0!==t)return t;const s=await this.v1GatewayGetQuery(this.extend({type:"contracts"},e)),i=this.safeDict(s,"data",{});return this.options.v1contracts=i,i}nonce(){return this.milliseconds()-this.options.timeDifference}hashMessage(e){return"0x"+this.hash(e,n.lY,"hex")}signHash(e,t){const s=(0,h.h1)(e.slice(-64),t.slice(-64),d.bI,void 0),i=s.r,r=s.s,a=this.intToBase16(this.sum(27,s.v));return"0x"+i.padStart(64,"0")+r.padStart(64,"0")+a}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}buildSig(e,t,s,i=""){const r={chainId:e,name:"Vertex",verifyingContract:i,version:"0.0.1"},a=this.ethEncodeStructuredData(r,t,s);return this.signMessage(a,this.privateKey)}buildCreateOrderSig(e,t,s){return this.buildSig(t,{Order:[{name:"sender",type:"bytes32"},{name:"priceX18",type:"int128"},{name:"amount",type:"int128"},{name:"expiration",type:"uint64"},{name:"nonce",type:"uint64"}]},e,s)}buildListTriggerTxSig(e,t,s){return this.buildSig(t,{ListTriggerOrders:[{name:"sender",type:"bytes32"},{name:"recvTime",type:"uint64"}]},e,s)}buildCancelAllOrdersSig(e,t,s){return this.buildSig(t,{CancellationProducts:[{name:"sender",type:"bytes32"},{name:"productIds",type:"uint32[]"},{name:"nonce",type:"uint64"}]},e,s)}buildCancelOrdersSig(e,t,s){return this.buildSig(t,{Cancellation:[{name:"sender",type:"bytes32"},{name:"productIds",type:"uint32[]"},{name:"digests",type:"bytes32[]"},{name:"nonce",type:"uint64"}]},e,s)}buildWithdrawSig(e,t,s){return this.buildSig(t,{WithdrawCollateral:[{name:"sender",type:"bytes32"},{name:"productId",type:"uint32"},{name:"amount",type:"uint128"},{name:"nonce",type:"uint64"}]},e,s)}convertAddressToSender(e){return(e+"64656661756c74").padEnd(66,"0")}getNonce(e,t){return void 0===e&&(e=this.nonce()),a.Y.stringAdd(a.Y.stringMul(a.Y.stringAdd(this.numberToString(e),this.numberToString(t)),"1048576"),"1000")}getExpiration(e,t,s,i){let r=a.Y.stringAdd(this.numberToString(e),"86400");return"ioc"===t?r=a.Y.stringOr(r,"4611686018427387904"):"fok"===t?r=a.Y.stringOr(r,"9223372036854775808"):s&&(r=a.Y.stringOr(r,"13835058055282163712")),i&&(r=a.Y.stringOr(r,"2305843009213693952")),r}getAmount(e,t){let s=this.numberToString(e);return"sell"===t?e>0&&(s=a.Y.stringMul(s,"-1")):e<0&&(s=a.Y.stringMul(s,"-1")),s}async createOrder(e,t,s,i,o=void 0,n={}){this.checkRequiredCredentials();const d="market"===t.toLowerCase();if(d&&void 0===o)throw new r.ArgumentsRequired(this.id+" createOrder() requires a price argument for market order");await this.loadMarkets();const h=this.market(e),c=this.parseToInt(h.id),l=await this.queryContracts(),u=this.safeString(l,"chain_id"),p=this.safeList(l,"book_addrs",[]),f=this.safeString(p,c),m=d?"fok":void 0,g=this.safeStringLower(n,"timeInForce",m),v=this.safeBool(n,"postOnly",!1),y=this.safeBool(n,"reduceOnly",!1),w=this.safeString2(n,"triggerPrice","stopPrice"),b=this.safeString(n,"stopLossPrice",w),S=this.safeString(n,"takeProfitPrice"),k=b||S,O=this.nonce();let T=this.getNonce(O,9e4);if(v&&y)throw new r.NotSupported(this.id+" reduceOnly not supported when postOnly is enabled");const P=this.getExpiration(O,g,v,y);k&&(T=a.Y.stringOr(T,"9223372036854775808"));const I=this.getAmount(i,s),x={sender:this.convertAddressToSender(this.walletAddress),priceX18:this.convertToX18(this.priceToPrecision(e,o)),amount:this.convertToX18(this.amountToPrecision(e,I)),expiration:P,nonce:T},A={place_order:{product_id:c,order:{sender:x.sender,priceX18:x.priceX18,amount:x.amount,expiration:this.numberToString(x.expiration),nonce:x.nonce},signature:this.buildCreateOrderSig(x,u,f),id:this.safeInteger(this.options,"brokerId",5930043274845996)}};let M;if(n=this.omit(n,["timeInForce","reduceOnly","postOnly","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]),k){const e={};void 0!==b?e.last_price_below=this.convertToX18(b):void 0!==S&&(e.last_price_above=this.convertToX18(S)),A.place_order.trigger=e,M=await this.v1TriggerPostExecute(this.extend(A,n))}else M=await this.v1GatewayPostExecute(this.extend(A,n));const C=this.safeDict(M,"data",{});return this.safeOrder({id:this.safeString(C,"digest")})}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){this.checkRequiredCredentials();const d="market"===s.toLowerCase();if(d&&void 0===o)throw new r.ArgumentsRequired(this.id+" editOrder() requires a price argument for market order");await this.loadMarkets();const h=this.market(t),c=this.parseToInt(h.id),l=d?"fok":void 0,u=this.safeStringLower(n,"timeInForce",l),p=this.safeBool(n,"postOnly",!1),f=this.safeBool(n,"reduceOnly",!1),m=this.safeString2(n,"triggerPrice","stopPrice"),g=this.safeString(n,"stopLossPrice",m),v=this.safeString(n,"takeProfitPrice"),y=g||v,w=await this.queryContracts(),b=this.safeString(w,"chain_id"),S=this.safeList(w,"book_addrs",[]),k=this.safeString(S,c),O=this.safeString(w,"endpoint_addr"),T=this.nonce(),P=this.getNonce(T,9e4),I=this.convertAddressToSender(this.walletAddress);if(p&&f)throw new r.NotSupported(this.id+" reduceOnly not supported when postOnly is enabled");if(y)throw new r.NotSupported(this.id+" editOrder() not supported for trigger order");const x=this.getExpiration(T,u,p,f),A=this.getAmount(a,i),M={sender:I,priceX18:this.convertToX18(this.priceToPrecision(t,o)),amount:this.convertToX18(this.amountToPrecision(t,A)),expiration:x,nonce:P},C={sender:I,productIds:[c],digests:[e],nonce:P},E={cancel_and_place:{cancel_tx:{sender:C.sender,productIds:C.productIds,digests:C.digests,nonce:this.numberToString(C.nonce)},cancel_signature:this.buildCancelOrdersSig(C,b,O),place_order:{product_id:c,order:{sender:M.sender,priceX18:M.priceX18,amount:M.amount,expiration:this.numberToString(M.expiration),nonce:M.nonce},signature:this.buildCreateOrderSig(M,b,k),id:this.safeInteger(this.options,"brokerId",5930043274845996)}}};n=this.omit(n,["timeInForce","reduceOnly","postOnly","triggerPrice","stopPrice","stopLossPrice","takeProfitPrice"]);const _=await this.v1GatewayPostExecute(this.extend(E,n)),B=this.safeDict(_,"data",{});return this.safeOrder({id:this.safeString(B,"digest")})}parseOrderStatus(e){if(void 0!==e){const t={pending:"open"};if("string"==typeof e)return this.safeString(t,e,e);if(void 0!==this.safeDict(e,"cancelled"))return"canceled";const s=this.safeDict(e,"triggered",{});return"success"===this.safeString(s,"status","failure")?"closed":"canceled"}return e}parseOrder(e,t=void 0){let s=this.safeString(e,"product_id"),i=this.safeTimestamp(e,"placed_at"),r=this.safeString(e,"amount"),a=this.safeString(e,"price_x18");const o=this.safeString(e,"unfilled_amount");let n;const d=this.safeValue(e,"status");if(void 0!==d){const t=this.safeDict(e,"order",{}),o=this.safeDict(t,"order",{});s=this.safeString(t,"product_id"),r=this.safeString(o,"amount"),a=this.safeString(o,"priceX18"),i=this.safeTimestamp(e,"updated_at");const d=this.safeDict(t,"trigger",{}),h=this.safeStringN(d,["price_above","price_below","last_price_above","last_price_below"]);void 0!==h&&(n=this.parseToNumeric(this.convertFromX18(h)))}const h=(t=this.safeMarket(s,t)).symbol;let c,l,u,p;void 0!==a&&(c=this.parseToNumeric(this.convertFromX18(a))),void 0!==r&&(l=this.parseToNumeric(this.convertFromX18(r))),void 0!==o&&(u=this.parseToNumeric(this.convertFromX18(o))),void 0!==l&&void 0!==u&&(p=l<0||u<0?"sell":"buy");const f=this.parseTimeInForce(this.safeString(e,"order_type")),m="PO"===f;return this.safeOrder({info:e,id:this.safeString(e,"digest"),clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,lastUpdateTimestamp:void 0,symbol:h,type:void 0,timeInForce:f,postOnly:m,reduceOnly:void 0,side:p,price:c,triggerPrice:n,amount:l,cost:void 0,average:void 0,filled:void 0,remaining:u,status:this.parseOrderStatus(d),fee:void 0,trades:void 0},t)}parseTimeInForce(e){return this.safeStringUpper({POST_ONLY:"PO"},e,e)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(t),r={type:"order",product_id:this.parseToInt(i.id),digest:e},a=await this.v1GatewayGetQuery(this.extend(r,s)),o=this.safeDict(a,"data");return this.parseOrder(o,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;this.checkRequiredCredentials(),await this.loadMarkets(),[r,i]=this.handlePublicAddress("fetchOpenOrders",i);const a={};let o;const n=this.safeBool2(i,"stop","trigger");let d;if(i=this.omit(i,["stop","trigger"]),void 0!==e&&(o=this.market(e),a.product_id=this.parseToNumeric(o.id)),n){const e=await this.queryContracts(),t=this.safeString(e,"chain_id"),o=this.safeString(e,"endpoint_addr"),n={sender:this.convertAddressToSender(r),recvTime:this.nonce()+9e4};a.signature=this.buildListTriggerTxSig(n,t,o),a.tx={sender:n.sender,recvTime:this.numberToString(n.recvTime)},a.type="list_trigger_orders",a.pending=!0;const h=this.safeInteger(i,"until");i=this.omit(i,"until"),void 0!==h&&(a.max_update_time=h),void 0!==s&&(a.limit=s),d=await this.v1TriggerPostQuery(this.extend(a,i))}else this.checkRequiredArgument("fetchOpenOrders",e,"symbol"),a.type="subaccount_orders",a.sender=this.convertAddressToSender(r),d=await this.v1GatewayPostQuery(this.extend(a,i));const h=this.safeDict(d,"data",{}),c=this.safeList(h,"orders");return this.parseOrders(c,o,t,s)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){this.checkRequiredCredentials();const a=this.safeBool2(i,"stop","trigger");if(i=this.omit(i,["stop","trigger"]),!a)throw new r.NotSupported(this.id+" fetchOrders only support trigger orders");let o,n;[o,i]=this.handlePublicAddress("fetchOrders",i),await this.loadMarkets();const d={type:"list_trigger_orders",pending:!1};void 0!==e&&(n=this.market(e),d.product_id=this.parseToNumeric(n.id));const h=await this.queryContracts(),c=this.safeString(h,"chain_id"),l=this.safeString(h,"endpoint_addr"),u={sender:this.convertAddressToSender(o),recvTime:this.nonce()+9e4};d.signature=this.buildListTriggerTxSig(u,c,l),d.tx={sender:u.sender,recvTime:this.numberToString(u.recvTime)};const p=this.safeInteger(i,"until");i=this.omit(i,"until"),void 0!==p&&(d.max_update_time=p),void 0!==s&&(d.limit=s);const f=await this.v1TriggerPostQuery(this.extend(d,i)),m=this.safeDict(f,"data",{}),g=this.safeList(m,"orders");return this.parseOrders(g,n,t,s)}async cancelAllOrders(e=void 0,t={}){if(this.checkRequiredCredentials(),await this.loadMarkets(),void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");const s=this.market(e).id,i=await this.queryContracts(),a=this.safeString(i,"chain_id"),o=this.safeString(i,"endpoint_addr"),n=this.nonce(),d=this.getNonce(n,9e4),h={sender:this.convertAddressToSender(this.walletAddress),productIds:[this.parseToNumeric(s)],nonce:d},c={cancel_product_orders:{tx:{sender:h.sender,productIds:h.productIds,nonce:this.numberToString(h.nonce)},signature:this.buildCancelAllOrdersSig(h,a,o)}},l=this.safeBool2(t,"stop","trigger");let u;return t=this.omit(t,["stop","trigger"]),u=l?await this.v1TriggerPostExecute(this.extend(c,t)):await this.v1GatewayPostExecute(this.extend(c,t)),u}async cancelOrder(e,t=void 0,s={}){return await this.cancelOrders([e],t,s)}async cancelOrders(e,t=void 0,s={}){if(this.checkRequiredCredentials(),void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");await this.loadMarkets();const i=this.market(t).id,a=await this.queryContracts(),o=this.safeString(a,"chain_id"),n=this.safeString(a,"endpoint_addr"),d=this.nonce(),h=this.getNonce(d,9e4),c={sender:this.convertAddressToSender(this.walletAddress),productIds:[],digests:e,nonce:h},l=this.parseToNumeric(i);for(let t=0;t<e.length;t++)c.productIds.push(l);const u={cancel_orders:{tx:{sender:c.sender,productIds:c.productIds,digests:c.digests,nonce:this.numberToString(c.nonce)},signature:this.buildCancelOrdersSig(c,o,n)}},p=this.safeBool2(s,"stop","trigger");let f;return s=this.omit(s,["stop","trigger"]),f=p?await this.v1TriggerPostExecute(this.extend(u,s)):await this.v1GatewayPostExecute(this.extend(u,s)),f}async fetchBalance(e={}){let t;[t,e]=this.handlePublicAddress("fetchBalance",e);const s={type:"subaccount_info",subaccount:this.convertAddressToSender(t)},i=await this.v1GatewayGetQuery(this.extend(s,e)),r=this.safeDict(i,"data",{}),a=this.safeList(r,"spot_balances",[]),o={info:i};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"product_id"),i=this.safeMarket(s),r="0"===s;if(void 0===i.id&&!r)continue;const n=r?"USDC":this.safeString(i,"baseId"),d=this.safeCurrencyCode(n),h=this.account(),c=this.safeDict(t,"balance",{}),l=this.convertFromX18(this.safeString(c,"amount"));h.total=l,o[d]=h}return this.safeBalance(o)}parsePosition(e,t=void 0){const s=this.safeString(e,"product_id");t=this.safeMarket(s);const i=this.safeDict(e,"balance",{}),r=this.convertFromX18(this.safeString(i,"amount"));let o="buy";return a.Y.stringLt(r,"1")&&(o="sell"),this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:void 0,datetime:void 0,lastUpdateTimestamp:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:void 0,notional:void 0,leverage:void 0,unrealizedPnl:void 0,contracts:void 0,contractSize:this.parseToNumeric(r),marginRatio:void 0,liquidationPrice:void 0,markPrice:void 0,lastPrice:void 0,collateral:void 0,marginMode:"cross",marginType:void 0,side:o,percentage:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchPositions(e=void 0,t={}){let s;[s,t]=this.handlePublicAddress("fetchPositions",t);const i={type:"subaccount_info",subaccount:this.convertAddressToSender(s)},r=await this.v1GatewayGetQuery(this.extend(i,t)),a=this.safeDict(r,"data",{}),o=this.safeList(a,"perp_balances",[]);e=this.marketSymbols(e);const n=[];for(let e=0;e<o.length;e++){const s=this.extend(this.parsePosition(o[e],void 0),t);0!==s.contractSize&&n.push(s)}return this.filterByArrayPositions(n,"symbol",e,!1)}async queryNonces(){const e={type:"nonces",address:this.walletAddress},t=await this.v1GatewayGetQuery(e);return this.safeDict(t,"data",{})}async withdraw(e,t,s,i=void 0,r={}){this.checkRequiredCredentials(),await this.loadMarkets();const a=this.currency(e),o=await this.queryContracts(),n=this.safeString(o,"chain_id"),d=this.safeString(o,"endpoint_addr"),h=await this.queryNonces(),c=this.safeNumber(h,"tx_nonce"),l={sender:this.convertAddressToSender(this.walletAddress),productId:this.parseToNumeric(a.id),amount:t.toString(),nonce:c},u={withdraw_collateral:{tx:{sender:l.sender,productId:l.productId,amount:l.amount,nonce:this.numberToString(l.nonce)},signature:this.buildWithdrawSig(l,n,d)}};return await this.v1GatewayPostExecute(this.extend(u,r))}handlePublicAddress(e,t){let s;[s,t]=this.handleOptionAndParams(t,e,"user");let i=s;if([i,t]=this.handleOptionAndParams(t,e,"address",s),void 0!==i&&""!==i)return[i,t];if(void 0!==this.walletAddress&&""!==this.walletAddress)return[this.walletAddress,t];throw new r.ArgumentsRequired(this.id+" "+e+"() requires a user parameter inside 'params' or the wallet address set")}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;if("failure"===this.safeString(n,"status","")){const e=this.safeString(n,"error"),t=this.id+" "+o,s=this.safeString(n,"error_code");throw this.throwExactlyMatchedException(this.exceptions.exact,s,t),this.throwBroadlyMatchedException(this.exceptions.broad,e,t),new r.ExchangeError(t)}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.safeString(t,0),n=this.safeString(t,1);let d=this.implodeHostname(this.urls.api[o][n]);return"v1"===o&&"archive"===n||(d=d+"/"+e),"POST"===s?(r={"Content-Type":"application/json"},a=this.json(i)):Object.keys(i).length&&(d+="?"+this.urlencode(i)),{url:d,method:s,body:a,headers:r}}}},7073:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7698),r=s(2079),a=s(5147),o=s(6414),n=s(1579);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"wavesexchange",name:"Waves.Exchange",countries:["CH"],certified:!1,pro:!1,dex:!0,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createMarketOrder:!0,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTransfer:!1,fetchTransfers:!1,reduceMargin:!1,sandbox:!0,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,signIn:!0,transfer:!1,withdraw:!0,ws:!1},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","3h":"3h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/84547058-5fb27d80-ad0b-11ea-8711-78ac8b3c7f31.jpg",test:{matcher:"https://matcher-testnet.wx.network",node:"https://nodes-testnet.wavesnodes.com",public:"https://api-testnet.wavesplatform.com/v0",private:"https://api-testnet.wx.network/v1",forward:"https://testnet.wx.network/api/v1/forward/matcher",market:"https://testnet.wx.network/api/v1/forward/marketdata/api/v1"},api:{matcher:"https://matcher.wx.network",node:"https://nodes.wx.network",public:"https://api.wavesplatform.com/v0",private:"https://api.wx.network/v1",forward:"https://wx.network/api/v1/forward/matcher",market:"https://wx.network/api/v1/forward/marketdata/api/v1"},doc:"https://docs.wx.network",www:"https://wx.network"},api:{matcher:{get:["matcher","matcher/settings","matcher/settings/rates","matcher/balance/reserved/{publicKey}","matcher/debug/allSnashotOffsets","matcher/debug/currentOffset","matcher/debug/lastOffset","matcher/debug/oldestSnapshotOffset","matcher/debug/config","matcher/debug/address/{address}","matcher/debug/status","matcher/debug/address/{address}/check","matcher/orderbook","matcher/orderbook/{baseId}/{quoteId}","matcher/orderbook/{baseId}/{quoteId}/publicKey/{publicKey}","matcher/orderbook/{baseId}/{quoteId}/{orderId}","matcher/orderbook/{baseId}/{quoteId}/info","matcher/orderbook/{baseId}/{quoteId}/status","matcher/orderbook/{baseId}/{quoteId}/tradableBalance/{address}","matcher/orderbook/{publicKey}","matcher/orderbook/{publicKey}/{orderId}","matcher/orders/{address}","matcher/orders/{address}/{orderId}","matcher/transactions/{orderId}","api/v1/orderbook/{baseId}/{quoteId}"],post:["matcher/orderbook","matcher/orderbook/market","matcher/orderbook/cancel","matcher/orderbook/{baseId}/{quoteId}/cancel","matcher/orderbook/{baseId}/{quoteId}/calculateFee","matcher/orderbook/{baseId}/{quoteId}/delete","matcher/orderbook/{baseId}/{quoteId}/cancelAll","matcher/debug/saveSnapshots","matcher/orders/{address}/cancel","matcher/orders/cancel/{orderId}","matcher/orders/serialize"],delete:["matcher/orderbook/{baseId}/{quoteId}","matcher/settings/rates/{assetId}"],put:["matcher/settings/rates/{assetId}"]},node:{get:["addresses","addresses/balance/{address}","addresses/balance/{address}/{confirmations}","addresses/balance/details/{address}","addresses/data/{address}","addresses/data/{address}/{key}","addresses/effectiveBalance/{address}","addresses/effectiveBalance/{address}/{confirmations}","addresses/publicKey/{publicKey}","addresses/scriptInfo/{address}","addresses/scriptInfo/{address}/meta","addresses/seed/{address}","addresses/seq/{from}/{to}","addresses/validate/{address}","alias/by-address/{address}","alias/by-alias/{alias}","assets/{assetId}/distribution/{height}/{limit}","assets/balance/{address}","assets/balance/{address}/{assetId}","assets/details/{assetId}","assets/nft/{address}/limit/{limit}","blockchain/rewards","blockchain/rewards/height","blocks/address/{address}/{from}/{to}/","blocks/at/{height}","blocks/delay/{signature}/{blockNum}","blocks/first","blocks/headers/last","blocks/headers/seq/{from}/{to}","blocks/height","blocks/height/{signature}","blocks/last","blocks/seq/{from}/{to}","blocks/signature/{signature}","consensus/algo","consensus/basetarget","consensus/basetarget/{blockId}","consensus/{generatingbalance}/address","consensus/generationsignature","consensus/generationsignature/{blockId}","debug/balances/history/{address}","debug/blocks/{howMany}","debug/configInfo","debug/historyInfo","debug/info","debug/minerInfo","debug/portfolios/{address}","debug/state","debug/stateChanges/address/{address}","debug/stateChanges/info/{id}","debug/stateWaves/{height}","leasing/active/{address}","node/state","node/version","peers/all","peers/blacklisted","peers/connected","peers/suspended","transactions/address/{address}/limit/{limit}","transactions/info/{id}","transactions/status","transactions/unconfirmed","transactions/unconfirmed/info/{id}","transactions/unconfirmed/size","utils/seed","utils/seed/{length}","utils/time","wallet/seed"],post:["addresses","addresses/data/{address}","addresses/sign/{address}","addresses/signText/{address}","addresses/verify/{address}","addresses/verifyText/{address}","debug/blacklist","debug/print","debug/rollback","debug/validate","node/stop","peers/clearblacklist","peers/connect","transactions/broadcast","transactions/calculateFee","tranasctions/sign","transactions/sign/{signerAddress}","tranasctions/status","utils/hash/fast","utils/hash/secure","utils/script/compileCode","utils/script/compileWithImports","utils/script/decompile","utils/script/estimate","utils/sign/{privateKey}","utils/transactionsSerialize"],delete:["addresses/{address}","debug/rollback-to/{signature}"]},public:{get:["assets","pairs","candles/{baseId}/{quoteId}","transactions/exchange"]},private:{get:["deposit/addresses/{currency}","deposit/addresses/{currency}/{platform}","platforms","deposit/currencies","withdraw/currencies","withdraw/addresses/{currency}/{address}"],post:["oauth2/token"]},forward:{get:["matcher/orders/{address}","matcher/orders/{address}/{orderId}"],post:["matcher/orders/{wavesAddress}/cancel"]},market:{get:["tickers"]}},currencies:{WX:this.safeCurrencyStructure({id:"EMAMLxDnv3xiz8RXg8Btj33jcEw3wLczL3JKYYmuubpc",numericId:void 0,code:"WX",precision:this.parseNumber("1e-8")})},precisionMode:n.kb,options:{allowedCandles:1440,accessToken:void 0,createMarketBuyOrderRequiresPrice:!0,matcherPublicKey:void 0,quotes:void 0,createOrderDefaultExpiry:24192e5,wavesAddress:void 0,withdrawFeeUSDN:7420,withdrawFeeWAVES:1e5,wavesPrecision:1e-8,messagePrefix:"W",networks:{ERC20:"ETH",BEP20:"BSC"}},commonCurrencies:{EGG:"Waves Ducks"},requiresEddsa:!0,exceptions:{3147270:r.InsufficientFunds,112:r.InsufficientFunds,4:r.ExchangeError,13:r.ExchangeNotAvailable,14:r.ExchangeNotAvailable,3145733:r.AccountSuspended,3148040:r.DuplicateOrderId,3148801:r.AuthenticationError,9440512:r.AuthenticationError,9440771:r.BadSymbol,9441026:r.InvalidOrder,9441282:r.InvalidOrder,9441286:r.InvalidOrder,9441295:r.InvalidOrder,9441540:r.InvalidOrder,9441542:r.InvalidOrder,106954752:r.AuthenticationError,106954769:r.AuthenticationError,106957828:r.AuthenticationError,106960131:r.AuthenticationError,106981137:r.AuthenticationError,9437184:r.BadRequest,9437193:r.OrderNotFound,1048577:r.BadRequest,1051904:r.AuthenticationError}})}setSandboxMode(e){this.options.messagePrefix=e?"T":"W",this.options.sandboxMode=e,super.setSandboxMode(e)}async getFeesForAsset(e,t,s,i,r={}){await this.loadMarkets();const a=this.market(e);s=this.toRealSymbolAmount(e,s),i=this.toRealSymbolPrice(e,i);const o=this.extend({baseId:a.baseId,quoteId:a.quoteId,orderType:t,amount:s,price:i},r);return await this.matcherPostMatcherOrderbookBaseIdQuoteIdCalculateFee(o)}async customCalculateFee(e,t,s,i,r,o="taker",n={}){const d=await this.getFeesForAsset(e,s,i,r);let h;h=this.safeBool(n,"isDiscountFee",!1)?this.safeValue(d,"discount"):this.safeValue(d,"base");const c=this.safeString(h,"matcherFee"),l=this.safeString(h,"feeAssetId"),u=this.safeCurrencyCode(l),p=this.fromRealCurrencyAmount(u,c),f=this.numberToString(i),m=this.numberToString(r),g=this.feeToPrecision(e,this.parseNumber(p)),v=a.Y.stringDiv(p,a.Y.stringMul(f,m));return{type:o,currency:u,rate:this.parseNumber(v),cost:this.parseNumber(g)}}async getQuotes(){let e=this.safeValue(this.options,"quotes");if(e)return e;{const t=await this.matcherGetMatcherSettings();e={};const s=this.safeValue(t,"priceAssets");for(let t=0;t<s.length;t++)e[s[t]]=!0;return this.options.quotes=e,e}}async fetchMarkets(e={}){const t=await this.marketGetTickers(),s=[];for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"amountAssetID"),a=this.safeString(i,"priceAssetID"),o=r+"/"+a,n=this.safeString(i,"symbol");let[d,h]=n.split("/");d=this.safeCurrencyCode(d),h=this.safeCurrencyCode(h);const c=d+"/"+h;s.push({id:o,symbol:c,base:d,quote:h,settle:void 0,baseId:r,quoteId:a,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(i,"amountAssetDecimals"))),price:this.parseNumber(this.parsePrecision(this.safeString(i,"priceAssetDecimals")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:void 0,max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:i})}return s}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r=this.extend({baseId:i.baseId,quoteId:i.quoteId},s),a=await this.matcherGetMatcherOrderbookBaseIdQuoteId(r),o=this.safeInteger(a,"timestamp");return{symbol:e,bids:this.parseOrderBookSide(this.safeValue(a,"bids"),i,t),asks:this.parseOrderBookSide(this.safeValue(a,"asks"),i,t),timestamp:o,datetime:this.iso8601(o),nonce:void 0}}parseOrderBookSide(e,t=void 0,s=void 0){const i=t.precision,r=this.safeString(this.options,"wavesPrecision","1e-8"),o=this.safeString(i,"amount"),n=this.safeString(i,"price"),d=a.Y.stringDiv(o,n),h=a.Y.stringDiv(r,d),c=[];for(let t=0;t<e.length;t++){const i=e[t],r=this.safeString(i,"price","0"),n=this.safeString(i,"amount","0");let d,l;if(void 0!==h&&void 0!==r&&(d=a.Y.stringMul(r,h)),void 0!==o&&void 0!==n&&(l=a.Y.stringMul(n,o)),void 0!==s&&t>s)break;c.push([this.parseNumber(d),this.parseNumber(l)])}return c}checkRequiredKeys(){if(void 0===this.apiKey)throw new r.AuthenticationError(this.id+" requires apiKey credential");if(void 0===this.secret)throw new r.AuthenticationError(this.id+" requires secret credential");let e,t;try{e=this.base58ToBinary(this.apiKey)}catch(e){throw new r.AuthenticationError(this.id+" apiKey must be a base58 encoded public key")}try{t=this.base58ToBinary(this.secret)}catch(e){throw new r.AuthenticationError(this.id+" secret must be a base58 encoded private key")}const s=this.binaryToBase16(e),i=this.binaryToBase16(t);if(64!==s.length)throw new r.AuthenticationError(this.id+" apiKey must be a base58 encoded public key");if(64!==i.length)throw new r.AuthenticationError(this.id+" secret must be a base58 encoded private key")}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),n="matcher/orders/{wavesAddress}/cancel"===e;e=this.implodeParams(e,i);let d=this.urls.api[t]+"/"+e,h=this.urlencodeWithArrayRepeat(o);if("private"===t||"forward"===t){r={Accept:"application/json"};const e=this.safeString(this.options,"accessToken");e&&(r.Authorization="Bearer "+e),r["content-type"]="POST"===s?"application/json":"application/x-www-form-urlencoded",n&&(a=this.json([o.orderId]),h=""),h.length>0&&(d+="?"+h)}else"matcher"===t?"POST"===s?(r={Accept:"application/json","Content-Type":"application/json"},a=this.json(o)):r=o:"POST"===s?(r={"content-type":"application/json"},a=this.json(o)):(r={"content-type":"application/x-www-form-urlencoded"},h.length>0&&(d+="?"+h));return{url:d,method:s,body:a,headers:r}}async signIn(e={}){if(!this.safeString(this.options,"accessToken")){const e="ffffff01",t=604800;let s=this.sum(this.seconds(),t);s=s.toString();const i="wx.network",r=this.safeString(this.options,"messagePrefix","W")+":"+i+":"+s,a=e+this.binaryToBase16(this.encode(r)),n=this.binaryToBase16(this.base58ToBinary(this.secret)),d=this.axolotl(a,n,o.ev),h={grant_type:"password",scope:"general",username:this.apiKey,password:s+":"+d,client_id:i},c=await this.privatePostOauth2Token(h);return this.options.accessToken=this.safeString(c,"access_token"),this.options.accessToken}}parseTicker(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString(e,"symbol"),r=(t=this.safeMarket(i,t,"/")).symbol,a=this.safeString2(e,"24h_close","lastPrice"),o=this.safeString2(e,"24h_low","low"),n=this.safeString2(e,"24h_high","high"),d=this.safeString2(e,"24h_vwap","weightedAveragePrice"),h=this.safeString2(e,"24h_volume","volume"),c=this.safeString2(e,"24h_priceVolume","quoteVolume"),l=this.safeString2(e,"24h_open","firstPrice");return this.safeTicker({symbol:r,timestamp:s,datetime:this.iso8601(s),high:n,low:o,bid:void 0,bidVolume:void 0,ask:void 0,askVolume:void 0,vwap:d,open:l,close:a,last:a,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:h,quoteVolume:c,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pairs:s.id},r=await this.publicGetPairs(this.extend(i,t)),a=this.safeValue(r,"data",[]),o=this.safeValue(a,0,{}),n=this.safeDict(o,"data",{});return this.parseTicker(n,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.marketGetTickers(t);return this.parseTickers(s,e)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={baseId:a.baseId,quoteId:a.quoteId,interval:this.safeString(this.timeframes,t,t)},n=this.safeInteger(this.options,"allowedCandles",1440);void 0===i&&(i=n),i=Math.min(n,i);const d=1e3*this.parseTimeframe(t);if(void 0===s){const e=this.parseToInt(this.milliseconds()/d)*d-(i-1)*d;o.timeStart=e.toString()}else{o.timeStart=s.toString();const e=this.sum(s,d*i);o.timeEnd=e.toString()}const h=await this.publicGetCandlesBaseIdQuoteId(this.extend(o,r)),c=this.safeValue(h,"data",[]);let l,u=this.parseOHLCVs(c,a,t,s,i);u=this.filterFutureCandles(u);const p=u.length;for(let e=0;e<u.length;e++){const t=p-e-1,s=u[t];void 0===s[1]&&(s[1]=l,s[2]=l,s[3]=l,s[4]=l,u[t]=s),l=s[4]}return u}filterFutureCandles(e){const t=[],s=this.milliseconds();for(let i=0;i<e.length&&!(e[i][0]>s);i++)t.push(e[i]);return t}parseOHLCV(e,t=void 0){const s=this.safeValue(e,"data",{});return[this.parse8601(this.safeString(s,"time")),this.safeNumber(s,"open"),this.safeNumber(s,"high"),this.safeNumber(s,"low"),this.safeNumber(s,"close"),this.safeNumber(s,"volume",0)]}async fetchDepositAddress(e,t={}){await this.signIn();const s=this.safeValue(this.options,"networks",{}),i=this.safeStringUpper(t,"network"),a=this.safeString(s,i,i);t=this.omit(t,["network"]);const o=await this.privateGetPlatforms(),n={},d={},h=this.safeValue(o,"items",[]);for(let e=0;e<h.length;e++){const t=h[e],s=this.safeString(t,"id"),i=this.safeValue(t,"currencies",[]);for(let e=0;e<i.length;e++){const t=this.safeString(i,e);n[t]=!0,t in d||(d[t]={}),d[t][s]=!0}}if(!(e in n)){const t=Object.keys(n);throw new r.ExchangeError(this.id+" fetchDepositAddress() "+e+" not supported. Currency code must be one of "+t.join(", "))}let c;if(void 0===a){const s={currency:e};c=await this.privateGetDepositAddressesCurrency(this.extend(s,t))}else{const s=d[e];if(!(a in s)){const t=Object.keys(s);throw new r.ExchangeError(this.id+" "+a+" network "+e+" deposit address not supported. Network must be one of "+t.join(", "))}if("WAVES"===a){const t={publicKey:this.apiKey},s=await this.nodeGetAddressesPublicKeyPublicKey(this.extend(t,t));return{address:this.safeString(c,"address"),code:e,currency:e,network:a,tag:void 0,info:s}}{const s={currency:e,platform:a};c=await this.privateGetDepositAddressesCurrencyPlatform(this.extend(s,t))}}const l=this.safeValue(c,"currency"),u=this.safeString(l,"platform_id"),p=this.safeValue(this.options,"networkByIds",{}),f=this.safeString(p,u,u),m=this.safeValue(c,"deposit_addresses");return{address:this.safeString(m,0),code:e,currency:e,tag:void 0,network:f,info:c}}async getMatcherPublicKey(){const e=this.safeString(this.options,"matcherPublicKey");if(e)return e;{const e=await this.matcherGetMatcher();return this.options.matcherPublicKey=e.slice(1,e.length-1),this.options.matcherPublicKey}}getAssetBytes(e){return"WAVES"===e?this.numberToBE(0,1):this.binaryConcat(this.numberToBE(1,1),this.base58ToBinary(e))}getAssetId(e){return"WAVES"===e?"":e}toRealCurrencyAmount(e,t,s=void 0){const i=this.currency(e),r=a.Y.stringDiv(this.numberToString(t),this.safeString(i,"precision"));return parseInt(r)}fromRealCurrencyAmount(e,t){if(!(e in this.currencies))return t;const s=this.currency(e),i=this.safeString(s,"precision");return a.Y.stringMul(t,i)}toRealSymbolPrice(e,t){const s=this.market(e),i=a.Y.stringDiv(this.numberToString(t),this.safeString(s.precision,"price"));return parseInt(i)}fromRealSymbolPrice(e,t){const s=this.markets[e];return a.Y.stringMul(t,this.safeString(s.precision,"price"))}toRealSymbolAmount(e,t){const s=this.market(e),i=a.Y.stringDiv(this.numberToString(t),this.safeString(s.precision,"amount"));return parseInt(i)}fromRealSymbolAmount(e,t){const s=this.markets[e];return a.Y.stringMul(t,s.precision.amount)}safeGetDynamic(e){const t=this.safeValue(e,"orderFee");return"dynamic"in t?this.safeValue(t,"dynamic"):this.safeValue(t.composite.default,"dynamic")}safeGetRates(e){const t=this.safeValue(e,"rates");return void 0===t?{WAVES:1}:t}async createOrder(e,t,s,i,a=void 0,n={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const d=this.market(e),h=await this.getMatcherPublicKey(),c=this.getAssetId(d.baseId),l=this.getAssetId(d.quoteId),u="market"===t,p=this.safeFloat2(n,"triggerPrice","stopPrice"),f=void 0!==p;if(u&&void 0===a)throw new r.InvalidOrder(this.id+" createOrder() requires a price argument for "+t+" orders to determine the max price for buy and the min price for sell");const m=this.milliseconds();let g;[g,n]=this.handleOptionAndParams(n,"createOrder","defaultExpiry",this.safeInteger(this.options,"createOrderDefaultExpiry",24192e5));const v=this.sum(m,g),y=await this.getFeesForAsset(e,s,i,a),w=this.safeValue2(y,"base","discount"),b=this.safeString(w,"feeAssetId"),S=this.safeCurrencyCode(b),k=this.safeString(w,"matcherFee"),O=this.safeValue(y,"discount"),T=this.safeString(O,"feeAssetId"),P=this.safeCurrencyCode(T),I=this.safeString(O,"matcherFee");let x,A;if("feeAsset"in n||"feeAsset"in this.options){const e=this.safeString(n,"feeAsset",this.safeString(this.options,"feeAsset")),t=this.currency(e);x=this.safeString(t,"id")}const M=await this.fetchBalance();if(void 0!==x){if(b!==x&&T!==x)throw new r.InvalidOrder(this.id+" asset fee must be "+S+" or "+P);const e=this.safeCurrencyCode(x),t=x===b?k:I,s=parseFloat(this.fromRealCurrencyAmount(e,t));if(!(e in M&&M[e].free>=s))throw new r.InsufficientFunds(this.id+" not enough funds of the selected asset fee");A=parseInt(t)}const C=this.fromRealCurrencyAmount(S,k),E=this.fromRealCurrencyAmount(P,I);if(void 0===x&&(S in M&&M[S].free>=parseFloat(C)?(x=b,A=parseInt(k)):P in M&&M[P].free>=parseFloat(E)&&(x=T,A=parseInt(I))),void 0===x)throw new r.InsufficientFunds(this.id+" not enough funds on none of the eligible asset fees: "+S+" "+C+" or "+P+" "+E);i=this.toRealSymbolAmount(e,i),a=this.toRealSymbolPrice(e,a);const _={amountAsset:c,priceAsset:l},B=this.safeBool(this.options,"sandboxMode",!1)?84:87,N={senderPublicKey:this.apiKey,matcherPublicKey:h,assetPair:_,orderType:s,price:a,amount:i,timestamp:m,expiration:v,matcherFee:parseInt(A),priceMode:"assetDecimals",version:4,chainId:B};if(f){const t={v:1,c:{t:"sp",v:{p:this.toRealSymbolPrice(e,p)}}};N.attachment=this.binaryToBase58(this.encode(JSON.stringify(t)))}"WAVES"!==x&&(N.matcherFeeAssetId=x);let R=await this.matcherPostMatcherOrdersSerialize(N);'"'===R[0]&&'"'===R[R.length-1]&&(R=R.slice(1,R.length-1));const L=this.axolotl(this.binaryToBase16(this.base58ToBinary(R)),this.binaryToBase16(this.base58ToBinary(this.secret)),o.ev);if(N.signature=L,u){const e=await this.matcherPostMatcherOrderbookMarket(this.extend(N,n)),t=this.safeDict(e,"message");return this.parseOrder(t,d)}{const e=await this.matcherPostMatcherOrderbook(this.extend(N,n)),t=this.safeDict(e,"message");return this.parseOrder(t,d)}}async cancelOrder(e,t=void 0,s={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.signIn();const i=await this.getWavesAddress(),r=await this.forwardPostMatcherOrdersWavesAddressCancel({wavesAddress:i,orderId:e}),a=this.safeValue(r,"message"),o=this.safeValue(a,0),n=this.safeValue(o,0),d=this.safeString(n,"orderId");return this.safeOrder({info:r,id:d,clientOrderId:void 0,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,symbol:t,type:void 0,side:void 0,price:void 0,amount:void 0,cost:void 0,average:void 0,filled:void 0,remaining:void 0,status:void 0,fee:void 0,trades:void 0})}async fetchOrder(e,t=void 0,s={}){let i;this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r=this.milliseconds(),a=[this.base58ToBinary(this.apiKey),this.numberToBE(r,8)],n=this.binaryConcatArray(a),d=this.binaryToBase16(this.base58ToBinary(this.secret)),h=this.axolotl(this.binaryToBase16(n),d,o.ev),c={Timestamp:r.toString(),Signature:h,publicKey:this.apiKey,orderId:e},l=await this.matcherGetMatcherOrderbookPublicKeyOrderId(this.extend(c,s));return this.parseOrder(l,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(this.checkRequiredDependencies(),this.checkRequiredKeys(),void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),n=this.milliseconds(),d=[this.base58ToBinary(this.apiKey),this.numberToBE(n,8)],h=this.binaryConcatArray(d),c=this.binaryToBase16(this.base58ToBinary(this.secret)),l=this.axolotl(this.binaryToBase16(h),c,o.ev),u={Accept:"application/json",Timestamp:n.toString(),Signature:l,publicKey:this.apiKey,baseId:a.baseId,quoteId:a.quoteId},p=await this.matcherGetMatcherOrderbookBaseIdQuoteIdPublicKeyPublicKey(this.extend(u,i));return this.parseOrders(p,a,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),await this.signIn(),void 0!==e&&(r=this.market(e));const a={address:await this.getWavesAddress(),activeOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets(),await this.signIn(),void 0!==e&&(r=this.market(e));const a={address:await this.getWavesAddress(),closedOnly:!0},o=await this.forwardGetMatcherOrdersAddress(a);return this.parseOrders(o,r,t,s)}parseOrderStatus(e){return this.safeString({Cancelled:"canceled",Accepted:"open",Filled:"closed",PartiallyFilled:"open"},e,e)}getSymbolFromAssetPair(e){const t=this.safeString(e,"amountAsset","WAVES"),s=this.safeString(e,"priceAsset","WAVES");return this.safeCurrencyCode(t)+"/"+this.safeCurrencyCode(s)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"timestamp"),i=this.safeString2(e,"type","orderType");let r="limit";"type"in e&&(r=this.safeString(e,"orderType",r));const a=this.safeString(e,"id"),o=this.safeString(e,"filled"),n=this.safeString(e,"price"),d=this.safeString(e,"amount"),h=this.safeValue(e,"assetPair");let c;void 0!==h?c=this.getSymbolFromAssetPair(h):void 0!==t&&(c=t.symbol);const l=this.safeCurrencyCode(this.safeString(h,"amountAsset","WAVES")),u=this.fromRealSymbolPrice(c,n),p=this.fromRealCurrencyAmount(l,d),f=this.fromRealCurrencyAmount(l,o),m=this.fromRealSymbolPrice(c,this.safeString(e,"avgWeighedPrice")),g=this.parseOrderStatus(this.safeString(e,"status"));let v,y;if("type"in e){const t=this.safeCurrencyCode(this.safeString(e,"feeAsset"));v={currency:t,fee:this.parseNumber(this.fromRealCurrencyAmount(t,this.safeString(e,"filledFee")))}}else{const t=this.safeCurrencyCode(this.safeString(e,"matcherFeeAssetId","WAVES"));v={currency:t,fee:this.parseNumber(this.fromRealCurrencyAmount(t,this.safeString(e,"matcherFee")))}}const w=this.safeString(e,"attachment");if(void 0!==w){const e=this.parseJson(this.decode(this.base58ToBinary(w)));if(void 0!==e){const t=this.safeValue(e,"c");if(void 0!==t){const e=this.safeValue(t,"v");void 0!==e&&(y=this.safeString(e,"p"))}}}return this.safeOrder({info:e,id:a,clientOrderId:void 0,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,symbol:c,type:r,timeInForce:void 0,postOnly:void 0,side:i,price:u,stopPrice:y,triggerPrice:y,amount:p,cost:void 0,average:m,filled:f,remaining:void 0,status:g,fee:v,trades:void 0},t)}async getWavesAddress(){const e=this.safeString(this.options,"wavesAddress");if(void 0===e){const e={publicKey:this.apiKey},t=await this.nodeGetAddressesPublicKeyPublicKey(e);return this.options.wavesAddress=this.safeString(t,"address"),this.options.wavesAddress}return e}async fetchBalance(e={}){this.checkRequiredDependencies(),this.checkRequiredKeys(),await this.loadMarkets();const t=await this.getWavesAddress(),s={address:t},i=await this.nodeGetAssetsBalanceAddress(s),r=this.safeValue(i,"balances",[]);let n,d={};const h=[],c=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeInteger(t,"timestamp");n=void 0===n?s:Math.max(n,s);const i=this.safeValue(t,"issueTransaction"),a=this.safeString(t,"assetId"),o=this.safeString(t,"balance");if(a in this.currencies_by_id){const e=this.safeCurrencyCode(a);d[e]=this.account(),d[e].total=this.fromRealCurrencyAmount(e,o)}else void 0===i&&(h.push(a),c.push(o))}if(h.length){const e={ids:h},t=await this.publicGetAssets(e),s=this.safeValue(t,"data",[]);for(let e=0;e<s.length;e++){const t=s[e],i=c[e],r=this.safeValue(t,"data"),o=this.parsePrecision(this.safeString(r,"precision")),n=this.safeString(r,"ticker"),h=this.safeCurrencyCode(n);d[h]=this.account(),d[h].total=a.Y.stringMul(i,o)}}const l=this.milliseconds(),u=[this.base58ToBinary(this.apiKey),this.numberToBE(l,8)],p=this.binaryConcatArray(u),f=this.binaryToBase16(this.base58ToBinary(this.secret)),m=this.axolotl(this.binaryToBase16(p),f,o.ev),g={publicKey:this.apiKey,signature:m,timestamp:l.toString()},v=await this.matcherGetMatcherBalanceReservedPublicKey(g),y=Object.keys(v);for(let e=0;e<y.length;e++){const t=y[e],s=this.safeCurrencyCode(t);s in d||(d[s]=this.account());const i=this.safeString(v,t);d[s].used=this.fromRealCurrencyAmount(s,i)}const w={address:t},b=await this.nodeGetAddressesBalanceAddress(w);return d.WAVES=this.safeValue(d,"WAVES",this.account()),d.WAVES.total=this.fromRealCurrencyAmount("WAVES",this.safeString(b,"balance")),d=this.setUndefinedBalancesToZero(d),d.timestamp=n,d.datetime=this.iso8601(n),this.safeBalance(d)}setUndefinedBalancesToZero(e,t="used"){const s=Object.keys(e);for(let i=0;i<s.length;i++){const r=s[i];void 0===this.safeValue(e[r],"used")&&(e[r][t]="0")}return e}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={sender:await this.getWavesAddress()};let a;void 0!==e&&(a=this.market(e),r.amountAsset=a.baseId,r.priceAsset=a.quoteId);const o=await this.publicGetTransactionsExchange(r),n=this.safeValue(o,"data");return this.parseTrades(n,a,t,s)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={amountAsset:r.baseId,priceAsset:r.quoteId};void 0!==s&&(a.limit=Math.min(s,100)),void 0!==t&&(a.timeStart=t);const o=await this.publicGetTransactionsExchange(a),n=this.safeValue(o,"data");return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s=this.safeValue(e,"data"),i=this.safeString(s,"timestamp"),r=this.parse8601(i),a=this.safeString(s,"id"),o=this.safeString(s,"price"),n=this.safeString(s,"amount"),d=this.safeValue(s,"order1"),h=this.safeValue(s,"order2");let c,l;c=this.safeString(d,"senderPublicKey")===this.apiKey?d:h;const u=this.safeValue(c,"assetPair");void 0!==u?l=this.getSymbolFromAssetPair(u):void 0!==t&&(l=t.symbol);const p=this.safeString(c,"orderType"),f=this.safeString(c,"id"),m={cost:this.safeString(c,"matcherFee"),currency:this.safeCurrencyCode(this.safeString(c,"matcherFeeAssetId","WAVES"))};return this.safeTrade({info:e,timestamp:r,datetime:i,symbol:l,id:a,order:f,type:void 0,side:p,takerOrMaker:void 0,price:o,amount:n,cost:void 0,fee:m},t)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);for(let r=0;r<e.length;r++){const a=e[r],o=this.safeString(a,s),n=this.safeValue(this.currencies_by_id,o),d=this.safeString(n,"code",o);if(void 0===t||this.inArray(d,t)){let e=this.safeValue(i,d);void 0===e?e={info:[a],withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0},networks:{}}:(e=i[d],e.info=this.arrayConcat(e.info,[a]));const t=this.safeString(a,"platform_id"),s=this.safeString(n,"code"),r=this.networkIdToCode(t,s);let o=this.safeValue(e.networks,r);void 0===o&&(o={withdraw:{fee:void 0,percentage:void 0},deposit:{fee:void 0,percentage:void 0}});const h=this.safeString(a,"type"),c=this.safeValue(a,"fees");let l="deposit";"withdrawal_currency"===h&&(l="withdraw"),o[l]={fee:this.safeNumber(c,"flat"),percentage:!1},e.networks[r]=o,i[d]=e}}const r=Object.keys(i);for(let e=0;e<r.length;e++){const t=r[e],s=i[t],a=this.safeValue(s,"networks"),o=Object.keys(a);if(1===o.length){const e=this.safeValue(a,o[0]);i[t].withdraw=this.safeValue(e,"withdraw"),i[t].deposit=this.safeValue(e,"deposit")}}return i}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();let s=[],i=[];i.push(this.privateGetDepositCurrencies(t)),i.push(this.privateGetWithdrawCurrencies(t)),i=await Promise.all(i);for(let e=0;e<i.length;e++){const t=this.safeValue(i[e],"items");s=this.arrayConcat(s,t)}return this.parseDepositWithdrawFees(s,e,"id")}handleErrors(e,t,s,i,a,o,n,d,h){const c=this.safeString(n,"error"),l=this.safeBool(n,"success",!0),u=this.safeValue(this.exceptions,c);if(void 0!==u){const e=this.safeString(n,"message");throw new u(this.id+" "+e)}if("Validation Error"===this.safeString(n,"message"))throw new r.BadRequest(this.id+" "+o);if(!l)throw new r.ExchangeError(this.id+" "+o)}async withdraw(e,t,s,i=void 0,a={}){if([i,a]=this.handleWithdrawTagAndParams(i,a),"WAVES"!==e){const t=await this.privateGetWithdrawCurrencies(),s={},i=this.safeValue(t,"items",[]);for(let e=0;e<i.length;e++){const t=i[e];s[this.safeString(t,"id")]=!0}if(!(e in s)){const t=Object.keys(s);throw new r.ExchangeError(this.id+" withdraw() "+e+" not supported. Currency code must be one of "+t.toString())}}await this.loadMarkets();const n=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],d={};for(let e=0;e<n.length;e++){d[n[e]]=!0}let h=!0;const c=this.remove0xPrefix(s).toLowerCase(),l=1*c.length;for(let e=0;e<l;e++){if(!(c[e]in d)){h=!1;break}}let u;if(await this.signIn(),"WAVES"!==e||h){const i={address:s,currency:e},a=await this.privateGetWithdrawAddressesCurrencyAddress(i),o=this.safeValue(a,"currency"),n=this.safeValue(o,"allowed_amount"),d=this.safeNumber(n,"min");if(t<=d)throw new r.BadRequest(this.id+" "+e+" withdraw failed, amount "+t.toString()+" must be greater than the minimum allowed amount of "+d.toString());const h=this.safeValue(a,"proxy_addresses",[]);u=this.safeString(h,0)}else u=s;const p=this.safeInteger(this.options,"withdrawFeeWAVES",1e5),f="WAVES",m=this.toRealCurrencyAmount(e,t),g=this.currency(e),v=this.milliseconds(),y=[this.numberToBE(4,1),this.numberToBE(2,1),this.base58ToBinary(this.apiKey),this.getAssetBytes(g.id),this.getAssetBytes(f),this.numberToBE(v,8),this.numberToBE(m,8),this.numberToBE(p,8),this.base58ToBinary(u),this.numberToBE(0,2)],w=this.binaryConcatArray(y),b=this.binaryToBase16(this.base58ToBinary(this.secret)),S=this.axolotl(this.binaryToBase16(w),b,o.ev),k={senderPublicKey:this.apiKey,amount:m,fee:p,type:4,version:2,attachment:"",feeAssetId:this.getAssetId(f),proofs:[S],assetId:this.getAssetId(g.id),recipient:u,timestamp:v,signature:S},O=await this.nodePostTransactionsBroadcast(k);return this.parseTransaction(O,g)}parseTransaction(e,t=void 0){const s=(t=this.safeCurrency(void 0,t)).code,i="4"===this.safeString(e,"type")?"withdraw":"deposit",r=this.parseNumber(this.fromRealCurrencyAmount(s,this.safeString(e,"amount"))),a=this.safeString(e,"fee"),o=this.safeString(e,"feeAssetId","WAVES"),n=this.safeCurrencyCode(o),d=this.parseNumber(this.fromRealCurrencyAmount(n,a)),h=this.safeInteger(e,"timestamp");return{id:this.safeString(e,"id"),txid:void 0,timestamp:h,datetime:this.iso8601(h),network:void 0,addressFrom:this.safeString(e,"sender"),address:void 0,addressTo:this.safeString(e,"recipient"),amount:r,type:i,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:{currency:n,cost:d},info:e}}}},3439:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8646),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"wazirx",name:"WazirX",countries:["IN"],version:"v2",rateLimit:1e3,pro:!0,has:{CORS:!1,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,fetchBalance:!0,fetchBidsAsks:!1,fetchBorrowInterest:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDepositAddressesByNetwork:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchIsolatedPositions:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarketLeverageTiers:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!1,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!1,fetchOrderBook:!0,fetchOrders:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/148647666-c109c20b-f8ac-472f-91c3-5f658cb90f49.jpeg",api:{rest:"https://api.wazirx.com/sapi/v1"},www:"https://wazirx.com",doc:"https://docs.wazirx.com/#public-rest-api-for-wazirx",fees:"https://wazirx.com/fees",referral:"https://wazirx.com/invite/k7rrnks5"},api:{public:{get:{exchangeInfo:1,depth:.5,ping:1,systemStatus:1,"tickers/24hr":1,"ticker/24hr":1,time:1,trades:1,klines:1}},private:{get:{account:1,allOrders:1,funds:1,historicalTrades:1,openOrders:1,order:.5,myTrades:.5,coins:12,"crypto/withdraws":12,"crypto/deposits/address":60,"sub_account/fund_transfer/history":1,"sub_account/accounts":1},post:{order:.1,"order/test":.5},delete:{order:.1,openOrders:1}}},fees:{WRX:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.0")}},precisionMode:o.kb,exceptions:{exact:{"-1121":r.BadSymbol,1999:r.BadRequest,2002:r.InsufficientFunds,2005:r.BadRequest,2078:r.PermissionDenied,2098:r.BadRequest,2031:r.InvalidOrder,2113:r.BadRequest,2115:r.BadRequest,2136:r.RateLimitExceeded,94001:r.InvalidOrder}},timeframes:{"1m":"1m","5m":"5m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","12h":"12h","1d":"1d","1w":"1w"},options:{recvWindow:1e4,networks:{}}})}async fetchMarkets(e={}){const t=await this.publicGetExchangeInfo(e),s=this.safeValue(t,"symbols",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString(e,"baseAsset"),i=this.safeString(e,"quoteAsset"),r=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeValue(e,"isSpotTradingAllowed"),d=this.safeValue(e,"filters");let h;for(let e=0;e<d.length;e++){const t=d[e];"PRICE_FILTER"===this.safeString(t,"filterType")&&(h=this.safeNumber(t,"minPrice"))}const c=this.safeValue(this.fees,o,{});let l=this.safeString(c,"taker","0.2");l=a.Y.stringDiv(l,"100");let u=this.safeString(c,"maker","0.2");u=a.Y.stringDiv(u,"100");return{id:t,symbol:r+"/"+o,base:r,quote:o,settle:void 0,baseId:s,quoteId:i,settleId:void 0,type:"spot",spot:n,margin:!1,swap:!1,future:!1,option:!1,active:"trading"===this.safeString(e,"status"),contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(l),maker:this.parseNumber(u),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(e,"baseAssetPrecision"))),price:this.parseNumber(this.parsePrecision(this.safeString(e,"quoteAssetPrecision")))},limits:{leverage:{min:void 0,max:void 0},price:{min:h,max:void 0},amount:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,interval:this.safeString(this.timeframes,t,t)};void 0!==i&&(o.limit=Math.min(i,2e3));const n=this.safeInteger(r,"until");r=this.omit(r,["until"]),void 0!==s&&(o.startTime=this.parseToInt(s/1e3)),void 0!==n&&(o.endTime=n);const d=await this.publicGetKlines(this.extend(o,r));return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,2),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,5)]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.publicGetDepth(this.extend(i,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.publicGetTicker24hr(this.extend(i,t));return this.parseTicker(r,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s=await this.publicGetTickers24hr(),i={};for(let e=0;e<s.length;e++){const t=s[e],r=this.parseTicker(t);i[r.symbol]=r}return this.filterByArrayTickers(i,"symbol",e)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=Math.min(s,1e3));let o;return o="privateGetHistoricalTrades"===this.safeString(this.options,"fetchTradesMethod","publicGetTrades")?await this.privateGetHistoricalTrades(this.extend(a,i)):await this.publicGetTrades(this.extend(a,i)),this.parseTrades(o,r,t,s)}parseTrade(e,t=void 0){const s=this.safeString(e,"id"),i=this.safeInteger(e,"time"),r=this.iso8601(i);t=this.safeMarket(void 0,t);const a=this.safeValue(e,"isBuyerMaker")?"sell":"buy",o=this.safeNumber(e,"price"),n=this.safeNumber(e,"qty"),d=this.safeNumber(e,"quoteQty");return this.safeTrade({info:e,id:s,timestamp:i,datetime:r,symbol:t.symbol,order:s,type:void 0,side:a,takerOrMaker:void 0,price:o,amount:n,cost:d,fee:void 0},t)}async fetchStatus(e={}){const t=await this.publicGetSystemStatus(e);return{status:"normal"===this.safeString(t,"status")?"ok":"maintenance",updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.publicGetTime(e);return this.safeInteger(t,"serverTime")}parseTicker(e,t=void 0){const s=this.safeString(e,"symbol"),i=(t=this.safeMarket(s,t)).symbol,r=this.safeString(e,"lastPrice"),a=this.safeString(e,"openPrice"),o=this.safeString(e,"highPrice"),n=this.safeString(e,"lowPrice"),d=this.safeString(e,"volume"),h=this.safeString(e,"bidPrice"),c=this.safeString(e,"askPrice"),l=this.safeInteger(e,"at");return this.safeTicker({symbol:i,timestamp:l,datetime:this.iso8601(l),high:o,low:n,bid:h,bidVolume:void 0,ask:c,askVolume:void 0,vwap:void 0,open:a,close:r,last:r,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:d,quoteVolume:void 0,info:e},t)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],r=this.safeString(i,"asset"),a=this.safeCurrencyCode(r),o=this.account();o.free=this.safeString(i,"free"),o.used=this.safeString(i,"locked"),t[a]=o}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privateGetFunds(e);return this.parseBalance(t)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={symbol:a.id};void 0!==t&&(o.startTime=t),void 0!==s&&(o.limit=s);const n=await this.privateGetAllOrders(this.extend(o,i));let d=this.parseOrders(n,a,t,s);return d=this.filterBy(d,"symbol",e),d}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),r.symbol=a.id);const o=await this.privateGetOpenOrders(this.extend(r,i));return this.parseOrders(o,a,t,s)}async cancelAllOrders(e=void 0,t={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelAllOrders() requires a symbol argument");await this.loadMarkets();const s={symbol:this.market(e).id},i=await this.privateDeleteOpenOrders(this.extend(s,t));return this.parseOrders(i)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={symbol:this.market(t).id,orderId:e},a=await this.privateDeleteOrder(this.extend(i,s));return this.parseOrder(a)}async createOrder(e,t,s,i,a=void 0,o={}){if("limit"!==(t=t.toLowerCase())&&"stop_limit"!==t)throw new r.ExchangeError(this.id+" createOrder() supports limit and stop_limit orders only");if(void 0===a)throw new r.ExchangeError(this.id+" createOrder() requires a price argument");await this.loadMarkets();const n=this.market(e),d={symbol:n.id,side:s,quantity:i,type:"limit"};d.price=this.priceToPrecision(e,a);const h=this.safeString(o,"stopPrice");void 0!==h&&(d.type="stop_limit",d.stopPrice=this.priceToPrecision(e,h));const c=await this.privatePostOrder(this.extend(d,o));return this.parseOrder(c,n)}parseOrder(e,t=void 0){const s=this.safeInteger(e,"createdTime"),i=this.safeInteger(e,"updatedTime"),r=this.safeString(e,"symbol"),a=this.safeSymbol(r,t),o=this.safeString(e,"quantity"),n=this.safeString(e,"executedQty"),d=this.parseOrderStatus(this.safeString(e,"status")),h=this.safeString(e,"id"),c=this.safeString(e,"price"),l=this.safeStringLower(e,"type"),u=this.safeStringLower(e,"side");return this.safeOrder({info:e,id:h,clientOrderId:this.safeString(e,"clientOrderId"),timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:i,status:d,symbol:a,type:l,timeInForce:void 0,postOnly:void 0,side:u,price:c,amount:o,filled:n,remaining:void 0,cost:void 0,fee:void 0,average:this.safeString(e,"avgPrice"),trades:[]},t)}parseOrderStatus(e){return this.safeString({wait:"open",done:"closed",cancel:"canceled"},e,e)}async fetchCurrencies(e={}){if(!this.checkRequiredCredentials(!1))return;const t=await this.privateGetCoins(e),s={};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency"),o=this.safeCurrencyCode(r),n=this.safeString(i,"name"),d=this.safeList(i,"networkList",[]),h={};let c,l,u,p,f,m=!1,g=!1;for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"network"),i=this.networkIdToCode(s),r=this.parseNumber(this.parsePrecision(this.safeString(t,"precision")));c=void 0===c?r:Math.min(c,r);const o=this.safeBool(t,"depositEnable");m=o||m;const n=this.safeBool(t,"withdrawEnable");g=n||g;const v=this.safeString(t,"withdrawFee");void 0!==v&&(l=void 0===l?v:a.Y.stringMin(v,l));const y=this.safeString(t,"minWithdrawAmount");void 0!==y&&(u=void 0===u?y:a.Y.stringMin(y,u));const w=this.safeString(t,"maxWithdrawAmount");void 0!==w&&(p=void 0===p?w:a.Y.stringMin(w,p));const b=this.safeString(t,"depositDust");void 0!==b&&(f=void 0===f?b:a.Y.stringMin(b,f)),h[i]={info:t,id:s,network:i,active:o&&n,deposit:o,withdraw:n,fee:this.parseNumber(v),precision:r,limits:{withdraw:{min:this.parseNumber(y),max:this.parseNumber(w)},deposit:{min:this.parseNumber(b),max:void 0}}}}s[o]={info:i,code:o,id:r,name:n,active:m&&g,deposit:m,withdraw:g,fee:this.parseNumber(l),precision:c,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(u),max:this.parseNumber(p)},deposit:{min:this.parseNumber(f),max:void 0}},networks:h}}return s}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.safeString(t,"network");if(t=this.omit(t,"network"),void 0===i)throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() requires a network parameter");const a={coin:s.id,network:this.networkCodeToId(i,e)},o=await this.privateGetCryptoDepositsAddress(this.extend(a,t));return{currency:e,address:this.safeString(o,"address"),tag:void 0,network:this.networkCodeToId(i,e),info:o}}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.coin=a.id),void 0!==s&&(r.limit=s);const o=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==t&&(r.startTime=t),void 0!==o&&(r.endTime=o);const n=await this.privateGetCryptoWithdraws(this.extend(r,i));return this.parseTransactions(n,a,t,s)}parseTransactionStatus(e){return this.safeString({0:"ok",1:"fail",2:"pending",3:"canceled"},e,e)}parseTransaction(e,t=void 0){const s=this.safeString(e,"coin"),i=this.safeCurrencyCode(s,t),r=this.parse8601(this.safeString(e,"createdAt")),a=this.parse8601(this.safeString(e,"lastUpdated")),o=this.parseTransactionStatus(this.safeString(e,"status")),n=this.safeNumber(e,"transactionFee");let d;return void 0!==n&&(d={cost:n,currency:i}),{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"txId"),timestamp:r,datetime:this.iso8601(r),network:this.networkIdToCode(this.safeString(e,"network")),address:this.safeString(e,"address"),addressTo:this.safeString(e,"address"),addressFrom:void 0,tag:void 0,tagTo:void 0,tagFrom:void 0,type:"withdrawal",amount:this.safeNumber(e,"amount"),currency:i,status:o,updated:a,fee:d,internal:void 0,comment:void 0}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/"+e;if("public"===t&&Object.keys(i).length&&(o+="?"+this.urlencode(i)),"private"===t){this.checkRequiredCredentials();const e=this.milliseconds();let t=this.extend({recvWindow:this.options.recvWindow,timestamp:e},i);t=this.keysort(t);const s=this.hmac(this.encode(this.urlencode(t)),this.encode(this.secret),n.s);o+="?"+this.urlencode(t),o+="&signature="+s,r={"Content-Type":"application/x-www-form-urlencoded","X-Api-Key":this.apiKey}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.safeString(n,"code");if(void 0!==c){const e=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,c,e),new r.ExchangeError(e)}}}},5336:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3965),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"whitebit",name:"WhiteBit",version:"v4",countries:["EE"],rateLimit:50,pro:!0,has:{CORS:void 0,spot:!0,margin:!0,swap:!1,future:!1,option:!1,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelOrders:!1,createMarketBuyOrderWithCost:!0,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createStopLimitOrder:!0,createStopMarketOrder:!0,createStopOrder:!0,editOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchClosedOrders:!0,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchCurrencies:!0,fetchDeposit:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchDepositWithdrawFee:"emulated",fetchDepositWithdrawFees:!0,fetchFundingHistory:!1,fetchFundingRate:!0,fetchFundingRateHistory:!1,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderTrades:!0,fetchPositionMode:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactionFees:!0,repayCrossMargin:!1,repayIsolatedMargin:!1,setLeverage:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","3m":"3m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","12h":"12h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},urls:{logo:"https://user-images.githubusercontent.com/1294454/66732963-8eb7dd00-ee66-11e9-849b-10d9282bb9e0.jpg",api:{v1:{public:"https://whitebit.com/api/v1/public",private:"https://whitebit.com/api/v1"},v2:{public:"https://whitebit.com/api/v2/public"},v4:{public:"https://whitebit.com/api/v4/public",private:"https://whitebit.com/api/v4"}},www:"https://www.whitebit.com",doc:"https://github.com/whitebit-exchange/api-docs",fees:"https://whitebit.com/fee-schedule",referral:"https://whitebit.com/referral/d9bdf40e-28f2-4b52-b2f9-cd1415d82963"},api:{web:{get:["v1/healthcheck"]},v1:{public:{get:["markets","tickers","ticker","symbols","depth/result","history","kline"]},private:{post:["account/balance","order/new","order/cancel","orders","account/order_history","account/executed_history","account/executed_history/all","account/order"]}},v2:{public:{get:["markets","ticker","assets","fee","depth/{market}","trades/{market}"]}},v4:{public:{get:["assets","collateral/markets","fee","orderbook/{market}","ticker","trades/{market}","time","ping","markets","futures","platform/status"]},private:{post:["collateral-account/balance","collateral-account/balance-summary","collateral-account/positions/history","collateral-account/leverage","collateral-account/positions/open","collateral-account/summary","main-account/address","main-account/balance","main-account/create-new-address","main-account/codes","main-account/codes/apply","main-account/codes/my","main-account/codes/history","main-account/fiat-deposit-url","main-account/history","main-account/withdraw","main-account/withdraw-pay","main-account/transfer","main-account/smart/plans","main-account/smart/investment","main-account/smart/investment/close","main-account/smart/investments","main-account/fee","main-account/smart/interest-payment-history","trade-account/balance","trade-account/executed-history","trade-account/order","trade-account/order/history","order/collateral/limit","order/collateral/market","order/collateral/stop-limit","order/collateral/trigger-market","order/new","order/market","order/stock_market","order/stop_limit","order/stop_market","order/cancel","order/cancel/all","order/kill-switch","order/kill-switch/status","order/bulk","order/modify","orders","oco-orders","order/collateral/oco","order/oco-cancel","order/oto-cancel","profile/websocket_token","convert/estimate","convert/confirm","convert/history","sub-account/create","sub-account/delete","sub-account/edit","sub-account/list","sub-account/transfer","sub-account/block","sub-account/unblock","sub-account/balances","sub-account/transfer/history"]}}},fees:{trading:{tierBased:!1,percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0.001")}},options:{fiatCurrencies:["EUR","USD","RUB","UAH"],fetchBalance:{account:"spot"},accountsByType:{funding:"main",main:"main",spot:"spot",margin:"collateral",trade:"spot"},networksById:{BEP20:"BSC"},defaultType:"spot",brokerId:"ccxt"},precisionMode:o.kb,exceptions:{exact:{"Unauthorized request.":r.AuthenticationError,"The market format is invalid.":r.BadSymbol,"Market is not available":r.BadSymbol,"Invalid payload.":r.BadRequest,"Amount must be greater than 0":r.InvalidOrder,"Not enough balance.":r.InsufficientFunds,"The order id field is required.":r.InvalidOrder,"Not enough balance":r.InsufficientFunds,"This action is unauthorized.":r.PermissionDenied,"This API Key is not authorized to perform this action.":r.PermissionDenied,"Unexecuted order was not found.":r.OrderNotFound,"The selected from is invalid.":r.BadRequest,503:r.ExchangeNotAvailable,422:r.OrderNotFound},broad:{"This action is unauthorized":r.PermissionDenied,"Given amount is less than min amount":r.InvalidOrder,"Total is less than":r.InvalidOrder,"fee must be no less than":r.InvalidOrder,"Enable your key in API settings":r.PermissionDenied,"You don't have such amount for transfer":r.InsufficientFunds}}})}async fetchMarkets(e={}){const t=await this.v4PublicGetMarkets();return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"name"),s=this.safeString(e,"stock");let i=this.safeString(e,"money");i="PERP"===i?"USDT":i;const r=this.safeCurrencyCode(s),o=this.safeCurrencyCode(i),n=this.safeValue(e,"tradesEnabled"),d=this.safeValue(e,"isCollateral");let h,c,l,u=r+"/"+o;const p="futures"===this.safeString(e,"type"),f=d&&!p;let m=!1;const g=this.parseNumber(this.parsePrecision(this.safeString(e,"stockPrec"))),v=g;let y,w;p?(l=i,c=this.safeCurrencyCode(l),u=u+":"+c,h="swap",m=!0,y=!0,w=!1):h="spot";const b=this.safeString(e,"takerFee"),S=a.Y.stringDiv(b,"100"),k=this.safeString(e,"makerFee"),O=a.Y.stringDiv(k,"100");return{id:t,symbol:u,base:r,quote:o,settle:c,baseId:s,quoteId:i,settleId:l,type:h,spot:!p,margin:f,swap:p,future:!1,option:!1,active:n,contract:m,linear:y,inverse:w,taker:this.parseNumber(S),maker:this.parseNumber(O),contractSize:v,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:g,price:this.parseNumber(this.parsePrecision(this.safeString(e,"moneyPrec")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"minAmount"),max:void 0},price:{min:void 0,max:void 0},cost:{min:this.safeNumber(e,"minTotal"),max:this.safeNumber(e,"maxTotal")}},created:void 0,info:e}}async fetchCurrencies(e={}){const t=await this.v4PublicGetAssets(e),s=Object.keys(t),i={};for(let e=0;e<s.length;e++){const r=s[e],a=t[r],o=this.safeBool(a,"can_deposit",!0),n=this.safeBool(a,"can_withdraw",!0),d=o&&n,h=this.safeCurrencyCode(r);i[h]={id:r,code:h,info:a,name:void 0,active:d,deposit:o,withdraw:n,fee:void 0,precision:void 0,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(a,"min_withdraw"),max:this.safeNumber(a,"max_withdraw")}}}}return i}async fetchTransactionFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t),i=Object.keys(s),r={},a={};for(let e=0;e<i.length;e++){const t=i[e],o=s[t],n=this.safeCurrencyCode(t),d=this.safeValue(o,"withdraw",{});r[n]=this.safeString(d,"fixed");const h=this.safeValue(o,"deposit",{});a[n]=this.safeString(h,"fixed")}return{withdraw:r,deposit:a,info:s}}async fetchDepositWithdrawFees(e=void 0,t={}){await this.loadMarkets();const s=await this.v4PublicGetFee(t);return this.parseDepositWithdrawFees(s,e)}parseDepositWithdrawFees(e,t=void 0,s=void 0){const i={};t=this.marketCodes(t);const r=Object.keys(e);for(let s=0;s<r.length;s++){const a=r[s],o=a.split(" "),n=o[0],d=e[a],h=this.safeCurrencyCode(n);if(void 0===t||this.inArray(h,t)){void 0===this.safeValue(i,h)&&(i[h]=this.depositWithdrawFee({})),i[h].info[a]=d;let e=this.safeString(o,1);const t=this.safeValue(d,"withdraw"),s=this.safeValue(d,"deposit"),r=this.safeNumber(t,"fixed"),n=this.safeNumber(s,"fixed"),c={fee:r,percentage:void 0===r&&void 0},l={fee:n,percentage:void 0===n&&void 0};if(void 0!==e){const t=e.length;e=e.slice(1,t-1);const s=this.networkIdToCode(e);i[h].networks[s]={withdraw:c,deposit:l}}else i[h].withdraw=c,i[h].deposit=l}}const a=Object.keys(i);for(let e=0;e<a.length;e++){const t=a[e],s=this.currency(t);i[t]=this.assignDefaultDepositWithdrawFees(i[t],s)}return i}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v4PublicGetAssets(e),s={};for(let e=0;e<this.symbols.length;e++){const i=this.symbols[e],r=this.market(i),o=this.safeValue(t,r.baseId,{});let n=this.safeString(o,"maker_fee"),d=this.safeString(o,"taker_fee");n=a.Y.stringDiv(n,"100"),d=a.Y.stringDiv(d,"100"),s[i]={info:o,symbol:r.symbol,percentage:!0,tierBased:!1,maker:this.parseNumber(n),taker:this.parseNumber(d)}}return s}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={market:s.id},r=await this.v1PublicGetTicker(this.extend(i,t)),a=this.safeDict(r,"result",{});return this.parseTicker(a,s)}parseTicker(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeString2(e,"last","last_price"),i=this.safeString(e,"close",s);return this.safeTicker({symbol:t.symbol,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"open"),close:i,last:s,previousClose:void 0,change:void 0,percentage:this.safeString(e,"change"),average:void 0,baseVolume:this.safeString2(e,"base_volume","volume"),quoteVolume:this.safeString2(e,"quote_volume","deal"),info:e},t)}async fetchTickers(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v4PublicGetTicker(t),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],a=this.safeMarket(t),o=this.parseTicker(s[t],a);r[o.symbol]=o}return this.filterByArrayTickers(r,"symbol",e)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={market:this.market(e).id};void 0!==t&&(i.limit=t);const r=await this.v4PublicGetOrderbookMarket(this.extend(i,s)),a=this.safeTimestamp(r,"timestamp");return this.parseOrderBook(r,e,a)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={market:r.id},o=await this.v4PublicGetTradesMarket(this.extend(a,i));return this.parseTrades(o,r,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.market=r.id);const o=await this.v4PrivatePostTradeAccountExecutedHistory(this.extend(a,i));if(Array.isArray(o))return this.parseTrades(o,r,t,s);{let e=[];const i=Object.keys(o);for(let r=0;r<i.length;r++){const a=i[r],n=this.safeMarket(a,void 0,"_"),d=this.safeValue(o,a,[]),h=this.parseTrades(d,n,t,s);e=this.arrayConcat(e,h)}return e=this.sortBy2(e,"timestamp","id"),this.filterBySinceLimit(e,t,s,"timestamp")}}parseTrade(e,t=void 0){t=this.safeMarket(void 0,t);const s=this.safeTimestamp2(e,"time","trade_timestamp"),i=this.safeString2(e,"dealOrderId","orderId"),r=this.safeString(e,"deal"),a=this.safeString(e,"price"),o=this.safeString2(e,"amount","quote_volume"),n=this.safeString2(e,"id","tradeID"),d=this.safeString2(e,"type","side"),h=t.symbol,c=this.safeInteger(e,"role");let l,u;void 0!==c&&(l=1===c?"maker":"taker");const p=this.safeString(e,"fee");return void 0!==p&&(u={cost:p,currency:t.quote}),this.safeTrade({info:e,timestamp:s,datetime:this.iso8601(s),symbol:h,id:n,order:i,type:void 0,takerOrMaker:l,side:d,price:a,amount:o,cost:r,fee:u},t)}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={market:a.id,interval:this.safeString(this.timeframes,t,t)};if(void 0!==s){const e=1440;void 0===i&&(i=e),i=Math.min(i,e);const t=this.parseToInt(s/1e3);o.start=t}void 0!==i&&(o.limit=Math.min(i,1440));const n=await this.v1PublicGetKline(this.extend(o,r)),d=this.safeList(n,"result",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeTimestamp(e,0),this.safeNumber(e,1),this.safeNumber(e,3),this.safeNumber(e,4),this.safeNumber(e,2),this.safeNumber(e,5)]}async fetchStatus(e={}){const t=await this.v4PublicGetPing(e),s=this.safeString(t,0);return{status:"pong"===s?"ok":s,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v4PublicGetTime(e);return this.safeInteger(t,"time")}async createMarketOrderWithCost(e,t,s,i={}){return i.cost=s,await this.createOrder(e,"market",t,0,void 0,i)}async createMarketBuyOrderWithCost(e,t,s={}){return await this.createMarketOrderWithCost(e,"buy",t,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d={market:n.id,side:s};let h;if([h,o]=this.handleParamString(o,"cost"),void 0!==h){if("buy"!==s||"market"!==t)throw new r.InvalidOrder(this.id+" createOrder() cost is only supported for market buy orders");d.amount=this.costToPrecision(e,h)}else d.amount=this.amountToPrecision(e,i);const c=this.safeString2(o,"clOrdId","clientOrderId");if(void 0===c){const e=this.safeString(this.options,"brokerId");void 0!==e&&(d.clientOrderId=e+this.uuid16())}else d.clientOrderId=c,o=this.omit(o,["clientOrderId"]);const l=this.safeString(n,"type"),u="limit"===t,p="market"===t,f=this.safeNumberN(o,["triggerPrice","stopPrice","activation_price"]),m=void 0!==f,g=this.isPostOnly(p,!1,o),[v,y]=this.handleMarginModeAndParams("createOrder",o);if(g&&(d.postOnly=!0),void 0!==v&&"cross"!==v)throw new r.NotSupported(this.id+" createOrder() is only available for cross margin");o=this.omit(y,["postOnly","triggerPrice","stopPrice"]);const w=void 0!==v||"swap"===l;let b;return m?(d.activation_price=this.priceToPrecision(e,f),u?(d.price=this.priceToPrecision(e,a),b=await this.v4PrivatePostOrderStopLimit(this.extend(d,o))):b=w?await this.v4PrivatePostOrderCollateralTriggerMarket(this.extend(d,o)):await this.v4PrivatePostOrderStopMarket(this.extend(d,o))):u?(d.price=this.priceToPrecision(e,a),b=w?await this.v4PrivatePostOrderCollateralLimit(this.extend(d,o)):await this.v4PrivatePostOrderNew(this.extend(d,o))):b=w?await this.v4PrivatePostOrderCollateralMarket(this.extend(d,o)):void 0!==h?await this.v4PrivatePostOrderMarket(this.extend(d,o)):await this.v4PrivatePostOrderStockMarket(this.extend(d,o)),this.parseOrder(b)}async editOrder(e,t,s,i,a=void 0,o=void 0,n={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" editOrder() requires a id argument");if(void 0===t)throw new r.ArgumentsRequired(this.id+" editOrder() requires a symbol argument");await this.loadMarkets();const d={orderId:e,market:this.market(t).id},h=this.safeString2(n,"clOrdId","clientOrderId");void 0!==h&&(d.clientOrderId=h);const c="limit"===s,l=this.safeNumberN(n,["triggerPrice","stopPrice","activation_price"]),u=void 0!==l;n=this.omit(n,["clOrdId","clientOrderId","triggerPrice","stopPrice"]),u?(d.activation_price=this.priceToPrecision(t,l),c?(d.amount=this.amountToPrecision(t,a),d.price=this.priceToPrecision(t,o)):"buy"===i?d.total=this.amountToPrecision(t,a):d.amount=this.amountToPrecision(t,a)):(d.amount=this.amountToPrecision(t,a),c&&(d.price=this.priceToPrecision(t,o)));const p=await this.v4PrivatePostOrderModify(this.extend(d,n));return this.parseOrder(p)}async cancelOrder(e,t=void 0,s={}){if(void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");await this.loadMarkets();const i={market:this.market(t).id,orderId:parseInt(e)},a=await this.v4PrivatePostOrderCancel(this.extend(i,s));return this.parseOrder(a)}async cancelAllOrders(e=void 0,t={}){let s;await this.loadMarkets();const i={};let a;void 0!==e&&(s=this.market(e),i.market=s.id),[a,t]=this.handleMarketTypeAndParams("cancelAllOrders",s,t);const o=[];if("spot"===a){let e;[e,t]=this.handleOptionAndParams(t,"cancelAllOrders","isMargin",!1),e?o.push("margin"):o.push("spot")}else{if("swap"!==a)throw new r.NotSupported(this.id+" cancelAllOrders() does not support "+a+" type");o.push("futures")}i.type=o;const n=await this.v4PrivatePostOrderCancelAll(this.extend(i,t));return this.parseOrders(n,s)}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s=this.safeString(t,"symbol");if(void 0===s)throw new r.ArgumentsRequired(this.id+" cancelAllOrdersAfter() requires a symbol argument in params");const i=this.market(s);t=this.omit(t,"symbol");const a=e>0,o={market:i.id};o.timeout=a?this.numberToString(e/1e3):"null";return await this.v4PrivatePostOrderKillSwitch(this.extend(o,t))}parseBalance(e){const t=Object.keys(e),s={};for(let i=0;i<t.length;i++){const r=t[i],a=this.safeCurrencyCode(r),o=e[r];if("object"==typeof o&&void 0!==o){const e=this.account();e.free=this.safeString2(o,"available","main_balance"),e.used=this.safeString(o,"freeze"),e.total=this.safeString(o,"main_balance"),s[a]=e}else{const e=this.account();e.total=o,s[a]=e}}return this.safeBalance(s)}async fetchBalance(e={}){let t,s;if(await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),"swap"===t)s=await this.v4PrivatePostCollateralAccountBalance(e);else{const t=this.safeValue(this.options,"fetchBalance",{}),i=this.safeString(t,"account"),r=this.safeString2(e,"account","type",i);e=this.omit(e,["account","type"]),s="main"===r||"funding"===r?await this.v4PrivatePostMainAccountBalance(e):await this.v4PrivatePostTradeAccountBalance(e)}return this.parseBalance(s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={market:a.id};void 0!==s&&(o.limit=Math.min(s,100));const n=await this.v4PrivatePostOrders(this.extend(o,i));return this.parseOrders(n,a,t,s,{status:"open"})}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.market(e),e=a.symbol,r.market=a.id),void 0!==s&&(r.limit=Math.min(s,100));const o=await this.v4PrivatePostTradeAccountOrderHistory(this.extend(r,i)),n=Object.keys(o);let d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeMarket(t,void 0,"_"),i=o[t];for(let e=0;e<i.length;e++){const t=this.parseOrder(i[e],s);d.push(this.extend(t,{status:"closed"}))}}return d=this.sortBy(d,"timestamp"),d=this.filterBySymbolSinceLimit(d,e,t,s),d}parseOrderType(e){return this.safeString({limit:"limit",market:"market","stop market":"market","stop limit":"limit","stock market":"market","margin limit":"limit","margin market":"market"},e,e)}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=(t=this.safeMarket(s,t,"_")).symbol,r=this.safeString(e,"side"),a=this.safeString(e,"dealStock");let o=this.safeString(e,"left"),n=this.safeString(e,"clientOrderId");""===n&&(n=void 0);const d=this.safeString(e,"price"),h=this.safeNumber(e,"activation_price"),c=this.safeString2(e,"orderId","id"),l=this.safeString(e,"type"),u=this.parseOrderType(l);"market"===u&&(o=void 0);let p=this.safeString(e,"amount");const f=this.safeString(e,"dealMoney");"buy"!==r||"market"!==l&&"stop market"!==l||(p=a);const m=this.safeString(e,"dealFee");let g;void 0!==m&&(g={cost:this.parseNumber(m),currency:t.quote});const v=this.safeTimestamp2(e,"ctime","timestamp"),y=this.safeTimestamp(e,"ftime");return this.safeOrder({info:e,id:c,symbol:i,clientOrderId:n,timestamp:v,datetime:this.iso8601(v),lastTradeTimestamp:y,timeInForce:void 0,postOnly:void 0,status:void 0,side:r,price:d,type:u,stopPrice:h,triggerPrice:h,amount:p,filled:a,remaining:o,average:void 0,cost:f,fee:g,trades:void 0},t)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={orderId:parseInt(e)};let o;void 0!==t&&(o=this.market(t),a.market=o.id),void 0!==i&&(a.limit=Math.min(i,100));const n=await this.v4PrivatePostTradeAccountOrder(this.extend(a,r)),d=this.safeList(n,"records",[]);return this.parseTrades(d,o)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s={ticker:this.currency(e).id};let i;if(this.isFiat(e)){const e=this.safeString(t,"provider");if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() requires a provider when the ticker is fiat");s.provider=e;const a=this.safeNumber(t,"amount");if(void 0===a)throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() requires an amount when the ticker is fiat");s.amount=a;if(void 0===this.safeValue(t,"uniqueId"))throw new r.ArgumentsRequired(this.id+" fetchDepositAddress() requires an uniqueId when the ticker is fiat");i=await this.v4PrivatePostMainAccountFiatDepositUrl(this.extend(s,t))}else i=await this.v4PrivatePostMainAccountAddress(this.extend(s,t));const a=this.safeString(i,"url"),o=this.safeValue(i,"account",{}),n=this.safeString(o,"address",a),d=this.safeString(o,"memo");return this.checkAddress(n),{currency:e,address:n,tag:d,network:void 0,info:i}}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),void 0!==t)throw new r.NotSupported(this.id+" setLeverage() does not allow to set per symbol");if(e<1||e>20)throw new r.BadRequest(this.id+" setLeverage() leverage should be between 1 and 20");const i={leverage:e};return await this.v4PrivatePostCollateralAccountLeverage(this.extend(i,s))}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsByType"),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.currencyToPrecision(e,t),c={ticker:a.id,amount:h,from:n,to:d},l=await this.v4PrivatePostMainAccountTransfer(this.extend(c,r));return this.parseTransfer(l,a)}parseTransfer(e,t=void 0){return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}async withdraw(e,t,s,i=void 0,a={}){await this.loadMarkets();const o=this.currency(e),n={ticker:o.id,amount:this.currencyToPrecision(e,t),address:s};let d=this.safeValue(a,"uniqueId");if(void 0===d&&(d=this.uuid22()),n.uniqueId=d,void 0!==i&&(n.memo=i),this.isFiat(e)){const e=this.safeValue(a,"provider");if(void 0===e)throw new r.ArgumentsRequired(this.id+" withdraw() requires a provider when the ticker is fiat");n.provider=e}const h=await this.v4PrivatePostMainAccountWithdraw(this.extend(n,a));return this.extend({id:d},this.parseTransaction(h,o))}parseTransaction(e,t=void 0){t=this.safeCurrency(void 0,t);const s=this.safeString(e,"address"),i=this.safeTimestamp(e,"createdAt"),r=this.safeString(e,"ticker"),a=this.safeString(e,"status"),o=this.safeString(e,"method");return{id:this.safeString(e,"uniqueId"),txid:this.safeString(e,"transactionId"),timestamp:i,datetime:this.iso8601(i),network:this.safeString(e,"network"),addressFrom:"1"===o?s:void 0,address:s,addressTo:"2"===o?s:void 0,amount:this.safeNumber(e,"amount"),type:"1"===o?"deposit":"withdrawal",currency:this.safeCurrencyCode(r,t),status:this.parseTransactionStatus(a),updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:this.safeString(e,"description"),internal:void 0,fee:{cost:this.safeNumber(e,"fee"),currency:this.safeCurrencyCode(r,t)},info:e}}parseTransactionStatus(e){return this.safeString({1:"pending",2:"pending",3:"ok",4:"canceled",5:"pending",6:"pending",7:"ok",9:"canceled",10:"pending",11:"pending",12:"pending",13:"pending",14:"pending",15:"pending",16:"pending",17:"pending"},e,e)}async fetchDeposit(e,t=void 0,s={}){let i;await this.loadMarkets();const r={transactionMethod:1,uniqueId:e,limit:1,offset:0};void 0!==t&&(i=this.currency(t),r.ticker=i.id);const a=await this.v4PrivatePostMainAccountHistory(this.extend(r,s)),o=this.safeValue(a,"records",[]),n=this.safeDict(o,0,{});return this.parseTransaction(n,i)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={transactionMethod:1,limit:100,offset:0};void 0!==e&&(r=this.currency(e),a.ticker=r.id),void 0!==s&&(a.limit=Math.min(s,100));const o=await this.v4PrivatePostMainAccountHistory(this.extend(a,i)),n=this.safeList(o,"records",[]);return this.parseTransactions(n,r,t,s)}async fetchBorrowInterest(e=void 0,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o;void 0!==t&&(o=this.market(t),a.market=o.id);const n=await this.v4PrivatePostCollateralAccountPositionsOpen(this.extend(a,r)),d=this.parseBorrowInterests(n,o);return this.filterByCurrencySinceLimit(d,e,s,i)}parseBorrowInterest(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"_"),r=this.safeTimestamp(e,"modifyDate");return{symbol:i,marginMode:"cross",currency:"USDT",interest:this.safeNumber(e,"unrealizedFunding"),interestRate:98e-5,amountBorrowed:this.safeNumber(e,"amount"),timestamp:r,datetime:this.iso8601(r),info:e}}async fetchFundingRate(e,t={}){await this.loadMarkets(),e=this.symbol(e);const s=await this.fetchFundingRates([e],t);return this.safeValue(s,e)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v4PublicGetFutures(t),i=this.safeValue(s,"result",[]),r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"ticker_id"),i=this.safeSymbol(s,t),r=this.safeNumber(e,"markPrice"),a=this.safeNumber(e,"indexPrice"),o=this.safeNumber(e,"interestRate"),n=this.safeNumber(e,"funding_rate"),d=this.safeInteger(e,"next_funding_rate_timestamp");return{info:e,symbol:i,markPrice:r,indexPrice:a,interestRate:o,timestamp:void 0,datetime:void 0,fundingRate:n,fundingTimestamp:void 0,fundingDatetime:this.iso8601(void 0),nextFundingRate:void 0,nextFundingTimestamp:d,nextFundingDatetime:this.iso8601(d),previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.ticker=a.id),void 0!==s&&(r.limit=s);const o=await this.v4PrivatePostMainAccountHistory(this.extend(r,i)),n=this.safeList(o,"records");return this.parseTransactions(n,a,t,s)}isFiat(e){const t=this.safeValue(this.options,"fiatCurrencies",[]);return this.inArray(e,t)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=this.omit(i,this.extractParams(e)),d=this.safeValue(t,0),h=this.safeValue(t,1),c="/"+this.implodeParams(e,i);let l=this.urls.api[d][h]+c;if("public"===h&&Object.keys(o).length&&(l+="?"+this.urlencode(o)),"private"===h){this.checkRequiredCredentials();const e=this.nonce().toString(),t=this.encode(this.secret),s="/api/"+d+c;a=this.json(this.extend({request:s,nonce:e},i));const o=this.stringToBase64(a),h=this.hmac(this.encode(o),t,n.Zf);r={"Content-Type":"application/json","X-TXC-APIKEY":this.apiKey,"X-TXC-PAYLOAD":o,"X-TXC-SIGNATURE":h}}return{url:l,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(418===e||429===e)throw new r.DDoSProtection(this.id+" "+e.toString()+" "+t+" "+o);if(404===e)throw new r.ExchangeError(this.id+" "+e.toString()+" endpoint not found");if(void 0!==n){const e=this.safeString(n,"status"),t=this.safeString(n,"message"),s=this.safeInteger(n,"code"),i=void 0!==e&&"200"!==e;if(i||void 0!==s){const s=this.id+" "+o;let a=t;if(i)a=e;else{const e=this.safeDict(n,"errors",{}),t=Object.keys(e);if(t.length>0){const s=t[0],i=this.safeValue(e,s,[]);a=i.length>0?i[0]:o}}throw this.throwExactlyMatchedException(this.exceptions.exact,a,s),this.throwBroadlyMatchedException(this.exceptions.broad,o,s),new r.ExchangeError(s)}}}}},669:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(7246),r=s(2079),a=s(5147),o=s(1579),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"woo",name:"WOO X",countries:["KY"],rateLimit:100,version:"v1",certified:!0,pro:!0,hostname:"woo.org",has:{CORS:void 0,spot:!0,margin:!0,swap:!0,future:!1,option:!1,addMargin:!0,cancelAllOrders:!0,cancelAllOrdersAfter:!0,cancelOrder:!0,cancelWithdraw:!1,closeAllPositions:!1,closePosition:!1,createConvertTrade:!0,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketOrder:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!0,createOrder:!0,createOrderWithTakeProfitAndStopLoss:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopLossOrder:!0,createStopMarketOrder:!1,createStopOrder:!1,createTakeProfitOrder:!0,createTrailingAmountOrder:!0,createTrailingPercentOrder:!0,createTriggerOrder:!0,fetchAccounts:!0,fetchBalance:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!0,fetchConvertCurrencies:!0,fetchConvertQuote:!0,fetchConvertTrade:!0,fetchConvertTradeHistory:!0,fetchCurrencies:!0,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!0,fetchPositionsHistory:!1,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfers:!0,fetchWithdrawals:!0,reduceMargin:!1,sandbox:!0,setLeverage:!0,setMargin:!1,setPositionMode:!0,transfer:!0,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w","1M":"1mon","1y":"1y"},urls:{logo:"https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",api:{pub:"https://api-pub.woo.org",public:"https://api.{hostname}",private:"https://api.{hostname}"},test:{pub:"https://api-pub.staging.woo.org",public:"https://api.staging.woo.org",private:"https://api.staging.woo.org"},www:"https://woo.org/",doc:["https://docs.woo.org/"],fees:["https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"],referral:{url:"https://x.woo.org/register?ref=DIJT0CNL",discount:.35}},api:{v1:{pub:{get:{"hist/kline":10,"hist/trades":1}},public:{get:{info:1,"info/{symbol}":1,system_info:1,market_trades:1,token:1,token_network:1,funding_rates:1,"funding_rate/{symbol}":1,funding_rate_history:1,futures:1,"futures/{symbol}":1,"orderbook/{symbol}":1,kline:1}},private:{get:{"client/token":1,"order/{oid}":1,"client/order/{client_order_id}":1,orders:1,"client/trade/{tid}":1,"order/{oid}/trades":1,"client/trades":1,"client/hist_trades":1,"staking/yield_history":1,"client/holding":1,"asset/deposit":10,"asset/history":60,"sub_account/all":60,"sub_account/assets":60,"sub_account/asset_detail":60,"sub_account/ip_restriction":10,"asset/main_sub_transfer_history":30,token_interest:60,"token_interest/{token}":60,"interest/history":60,"interest/repay":60,"funding_fee/history":30,positions:3.33,"position/{symbol}":3.33,"client/transaction_history":60,"client/futures_leverage":60},post:{order:5,"order/cancel_all_after":1,"asset/main_sub_transfer":30,"asset/ltv":30,"asset/withdraw":30,"asset/internal_withdraw":30,"interest/repay":60,"client/account_mode":120,"client/position_mode":5,"client/leverage":120,"client/futures_leverage":30,"client/isolated_margin":30},delete:{order:1,"client/order":1,orders:1,"asset/withdraw":120}}},v2:{private:{get:{"client/holding":1}}},v3:{public:{get:{insuranceFund:3}},private:{get:{"algo/order/{oid}":1,"algo/orders":1,balances:1,accountinfo:60,positions:3.33,buypower:1,referrals:60,referral_rewards:60,"convert/exchangeInfo":1,"convert/assetInfo":1,"convert/rfq":60,"convert/trade":1,"convert/trades":1},post:{"algo/order":5,"convert/rft":60},put:{"order/{oid}":2,"order/client/{client_order_id}":2,"algo/order/{oid}":2,"algo/order/client/{client_order_id}":2},delete:{"algo/order/{order_id}":1,"algo/orders/pending":1,"algo/orders/pending/{symbol}":1,"orders/pending":1}}}},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},options:{sandboxMode:!1,createMarketBuyOrderRequiresPrice:!0,"network-aliases-for-tokens":{HT:"ERC20",OMG:"ERC20",UATOM:"ATOM",ZRX:"ZRX"},networks:{TRX:"TRON",TRC20:"TRON",ERC20:"ETH",BEP20:"BSC"},defaultNetworkCodeForCurrencies:{},transfer:{fillResponseFromRequest:!0},brokerId:"bc830de7-50f3-460b-9ee0-f430f83f9dad"},commonCurrencies:{},exceptions:{exact:{"-1000":r.OperationFailed,"-1001":r.AuthenticationError,"-1002":r.AuthenticationError,"-1003":r.RateLimitExceeded,"-1004":r.BadRequest,"-1005":r.BadRequest,"-1006":r.BadRequest,"-1007":r.BadRequest,"-1008":r.InvalidOrder,"-1009":r.BadRequest,"-1012":r.BadRequest,"-1101":r.InvalidOrder,"-1102":r.InvalidOrder,"-1103":r.InvalidOrder,"-1104":r.InvalidOrder,"-1105":r.InvalidOrder},broad:{"Can not place":r.ExchangeError,maintenance:r.OnMaintenance,"symbol must not be blank":r.BadRequest,"The token is not supported":r.BadRequest,"Your order and symbol are not valid or already canceled":r.BadRequest,"Insufficient WOO. Please enable margin trading for leverage trading":r.BadRequest}},precisionMode:o.kb})}async fetchStatus(e={}){const t=await this.v1PublicGetSystemInfo(e),s=this.safeDict(t,"data",{});let i=this.safeString(s,"status");return i=void 0===i?"error":"0"===i?"ok":"maintenance",{status:i,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v1PublicGetSystemInfo(e);return this.safeInteger(t,"timestamp")}async fetchMarkets(e={}){const t=await this.v1PublicGetInfo(e),s=this.safeList(t,"rows",[]);return this.parseMarkets(s)}parseMarket(e){const t=this.safeString(e,"symbol"),s=t.split("_"),i=this.safeString(s,0);let r,a=!1,o=!1;"SPOT"===i?(a=!0,r="spot"):"PERP"===i&&(o=!0,r="swap");const n=this.safeString(s,1),d=this.safeString(s,2),h=this.safeCurrencyCode(n),c=this.safeCurrencyCode(d);let l,u,p,f,m=h+"/"+c,g=!0;const v=o;return v&&(g=!1,l=this.safeString(s,2),u=this.safeCurrencyCode(l),m=h+"/"+c+":"+u,p=this.parseNumber("1"),f=!0),{id:t,symbol:m,base:h,quote:c,settle:u,baseId:n,quoteId:d,settleId:l,type:r,spot:a,margin:g,swap:o,future:!1,option:!1,active:"1"===this.safeString(e,"is_trading"),contract:v,linear:f,inverse:void 0,contractSize:p,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"base_tick"),price:this.safeNumber(e,"quote_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"base_min"),max:this.safeNumber(e,"base_max")},price:{min:this.safeNumber(e,"quote_min"),max:this.safeNumber(e,"quote_max")},cost:{min:this.safeNumber(e,"min_notional"),max:void 0}},created:this.safeTimestamp(e,"created_time"),info:e}}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=s);const o=await this.v1PublicGetMarketTrades(this.extend(a,i)),n=this.safeList(o,"rows",[]);return this.parseTrades(n,r,t,s)}parseTrade(e,t=void 0){const s="id"in e,i=this.safeTimestamp(e,"executed_timestamp"),r=this.safeString(e,"symbol"),o=(t=this.safeMarket(r,t)).symbol,n=this.safeString(e,"executed_price"),d=this.safeString(e,"executed_quantity"),h=this.safeString(e,"order_id"),c=this.parseTokenAndFeeTemp(e,"fee_asset","fee"),l=this.safeString(c,"cost");void 0!==l&&(c.cost=l);const u=a.Y.stringMul(n,d),p=this.safeStringLower(e,"side"),f=this.safeString(e,"id");let m;if(s){m="1"===this.safeString(e,"is_maker")?"maker":"taker"}return this.safeTrade({id:f,timestamp:i,datetime:this.iso8601(i),symbol:o,side:p,price:n,amount:d,cost:u,order:h,takerOrMaker:m,type:void 0,fee:c,info:e},t)}parseTokenAndFeeTemp(e,t,s){const i=this.safeString(e,s);let r;if(void 0!==i){const s=this.safeString(e,t);r={cost:i,currency:this.safeCurrencyCode(s)}}return r}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v3PrivateGetAccountinfo(e),s=this.safeDict(t,"data",{}),i=this.safeString(s,"makerFeeRate"),r=this.safeString(s,"takerFeeRate"),o={};for(let e=0;e<this.symbols.length;e++){const s=this.symbols[e];o[s]={info:t,symbol:s,maker:this.parseNumber(a.Y.stringDiv(i,"10000")),taker:this.parseNumber(a.Y.stringDiv(r,"10000")),percentage:!0,tierBased:!0}}return o}async fetchCurrencies(e={}){const t={},s=await this.v1PublicGetToken(e),i=this.safeList(s,"rows",[]),r=this.groupBy(i,"balance_token"),o=Object.keys(r);for(let e=0;e<o.length;e++){const s=o[e],i=r[s],n=this.safeCurrencyCode(s);let d,h;const c={};for(let e=0;e<i.length;e++){const t=i[e];d=this.safeString(t,"fullname");const s=this.safeString(t,"token"),r=s.split("_")[0],o=this.parsePrecision(this.safeString(t,"decimals"));void 0!==o&&(h=void 0===h?o:a.Y.stringMin(o,h)),c[r]={id:s,network:r,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.parseNumber(o),info:t}}t[n]={id:s,name:d,code:n,precision:this.parseNumber(h),active:void 0,fee:void 0,networks:c,deposit:void 0,withdraw:void 0,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0}},info:i}}return t}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","buy",t,1,s)}async createMarketSellOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new r.NotSupported(this.id+" createMarketSellOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","sell",t,1,s)}async createTrailingAmountOrder(e,t,s,i,a=void 0,o=void 0,n=void 0,d={}){if(void 0===o)throw new r.ArgumentsRequired(this.id+" createTrailingAmountOrder() requires a trailingAmount argument");if(void 0===n)throw new r.ArgumentsRequired(this.id+" createTrailingAmountOrder() requires a trailingTriggerPrice argument");return d.trailingAmount=o,d.trailingTriggerPrice=n,await this.createOrder(e,t,s,i,a,d)}async createTrailingPercentOrder(e,t,s,i,a=void 0,o=void 0,n=void 0,d={}){if(void 0===o)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingPercent argument");if(void 0===n)throw new r.ArgumentsRequired(this.id+" createTrailingPercentOrder() requires a trailingTriggerPrice argument");return d.trailingPercent=o,d.trailingTriggerPrice=n,await this.createOrder(e,t,s,i,a,d)}async createOrder(e,t,s,i,o=void 0,n={}){const d=this.safeBool2(n,"reduceOnly","reduce_only");n=this.omit(n,["reduceOnly","reduce_only"]);const h=t.toUpperCase();await this.loadMarkets();const c=this.market(e),l=s.toUpperCase(),u={symbol:c.id,side:l};let p;[p,n]=this.handleMarginModeAndParams("createOrder",n),void 0!==p&&(u.margin_mode=this.encodeMarginMode(p));const f=this.safeNumber2(n,"triggerPrice","stopPrice"),m=this.safeValue(n,"stopLoss"),g=this.safeValue(n,"takeProfit"),v=this.safeString(n,"algoType"),y=this.safeString2(n,"trailingTriggerPrice","activatedPrice",this.numberToString(o)),w=this.safeString2(n,"trailingAmount","callbackValue"),b=this.safeString2(n,"trailingPercent","callbackRate"),S=void 0!==w,k=void 0!==b,O=S||k,T=O||void 0!==f||void 0!==m||void 0!==g||void 0!==this.safeValue(n,"childOrders"),P="MARKET"===h,I=this.safeStringLower(n,"timeInForce"),x=this.isPostOnly(P,void 0,n),A=T?"reduceOnly":"reduce_only",M=T?"clientOrderId":"client_order_id",C=T?"quantity":"order_quantity",E=T?"price":"order_price";if(u[T?"type":"order_type"]=h,T||(x?u.order_type="POST_ONLY":"fok"===I?u.order_type="FOK":"ioc"===I&&(u.order_type="IOC")),d&&(u[A]=d),P||void 0===o||(u[E]=this.priceToPrecision(e,o)),P&&!T){const t=this.safeString2(n,"cost","order_amount");n=this.omit(n,["cost","order_amount"]);const s=void 0!==o;if(c.spot&&(s||void 0!==t)){let s;if(void 0!==t)s=this.costToPrecision(e,t);else{const t=this.numberToString(i),r=this.numberToString(o),n=a.Y.stringMul(t,r);s=this.costToPrecision(e,n)}u.order_amount=s}else u.order_quantity=this.amountToPrecision(e,i)}else"POSITIONAL_TP_SL"!==v&&(u[C]=this.amountToPrecision(e,i));const _=this.safeStringN(n,["clOrdID","clientOrderId","client_order_id"]);if(void 0!==_&&(u[M]=_),O){if(void 0===y)throw new r.ArgumentsRequired(this.id+" createOrder() requires a trailingTriggerPrice parameter for trailing orders");if(u.activatedPrice=this.priceToPrecision(e,y),u.algoType="TRAILING_STOP",S)u.callbackValue=w;else if(k){const e=a.Y.stringDiv(b,"100");u.callbackRate=e}}else if(void 0!==f)"TRAILING_STOP"!==v&&(u.triggerPrice=this.priceToPrecision(e,f),u.algoType="STOP");else if(void 0!==m||void 0!==g){u.algoType="BRACKET";const t={symbol:c.id,reduceOnly:!1,algoType:"POSITIONAL_TP_SL",childOrders:[]},s="BUY"===l?"SELL":"BUY";if(void 0!==m){const i=this.safeNumber2(m,"triggerPrice","price",m),r={side:s,algoType:"STOP_LOSS",triggerPrice:this.priceToPrecision(e,i),type:"CLOSE_POSITION",reduceOnly:!0};t.childOrders.push(r)}if(void 0!==g){const i=this.safeNumber2(g,"triggerPrice","price",g),r={side:s,algoType:"TAKE_PROFIT",triggerPrice:this.priceToPrecision(e,i),type:"CLOSE_POSITION",reduceOnly:!0};t.childOrders.push(r)}u.childOrders=[t]}let B;n=this.omit(n,["clOrdID","clientOrderId","client_order_id","postOnly","timeInForce","stopPrice","triggerPrice","stopLoss","takeProfit","trailingPercent","trailingAmount","trailingTriggerPrice"]),B=T?await this.v3PrivatePostAlgoOrder(this.extend(u,n)):await this.v1PrivatePostOrder(this.extend(u,n));const N=this.safeDict(B,"data");if(void 0!==N){const e=this.safeList(N,"rows",[]);return this.parseOrder(e[0],c)}const R=this.parseOrder(B,c);return R.type=t,R}encodeMarginMode(e){return this.safeString({cross:"CROSS",isolated:"ISOLATED"},e,e)}async editOrder(e,t,s,i,r=void 0,o=void 0,n={}){await this.loadMarkets();const d=this.market(t),h={};void 0!==o&&(h.price=this.priceToPrecision(t,o)),void 0!==r&&(h.quantity=this.amountToPrecision(t,r));const c=this.safeString2(n,"clOrdID","clientOrderId"),l=this.safeString(n,"client_order_id",c),u=void 0!==l,p=this.safeNumberN(n,["triggerPrice","stopPrice","takeProfitPrice","stopLossPrice"]);void 0!==p&&(h.triggerPrice=this.priceToPrecision(t,p));const f=this.safeString2(n,"trailingTriggerPrice","activatedPrice",this.numberToString(o)),m=this.safeString2(n,"trailingAmount","callbackValue"),g=this.safeString2(n,"trailingPercent","callbackRate"),v=void 0!==m,y=void 0!==g,w=v||y;if(w)if(void 0!==f&&(h.activatedPrice=this.priceToPrecision(t,f)),v)h.callbackValue=m;else if(y){const e=a.Y.stringDiv(g,"100");h.callbackRate=e}n=this.omit(n,["clOrdID","clientOrderId","client_order_id","stopPrice","triggerPrice","takeProfitPrice","stopLossPrice","trailingTriggerPrice","trailingAmount","trailingPercent"]);const b=w||void 0!==p||void 0!==this.safeValue(n,"childOrders");let S;u?(h.client_order_id=l,S=b?await this.v3PrivatePutAlgoOrderClientClientOrderId(this.extend(h,n)):await this.v3PrivatePutOrderClientClientOrderId(this.extend(h,n))):(h.oid=e,S=b?await this.v3PrivatePutAlgoOrderOid(this.extend(h,n)):await this.v3PrivatePutOrderOid(this.extend(h,n)));const k=this.safeDict(S,"data",{});return this.parseOrder(k,d)}async cancelOrder(e,t=void 0,s={}){const i=this.safeBool(s,"stop",!1);if(s=this.omit(s,"stop"),!i&&void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={},n=this.safeString2(s,"clOrdID","clientOrderId"),d=this.safeString(s,"client_order_id",n),h=void 0!==d;let c;i?(o.order_id=e,c=await this.v3PrivateDeleteAlgoOrderOrderId(this.extend(o,s))):(o.symbol=a.id,h?(o.client_order_id=d,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"]),c=await this.v1PrivateDeleteClientOrder(this.extend(o,s))):(o.order_id=e,c=await this.v1PrivateDeleteOrder(this.extend(o,s))));const l={symbol:t};return h?l.client_order_id=d:l.id=e,this.extend(this.parseOrder(c),l)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.safeBool2(t,"stop","trigger");if(t=this.omit(t,["stop","trigger"]),s)return await this.v3PrivateDeleteAlgoOrdersPending(t);if(void 0===e)throw new r.ArgumentsRequired(this.id+" cancelOrders() requires a symbol argument");const i={symbol:this.market(e).id},a=await this.v1PrivateDeleteOrders(this.extend(i,t));return[this.safeOrder(a)]}async cancelAllOrdersAfter(e,t={}){await this.loadMarkets();const s={trigger_after:e>0?e:0},i=await this.v1PrivatePostOrderCancelAllAfter(this.extend(s,t));return[this.safeOrder(i)]}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=void 0!==t?this.market(t):void 0,r=this.safeBool2(s,"stop","trigger");s=this.omit(s,["stop","trigger"]);const a={},o=this.safeString2(s,"clOrdID","clientOrderId");let n;r?(a.oid=e,n=await this.v3PrivateGetAlgoOrderOid(this.extend(a,s))):o?(a.client_order_id=o,n=await this.v1PrivateGetClientOrderClientOrderId(this.extend(a,s))):(a.oid=e,n=await this.v1PrivateGetOrderOid(this.extend(a,s)));const d=this.safeDict(n,"data",n);return this.parseOrder(d,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchOrders",e,t,s,i,"page",500);const a={};let o;const n=this.safeBool2(i,"stop","trigger"),d=this.safeBool(i,"trailing",!1);let h;i=this.omit(i,["stop","trailing","trigger"]),void 0!==e&&(o=this.market(e),a.symbol=o.id),void 0!==t&&(n||d?a.createdTimeStart=t:a.start_t=t),a.size=void 0!==s?s:500,n?a.algoType="stop":d&&(a.algoType="TRAILING_STOP"),h=n||d?await this.v3PrivateGetAlgoOrders(this.extend(a,i)):await this.v1PrivateGetOrders(this.extend(a,i));const c=this.safeValue(h,"data",h),l=this.safeList(c,"rows");return this.parseOrders(l,o,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.extend(i,{status:"INCOMPLETE"});return await this.fetchOrders(e,t,s,r)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.extend(i,{status:"COMPLETED"});return await this.fetchOrders(e,t,s,r)}parseTimeInForce(e){return this.safeString({ioc:"IOC",fok:"FOK",post_only:"PO"},e,void 0)}parseOrder(e,t=void 0){const s=this.safeTimestampN(e,["timestamp","created_time","createdTime"]),i=this.safeStringN(e,["order_id","orderId","algoOrderId"]),r=this.omitZero(this.safeString2(e,"client_order_id","clientOrderId")),a=this.safeString(e,"symbol"),o=(t=this.safeMarket(a,t)).symbol,n=this.safeString2(e,"order_price","price"),d=this.safeString2(e,"order_quantity","quantity"),h=this.safeString2(e,"order_amount","amount"),c=this.safeStringLower2(e,"order_type","type"),l=this.safeValue2(e,"status","algoStatus"),u=this.safeStringLower(e,"side"),p=this.omitZero(this.safeValue2(e,"executed","totalExecutedQuantity")),f=this.omitZero(this.safeString2(e,"average_executed_price","averageExecutedPrice")),m=this.safeNumber2(e,"total_fee","totalFee"),g=this.safeString2(e,"fee_asset","feeAsset"),v=this.safeValue(e,"Transactions"),y=this.safeNumber(e,"triggerPrice");let w,b;const S=this.safeValue(e,"childOrders");if(void 0!==S){const e=this.safeValue(S,0),t=this.safeValue(e,"childOrders",[]);if(t.length>0){const e=this.safeValue(t,0),s=this.safeValue(t,1);w=this.safeNumber(e,"triggerPrice"),b=this.safeNumber(s,"triggerPrice")}}const k=this.safeTimestamp2(e,"updatedTime","updated_time");return this.safeOrder({id:i,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,lastUpdateTimestamp:k,status:this.parseOrderStatus(l),symbol:o,type:c,timeInForce:this.parseTimeInForce(c),postOnly:void 0,reduceOnly:this.safeBool(e,"reduce_only"),side:u,price:n,stopPrice:y,triggerPrice:y,takeProfitPrice:w,stopLossPrice:b,average:f,amount:d,filled:p,remaining:void 0,cost:h,trades:v,fee:{cost:m,currency:g},info:e},t)}parseOrderStatus(e){if(void 0!==e){const t={NEW:"open",FILLED:"closed",CANCEL_SENT:"canceled",CANCEL_ALL_SENT:"canceled",CANCELLED:"canceled",PARTIAL_FILLED:"open",REJECTED:"rejected",INCOMPLETE:"open",COMPLETED:"closed"};return this.safeString(t,e,e)}return e}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(t=Math.min(t,1e3),i.max_level=t);const r=await this.v1PublicGetOrderbookSymbol(this.extend(i,s)),a=this.safeInteger(r,"timestamp");return this.parseOrderBook(r,e,a,"bids","asks","price","quantity")}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,type:this.safeString(this.timeframes,t,t)};let n,d=void 0!==s;if(void 0!==i&&void 0!==s){const e=1e3*this.parseTimeframe(t)*999;d=s<this.milliseconds()-e}d?o.start_time=s:void 0!==i&&(o.limit=Math.min(i,1e3)),d?(n=await this.v1PubGetHistKline(this.extend(o,r)),n=this.safeDict(n,"data")):n=await this.v1PublicGetKline(this.extend(o,r));const h=this.safeList(n,"rows",[]);return this.parseOHLCVs(h,a,t,s,i)}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start_timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={oid:e},n=await this.v1PrivateGetOrderOidTrades(this.extend(o,r)),d=this.safeList(n,"rows",[]);return this.parseTrades(d,a,s,i,r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchMyTrades",e,t,s,i,"page",500);const a={};let o;void 0!==e&&(o=this.market(e),a.symbol=o.id),void 0!==t&&(a.start_t=t),a.size=void 0!==s?s:500;const n=await this.v1PrivateGetClientTrades(this.extend(a,i)),d=this.safeList(n,"rows",[]);return this.parseTrades(d,o,t,s,i)}async fetchAccounts(e={}){const t=await this.v1PrivateGetSubAccountAssets(e),s=this.safeList(t,"rows",[]);return this.parseAccounts(s,e)}parseAccount(e){const t=this.safeString(e,"account");return{info:e,id:this.safeString(e,"application_id"),name:t,code:void 0,type:"Main"===t?"main":"subaccount"}}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v3PrivateGetBalances(e),s=this.safeDict(t,"data");return this.parseBalance(s)}parseBalance(e){const t={info:e},s=this.safeList(e,"holding",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeCurrencyCode(this.safeString(i,"token")),a=this.account();a.total=this.safeString(i,"holding"),a.free=this.safeString(i,"availableBalance"),t[r]=a}return this.safeBalance(t)}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i=this.defaultNetworkCodeForCurrency(e),r=this.safeString(t,"network",i);t=this.omit(t,"network");const a={token:r+"_"+s.code},o=await this.v1PrivateGetAssetDeposit(this.extend(a,t)),n=this.safeString(o,"extra"),d=this.safeString(o,"address");return this.checkAddress(d),{currency:e,address:d,tag:n,network:r,info:o}}async getAssetHistoryRows(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.balance_token=a.id),void 0!==t&&(r.start_t=t),void 0!==s&&(r.pageSize=s);const o=this.safeString(i,"type");i=this.omit(i,"type"),void 0!==o&&(r.type=o);const n=await this.v1PrivateGetAssetHistory(this.extend(r,i));return[a,this.safeList(n,"rows",[])]}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const[r,a]=await this.getAssetHistoryRows(e,t,s,i);return this.parseLedger(a,r,t,s,i)}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"token"),i=this.getCurrencyFromChaincode(s,t).code,r=this.safeNumber(e,"amount"),a="DEPOSIT"===this.safeString(e,"token_side")?"in":"out",o=this.safeTimestamp(e,"created_time"),n=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");return{id:this.safeString(e,"id"),currency:i,account:this.safeString(e,"account"),referenceAccount:void 0,referenceId:this.safeString(e,"tx_id"),status:this.parseTransactionStatus(this.safeString(e,"status")),amount:r,before:void 0,after:void 0,fee:n,direction:a,timestamp:o,datetime:this.iso8601(o),type:this.parseLedgerEntryType(this.safeString(e,"type")),info:e}}parseLedgerEntryType(e){return this.safeString({BALANCE:"transaction",COLLATERAL:"transfer"},e,e)}getCurrencyFromChaincode(e,t){if(void 0!==t)return t;{const s=e.split("_"),i=s.length,r=this.safeString(s,0);let a=this.safeString(s,1,r);i>2&&(a+="_"+this.safeString(s,2)),t=this.safeCurrency(a)}return t}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({token_side:"DEPOSIT"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({token_side:"WITHDRAW"},i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend({type:"BALANCE"},i));return this.parseTransactions(a,r,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"token"),i=this.getCurrencyFromChaincode(s,t).code;let r=this.safeStringLower(e,"token_side");"withdraw"===r&&(r="withdrawal");const a=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount"),o=this.safeString(e,"target_address"),n=this.safeString(e,"source_address"),d=this.safeTimestamp(e,"created_time");return{info:e,id:this.safeString2(e,"id","withdraw_id"),txid:this.safeString(e,"tx_id"),timestamp:d,datetime:this.iso8601(d),address:void 0,addressFrom:n,addressTo:o,tag:this.safeString(e,"extra"),tagFrom:void 0,tagTo:void 0,type:r,amount:this.safeNumber(e,"amount"),currency:i,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.safeTimestamp(e,"updated_time"),comment:void 0,internal:void 0,fee:a,network:void 0}}parseTransactionStatus(e){return this.safeString({NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"},e,e)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={token:a.id,amount:this.parseToNumeric(t),from_application_id:s,to_application_id:i},n=await this.v1PrivatePostAssetMainSubTransfer(this.extend(o,r)),d=this.parseTransfer(n,a),h=this.safeDict(this.options,"transfer",{});return this.safeBool(h,"fillResponseFromRequest",!0)&&(d.amount=t,d.fromAccount=s,d.toAccount=i),d}async fetchTransfers(e=void 0,t=void 0,s=void 0,i={}){const r={};void 0!==s&&(r.size=s),void 0!==t&&(r.start_t=t);const a=this.safeInteger(i,"until");i=this.omit(i,["until"]),void 0!==a&&(r.end_t=a);const o=await this.v1PrivateGetAssetMainSubTransferHistory(this.extend(r,i)),n=this.safeList(o,"rows",[]);return this.parseTransfers(n,void 0,t,s,i)}parseTransfer(e,t=void 0){const s=this.safeString(e,"token"),i=this.getCurrencyFromChaincode(s,t).code,r=this.safeTimestamp(e,"created_time"),a=this.safeBool(e,"success");let o;return void 0!==a&&(o=a?"ok":"failed"),{id:this.safeString(e,"id"),timestamp:r,datetime:this.iso8601(r),currency:i,amount:this.safeNumber(e,"amount"),fromAccount:this.safeString(e,"from_application_id"),toAccount:this.safeString(e,"to_application_id"),status:this.parseTransferStatus(this.safeString(e,"status",o)),info:e}}parseTransferStatus(e){return this.safeString({NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"},e,e)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),await this.loadMarkets(),this.checkAddress(s);const o=this.currency(e),n={amount:t,address:s};void 0!==i&&(n.extra=i);const d=this.safeDict(this.options,"networks",{}),h=this.safeDict(o,"networks",{}),c=this.safeStringUpper(a,"network"),l=this.safeString(d,c,c),u=this.safeDict(h,l,{}),p=this.safeString(u,"id");if(void 0===p)throw new r.BadRequest(this.id+" withdraw() require network parameter");n.token=p;const f=await this.v1PrivatePostAssetWithdraw(this.extend(n,a));return this.parseTransaction(f,o)}async repayMargin(e,t,s=void 0,i={}){let r;await this.loadMarkets(),void 0!==s&&(r=this.market(s),s=r.symbol);const a=this.currency(e),o={token:a.id,amount:this.currencyToPrecision(e,t)},n=await this.v1PrivatePostInterestRepay(this.extend(o,i)),d=this.parseMarginLoan(n,a);return this.extend(d,{amount:t,symbol:s})}parseMarginLoan(e,t=void 0){return{id:void 0,currency:this.safeCurrencyCode(void 0,t),amount:void 0,symbol:void 0,timestamp:void 0,datetime:void 0,info:e}}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=t[0],d=t[1],h=this.implodeParams(e,i);let c=this.implodeHostname(this.urls.api[d]);if(c+="/"+o+"/",i=this.omit(i,this.extractParams(e)),i=this.keysort(i),"public"===d)c+=d+"/"+h,Object.keys(i).length&&(c+="?"+this.urlencode(i));else if("pub"===d)c+=h,Object.keys(i).length&&(c+="?"+this.urlencode(i));else{if(this.checkRequiredCredentials(),"POST"===s&&("algo/order"===e||"order"===e)){if(!this.safeBool(this.options,"sandboxMode",!1)){const t="bc830de7-50f3-460b-9ee0-f430f83f9dad",s=this.safeString(this.options,"brokerId",t);e.indexOf("algo")>-1?i.brokerId=s:i.broker_id=s}i=this.keysort(i)}let t="";const d=this.nonce().toString();if(c+=h,r={"x-api-key":this.apiKey,"x-api-timestamp":d},"v3"===o){if(t=d+s+"/"+o+"/"+h,"POST"===s||"PUT"===s||"DELETE"===s)t+=a=this.json(i);else if(Object.keys(i).length){const e=this.urlencode(i);c+="?"+e,t+="?"+e}r["content-type"]="application/json"}else t=this.urlencode(i),"POST"===s||"PUT"===s||"DELETE"===s?a=t:Object.keys(i).length&&(c+="?"+t),t+="|"+d,r["content-type"]="application/x-www-form-urlencoded";r["x-api-signature"]=this.hmac(this.encode(t),this.encode(this.secret),n.s)}return{url:c,method:s,body:a,headers:r}}handleErrors(e,t,s,i,r,a,o,n,d){if(!o)return;const h=this.safeBool(o,"success"),c=this.safeString(o,"code");if(!h){const e=this.id+" "+this.json(o);this.throwBroadlyMatchedException(this.exceptions.broad,a,e),this.throwExactlyMatchedException(this.exceptions.exact,c,e)}}parseIncome(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t);let r=this.safeString(e,"funding_fee");const o=this.safeCurrencyCode("USD"),n=this.safeString(e,"id"),d=this.safeTimestamp(e,"updated_time"),h=this.safeNumber(e,"funding_rate");return r="Pay"===this.safeString(e,"payment_type")?a.Y.stringNeg(r):r,{info:e,symbol:i,code:o,timestamp:d,datetime:this.iso8601(d),id:n,amount:this.parseNumber(r),rate:h}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingHistory","paginate"),r)return await this.fetchPaginatedCallCursor("fetchFundingHistory",e,t,s,i,"page","page",1,500);const a={};let o;void 0!==e&&(o=this.market(e),a.symbol=o.id),void 0!==t&&(a.start_t=t),a.size=void 0!==s?s:5e3;const n=await this.v1PrivateGetFundingFeeHistory(this.extend(a,i)),d=this.safeDict(n,"meta",{}),h=this.safeInteger(d,"current_page"),c=this.safeList(n,"rows",[]),l=c.length;if(l>0){const e=c[l-1];e.page=h,c[l-1]=e}return this.parseIncomes(c,o,t,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.market(s);const i=this.safeInteger(e,"next_funding_time"),r=this.safeInteger(e,"est_funding_rate_timestamp"),a=this.safeInteger(e,"last_funding_rate_timestamp");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:r,datetime:this.iso8601(r),fundingRate:this.safeNumber(e,"est_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"last_funding_rate"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.v1PublicGetFundingRateSymbol(this.extend(i,t));return this.parseFundingRate(r,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetFundingRates(t),i=this.safeList(s,"rows",[]),r=this.parseFundingRates(i);return this.filterByArray(r,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory",e,t,s,i,"page",25);let a={};if(void 0!==e){const t=this.market(e);e=t.symbol,a.symbol=t.id}void 0!==t&&(a.start_t=this.parseToInt(t/1e3)),[a,i]=this.handleUntilOption("end_t",a,i,.001);const o=await this.v1PublicGetFundingRateHistory(this.extend(a,i)),n=this.safeList(o,"rows"),d=[];for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"symbol"),i=this.safeInteger(t,"funding_rate_timestamp");d.push({info:t,symbol:this.safeSymbol(s),fundingRate:this.safeNumber(t,"funding_rate"),timestamp:i,datetime:this.iso8601(i)})}const h=this.sortBy(d,"timestamp");return this.filterBySymbolSinceLimit(h,e,t,s)}async setPositionMode(e,t=void 0,s={}){let i;i=e?"HEDGE_MODE":"ONE_WAY";const r={position_mode:i};return await this.v1PrivatePostClientPositionMode(this.extend(r,s))}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e);let i;if(s.spot)i=await this.v3PrivateGetAccountinfo(t);else{if(!s.swap)throw new r.NotSupported(this.id+" fetchLeverage() is not supported for "+s.type+" markets");{const e={symbol:s.id};let r;[r,t]=this.handleMarginModeAndParams("fetchLeverage",t,"cross"),e.margin_mode=this.encodeMarginMode(r),i=await this.v1PrivateGetClientFuturesLeverage(this.extend(e,t))}}const a=this.safeDict(i,"data",{});return this.parseLeverage(a,s)}parseLeverage(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);const i=this.safeStringLower(e,"default_margin_mode"),r=this.safeInteger(e,"leverage");let a=r,o=r;const n=this.safeList(e,"details",[]);for(let e=0;e<n.length;e++){const t=this.safeDict(n,e,{}),s=this.safeInteger(t,"leverage"),i=this.safeString(t,"position_side");"BOTH"===i?(a=s,o=s):"LONG"===i?a=s:"SHORT"===i&&(o=s)}return{info:e,symbol:t.symbol,marginMode:i,longLeverage:a,shortLeverage:o}}async setLeverage(e,t=void 0,s={}){await this.loadMarkets();const i={leverage:e};let a;if(void 0!==t&&(a=this.market(t)),void 0===t||a.spot)return await this.v1PrivatePostClientLeverage(this.extend(i,s));if(a.swap){let e;return i.symbol=a.id,[e,s]=this.handleMarginModeAndParams("fetchLeverage",s,"cross"),i.margin_mode=this.encodeMarginMode(e),await this.v1PrivatePostClientFuturesLeverage(this.extend(i,s))}throw new r.NotSupported(this.id+" fetchLeverage() is not supported for "+a.type+" markets")}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"REDUCE",s)}async modifyMarginHelper(e,t,s,i={}){await this.loadMarkets();const r={symbol:this.market(e).id,adjust_token:"USDT",adjust_amount:t,action:s};return await this.v1PrivatePostClientIsolatedMargin(this.extend(r,i))}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.v1PrivateGetPositionSymbol(this.extend(i,t));return this.parsePosition(r,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.v3PrivateGetPositions(t),i=this.safeDict(s,"data",{}),r=this.safeList(i,"positions",[]);return this.parsePositions(r,e)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,r=this.safeString(e,"holding");i=a.Y.stringGt(r,"0")?"long":"short";const o=this.safeString(t,"contractSize"),n=this.safeString2(e,"markPrice","mark_price"),d=this.safeTimestamp(e,"timestamp"),h=this.safeString2(e,"averageOpenPrice","average_open_price"),c=a.Y.stringSub(n,h),l=a.Y.stringMul(c,r);r=a.Y.stringAbs(r);const u=a.Y.stringMul(r,n),p=this.safeString(e,"positionSide");return this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:d,datetime:this.iso8601(d),lastUpdateTimestamp:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(h),notional:this.parseNumber(u),leverage:this.safeNumber(e,"leverage"),unrealizedPnl:this.parseNumber(l),contracts:this.parseNumber(r),contractSize:this.parseNumber(o),marginRatio:void 0,liquidationPrice:this.safeNumber2(e,"estLiqPrice","est_liq_price"),markPrice:this.parseNumber(n),lastPrice:void 0,collateral:void 0,marginMode:this.safeStringLower2(e,"marginMode","margin_mode"),side:i,percentage:void 0,hedged:"BOTH"!==p,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchConvertQuote(e,t,s=void 0,i={}){await this.loadMarkets();const r={sellToken:e.toUpperCase(),buyToken:t.toUpperCase(),sellQuantity:this.numberToString(s)},a=await this.v3PrivateGetConvertRfq(this.extend(r,i)),o=this.safeDict(a,"data",{}),n=this.safeString(o,"sellToken",e),d=this.currency(n),h=this.safeString(o,"buyToken",t),c=this.currency(h);return this.parseConversion(o,d,c)}async createConvertTrade(e,t,s,i=void 0,r={}){await this.loadMarkets();const a={quoteId:e},o=await this.v3PrivatePostConvertRft(this.extend(a,r)),n=this.safeDict(o,"data",{});return this.parseConversion(n)}async fetchConvertTrade(e,t=void 0,s={}){await this.loadMarkets();const i={quoteId:e},r=await this.v3PrivateGetConvertTrade(this.extend(i,s)),a=this.safeDict(r,"data",{}),o=this.safeString(a,"sellAsset"),n=this.safeString(a,"buyAsset");let d,h;return void 0!==o&&(d=this.currency(o)),void 0!==n&&(h=this.currency(n)),this.parseConversion(a,d,h)}async fetchConvertTradeHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r={};[r,i]=this.handleUntilOption("endTime",r,i),void 0!==t&&(r.startTime=t),void 0!==s&&(r.size=s);const a=await this.v3PrivateGetConvertTrades(this.extend(r,i)),o=this.safeDict(a,"data",{}),n=this.safeList(o,"tradeVos",[]);return this.parseConversions(n,e,"sellAsset","buyAsset",t,s)}parseConversion(e,t=void 0,s=void 0){const i=this.safeInteger2(e,"expireTimestamp","createdTime"),r=this.safeString2(e,"sellToken","buyAsset"),a=this.safeCurrencyCode(r,t),o=this.safeString2(e,"buyToken","sellAsset"),n=this.safeCurrencyCode(o,s);return{info:e,timestamp:i,datetime:this.iso8601(i),id:this.safeString(e,"quoteId"),fromCurrency:a,fromAmount:this.safeNumber2(e,"sellQuantity","sellAmount"),toCurrency:n,toAmount:this.safeNumber2(e,"buyQuantity","buyAmount"),price:this.safeNumber(e,"buyPrice"),fee:void 0}}async fetchConvertCurrencies(e={}){await this.loadMarkets();const t=await this.v3PrivateGetConvertAssetInfo(e),s={},i=this.safeList(t,"rows",[]);for(let e=0;e<i.length;e++){const t=i[e],r=this.safeString(t,"token"),a=this.safeCurrencyCode(r);s[a]={info:t,id:r,code:a,networks:void 0,type:void 0,name:void 0,active:void 0,deposit:void 0,withdraw:void 0,fee:void 0,precision:this.safeNumber(t,"tick"),limits:{amount:{min:void 0,max:void 0},withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},created:this.safeTimestamp(t,"createdTime")}}return s}defaultNetworkCodeForCurrency(e){const t=this.currency(e).networks,s=Object.keys(t);for(let e=0;e<s.length;e++){const t=s[e];if("ETH"===t)return t}return this.safeValue(s,0)}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}}},9641:(e,t,s)=>{s.d(t,{A:()=>l});var i=s(5308),r=s(2079),a=s(1579),o=s(5147),n=s(8283),d=s(6414),h=s(8432),c=s(987);class l extends i.A{describe(){return this.deepExtend(super.describe(),{id:"woofipro",name:"WOOFI PRO",countries:["KY"],rateLimit:100,version:"v1",certified:!0,pro:!0,dex:!0,hostname:"dex.woo.org",has:{CORS:void 0,spot:!1,margin:!1,swap:!0,future:!1,option:!1,addMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,cancelWithdraw:!1,closeAllPositions:!1,closePosition:!1,createConvertTrade:!1,createDepositAddress:!1,createMarketBuyOrderWithCost:!1,createMarketOrder:!1,createMarketOrderWithCost:!1,createMarketSellOrderWithCost:!1,createOrder:!0,createOrderWithTakeProfitAndStopLoss:!0,createReduceOnlyOrder:!0,createStopLimitOrder:!1,createStopLossOrder:!0,createStopMarketOrder:!1,createStopOrder:!1,createTakeProfitOrder:!0,createTrailingAmountOrder:!1,createTrailingPercentOrder:!1,createTriggerOrder:!0,fetchAccounts:!1,fetchBalance:!0,fetchCanceledOrders:!1,fetchClosedOrder:!1,fetchClosedOrders:!0,fetchConvertCurrencies:!1,fetchConvertQuote:!1,fetchCurrencies:!0,fetchDepositAddress:!1,fetchDeposits:!0,fetchDepositsWithdrawals:!0,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!0,fetchIndexOHLCV:!1,fetchLedger:!0,fetchLeverage:!0,fetchMarginAdjustmentHistory:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrders:!0,fetchOrderTrades:!0,fetchPosition:!0,fetchPositionMode:!1,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchStatus:!0,fetchTicker:!1,fetchTickers:!1,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:"emulated",fetchTransfers:!1,fetchWithdrawals:!0,reduceMargin:!1,setLeverage:!0,setMargin:!1,setPositionMode:!1,transfer:!1,withdraw:!0},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","4h":"4h","12h":"12h","1d":"1d","1w":"1w","1M":"1mon","1y":"1y"},urls:{logo:"https://github.com/ccxt/ccxt/assets/43336371/b1e7b348-a0fc-4605-8b7f-91176958fd69",api:{public:"https://api-evm.orderly.org",private:"https://api-evm.orderly.org"},test:{public:"https://testnet-api-evm.orderly.org",private:"https://testnet-api-evm.orderly.org"},www:"https://dex.woo.org",doc:["https://orderly.network/docs/build-on-evm/building-on-evm"],fees:["https://dex.woo.org/en/orderly"],referral:{url:"https://dex.woo.org/en/trade?ref=CCXT",discount:.05}},api:{v1:{public:{get:{"public/volume/stats":1,"public/broker/name":1,"public/chain_info/{broker_id}":1,"public/system_info":1,"public/vault_balance":1,"public/insurancefund":1,"public/chain_info":1,"faucet/usdc":1,"public/account":1,get_account:1,registration_nonce:1,get_orderly_key:1,"public/liquidation":1,"public/liquidated_positions":1,"public/config":1,"public/campaign/ranking":10,"public/campaign/stats":10,"public/campaign/user":10,"public/campaign/stats/details":10,"public/campaigns":10,"public/points/leaderboard":1,"client/points":1,"public/points/epoch":1,"public/points/epoch_dates":1,"public/referral/check_ref_code":1,"public/referral/verify_ref_code":1,"referral/admin_info":1,"referral/info":1,"referral/referee_info":1,"referral/referee_rebate_summary":1,"referral/referee_history":1,"referral/referral_history":1,"referral/rebate_summary":1,"client/distribution_history":1,"tv/config":1,"tv/history":1,"tv/symbol_info":1,"public/funding_rate_history":1,"public/funding_rate/{symbol}":.33,"public/funding_rates":1,"public/info":1,"public/info/{symbol}":1,"public/market_trades":1,"public/token":1,"public/futures":1,"public/futures/{symbol}":1},post:{register_account:1}},private:{get:{"client/key_info":6,"client/orderly_key_ip_restriction":6,"order/{oid}":1,"client/order/{client_order_id}":1,"algo/order/{oid}":1,"algo/client/order/{client_order_id}":1,orders:1,"algo/orders":1,"trade/{tid}":1,trades:1,"order/{oid}/trades":1,"client/liquidator_liquidations":1,liquidations:1,"asset/history":60,"client/holding":1,withdraw_nonce:1,settle_nonce:1,"pnl_settlement/history":1,"volume/user/daily":60,"volume/user/stats":60,"client/statistics":60,"client/info":60,"client/statistics/daily":60,positions:3.33,"position/{symbol}":3.33,"funding_fee/history":30,"notification/inbox/notifications":60,"notification/inbox/unread":60,"volume/broker/daily":60,"broker/fee_rate/default":10,"broker/user_info":10,"orderbook/{symbol}":1,kline:1},post:{orderly_key:1,"client/set_orderly_key_ip_restriction":6,"client/reset_orderly_key_ip_restriction":6,order:1,"batch-order":10,"algo/order":1,liquidation:1,claim_insurance_fund:1,withdraw_request:1,settle_pnl:1,"notification/inbox/mark_read":60,"notification/inbox/mark_read_all":60,"client/leverage":120,"client/maintenance_config":60,delegate_signer:10,delegate_orderly_key:10,delegate_settle_pnl:10,delegate_withdraw_request:10,"broker/fee_rate/set":10,"broker/fee_rate/set_default":10,"broker/fee_rate/default":10,"referral/create":10,"referral/update":10,"referral/bind":10,"referral/edit_split":10},put:{order:1,"algo/order":1},delete:{order:1,"algo/order":1,"client/order":1,"algo/client/order":1,"algo/orders":1,orders:1,"batch-order":1,"client/batch-order":1}}}},requiredCredentials:{apiKey:!0,secret:!0,accountId:!0,privateKey:!1},fees:{trading:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0002"),taker:this.parseNumber("0.0005")}},options:{sandboxMode:!1,brokerId:"CCXT",verifyingContractAddress:"0x6F7a338F2aA472838dEFD3283eB360d4Dff5D203"},commonCurrencies:{},exceptions:{exact:{"-1000":r.ExchangeError,"-1001":r.AuthenticationError,"-1002":r.AuthenticationError,"-1003":r.RateLimitExceeded,"-1004":r.BadRequest,"-1005":r.BadRequest,"-1006":r.InvalidOrder,"-1007":r.BadRequest,"-1008":r.InvalidOrder,"-1009":r.InsufficientFunds,"-1011":r.NetworkError,"-1012":r.BadRequest,"-1101":r.InsufficientFunds,"-1102":r.InvalidOrder,"-1103":r.InvalidOrder,"-1104":r.InvalidOrder,"-1105":r.InvalidOrder,"-1201":r.BadRequest,"-1202":r.BadRequest,29:r.BadRequest,9:r.AuthenticationError,3:r.AuthenticationError,2:r.BadRequest,15:r.BadRequest},broad:{}},precisionMode:a.kb})}setSandboxMode(e){super.setSandboxMode(e),this.options.sandboxMode=e}async fetchStatus(e={}){const t=await this.v1PublicGetPublicSystemInfo(e),s=this.safeDict(t,"data",{});let i=this.safeString(s,"status");return i=void 0===i?"error":"0"===i?"ok":"maintenance",{status:i,updated:void 0,eta:void 0,url:void 0,info:t}}async fetchTime(e={}){const t=await this.v1PublicGetPublicSystemInfo(e);return this.safeInteger(t,"timestamp")}parseMarket(e){const t=this.safeString(e,"symbol"),s=t.split("_"),i=this.safeString(s,1),r=this.safeString(s,2),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r),n=this.safeString(s,2),d=this.safeCurrencyCode(n);return{id:t,symbol:a+"/"+o+":"+d,base:a,quote:o,settle:d,baseId:i,quoteId:r,settleId:n,type:"swap",spot:!1,margin:!1,swap:!0,future:!1,option:!1,active:void 0,contract:!0,linear:!0,inverse:void 0,contractSize:this.parseNumber("1"),expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"base_tick"),price:this.safeNumber(e,"quote_tick")},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"base_min"),max:this.safeNumber(e,"base_max")},price:{min:this.safeNumber(e,"quote_min"),max:this.safeNumber(e,"quote_max")},cost:{min:this.safeNumber(e,"min_notional"),max:void 0}},created:this.safeInteger(e,"created_time"),info:e}}async fetchMarkets(e={}){const t=await this.v1PublicGetPublicInfo(e),s=this.safeDict(t,"data",{}),i=this.safeList(s,"rows",[]);return this.parseMarkets(i)}async fetchCurrencies(e={}){const t={},s=await this.v1PublicGetPublicToken(e),i=this.safeDict(s,"data",{}),r=this.safeList(i,"rows",[]);for(let e=0;e<r.length;e++){const s=r[e],i=this.safeString(s,"token"),a=this.safeList(s,"chain_details"),n=this.safeCurrencyCode(i);let d;const h={};for(let e=0;e<a.length;e++){const t=a[e],s=this.safeString(t,"chain_id"),i=this.parsePrecision(this.safeString(t,"decimals"));void 0!==i&&(d=void 0===d?i:o.Y.stringMin(i,d)),h[s]={id:s,network:s,limits:{withdraw:{min:void 0,max:void 0},deposit:{min:void 0,max:void 0}},active:void 0,deposit:void 0,withdraw:void 0,fee:this.safeNumber(t,"withdrawal_fee"),precision:this.parseNumber(i),info:t}}t[n]={id:i,name:i,code:n,precision:this.parseNumber(d),active:void 0,fee:void 0,networks:h,deposit:void 0,withdraw:void 0,limits:{deposit:{min:void 0,max:void 0},withdraw:{min:this.safeNumber(s,"minimum_withdraw_amount"),max:void 0}},info:s}}return t}parseTokenAndFeeTemp(e,t,s){const i=this.safeString(e,s);let r;if(void 0!==i){const s=this.safeString(e,t);r={cost:i,currency:this.safeCurrencyCode(s)}}return r}parseTrade(e,t=void 0){const s="id"in e,i=this.safeInteger(e,"executed_timestamp"),r=this.safeString(e,"symbol"),a=(t=this.safeMarket(r,t)).symbol,n=this.safeString(e,"executed_price"),d=this.safeString(e,"executed_quantity"),h=this.safeString(e,"order_id"),c=this.parseTokenAndFeeTemp(e,"fee_asset","fee"),l=this.safeString(c,"cost");void 0!==l&&(c.cost=l);const u=o.Y.stringMul(n,d),p=this.safeStringLower(e,"side"),f=this.safeString(e,"id");let m;if(s){m="1"===this.safeString(e,"is_maker")?"maker":"taker"}return this.safeTrade({id:f,timestamp:i,datetime:this.iso8601(i),symbol:a,side:p,price:n,amount:d,cost:u,order:h,takerOrMaker:m,type:void 0,fee:c,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};void 0!==s&&(a.limit=s);const o=await this.v1PublicGetPublicMarketTrades(this.extend(a,i)),n=this.safeDict(o,"data",{}),d=this.safeList(n,"rows",[]);return this.parseTrades(d,r,t,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol");t=this.market(s);const i=this.safeInteger(e,"next_funding_time"),r=this.safeInteger(e,"est_funding_rate_timestamp"),a=this.safeInteger(e,"last_funding_rate_timestamp");return{info:e,symbol:t.symbol,markPrice:void 0,indexPrice:void 0,interestRate:this.parseNumber("0"),estimatedSettlePrice:void 0,timestamp:r,datetime:this.iso8601(r),fundingRate:this.safeNumber(e,"est_funding_rate"),fundingTimestamp:i,fundingDatetime:this.iso8601(i),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:this.safeNumber(e,"last_funding_rate"),previousFundingTimestamp:a,previousFundingDatetime:this.iso8601(a)}}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.v1PublicGetPublicFundingRateSymbol(this.extend(i,t)),a=this.safeDict(r,"data",{});return this.parseFundingRate(a,s)}async fetchFundingRates(e=void 0,t={}){await this.loadMarkets(),e=this.marketSymbols(e);const s=await this.v1PublicGetPublicFundingRates(t),i=this.safeDict(s,"data",{}),r=this.safeList(i,"rows",[]),a=this.parseFundingRates(r);return this.filterByArray(a,"symbol",e)}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchFundingRateHistory","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchFundingRateHistory",e,t,s,i,"page",25);let a={};if(void 0!==e){const t=this.market(e);e=t.symbol,a.symbol=t.id}void 0!==t&&(a.start_t=t),[a,i]=this.handleUntilOption("end_t",a,i,.001);const o=await this.v1PublicGetPublicFundingRateHistory(this.extend(a,i)),n=this.safeDict(o,"data",{}),d=this.safeList(n,"rows",[]),h=[];for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"symbol"),i=this.safeInteger(t,"funding_rate_timestamp");h.push({info:t,symbol:this.safeSymbol(s),fundingRate:this.safeNumber(t,"funding_rate"),timestamp:i,datetime:this.iso8601(i)})}const c=this.sortBy(h,"timestamp");return this.filterBySymbolSinceLimit(c,e,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.v1PrivateGetClientInfo(e),s=this.safeDict(t,"data",{}),i=this.safeString(s,"futures_maker_fee_rate"),r=this.safeString(s,"futures_taker_fee_rate"),a={};for(let e=0;e<this.symbols.length;e++){const s=this.symbols[e];a[s]={info:t,symbol:s,maker:this.parseNumber(o.Y.stringDiv(i,"10000")),taker:this.parseNumber(o.Y.stringDiv(r,"10000")),percentage:!0,tierBased:!0}}return a}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i={symbol:this.market(e).id};void 0!==t&&(t=Math.min(t,1e3),i.max_level=t);const r=await this.v1PrivateGetOrderbookSymbol(this.extend(i,s)),a=this.safeDict(r,"data",{}),o=this.safeInteger(a,"timestamp");return this.parseOrderBook(a,e,o,"bids","asks","price","quantity")}parseOHLCV(e,t=void 0){return[this.safeInteger(e,"start_timestamp"),this.safeNumber(e,"open"),this.safeNumber(e,"high"),this.safeNumber(e,"low"),this.safeNumber(e,"close"),this.safeNumber(e,"volume")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,type:this.safeString(this.timeframes,t,t)};void 0!==i&&(o.limit=Math.min(i,1e3));const n=await this.v1PrivateGetKline(this.extend(o,r)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"rows",[]);return this.parseOHLCVs(h,a,t,s,i)}parseOrder(e,t=void 0){const s=this.safeIntegerN(e,["timestamp","created_time","createdTime"]),i=this.safeStringN(e,["order_id","orderId","algoOrderId"]),r=this.omitZero(this.safeString2(e,"client_order_id","clientOrderId")),a=this.safeString(e,"symbol"),n=(t=this.safeMarket(a,t)).symbol,d=this.safeString2(e,"order_price","price"),h=this.safeString2(e,"order_quantity","quantity"),c=this.safeString2(e,"order_amount","amount"),l=this.safeStringLower2(e,"order_type","type");let u=this.safeValue2(e,"status","algoStatus");const p=this.safeBool(e,"success");void 0!==p&&(u=p?"NEW":"REJECTED");const f=this.safeStringLower(e,"side"),m=this.omitZero(this.safeValue2(e,"executed","totalExecutedQuantity")),g=this.omitZero(this.safeString2(e,"average_executed_price","averageExecutedPrice")),v=o.Y.stringSub(c,m),y=this.safeValue2(e,"total_fee","totalFee"),w=this.safeString2(e,"fee_asset","feeAsset"),b=this.safeValue(e,"Transactions"),S=this.safeNumber(e,"triggerPrice");let k,O;const T=this.safeValue(e,"childOrders");if(void 0!==T){const e=this.safeValue(T,0),t=this.safeValue(e,"childOrders",[]);if(t.length>0){const e=this.safeValue(t,0),s=this.safeValue(t,1);k=this.safeNumber(e,"triggerPrice"),O=this.safeNumber(s,"triggerPrice")}}const P=this.safeInteger2(e,"updatedTime","updated_time");return this.safeOrder({id:i,clientOrderId:r,timestamp:s,datetime:this.iso8601(s),lastTradeTimestamp:void 0,lastUpdateTimestamp:P,status:this.parseOrderStatus(u),symbol:n,type:this.parseOrderType(l),timeInForce:this.parseTimeInForce(l),postOnly:void 0,reduceOnly:this.safeBool(e,"reduce_only"),side:f,price:d,stopPrice:S,triggerPrice:S,takeProfitPrice:k,stopLossPrice:O,average:g,amount:h,filled:m,remaining:v,cost:c,trades:b,fee:{cost:y,currency:w},info:e},t)}parseTimeInForce(e){return this.safeString({ioc:"IOC",fok:"FOK",post_only:"PO"},e,void 0)}parseOrderStatus(e){if(void 0!==e){const t={NEW:"open",FILLED:"closed",CANCEL_SENT:"canceled",CANCEL_ALL_SENT:"canceled",CANCELLED:"canceled",PARTIAL_FILLED:"open",REJECTED:"rejected",INCOMPLETE:"open",COMPLETED:"closed"};return this.safeString(t,e,e)}return e}parseOrderType(e){return this.safeStringLower({LIMIT:"limit",MARKET:"market",POST_ONLY:"limit"},e,e)}createOrderRequest(e,t,s,i,r=void 0,a={}){const o=this.safeBool2(a,"reduceOnly","reduce_only"),n=t.toUpperCase(),d=this.market(e),h=s.toUpperCase(),c={symbol:d.id,side:h},l=this.safeString2(a,"triggerPrice","stopPrice"),u=this.safeValue(a,"stopLoss"),p=this.safeValue(a,"takeProfit"),f=this.safeString(a,"algoType"),m=void 0!==l||void 0!==u||void 0!==p||void 0!==this.safeValue(a,"childOrders"),g="MARKET"===n,v=this.safeStringLower(a,"timeInForce"),y=this.isPostOnly(g,void 0,a),w=m?"quantity":"order_quantity",b=m?"price":"order_price";c[m?"type":"order_type"]=n,m||(y?c.order_type="POST_ONLY":"fok"===v?c.order_type="FOK":"ioc"===v&&(c.order_type="IOC")),o&&(c.reduce_only=o),void 0!==r&&(c[b]=this.priceToPrecision(e,r)),(g&&!m||"POSITIONAL_TP_SL"!==f)&&(c[w]=this.amountToPrecision(e,i));const S=this.safeStringN(a,["clOrdID","clientOrderId","client_order_id"]);if(void 0!==S&&(c.client_order_id=S),void 0!==l)c.trigger_price=this.priceToPrecision(e,l),c.algo_type="STOP";else if(void 0!==u||void 0!==p){c.algo_type="TP_SL";const t={symbol:d.id,reduce_only:!1,algo_type:"POSITIONAL_TP_SL",child_orders:[]},s="BUY"===h?"SELL":"BUY";if(void 0!==u){const i=this.safeNumber2(u,"triggerPrice","price",u),r={side:s,algo_type:"TP_SL",trigger_price:this.priceToPrecision(e,i),type:"LIMIT",reduce_only:!0};t.child_orders.push(r)}if(void 0!==p){const i=this.safeNumber2(p,"triggerPrice","price",p),r={side:s,algo_type:"TP_SL",trigger_price:this.priceToPrecision(e,i),type:"LIMIT",reduce_only:!0};t.child_orders.push(r)}c.child_orders=[t]}return a=this.omit(a,["reduceOnly","reduce_only","clOrdID","clientOrderId","client_order_id","postOnly","timeInForce","stopPrice","triggerPrice","stopLoss","takeProfit"]),this.extend(c,a)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n=this.createOrderRequest(e,t,s,i,r,a),d=this.safeString2(a,"triggerPrice","stopPrice"),h=this.safeValue(a,"stopLoss"),c=this.safeValue(a,"takeProfit");let l;l=void 0!==d||void 0!==h||void 0!==c||void 0!==this.safeValue(a,"childOrders")?await this.v1PrivatePostAlgoOrder(n):await this.v1PrivatePostOrder(n);const u=this.safeDict(l,"data");u.timestamp=this.safeInteger(l,"timestamp");const p=this.parseOrder(u,o);return p.type=t,p}async createOrders(e,t={}){await this.loadMarkets();const s=[];for(let t=0;t<e.length;t++){const i=e[t],a=this.safeString(i,"symbol"),o=this.safeString(i,"type"),n=this.safeString(i,"side"),d=this.safeValue(i,"amount"),h=this.safeValue(i,"price"),c=this.safeDict(i,"params",{}),l=this.safeString2(c,"triggerPrice","stopPrice"),u=this.safeValue(c,"stopLoss"),p=this.safeValue(c,"takeProfit");if(void 0!==l||void 0!==u||void 0!==p||void 0!==this.safeValue(c,"childOrders"))throw new r.NotSupported(this.id+"createOrders() only support non-stop order");const f=this.createOrderRequest(a,o,n,d,h,c);s.push(f)}const i={orders:s},a=await this.v1PrivatePostBatchOrder(this.extend(i,t)),o=this.safeDict(a,"data",{}),n=this.safeList(o,"rows",[]);return this.parseOrders(n)}async editOrder(e,t,s,i,r=void 0,a=void 0,o={}){await this.loadMarkets();const n=this.market(t),d={order_id:e},h=this.safeStringN(o,["triggerPrice","stopPrice","takeProfitPrice","stopLossPrice"]);void 0!==h&&(d.triggerPrice=this.priceToPrecision(t,h));const c=void 0!==h||void 0!==this.safeValue(o,"childOrders"),l=c?"quantity":"order_quantity";let u;if(void 0!==a&&(d[c?"price":"order_price"]=this.priceToPrecision(t,a)),void 0!==r&&(d[l]=this.amountToPrecision(t,r)),o=this.omit(o,["stopPrice","triggerPrice","takeProfitPrice","stopLossPrice","trailingTriggerPrice","trailingAmount","trailingPercent"]),c)u=await this.v1PrivatePutAlgoOrder(this.extend(d,o));else{d.symbol=n.id,d.side=i.toUpperCase();const e=s.toUpperCase(),t=this.safeStringLower(o,"timeInForce"),r="MARKET"===e,a=this.isPostOnly(r,void 0,o);d.order_type=a?"POST_ONLY":"fok"===t?"FOK":"ioc"===t?"IOC":e;const h=this.safeStringN(o,["clOrdID","clientOrderId","client_order_id"]);o=this.omit(o,["clOrdID","clientOrderId","client_order_id","postOnly","timeInForce"]),void 0!==h&&(d.client_order_id=h),u=await this.v1PrivatePutOrder(this.extend(d,o))}const p=this.safeDict(u,"data",{});return p.timestamp=this.safeInteger(u,"timestamp"),this.parseOrder(p,n)}async cancelOrder(e,t=void 0,s={}){const i=this.safeBool2(s,"stop","trigger",!1);if(s=this.omit(s,["stop","trigger"]),!i&&void 0===t)throw new r.ArgumentsRequired(this.id+" cancelOrder() requires a symbol argument");let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={symbol:a.id},n=this.safeString2(s,"clOrdID","clientOrderId"),d=this.safeString(s,"client_order_id",n),h=void 0!==d;let c;i?h?(o.client_order_id=d,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"]),c=await this.v1PrivateDeleteAlgoClientOrder(this.extend(o,s))):(o.order_id=e,c=await this.v1PrivateDeleteAlgoOrder(this.extend(o,s))):h?(o.client_order_id=d,s=this.omit(s,["clOrdID","clientOrderId","client_order_id"]),c=await this.v1PrivateDeleteClientOrder(this.extend(o,s))):(o.order_id=e,c=await this.v1PrivateDeleteOrder(this.extend(o,s)));const l={symbol:t};if(h?l.client_order_id=d:l.id=e,i)return this.extend(this.parseOrder(c),l);const u=this.safeDict(c,"data",{});return this.extend(this.parseOrder(u),l)}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i=this.safeListN(s,["clOrdIDs","clientOrderIds","client_order_ids"]);s=this.omit(s,["clOrdIDs","clientOrderIds","client_order_ids"]);const r={};let a;return i?(r.client_order_ids=i.join(","),a=await this.v1PrivateDeleteClientBatchOrder(this.extend(r,s))):(r.order_ids=e.join(","),a=await this.v1PrivateDeleteBatchOrder(this.extend(r,s))),[this.safeOrder({info:a})]}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s=this.safeBool2(t,"stop","trigger");t=this.omit(t,["stop","trigger"]);const i={};if(void 0!==e){const t=this.market(e);i.symbol=t.id}let r;return r=s?await this.v1PrivateDeleteAlgoOrders(this.extend(i,t)):await this.v1PrivateDeleteOrders(this.extend(i,t)),[{info:r}]}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i=void 0!==t?this.market(t):void 0,r=this.safeBool2(s,"stop","trigger",!1),a={},o=this.safeStringN(s,["clOrdID","clientOrderId","client_order_id"]);let n;s=this.omit(s,["stop","trigger","clOrdID","clientOrderId","client_order_id"]),r?o?(a.client_order_id=o,n=await this.v1PrivateGetAlgoClientOrderClientOrderId(this.extend(a,s))):(a.oid=e,n=await this.v1PrivateGetAlgoOrderOid(this.extend(a,s))):o?(a.client_order_id=o,n=await this.v1PrivateGetClientOrderClientOrderId(this.extend(a,s))):(a.oid=e,n=await this.v1PrivateGetOrderOid(this.extend(a,s)));const d=this.safeDict(n,"data",n);return this.parseOrder(d,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;const a=this.safeBool2(i,"stop","trigger",!1),o=a?100:500;if([r,i]=this.handleOptionAndParams(i,"fetchOrders","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchOrders",e,t,s,i,"page",o);let n,d,h={};i=this.omit(i,["stop","trigger"]),void 0!==e&&(n=this.market(e),h.symbol=n.id),void 0!==t&&(h.start_t=t),h.size=void 0!==s?s:o,a&&(h.algo_type="STOP"),[h,i]=this.handleUntilOption("end_t",h,i),d=a?await this.v1PrivateGetAlgoOrders(this.extend(h,i)):await this.v1PrivateGetOrders(this.extend(h,i));const c=this.safeValue(d,"data",d),l=this.safeList(c,"rows");return this.parseOrders(l,n,t,s)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.extend(i,{status:"INCOMPLETE"});return await this.fetchOrders(e,t,s,r)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.extend(i,{status:"COMPLETED"});return await this.fetchOrders(e,t,s,r)}async fetchOrderTrades(e,t=void 0,s=void 0,i=void 0,r={}){let a;await this.loadMarkets(),void 0!==t&&(a=this.market(t));const o={oid:e},n=await this.v1PrivateGetOrderOidTrades(this.extend(o,r)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"rows",[]);return this.parseTrades(h,a,s,i,r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();let r=!1;if([r,i]=this.handleOptionAndParams(i,"fetchMyTrades","paginate"),r)return await this.fetchPaginatedCallIncremental("fetchMyTrades",e,t,s,i,"page",500);let a,o={};void 0!==e&&(a=this.market(e),o.symbol=a.id),void 0!==t&&(o.start_t=t),o.size=void 0!==s?s:500,[o,i]=this.handleUntilOption("end_t",o,i);const n=await this.v1PrivateGetTrades(this.extend(o,i)),d=this.safeDict(n,"data",{}),h=this.safeList(d,"rows",[]);return this.parseTrades(h,a,t,s,i)}parseBalance(e){const t={info:e},s=this.safeList(e,"holding",[]);for(let e=0;e<s.length;e++){const i=s[e],r=this.safeCurrencyCode(this.safeString(i,"token")),a=this.account();a.total=this.safeString(i,"holding"),a.frozen=this.safeString(i,"frozen"),t[r]=a}return this.safeBalance(t)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1PrivateGetClientHolding(e),s=this.safeDict(t,"data");return this.parseBalance(s)}async getAssetHistoryRows(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.balance_token=a.id),void 0!==t&&(r.start_t=t),void 0!==s&&(r.pageSize=s);const o=this.safeString(i,"type");i=this.omit(i,"type"),void 0!==o&&(r.type=o);const n=await this.v1PrivateGetAssetHistory(this.extend(r,i)),d=this.safeDict(n,"data",{});return[a,this.safeList(d,"rows",[])]}parseLedgerEntry(e,t=void 0){const s=this.safeString(e,"token"),i=this.safeNumber(e,"amount"),r="DEPOSIT"===this.safeString(e,"token_side")?"in":"out",a=this.safeInteger(e,"created_time"),o=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount");return{id:this.safeString(e,"id"),currency:s,account:this.safeString(e,"account"),referenceAccount:void 0,referenceId:this.safeString(e,"tx_id"),status:this.parseTransactionStatus(this.safeString(e,"status")),amount:i,before:void 0,after:void 0,fee:o,direction:r,timestamp:a,datetime:this.iso8601(a),type:this.parseLedgerEntryType(this.safeString(e,"type")),info:e}}parseLedgerEntryType(e){return this.safeString({BALANCE:"transaction",COLLATERAL:"transfer"},e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const[r,a]=await this.getAssetHistoryRows(e,t,s,i);return this.parseLedger(a,r,t,s,i)}parseTransaction(e,t=void 0){const s=this.safeString(e,"token");let i=this.safeStringLower(e,"token_side");"withdraw"===i&&(i="withdrawal");const r=this.parseTokenAndFeeTemp(e,"fee_token","fee_amount"),a=this.safeString(e,"target_address"),o=this.safeString(e,"source_address"),n=this.safeInteger(e,"created_time");return{info:e,id:this.safeString2(e,"id","withdraw_id"),txid:this.safeString(e,"tx_id"),timestamp:n,datetime:this.iso8601(n),address:void 0,addressFrom:o,addressTo:a,tag:this.safeString(e,"extra"),tagFrom:void 0,tagTo:void 0,type:i,amount:this.safeNumber(e,"amount"),currency:s,status:this.parseTransactionStatus(this.safeString(e,"status")),updated:this.safeInteger(e,"updated_time"),comment:void 0,internal:void 0,fee:r,network:void 0}}parseTransactionStatus(e){return this.safeString({NEW:"pending",CONFIRMING:"pending",PROCESSING:"pending",COMPLETED:"ok",CANCELED:"canceled"},e,e)}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({side:"DEPOSIT"},i))}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchDepositsWithdrawals(e,t,s,this.extend({side:"WITHDRAW"},i))}async fetchDepositsWithdrawals(e=void 0,t=void 0,s=void 0,i={}){const[r,a]=await this.getAssetHistoryRows(e,t,s,this.extend({},i));return this.parseTransactions(a,r,t,s,i)}async getWithdrawNonce(e={}){const t=await this.v1PrivateGetWithdrawNonce(e),s=this.safeDict(t,"data",{});return this.safeNumber(s,"withdraw_nonce")}hashMessage(e){return"0x"+this.hash(e,h.lY,"hex")}signHash(e,t){const s=(0,n.h1)(e.slice(-64),t.slice(-64),c.bI,void 0),i=s.r,r=s.s,a=this.intToBase16(this.sum(27,s.v));return"0x"+i.padStart(64,"0")+r.padStart(64,"0")+a}signMessage(e,t){return this.signHash(this.hashMessage(e),t.slice(-64))}async withdraw(e,t,s,i=void 0,a={}){if(await this.loadMarkets(),this.checkAddress(s),void 0!==e&&"USDC"!==(e=e.toUpperCase()))throw new r.NotSupported(this.id+"withdraw() only support USDC");const o=this.currency(e),n=this.safeString(this.options,"verifyingContractAddress"),d=this.safeString(a,"chainId"),h=this.safeDict(o,"networks",{}),c=this.safeDict(h,d,{});if(void 0===this.safeNumber(c,"id"))throw new r.BadRequest(this.id+" withdraw() require chainId parameter");const l=await this.getWithdrawNonce(a),u=this.nonce(),p={chainId:d,name:"Orderly",verifyingContract:n,version:"1"},f={brokerId:this.safeString(this.options,"keyBrokerId","woofi_pro"),chainId:this.parseToInt(d),receiver:s,token:e,amount:t.toString(),withdrawNonce:l,timestamp:u},m=this.ethEncodeStructuredData(p,{Withdraw:[{name:"brokerId",type:"string"},{name:"chainId",type:"uint256"},{name:"receiver",type:"address"},{name:"token",type:"string"},{name:"amount",type:"uint256"},{name:"withdrawNonce",type:"uint64"},{name:"timestamp",type:"uint64"}]},f),g={signature:this.signMessage(m,this.privateKey),userAddress:s,verifyingContract:n,message:f};a=this.omit(a,"chainId");const v=await this.v1PrivatePostWithdrawRequest(this.extend(g,a)),y=this.safeDict(v,"data",{});return this.parseTransaction(y,o)}parseLeverage(e,t=void 0){const s=this.safeInteger(e,"max_leverage");return{info:e,symbol:t.symbol,marginMode:void 0,longLeverage:s,shortLeverage:s}}async fetchLeverage(e,t={}){await this.loadMarkets();const s=this.market(e),i=await this.v1PrivateGetClientInfo(t),r=this.safeDict(i,"data",{});return this.parseLeverage(r,s)}async setLeverage(e,t=void 0,s={}){if(await this.loadMarkets(),e<1||e>50)throw new r.BadRequest(this.id+" leverage should be between 1 and 50");const i={leverage:e};return await this.v1PrivatePostClientLeverage(this.extend(i,s))}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t);let i,r=this.safeString(e,"position_qty");i=o.Y.stringGt(r,"0")?"long":"short";const a=this.safeString(t,"contractSize"),n=this.safeString(e,"mark_price"),d=this.safeInteger(e,"timestamp"),h=this.safeString(e,"average_open_price"),c=this.safeString(e,"unsettled_pnl");r=o.Y.stringAbs(r);const l=o.Y.stringMul(r,n);return this.safePosition({info:e,id:void 0,symbol:this.safeString(t,"symbol"),timestamp:d,datetime:this.iso8601(d),lastUpdateTimestamp:void 0,initialMargin:void 0,initialMarginPercentage:void 0,maintenanceMargin:void 0,maintenanceMarginPercentage:void 0,entryPrice:this.parseNumber(h),notional:this.parseNumber(l),leverage:void 0,unrealizedPnl:this.parseNumber(c),contracts:this.parseNumber(r),contractSize:this.parseNumber(a),marginRatio:void 0,liquidationPrice:this.safeNumber(e,"est_liq_price"),markPrice:this.parseNumber(n),lastPrice:void 0,collateral:void 0,marginMode:"cross",marginType:void 0,side:i,percentage:void 0,hedged:void 0,stopLossPrice:void 0,takeProfitPrice:void 0})}async fetchPosition(e=void 0,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},r=await this.v1PrivateGetPositionSymbol(this.extend(i,t)),a=this.safeDict(r,"data");return this.parsePosition(a,s)}async fetchPositions(e=void 0,t={}){await this.loadMarkets();const s=await this.v1PrivateGetPositions(t),i=this.safeDict(s,"data",{}),r=this.safeList(i,"rows",[]);return this.parsePositions(r,e)}nonce(){return this.milliseconds()}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){const o=t[0],h=t[1],c=this.implodeParams(e,i);let l=this.implodeHostname(this.urls.api[h]);if(l+="/"+o+"/",i=this.omit(i,this.extractParams(e)),i=this.keysort(i),"public"===h)l+=c,Object.keys(i).length&&(l+="?"+this.urlencode(i));else{if(this.checkRequiredCredentials(),!("POST"!==s&&"PUT"!==s||"algo/order"!==e&&"order"!==e&&"batch-order"!==e)){if(!this.safeBool(this.options,"sandboxMode",!1)){const t=this.safeString(this.options,"brokerId","CCXT");if("batch-order"===e){const e=this.safeList(i,"orders",[]);for(let s=0;s<e.length;s++)i.orders[s].order_tag=t}else i.order_tag=t}i=this.keysort(i)}let t="";const h=this.nonce().toString();l+=c,r={"orderly-account-id":this.accountId,"orderly-key":this.apiKey,"orderly-timestamp":h},t=h+s+"/"+o+"/"+c,"POST"===s||"PUT"===s?(t+=a=this.json(i),r["content-type"]="application/json"):(Object.keys(i).length&&(l+="?"+this.urlencode(i),t+="?"+this.rawencode(i)),r["content-type"]="application/x-www-form-urlencoded","DELETE"===s&&(a=""));let u=this.secret;if(u.indexOf("ed25519:")>=0){const e=u.split("ed25519:");u=e[1]}const p=(0,n.q4)(this.encode(t),this.base58ToBinary(u),d.ev);r["orderly-signature"]=this.urlencodeBase64(this.base64ToBinary(p))}return{url:l,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(!n)return;const c=this.safeBool(n,"success"),l=this.safeString(n,"code");if(!c){const e=this.id+" "+this.json(n);throw this.throwBroadlyMatchedException(this.exceptions.broad,o,e),this.throwExactlyMatchedException(this.exceptions.exact,l,e),new r.ExchangeError(e)}}}},5344:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3521),r=s(5147),a=s(1579),o=s(2079),n=s(4852);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"xt",name:"XT",countries:["SC"],rateLimit:100,version:"v4",certified:!1,pro:!0,has:{CORS:!1,spot:!0,margin:!0,swap:!0,future:!0,option:!1,addMargin:!0,borrowMargin:!1,cancelAllOrders:!0,cancelOrder:!0,cancelOrders:!0,createDepositAddress:!1,createMarketBuyOrderWithCost:!0,createMarketSellOrderWithCost:!1,createOrder:!0,createPostOnlyOrder:!1,createReduceOnlyOrder:!0,editOrder:!1,fetchAccounts:!1,fetchBalance:!0,fetchBidsAsks:!0,fetchBorrowInterest:!1,fetchBorrowRate:!1,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchBorrowRatesPerSymbol:!1,fetchCanceledOrders:!0,fetchClosedOrders:!0,fetchCurrencies:!0,fetchDeposit:!1,fetchDepositAddress:!0,fetchDeposits:!0,fetchDepositWithdrawals:!1,fetchDepositWithdrawFee:!1,fetchDepositWithdrawFees:!1,fetchFundingHistory:!0,fetchFundingRate:!0,fetchFundingRateHistory:!0,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchL3OrderBook:!1,fetchLedger:!0,fetchLedgerEntry:!1,fetchLeverage:!1,fetchLeverageTiers:!0,fetchMarketLeverageTiers:!0,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterest:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchOrders:!0,fetchOrdersByStatus:!0,fetchOrderTrades:!1,fetchPosition:!0,fetchPositions:!0,fetchPremiumIndexOHLCV:!1,fetchSettlementHistory:!1,fetchStatus:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTradingLimits:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawal:!1,fetchWithdrawals:!0,fetchWithdrawalWhitelist:!1,reduceMargin:!0,repayMargin:!1,setLeverage:!0,setMargin:!1,setMarginMode:!1,setPositionMode:!1,signIn:!1,transfer:!0,withdraw:!0},precisionMode:a.kb,urls:{logo:"https://user-images.githubusercontent.com/14319357/232636712-466df2fc-560a-4ca4-aab2-b1d954a58e24.jpg",api:{spot:"https://sapi.xt.com",linear:"https://fapi.xt.com",inverse:"https://dapi.xt.com",user:"https://api.xt.com"},www:"https://xt.com",referral:"https://www.xt.com/en/accounts/register?ref=9PTM9VW",doc:["https://doc.xt.com/","https://github.com/xtpub/api-doc"],fees:"https://www.xt.com/en/rate"},api:{public:{spot:{get:{currencies:1,depth:.05,kline:.1,symbol:1,ticker:1,"ticker/book":1,"ticker/price":1,"ticker/24h":1,time:1,"trade/history":.1,"trade/recent":.1,"wallet/support/currency":1}},linear:{get:{"future/market/v1/public/contract/risk-balance":1,"future/market/v1/public/contract/open-interest":1,"future/market/v1/public/leverage/bracket/detail":1,"future/market/v1/public/leverage/bracket/list":1,"future/market/v1/public/q/agg-ticker":1,"future/market/v1/public/q/agg-tickers":1,"future/market/v1/public/q/deal":1,"future/market/v1/public/q/depth":1,"future/market/v1/public/q/funding-rate":1,"future/market/v1/public/q/funding-rate-record":1,"future/market/v1/public/q/index-price":1,"future/market/v1/public/q/kline":1,"future/market/v1/public/q/mark-price":1,"future/market/v1/public/q/symbol-index-price":1,"future/market/v1/public/q/symbol-mark-price":1,"future/market/v1/public/q/ticker":1,"future/market/v1/public/q/tickers":1,"future/market/v1/public/symbol/coins":3.33,"future/market/v1/public/symbol/detail":3.33,"future/market/v1/public/symbol/list":1}},inverse:{get:{"future/market/v1/public/contract/risk-balance":1,"future/market/v1/public/contract/open-interest":1,"future/market/v1/public/leverage/bracket/detail":1,"future/market/v1/public/leverage/bracket/list":1,"future/market/v1/public/q/agg-ticker":1,"future/market/v1/public/q/agg-tickers":1,"future/market/v1/public/q/deal":1,"future/market/v1/public/q/depth":1,"future/market/v1/public/q/funding-rate":1,"future/market/v1/public/q/funding-rate-record":1,"future/market/v1/public/q/index-price":1,"future/market/v1/public/q/kline":1,"future/market/v1/public/q/mark-price":1,"future/market/v1/public/q/symbol-index-price":1,"future/market/v1/public/q/symbol-mark-price":1,"future/market/v1/public/q/ticker":1,"future/market/v1/public/q/tickers":1,"future/market/v1/public/symbol/coins":3.33,"future/market/v1/public/symbol/detail":3.33,"future/market/v1/public/symbol/list":1}}},private:{spot:{get:{balance:1,balances:1,"batch-order":1,"deposit/address":1,"deposit/history":1,"history-order":1,"open-order":1,order:1,"order/{orderId}":1,trade:1,"withdraw/history":1},post:{order:.2,withdraw:1,"balance/transfer":1,"balance/account/transfer":1,"ws-token":1},delete:{"batch-order":1,"open-order":1,"order/{orderId}":1}},linear:{get:{"future/trade/v1/entrust/plan-detail":1,"future/trade/v1/entrust/plan-list":1,"future/trade/v1/entrust/plan-list-history":1,"future/trade/v1/entrust/profit-detail":1,"future/trade/v1/entrust/profit-list":1,"future/trade/v1/order/detail":1,"future/trade/v1/order/list":1,"future/trade/v1/order/list-history":1,"future/trade/v1/order/trade-list":1,"future/user/v1/account/info":1,"future/user/v1/balance/bills":1,"future/user/v1/balance/detail":1,"future/user/v1/balance/funding-rate-list":1,"future/user/v1/balance/list":1,"future/user/v1/position/adl":1,"future/user/v1/position/list":1,"future/user/v1/user/collection/list":1,"future/user/v1/user/listen-key":1},post:{"future/trade/v1/entrust/cancel-all-plan":1,"future/trade/v1/entrust/cancel-all-profit-stop":1,"future/trade/v1/entrust/cancel-plan":1,"future/trade/v1/entrust/cancel-profit-stop":1,"future/trade/v1/entrust/create-plan":1,"future/trade/v1/entrust/create-profit":1,"future/trade/v1/entrust/update-profit-stop":1,"future/trade/v1/order/cancel":1,"future/trade/v1/order/cancel-all":1,"future/trade/v1/order/create":1,"future/trade/v1/order/create-batch":1,"future/user/v1/account/open":1,"future/user/v1/position/adjust-leverage":1,"future/user/v1/position/auto-margin":1,"future/user/v1/position/close-all":1,"future/user/v1/position/margin":1,"future/user/v1/user/collection/add":1,"future/user/v1/user/collection/cancel":1}},inverse:{get:{"future/trade/v1/entrust/plan-detail":1,"future/trade/v1/entrust/plan-list":1,"future/trade/v1/entrust/plan-list-history":1,"future/trade/v1/entrust/profit-detail":1,"future/trade/v1/entrust/profit-list":1,"future/trade/v1/order/detail":1,"future/trade/v1/order/list":1,"future/trade/v1/order/list-history":1,"future/trade/v1/order/trade-list":1,"future/user/v1/account/info":1,"future/user/v1/balance/bills":1,"future/user/v1/balance/detail":1,"future/user/v1/balance/funding-rate-list":1,"future/user/v1/balance/list":1,"future/user/v1/position/adl":1,"future/user/v1/position/list":1,"future/user/v1/user/collection/list":1,"future/user/v1/user/listen-key":1},post:{"future/trade/v1/entrust/cancel-all-plan":1,"future/trade/v1/entrust/cancel-all-profit-stop":1,"future/trade/v1/entrust/cancel-plan":1,"future/trade/v1/entrust/cancel-profit-stop":1,"future/trade/v1/entrust/create-plan":1,"future/trade/v1/entrust/create-profit":1,"future/trade/v1/entrust/update-profit-stop":1,"future/trade/v1/order/cancel":1,"future/trade/v1/order/cancel-all":1,"future/trade/v1/order/create":1,"future/trade/v1/order/create-batch":1,"future/user/v1/account/open":1,"future/user/v1/position/adjust-leverage":1,"future/user/v1/position/auto-margin":1,"future/user/v1/position/close-all":1,"future/user/v1/position/margin":1,"future/user/v1/user/collection/add":1,"future/user/v1/user/collection/cancel":1}},user:{get:{"user/account":1,"user/account/api-key":1},post:{"user/account":1,"user/account/api-key":1},put:{"user/account/api-key":1},delete:{"user/account/{apikeyId}":1}}}},fees:{spot:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.002"),taker:this.parseNumber("0.002"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("5000"),this.parseNumber("0.0018")],[this.parseNumber("10000"),this.parseNumber("0.0016")],[this.parseNumber("20000"),this.parseNumber("0.0014")],[this.parseNumber("50000"),this.parseNumber("0.0012")],[this.parseNumber("150000"),this.parseNumber("0.0010")],[this.parseNumber("300000"),this.parseNumber("0.0008")],[this.parseNumber("600000"),this.parseNumber("0.0007")],[this.parseNumber("1200000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("6000000"),this.parseNumber("0.0004")],[this.parseNumber("15000000"),this.parseNumber("0.0003")],[this.parseNumber("30000000"),this.parseNumber("0.0002")]],taker:[[this.parseNumber("0"),this.parseNumber("0.002")],[this.parseNumber("5000"),this.parseNumber("0.0018")],[this.parseNumber("10000"),this.parseNumber("0.0016")],[this.parseNumber("20000"),this.parseNumber("0.0014")],[this.parseNumber("50000"),this.parseNumber("0.0012")],[this.parseNumber("150000"),this.parseNumber("0.0010")],[this.parseNumber("300000"),this.parseNumber("0.0008")],[this.parseNumber("600000"),this.parseNumber("0.0007")],[this.parseNumber("1200000"),this.parseNumber("0.0006")],[this.parseNumber("2500000"),this.parseNumber("0.0005")],[this.parseNumber("6000000"),this.parseNumber("0.0004")],[this.parseNumber("15000000"),this.parseNumber("0.0003")],[this.parseNumber("30000000"),this.parseNumber("0.0002")]]}},contract:{tierBased:!0,percentage:!0,maker:this.parseNumber("0.0004"),taker:this.parseNumber("0.0006"),tiers:{maker:[[this.parseNumber("0"),this.parseNumber("0.0004")],[this.parseNumber("200000"),this.parseNumber("0.00038")],[this.parseNumber("1000000"),this.parseNumber("0.00036")],[this.parseNumber("5000000"),this.parseNumber("0.00034")],[this.parseNumber("10000000"),this.parseNumber("0.00032")],[this.parseNumber("15000000"),this.parseNumber("0.00028")],[this.parseNumber("30000000"),this.parseNumber("0.00024")],[this.parseNumber("50000000"),this.parseNumber("0.0002")],[this.parseNumber("100000000"),this.parseNumber("0.00016")],[this.parseNumber("300000000"),this.parseNumber("0.00012")],[this.parseNumber("500000000"),this.parseNumber("0.00008")]],taker:[[this.parseNumber("0"),this.parseNumber("0.0006")],[this.parseNumber("200000"),this.parseNumber("0.000588")],[this.parseNumber("1000000"),this.parseNumber("0.00057")],[this.parseNumber("5000000"),this.parseNumber("0.00054")],[this.parseNumber("10000000"),this.parseNumber("0.00051")],[this.parseNumber("15000000"),this.parseNumber("0.00048")],[this.parseNumber("30000000"),this.parseNumber("0.00045")],[this.parseNumber("50000000"),this.parseNumber("0.00045")],[this.parseNumber("100000000"),this.parseNumber("0.00036")],[this.parseNumber("300000000"),this.parseNumber("0.00033")],[this.parseNumber("500000000"),this.parseNumber("0.0003")]]}}},exceptions:{exact:{400:o.NetworkError,404:o.ExchangeError,429:o.RateLimitExceeded,500:o.ExchangeError,502:o.ExchangeError,503:o.OnMaintenance,AUTH_001:o.AuthenticationError,AUTH_002:o.AuthenticationError,AUTH_003:o.AuthenticationError,AUTH_004:o.AuthenticationError,AUTH_005:o.AuthenticationError,AUTH_006:o.AuthenticationError,AUTH_007:o.AuthenticationError,AUTH_101:o.AuthenticationError,AUTH_102:o.AuthenticationError,AUTH_103:o.AuthenticationError,AUTH_104:o.AuthenticationError,AUTH_105:o.AuthenticationError,AUTH_106:o.PermissionDenied,SYMBOL_001:o.BadSymbol,SYMBOL_002:o.BadSymbol,SYMBOL_003:o.BadSymbol,SYMBOL_004:o.BadSymbol,SYMBOL_005:o.BadSymbol,ORDER_001:o.InvalidOrder,ORDER_002:o.InsufficientFunds,ORDER_003:o.InvalidOrder,ORDER_004:o.InvalidOrder,ORDER_005:o.InvalidOrder,ORDER_006:o.InvalidOrder,ORDER_007:o.PermissionDenied,ORDER_F0101:o.InvalidOrder,ORDER_F0102:o.InvalidOrder,ORDER_F0103:o.InvalidOrder,ORDER_F0201:o.InvalidOrder,ORDER_F0202:o.InvalidOrder,ORDER_F0203:o.InvalidOrder,ORDER_F0301:o.InvalidOrder,ORDER_F0401:o.InvalidOrder,ORDER_F0501:o.InvalidOrder,ORDER_F0502:o.InvalidOrder,ORDER_F0601:o.InvalidOrder,COMMON_001:o.ExchangeError,COMMON_002:o.ExchangeError,COMMON_003:o.BadRequest,CURRENCY_001:o.BadRequest,DEPOSIT_001:o.BadRequest,DEPOSIT_002:o.PermissionDenied,DEPOSIT_003:o.BadRequest,DEPOSIT_004:o.BadRequest,DEPOSIT_005:o.BadRequest,DEPOSIT_006:o.BadRequest,DEPOSIT_007:o.BadRequest,DEPOSIT_008:o.BadRequest,WITHDRAW_001:o.BadRequest,WITHDRAW_002:o.BadRequest,WITHDRAW_003:o.PermissionDenied,WITHDRAW_004:o.BadRequest,WITHDRAW_005:o.BadRequest,WITHDRAW_006:o.BadRequest,WITHDRAW_008:o.PermissionDenied,WITHDRAW_009:o.PermissionDenied,WITHDRAW_010:o.BadRequest,WITHDRAW_011:o.InsufficientFunds,WITHDRAW_012:o.PermissionDenied,WITHDRAW_013:o.PermissionDenied,WITHDRAW_014:o.BadRequest,WITHDRAW_015:o.BadRequest,WITHDRAW_016:o.BadRequest,WITHDRAW_017:o.BadRequest,WITHDRAW_018:o.BadRequest,WITHDRAW_019:o.BadRequest,WITHDRAW_020:o.PermissionDenied,WITHDRAW_021:o.PermissionDenied,WITHDRAW_022:o.BadRequest,WITHDRAW_023:o.BadRequest,WITHDRAW_024:o.BadRequest,WITHDRAW_025:o.BadRequest,FUND_001:o.BadRequest,FUND_002:o.InsufficientFunds,FUND_003:o.BadRequest,FUND_004:o.ExchangeError,FUND_005:o.PermissionDenied,FUND_014:o.BadRequest,FUND_015:o.BadRequest,FUND_016:o.BadRequest,FUND_017:o.BadRequest,FUND_018:o.BadRequest,FUND_019:o.BadRequest,FUND_020:o.BadRequest,FUND_021:o.BadRequest,FUND_022:o.BadRequest,FUND_044:o.BadRequest,TRANSFER_001:o.BadRequest,TRANSFER_002:o.InsufficientFunds,TRANSFER_003:o.BadRequest,TRANSFER_004:o.PermissionDenied,TRANSFER_005:o.PermissionDenied,TRANSFER_006:o.PermissionDenied,TRANSFER_007:o.RequestTimeout,TRANSFER_008:o.BadRequest,TRANSFER_009:o.BadRequest,TRANSFER_010:o.PermissionDenied,TRANSFER_011:o.PermissionDenied,TRANSFER_012:o.PermissionDenied,symbol_not_support_trading_via_api:o.BadSymbol,open_order_min_nominal_value_limit:o.InvalidOrder},broad:{"The symbol does not support trading via API":o.BadSymbol,"Exceeds the minimum notional value of a single order":o.InvalidOrder}},timeframes:{"1m":"1m","5m":"5m","15m":"15m","30m":"30m","1h":"1h","2h":"2h","4h":"4h","6h":"6h","8h":"8h","1d":"1d","3d":"3d","1w":"1w","1M":"1M"},commonCurrencies:{},options:{adjustForTimeDifference:!1,timeDifference:0,accountsById:{spot:"SPOT",leverage:"LEVER",finance:"FINANCE",swap:"FUTURES_U",future:"FUTURES_U",linear:"FUTURES_U",inverse:"FUTURES_C"},networks:{ERC20:"Ethereum",TRC20:"Tron",BEP20:"BNB Smart Chain",BEP2:"BNB-BEP2",ETH:"Ethereum",TRON:"Tron",BNB:"BNB Smart Chain",AVAX:"AVAX C-Chain",GAL:"GAL(FT)",ALEO:"ALEO(IOU)",BTC:"Bitcoin",XT:"XT Smart Chain",ETC:"Ethereum Classic",MATIC:"Polygon",LTC:"Litecoin",BTS:"BitShares",XRP:"Ripple",XLM:"Stellar Network",ADA:"Cardano",XWC:"XWC-XWC",DOGE:"dogecoin",DCR:"Decred",SC:"Siacoin",XTZ:"Tezos",ZEC:"Zcash",XMR:"Monero",LSK:"Lisk",ATOM:"Cosmos",ONT:"Ontology",ALGO:"Algorand",SOL:"SOL-SOL",DOT:"Polkadot",ZEN:"Horizen",FIL:"Filecoin",CHZ:"chz",ICP:"Internet Computer",KSM:"Kusama",LUNA:"Terra",THETA:"Theta Token",FTM:"Fantom",VET:"VeChain",NEAR:"NEAR Protocol",ONE:"Harmony",KLAY:"Klaytn",AR:"Arweave",CELT:"OKT",EGLD:"Elrond eGold",CRO:"CRO-CRONOS",BCH:"Bitcoin Cash",GLMR:"Moonbeam",LOOP:"LOOP-LRC",REI:"REI Network",ASTR:"Astar Network",OP:"OPT",MMT:"MMT-MMT",TBC:"TBC-TBC",OMAX:"OMAX-OMAX CHAIN",GMMT:"GMMT chain",ZIL:"Zilliqa"},networksById:{Ethereum:"ERC20",Tron:"TRC20","BNB Smart Chain":"BEP20","BNB-BEP2":"BEP2",Bitcoin:"BTC","XT Smart Chain":"XT","Ethereum Classic":"ETC",Polygon:"MATIC",Litecoin:"LTC",BitShares:"BTS",Ripple:"XRP","Stellar Network":"XLM",Cardano:"ADA","XWC-XWC":"XWC",dogecoin:"DOGE",Decred:"DCR",Siacoin:"SC",Tezos:"XTZ",Zcash:"ZEC",Monero:"XMR",Lisk:"LSK",Cosmos:"ATOM",Ontology:"ONT",Algorand:"ALGO","SOL-SOL":"SOL",Polkadot:"DOT",Horizen:"ZEN",Filecoin:"FIL",chz:"CHZ","Internet Computer":"ICP",Kusama:"KSM",Terra:"LUNA","Theta Token":"THETA",Fantom:"FTM",VeChain:"VET","AVAX C-Chain":"AVAX","NEAR Protocol":"NEAR",Harmony:"ONE",Klaytn:"KLAY",Arweave:"AR",OKT:"CELT","Elrond eGold":"EGLD","CRO-CRONOS":"CRO","Bitcoin Cash":"BCH",Moonbeam:"GLMR","LOOP-LRC":"LOOP","REI Network":"REI","Astar Network":"ASTR","GAL(FT)":"GAL","ALEO(IOU)":"ALEO",OPT:"OP","MMT-MMT":"MMT","TBC-TBC":"TBC","OMAX-OMAX CHAIN":"OMAX","GMMT chain":"GMMT",Zilliqa:"ZIL"},createMarketBuyOrderRequiresPrice:!0,recvWindow:"5000"}})}nonce(){return this.milliseconds()-this.options.timeDifference}async fetchTime(e={}){const t=await this.publicSpotGetTime(e),s=this.safeValue(t,"result");return this.safeInteger(s,"serverTime")}async fetchCurrencies(e={}){const t=[this.publicSpotGetWalletSupportCurrency(e),this.publicSpotGetCurrencies(e)],[s,i]=await Promise.all(t),a=this.safeValue(s,"result",[]),o=this.safeValue(i,"result",[]),n=this.safeValue(o,"currencies",[]),d=this.indexBy(a,"currency"),h={};for(let e=0;e<n.length;e++){const t=n[e],s=this.safeString(t,"currency"),i=this.safeCurrencyCode(s),a=this.parseNumber(this.parsePrecision(this.safeString(t,"maxPrecision"))),o=this.safeValue(d,s,{}),c=this.safeValue(o,"supportChains",[]),l={};let u,p,f=!1,m=!1,g=!1;for(let e=0;e<c.length;e++){const t=c[e],s=this.safeString(t,"chain"),i=this.networkIdToCode(s),o=this.safeValue(t,"depositEnabled");m=o||m;const n=this.safeValue(t,"withdrawEnabled");g=n||g;const d=o&&n;f=d||f;const h=this.safeString(t,"withdrawFeeAmount");void 0!==h&&(p=void 0===p?h:r.Y.stringMin(h,p));const v=this.safeString(t,"withdrawMinAmount");void 0!==v&&(u=void 0===u?v:r.Y.stringMin(v,u)),l[i]={info:t,id:s,network:i,name:void 0,active:d,fee:this.parseNumber(h),precision:a,deposit:o,withdraw:n,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(v),max:void 0},deposit:{min:void 0,max:void 0}}}}h[i]={info:t,id:s,code:i,name:this.safeString(t,"fullName"),active:f,fee:this.parseNumber(p),precision:a,deposit:m,withdraw:g,networks:l,limits:{amount:{min:void 0,max:void 0},withdraw:{min:this.parseNumber(u),max:void 0},deposit:{min:void 0,max:void 0}}}}return h}async fetchMarkets(e={}){this.options.adjustForTimeDifference&&await this.loadTimeDifference();const t=[this.fetchSpotMarkets(e),this.fetchSwapAndFutureMarkets(e)],s=await Promise.all(t),i=s[0],r=s[1];return this.arrayConcat(i,r)}async fetchSpotMarkets(e={}){const t=await this.publicSpotGetSymbol(e),s=this.safeValue(t,"result",{}),i=this.safeValue(s,"symbols",[]);return this.parseMarkets(i)}async fetchSwapAndFutureMarkets(e={}){const t=await Promise.all([this.publicLinearGetFutureMarketV1PublicSymbolList(e),this.publicInverseGetFutureMarketV1PublicSymbolList(e)]),s=this.arrayConcat(this.safeValue(t[0],"result",[]),this.safeValue(t[1],"result",[]));return this.parseMarkets(s)}parseMarkets(e){const t=[];for(let s=0;s<e.length;s++)t.push(this.parseMarket(e[s]));return t}parseMarket(e){const t=this.safeString(e,"symbol"),s=this.safeString2(e,"baseCurrency","baseCoin"),i=this.safeString2(e,"quoteCurrency","quoteCoin"),r=this.safeCurrencyCode(s),a=this.safeCurrencyCode(i),o=this.safeString(e,"state");let n=r+"/"+a;const d=this.safeValue(e,"filters",[]);let h,c,l,u,p,f;for(let e=0;e<d.length;e++){const t=d[e],s=this.safeString(t,"filter");"QUANTITY"===s&&(h=this.safeNumber(t,"min"),c=this.safeNumber(t,"max")),"QUOTE_QTY"===s&&(l=this.safeNumber(t,"min")),"PRICE"===s&&(p=this.safeNumber(t,"min"),f=this.safeNumber(t,"max"))}const m=this.safeString(e,"underlyingType");let g,v,y,w,b,S=!1,k=!1,O=!1,T=!0,P="spot";if("U_BASED"===m?(n=n+":"+a,y=s,w=a,g=!0,v=!1):"COIN_BASED"===m&&(n=n+":"+r,y=s,w=r,g=!1,v=!0),void 0!==m){b=this.safeInteger(e,"deliveryDate");"perpetual"!==this.safeString(e,"productType")?(n=n+"-"+this.yymmdd(b),P="future",S=!0):(P="swap",k=!0),h=this.safeNumber(e,"minQty"),l=this.safeNumber(e,"minNotional"),u=this.safeNumber(e,"maxNotional"),p=this.safeNumber(e,"minPrice"),f=this.safeNumber(e,"maxPrice"),O=!0,T=!1}let I=!1;return O?I=this.safeValue(e,"isOpenApi",!1):"ONLINE"===o&&this.safeValue(e,"tradingEnabled")&&this.safeValue(e,"openapiEnabled")&&(I=!0),this.safeMarketStructure({id:t,symbol:n,base:r,quote:a,settle:w,baseId:s,quoteId:i,settleId:y,type:P,spot:T,margin:void 0,swap:k,future:S,option:!1,active:I,contract:O,linear:g,inverse:v,taker:this.safeNumber(e,"takerFee"),maker:this.safeNumber(e,"makerFee"),contractSize:this.safeNumber(e,"contractSize"),expiry:b,expiryDatetime:this.iso8601(b),strike:void 0,optionType:void 0,precision:{price:this.parseNumber(this.parsePrecision(this.safeString(e,"pricePrecision"))),amount:this.parseNumber(this.parsePrecision(this.safeString(e,"quantityPrecision"))),base:this.parseNumber(this.parsePrecision(this.safeString(e,"baseCoinPrecision"))),quote:this.parseNumber(this.parsePrecision(this.safeString(e,"quoteCoinPrecision")))},limits:{leverage:{min:this.parseNumber("1"),max:void 0},amount:{min:h,max:c},price:{min:p,max:f},cost:{min:l,max:u}},info:e})}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.id,interval:this.safeString(this.timeframes,t,t)};let n;void 0!==s&&(o.startTime=s),void 0!==i&&(o.limit=i),n=a.linear?await this.publicLinearGetFutureMarketV1PublicQKline(this.extend(o,r)):a.inverse?await this.publicInverseGetFutureMarketV1PublicQKline(this.extend(o,r)):await this.publicSpotGetKline(this.extend(o,r));const d=this.safeValue(n,"result",[]);return this.parseOHLCVs(d,a,t,s,i)}parseOHLCV(e,t=void 0){const s=t.inverse?"v":"a";return[this.safeInteger(e,"t"),this.safeNumber(e,"o"),this.safeNumber(e,"h"),this.safeNumber(e,"l"),this.safeNumber(e,"c"),this.safeNumber2(e,s,"v")]}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id};let a;i.spot?(void 0!==t&&(r.limit=Math.min(t,500)),a=await this.publicSpotGetDepth(this.extend(r,s))):(r.level=void 0!==t?Math.min(t,50):50,i.linear?a=await this.publicLinearGetFutureMarketV1PublicQDepth(this.extend(r,s)):i.inverse&&(a=await this.publicInverseGetFutureMarketV1PublicQDepth(this.extend(r,s))));const o=this.safeValue(a,"result",{}),n=this.safeInteger2(o,"timestamp","t");if(i.spot){const t=this.parseOrderBook(o,e,n);return t.nonce=this.safeInteger(o,"lastUpdateId"),t}const d=this.parseOrderBook(o,e,n,"b","a");return d.nonce=this.safeInteger2(o,"u","lastUpdateId"),d}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r;r=s.linear?await this.publicLinearGetFutureMarketV1PublicQAggTicker(this.extend(i,t)):s.inverse?await this.publicInverseGetFutureMarketV1PublicQAggTicker(this.extend(i,t)):await this.publicSpotGetTicker24h(this.extend(i,t));const a=this.safeValue(r,"result");return s.spot?this.parseTicker(a[0],s):this.parseTicker(a,s)}async fetchTickers(e=void 0,t={}){let s;await this.loadMarkets(),void 0!==e&&(e=this.marketSymbols(e),s=this.market(e[0]));const i={};let r,a,o;[r,t]=this.handleMarketTypeAndParams("fetchTickers",s,t),[a,t]=this.handleSubTypeAndParams("fetchTickers",s,t),o="inverse"===a?await this.publicInverseGetFutureMarketV1PublicQAggTickers(this.extend(i,t)):"linear"===a||"swap"===r||"future"===r?await this.publicLinearGetFutureMarketV1PublicQAggTickers(this.extend(i,t)):await this.publicSpotGetTicker24h(this.extend(i,t));const n=this.safeValue(o,"result",[]),d={};for(let e=0;e<n.length;e++){const t=this.parseTicker(n[e],s);d[t.symbol]=t}return this.filterByArray(d,"symbol",e)}async fetchBidsAsks(e=void 0,t={}){await this.loadMarkets();let s,i;if(void 0!==(e=this.marketSymbols(e))&&(s=this.market(e[0])),[i,t]=this.handleSubTypeAndParams("fetchBidsAsks",s,t),void 0!==i)throw new o.NotSupported(this.id+" fetchBidsAsks() is not available for swap and future markets, only spot markets are supported");const r=await this.publicSpotGetTickerBook(this.extend({},t)),a=this.safeValue(r,"result",[]);return this.parseTickers(a,e)}parseTicker(e,t=void 0){const s=this.safeString(e,"s");let i=void 0!==t?t.type:void 0;void 0===i&&(i="cv"in e||"aq"in e?"spot":"contract");const r=(t=this.safeMarket(s,t,"_",i)).symbol,a=this.safeInteger(e,"t");return this.safeTicker({symbol:r,timestamp:a,datetime:this.iso8601(a),high:this.safeNumber(e,"h"),low:this.safeNumber(e,"l"),bid:this.safeNumber(e,"bp"),bidVolume:this.safeNumber(e,"bq"),ask:this.safeNumber(e,"ap"),askVolume:this.safeNumber(e,"aq"),vwap:void 0,open:this.safeString(e,"o"),close:this.safeString(e,"c"),last:this.safeString(e,"c"),previousClose:void 0,change:this.safeNumber(e,"cv"),percentage:this.safeNumber2(e,"cr","r"),average:void 0,baseVolume:void 0,quoteVolume:this.safeNumber2(e,"a","v"),info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.id};let o;r.spot?(void 0!==s&&(a.limit=s),o=await this.publicSpotGetTradeRecent(this.extend(a,i))):(void 0!==s&&(a.num=s),r.linear?o=await this.publicLinearGetFutureMarketV1PublicQDeal(this.extend(a,i)):r.inverse&&(o=await this.publicInverseGetFutureMarketV1PublicQDeal(this.extend(a,i))));const n=this.safeValue(o,"result",[]);return this.parseTrades(n,r)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o,n,d;if(void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==t&&(r.startTime=t),[o,i]=this.handleMarketTypeAndParams("fetchMyTrades",a,i),[n,i]=this.handleSubTypeAndParams("fetchMyTrades",a,i),void 0!==n||"swap"===o||"future"===o)void 0!==s&&(r.size=s),d="inverse"===n?await this.privateInverseGetFutureTradeV1OrderTradeList(this.extend(r,i)):await this.privateLinearGetFutureTradeV1OrderTradeList(this.extend(r,i));else{let e;[e,i]=this.handleMarginModeAndParams("fetchMyTrades",i);const t=void 0!==e?"LEVER":"SPOT";r.bizType=t,void 0!==s&&(r.limit=s),d=await this.privateSpotGetTrade(this.extend(r,i))}const h=this.safeValue(d,"result",{}),c=this.safeValue(h,"items",[]);return this.parseTrades(c,a,t,s)}parseTrade(e,t=void 0){const s=this.safeString2(e,"s","symbol");let i=void 0!==t?t.type:void 0;void 0===i&&(i="b"in e||"bizType"in e||"oi"in e?"spot":"contract"),t=this.safeMarket(s,t,"_",i);const a=this.safeString(e,"m");let o=this.safeStringLower(e,"orderSide");void 0!==a&&(o="BID"===a?"buy":"sell");const n=this.safeValue(e,"b");void 0!==n&&(o="buy");let d=this.safeStringLower(e,"takerMaker");void 0!==n&&(d=n?"maker":"taker");const h=this.safeBool(e,"isMaker");void 0!==h&&(d=h?"maker":"taker");const c=this.safeIntegerN(e,["t","time","timestamp"]),l=this.safeString2(e,"q","quantity");let u;return u="spot"===i?l:void 0===l?r.Y.stringMul(this.safeString(e,"a"),this.numberToString(t.contractSize)):r.Y.stringMul(l,this.numberToString(t.contractSize)),this.safeTrade({info:e,id:this.safeStringN(e,["i","tradeId","execId"]),timestamp:c,datetime:this.iso8601(c),symbol:t.symbol,order:this.safeString2(e,"orderId","oi"),type:this.safeStringLower(e,"orderType"),side:o,takerOrMaker:d,price:this.safeString2(e,"p","price"),amount:u,cost:void 0,fee:{currency:this.safeCurrencyCode(this.safeString2(e,"feeCurrency","feeCoin")),cost:this.safeString(e,"fee")}},t)}async fetchBalance(e={}){let t,s,i;await this.loadMarkets(),[t,e]=this.handleMarketTypeAndParams("fetchBalance",void 0,e),[s,e]=this.handleSubTypeAndParams("fetchBalance",void 0,e);const r="swap"===t||"future"===t;let a;if(i="inverse"===s?await this.privateInverseGetFutureUserV1BalanceList(e):"linear"===s||r?await this.privateLinearGetFutureUserV1BalanceList(e):await this.privateSpotGetBalances(e),void 0!==s||r)a=this.safeValue(i,"result",[]);else{const e=this.safeValue(i,"result",{});a=this.safeValue(e,"assets",[])}return this.parseBalance(a)}parseBalance(e){const t={info:e};for(let s=0;s<e.length;s++){const i=e[s],a=this.safeString2(i,"currency","coin"),o=this.safeCurrencyCode(a),n=this.account(),d=this.safeString2(i,"availableAmount","availableBalance");let h=this.safeString(i,"frozenAmount");const c=this.safeString2(i,"totalAmount","walletBalance");if(void 0===h){const e=r.Y.stringAdd(this.safeString(i,"crossedMargin"),this.safeString(i,"isolatedMargin"));h=r.Y.stringAdd(this.safeString(i,"openOrderMarginFrozen"),e)}n.free=d,n.used=h,n.total=c,t[o]=n}return this.safeBalance(t)}async createMarketBuyOrderWithCost(e,t,s={}){await this.loadMarkets();if(!this.market(e).spot)throw new o.NotSupported(this.id+" createMarketBuyOrderWithCost() supports spot orders only");return await this.createOrder(e,"market","buy",t,1,s)}async createOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e);return e=o.symbol,o.spot?await this.createSpotOrder(e,t,s,i,r,a):await this.createContractOrder(e,t,s,i,r,a)}async createSpotOrder(e,t,s,i,a=void 0,n={}){await this.loadMarkets();const d=this.market(e),h={symbol:d.id,side:s.toUpperCase(),type:t.toUpperCase()};let c,l;[l,n]=this.handleMarginModeAndParams("createOrder",n);const u=void 0!==l?"LEVER":"SPOT";if(h.bizType=u,"market"===t){if(c=this.safeStringUpper(n,"timeInForce","FOK"),"buy"===s){const t=this.safeString(n,"cost");n=this.omit(n,"cost");if(this.safeBool(this.options,"createMarketBuyOrderRequiresPrice",!0)){if(void 0===a&&void 0===t)throw new o.InvalidOrder(this.id+" createOrder() requires a price argument or cost in params for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option to false and pass in the cost to spend into the amount parameter");{const s=this.numberToString(i),o=this.numberToString(a);let n;n=void 0!==a?r.Y.stringMul(s,o):t,h.quoteQty=this.costToPrecision(e,n)}}else{const s=void 0!==t?t:i;h.quoteQty=this.costToPrecision(e,s)}}}else c=this.safeStringUpper(n,"timeInForce","GTC"),h.price=this.priceToPrecision(e,a);"sell"!==s&&"limit"!==t||(h.quantity=this.amountToPrecision(e,i)),h.timeInForce=c;const p=await this.privateSpotPostOrder(this.extend(h,n)),f=this.safeValue(p,"result",{});return this.parseOrder(f,d)}async createContractOrder(e,t,s,i,r=void 0,a={}){await this.loadMarkets();const o=this.market(e),n={symbol:o.id,origQty:this.amountToPrecision(e,i)},d=this.safeStringUpper(a,"timeInForce");void 0!==d&&(n.timeInForce=d);const h=this.safeValue(a,"reduceOnly",!1);if("buy"===s){const e=h?"SHORT":"LONG";n.positionSide=e}else{const e=h?"LONG":"SHORT";n.positionSide=e}let c;const l=this.safeNumber2(a,"triggerPrice","stopPrice"),u=this.safeNumber2(a,"stopLoss","triggerStopPrice"),p=this.safeNumber2(a,"takeProfit","triggerProfitPrice"),f=void 0!==l,m=void 0!==u,g=void 0!==p;if(void 0!==r&&(m||g||(n.price=this.priceToPrecision(e,r))),f){n.timeInForce=this.safeStringUpper(a,"timeInForce","GTC"),n.triggerPriceType=this.safeString(a,"triggerPriceType","LATEST_PRICE"),n.orderSide=s.toUpperCase(),n.stopPrice=this.priceToPrecision(e,l);const i="market"===t?"STOP_MARKET":"STOP";n.entrustType=i,a=this.omit(a,"triggerPrice"),o.linear?c=await this.privateLinearPostFutureTradeV1EntrustCreatePlan(this.extend(n,a)):o.inverse&&(c=await this.privateInversePostFutureTradeV1EntrustCreatePlan(this.extend(n,a)))}else m||g?(m?n.triggerStopPrice=this.priceToPrecision(e,u):n.triggerProfitPrice=this.priceToPrecision(e,p),a=this.omit(a,["stopLoss","takeProfit"]),o.linear?c=await this.privateLinearPostFutureTradeV1EntrustCreateProfit(this.extend(n,a)):o.inverse&&(c=await this.privateInversePostFutureTradeV1EntrustCreateProfit(this.extend(n,a)))):(n.orderSide=s.toUpperCase(),n.orderType=t.toUpperCase(),o.linear?c=await this.privateLinearPostFutureTradeV1OrderCreate(this.extend(n,a)):o.inverse&&(c=await this.privateInversePostFutureTradeV1OrderCreate(this.extend(n,a))));return this.parseOrder(c,o)}async fetchOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={};let a,o,n;[a,s]=this.handleMarketTypeAndParams("fetchOrder",i,s),[o,s]=this.handleSubTypeAndParams("fetchOrder",i,s);const d=this.safeValue(s,"stop"),h=this.safeValue(s,"stopLossTakeProfit");d?r.entrustId=e:h?r.profitId=e:r.orderId=e,d?(s=this.omit(s,"stop"),n="inverse"===o?await this.privateInverseGetFutureTradeV1EntrustPlanDetail(this.extend(r,s)):await this.privateLinearGetFutureTradeV1EntrustPlanDetail(this.extend(r,s))):h?(s=this.omit(s,"stopLossTakeProfit"),n="inverse"===o?await this.privateInverseGetFutureTradeV1EntrustProfitDetail(this.extend(r,s)):await this.privateLinearGetFutureTradeV1EntrustProfitDetail(this.extend(r,s))):n="inverse"===o?await this.privateInverseGetFutureTradeV1OrderDetail(this.extend(r,s)):"linear"===o||"swap"===a||"future"===a?await this.privateLinearGetFutureTradeV1OrderDetail(this.extend(r,s)):await this.privateSpotGetOrderOrderId(this.extend(r,s));const c=this.safeValue(n,"result",{});return this.parseOrder(c,i)}async fetchOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,o,n,d;void 0!==e&&(a=this.market(e),r.symbol=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s),[o,i]=this.handleMarketTypeAndParams("fetchOrders",a,i),[n,i]=this.handleSubTypeAndParams("fetchOrders",a,i);if(this.safeValue(i,"stop"))i=this.omit(i,"stop"),d="inverse"===n?await this.privateInverseGetFutureTradeV1EntrustPlanListHistory(this.extend(r,i)):await this.privateLinearGetFutureTradeV1EntrustPlanListHistory(this.extend(r,i));else if("inverse"===n)d=await this.privateInverseGetFutureTradeV1OrderListHistory(this.extend(r,i));else if("linear"===n||"swap"===o||"future"===o)d=await this.privateLinearGetFutureTradeV1OrderListHistory(this.extend(r,i));else{let e;[e,i]=this.handleMarginModeAndParams("fetchOrders",i);const t=void 0!==e?"LEVER":"SPOT";r.bizType=t,d=await this.privateSpotGetHistoryOrder(this.extend(r,i))}const h=this.safeValue(d,"result",{}),c=this.safeValue(h,"items",[]);return this.parseOrders(c,a,t,s)}async fetchOrdersByStatus(e,t=void 0,s=void 0,i=void 0,r={}){await this.loadMarkets();const a={};let o,n,d,h;void 0!==t&&(o=this.market(t),a.symbol=o.id),[n,r]=this.handleMarketTypeAndParams("fetchOrdersByStatus",o,r),[d,r]=this.handleSubTypeAndParams("fetchOrdersByStatus",o,r);const c=this.safeValue(r,"stop"),l=this.safeValue(r,"stopLossTakeProfit");if("open"===e?c||l?a.state="NOT_TRIGGERED":void 0!==d&&(a.state="NEW"):a.state="closed"===e?c||l?"TRIGGERED":"FILLED":"canceled"===e?c||l?"USER_REVOCATION":"CANCELED":e,(c||l||void 0!==d||"swap"===n||"future"===n)&&(void 0!==s&&(a.startTime=s),void 0!==i&&(a.size=i)),c)r=this.omit(r,"stop"),h="inverse"===d?await this.privateInverseGetFutureTradeV1EntrustPlanList(this.extend(a,r)):await this.privateLinearGetFutureTradeV1EntrustPlanList(this.extend(a,r));else if(l)r=this.omit(r,"stopLossTakeProfit"),h="inverse"===d?await this.privateInverseGetFutureTradeV1EntrustProfitList(this.extend(a,r)):await this.privateLinearGetFutureTradeV1EntrustProfitList(this.extend(a,r));else if(void 0!==d||"swap"===n||"future"===n)h="inverse"===d?await this.privateInverseGetFutureTradeV1OrderList(this.extend(a,r)):await this.privateLinearGetFutureTradeV1OrderList(this.extend(a,r));else{let t;[t,r]=this.handleMarginModeAndParams("fetchOrdersByStatus",r);const o=void 0!==t?"LEVER":"SPOT";a.bizType=o,"open"!==e?(void 0!==s&&(a.startTime=s),void 0!==i&&(a.limit=i),h=await this.privateSpotGetHistoryOrder(this.extend(a,r))):h=await this.privateSpotGetOpenOrder(this.extend(a,r))}const u="open"===e&&void 0===d,p=this.safeValue(h,"result",{}),f=u?this.safeValue(h,"result",[]):this.safeValue(p,"items",[]);return this.parseOrders(f,o,s,i)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("open",e,t,s,i)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("closed",e,t,s,i)}async fetchCanceledOrders(e=void 0,t=void 0,s=void 0,i={}){return await this.fetchOrdersByStatus("canceled",e,t,s,i)}async cancelOrder(e,t=void 0,s={}){let i;await this.loadMarkets(),void 0!==t&&(i=this.market(t));const r={};let a,o,n;[a,s]=this.handleMarketTypeAndParams("cancelOrder",i,s),[o,s]=this.handleSubTypeAndParams("cancelOrder",i,s);const d=this.safeValue(s,"stop"),h=this.safeValue(s,"stopLossTakeProfit");d?r.entrustId=e:h?r.profitId=e:r.orderId=e,d?(s=this.omit(s,"stop"),n="inverse"===o?await this.privateInversePostFutureTradeV1EntrustCancelPlan(this.extend(r,s)):await this.privateLinearPostFutureTradeV1EntrustCancelPlan(this.extend(r,s))):h?(s=this.omit(s,"stopLossTakeProfit"),n="inverse"===o?await this.privateInversePostFutureTradeV1EntrustCancelProfitStop(this.extend(r,s)):await this.privateLinearPostFutureTradeV1EntrustCancelProfitStop(this.extend(r,s))):n="inverse"===o?await this.privateInversePostFutureTradeV1OrderCancel(this.extend(r,s)):"linear"===o||"swap"===a||"future"===a?await this.privateLinearPostFutureTradeV1OrderCancel(this.extend(r,s)):await this.privateSpotDeleteOrderOrderId(this.extend(r,s));const c=void 0!==o||"swap"===a||"future"===a?n:this.safeValue(n,"result",{});return this.parseOrder(c,i)}async cancelAllOrders(e=void 0,t={}){await this.loadMarkets();const s={};let i,r,a,o;void 0!==e&&(i=this.market(e),s.symbol=i.id),[r,t]=this.handleMarketTypeAndParams("cancelAllOrders",i,t),[a,t]=this.handleSubTypeAndParams("cancelAllOrders",i,t);const n=this.safeValue(t,"stop"),d=this.safeValue(t,"stopLossTakeProfit");if(n)t=this.omit(t,"stop"),o="inverse"===a?await this.privateInversePostFutureTradeV1EntrustCancelAllPlan(this.extend(s,t)):await this.privateLinearPostFutureTradeV1EntrustCancelAllPlan(this.extend(s,t));else if(d)t=this.omit(t,"stopLossTakeProfit"),o="inverse"===a?await this.privateInversePostFutureTradeV1EntrustCancelAllProfitStop(this.extend(s,t)):await this.privateLinearPostFutureTradeV1EntrustCancelAllProfitStop(this.extend(s,t));else if("inverse"===a)o=await this.privateInversePostFutureTradeV1OrderCancelAll(this.extend(s,t));else if("linear"===a||"swap"===r||"future"===r)o=await this.privateLinearPostFutureTradeV1OrderCancelAll(this.extend(s,t));else{let e;[e,t]=this.handleMarginModeAndParams("cancelAllOrders",t);const i=void 0!==e?"LEVER":"SPOT";s.bizType=i,o=await this.privateSpotDeleteOpenOrder(this.extend(s,t))}return[this.safeOrder(o)]}async cancelOrders(e,t=void 0,s={}){await this.loadMarkets();const i={orderIds:e};let r,a;if(void 0!==t&&(r=this.market(t)),[a,s]=this.handleSubTypeAndParams("cancelOrders",r,s),void 0!==a)throw new o.NotSupported(this.id+" cancelOrders() does not support swap and future orders, only spot orders are accepted");const n=await this.privateSpotDeleteBatchOrder(this.extend(i,s));return[this.safeOrder(n)]}parseOrder(e,t=void 0){const s=this.safeString(e,"symbol"),i="result"in e||"positionSide"in e?"contract":"spot";t=this.safeMarket(s,t,void 0,i);const a=this.safeSymbol(s,t,void 0,i),o=this.safeInteger2(e,"time","createdTime"),n=this.safeNumber(e,"origQty"),d="spot"===i?n:r.Y.stringMul(this.numberToString(n),this.numberToString(t.contractSize)),h=this.safeNumber(e,"executedQty"),c="spot"===i?h:r.Y.stringMul(this.numberToString(h),this.numberToString(t.contractSize)),l=this.safeInteger(e,"updatedTime");return this.safeOrder({info:e,id:this.safeStringN(e,["orderId","result","cancelId","entrustId","profitId"]),clientOrderId:this.safeString(e,"clientOrderId"),timestamp:o,datetime:this.iso8601(o),lastTradeTimestamp:l,lastUpdateTimestamp:l,symbol:a,type:this.safeStringLower2(e,"type","orderType"),timeInForce:this.safeString(e,"timeInForce"),postOnly:void 0,side:this.safeStringLower2(e,"side","orderSide"),price:this.safeNumber(e,"price"),stopPrice:this.safeNumber(e,"stopPrice"),stopLoss:this.safeNumber(e,"triggerStopPrice"),takeProfit:this.safeNumber(e,"triggerProfitPrice"),amount:d,filled:c,remaining:this.safeNumber(e,"leavingQty"),cost:void 0,average:this.safeNumber(e,"avgPrice"),status:this.parseOrderStatus(this.safeString(e,"state")),fee:{currency:this.safeCurrencyCode(this.safeString(e,"feeCurrency")),cost:this.safeNumber(e,"fee")},trades:void 0},t)}parseOrderStatus(e){return this.safeString({NEW:"open",PARTIALLY_FILLED:"open",FILLED:"closed",CANCELED:"canceled",REJECTED:"rejected",EXPIRED:"expired",UNFINISHED:"open",NOT_TRIGGERED:"open",TRIGGERING:"open",TRIGGERED:"closed",USER_REVOCATION:"canceled",PLATFORM_REVOCATION:"rejected",HISTORY:"expired"},e,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a,n,d,h;if(void 0!==e&&(a=this.currency(e)),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s),[n,i]=this.handleMarketTypeAndParams("fetchLedger",void 0,i),[d,i]=this.handleSubTypeAndParams("fetchLedger",void 0,i),"inverse"===d)h=await this.privateInverseGetFutureUserV1BalanceBills(this.extend(r,i));else{if("linear"!==d&&"swap"!==n&&"future"!==n)throw new o.NotSupported(this.id+" fetchLedger() does not support spot transactions, only swap and future wallet transactions are supported");h=await this.privateLinearGetFutureUserV1BalanceBills(this.extend(r,i))}const c=this.safeValue(h,"result",{}),l=this.safeValue(c,"items",[]);return this.parseLedger(l,a,t,s)}parseLedgerEntry(e,t=void 0){const s="ADD"===this.safeString(e,"side")?"in":"out",i=this.safeString(e,"coin"),r=this.safeInteger(e,"createdTime");return{id:this.safeString(e,"id"),direction:s,account:void 0,referenceId:void 0,referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:this.safeCurrencyCode(i,t),amount:this.safeNumber(e,"amount"),timestamp:r,datetime:this.iso8601(r),before:void 0,after:this.safeNumber(e,"afterAmount"),status:void 0,fee:{currency:void 0,cost:void 0},info:e}}parseLedgerEntryType(e){return this.safeString({EXCHANGE:"transfer",CLOSE_POSITION:"trade",TAKE_OVER:"trade",MERGE:"trade",QIANG_PING_MANAGER:"fee",FUND:"fee",FEE:"fee",ADL:"auto-deleveraging"},e,e)}async fetchDepositAddress(e,t={}){let s;await this.loadMarkets(),[s,t]=this.handleNetworkCodeAndParams(t);const i=this.currency(e),r=this.networkCodeToId(s,e);this.checkRequiredArgument("fetchDepositAddress",r,"network");const a={currency:i.id,chain:r},o=await this.privateSpotGetDepositAddress(this.extend(a,t)),n=this.safeValue(o,"result",{});return this.parseDepositAddress(n,i)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"address");return this.checkAddress(s),{currency:this.safeCurrencyCode(void 0,t),address:s,tag:this.safeString(e,"memo"),network:void 0,info:e}}async fetchDeposits(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=await this.privateSpotGetDepositHistory(this.extend(r,i)),n=this.safeValue(o,"result",{}),d=this.safeValue(n,"items",[]);return this.parseTransactions(d,a,t,s,i)}async fetchWithdrawals(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};let a;void 0!==e&&(a=this.currency(e),r.currency=a.id),void 0!==t&&(r.startTime=t),void 0!==s&&(r.limit=s);const o=await this.privateSpotGetWithdrawHistory(this.extend(r,i)),n=this.safeValue(o,"result",{}),d=this.safeValue(n,"items",[]);return this.parseTransactions(d,a,t,s,i)}async withdraw(e,t,s,i=void 0,r={}){this.checkAddress(s),await this.loadMarkets();const a=this.currency(e);let o;[i,r]=this.handleWithdrawTagAndParams(i,r),[o,r]=this.handleNetworkCodeAndParams(r);const n=this.safeValue(this.options,"networks",{}),d=this.safeString2(n,o,e,e),h={currency:a.id,chain:d,amount:this.currencyToPrecision(e,t),address:s};void 0!==i&&(h.memo=i);const c=await this.privateSpotPostWithdraw(this.extend(h,r)),l=this.safeValue(c,"result",{});return this.parseTransaction(l,a)}parseTransaction(e,t=void 0){const s="fromAddr"in e?"deposit":"withdraw",i=this.safeInteger(e,"createdTime"),r=this.safeString(e,"address"),a=this.safeString(e,"memo"),o=this.safeCurrencyCode(this.safeString(e,"currency"),t),n=this.safeNumber(e,"fee"),d=void 0!==n?o:void 0,h=this.safeString(e,"chain");return{info:e,id:this.safeString(e,"id"),txid:this.safeString(e,"transactionId"),timestamp:i,datetime:this.iso8601(i),updated:void 0,addressFrom:this.safeString(e,"fromAddr"),addressTo:r,address:r,tagFrom:void 0,tagTo:void 0,tag:a,type:s,amount:this.safeNumber(e,"amount"),currency:o,network:this.networkIdToCode(h,o),status:this.parseTransactionStatus(this.safeString(e,"status")),comment:a,fee:{currency:d,cost:n,rate:void 0},internal:void 0}}parseTransactionStatus(e){return this.safeString({SUBMIT:"pending",REVIEW:"pending",AUDITED:"pending",PENDING:"pending",CANCEL:"canceled",FAIL:"failed",SUCCESS:"ok"},e,e)}async setLeverage(e,t=void 0,s={}){if(void 0===t)throw new o.ArgumentsRequired(this.id+" setLeverage() requires a symbol argument");const i=this.safeString(s,"positionSide");if(this.checkRequiredArgument("setLeverage",i,"positionSide",["LONG","SHORT"]),e<1||e>125)throw new o.BadRequest(this.id+" setLeverage() leverage should be between 1 and 125");await this.loadMarkets();const r=this.market(t);if(!r.contract)throw new o.BadSymbol(this.id+" setLeverage() supports contract markets only");const a={symbol:r.id,positionSide:i,leverage:e};let n,d;return[n,s]=this.handleSubTypeAndParams("setLeverage",r,s),d="inverse"===n?await this.privateInversePostFutureUserV1PositionAdjustLeverage(this.extend(a,s)):await this.privateLinearPostFutureUserV1PositionAdjustLeverage(this.extend(a,s)),d}async addMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"ADD",s)}async reduceMargin(e,t,s={}){return await this.modifyMarginHelper(e,t,"SUB",s)}async modifyMarginHelper(e,t,s,i={}){const r=this.safeString(i,"positionSide");this.checkRequiredArgument("setLeverage",r,"positionSide",["LONG","SHORT"]),await this.loadMarkets();const a=this.market(e),o={symbol:a.id,margin:t,type:s,positionSide:r};let n,d;return[n,i]=this.handleSubTypeAndParams("modifyMarginHelper",a,i),d="inverse"===n?await this.privateInversePostFutureUserV1PositionMargin(this.extend(o,i)):await this.privateLinearPostFutureUserV1PositionMargin(this.extend(o,i)),this.parseMarginModification(d,a)}parseMarginModification(e,t=void 0){return{info:e,type:void 0,amount:void 0,code:void 0,symbol:this.safeSymbol(void 0,t),status:void 0,marginMode:void 0,total:void 0,timestamp:void 0,datetime:void 0}}async fetchLeverageTiers(e=void 0,t={}){let s,i;await this.loadMarkets(),[s,t]=this.handleSubTypeAndParams("fetchLeverageTiers",void 0,t),i="inverse"===s?await this.publicInverseGetFutureMarketV1PublicLeverageBracketList(t):await this.publicLinearGetFutureMarketV1PublicLeverageBracketList(t);const r=this.safeValue(i,"result",[]);return e=this.marketSymbols(e),this.parseLeverageTiers(r,e,"symbol")}parseLeverageTiers(e,t=void 0,s=void 0){const i={};for(let s=0;s<e.length;s++){const r=e[s],a=this.safeString(r,"symbol"),o=this.safeMarket(a,void 0,"_","contract"),n=this.safeSymbol(a,o);void 0!==t?this.inArray(n,t)&&(i[n]=this.parseMarketLeverageTiers(r,o)):i[n]=this.parseMarketLeverageTiers(e[s],o)}return i}async fetchMarketLeverageTiers(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a;[r,t]=this.handleSubTypeAndParams("fetchMarketLeverageTiers",s,t),a="inverse"===r?await this.publicInverseGetFutureMarketV1PublicLeverageBracketDetail(this.extend(i,t)):await this.publicLinearGetFutureMarketV1PublicLeverageBracketDetail(this.extend(i,t));const o=this.safeValue(a,"result",{});return this.parseMarketLeverageTiers(o,s)}parseMarketLeverageTiers(e,t=void 0){const s=[],i=this.safeValue(e,"leverageBrackets",[]);for(let r=0;r<i.length;r++){const a=i[r],o=this.safeString(e,"symbol");t=this.safeMarket(o,t,"_","contract"),s.push({tier:this.safeInteger(a,"bracket"),currency:t.settle,minNotional:this.safeNumber(i[r-1],"maxNominalValue",0),maxNotional:this.safeNumber(a,"maxNominalValue"),maintenanceMarginRate:this.safeNumber(a,"maintMarginRate"),maxLeverage:this.safeNumber(a,"maxLeverage"),info:a})}return s}async fetchFundingRateHistory(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new o.ArgumentsRequired(this.id+" fetchFundingRateHistory() requires a symbol argument");await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new o.BadSymbol(this.id+" fetchFundingRateHistory() supports swap contracts only");const a={symbol:r.id};let n,d;void 0!==s&&(a.limit=s),[n,i]=this.handleSubTypeAndParams("fetchFundingRateHistory",r,i),d="inverse"===n?await this.publicInverseGetFutureMarketV1PublicQFundingRateRecord(this.extend(a,i)):await this.publicLinearGetFutureMarketV1PublicQFundingRateRecord(this.extend(a,i));const h=this.safeValue(d,"result",{}),c=this.safeValue(h,"items",[]),l=[];for(let e=0;e<c.length;e++){const t=c[e],s=this.safeString(t,"symbol"),i=this.safeSymbol(s,r),a=this.safeInteger(t,"createdTime");l.push({info:t,symbol:i,fundingRate:this.safeNumber(t,"fundingRate"),timestamp:a,datetime:this.iso8601(a)})}const u=this.sortBy(l,"timestamp");return this.filterBySymbolSinceLimit(u,r.symbol,t,s)}async fetchFundingRate(e,t={}){await this.loadMarkets();const s=this.market(e);if(!s.swap)throw new o.BadSymbol(this.id+" fetchFundingRate() supports swap contracts only");const i={symbol:s.id};let r,a;[r,t]=this.handleSubTypeAndParams("fetchFundingRate",s,t),a="inverse"===r?await this.publicInverseGetFutureMarketV1PublicQFundingRate(this.extend(i,t)):await this.publicLinearGetFutureMarketV1PublicQFundingRate(this.extend(i,t));const n=this.safeValue(a,"result",{});return this.parseFundingRate(n,s)}parseFundingRate(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"_","swap"),r=this.safeInteger(e,"nextCollectionTime");return{info:e,symbol:i,markPrice:void 0,indexPrice:void 0,interestRate:void 0,estimatedSettlePrice:void 0,timestamp:void 0,datetime:void 0,fundingRate:this.safeNumber(e,"fundingRate"),fundingTimestamp:r,fundingDatetime:this.iso8601(r),nextFundingRate:void 0,nextFundingTimestamp:void 0,nextFundingDatetime:void 0,previousFundingRate:void 0,previousFundingTimestamp:void 0,previousFundingDatetime:void 0}}async fetchFundingHistory(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e);if(!r.swap)throw new o.BadSymbol(this.id+" fetchFundingHistory() supports swap contracts only");const a={symbol:r.id};let n,d;void 0!==t&&(a.startTime=t),void 0!==s&&(a.limit=s),[n,i]=this.handleSubTypeAndParams("fetchFundingHistory",r,i),d="inverse"===n?await this.privateInverseGetFutureUserV1BalanceFundingRateList(this.extend(a,i)):await this.privateLinearGetFutureUserV1BalanceFundingRateList(this.extend(a,i));const h=this.safeValue(d,"result",{}),c=this.safeValue(h,"items",[]),l=[];for(let e=0;e<c.length;e++){const t=c[e];l.push(this.parseFundingHistory(t,r))}const u=this.sortBy(l,"timestamp");return this.filterBySinceLimit(u,t,s)}parseFundingHistory(e,t=void 0){const s=this.safeString(e,"symbol"),i=this.safeSymbol(s,t,"_","swap"),r=this.safeString(e,"coin"),a=this.safeCurrencyCode(r),o=this.safeInteger(e,"createdTime");return{info:e,symbol:i,code:a,timestamp:o,datetime:this.iso8601(o),id:this.safeString(e,"id"),amount:this.safeNumber(e,"cast")}}async fetchPosition(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id};let r,a;[r,t]=this.handleSubTypeAndParams("fetchPosition",s,t),a="inverse"===r?await this.privateInverseGetFutureUserV1PositionList(this.extend(i,t)):await this.privateLinearGetFutureUserV1PositionList(this.extend(i,t));const o=this.safeValue(a,"result",[]);for(let e=0;e<o.length;e++){const t=o[e],s=this.safeString(t,"symbol"),i=this.safeMarket(s,void 0,void 0,"contract");if("0"!==this.safeString(t,"positionSize"))return this.parsePosition(t,i)}}async fetchPositions(e=void 0,t={}){let s,i;await this.loadMarkets(),[s,t]=this.handleSubTypeAndParams("fetchPositions",void 0,t),i="inverse"===s?await this.privateInverseGetFutureUserV1PositionList(t):await this.privateLinearGetFutureUserV1PositionList(t);const r=this.safeValue(i,"result",[]),a=[];for(let e=0;e<r.length;e++){const t=r[e],s=this.safeString(t,"symbol"),i=this.safeMarket(s,void 0,void 0,"contract");a.push(this.parsePosition(t,i))}return this.filterByArrayPositions(a,"symbol",e,!1)}parsePosition(e,t=void 0){const s=this.safeString(e,"symbol");t=this.safeMarket(s,t,void 0,"contract");const i=this.safeSymbol(s,t,void 0,"contract"),r="CROSSED"===this.safeString(e,"positionType")?"cross":"isolated",a=this.safeNumber(e,"isolatedMargin");return this.safePosition({info:e,id:void 0,symbol:i,timestamp:void 0,datetime:void 0,hedged:void 0,side:this.safeStringLower(e,"positionSide"),contracts:this.safeNumber(e,"positionSize"),contractSize:t.contractSize,entryPrice:this.safeNumber(e,"entryPrice"),markPrice:void 0,notional:void 0,leverage:this.safeInteger(e,"leverage"),collateral:a,initialMargin:a,maintenanceMargin:void 0,initialMarginPercentage:void 0,maintenanceMarginPercentage:void 0,unrealizedPnl:void 0,liquidationPrice:void 0,marginMode:r,percentage:void 0,marginRatio:void 0})}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o=this.safeValue(this.options,"accountsById"),n=this.safeString(o,s,s),d=this.safeString(o,i,i),h=this.currencyToPrecision(e,t),c={bizId:this.uuid(),currency:a.id,amount:h,from:n,to:d},l=await this.privateSpotPostBalanceTransfer(this.extend(c,r));return this.parseTransfer(l,a)}parseTransfer(e,t=void 0){return{info:e,id:this.safeString(e,"result"),timestamp:void 0,datetime:void 0,currency:void 0,amount:void 0,fromAccount:void 0,toAccount:void 0,status:void 0}}handleErrors(e,t,s,i,r,a,n,d,h){const c=this.safeStringUpper2(n,"msgInfo","mc");if(void 0!==c&&"SUCCESS"!==c){const e=this.id+" "+a,t=this.safeValue(n,"error",{}),s=this.safeString(n,"mc"),i=this.safeString(t,"code",s),r=this.safeString(n,"msgInfo"),d=this.safeString(t,"msg",r);throw this.throwExactlyMatchedException(this.exceptions.exact,i,e),this.throwBroadlyMatchedException(this.exceptions.broad,d,e),new o.ExchangeError(e)}}sign(e,t=[],s="GET",i={},r=void 0,a=void 0){const o="private"===t[0],d=t[1],h="/"+this.implodeParams(e,i);let c;c="spot"===d||"user"===d?o?"/"+this.version+h:"/"+this.version+"/public"+h:h;let l=this.urls.api[d]+c;const u=this.omit(i,this.extractParams(e)),p=this.urlencode(this.keysort(u));if(r={"Content-Type":"application/json"},o){this.checkRequiredCredentials();const t=this.safeString(this.options,"recvWindow"),i=this.safeString(u,"recvWindow",t),o=this.numberToString(this.nonce());if(a=u,"/v4/order"===c||"/future/trade/v1/order/create"===c||"/future/trade/v1/entrust/create-plan"===c||"/future/trade/v1/entrust/create-profit"===c||"/future/trade/v1/order/create-batch"===c){const e="CCXT";c.indexOf("future")>-1?a.clientMedia=e:a.media=e}const h="GET"===s||"order/{orderId}"===e||"ws-token"===e;let f;a=h?void 0:this.json(a),"spot"===d||"user"===d?(f="xt-validate-algorithms=HmacSHA256&xt-validate-appkey="+this.apiKey+"&xt-validate-recvwindow="+i+"&xt-validate-timestamp="+o,h?p?(l+="?"+p,f+="#"+s+"#"+c+"#"+this.rawencode(this.keysort(u))):f+="#"+s+"#"+c:f+="#"+s+"#"+c+"#"+a,r["xt-validate-algorithms"]="HmacSHA256",r["xt-validate-recvwindow"]=i):(f="xt-validate-appkey="+this.apiKey+"&xt-validate-timestamp="+o,"GET"===s?p?(l+="?"+p,f+="#"+c+"#"+p):f+="#"+c:f+="#"+c+"#"+a);const m=this.hmac(this.encode(f),this.encode(this.secret),n.s);r["xt-validate-appkey"]=this.apiKey,r["xt-validate-timestamp"]=o,r["xt-validate-signature"]=m}else p&&(l+="?"+p);return{url:l,method:s,body:a,headers:r}}}},7469:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(3578),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"yobit",name:"YoBit",countries:["RU"],rateLimit:2e3,version:"3",pro:!1,has:{CORS:void 0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelOrder:!0,closeAllPositions:!1,closePosition:!1,createDepositAddress:!0,createMarketOrder:!1,createOrder:!0,createReduceOnlyOrder:!1,createStopLimitOrder:!1,createStopMarketOrder:!1,createStopOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDepositAddress:!0,fetchDeposits:!1,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrder:!0,fetchOrderBook:!0,fetchOrderBooks:!0,fetchPosition:!1,fetchPositionHistory:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsForSymbol:!1,fetchPositionsHistory:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!0,fetchTransactions:!1,fetchTransfer:!1,fetchTransfers:!1,fetchWithdrawals:!1,reduceMargin:!1,setLeverage:!1,setMarginMode:!1,setPositionMode:!1,transfer:!1,withdraw:!0,ws:!1},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg",api:{public:"https://yobit.net/api",private:"https://yobit.net/tapi"},www:"https://www.yobit.net",doc:"https://www.yobit.net/en/api/",fees:"https://www.yobit.net/en/fees/"},api:{public:{get:{"depth/{pair}":1,info:1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{ActiveOrders:1,CancelOrder:1,GetDepositAddress:1,getInfo:1,OrderInfo:1,Trade:1,TradeHistory:1,WithdrawCoinsToAddress:1}}},fees:{trading:{maker:.002,taker:.002},funding:{withdraw:{}}},commonCurrencies:{AIR:"AirCoin",ANI:"ANICoin",ANT:"AntsCoin",ATMCHA:"ATM",ASN:"Ascension",AST:"Astral",ATM:"Autumncoin",AUR:"AuroraCoin",BAB:"Babel",BAN:"BANcoin",BCC:"BCH",BCS:"BitcoinStake",BITS:"Bitstar",BLN:"Bulleon",BNS:"Benefit Bonus Coin",BOT:"BOTcoin",BON:"BONES",BPC:"BitcoinPremium",BST:"BitStone",BTS:"Bitshares2",CAT:"BitClave",CBC:"CryptoBossCoin",CMT:"CometCoin",COIN:"Coin.com",COV:"Coven Coin",COVX:"COV",CPC:"Capricoin",CREDIT:"Creditbit",CS:"CryptoSpots",DCT:"Discount",DFT:"DraftCoin",DGD:"DarkGoldCoin",DIRT:"DIRTY",DROP:"FaucetCoin",DSH:"DASH",EGC:"EverGreenCoin",EGG:"EggCoin",EKO:"EkoCoin",ENTER:"ENTRC",EPC:"ExperienceCoin",ESC:"EdwardSnowden",EUROPE:"EUROP",EXT:"LifeExtension",FUND:"FUNDChains",FUNK:"FUNKCoin",FX:"FCoin",GCC:"GlobalCryptocurrency",GEN:"Genstake",GENE:"Genesiscoin",GMR:"Gimmer",GOLD:"GoldMint",GOT:"Giotto Coin",GSX:"GlowShares",GT:"GTcoin",HTML5:"HTML",HYPERX:"HYPER",ICN:"iCoin",INSANE:"INSN",JNT:"JointCoin",JPC:"JupiterCoin",JWL:"Jewels",KNC:"KingN Coin",LBTCX:"LiteBitcoin",LIZI:"LiZi",LOC:"LocoCoin",LOCX:"LOC",LUNYR:"LUN",LUN:"LunarCoin",LUNA:"Luna Coin",MASK:"Yobit MASK",MDT:"Midnight",MEME:"Memez Token",MIS:"MIScoin",MM:"MasterMint",NAV:"NavajoCoin",NBT:"NiceBytes",OMG:"OMGame",ONX:"Onix",PAC:"$PAC",PLAY:"PlayCoin",PIVX:"Darknet",PURE:"PurePOS",PUTIN:"PutinCoin",SPACE:"Spacecoin",STK:"StakeCoin",SUB:"Subscriptio",PAY:"EPAY",PLC:"Platin Coin",RAI:"RaiderCoin",RCN:"RCoin",REP:"Republicoin",RUR:"RUB",SBTC:"Super Bitcoin",SMC:"SmartCoin",SOLO:"SoloCoin",SOUL:"SoulCoin",STAR:"StarCoin",SUPER:"SuperCoin",TNS:"Transcodium",TTC:"TittieCoin",UNI:"Universe",UST:"Uservice",VOL:"VolumeCoin",XIN:"XINCoin",XMT:"SummitCoin",XRA:"Ratecoin",BCHN:"BSV"},options:{maxUrlLength:2048,fetchOrdersRequiresSymbol:!0,networks:{ETH:"ERC20",TRX:"TRC20",BSC:"BEP20"}},precisionMode:o.kb,exceptions:{exact:{803:r.InvalidOrder,804:r.InvalidOrder,805:r.InvalidOrder,806:r.InvalidOrder,807:r.InvalidOrder,831:r.InsufficientFunds,832:r.InsufficientFunds,833:r.OrderNotFound},broad:{"Invalid pair name":r.ExchangeError,"invalid api key":r.AuthenticationError,"invalid sign":r.AuthenticationError,"api key dont have trade permission":r.AuthenticationError,"invalid parameter":r.InvalidOrder,"invalid order":r.InvalidOrder,"The given order has already been cancelled":r.InvalidOrder,"Requests too often":r.DDoSProtection,"not available":r.ExchangeNotAvailable,"data unavailable":r.ExchangeNotAvailable,"external service unavailable":r.ExchangeNotAvailable,"Total transaction amount":r.InvalidOrder,"The given order has already been closed and cannot be cancelled":r.InvalidOrder,"Insufficient funds":r.InsufficientFunds,"invalid key":r.AuthenticationError,"invalid nonce":r.InvalidNonce,"Total order amount is less than minimal amount":r.InvalidOrder,"Rate Limited":r.RateLimitExceeded}},orders:{}})}parseBalance(e){const t=this.safeDict(e,"return",{}),s=this.safeInteger(t,"server_time"),i={info:e,timestamp:s,datetime:this.iso8601(s)},r=this.safeDict(t,"funds",{}),a=this.safeDict(t,"funds_incl_orders",{}),o=Object.keys(this.extend(r,a));for(let e=0;e<o.length;e++){const t=o[e],s=this.safeCurrencyCode(t),n=this.account();n.free=this.safeString(r,t),n.total=this.safeString(a,t),i[s]=n}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchMarkets(e={}){const t=await this.publicGetInfo(e),s=this.safeDict(t,"pairs",{}),i=Object.keys(s),r=[];for(let e=0;e<i.length;e++){const t=i[e],o=s[t],[n,d]=t.split("_");let h=n.toUpperCase(),c=d.toUpperCase();h=this.safeCurrencyCode(h),c=this.safeCurrencyCode(c);const l=this.safeInteger(o,"hidden");let u=this.safeString(o,"fee");u=a.Y.stringDiv(u,"100"),r.push({id:t,symbol:h+"/"+c,base:h,quote:c,settle:void 0,baseId:n,quoteId:d,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:0===l,contract:!1,linear:void 0,inverse:void 0,taker:this.parseNumber(u),maker:this.parseNumber(u),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places"))),price:this.parseNumber(this.parsePrecision(this.safeString(o,"decimal_places")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(o,"min_amount"),max:this.safeNumber(o,"max_amount")},price:{min:this.safeNumber(o,"min_price"),max:this.safeNumber(o,"max_price")},cost:{min:this.safeNumber(o,"min_total"),max:void 0}},created:void 0,info:o})}return r}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),a={pair:i.id};void 0!==t&&(a.limit=t);const o=await this.publicGetDepthPair(this.extend(a,s));if(!(i.id in o))throw new r.ExchangeError(this.id+" "+i.symbol+" order book is empty or not available");const n=o[i.id];return this.parseOrderBook(n,e)}async fetchOrderBooks(e=void 0,t=void 0,s={}){let i;if(await this.loadMarkets(),void 0===e){if(i=this.ids.join("-"),i.length>2048){const e=this.ids.length;throw new r.ExchangeError(this.id+" fetchOrderBooks() has "+e.toString()+" symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks")}}else i=this.marketIds(e),i=i.join("-");const a={pair:i};void 0!==t&&(a.limit=t);const o=await this.publicGetDepthPair(this.extend(a,s)),n={};i=Object.keys(o);for(let e=0;e<i.length;e++){const t=i[e],s=this.safeSymbol(t);n[s]=this.parseOrderBook(o[t],s)}return n}parseTicker(e,t=void 0){const s=this.safeTimestamp(e,"updated"),i=this.safeString(e,"last");return this.safeTicker({symbol:this.safeSymbol(void 0,t),timestamp:s,datetime:this.iso8601(s),high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"buy"),bidVolume:void 0,ask:this.safeString(e,"sell"),askVolume:void 0,vwap:void 0,open:void 0,close:i,last:i,previousClose:void 0,change:void 0,percentage:void 0,average:this.safeString(e,"avg"),baseVolume:this.safeString(e,"vol_cur"),quoteVolume:this.safeString(e,"vol"),info:e},t)}async fetchTickersHelper(e,t={}){const s={pair:e},i=await this.publicGetTickerPair(this.extend(s,t)),r={},a=Object.keys(i);for(let e=0;e<a.length;e++){const t=a[e],s=i[t],o=this.safeMarket(t);r[o.symbol]=this.parseTicker(s,o)}return r}async fetchTickers(e=void 0,t={}){let s;if([s,t]=this.handleParamBool(t,"all",!1),void 0===e&&!s)throw new r.ArgumentsRequired(this.id+' fetchTickers() requires "symbols" argument or use `params["all"] = true` to send multiple requests for all markets');await this.loadMarkets();const i=[],a=this.safeInteger(this.options,"maxUrlLength",2048);if(s){e=this.symbols;let s="";for(let e=0;e<this.ids.length;e++){s+=(""===s?"":"-")+this.ids[e],s.length>a&&(i.push(this.fetchTickersHelper(s,t)),s="")}""!==s&&i.push(this.fetchTickersHelper(s,t))}else{e=this.marketSymbols(e);const s=this.marketIds(e),o=s.length,n=s.join("-"),d=n.length+40;if(d>a)throw new r.ArgumentsRequired(this.id+" fetchTickers() is being requested for "+o.toString()+" markets (which has an URL length of "+d.toString()+" characters), but it exceedes max URL length ("+a.toString()+"), please pass limisted symbols array to fetchTickers to fit in one request");i.push(this.fetchTickersHelper(n,t))}const o=await Promise.all(i);let n={};for(let t=0;t<o.length;t++){const s=this.filterByArrayTickers(o[t],"symbol",e);n=this.extend(n,s)}return n}async fetchTicker(e,t={}){return(await this.fetchTickers([e],t))[e]}parseTrade(e,t=void 0){const s=this.safeTimestamp(e,"timestamp");let i=this.safeString(e,"type");"ask"===i?i="sell":"bid"===i&&(i="buy");const r=this.safeString2(e,"rate","price"),a=this.safeString2(e,"trade_id","tid"),o=this.safeString(e,"order_id"),n=this.safeString(e,"pair"),d=this.safeSymbol(n,t),h=this.safeString(e,"amount"),c=this.parseNumber(r),l=this.parseNumber(h),u="limit";let p;const f=this.safeNumber(e,"commission");if(void 0!==f){const t=this.safeString(e,"commissionCurrency");p={cost:f,currency:this.safeCurrencyCode(t)}}if(void 0!==this.safeString(e,"is_your_order")&&void 0===p){const e=this.calculateFee(d,u,i,l,c,"taker");p={currency:this.safeString(e,"currency"),cost:this.safeString(e,"cost"),rate:this.safeString(e,"rate")}}return this.safeTrade({id:a,order:o,timestamp:s,datetime:this.iso8601(s),symbol:d,type:u,side:i,takerOrMaker:void 0,price:r,amount:h,cost:void 0,fee:p,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};void 0!==s&&(a.limit=s);const o=await this.publicGetTradesPair(this.extend(a,i));if(Array.isArray(o)){if(0===o.length)return[]}const n=this.safeList(o,r.id,[]);return this.parseTrades(n,r,t,s)}async fetchTradingFees(e={}){await this.loadMarkets();const t=await this.publicGetInfo(e),s=this.safeDict(t,"pairs",{}),i=Object.keys(s),r={};for(let e=0;e<i.length;e++){const t=i[e],o=this.safeDict(s,t,{}),n=this.safeSymbol(t,void 0,"_"),d=this.safeString(o,"fee_buyer"),h=this.safeString(o,"fee_seller"),c=this.parseNumber(a.Y.stringDiv(d,"100")),l=this.parseNumber(a.Y.stringDiv(h,"100"));r[n]={info:o,symbol:n,taker:c,maker:l,percentage:!0,tierBased:!1}}return r}async createOrder(e,t,s,i,a=void 0,o={}){if("market"===t)throw new r.ExchangeError(this.id+" createOrder() allows limit orders only");await this.loadMarkets();const n=this.market(e),d={pair:n.id,type:s,amount:this.amountToPrecision(e,i),rate:this.priceToPrecision(e,a)},h=await this.privatePostTrade(this.extend(d,o)),c=this.safeDict(h,"return");return this.parseOrder(c,n)}async cancelOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},r=await this.privatePostCancelOrder(this.extend(i,s)),a=this.safeDict(r,"return",{});return this.parseOrder(a)}parseOrderStatus(e){return this.safeString({0:"open",1:"closed",2:"canceled",3:"open"},e,e)}parseOrder(e,t=void 0){let s=this.safeString2(e,"id","order_id"),i=this.parseOrderStatus(this.safeString(e,"status","open"));"0"===s&&(s=this.safeString(e,"init_order_id"),i="closed");const r=this.safeTimestamp2(e,"timestamp_created","server_time"),a=this.safeString(e,"pair"),o=this.safeSymbol(a,t),n=this.safeString(e,"start_amount"),d=this.safeString2(e,"amount","remains"),h=this.safeString(e,"received","0.0"),c=this.safeString(e,"rate"),l=this.safeString(e,"type");return this.safeOrder({info:e,id:s,clientOrderId:void 0,symbol:o,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,type:"limit",timeInForce:void 0,postOnly:void 0,side:l,price:c,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:n,remaining:d,filled:h,status:i,fee:undefined,average:void 0,trades:void 0},t)}async fetchOrder(e,t=void 0,s={}){await this.loadMarkets();const i={order_id:parseInt(e)},r=await this.privatePostOrderInfo(this.extend(i,s));e=e.toString();const a=this.safeDict(r,"return",{});return this.parseOrder(this.extend({id:e},a[e]))}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchOpenOrders() requires a symbol argument");await this.loadMarkets();const a={};if(void 0!==e){const t=this.market(e);a.pair=t.id}const o=await this.privatePostActiveOrders(this.extend(a,i)),n=this.safeDict(o,"return",{});return this.parseOrders(n,undefined,t,s)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){if(void 0===e)throw new r.ArgumentsRequired(this.id+" fetchMyTrades() requires a symbol argument");await this.loadMarkets();const a=this.market(e),o={pair:a.id};void 0!==s&&(o.count=s),void 0!==t&&(o.since=this.parseToInt(t/1e3));const n=await this.privatePostTradeHistory(this.extend(o,i)),d=this.safeDict(n,"return",{}),h=Object.keys(d),c=[];for(let e=0;e<h.length;e++){const t=h[e],s=this.parseTrade(this.extend(d[t],{trade_id:t}),a);c.push(s)}return this.filterBySymbolSinceLimit(c,a.symbol,t,s)}async createDepositAddress(e,t={}){const s=await this.fetchDepositAddress(e,this.extend({need_new:1},t)),i=this.safeString(s,"address");return this.checkAddress(i),{currency:e,address:i,tag:void 0,info:s.info}}async fetchDepositAddress(e,t={}){await this.loadMarkets();let s=this.currency(e).id;const i=this.safeDict(this.options,"networks",{});let r=this.safeStringUpper(t,"network");r=this.safeString(i,r,r),void 0!==r&&("ERC20"!==r&&(s+=r.toLowerCase()),t=this.omit(t,"network"));const a={coinName:s,need_new:0},o=await this.privatePostGetDepositAddress(this.extend(a,t)),n=this.safeString(o.return,"address");return this.checkAddress(n),{id:void 0,currency:e,address:n,tag:void 0,network:void 0,info:o,txid:void 0,type:void 0,amount:void 0,status:void 0,timestamp:void 0,datetime:void 0,addressFrom:void 0,addressTo:void 0,tagFrom:void 0,tagTo:void 0,updated:void 0,comment:void 0,fee:{currency:void 0,cost:void 0,rate:void 0}}}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o={coinName:this.currency(e).id,amount:t,address:s};if(void 0!==i)throw new r.ExchangeError(this.id+" withdraw() does not support the tag argument yet due to a lack of docs on withdrawing with tag/memo on behalf of the exchange.");return{info:await this.privatePostWithdrawCoinsToAddress(this.extend(o,a)),id:void 0,txid:void 0,type:void 0,currency:void 0,network:void 0,amount:void 0,status:void 0,timestamp:void 0,datetime:void 0,address:void 0,addressFrom:void 0,addressTo:void 0,tag:void 0,tagFrom:void 0,tagTo:void 0,updated:void 0,comment:void 0,fee:{currency:void 0,cost:void 0,rate:void 0}}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api[t];const d=this.omit(i,this.extractParams(e));if("private"===t){this.checkRequiredCredentials();const t=this.nonce();a=this.urlencode(this.extend({nonce:t,method:e},d));const s=this.hmac(this.encode(a),this.encode(this.secret),n.Zf);r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:s}}else"public"===t?(o+="/"+this.version+"/"+this.implodeParams(e,i),Object.keys(d).length&&(o+="?"+this.urlencode(d))):(o+="/"+this.implodeParams(e,i),"GET"===s?Object.keys(d).length&&(o+="?"+this.urlencode(d)):Object.keys(d).length&&(a=this.json(d),r={"Content-Type":"application/json"}));return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n&&"success"in n){let e=this.safeValue(n,"success");if("string"==typeof e&&(e="true"===e||"1"===e),!e){const e=this.safeString(n,"code"),t=this.safeString(n,"error"),s=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions.exact,e,s),this.throwExactlyMatchedException(this.exceptions.exact,t,s),this.throwBroadlyMatchedException(this.exceptions.broad,t,s),new r.ExchangeError(s)}}}}},1530:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(8291),r=s(2079),a=s(5147),o=s(1579),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"zaif",name:"Zaif",countries:["JP"],rateLimit:100,version:"1",has:{CORS:void 0,spot:!0,margin:void 0,swap:!1,future:!1,option:!1,cancelOrder:!0,createMarketOrder:!1,createOrder:!0,fetchBalance:!0,fetchClosedOrders:!0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchOpenInterestHistory:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,withdraw:!0},urls:{logo:"https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",api:{rest:"https://api.zaif.jp"},www:"https://zaif.jp",doc:["https://techbureau-api-document.readthedocs.io/ja/latest/index.html","https://corp.zaif.jp/api-docs","https://corp.zaif.jp/api-docs/api_links","https://www.npmjs.com/package/zaif.jp","https://github.com/you21979/node-zaif"],fees:"https://zaif.jp/fee?lang=en"},fees:{trading:{percentage:!0,taker:this.parseNumber("0.001"),maker:this.parseNumber("0")}},api:{public:{get:{"depth/{pair}":1,"currencies/{pair}":1,"currencies/all":1,"currency_pairs/{pair}":1,"currency_pairs/all":1,"last_price/{pair}":1,"ticker/{pair}":1,"trades/{pair}":1}},private:{post:{active_orders:5,cancel_order:5,deposit_history:5,get_id_info:5,get_info:10,get_info2:5,get_personal_info:5,trade:5,trade_history:50,withdraw:5,withdraw_history:5}},ecapi:{post:{createInvoice:1,getInvoice:1,getInvoiceIdsByOrderNumber:1,cancelInvoice:1}},tlapi:{post:{get_positions:66,position_history:66,active_positions:5,create_position:33,change_position:33,cancel_position:33}},fapi:{get:{"groups/{group_id}":1,"last_price/{group_id}/{pair}":1,"ticker/{group_id}/{pair}":1,"trades/{group_id}/{pair}":1,"depth/{group_id}/{pair}":1}}},options:{},precisionMode:o.kb,exceptions:{exact:{"unsupported currency_pair":r.BadRequest},broad:{}}})}async fetchMarkets(e={}){const t=await this.publicGetCurrencyPairsAll(e);return this.parseMarkets(t)}parseMarket(e){const t=this.safeString(e,"currency_pair"),s=this.safeString(e,"name"),[i,r]=s.split("/"),a=this.safeCurrencyCode(i),o=this.safeCurrencyCode(r);return{id:t,symbol:a+"/"+o,base:a,quote:o,settle:void 0,baseId:i,quoteId:r,settleId:void 0,type:"spot",spot:!0,margin:void 0,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,contractSize:void 0,expiry:void 0,expiryDatetime:void 0,strike:void 0,optionType:void 0,precision:{amount:this.safeNumber(e,"item_unit_step"),price:this.parseNumber(this.parsePrecision(this.safeString(e,"aux_unit_point")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(e,"item_unit_min"),max:void 0},price:{min:this.safeNumber(e,"aux_unit_min"),max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}parseBalance(e){const t=this.safeValue(e,"return",{}),s=this.safeValue(t,"deposit"),i={info:e,timestamp:void 0,datetime:void 0},r=this.safeValue(t,"funds",{}),a=Object.keys(r);for(let e=0;e<a.length;e++){const t=a[e],o=this.safeCurrencyCode(t),n=this.safeString(r,t),d=this.account();d.free=n,d.total=n,void 0!==s&&t in s&&(d.total=this.safeString(s,t)),i[o]=d}return this.safeBalance(i)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.privatePostGetInfo(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={pair:i.id},a=await this.publicGetDepthPair(this.extend(r,s));return this.parseOrderBook(a,i.symbol)}parseTicker(e,t=void 0){const s=this.safeSymbol(void 0,t),i=this.safeString(e,"vwap"),r=this.safeString(e,"volume"),o=a.Y.stringMul(r,i),n=this.safeString(e,"last");return this.safeTicker({symbol:s,timestamp:void 0,datetime:void 0,high:this.safeString(e,"high"),low:this.safeString(e,"low"),bid:this.safeString(e,"bid"),bidVolume:void 0,ask:this.safeString(e,"ask"),askVolume:void 0,vwap:i,open:void 0,close:n,last:n,previousClose:void 0,change:void 0,percentage:void 0,average:void 0,baseVolume:r,quoteVolume:o,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={pair:s.id},r=await this.publicGetTickerPair(this.extend(i,t));return this.parseTicker(r,s)}parseTrade(e,t=void 0){let s=this.safeString(e,"trade_type");s="bid"===s?"buy":"sell";const i=this.safeTimestamp(e,"date"),r=this.safeString2(e,"id","tid"),a=this.safeString(e,"price"),o=this.safeString(e,"amount"),n=this.safeString(e,"currency_pair"),d=this.safeSymbol(n,t,"_");return this.safeTrade({id:r,info:e,timestamp:i,datetime:this.iso8601(i),symbol:d,type:void 0,side:s,order:void 0,takerOrMaker:void 0,price:a,amount:o,cost:void 0,fee:void 0},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={pair:r.id};let o=await this.publicGetTradesPair(this.extend(a,i));if(1===o.length){const e=o[0];Object.keys(e).length||(o=[])}return this.parseTrades(o,r,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){if(await this.loadMarkets(),"limit"!==t)throw new r.ExchangeError(this.id+" createOrder() allows limit orders only");const n=this.market(e),d={currency_pair:n.id,action:"buy"===s?"bid":"ask",amount:i,price:a},h=await this.privatePostTrade(this.extend(d,o));return this.safeOrder({info:h,id:h.return.order_id.toString()},n)}async cancelOrder(e,t=void 0,s={}){const i={order_id:e},r=await this.privatePostCancelOrder(this.extend(i,s)),a=this.safeDict(r,"return");return this.parseOrder(a)}parseOrder(e,t=void 0){let s=this.safeString(e,"action");s="bid"===s?"buy":"sell";const i=this.safeTimestamp(e,"timestamp"),r=this.safeString(e,"currency_pair"),a=this.safeSymbol(r,t,"_"),o=this.safeString(e,"price"),n=this.safeString(e,"amount"),d=this.safeString2(e,"id","order_id");return this.safeOrder({id:d,clientOrderId:void 0,timestamp:i,datetime:this.iso8601(i),lastTradeTimestamp:void 0,status:"open",symbol:a,type:"limit",timeInForce:void 0,postOnly:void 0,side:s,price:o,stopPrice:void 0,triggerPrice:void 0,cost:void 0,amount:n,filled:void 0,remaining:void 0,trades:void 0,fee:void 0,info:e,average:void 0},t)}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.currency_pair=r.id);const o=await this.privatePostActiveOrders(this.extend(a,i));return this.parseOrders(o.return,r,t,s)}async fetchClosedOrders(e=void 0,t=void 0,s=void 0,i={}){let r;await this.loadMarkets();const a={};void 0!==e&&(r=this.market(e),a.currency_pair=r.id);const o=await this.privatePostTradeHistory(this.extend(a,i));return this.parseOrders(o.return,r,t,s)}async withdraw(e,t,s,i=void 0,a={}){[i,a]=this.handleWithdrawTagAndParams(i,a),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e);if("JPY"===e)throw new r.ExchangeError(this.id+" withdraw() does not allow "+e+" withdrawals");const n={currency:o.id,amount:t,address:s};void 0!==i&&(n.message=i);const d=await this.privatePostWithdraw(this.extend(n,a)),h=this.safeDict(d,"return");return this.parseTransaction(h,o)}parseTransaction(e,t=void 0){let s;t=this.safeCurrency(void 0,t);const i=this.safeValue(e,"fee");return void 0!==i&&(s={cost:i,currency:t.code}),{id:this.safeString(e,"id"),txid:this.safeString(e,"txid"),timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:s,info:e}}customNonce(){const e=this.numberToString(this.milliseconds()/1e3);return parseFloat(e).toFixed(8)}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.urls.api.rest+"/";if("public"===t)o+="api/"+this.version+"/"+this.implodeParams(e,i);else if("fapi"===t)o+="fapi/"+this.version+"/"+this.implodeParams(e,i);else{this.checkRequiredCredentials(),o+="ecapi"===t?"ecapi":"tlapi"===t?"tlapi":"tapi";const s=this.customNonce();a=this.urlencode(this.extend({method:e,nonce:s},i)),r={"Content-Type":"application/x-www-form-urlencoded",Key:this.apiKey,Sign:this.hmac(this.encode(a),this.encode(this.secret),n.Zf)}}return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0===n)return;const c=this.id+" "+o,l=this.safeString(n,"error");if(void 0!==l)throw this.throwExactlyMatchedException(this.exceptions.exact,l,c),this.throwBroadlyMatchedException(this.exceptions.broad,l,c),new r.ExchangeError(c);if(!this.safeBool(n,"success",!0))throw new r.ExchangeError(c)}}},6022:(e,t,s)=>{s.d(t,{A:()=>d});var i=s(5517),r=s(2079),a=s(1579),o=s(5147),n=s(7481);class d extends i.A{describe(){return this.deepExtend(super.describe(),{id:"zonda",name:"Zonda",countries:["EE"],rateLimit:1e3,has:{CORS:!0,spot:!0,margin:!1,swap:!1,future:!1,option:!1,addMargin:!1,cancelAllOrders:!1,cancelOrder:!0,cancelOrders:!1,closeAllPositions:!1,closePosition:!1,createDepositAddress:!1,createOrder:!0,createReduceOnlyOrder:!1,fetchBalance:!0,fetchBorrowRateHistories:!1,fetchBorrowRateHistory:!1,fetchCrossBorrowRate:!1,fetchCrossBorrowRates:!1,fetchDeposit:!1,fetchDepositAddress:!0,fetchDepositAddresses:!0,fetchDeposits:void 0,fetchFundingHistory:!1,fetchFundingRate:!1,fetchFundingRateHistory:!1,fetchFundingRates:!1,fetchIndexOHLCV:!1,fetchIsolatedBorrowRate:!1,fetchIsolatedBorrowRates:!1,fetchLedger:!0,fetchLeverage:!1,fetchLeverageTiers:!1,fetchMarginMode:!1,fetchMarkets:!0,fetchMarkOHLCV:!1,fetchMyTrades:!0,fetchOHLCV:!0,fetchOpenInterestHistory:!1,fetchOpenOrder:!1,fetchOpenOrders:!0,fetchOrderBook:!0,fetchOrderBooks:!1,fetchPosition:!1,fetchPositionMode:!1,fetchPositions:!1,fetchPositionsRisk:!1,fetchPremiumIndexOHLCV:!1,fetchTicker:!0,fetchTickers:!0,fetchTime:!1,fetchTrades:!0,fetchTradingFee:!1,fetchTradingFees:!1,fetchTransactionFee:!1,fetchTransactionFees:!1,fetchTransactions:void 0,fetchTransfer:!1,fetchWithdrawal:!1,fetchWithdrawals:void 0,reduceMargin:!1,setLeverage:!1,setMargin:!1,setMarginMode:!1,setPositionMode:!1,transfer:!0,withdraw:!0},timeframes:{"1m":"60","3m":"180","5m":"300","15m":"900","30m":"1800","1h":"3600","2h":"7200","4h":"14400","6h":"21600","12h":"43200","1d":"86400","3d":"259200","1w":"604800"},hostname:"zondacrypto.exchange",urls:{referral:"https://auth.zondaglobal.com/ref/jHlbB4mIkdS1",logo:"https://user-images.githubusercontent.com/1294454/159202310-a0e38007-5e7c-4ba9-a32f-c8263a0291fe.jpg",www:"https://zondaglobal.com",api:{public:"https://{hostname}/API/Public",private:"https://{hostname}/API/Trading/tradingApi.php",v1_01Public:"https://api.{hostname}/rest",v1_01Private:"https://api.{hostname}/rest"},doc:["https://docs.zondacrypto.exchange/","https://github.com/BitBayNet/API"],support:"https://zondaglobal.com/en/helpdesk/zonda-exchange",fees:"https://zondaglobal.com/legal/zonda-exchange/fees"},api:{public:{get:["{id}/all","{id}/market","{id}/orderbook","{id}/ticker","{id}/trades"]},private:{post:["info","trade","cancel","orderbook","orders","transfer","withdraw","history","transactions"]},v1_01Public:{get:["trading/ticker","trading/ticker/{symbol}","trading/stats","trading/stats/{symbol}","trading/orderbook/{symbol}","trading/transactions/{symbol}","trading/candle/history/{symbol}/{resolution}"]},v1_01Private:{get:["api_payments/deposits/crypto/addresses","payments/withdrawal/{detailId}","payments/deposit/{detailId}","trading/offer","trading/stop/offer","trading/config/{symbol}","trading/history/transactions","balances/BITBAY/history","balances/BITBAY/balance","fiat_cantor/rate/{baseId}/{quoteId}","fiat_cantor/history","client_payments/v2/customer/crypto/{currency}/channels/deposit","client_payments/v2/customer/crypto/{currency}/channels/withdrawal","client_payments/v2/customer/crypto/deposit/fee","client_payments/v2/customer/crypto/withdrawal/fee"],post:["trading/offer/{symbol}","trading/stop/offer/{symbol}","trading/config/{symbol}","balances/BITBAY/balance","balances/BITBAY/balance/transfer/{source}/{destination}","fiat_cantor/exchange","api_payments/withdrawals/crypto","api_payments/withdrawals/fiat","client_payments/v2/customer/crypto/deposit","client_payments/v2/customer/crypto/withdrawal"],delete:["trading/offer/{symbol}/{id}/{side}/{price}","trading/stop/offer/{symbol}/{id}/{side}/{price}"],put:["balances/BITBAY/balance/{id}"]}},fees:{trading:{maker:this.parseNumber("0.0"),taker:this.parseNumber("0.001"),percentage:!0,tierBased:!1},fiat:{maker:this.parseNumber("0.0030"),taker:this.parseNumber("0.0043"),percentage:!0,tierBased:!0,tiers:{taker:[[this.parseNumber("0.0043"),this.parseNumber("0")],[this.parseNumber("0.0042"),this.parseNumber("1250")],[this.parseNumber("0.0041"),this.parseNumber("3750")],[this.parseNumber("0.0040"),this.parseNumber("7500")],[this.parseNumber("0.0039"),this.parseNumber("10000")],[this.parseNumber("0.0038"),this.parseNumber("15000")],[this.parseNumber("0.0037"),this.parseNumber("20000")],[this.parseNumber("0.0036"),this.parseNumber("25000")],[this.parseNumber("0.0035"),this.parseNumber("37500")],[this.parseNumber("0.0034"),this.parseNumber("50000")],[this.parseNumber("0.0033"),this.parseNumber("75000")],[this.parseNumber("0.0032"),this.parseNumber("100000")],[this.parseNumber("0.0031"),this.parseNumber("150000")],[this.parseNumber("0.0030"),this.parseNumber("200000")],[this.parseNumber("0.0029"),this.parseNumber("250000")],[this.parseNumber("0.0028"),this.parseNumber("375000")],[this.parseNumber("0.0027"),this.parseNumber("500000")],[this.parseNumber("0.0026"),this.parseNumber("625000")],[this.parseNumber("0.0025"),this.parseNumber("875000")]],maker:[[this.parseNumber("0.0030"),this.parseNumber("0")],[this.parseNumber("0.0029"),this.parseNumber("1250")],[this.parseNumber("0.0028"),this.parseNumber("3750")],[this.parseNumber("0.0028"),this.parseNumber("7500")],[this.parseNumber("0.0027"),this.parseNumber("10000")],[this.parseNumber("0.0026"),this.parseNumber("15000")],[this.parseNumber("0.0025"),this.parseNumber("20000")],[this.parseNumber("0.0025"),this.parseNumber("25000")],[this.parseNumber("0.0024"),this.parseNumber("37500")],[this.parseNumber("0.0023"),this.parseNumber("50000")],[this.parseNumber("0.0023"),this.parseNumber("75000")],[this.parseNumber("0.0022"),this.parseNumber("100000")],[this.parseNumber("0.0021"),this.parseNumber("150000")],[this.parseNumber("0.0021"),this.parseNumber("200000")],[this.parseNumber("0.0020"),this.parseNumber("250000")],[this.parseNumber("0.0019"),this.parseNumber("375000")],[this.parseNumber("0.0018"),this.parseNumber("500000")],[this.parseNumber("0.0018"),this.parseNumber("625000")],[this.parseNumber("0.0017"),this.parseNumber("875000")]]}},funding:{withdraw:{}}},options:{fetchTickerMethod:"v1_01PublicGetTradingTickerSymbol",fetchTickersMethod:"v1_01PublicGetTradingTicker",fiatCurrencies:["EUR","USD","GBP","PLN"],transfer:{fillResponseFromRequest:!0}},precisionMode:a.kb,exceptions:{400:r.ExchangeError,401:r.InvalidOrder,402:r.InvalidOrder,403:r.InvalidOrder,404:r.InvalidOrder,405:r.InvalidOrder,406:r.InsufficientFunds,408:r.InvalidOrder,501:r.AuthenticationError,502:r.AuthenticationError,503:r.InvalidNonce,504:r.ExchangeError,505:r.AuthenticationError,506:r.AccountSuspended,509:r.ExchangeError,510:r.BadSymbol,FUNDS_NOT_SUFFICIENT:r.InsufficientFunds,OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS:r.InvalidOrder,OFFER_NOT_FOUND:r.OrderNotFound,OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED:r.OrderImmediatelyFillable,ACTION_LIMIT_EXCEEDED:r.RateLimitExceeded,UNDER_MAINTENANCE:r.OnMaintenance,REQUEST_TIMESTAMP_TOO_OLD:r.InvalidNonce,PERMISSIONS_NOT_SUFFICIENT:r.PermissionDenied,INVALID_STOP_RATE:r.InvalidOrder,TIMEOUT:r.ExchangeError,RESPONSE_TIMEOUT:r.ExchangeError,ACTION_BLOCKED:r.PermissionDenied,INVALID_HASH_SIGNATURE:r.AuthenticationError},commonCurrencies:{GGC:"Global Game Coin"}})}async fetchMarkets(e={}){const t=await this.v1_01PublicGetTradingTicker(e),s=this.safeValue(t,"items",{}),i=Object.values(s);return this.parseMarkets(i)}parseMarket(e){const t=this.safeValue(e,"market",{}),s=this.safeString(t,"code"),i=this.safeValue(t,"first",{}),r=this.safeValue(t,"second",{}),a=this.safeString(i,"currency"),o=this.safeString(r,"currency"),n=this.safeCurrencyCode(a),d=this.safeCurrencyCode(o);let h=this.safeValue(this.fees,"trading",{});const c=this.safeValue(this.options,"fiatCurrencies",[]);return(this.inArray(n,c)||this.inArray(d,c))&&(h=this.safeValue(this.fees,"fiat",{})),{id:s,symbol:n+"/"+d,base:n,quote:d,settle:void 0,baseId:a,quoteId:o,settleId:void 0,type:"spot",spot:!0,margin:!1,swap:!1,future:!1,option:!1,active:void 0,contract:!1,linear:void 0,inverse:void 0,taker:this.safeNumber(h,"taker"),maker:this.safeNumber(h,"maker"),contractSize:void 0,expiry:void 0,expiryDatetime:void 0,optionType:void 0,strike:void 0,precision:{amount:this.parseNumber(this.parsePrecision(this.safeString(i,"scale"))),price:this.parseNumber(this.parsePrecision(this.safeString(r,"scale")))},limits:{leverage:{min:void 0,max:void 0},amount:{min:this.safeNumber(i,"minOffer"),max:void 0},price:{min:void 0,max:void 0},cost:{min:void 0,max:void 0}},created:void 0,info:e}}async fetchOpenOrders(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=await this.v1_01PrivateGetTradingOffer(this.extend({},i)),a=this.safeList(r,"items",[]);return this.parseOrders(a,void 0,t,s,{status:"open"})}parseOrder(e,t=void 0){const s=this.safeString(e,"market"),i=this.safeSymbol(s,t,"-"),r=this.safeInteger(e,"time"),a=this.safeString(e,"startAmount"),o=this.safeString(e,"currentAmount"),n=this.safeValue(e,"postOnly");return this.safeOrder({id:this.safeString(e,"id"),clientOrderId:void 0,info:e,timestamp:r,datetime:this.iso8601(r),lastTradeTimestamp:void 0,status:void 0,symbol:i,type:this.safeString(e,"mode"),timeInForce:void 0,postOnly:n,side:this.safeStringLower(e,"offerType"),price:this.safeString(e,"rate"),stopPrice:void 0,triggerPrice:void 0,amount:a,cost:void 0,filled:void 0,remaining:o,average:void 0,fee:void 0,trades:void 0},t)}async fetchMyTrades(e=void 0,t=void 0,s=void 0,i={}){await this.loadMarkets();const r={};if(e){const t=[this.marketId(e)];e=this.symbol(e),r.markets=t}const a={query:this.json(this.extend(r,i))},o=await this.v1_01PrivateGetTradingHistoryTransactions(a),n=this.safeValue(o,"items"),d=this.parseTrades(n,void 0,t,s);return void 0===e?d:this.filterBySymbol(d,e)}parseBalance(e){const t=this.safeValue(e,"balances");if(void 0===t)throw new r.ExchangeError(this.id+" empty balance response "+this.json(e));const s={info:e};for(let e=0;e<t.length;e++){const i=t[e],r=this.safeString(i,"currency"),a=this.safeCurrencyCode(r),o=this.account();o.used=this.safeString(i,"lockedFunds"),o.free=this.safeString(i,"availableFunds"),s[a]=o}return this.safeBalance(s)}async fetchBalance(e={}){await this.loadMarkets();const t=await this.v1_01PrivateGetBalancesBITBAYBalance(e);return this.parseBalance(t)}async fetchOrderBook(e,t=void 0,s={}){await this.loadMarkets();const i=this.market(e),r={symbol:i.id},a=await this.v1_01PublicGetTradingOrderbookSymbol(this.extend(r,s)),o=this.safeValue(a,"buy",[]),n=this.safeValue(a,"sell",[]),d=this.safeInteger(a,"timestamp");return{symbol:i.symbol,bids:this.parseBidsAsks(o,"ra","ca"),asks:this.parseBidsAsks(n,"ra","ca"),timestamp:d,datetime:this.iso8601(d),nonce:this.safeInteger(a,"seqNo")}}parseTicker(e,t=void 0){const s=this.safeValue(e,"market"),i=this.safeString2(s,"code","m");t=this.safeMarket(i,t);const r=this.safeInteger(e,"time"),a=this.safeValue(e,"rate");return this.safeTicker({symbol:this.safeSymbol(i,t),timestamp:r,datetime:this.iso8601(r),high:this.safeString(e,"h"),low:this.safeString(e,"l"),bid:this.safeNumber(e,"highestBid"),bidVolume:void 0,ask:this.safeNumber(e,"lowestAsk"),askVolume:void 0,vwap:void 0,open:this.safeString(e,"r24h"),close:a,last:a,previousClose:this.safeValue(e,"previousRate"),change:void 0,percentage:void 0,average:void 0,baseVolume:this.safeString(e,"v"),quoteVolume:void 0,info:e},t)}async fetchTicker(e,t={}){await this.loadMarkets();const s=this.market(e),i={symbol:s.id},a="v1_01PublicGetTradingTickerSymbol",o=this.safeString(this.options,"fetchTickerMethod",a),n=this.safeString2(t,"method","fetchTickerMethod",o);let d;if(n===a)d=await this.v1_01PublicGetTradingTickerSymbol(this.extend(i,t));else{if("v1_01PublicGetTradingStatsSymbol"!==n)throw new r.BadRequest(this.id+' fetchTicker params["method"] must be "v1_01PublicGetTradingTickerSymbol" or "v1_01PublicGetTradingStatsSymbol"');d=await this.v1_01PublicGetTradingStatsSymbol(this.extend(i,t))}const h=this.safeValue2(d,"ticker","stats");return this.parseTicker(h,s)}async fetchTickers(e=void 0,t={}){await this.loadMarkets();const s="v1_01PublicGetTradingTicker",i=this.safeString(this.options,"fetchTickersMethod",s),a=this.safeString2(t,"method","fetchTickersMethod",i);let o;if(a===s)o=await this.v1_01PublicGetTradingTicker(t);else{if("v1_01PublicGetTradingStats"!==a)throw new r.BadRequest(this.id+' fetchTickers params["method"] must be "v1_01PublicGetTradingTicker" or "v1_01PublicGetTradingStats"');o=await this.v1_01PublicGetTradingStats(t)}const n=this.safeDict(o,"items");return this.parseTickers(n,e)}async fetchLedger(e=void 0,t=void 0,s=void 0,i={}){const r=[];if(void 0!==e){const t=this.currency(e);r.push(t.id)}let a={balanceCurrencies:r};void 0!==t&&(a.fromTime=t),void 0!==s&&(a.limit=s),a=this.extend(a,i);const o=(await this.v1_01PrivateGetBalancesBITBAYHistory({query:this.json(a)})).items;return this.parseLedger(o,void 0,t,s)}parseLedgerEntry(e,t=void 0){const s=this.safeInteger(e,"time"),i=this.safeValue(e,"balance",{}),r=this.safeString(i,"currency"),a=this.safeValue(e,"change",{});let n=this.safeString(a,"total"),d="in";o.Y.stringLt(n,"0")&&(d="out",n=o.Y.stringNeg(n));const h=this.safeValue(e,"fundsBefore",{}),c=this.safeValue(e,"fundsAfter",{});return{info:e,id:this.safeString(e,"historyId"),direction:d,account:void 0,referenceId:this.safeString(e,"detailId"),referenceAccount:void 0,type:this.parseLedgerEntryType(this.safeString(e,"type")),currency:this.safeCurrencyCode(r),amount:this.parseNumber(n),before:this.safeNumber(h,"total"),after:this.safeNumber(c,"total"),status:"ok",timestamp:s,datetime:this.iso8601(s),fee:void 0}}parseLedgerEntryType(e){return this.safeString({ADD_FUNDS:"transaction",BITCOIN_GOLD_FORK:"transaction",CREATE_BALANCE:"transaction",FUNDS_MIGRATION:"transaction",WITHDRAWAL_LOCK_FUNDS:"transaction",WITHDRAWAL_SUBTRACT_FUNDS:"transaction",WITHDRAWAL_UNLOCK_FUNDS:"transaction",TRANSACTION_COMMISSION_OUTCOME:"fee",TRANSACTION_COMMISSION_RETURN:"fee",TRANSACTION_OFFER_ABORTED_RETURN:"trade",TRANSACTION_OFFER_COMPLETED_RETURN:"trade",TRANSACTION_POST_INCOME:"trade",TRANSACTION_POST_OUTCOME:"trade",TRANSACTION_PRE_LOCKING:"trade"},e,e)}parseOHLCV(e,t=void 0){const s=this.safeValue(e,1,{});return[this.safeInteger(e,0),this.safeNumber(s,"o"),this.safeNumber(s,"h"),this.safeNumber(s,"l"),this.safeNumber(s,"c"),this.safeNumber(s,"v")]}async fetchOHLCV(e,t="1m",s=void 0,i=void 0,r={}){await this.loadMarkets();const a=this.market(e),o={symbol:a.baseId+"-"+a.quoteId,resolution:this.safeString(this.timeframes,t,t)},n=(i=void 0===i?100:Math.min(i,11e3))*this.parseTimeframe(t)*1e3;void 0===s?(o.to=this.milliseconds(),o.from=o.to-n):(o.from=s,o.to=this.sum(o.from,n));const d=await this.v1_01PublicGetTradingCandleHistorySymbolResolution(this.extend(o,r)),h=this.safeList(d,"items",[]);return this.parseOHLCVs(h,a,t,s,i)}parseTrade(e,t=void 0){const s=this.safeInteger2(e,"time","t"),i=this.safeStringLower2(e,"userAction","ty"),r=this.safeValue(e,"wasTaker");let a;void 0!==r&&(a=r?"taker":"maker");const o=this.safeString2(e,"rate","r"),n=this.safeString2(e,"amount","a"),d=this.safeString(e,"commissionValue"),h=this.safeString(e,"market"),c=(t=this.safeMarket(h,t,"-")).symbol;let l;if(void 0!==d){l={currency:"buy"===i?t.base:t.quote,cost:d}}const u=this.safeString(e,"offerId");let p;return void 0!==u&&(p=u?"limit":"market"),this.safeTrade({id:this.safeString(e,"id"),order:u,timestamp:s,datetime:this.iso8601(s),symbol:c,type:p,side:i,price:o,amount:n,cost:void 0,takerOrMaker:a,fee:l,info:e},t)}async fetchTrades(e,t=void 0,s=void 0,i={}){await this.loadMarkets();const r=this.market(e),a={symbol:r.baseId+"-"+r.quoteId};void 0!==t&&(a.fromTime=t-1),void 0!==s&&(a.limit=s);const o=await this.v1_01PublicGetTradingTransactionsSymbol(this.extend(a,i)),n=this.safeList(o,"items");return this.parseTrades(n,r,t,s)}async createOrder(e,t,s,i,a=void 0,o={}){await this.loadMarkets();const n=this.market(e),d=n.baseId+"-"+n.quoteId;i=parseFloat(this.amountToPrecision(e,i));const h={symbol:d,offerType:s.toUpperCase(),amount:i},c=this.safeValue2(o,"stopPrice","stopLossPrice"),l=void 0!==c,u="limit"===t,p="market"===t,f="stop-limit"===t||u&&l,m="stop-market"===t||p&&l,g=f||m;if(u||f)h.rate=this.priceToPrecision(e,a),h.mode=f?"stop-limit":"limit";else{if(!p&&!m)throw new r.ExchangeError(this.id+" createOrder() invalid type");h.mode=m?"stop-market":"market"}let v;if(o=this.omit(o,["stopPrice","stopLossPrice"]),g){if(!l)throw new r.ExchangeError(this.id+" createOrder() zonda requires `triggerPrice` or `stopPrice` parameter for stop-limit or stop-market orders");h.stopRate=this.priceToPrecision(e,c),v=await this.v1_01PrivatePostTradingStopOfferSymbol(this.extend(h,o))}else v=await this.v1_01PrivatePostTradingOfferSymbol(this.extend(h,o));const y=this.safeString2(v,"offerId","stopOfferId"),w=this.safeBool(v,"completed",!1)?"closed":"open",b=this.safeValue(v,"transactions");return this.safeOrder({id:y,info:v,timestamp:void 0,datetime:void 0,lastTradeTimestamp:void 0,status:w,symbol:e,type:t,side:s,price:a,amount:i,cost:void 0,filled:void 0,remaining:void 0,average:void 0,fee:void 0,trades:b,clientOrderId:void 0})}async cancelOrder(e,t=void 0,s={}){const i=this.safeString(s,"side");if(void 0===i)throw new r.ExchangeError(this.id+' cancelOrder() requires a `side` parameter ("buy" or "sell")');const a=this.safeValue(s,"price");if(void 0===a)throw new r.ExchangeError(this.id+" cancelOrder() requires a `price` parameter (float or string)");await this.loadMarkets();const o=this.market(t),n={symbol:o.baseId+"-"+o.quoteId,id:e,side:i,price:a},d=await this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice(this.extend(n,s));return this.parseOrder(d)}isFiat(e){return this.safeBool({USD:!0,EUR:!0,PLN:!0},e,!1)}parseDepositAddress(e,t=void 0){const s=this.safeString(e,"currency"),i=this.safeString(e,"address");return this.checkAddress(i),{currency:this.safeCurrencyCode(s,t),address:i,tag:this.safeString(e,"tag"),network:void 0,info:e}}async fetchDepositAddress(e,t={}){await this.loadMarkets();const s=this.currency(e),i={currency:s.id},r=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(this.extend(i,t)),a=this.safeValue(r,"data"),o=this.safeDict(a,0);return this.parseDepositAddress(o,s)}async fetchDepositAddresses(e=void 0,t={}){await this.loadMarkets();const s=await this.v1_01PrivateGetApiPaymentsDepositsCryptoAddresses(t),i=this.safeList(s,"data");return this.parseDepositAddresses(i,e)}async transfer(e,t,s,i,r={}){await this.loadMarkets();const a=this.currency(e),o={source:s,destination:i,currency:e,funds:this.currencyToPrecision(e,t)},n=await this.v1_01PrivatePostBalancesBITBAYBalanceTransferSourceDestination(this.extend(o,r)),d=this.parseTransfer(n,a),h=this.safeValue(this.options,"transfer",{});return this.safeBool(h,"fillResponseFromRequest",!0)&&(d.amount=t),d}parseTransfer(e,t=void 0){const s=this.safeString(e,"status"),i=this.safeValue(e,"from",{}),r=this.safeString(i,"id"),a=this.safeValue(e,"to",{}),o=this.safeString(a,"id"),n=this.safeString(i,"currency");return{info:e,id:void 0,timestamp:void 0,datetime:void 0,currency:this.safeCurrencyCode(n,t),amount:void 0,fromAccount:r,toAccount:o,status:this.parseTransferStatus(s)}}parseTransferStatus(e){return this.safeString({Ok:"ok",Fail:"failed"},e,e)}async withdraw(e,t,s,i=void 0,r={}){let a;[i,r]=this.handleWithdrawTagAndParams(i,r),this.checkAddress(s),await this.loadMarkets();const o=this.currency(e),n={currency:o.id,amount:t,address:s};this.isFiat(e)?a=await this.v1_01PrivatePostApiPaymentsWithdrawalsFiat(this.extend(n,r)):(void 0!==i&&(n.tag=i),a=await this.v1_01PrivatePostApiPaymentsWithdrawalsCrypto(this.extend(n,r)));const d=this.safeDict(a,"data");return this.parseTransaction(d,o)}parseTransaction(e,t=void 0){return t=this.safeCurrency(void 0,t),{id:this.safeString(e,"id"),txid:void 0,timestamp:void 0,datetime:void 0,network:void 0,addressFrom:void 0,address:void 0,addressTo:void 0,amount:void 0,type:void 0,currency:t.code,status:void 0,updated:void 0,tagFrom:void 0,tag:void 0,tagTo:void 0,comment:void 0,internal:void 0,fee:void 0,info:e}}sign(e,t="public",s="GET",i={},r=void 0,a=void 0){let o=this.implodeHostname(this.urls.api[t]);if("public"===t){const t=this.omit(i,this.extractParams(e));o+="/"+this.implodeParams(e,i)+".json",Object.keys(t).length&&(o+="?"+this.urlencode(t))}else if("v1_01Public"===t){const t=this.omit(i,this.extractParams(e));o+="/"+this.implodeParams(e,i),Object.keys(t).length&&(o+="?"+this.urlencode(t))}else if("v1_01Private"===t){this.checkRequiredCredentials();const t=this.omit(i,this.extractParams(e));o+="/"+this.implodeParams(e,i);const d=this.milliseconds().toString();let h;"POST"!==s?(Object.keys(t).length&&(o+="?"+this.urlencode(t)),h=this.apiKey+d):void 0===a&&(a=this.json(t),h=this.apiKey+d+a),r={"Request-Timestamp":d,"Operation-Id":this.uuid(),"API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(h),this.encode(this.secret),n.Zf),"Content-Type":"application/json"}}else this.checkRequiredCredentials(),a=this.urlencode(this.extend({method:e,moment:this.nonce()},i)),r={"Content-Type":"application/x-www-form-urlencoded","API-Key":this.apiKey,"API-Hash":this.hmac(this.encode(a),this.encode(this.secret),n.Zf)};return{url:o,method:s,body:a,headers:r}}handleErrors(e,t,s,i,a,o,n,d,h){if(void 0!==n){if("code"in n){const e=this.safeString(n,"code"),t=this.id+" "+o;throw this.throwExactlyMatchedException(this.exceptions,e,t),new r.ExchangeError(t)}if("status"in n){if("Fail"===this.safeString(n,"status")){const e=this.safeValue(n,"errors"),t=this.id+" "+o;for(let s=0;s<e.length;s++){const i=e[s];this.throwExactlyMatchedException(this.exceptions,i,t)}throw new r.ExchangeError(t)}}}}}},1591:e=>{e.exports=function(){throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")}},3544:e=>{var t=String.prototype.replace,s=/%20/g;e.exports={default:"RFC3986",formatters:{RFC1738:function(e){return t.call(e,s,"+")},RFC3986:function(e){return e}},RFC1738:"RFC1738",RFC3986:"RFC3986"}},4580:(e,t,s)=>{var i=s(1603),r=s(3437),a=s(3544);e.exports={formats:a,parse:r,stringify:i}},3437:(e,t,s)=>{var i=s(3247),r=Object.prototype.hasOwnProperty,a={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:i.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},o=function(e){return e.replace(/&#(\d+);/g,(function(e,t){return String.fromCharCode(parseInt(t,10))}))},n=function(e,t,s){if(e){var i=s.allowDots?e.replace(/\.([^.[]+)/g,"[$1]"):e,a=/(\[[^[\]]*])/g,o=/(\[[^[\]]*])/.exec(i),n=o?i.slice(0,o.index):i,d=[];if(n){if(!s.plainObjects&&r.call(Object.prototype,n)&&!s.allowPrototypes)return;d.push(n)}for(var h=0;null!==(o=a.exec(i))&&h<s.depth;){if(h+=1,!s.plainObjects&&r.call(Object.prototype,o[1].slice(1,-1))&&!s.allowPrototypes)return;d.push(o[1])}return o&&d.push("["+i.slice(o.index)+"]"),function(e,t,s){for(var i=t,r=e.length-1;r>=0;--r){var a,o=e[r];if("[]"===o&&s.parseArrays)a=[].concat(i);else{a=s.plainObjects?Object.create(null):{};var n="["===o.charAt(0)&&"]"===o.charAt(o.length-1)?o.slice(1,-1):o,d=parseInt(n,10);s.parseArrays||""!==n?!isNaN(d)&&o!==n&&String(d)===n&&d>=0&&s.parseArrays&&d<=s.arrayLimit?(a=[])[d]=i:a[n]=i:a={0:i}}i=a}return i}(d,t,s)}};e.exports=function(e,t){var s=function(e){if(!e)return a;if(null!==e.decoder&&void 0!==e.decoder&&"function"!=typeof e.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var t=void 0===e.charset?a.charset:e.charset;return{allowDots:void 0===e.allowDots?a.allowDots:!!e.allowDots,allowPrototypes:"boolean"==typeof e.allowPrototypes?e.allowPrototypes:a.allowPrototypes,arrayLimit:"number"==typeof e.arrayLimit?e.arrayLimit:a.arrayLimit,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:a.charsetSentinel,comma:"boolean"==typeof e.comma?e.comma:a.comma,decoder:"function"==typeof e.decoder?e.decoder:a.decoder,delimiter:"string"==typeof e.delimiter||i.isRegExp(e.delimiter)?e.delimiter:a.delimiter,depth:"number"==typeof e.depth?e.depth:a.depth,ignoreQueryPrefix:!0===e.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof e.interpretNumericEntities?e.interpretNumericEntities:a.interpretNumericEntities,parameterLimit:"number"==typeof e.parameterLimit?e.parameterLimit:a.parameterLimit,parseArrays:!1!==e.parseArrays,plainObjects:"boolean"==typeof e.plainObjects?e.plainObjects:a.plainObjects,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:a.strictNullHandling}}(t);if(""===e||null==e)return s.plainObjects?Object.create(null):{};for(var d="string"==typeof e?function(e,t){var s,n={},d=t.ignoreQueryPrefix?e.replace(/^\?/,""):e,h=t.parameterLimit===1/0?void 0:t.parameterLimit,c=d.split(t.delimiter,h),l=-1,u=t.charset;if(t.charsetSentinel)for(s=0;s<c.length;++s)0===c[s].indexOf("utf8=")&&("utf8=%E2%9C%93"===c[s]?u="utf-8":"utf8=%26%2310003%3B"===c[s]&&(u="iso-8859-1"),l=s,s=c.length);for(s=0;s<c.length;++s)if(s!==l){var p,f,m=c[s],g=m.indexOf("]="),v=-1===g?m.indexOf("="):g+1;-1===v?(p=t.decoder(m,a.decoder,u),f=t.strictNullHandling?null:""):(p=t.decoder(m.slice(0,v),a.decoder,u),f=t.decoder(m.slice(v+1),a.decoder,u)),f&&t.interpretNumericEntities&&"iso-8859-1"===u&&(f=o(f)),f&&t.comma&&f.indexOf(",")>-1&&(f=f.split(",")),r.call(n,p)?n[p]=i.combine(n[p],f):n[p]=f}return n}(e,s):e,h=s.plainObjects?Object.create(null):{},c=Object.keys(d),l=0;l<c.length;++l){var u=c[l],p=n(u,d[u],s);h=i.merge(h,p,s)}return i.compact(h)}},1603:(e,t,s)=>{var i=s(3247),r=s(3544),a=Object.prototype.hasOwnProperty,o={brackets:function(e){return e+"[]"},comma:"comma",indices:function(e,t){return e+"["+t+"]"},repeat:function(e){return e}},n=Array.isArray,d=Array.prototype.push,h=function(e,t){d.apply(e,n(t)?t:[t])},c=Date.prototype.toISOString,l={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:i.encode,encodeValuesOnly:!1,formatter:r.formatters[r.default],indices:!1,serializeDate:function(e){return c.call(e)},skipNulls:!1,strictNullHandling:!1},u=function e(t,s,r,a,o,d,c,u,p,f,m,g,v){var y=t;if("function"==typeof c?y=c(s,y):y instanceof Date?y=f(y):"comma"===r&&n(y)&&(y=y.join(",")),null===y){if(a)return d&&!g?d(s,l.encoder,v):s;y=""}if("string"==typeof y||"number"==typeof y||"boolean"==typeof y||i.isBuffer(y))return d?[m(g?s:d(s,l.encoder,v))+"="+m(d(y,l.encoder,v))]:[m(s)+"="+m(String(y))];var w,b=[];if(void 0===y)return b;if(n(c))w=c;else{var S=Object.keys(y);w=u?S.sort(u):S}for(var k=0;k<w.length;++k){var O=w[k];o&&null===y[O]||(n(y)?h(b,e(y[O],"function"==typeof r?r(s,O):s,r,a,o,d,c,u,p,f,m,g,v)):h(b,e(y[O],s+(p?"."+O:"["+O+"]"),r,a,o,d,c,u,p,f,m,g,v)))}return b};e.exports=function(e,t){var s,i=e,d=function(e){if(!e)return l;if(null!==e.encoder&&void 0!==e.encoder&&"function"!=typeof e.encoder)throw new TypeError("Encoder has to be a function.");var t=e.charset||l.charset;if(void 0!==e.charset&&"utf-8"!==e.charset&&"iso-8859-1"!==e.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var s=r.default;if(void 0!==e.format){if(!a.call(r.formatters,e.format))throw new TypeError("Unknown format option provided.");s=e.format}var i=r.formatters[s],o=l.filter;return("function"==typeof e.filter||n(e.filter))&&(o=e.filter),{addQueryPrefix:"boolean"==typeof e.addQueryPrefix?e.addQueryPrefix:l.addQueryPrefix,allowDots:void 0===e.allowDots?l.allowDots:!!e.allowDots,charset:t,charsetSentinel:"boolean"==typeof e.charsetSentinel?e.charsetSentinel:l.charsetSentinel,delimiter:void 0===e.delimiter?l.delimiter:e.delimiter,encode:"boolean"==typeof e.encode?e.encode:l.encode,encoder:"function"==typeof e.encoder?e.encoder:l.encoder,encodeValuesOnly:"boolean"==typeof e.encodeValuesOnly?e.encodeValuesOnly:l.encodeValuesOnly,filter:o,formatter:i,serializeDate:"function"==typeof e.serializeDate?e.serializeDate:l.serializeDate,skipNulls:"boolean"==typeof e.skipNulls?e.skipNulls:l.skipNulls,sort:"function"==typeof e.sort?e.sort:null,strictNullHandling:"boolean"==typeof e.strictNullHandling?e.strictNullHandling:l.strictNullHandling}}(t);"function"==typeof d.filter?i=(0,d.filter)("",i):n(d.filter)&&(s=d.filter);var c,p=[];if("object"!=typeof i||null===i)return"";c=t&&t.arrayFormat in o?t.arrayFormat:t&&"indices"in t?t.indices?"indices":"repeat":"indices";var f=o[c];s||(s=Object.keys(i)),d.sort&&s.sort(d.sort);for(var m=0;m<s.length;++m){var g=s[m];d.skipNulls&&null===i[g]||h(p,u(i[g],g,f,d.strictNullHandling,d.skipNulls,d.encode?d.encoder:null,d.filter,d.sort,d.allowDots,d.serializeDate,d.formatter,d.encodeValuesOnly,d.charset))}var v=p.join(d.delimiter),y=!0===d.addQueryPrefix?"?":"";return d.charsetSentinel&&("iso-8859-1"===d.charset?y+="utf8=%26%2310003%3B&":y+="utf8=%E2%9C%93&"),v.length>0?y+v:""}},3247:e=>{var t=Object.prototype.hasOwnProperty,s=Array.isArray,i=function(){for(var e=[],t=0;t<256;++t)e.push("%"+((t<16?"0":"")+t.toString(16)).toUpperCase());return e}(),r=function(e,t){for(var s=t&&t.plainObjects?Object.create(null):{},i=0;i<e.length;++i)void 0!==e[i]&&(s[i]=e[i]);return s};e.exports={arrayToObject:r,assign:function(e,t){return Object.keys(t).reduce((function(e,s){return e[s]=t[s],e}),e)},combine:function(e,t){return[].concat(e,t)},compact:function(e){for(var t=[{obj:{o:e},prop:"o"}],i=[],r=0;r<t.length;++r)for(var a=t[r],o=a.obj[a.prop],n=Object.keys(o),d=0;d<n.length;++d){var h=n[d],c=o[h];"object"==typeof c&&null!==c&&-1===i.indexOf(c)&&(t.push({obj:o,prop:h}),i.push(c))}return function(e){for(;e.length>1;){var t=e.pop(),i=t.obj[t.prop];if(s(i)){for(var r=[],a=0;a<i.length;++a)void 0!==i[a]&&r.push(i[a]);t.obj[t.prop]=r}}}(t),e},decode:function(e,t,s){var i=e.replace(/\+/g," ");if("iso-8859-1"===s)return i.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(i)}catch(e){return i}},encode:function(e,t,s){if(0===e.length)return e;var r="string"==typeof e?e:String(e);if("iso-8859-1"===s)return escape(r).replace(/%u[0-9a-f]{4}/gi,(function(e){return"%26%23"+parseInt(e.slice(2),16)+"%3B"}));for(var a="",o=0;o<r.length;++o){var n=r.charCodeAt(o);45===n||46===n||95===n||126===n||n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?a+=r.charAt(o):n<128?a+=i[n]:n<2048?a+=i[192|n>>6]+i[128|63&n]:n<55296||n>=57344?a+=i[224|n>>12]+i[128|n>>6&63]+i[128|63&n]:(o+=1,n=65536+((1023&n)<<10|1023&r.charCodeAt(o)),a+=i[240|n>>18]+i[128|n>>12&63]+i[128|n>>6&63]+i[128|63&n])}return a},isBuffer:function(e){return!(!e||"object"!=typeof e)&&!!(e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer(e))},isRegExp:function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},merge:function e(i,a,o){if(!a)return i;if("object"!=typeof a){if(s(i))i.push(a);else{if(!i||"object"!=typeof i)return[i,a];(o&&(o.plainObjects||o.allowPrototypes)||!t.call(Object.prototype,a))&&(i[a]=!0)}return i}if(!i||"object"!=typeof i)return[i].concat(a);var n=i;return s(i)&&!s(a)&&(n=r(i,o)),s(i)&&s(a)?(a.forEach((function(s,r){if(t.call(i,r)){var a=i[r];a&&"object"==typeof a&&s&&"object"==typeof s?i[r]=e(a,s,o):i.push(s)}else i[r]=s})),i):Object.keys(a).reduce((function(s,i){var r=a[i];return t.call(s,i)?s[i]=e(s[i],r,o):s[i]=r,s}),n)}}},4350:(e,t,s)=>{s.d(t,{HM:()=>N,Wt:()=>R});var i=Uint8Array,r=Uint16Array,a=Uint32Array,o=new i([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),n=new i([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),d=new i([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),h=function(e,t){for(var s=new r(31),i=0;i<31;++i)s[i]=t+=1<<e[i-1];var o=new a(s[30]);for(i=1;i<30;++i)for(var n=s[i];n<s[i+1];++n)o[n]=n-s[i]<<5|i;return[s,o]},c=h(o,2),l=c[0],u=c[1];l[28]=258,u[258]=28;for(var p=h(n,0),f=p[0],m=(p[1],new r(32768)),g=0;g<32768;++g){var v=(43690&g)>>>1|(21845&g)<<1;v=(61680&(v=(52428&v)>>>2|(13107&v)<<2))>>>4|(3855&v)<<4,m[g]=((65280&v)>>>8|(255&v)<<8)>>>1}var y=function(e,t,s){for(var i=e.length,a=0,o=new r(t);a<i;++a)e[a]&&++o[e[a]-1];var n,d=new r(t);for(a=0;a<t;++a)d[a]=d[a-1]+o[a-1]<<1;if(s){n=new r(1<<t);var h=15-t;for(a=0;a<i;++a)if(e[a])for(var c=a<<4|e[a],l=t-e[a],u=d[e[a]-1]++<<l,p=u|(1<<l)-1;u<=p;++u)n[m[u]>>>h]=c}else for(n=new r(i),a=0;a<i;++a)e[a]&&(n[a]=m[d[e[a]-1]++]>>>15-e[a]);return n},w=new i(288);for(g=0;g<144;++g)w[g]=8;for(g=144;g<256;++g)w[g]=9;for(g=256;g<280;++g)w[g]=7;for(g=280;g<288;++g)w[g]=8;var b=new i(32);for(g=0;g<32;++g)b[g]=5;var S=y(w,9,1),k=y(b,5,1),O=function(e){for(var t=e[0],s=1;s<e.length;++s)e[s]>t&&(t=e[s]);return t},T=function(e,t,s){var i=t/8|0;return(e[i]|e[i+1]<<8)>>(7&t)&s},P=function(e,t){var s=t/8|0;return(e[s]|e[s+1]<<8|e[s+2]<<16)>>(7&t)},I=function(e){return(e+7)/8|0},x=function(e,t,s){(null==t||t<0)&&(t=0),(null==s||s>e.length)&&(s=e.length);var o=new(2==e.BYTES_PER_ELEMENT?r:4==e.BYTES_PER_ELEMENT?a:i)(s-t);return o.set(e.subarray(t,s)),o},A=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],M=function(e,t,s){var i=new Error(t||A[e]);if(i.code=e,Error.captureStackTrace&&Error.captureStackTrace(i,M),!s)throw i;return i},C=function(e,t,s){var r=e.length;if(!r||s&&s.f&&!s.l)return t||new i(0);var a=!t||s,h=!s||s.i;s||(s={}),t||(t=new i(3*r));var c=function(e){var s=t.length;if(e>s){var r=new i(Math.max(2*s,e));r.set(t),t=r}},u=s.f||0,p=s.p||0,m=s.b||0,g=s.l,v=s.d,w=s.m,b=s.n,A=8*r;do{if(!g){u=T(e,p,1);var C=T(e,p+1,3);if(p+=3,!C){var E=e[(H=I(p)+4)-4]|e[H-3]<<8,_=H+E;if(_>r){h&&M(0);break}a&&c(m+E),t.set(e.subarray(H,_),m),s.b=m+=E,s.p=p=8*_,s.f=u;continue}if(1==C)g=S,v=k,w=9,b=5;else if(2==C){var B=T(e,p,31)+257,N=T(e,p+10,15)+4,R=B+T(e,p+5,31)+1;p+=14;for(var L=new i(R),V=new i(19),D=0;D<N;++D)V[d[D]]=T(e,p+3*D,7);p+=3*N;var q=O(V),F=(1<<q)-1,G=y(V,q,1);for(D=0;D<R;){var H,U=G[T(e,p,F)];if(p+=15&U,(H=U>>>4)<16)L[D++]=H;else{var W=0,j=0;for(16==H?(j=3+T(e,p,3),p+=2,W=L[D-1]):17==H?(j=3+T(e,p,7),p+=3):18==H&&(j=11+T(e,p,127),p+=7);j--;)L[D++]=W}}var K=L.subarray(0,B),Y=L.subarray(B);w=O(K),b=O(Y),g=y(K,w,1),v=y(Y,b,1)}else M(1);if(p>A){h&&M(0);break}}a&&c(m+131072);for(var z=(1<<w)-1,X=(1<<b)-1,Q=p;;Q=p){var Z=(W=g[P(e,p)&z])>>>4;if((p+=15&W)>A){h&&M(0);break}if(W||M(2),Z<256)t[m++]=Z;else{if(256==Z){Q=p,g=null;break}var $=Z-254;if(Z>264){var J=o[D=Z-257];$=T(e,p,(1<<J)-1)+l[D],p+=J}var ee=v[P(e,p)&X],te=ee>>>4;ee||M(3),p+=15&ee;Y=f[te];if(te>3){J=n[te];Y+=P(e,p)&(1<<J)-1,p+=J}if(p>A){h&&M(0);break}a&&c(m+131072);for(var se=m+$;m<se;m+=4)t[m]=t[m-Y],t[m+1]=t[m+1-Y],t[m+2]=t[m+2-Y],t[m+3]=t[m+3-Y];m=se}}s.l=g,s.p=Q,s.b=m,s.f=u,g&&(u=1,s.m=w,s.d=v,s.n=b)}while(!u);return m==t.length?t:x(t,0,m)},E=new i(0),_=function(e){31==e[0]&&139==e[1]&&8==e[2]||M(6,"invalid gzip data");var t=e[3],s=10;4&t&&(s+=e[10]|2+(e[11]<<8));for(var i=(t>>3&1)+(t>>4&1);i>0;i-=!e[s++]);return s+(2&t)},B=function(e){var t=e.length;return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0};function N(e,t=void 0){return C(e,t)}function R(e,t=void 0){return C(e.subarray(_(e),-8),t||new i(B(e)))}var L="undefined"!=typeof TextDecoder&&new TextDecoder;try{L.decode(E,{stream:!0}),1}catch(e){}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout},6378:(e,t,s)=>{s.d(t,{b:()=>i});
/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var i={};i.lang={extend:function(e,t,s){if(!t||!e)throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");var i=function(){};if(i.prototype=t.prototype,e.prototype=new i,e.prototype.constructor=e,e.superclass=t.prototype,t.prototype.constructor==Object.prototype.constructor&&(t.prototype.constructor=t),s){var r;for(r in s)e.prototype[r]=s[r];var a=function(){},o=["toString","valueOf"];try{/MSIE/.test(navigator.userAgent)&&(a=function(e,t){for(r=0;r<o.length;r+=1){var s=o[r],i=t[s];"function"==typeof i&&i!=Object.prototype[s]&&(e[s]=i)}})}catch(e){}a(e.prototype,s)}}}},917:(e,t,s)=>{function i(e,t){if(t&&t.multiple&&!Array.isArray(e))throw new Error("Invalid argument type: Expected an Array to serialize multiple values.");const s=4294967296;let i,r,a=new Uint8Array(128),o=0;if(t&&t.multiple)for(let t=0;t<e.length;t++)n(e[t]);else n(e);return a.subarray(0,o);function n(e,a){switch(typeof e){case"undefined":d(e);break;case"boolean":!function(e){c(e?195:194)}(e);break;case"number":!function(e){if(isFinite(e)&&Math.floor(e)===e)if(e>=0&&e<=127)c(e);else if(e<0&&e>=-32)c(e);else if(e>0&&e<=255)l([204,e]);else if(e>=-128&&e<=127)l([208,e]);else if(e>0&&e<=65535)l([205,e>>>8,e]);else if(e>=-32768&&e<=32767)l([209,e>>>8,e]);else if(e>0&&e<=4294967295)l([206,e>>>24,e>>>16,e>>>8,e]);else if(e>=-2147483648&&e<=2147483647)l([210,e>>>24,e>>>16,e>>>8,e]);else if(e>0&&e<=0x10000000000000000){let t=e/s,i=e%s;l([207,t>>>24,t>>>16,t>>>8,t,i>>>24,i>>>16,i>>>8,i])}else e>=-0x8000000000000000&&e<=0x8000000000000000?(c(211),u(e)):l(e<0?[211,128,0,0,0,0,0,0,0]:[207,255,255,255,255,255,255,255,255]);else r||(i=new ArrayBuffer(8),r=new DataView(i)),r.setFloat64(0,e),c(203),l(new Uint8Array(i))}(e);break;case"string":!function(e){let t=function(e){let t=!0,s=e.length;for(let i=0;i<s;i++)if(e.charCodeAt(i)>127){t=!1;break}let i=0,r=new Uint8Array(e.length*(t?1:4));for(let t=0;t!==s;t++){let a=e.charCodeAt(t);if(a<128)r[i++]=a;else{if(a<2048)r[i++]=a>>6|192;else{if(a>55295&&a<56320){if(++t>=s)throw new Error("UTF-8 encode: incomplete surrogate pair");let o=e.charCodeAt(t);if(o<56320||o>57343)throw new Error("UTF-8 encode: second surrogate character 0x"+o.toString(16)+" at index "+t+" out of range");a=65536+((1023&a)<<10)+(1023&o),r[i++]=a>>18|240,r[i++]=a>>12&63|128}else r[i++]=a>>12|224;r[i++]=a>>6&63|128}r[i++]=63&a|128}}return t?r:r.subarray(0,i)}(e),s=t.length;s<=31?c(160+s):l(s<=255?[217,s]:s<=65535?[218,s>>>8,s]:[219,s>>>24,s>>>16,s>>>8,s]);l(t)}(e);break;case"object":null===e?d(e):e instanceof Date?function(e){let t=e.getTime()/1e3;if(0===e.getMilliseconds()&&t>=0&&t<4294967296)l([214,255,t>>>24,t>>>16,t>>>8,t]);else if(t>=0&&t<17179869184){let i=1e6*e.getMilliseconds();l([215,255,i>>>22,i>>>14,i>>>6,i<<2>>>0|t/s,t>>>24,t>>>16,t>>>8,t])}else{let s=1e6*e.getMilliseconds();l([199,12,255,s>>>24,s>>>16,s>>>8,s]),u(t)}}(e):Array.isArray(e)?h(e):e instanceof Uint8Array||e instanceof Uint8ClampedArray?function(e){let t=e.length;l(t<=15?[196,t]:t<=65535?[197,t>>>8,t]:[198,t>>>24,t>>>16,t>>>8,t]);l(e)}(e):e instanceof Int8Array||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array?h(e):function(e){let t=0;for(let s in e)void 0!==e[s]&&t++;t<=15?c(128+t):l(t<=65535?[222,t>>>8,t]:[223,t>>>24,t>>>16,t>>>8,t]);for(let t in e){let s=e[t];void 0!==s&&(n(t),n(s))}}(e);break;default:if(a||!t||!t.invalidTypeReplacement)throw new Error("Invalid argument type: The type '"+typeof e+"' cannot be serialized.");"function"==typeof t.invalidTypeReplacement?n(t.invalidTypeReplacement(e),!0):n(t.invalidTypeReplacement,!0)}}function d(e){c(192)}function h(e){let t=e.length;t<=15?c(144+t):l(t<=65535?[220,t>>>8,t]:[221,t>>>24,t>>>16,t>>>8,t]);for(let s=0;s<t;s++)n(e[s])}function c(e){if(a.length<o+1){let e=2*a.length;for(;e<o+1;)e*=2;let t=new Uint8Array(e);t.set(a),a=t}a[o]=e,o++}function l(e){if(a.length<o+e.length){let t=2*a.length;for(;t<o+e.length;)t*=2;let s=new Uint8Array(t);s.set(a),a=s}a.set(e,o),o+=e.length}function u(e){let t,i;e>=0?(t=e/s,i=e%s):(e++,t=Math.abs(e)/s,i=Math.abs(e)%s,t=~t,i=~i),l([t>>>24,t>>>16,t>>>8,t,i>>>24,i>>>16,i>>>8,i])}}s.d(t,{l:()=>i})}},t={};function s(i){var r=t[i];if(void 0!==r)return r.exports;var a=t[i]={exports:{}};return e[i](a,a.exports,s),a.exports}s.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return s.d(t,{a:t}),t},s.d=(e,t)=>{for(var i in t)s.o(t,i)&&!s.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var i={};s.r(i),s.d(i,{AccountNotEnabled:()=>n.AccountNotEnabled,AccountSuspended:()=>n.AccountSuspended,AddressPending:()=>n.AddressPending,ArgumentsRequired:()=>n.ArgumentsRequired,AuthenticationError:()=>n.AuthenticationError,BadRequest:()=>n.BadRequest,BadResponse:()=>n.BadResponse,BadSymbol:()=>n.BadSymbol,BaseError:()=>n.BaseError,CancelPending:()=>n.CancelPending,ChecksumError:()=>n.ChecksumError,ContractUnavailable:()=>n.ContractUnavailable,DDoSProtection:()=>n.DDoSProtection,DuplicateOrderId:()=>n.DuplicateOrderId,Exchange:()=>r.k,ExchangeClosedByUser:()=>n.ExchangeClosedByUser,ExchangeError:()=>n.ExchangeError,ExchangeNotAvailable:()=>n.ExchangeNotAvailable,InsufficientFunds:()=>n.InsufficientFunds,InvalidAddress:()=>n.InvalidAddress,InvalidNonce:()=>n.InvalidNonce,InvalidOrder:()=>n.InvalidOrder,InvalidProxySettings:()=>n.InvalidProxySettings,ManualInteractionNeeded:()=>n.ManualInteractionNeeded,MarginModeAlreadySet:()=>n.MarginModeAlreadySet,MarketClosed:()=>n.MarketClosed,NetworkError:()=>n.NetworkError,NoChange:()=>n.NoChange,NotSupported:()=>n.NotSupported,NullResponse:()=>n.NullResponse,OnMaintenance:()=>n.OnMaintenance,OperationFailed:()=>n.OperationFailed,OperationRejected:()=>n.OperationRejected,OrderImmediatelyFillable:()=>n.OrderImmediatelyFillable,OrderNotCached:()=>n.OrderNotCached,OrderNotFillable:()=>n.OrderNotFillable,OrderNotFound:()=>n.OrderNotFound,PermissionDenied:()=>n.PermissionDenied,Precise:()=>a.Y,RateLimitExceeded:()=>n.RateLimitExceeded,RequestTimeout:()=>n.RequestTimeout,UnsubscribeError:()=>n.UnsubscribeError,ace:()=>d.A,alpaca:()=>h.A,ascendex:()=>c.A,bequant:()=>l.A,bigone:()=>u.A,binance:()=>p.A,binancecoinm:()=>f.A,binanceus:()=>m.A,binanceusdm:()=>g.A,bingx:()=>v.A,bit2c:()=>y.A,bitbank:()=>w.A,bitbay:()=>b.A,bitbns:()=>S.A,bitcoincom:()=>k.A,bitfinex:()=>O.A,bitfinex2:()=>T.A,bitflyer:()=>P.A,bitget:()=>I.A,bithumb:()=>x.A,bitmart:()=>A.A,bitmex:()=>M.A,bitopro:()=>C.A,bitpanda:()=>E.A,bitrue:()=>_.A,bitso:()=>B.A,bitstamp:()=>N.A,bitteam:()=>R.A,bitvavo:()=>L.A,bl3p:()=>V.A,blockchaincom:()=>D.A,blofin:()=>q.A,btcalpha:()=>F.A,btcbox:()=>G.A,btcmarkets:()=>H.A,btcturk:()=>U.A,bybit:()=>W.A,cex:()=>j.A,coinbase:()=>K.A,coinbaseadvanced:()=>Y.A,coinbaseexchange:()=>z.A,coinbaseinternational:()=>X.A,coincheck:()=>Q.A,coinex:()=>Z.A,coinlist:()=>$.A,coinmate:()=>J.A,coinmetro:()=>ee.A,coinone:()=>te.A,coinsph:()=>se.A,coinspot:()=>ie.A,cryptocom:()=>re.A,currencycom:()=>ae.A,default:()=>Cs,delta:()=>oe.A,deribit:()=>ne.A,digifinex:()=>de.A,errors:()=>n,exchanges:()=>As,exmo:()=>he.A,fmfwio:()=>ce.A,functions:()=>o,gate:()=>le.A,gateio:()=>ue.A,gemini:()=>pe.A,hashkey:()=>fe.A,hitbtc:()=>me.A,hitbtc3:()=>ge.A,hollaex:()=>ve.A,htx:()=>ye.A,huobi:()=>we.A,huobijp:()=>be.A,hyperliquid:()=>Se.A,idex:()=>ke.A,independentreserve:()=>Oe.A,indodax:()=>Te.A,kraken:()=>Pe.A,krakenfutures:()=>Ie.A,kucoin:()=>xe.A,kucoinfutures:()=>Ae.A,kuna:()=>Me.A,latoken:()=>Ce.A,lbank:()=>Ee.A,luno:()=>_e.A,lykke:()=>Be.A,mercado:()=>Ne.A,mexc:()=>Re.A,ndax:()=>Le.A,novadax:()=>Ve.A,oceanex:()=>De.A,okcoin:()=>qe.A,okx:()=>Fe.A,onetrading:()=>Ge.A,oxfun:()=>He.A,p2b:()=>Ue.A,paradex:()=>We.A,paymium:()=>je.A,phemex:()=>Ke.A,poloniex:()=>Ye.A,poloniexfutures:()=>ze.A,pro:()=>Ms,probit:()=>Xe.A,timex:()=>Qe.A,tokocrypto:()=>Ze.A,tradeogre:()=>$e.A,upbit:()=>Je.A,version:()=>xs,vertex:()=>et.A,wavesexchange:()=>tt.A,wazirx:()=>st.A,whitebit:()=>it.A,woo:()=>rt.A,woofipro:()=>at.A,xt:()=>ot.A,yobit:()=>nt.A,zaif:()=>dt.A,zonda:()=>ht.A});var r=s(2961),a=s(5147),o=s(5095),n=s(2079),d=s(6729),h=s(7930),c=s(1411),l=s(9002),u=s(8698),p=s(3192),f=s(1510),m=s(8228),g=s(2171),v=s(2480),y=s(2342),w=s(7399),b=s(8085),S=s(6328),k=s(8959),O=s(8657),T=s(8703),P=s(1787),I=s(7757),x=s(357),A=s(1837),M=s(9523),C=s(2753),E=s(9110),_=s(9061),B=s(3019),N=s(382),R=s(112),L=s(3727),V=s(5257),D=s(3205),q=s(2520),F=s(3413),G=s(5376),H=s(4936),U=s(9265),W=s(5462),j=s(8846),K=s(7504),Y=s(3278),z=s(4293),X=s(1558),Q=s(2741),Z=s(9344),$=s(7477),J=s(6016),ee=s(8692),te=s(5377),se=s(2692),ie=s(1669),re=s(6068),ae=s(8686),oe=s(1080),ne=s(2591),de=s(779),he=s(7057),ce=s(3042),le=s(9403),ue=s(784),pe=s(8823),fe=s(2937),me=s(7996),ge=s(3947),ve=s(4455),ye=s(9946),we=s(63),be=s(1325),Se=s(1936),ke=s(636),Oe=s(4162),Te=s(7325),Pe=s(8042),Ie=s(2300),xe=s(1397),Ae=s(6217),Me=s(5193),Ce=s(8146),Ee=s(3144),_e=s(9248),Be=s(1850),Ne=s(6419),Re=s(2403),Le=s(4460),Ve=s(8473),De=s(3805),qe=s(7915),Fe=s(3660),Ge=s(3573),He=s(6358),Ue=s(4998),We=s(6993),je=s(3280),Ke=s(9075),Ye=s(288),ze=s(6826),Xe=s(5037),Qe=s(6213),Ze=s(2490),$e=s(5887),Je=s(930),et=s(4910),tt=s(7073),st=s(3439),it=s(5336),rt=s(669),at=s(9641),ot=s(5344),nt=s(7469),dt=s(1530),ht=s(6022),ct=s(6810),lt=s(1657),ut=s(9338),pt=s(9544),ft=s(902),mt=s(8788),gt=s(8251),vt=s(9456),yt=s(5343),wt=s(1038),bt=s(8255),St=s(205),kt=s(6181),Ot=s(3069),Tt=s(3731),Pt=s(4401),It=s(8265),xt=s(3333),At=s(3326),Mt=s(1327),Ct=s(8693),Et=s(1672),_t=s(8518),Bt=s(3774),Nt=s(8160),Rt=s(1925),Lt=s(998),Vt=s(5317),Dt=s(9088),qt=s(8673),Ft=s(6292),Gt=s(6302),Ht=s(7791),Ut=s(5233),Wt=s(9195),jt=s(5843),Kt=s(375),Yt=s(1481),zt=s(4524),Xt=s(8247),Qt=s(3898),Zt=s(6335),$t=s(6973),Jt=s(3984),es=s(460),ts=s(98),ss=s(9050),is=s(6396),rs=s(4965),as=s(905),os=s(1736),ns=s(2208),ds=s(9219),hs=s(3887),cs=s(6187),ls=s(8588),us=s(4357),ps=s(550),fs=s(4934),ms=s(1057),gs=s(1619),vs=s(3456),ys=s(5850),ws=s(5738),bs=s(5794),Ss=s(910),ks=s(9279),Os=s(4712),Ts=s(5869),Ps=s(8713),Is=s(2368);const xs="4.3.92";r.k.ccxtVersion=xs;const As={ace:d.A,alpaca:h.A,ascendex:c.A,bequant:l.A,bigone:u.A,binance:p.A,binancecoinm:f.A,binanceus:m.A,binanceusdm:g.A,bingx:v.A,bit2c:y.A,bitbank:w.A,bitbay:b.A,bitbns:S.A,bitcoincom:k.A,bitfinex:O.A,bitfinex2:T.A,bitflyer:P.A,bitget:I.A,bithumb:x.A,bitmart:A.A,bitmex:M.A,bitopro:C.A,bitpanda:E.A,bitrue:_.A,bitso:B.A,bitstamp:N.A,bitteam:R.A,bitvavo:L.A,bl3p:V.A,blockchaincom:D.A,blofin:q.A,btcalpha:F.A,btcbox:G.A,btcmarkets:H.A,btcturk:U.A,bybit:W.A,cex:j.A,coinbase:K.A,coinbaseadvanced:Y.A,coinbaseexchange:z.A,coinbaseinternational:X.A,coincheck:Q.A,coinex:Z.A,coinlist:$.A,coinmate:J.A,coinmetro:ee.A,coinone:te.A,coinsph:se.A,coinspot:ie.A,cryptocom:re.A,currencycom:ae.A,delta:oe.A,deribit:ne.A,digifinex:de.A,exmo:he.A,fmfwio:ce.A,gate:le.A,gateio:ue.A,gemini:pe.A,hashkey:fe.A,hitbtc:me.A,hitbtc3:ge.A,hollaex:ve.A,htx:ye.A,huobi:we.A,huobijp:be.A,hyperliquid:Se.A,idex:ke.A,independentreserve:Oe.A,indodax:Te.A,kraken:Pe.A,krakenfutures:Ie.A,kucoin:xe.A,kucoinfutures:Ae.A,kuna:Me.A,latoken:Ce.A,lbank:Ee.A,luno:_e.A,lykke:Be.A,mercado:Ne.A,mexc:Re.A,ndax:Le.A,novadax:Ve.A,oceanex:De.A,okcoin:qe.A,okx:Fe.A,onetrading:Ge.A,oxfun:He.A,p2b:Ue.A,paradex:We.A,paymium:je.A,phemex:Ke.A,poloniex:Ye.A,poloniexfutures:ze.A,probit:Xe.A,timex:Qe.A,tokocrypto:Ze.A,tradeogre:$e.A,upbit:Je.A,vertex:et.A,wavesexchange:tt.A,wazirx:st.A,whitebit:it.A,woo:rt.A,woofipro:at.A,xt:ot.A,yobit:nt.A,zaif:dt.A,zonda:ht.A},Ms={alpaca:ct.A,ascendex:lt.A,bequant:ut.A,binance:pt.A,binancecoinm:ft.A,binanceus:mt.A,binanceusdm:gt.A,bingx:vt.A,bitcoincom:yt.A,bitfinex:wt.A,bitfinex2:bt.A,bitget:St.A,bithumb:kt.A,bitmart:Ot.A,bitmex:Tt.A,bitopro:Pt.A,bitpanda:It.A,bitrue:xt.A,bitstamp:At.A,bitvavo:Mt.A,blockchaincom:Ct.A,blofin:Et.A,bybit:_t.A,cex:Bt.A,coinbase:Nt.A,coinbaseexchange:Rt.A,coinbaseinternational:Lt.A,coincheck:Vt.A,coinex:Dt.A,coinone:qt.A,cryptocom:Ft.A,currencycom:Gt.A,deribit:Ht.A,exmo:Ut.A,gate:Wt.A,gateio:jt.A,gemini:Kt.A,hashkey:Yt.A,hitbtc:zt.A,hollaex:Xt.A,htx:Qt.A,huobi:Zt.A,huobijp:$t.A,hyperliquid:Jt.A,idex:es.A,independentreserve:ts.A,kraken:ss.A,krakenfutures:is.A,kucoin:rs.A,kucoinfutures:as.A,lbank:os.A,luno:ns.A,mexc:ds.A,ndax:hs.A,okcoin:cs.A,okx:ls.A,onetrading:us.A,oxfun:ps.A,p2b:fs.A,paradex:ms.A,phemex:gs.A,poloniex:vs.A,poloniexfutures:ys.A,probit:ws.A,upbit:bs.A,vertex:Ss.A,wazirx:ks.A,whitebit:Os.A,woo:Ts.A,woofipro:Ps.A,xt:Is.A};for(const e in Ms);Ms.exchanges=Object.keys(Ms),Ms.Exchange=r.k;const Cs=Object.assign({version:xs,Exchange:r.k,Precise:a.Y,exchanges:Object.keys(As),pro:Ms},As,o,n);self.ccxt=i})();