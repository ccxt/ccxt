package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bingx struct {
	Exchange
}

func NewBingxCore() *bingx {
	p := &bingx{}
	setDefaults(p)
	return p
}

func (this *bingx) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bingx",
		"name":      "BingX",
		"countries": []interface{}{"US"},
		"rateLimit": 100,
		"version":   "v1",
		"certified": true,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               false,
			"swap":                                 true,
			"future":                               false,
			"option":                               false,
			"addMargin":                            true,
			"cancelAllOrders":                      true,
			"cancelAllOrdersAfter":                 true,
			"cancelOrder":                          true,
			"cancelOrders":                         true,
			"closeAllPositions":                    true,
			"closePosition":                        true,
			"createMarketBuyOrderWithCost":         true,
			"createMarketOrderWithCost":            true,
			"createMarketSellOrderWithCost":        true,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createReduceOnlyOrder":                true,
			"createStopLossOrder":                  true,
			"createStopOrder":                      true,
			"createTakeProfitOrder":                true,
			"createTrailingAmountOrder":            true,
			"createTrailingPercentOrder":           true,
			"createTriggerOrder":                   true,
			"editOrder":                            true,
			"fetchBalance":                         true,
			"fetchCanceledOrders":                  true,
			"fetchClosedOrders":                    true,
			"fetchCurrencies":                      true,
			"fetchDepositAddress":                  true,
			"fetchDepositAddresses":                false,
			"fetchDepositAddressesByNetwork":       true,
			"fetchDeposits":                        true,
			"fetchDepositWithdrawFee":              "emulated",
			"fetchDepositWithdrawFees":             true,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    true,
			"fetchLeverage":                        true,
			"fetchLiquidations":                    false,
			"fetchMarginAdjustmentHistory":         false,
			"fetchMarginMode":                      true,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       true,
			"fetchMarkPrice":                       true,
			"fetchMarkPrices":                      true,
			"fetchMyLiquidations":                  true,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    true,
			"fetchOpenOrders":                      true,
			"fetchOrder":                           true,
			"fetchOrderBook":                       true,
			"fetchOrders":                          true,
			"fetchPosition":                        true,
			"fetchPositionHistory":                 false,
			"fetchPositionMode":                    true,
			"fetchPositions":                       true,
			"fetchPositionsHistory":                true,
			"fetchTicker":                          true,
			"fetchTickers":                         true,
			"fetchTime":                            true,
			"fetchTrades":                          true,
			"fetchTradingFee":                      true,
			"fetchTransfers":                       true,
			"fetchWithdrawals":                     true,
			"reduceMargin":                         true,
			"sandbox":                              true,
			"setLeverage":                          true,
			"setMargin":                            true,
			"setMarginMode":                        true,
			"setPositionMode":                      true,
			"transfer":                             true,
		},
		"hostname": "bingx.com",
		"urls": map[string]interface{}{
			"logo": "https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/253675376-6983b72e-4999-4549-b177-33b374c195e3.jpg",
			"api": map[string]interface{}{
				"fund":        "https://open-api.{hostname}/openApi",
				"spot":        "https://open-api.{hostname}/openApi",
				"swap":        "https://open-api.{hostname}/openApi",
				"contract":    "https://open-api.{hostname}/openApi",
				"wallets":     "https://open-api.{hostname}/openApi",
				"user":        "https://open-api.{hostname}/openApi",
				"subAccount":  "https://open-api.{hostname}/openApi",
				"account":     "https://open-api.{hostname}/openApi",
				"copyTrading": "https://open-api.{hostname}/openApi",
				"cswap":       "https://open-api.{hostname}/openApi",
				"api":         "https://open-api.{hostname}/openApi",
			},
			"test": map[string]interface{}{
				"swap": "https://open-api-vst.{hostname}/openApi",
			},
			"www":      "https://bingx.com/",
			"doc":      "https://bingx-api.github.io/docs/",
			"referral": "https://bingx.com/invite/OHETOM",
		},
		"fees": map[string]interface{}{
			"tierBased": true,
			"spot": map[string]interface{}{
				"feeSide": "get",
				"maker":   this.ParseNumber("0.001"),
				"taker":   this.ParseNumber("0.001"),
			},
			"swap": map[string]interface{}{
				"feeSide": "quote",
				"maker":   this.ParseNumber("0.0002"),
				"taker":   this.ParseNumber("0.0005"),
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey": true,
			"secret": true,
		},
		"api": map[string]interface{}{
			"fund": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"account/balance": 1,
						},
					},
				},
			},
			"spot": map[string]interface{}{
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"server/time":       1,
							"common/symbols":    1,
							"market/trades":     1,
							"market/depth":      1,
							"market/kline":      1,
							"ticker/24hr":       1,
							"ticker/price":      1,
							"ticker/bookTicker": 1,
						},
					},
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"trade/query":         1,
							"trade/openOrders":    1,
							"trade/historyOrders": 1,
							"trade/myTrades":      2,
							"user/commissionRate": 5,
							"account/balance":     2,
						},
						"post": map[string]interface{}{
							"trade/order":               2,
							"trade/cancel":              2,
							"trade/batchOrders":         5,
							"trade/order/cancelReplace": 5,
							"trade/cancelOrders":        5,
							"trade/cancelOpenOrders":    5,
							"trade/cancelAllAfter":      5,
						},
					},
				},
				"v2": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"market/depth": 1,
							"market/kline": 1,
						},
					},
				},
				"v3": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"get/asset/transfer":       1,
							"asset/transfer":           1,
							"capital/deposit/hisrec":   1,
							"capital/withdraw/history": 1,
						},
						"post": map[string]interface{}{
							"post/asset/transfer": 5,
						},
					},
				},
			},
			"swap": map[string]interface{}{
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"ticker/price":            1,
							"market/historicalTrades": 1,
							"market/markPriceKlines":  1,
							"trade/multiAssetsRules":  1,
						},
					},
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"positionSide/dual":        5,
							"trade/batchCancelReplace": 5,
							"trade/fullOrder":          2,
							"maintMarginRatio":         2,
							"trade/positionHistory":    2,
							"positionMargin/history":   2,
							"twap/openOrders":          5,
							"twap/historyOrders":       5,
							"twap/orderDetail":         5,
							"trade/assetMode":          5,
							"user/marginAssets":        5,
						},
						"post": map[string]interface{}{
							"trade/cancelReplace":      2,
							"positionSide/dual":        5,
							"trade/batchCancelReplace": 5,
							"trade/closePosition":      2,
							"trade/getVst":             5,
							"twap/order":               5,
							"twap/cancelOrder":         5,
							"trade/assetMode":          5,
						},
					},
				},
				"v2": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"server/time":        1,
							"quote/contracts":    1,
							"quote/price":        1,
							"quote/depth":        1,
							"quote/trades":       1,
							"quote/premiumIndex": 1,
							"quote/fundingRate":  1,
							"quote/klines":       1,
							"quote/openInterest": 1,
							"quote/ticker":       1,
							"quote/bookTicker":   1,
						},
					},
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"user/balance":        2,
							"user/positions":      2,
							"user/income":         2,
							"trade/openOrders":    2,
							"trade/openOrder":     2,
							"trade/order":         2,
							"trade/marginType":    5,
							"trade/leverage":      2,
							"trade/forceOrders":   1,
							"trade/allOrders":     2,
							"trade/allFillOrders": 2,
							"trade/fillHistory":   2,
							"user/income/export":  2,
							"user/commissionRate": 2,
							"quote/bookTicker":    1,
						},
						"post": map[string]interface{}{
							"trade/order":             2,
							"trade/batchOrders":       2,
							"trade/closeAllPositions": 2,
							"trade/cancelAllAfter":    5,
							"trade/marginType":        5,
							"trade/leverage":          5,
							"trade/positionMargin":    5,
							"trade/order/test":        2,
						},
						"delete": map[string]interface{}{
							"trade/order":         2,
							"trade/batchOrders":   2,
							"trade/allOpenOrders": 2,
						},
					},
				},
				"v3": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"quote/klines": 1,
						},
					},
				},
			},
			"cswap": map[string]interface{}{
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"market/contracts":    1,
							"market/premiumIndex": 1,
							"market/openInterest": 1,
							"market/klines":       1,
							"market/depth":        1,
							"market/ticker":       1,
						},
					},
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"trade/leverage":      2,
							"trade/forceOrders":   2,
							"trade/allFillOrders": 2,
							"trade/openOrders":    2,
							"trade/orderDetail":   2,
							"trade/orderHistory":  2,
							"trade/marginType":    2,
							"user/commissionRate": 2,
							"user/positions":      2,
							"user/balance":        2,
						},
						"post": map[string]interface{}{
							"trade/order":             2,
							"trade/leverage":          2,
							"trade/allOpenOrders":     2,
							"trade/closeAllPositions": 2,
							"trade/marginType":        2,
							"trade/positionMargin":    2,
						},
						"delete": map[string]interface{}{
							"trade/allOpenOrders": 2,
							"trade/cancelOrder":   2,
						},
					},
				},
			},
			"contract": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"allPosition": 2,
							"allOrders":   2,
							"balance":     2,
						},
					},
				},
			},
			"wallets": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"capital/config/getall":                    5,
							"capital/deposit/address":                  5,
							"capital/innerTransfer/records":            1,
							"capital/subAccount/deposit/address":       5,
							"capital/deposit/subHisrec":                2,
							"capital/subAccount/innerTransfer/records": 1,
							"capital/deposit/riskRecords":              5,
						},
						"post": map[string]interface{}{
							"capital/withdraw/apply":                5,
							"capital/innerTransfer/apply":           5,
							"capital/subAccountInnerTransfer/apply": 2,
							"capital/deposit/createSubAddress":      2,
						},
					},
				},
			},
			"subAccount": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"list":              10,
							"assets":            2,
							"allAccountBalance": 2,
						},
						"post": map[string]interface{}{
							"create":        10,
							"apiKey/create": 2,
							"apiKey/edit":   2,
							"apiKey/del":    2,
							"updateStatus":  10,
						},
					},
				},
			},
			"account": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"uid":                    1,
							"apiKey/query":           2,
							"account/apiPermissions": 5,
							"allAccountBalance":      2,
						},
						"post": map[string]interface{}{
							"innerTransfer/authorizeSubAccount": 1,
						},
					},
				},
				"transfer": map[string]interface{}{
					"v1": map[string]interface{}{
						"private": map[string]interface{}{
							"get": map[string]interface{}{
								"subAccount/asset/transferHistory": 1,
							},
							"post": map[string]interface{}{
								"subAccount/transferAsset/supportCoins": 1,
								"subAccount/transferAsset":              1,
							},
						},
					},
				},
			},
			"user": map[string]interface{}{
				"auth": map[string]interface{}{
					"private": map[string]interface{}{
						"post": map[string]interface{}{
							"userDataStream": 2,
						},
						"put": map[string]interface{}{
							"userDataStream": 2,
						},
						"delete": map[string]interface{}{
							"userDataStream": 2,
						},
					},
				},
			},
			"copyTrading": map[string]interface{}{
				"v1": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"swap/trace/currentTrack": 2,
						},
						"post": map[string]interface{}{
							"swap/trace/closeTrackOrder": 2,
							"swap/trace/setTPSL":         2,
							"spot/trader/sellOrder":      10,
						},
					},
				},
			},
			"api": map[string]interface{}{
				"v3": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"asset/transfer":           1,
							"asset/transferRecord":     5,
							"capital/deposit/hisrec":   1,
							"capital/withdraw/history": 1,
						},
						"post": map[string]interface{}{
							"post/asset/transfer": 1,
						},
					},
				},
				"asset": map[string]interface{}{
					"v1": map[string]interface{}{
						"private": map[string]interface{}{
							"post": map[string]interface{}{
								"transfer": 5,
							},
						},
						"public": map[string]interface{}{
							"get": map[string]interface{}{
								"transfer/supportCoins": 5,
							},
						},
					},
				},
			},
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1d",
			"3d":  "3d",
			"1w":  "1w",
			"1M":  "1M",
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"400":                  BadRequest,
				"401":                  AuthenticationError,
				"403":                  PermissionDenied,
				"404":                  BadRequest,
				"429":                  DDoSProtection,
				"418":                  PermissionDenied,
				"500":                  ExchangeError,
				"504":                  ExchangeError,
				"100001":               AuthenticationError,
				"100412":               AuthenticationError,
				"100202":               InsufficientFunds,
				"100204":               BadRequest,
				"100400":               BadRequest,
				"100410":               OperationFailed,
				"100421":               BadSymbol,
				"100440":               ExchangeError,
				"100500":               OperationFailed,
				"100503":               ExchangeError,
				"80001":                BadRequest,
				"80012":                InsufficientFunds,
				"80014":                BadRequest,
				"80016":                OrderNotFound,
				"80017":                OrderNotFound,
				"100414":               AccountSuspended,
				"100419":               PermissionDenied,
				"100437":               BadRequest,
				"101204":               InsufficientFunds,
				"110425":               InvalidOrder,
				"Insufficient assets":  InsufficientFunds,
				"illegal transferType": BadRequest,
			},
			"broad": map[string]interface{}{},
		},
		"commonCurrencies": map[string]interface{}{
			"SNOW":     "Snowman",
			"OMNI":     "OmniCat",
			"NAP":      "$NAP",
			"TRUMP":    "TRUMPMAGA",
			"TRUMPSOL": "TRUMP",
		},
		"options": map[string]interface{}{
			"defaultType": "spot",
			"accountsByType": map[string]interface{}{
				"funding": "fund",
				"spot":    "spot",
				"future":  "stdFutures",
				"swap":    "USDTMPerp",
				"linear":  "USDTMPerp",
				"inverse": "coinMPerp",
			},
			"accountsById": map[string]interface{}{
				"fund":       "funding",
				"spot":       "spot",
				"stdFutures": "future",
				"USDTMPerp":  "linear",
				"coinMPerp":  "inverse",
			},
			"recvWindow": Multiply(5, 1000),
			"broker":     "CCXT",
			"defaultNetworks": map[string]interface{}{
				"ETH":  "ETH",
				"USDT": "ERC20",
				"USDC": "ERC20",
				"BTC":  "BTC",
				"LTC":  "LTC",
			},
			"networks": map[string]interface{}{
				"ARBITRUM": "ARB",
				"MATIC":    "POLYGON",
				"ZKSYNC":   "ZKSYNCERA",
				"AVAXC":    "AVAX-C",
				"HBAR":     "HEDERA",
			},
		},
		"features": map[string]interface{}{
			"defaultForLinear": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":   false,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": true,
					},
					"triggerDirection": false,
					"stopLossPrice":    true,
					"takeProfitPrice":  true,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  true,
							"mark":  true,
							"index": true,
						},
						"price": true,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 true,
					"trailing":               true,
					"leverage":               false,
					"marketBuyRequiresPrice": false,
					"marketBuyByCost":        true,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": map[string]interface{}{
					"max": 5,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          512,
					"daysBack":       30,
					"untilDays":      30,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       20000,
					"untilDays":      7,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            1000,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        7,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1440,
				},
			},
			"defaultForInverse": map[string]interface{}{
				"extends": "defaultForLinear",
				"fetchMyTrades": map[string]interface{}{
					"limit":     1000,
					"daysBack":  nil,
					"untilDays": nil,
				},
				"fetchOrders": nil,
			},
			"spot": map[string]interface{}{
				"extends": "defaultForLinear",
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
				"createOrder": map[string]interface{}{
					"triggerPriceType":           nil,
					"attachedStopLossTakeProfit": nil,
					"trailing":                   false,
				},
				"fetchMyTrades": map[string]interface{}{
					"limit":     1000,
					"daysBack":  1,
					"untilDays": 1,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"limit":     100,
					"untilDays": nil,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "defaultForLinear",
				},
				"inverse": map[string]interface{}{
					"extends": "defaultForInverse",
				},
			},
			"defaultForFuture": map[string]interface{}{
				"extends":     "defaultForLinear",
				"fetchOrders": nil,
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "defaultForFuture",
				},
				"inverse": map[string]interface{}{
					"extends": "defaultForFuture",
				},
			},
		},
	})
}

/**
 * @method
 * @name bingx#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the bingx server
 * @see https://bingx-api.github.io/docs/#/swapV2/base-info.html#Get%20Server%20Time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the bingx server
 */
func (this *bingx) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SwapV2PublicGetServerTime(params))
		PanicOnError(response)
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": {
		//            "serverTime": 1675319535362
		//        }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.SafeInteger(data, "serverTime")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *bingx) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if !IsTrue(this.CheckRequiredCredentials(false)) {

			ch <- map[string]interface{}{}
			return nil
		}
		var isSandbox interface{} = this.SafeBool(this.Options, "sandboxMode", false)
		if IsTrue(isSandbox) {

			ch <- map[string]interface{}{}
			return nil
		}

		response := (<-this.WalletsV1PrivateGetCapitalConfigGetall(params))
		PanicOnError(response)
		//
		//    {
		//      "code": 0,
		//      "timestamp": 1702623271476,
		//      "data": [
		//        {
		//          "coin": "BTC",
		//          "name": "BTC",
		//          "networkList": [
		//            {
		//              "name": "BTC",
		//              "network": "BTC",
		//              "isDefault": true,
		//              "minConfirm": 2,
		//              "withdrawEnable": true,
		//              "depositEnable": true,
		//              "withdrawFee": "0.0006",
		//              "withdrawMax": "1.17522",
		//              "withdrawMin": "0.0005",
		//              "depositMin": "0.0002"
		//            },
		//            {
		//              "name": "BTC",
		//              "network": "BEP20",
		//              "isDefault": false,
		//              "minConfirm": 15,
		//              "withdrawEnable": true,
		//              "depositEnable": true,
		//              "withdrawFee": "0.0000066",
		//              "withdrawMax": "1.17522",
		//              "withdrawMin": "0.0000066",
		//              "depositMin": "0.0002"
		//            }
		//          ]
		//        }
		//      ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var currencyId interface{} = this.SafeString(entry, "coin")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var name interface{} = this.SafeString(entry, "name")
			var networkList interface{} = this.SafeList(entry, "networkList")
			var networks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
				var rawNetwork interface{} = GetValue(networkList, j)
				var network interface{} = this.SafeString(rawNetwork, "network")
				var networkCode interface{} = this.NetworkIdToCode(network)
				var limits interface{} = map[string]interface{}{
					"withdraw": map[string]interface{}{
						"min": this.SafeNumber(rawNetwork, "withdrawMin"),
						"max": this.SafeNumber(rawNetwork, "withdrawMax"),
					},
					"deposit": map[string]interface{}{
						"min": this.SafeNumber(rawNetwork, "depositMin"),
						"max": nil,
					},
				}
				var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(rawNetwork, "withdrawPrecision")))
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"info":      rawNetwork,
					"id":        network,
					"network":   networkCode,
					"fee":       this.SafeNumber(rawNetwork, "withdrawFee"),
					"active":    nil,
					"deposit":   this.SafeBool(rawNetwork, "depositEnable"),
					"withdraw":  this.SafeBool(rawNetwork, "withdrawEnable"),
					"precision": precision,
					"limits":    limits,
				})
			}
			if !IsTrue((InOp(result, code))) {
				AddElementToObject(result, code, map[string]interface{}{
					"info":      entry,
					"code":      code,
					"id":        currencyId,
					"precision": nil,
					"name":      name,
					"active":    nil,
					"deposit":   nil,
					"withdraw":  nil,
					"networks":  networks,
					"fee":       nil,
					"limits":    nil,
					"type":      "crypto",
				})
			} else {
				var existing interface{} = GetValue(result, code)
				var existingNetworks interface{} = this.SafeDict(existing, "networks", map[string]interface{}{})
				var newNetworkCodes interface{} = ObjectKeys(networks)
				for j := 0; IsLessThan(j, GetArrayLength(newNetworkCodes)); j++ {
					var newNetworkCode interface{} = GetValue(newNetworkCodes, j)
					if !IsTrue((InOp(existingNetworks, newNetworkCode))) {
						AddElementToObject(existingNetworks, newNetworkCode, GetValue(networks, newNetworkCode))
					}
				}
				AddElementToObject(GetValue(result, code), "networks", existingNetworks)
			}
		}
		var codes interface{} = ObjectKeys(result)
		for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
			var code interface{} = GetValue(codes, i)
			var currency interface{} = GetValue(result, code)
			AddElementToObject(result, code, this.SafeCurrencyStructure(currency))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *bingx) FetchSpotMarkets(params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		response := (<-this.SpotV1PublicGetCommonSymbols(params))
		PanicOnError(response)
		//
		//    {
		//        "code": 0,
		//            "msg": "",
		//            "debugMsg": "",
		//            "data": {
		//              "symbols": [
		//                  {
		//                    "symbol": "GEAR-USDT",
		//                    "minQty": 735, // deprecated
		//                    "maxQty": 2941177, // deprecated.
		//                    "minNotional": 5,
		//                    "maxNotional": 20000,
		//                    "status": 1,
		//                    "tickSize": 0.000001,
		//                    "stepSize": 1,
		//                    "apiStateSell": true,
		//                    "apiStateBuy": true,
		//                    "timeOnline": 0,
		//                    "offTime": 0,
		//                    "maintainTime": 0
		//                  },
		//                  ...
		//              ]
		//         }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data")
		var markets interface{} = this.SafeList(data, "symbols", []interface{}{})

		ch <- this.ParseMarkets(markets)
		return nil

	}()
	return ch
}
func (this *bingx) FetchSwapMarkets(params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		response := (<-this.SwapV2PublicGetQuoteContracts(params))
		PanicOnError(response)
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": [
		//            {
		//                "contractId": "100",
		//                "symbol": "BTC-USDT",
		//                "size": "0.0001",
		//                "quantityPrecision": "4",
		//                "pricePrecision": "1",
		//                "feeRate": "0.0005",
		//                "makerFeeRate": "0.0002",
		//                "takerFeeRate": "0.0005",
		//                "tradeMinLimit": "0",
		//                "tradeMinQuantity": "0.0001",
		//                "tradeMinUSDT": "2",
		//                "maxLongLeverage": "125",
		//                "maxShortLeverage": "125",
		//                "currency": "USDT",
		//                "asset": "BTC",
		//                "status": "1",
		//                "apiStateOpen": "true",
		//                "apiStateClose": "true",
		//                "ensureTrigger": true,
		//                "triggerFeeRate": "0.00020000"
		//            },
		//            ...
		//        ]
		//    }
		//
		var markets interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(markets)
		return nil

	}()
	return ch
}
func (this *bingx) FetchInverseSwapMarkets(params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		response := (<-this.CswapV1PublicGetMarketContracts(params))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1720074487610,
		//         "data": [
		//             {
		//                 "symbol": "BNB-USD",
		//                 "pricePrecision": 2,
		//                 "minTickSize": "10",
		//                 "minTradeValue": "10",
		//                 "minQty": "1.00000000",
		//                 "status": 1,
		//                 "timeOnline": 1713175200000
		//             },
		//         ]
		//     }
		//
		var markets interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(markets)
		return nil

	}()
	return ch
}
func (this *bingx) ParseMarket(market interface{}) interface{} {
	var id interface{} = this.SafeString(market, "symbol")
	var symbolParts interface{} = Split(id, "-")
	var baseId interface{} = GetValue(symbolParts, 0)
	var quoteId interface{} = GetValue(symbolParts, 1)
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var currency interface{} = this.SafeString(market, "currency")
	var checkIsInverse interface{} = false
	var checkIsLinear interface{} = true
	var minTickSize interface{} = this.SafeNumber(market, "minTickSize")
	if IsTrue(!IsEqual(minTickSize, nil)) {
		// inverse swap market
		currency = baseId
		checkIsInverse = true
		checkIsLinear = false
	}
	var settle interface{} = this.SafeCurrencyCode(currency)
	var pricePrecision interface{} = this.SafeNumber(market, "tickSize")
	if IsTrue(IsEqual(pricePrecision, nil)) {
		pricePrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "pricePrecision")))
	}
	var quantityPrecision interface{} = this.SafeNumber(market, "stepSize")
	if IsTrue(IsEqual(quantityPrecision, nil)) {
		quantityPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityPrecision")))
	}
	var typeVar interface{} = Ternary(IsTrue((!IsEqual(settle, nil))), "swap", "spot")
	var spot interface{} = IsEqual(typeVar, "spot")
	var swap interface{} = IsEqual(typeVar, "swap")
	var symbol interface{} = Add(Add(base, "/"), quote)
	if IsTrue(!IsEqual(settle, nil)) {
		symbol = Add(symbol, Add(":", settle))
	}
	var fees interface{} = this.SafeDict(this.Fees, typeVar, map[string]interface{}{})
	var contractSize interface{} = Ternary(IsTrue((swap)), this.ParseNumber("1"), nil)
	var isActive interface{} = false
	if IsTrue(IsTrue((IsEqual(this.SafeString(market, "apiStateOpen"), "true"))) && IsTrue((IsEqual(this.SafeString(market, "apiStateClose"), "true")))) {
		isActive = true // swap active
	} else if IsTrue(IsTrue(IsTrue(this.SafeBool(market, "apiStateSell")) && IsTrue(this.SafeBool(market, "apiStateBuy"))) && IsTrue((IsEqual(this.SafeString(market, "status"), "1")))) {
		isActive = true // spot active
	}
	var isInverse interface{} = Ternary(IsTrue((spot)), nil, checkIsInverse)
	var isLinear interface{} = Ternary(IsTrue((spot)), nil, checkIsLinear)
	var minAmount interface{} = nil
	if !IsTrue(spot) {
		minAmount = this.SafeNumber2(market, "minQty", "tradeMinQuantity")
	}
	var timeOnline interface{} = this.SafeInteger(market, "timeOnline")
	if IsTrue(IsEqual(timeOnline, 0)) {
		timeOnline = nil
	}
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       currency,
		"type":           typeVar,
		"spot":           spot,
		"margin":         false,
		"swap":           swap,
		"future":         false,
		"option":         false,
		"active":         isActive,
		"contract":       swap,
		"linear":         isLinear,
		"inverse":        isInverse,
		"taker":          this.SafeNumber(fees, "taker"),
		"maker":          this.SafeNumber(fees, "maker"),
		"feeSide":        this.SafeString(fees, "feeSide"),
		"contractSize":   contractSize,
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": quantityPrecision,
			"price":  pricePrecision,
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"amount": map[string]interface{}{
				"min": minAmount,
				"max": nil,
			},
			"price": map[string]interface{}{
				"min": minTickSize,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": this.SafeNumberN(market, []interface{}{"minNotional", "tradeMinUSDT", "minTradeValue"}),
				"max": this.SafeNumber(market, "maxNotional"),
			},
		},
		"created": timeOnline,
		"info":    market,
	})
}

/**
 * @method
 * @name bingx#fetchMarkets
 * @description retrieves data on all markets for bingx
 * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20Symbols
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Contract%20Information
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Contract%20Information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *bingx) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var requests interface{} = []interface{}{this.FetchSwapMarkets(params)}
		var isSandbox interface{} = this.SafeBool(this.Options, "sandboxMode", false)
		if !IsTrue(isSandbox) {
			AppendToArray(&requests, this.FetchInverseSwapMarkets(params))
			AppendToArray(&requests, this.FetchSpotMarkets(params)) // sandbox is swap only
		}

		promises := (<-promiseAll(requests))
		PanicOnError(promises)
		var linearSwapMarkets interface{} = this.SafeList(promises, 0, []interface{}{})
		var inverseSwapMarkets interface{} = this.SafeList(promises, 1, []interface{}{})
		var spotMarkets interface{} = this.SafeList(promises, 2, []interface{}{})
		var swapMarkets interface{} = this.ArrayConcat(linearSwapMarkets, inverseSwapMarkets)

		ch <- this.ArrayConcat(spotMarkets, swapMarkets)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#K-Line%20Data
 * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Candlestick%20chart%20data
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#%20K-Line%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Mark%20Price%20Kline/Candlestick%20Data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Get%20K-line%20Data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *bingx) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11068 := (<-this.LoadMarkets())
		PanicOnError(retRes11068)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes111019 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1440))
			PanicOnError(retRes111019)
			ch <- retRes111019
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		AddElementToObject(request, "interval", this.SafeString(this.Timeframes, timeframe, timeframe))
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", mathMax(Subtract(since, 1), 0))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger2(params, "until", "endTime")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, []interface{}{"until"})
			AddElementToObject(request, "endTime", until)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.SpotV1PublicGetMarketKline(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PublicGetMarketKlines(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				var price interface{} = this.SafeString(params, "price")
				params = this.Omit(params, "price")
				if IsTrue(IsEqual(price, "mark")) {

					response = (<-this.SwapV1PublicGetMarketMarkPriceKlines(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.SwapV3PublicGetQuoteKlines(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		}
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": [
		//          {
		//            "open": "19396.8",
		//            "close": "19394.4",
		//            "high": "19397.5",
		//            "low": "19385.7",
		//            "volume": "110.05",
		//            "time": 1666583700000
		//          },
		//          ...
		//        ]
		//    }
		//
		// fetchMarkOHLCV
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": [
		//            {
		//                "open": "42191.7",
		//                "close": "42189.5",
		//                "high": "42196.5",
		//                "low": "42189.5",
		//                "volume": "0.00",
		//                "openTime": 1706508840000,
		//                "closeTime": 1706508840000
		//            }
		//        ]
		//    }
		//
		var ohlcvs interface{} = this.SafeValue(response, "data", []interface{}{})
		if !IsTrue(IsArray(ohlcvs)) {
			ohlcvs = []interface{}{ohlcvs}
		}

		ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "open": "19394.4",
	//        "close": "19379.0",
	//        "high": "19394.4",
	//        "low": "19368.3",
	//        "volume": "167.44",
	//        "time": 1666584000000
	//    }
	//
	// fetchMarkOHLCV
	//
	//    {
	//        "open": "42191.7",
	//        "close": "42189.5",
	//        "high": "42196.5",
	//        "low": "42189.5",
	//        "volume": "0.00",
	//        "openTime": 1706508840000,
	//        "closeTime": 1706508840000
	//    }
	// spot
	//    [
	//        1691402580000,
	//        29093.61,
	//        29093.93,
	//        29087.73,
	//        29093.24,
	//        0.59,
	//        1691402639999,
	//        17221.07
	//    ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	if IsTrue(IsArray(ohlcv)) {
		return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
	}
	return []interface{}{this.SafeInteger2(ohlcv, "time", "closeTime"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}

/**
 * @method
 * @name bingx#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20transaction%20records
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#The%20latest%20Trade%20of%20a%20Trading%20Pair
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *bingx) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes12538 := (<-this.LoadMarkets())
		PanicOnError(retRes12538)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", mathMin(limit, 100)) // avoid API exception "limit should less than 100"
		}
		var response interface{} = nil
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTrades", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotV1PublicGetMarketTrades(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PublicGetQuoteTrades(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//    {
		//        "code": 0,
		//        "data": [
		//            {
		//                "id": 43148253,
		//                "price": 25714.71,
		//                "qty": 1.674571,
		//                "time": 1655085975589,
		//                "buyerMaker": false
		//            }
		//        ]
		//    }
		//
		// swap
		//
		//    {
		//      "code":0,
		//      "msg":"",
		//      "data":[
		//        {
		//          "time": 1672025549368,
		//          "isBuyerMaker": true,
		//          "price": "16885.0",
		//          "qty": "3.3002",
		//          "quoteQty": "55723.87"
		//        },
		//        ...
		//      ]
		//    }
		//
		var trades interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot fetchTrades
	//
	//    {
	//        "id": 43148253,
	//        "price": 25714.71,
	//        "qty": 1.674571,
	//        "time": 1655085975589,
	//        "buyerMaker": false
	//    }
	//
	// spot fetchMyTrades
	//
	//     {
	//         "symbol": "LTC-USDT",
	//         "id": 36237072,
	//         "orderId": 1674069326895775744,
	//         "price": "85.891",
	//         "qty": "0.0582",
	//         "quoteQty": "4.9988562000000005",
	//         "commission": -0.00005820000000000001,
	//         "commissionAsset": "LTC",
	//         "time": 1687964205000,
	//         "isBuyer": true,
	//         "isMaker": false
	//     }
	//
	// swap fetchTrades
	//
	//    {
	//        "time": 1672025549368,
	//        "isBuyerMaker": true,
	//        "price": "16885.0",
	//        "qty": "3.3002",
	//        "quoteQty": "55723.87"
	//    }
	//
	// swap fetchMyTrades
	//
	//    {
	//        "volume": "0.1",
	//        "price": "106.75",
	//        "amount": "10.6750",
	//        "commission": "-0.0053",
	//        "currency": "USDT",
	//        "orderId": "1676213270274379776",
	//        "liquidatedPrice": "0.00",
	//        "liquidatedMarginRatio": "0.00",
	//        "filledTime": "2023-07-04T20:56:01.000+0800"
	//    }
	//
	// ws spot
	//
	//    {
	//        "E": 1690214529432,
	//        "T": 1690214529386,
	//        "e": "trade",
	//        "m": true,
	//        "p": "29110.19",
	//        "q": "0.1868",
	//        "s": "BTC-USDT",
	//        "t": "57903921"
	//    }
	//
	// ws linear swap
	//
	//    {
	//        "q": "0.0421",
	//        "p": "29023.5",
	//        "T": 1690221401344,
	//        "m": false,
	//        "s": "BTC-USDT"
	//    }
	//
	// ws inverse swap
	//
	//     {
	//         "e": "trade",
	//         "E": 1722920589665,
	//         "s": "BTC-USD",
	//         "t": "39125001",
	//         "p": "55360.0",
	//         "q": "1",
	//         "T": 1722920589582,
	//         "m": false
	//     }
	//
	// inverse swap fetchMyTrades
	//
	//     {
	//         "orderId": "1817441228670648320",
	//         "symbol": "SOL-USD",
	//         "type": "MARKET",
	//         "side": "BUY",
	//         "positionSide": "LONG",
	//         "tradeId": "97244554",
	//         "volume": "2",
	//         "tradePrice": "182.652",
	//         "amount": "20.00000000",
	//         "realizedPnl": "0.00000000",
	//         "commission": "-0.00005475",
	//         "currency": "SOL",
	//         "buyer": true,
	//         "maker": false,
	//         "tradeTime": 1722146730000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var time interface{} = this.SafeIntegerN(trade, []interface{}{"time", "filledTm", "T", "tradeTime"})
	var datetimeId interface{} = this.SafeString(trade, "filledTm")
	if IsTrue(!IsEqual(datetimeId, nil)) {
		time = this.Parse8601(datetimeId)
	}
	if IsTrue(IsEqual(time, 0)) {
		time = nil
	}
	var cost interface{} = this.SafeString(trade, "quoteQty")
	// const type = (cost === undefined) ? 'spot' : 'swap'; this is not reliable
	var currencyId interface{} = this.SafeStringN(trade, []interface{}{"currency", "N", "commissionAsset"})
	var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
	var m interface{} = this.SafeBool(trade, "m")
	var marketId interface{} = this.SafeString2(trade, "s", "symbol")
	var isBuyerMaker interface{} = this.SafeBoolN(trade, []interface{}{"buyerMaker", "isBuyerMaker", "maker"})
	var takeOrMaker interface{} = nil
	if IsTrue(IsTrue((!IsEqual(isBuyerMaker, nil))) || IsTrue((!IsEqual(m, nil)))) {
		takeOrMaker = Ternary(IsTrue((IsTrue(isBuyerMaker) || IsTrue(m))), "maker", "taker")
	}
	var side interface{} = this.SafeStringLower2(trade, "side", "S")
	if IsTrue(IsEqual(side, nil)) {
		if IsTrue(IsTrue((!IsEqual(isBuyerMaker, nil))) || IsTrue((!IsEqual(m, nil)))) {
			side = Ternary(IsTrue((IsTrue(isBuyerMaker) || IsTrue(m))), "sell", "buy")
			takeOrMaker = "taker"
		}
	}
	var isBuyer interface{} = this.SafeBool(trade, "isBuyer")
	if IsTrue(!IsEqual(isBuyer, nil)) {
		side = Ternary(IsTrue(isBuyer), "buy", "sell")
	}
	var isMaker interface{} = this.SafeBool(trade, "isMaker")
	if IsTrue(!IsEqual(isMaker, nil)) {
		takeOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
	}
	var amount interface{} = this.SafeStringN(trade, []interface{}{"qty", "amount", "q"})
	if IsTrue(IsTrue(IsTrue((!IsEqual(market, nil))) && IsTrue(GetValue(market, "swap"))) && IsTrue((InOp(trade, "volume")))) {
		// private trade returns num of contracts instead of base currency (as the order-related methods do)
		var contractSize interface{} = this.SafeString(GetValue(market, "info"), "tradeMinQuantity")
		var volume interface{} = this.SafeString(trade, "volume")
		amount = Precise.StringMul(volume, contractSize)
	}
	return this.SafeTrade(map[string]interface{}{
		"id":           this.SafeStringN(trade, []interface{}{"id", "t"}),
		"info":         trade,
		"timestamp":    time,
		"datetime":     this.Iso8601(time),
		"symbol":       this.SafeSymbol(marketId, market, "-"),
		"order":        this.SafeString2(trade, "orderId", "i"),
		"type":         this.SafeStringLower(trade, "o"),
		"side":         this.ParseOrderSide(side),
		"takerOrMaker": takeOrMaker,
		"price":        this.SafeStringN(trade, []interface{}{"price", "p", "tradePrice"}),
		"amount":       amount,
		"cost":         cost,
		"fee": map[string]interface{}{
			"cost":     this.ParseNumber(Precise.StringAbs(this.SafeString2(trade, "commission", "n"))),
			"currency": currencyCode,
		},
	}, market)
}

/**
 * @method
 * @name bingx#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bingx-api.github.io/docs/#/spot/market-api.html#Query%20depth%20information
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Market%20Depth
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%20Depth%20Data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *bingx) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14888 := (<-this.LoadMarkets())
		PanicOnError(retRes14888)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrderBook", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotV1PublicGetMarketDepth(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PublicGetMarketDepth(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PublicGetQuoteDepth(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "code":0,
		//         "timestamp":1743240504535,
		//         "data":{
		//             "bids":[
		//                 ["83775.39","1.981875"],
		//                 ["83775.38","0.001076"],
		//                 ["83775.34","0.254716"],
		//             ],
		//             "asks":[
		//                 ["83985.40","0.000013"],
		//                 ["83980.00","0.000011"],
		//                 ["83975.70","0.000061000000000000005"],
		//             ],
		//             "ts":1743240504535,
		//             "lastUpdateId":13565639906
		//         }
		//     }
		//
		//
		// linear swap
		//
		//     {
		//         "code":0,
		//         "msg":"",
		//         "data":{
		//             "T":1743240836255,
		//             "bids":[
		//                 ["83760.7","7.0861"],
		//                 ["83760.6","0.0044"],
		//                 ["83757.7","1.9526"],
		//             ],
		//             "asks":[
		//                 ["83784.3","8.3531"],
		//                 ["83782.8","23.7289"],
		//                 ["83780.1","18.0617"],
		//             ],
		//             "bidsCoin":[
		//                 ["83760.7","0.0007"],
		//                 ["83760.6","0.0000"],
		//                 ["83757.7","0.0002"],
		//             ],
		//             "asksCoin":[
		//                 ["83784.3","0.0008"],
		//                 ["83782.8","0.0024"],
		//                 ["83780.1","0.0018"],
		//             ]
		//         }
		//     }
		//
		// inverse swap
		//
		//     {
		//         "code":0,
		//         "msg":"",
		//         "timestamp":1743240979146,
		//         "data":{
		//             "T":1743240978691,
		//             "bids":[
		//                 ["83611.4","241.0"],
		//                 ["83611.3","1.0"],
		//                 ["83602.9","666.0"],
		//             ],
		//             "asks":[
		//                 ["83645.0","4253.0"],
		//                 ["83640.5","3188.0"],
		//                 ["83636.0","5540.0"],
		//             ]
		//         }
		//     }
		//
		var orderbook interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var nonce interface{} = this.SafeInteger(orderbook, "lastUpdateId")
		var timestamp interface{} = this.SafeInteger2(orderbook, "T", "ts")
		var result interface{} = this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp, "bids", "asks", 0, 1)
		AddElementToObject(result, "nonce", nonce)

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Price%20&%20Current%20Funding%20Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *bingx) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes16018 := (<-this.LoadMarkets())
		PanicOnError(retRes16018)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.CswapV1PublicGetMarketPremiumIndex(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PublicGetQuotePremiumIndex(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//    {
		//        "code":0,
		//        "msg":"",
		//        "data":[
		//          {
		//            "symbol": "BTC-USDT",
		//            "markPrice": "16884.5",
		//            "indexPrice": "16886.9",
		//            "lastFundingRate": "0.0001",
		//            "nextFundingTime": 1672041600000
		//          },
		//          ...
		//        ]
		//    }
		//
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseFundingRate(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchFundingRates
 * @description fetch the current funding rate for multiple symbols
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Current%20Funding%20Rate
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *bingx) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes16428 := (<-this.LoadMarkets())
		PanicOnError(retRes16428)
		symbols = this.MarketSymbols(symbols, "swap", true)

		response := (<-this.SwapV2PublicGetQuotePremiumIndex(this.Extend(params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRates(data, symbols)
		return nil

	}()
	return ch
}
func (this *bingx) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTC-USDT",
	//         "markPrice": "16884.5",
	//         "indexPrice": "16886.9",
	//         "lastFundingRate": "0.0001",
	//         "nextFundingTime": 1672041600000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   this.SafeSymbol(marketId, market, "-", "swap"),
		"markPrice":                this.SafeNumber(contract, "markPrice"),
		"indexPrice":               this.SafeNumber(contract, "indexPrice"),
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              this.SafeNumber(contract, "lastFundingRate"),
		"fundingTimestamp":         nil,
		"fundingDatetime":          nil,
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nextFundingTimestamp,
		"nextFundingDatetime":      this.Iso8601(nextFundingTimestamp),
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 nil,
	}
}

/**
 * @method
 * @name bingx#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Funding%20Rate%20History
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *bingx) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes17008 := (<-this.LoadMarkets())
		PanicOnError(retRes17008)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes170419 := (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params))
			PanicOnError(retRes170419)
			ch <- retRes170419
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger2(params, "until", "startTime")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, []interface{}{"until"})
			AddElementToObject(request, "startTime", until)
		}

		response := (<-this.SwapV2PublicGetQuoteFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code":0,
		//        "msg":"",
		//        "data":[
		//          {
		//            "symbol": "BTC-USDT",
		//            "fundingRate": "0.0001",
		//            "fundingTime": 1585684800000
		//          },
		//          ...
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRateHistories(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseFundingRateHistory(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTC-USDT",
	//         "fundingRate": "0.0001",
	//         "fundingTime": 1585684800000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(contract, "fundingTime")
	return map[string]interface{}{
		"info":        contract,
		"symbol":      this.SafeSymbol(this.SafeString(contract, "symbol"), market, "-", "swap"),
		"fundingRate": this.SafeNumber(contract, "fundingRate"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name bingx#fetchOpenInterest
 * @description retrieves the open interest of a trading pair
 * @see https://bingx-api.github.io/docs/#/swapV2/market-api.html#Get%20Swap%20Open%20Positions
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Get%20Swap%20Open%20Positions
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func (this *bingx) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17698 := (<-this.LoadMarkets())
		PanicOnError(retRes17698)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.CswapV1PublicGetMarketOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PublicGetQuoteOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// linear swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//           "openInterest": "3289641547.10",
		//           "symbol": "BTC-USDT",
		//           "time": 1672026617364
		//         }
		//     }
		//
		// inverse swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1720328247986,
		//         "data": [
		//             {
		//                 "symbol": "BTC-USD",
		//                 "openInterest": "749.1160",
		//                 "timestamp": 1720310400000
		//             }
		//         ]
		//     }
		//
		var result interface{} = map[string]interface{}{}
		if IsTrue(GetValue(market, "inverse")) {
			var data interface{} = this.SafeList(response, "data", []interface{}{})
			result = this.SafeDict(data, 0, map[string]interface{}{})
		} else {
			result = this.SafeDict(response, "data", map[string]interface{}{})
		}

		ch <- this.ParseOpenInterest(result, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	// linear swap
	//
	//     {
	//         "openInterest": "3289641547.10",
	//         "symbol": "BTC-USDT",
	//         "time": 1672026617364
	//     }
	//
	// inverse swap
	//
	//     {
	//         "symbol": "BTC-USD",
	//         "openInterest": "749.1160",
	//         "timestamp": 1720310400000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(interest, "time", "timestamp")
	var id interface{} = this.SafeString(interest, "symbol")
	var symbol interface{} = this.SafeSymbol(id, market, "-", "swap")
	var openInterest interface{} = this.SafeNumber(interest, "openInterest")
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             symbol,
		"baseVolume":         nil,
		"quoteVolume":        nil,
		"openInterestAmount": nil,
		"openInterestValue":  openInterest,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"info":               interest,
	}, market)
}

/**
 * @method
 * @name bingx#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Get%20Ticker
 * @see https://bingx-api.github.io/docs/#/en-us/spot/market-api.html#24-hour%20price%20changes
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%2024-Hour%20Price%20Change
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bingx) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18648 := (<-this.LoadMarkets())
		PanicOnError(retRes18648)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.SpotV1PublicGetTicker24hr(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PublicGetMarketTicker(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PublicGetQuoteTicker(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot and swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1720647285296,
		//         "data": [
		//             {
		//                 "symbol": "SOL-USD",
		//                 "priceChange": "-2.418",
		//                 "priceChangePercent": "-1.6900%",
		//                 "lastPrice": "140.574",
		//                 "lastQty": "1",
		//                 "highPrice": "146.190",
		//                 "lowPrice": "138.586",
		//                 "volume": "1464648.00",
		//                 "quoteVolume": "102928.12",
		//                 "openPrice": "142.994",
		//                 "closeTime": "1720647284976",
		//                 "bidPrice": "140.573",
		//                 "bidQty": "372",
		//                 "askPrice": "140.577",
		//                 "askQty": "58"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data")
		if IsTrue(!IsEqual(data, nil)) {
			var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

			ch <- this.ParseTicker(first, market)
			return nil
		}
		var dataDict interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTicker(dataDict, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Get%20Ticker
 * @see https://bingx-api.github.io/docs/#/en-us/spot/market-api.html#24-hour%20price%20changes
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/market-api.html#Query%2024-Hour%20Price%20Change
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bingx) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes19288 := (<-this.LoadMarkets())
		PanicOnError(retRes19288)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			symbols = this.MarketSymbols(symbols)
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			if IsTrue(!IsEqual(firstSymbol, nil)) {
				market = this.Market(firstSymbol)
			}
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchTickers", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.SpotV1PublicGetTicker24hr(params))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(subType, "inverse")) {

				response = (<-this.CswapV1PublicGetMarketTicker(params))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PublicGetQuoteTicker(params))
				PanicOnError(response)
			}
		}
		//
		// spot and swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1720647285296,
		//         "data": [
		//             {
		//                 "symbol": "SOL-USD",
		//                 "priceChange": "-2.418",
		//                 "priceChangePercent": "-1.6900%",
		//                 "lastPrice": "140.574",
		//                 "lastQty": "1",
		//                 "highPrice": "146.190",
		//                 "lowPrice": "138.586",
		//                 "volume": "1464648.00",
		//                 "quoteVolume": "102928.12",
		//                 "openPrice": "142.994",
		//                 "closeTime": "1720647284976",
		//                 "bidPrice": "140.573",
		//                 "bidQty": "372",
		//                 "askPrice": "140.577",
		//                 "askQty": "58"
		//             },
		//             ...
		//         ]
		//     }
		//
		var tickers interface{} = this.SafeList(response, "data")

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchMarkPrice
 * @description fetches mark prices for the market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Mark%20Price%20and%20Funding%20Rate
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bingx) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19948 := (<-this.LoadMarkets())
		PanicOnError(retRes19948)
		var market interface{} = this.Market(symbol)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMarkPrice", market, params, "linear")
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.CswapV1PublicGetMarketPremiumIndex(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PublicGetQuotePremiumIndex(this.Extend(request, params)))
			PanicOnError(response)
		}
		if IsTrue(IsArray(GetValue(response, "data"))) {

			ch <- this.ParseTicker(this.SafeDict(GetValue(response, "data"), 0, map[string]interface{}{}), market)
			return nil
		}

		ch <- this.ParseTicker(GetValue(response, "data"), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchMarkPrices
 * @description fetches mark prices for multiple markets
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/market-api.html#Mark%20Price%20and%20Funding%20Rate
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *bingx) FetchMarkPrices(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes20528 := (<-this.LoadMarkets())
		PanicOnError(retRes20528)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			symbols = this.MarketSymbols(symbols)
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			if IsTrue(!IsEqual(firstSymbol, nil)) {
				market = this.Market(firstSymbol)
			}
		}
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMarkPrices", market, params, "linear")
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.CswapV1PublicGetMarketPremiumIndex(params))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PublicGetQuotePremiumIndex(params))
			PanicOnError(response)
		}
		//
		// spot and swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1720647285296,
		//         "data": [
		//             {
		//                 "symbol": "SOL-USD",
		//                 "priceChange": "-2.418",
		//                 "priceChangePercent": "-1.6900%",
		//                 "lastPrice": "140.574",
		//                 "lastQty": "1",
		//                 "highPrice": "146.190",
		//                 "lowPrice": "138.586",
		//                 "volume": "1464648.00",
		//                 "quoteVolume": "102928.12",
		//                 "openPrice": "142.994",
		//                 "closeTime": "1720647284976",
		//                 "bidPrice": "140.573",
		//                 "bidQty": "372",
		//                 "askPrice": "140.577",
		//                 "askQty": "58"
		//             },
		//             ...
		//         ]
		//     }
		//
		var tickers interface{} = this.SafeList(response, "data")

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}
func (this *bingx) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// mark price
	// {
	//     "symbol": "string",
	//     "lastFundingRate": "string",
	//     "markPrice": "string",
	//     "indexPrice": "string",
	//     "nextFundingTime": "int64"
	// }
	//
	// spot
	//    {
	//        "symbol": "BTC-USDT",
	//        "openPrice": "26032.08",
	//        "highPrice": "26178.86",
	//        "lowPrice": "25968.18",
	//        "lastPrice": "26113.60",
	//        "volume": "1161.79",
	//        "quoteVolume": "30288466.44",
	//        "openTime": "1693081020762",
	//        "closeTime": "1693167420762",
	//  added 2023-11-10:
	//        "bidPrice": 16726.0,
	//        "bidQty": 0.05,
	//        "askPrice": 16726.0,
	//        "askQty": 0.05,
	//    }
	// swap
	//
	//    {
	//        "symbol": "BTC-USDT",
	//        "priceChange": "52.5",
	//        "priceChangePercent": "0.31%", // they started to add the percent sign in value
	//        "lastPrice": "16880.5",
	//        "lastQty": "2.2238",          // only present in swap!
	//        "highPrice": "16897.5",
	//        "lowPrice": "16726.0",
	//        "volume": "245870.1692",
	//        "quoteVolume": "4151395117.73",
	//        "openPrice": "16832.0",
	//        "openTime": 1672026667803,
	//        "closeTime": 1672026648425,
	//  added 2023-11-10:
	//        "bidPrice": 16726.0,
	//        "bidQty": 0.05,
	//        "askPrice": 16726.0,
	//        "askQty": 0.05,
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	var lastQty interface{} = this.SafeString(ticker, "lastQty")
	// in spot markets, lastQty is not present
	// it's (bad, but) the only way we can check the tickers origin
	var typeVar interface{} = Ternary(IsTrue((IsEqual(lastQty, nil))), "spot", "swap")
	market = this.SafeMarket(marketId, market, nil, typeVar)
	var symbol interface{} = GetValue(market, "symbol")
	var open interface{} = this.SafeString(ticker, "openPrice")
	var high interface{} = this.SafeString(ticker, "highPrice")
	var low interface{} = this.SafeString(ticker, "lowPrice")
	var close interface{} = this.SafeString(ticker, "lastPrice")
	var quoteVolume interface{} = this.SafeString(ticker, "quoteVolume")
	var baseVolume interface{} = this.SafeString(ticker, "volume")
	var percentage interface{} = this.SafeString(ticker, "priceChangePercent")
	if IsTrue(!IsEqual(percentage, nil)) {
		percentage = Replace(percentage, "%", "")
	}
	var change interface{} = this.SafeString(ticker, "priceChange")
	var ts interface{} = this.SafeInteger(ticker, "closeTime")
	if IsTrue(IsEqual(ts, 0)) {
		ts = nil
	}
	var datetime interface{} = this.Iso8601(ts)
	var bid interface{} = this.SafeString(ticker, "bidPrice")
	var bidVolume interface{} = this.SafeString(ticker, "bidQty")
	var ask interface{} = this.SafeString(ticker, "askPrice")
	var askVolume interface{} = this.SafeString(ticker, "askQty")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     ts,
		"datetime":      datetime,
		"high":          high,
		"low":           low,
		"bid":           bid,
		"bidVolume":     bidVolume,
		"ask":           ask,
		"askVolume":     askVolume,
		"vwap":          nil,
		"open":          open,
		"close":         close,
		"last":          nil,
		"previousClose": nil,
		"change":        change,
		"percentage":    percentage,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"markPrice":     this.SafeString(ticker, "markPrice"),
		"indexPrice":    this.SafeString(ticker, "indexPrice"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name bingx#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Query%20Assets
 * @see https://bingx-api.github.io/docs/#/swapV2/account-api.html#Get%20Perpetual%20Swap%20Account%20Asset%20Information
 * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Query%20standard%20contract%20balance
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Account%20Assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.standard] whether to fetch standard contract balances
 * @param {string} [params.type] the type of balance to fetch (spot, swap, funding) default is `spot`
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *bingx) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22198 := (<-this.LoadMarkets())
		PanicOnError(retRes22198)
		var response interface{} = nil
		var standard interface{} = nil
		standardparamsVariable := this.HandleOptionAndParams(params, "fetchBalance", "standard", false)
		standard = GetValue(standardparamsVariable, 0)
		params = GetValue(standardparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchBalance", nil, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		marketTypemarketTypeQueryVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		marketType := GetValue(marketTypemarketTypeQueryVariable, 0)
		marketTypeQuery := GetValue(marketTypemarketTypeQueryVariable, 1)
		if IsTrue(standard) {

			response = (<-this.ContractV1PrivateGetBalance(marketTypeQuery))
			PanicOnError(response)
		} else if IsTrue(IsTrue((IsEqual(marketType, "funding"))) || IsTrue((IsEqual(marketType, "fund")))) {

			response = (<-this.FundV1PrivateGetAccountBalance(marketTypeQuery))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotV1PrivateGetAccountBalance(marketTypeQuery))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(subType, "inverse")) {

				response = (<-this.CswapV1PrivateGetUserBalance(marketTypeQuery))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivateGetUserBalance(marketTypeQuery))
				PanicOnError(response)
			}
		}

		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *bingx) ParseBalance(response interface{}) interface{} {
	//
	// standard
	//
	//     {
	//         "code": 0,
	//         "timestamp": 1721192833454,
	//         "data": [
	//             {
	//                 "asset": "USDT",
	//                 "balance": "4.72644300000000000000",
	//                 "crossWalletBalance": "4.72644300000000000000",
	//                 "crossUnPnl": "0",
	//                 "availableBalance": "4.72644300000000000000",
	//                 "maxWithdrawAmount": "4.72644300000000000000",
	//                 "marginAvailable": false,
	//                 "updateTime": 1721192833443
	//             },
	//         ]
	//     }
	//
	// spot
	//
	//     {
	//         "code": 0,
	//         "msg": "",
	//         "debugMsg": "",
	//         "data": {
	//             "balances": [
	//                 {
	//                     "asset": "USDT",
	//                     "free": "45.733046995800514",
	//                     "locked": "0"
	//                 },
	//             ]
	//         }
	//     }
	//
	// inverse swap
	//
	//     {
	//         "code": 0,
	//         "msg": "",
	//         "timestamp": 1721191833813,
	//         "data": [
	//             {
	//                 "asset": "SOL",
	//                 "balance": "0.35707951",
	//                 "equity": "0.35791051",
	//                 "unrealizedProfit": "0.00083099",
	//                 "availableMargin": "0.35160653",
	//                 "usedMargin": "0.00630397",
	//                 "freezedMargin": "0",
	//                 "shortUid": "12851936"
	//             }
	//         ]
	//     }
	//
	// linear swap
	//
	//     {
	//         "code": 0,
	//         "msg": "",
	//         "data": {
	//             "balance": {
	//                 "userId": "1177064765068660742",
	//                 "asset": "USDT",
	//                 "balance": "51.5198",
	//                 "equity": "50.5349",
	//                 "unrealizedProfit": "-0.9849",
	//                 "realisedProfit": "-0.2134",
	//                 "availableMargin": "49.1428",
	//                 "usedMargin": "1.3922",
	//                 "freezedMargin": "0.0000",
	//                 "shortUid": "12851936"
	//             }
	//         }
	//     }
	//
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	var standardAndInverseBalances interface{} = this.SafeList(response, "data")
	var firstStandardOrInverse interface{} = this.SafeDict(standardAndInverseBalances, 0)
	var isStandardOrInverse interface{} = !IsEqual(firstStandardOrInverse, nil)
	var spotData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
	var spotBalances interface{} = this.SafeList2(spotData, "balances", "assets", []interface{}{})
	var firstSpot interface{} = this.SafeDict(spotBalances, 0)
	var isSpot interface{} = !IsEqual(firstSpot, nil)
	if IsTrue(isStandardOrInverse) {
		for i := 0; IsLessThan(i, GetArrayLength(standardAndInverseBalances)); i++ {
			var balance interface{} = GetValue(standardAndInverseBalances, i)
			var currencyId interface{} = this.SafeString(balance, "asset")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var account interface{} = this.Account()
			AddElementToObject(account, "free", this.SafeString2(balance, "availableMargin", "availableBalance"))
			AddElementToObject(account, "used", this.SafeString(balance, "usedMargin"))
			AddElementToObject(account, "total", this.SafeString(balance, "maxWithdrawAmount"))
			AddElementToObject(result, code, account)
		}
	} else if IsTrue(isSpot) {
		for i := 0; IsLessThan(i, GetArrayLength(spotBalances)); i++ {
			var balance interface{} = GetValue(spotBalances, i)
			var currencyId interface{} = this.SafeString(balance, "asset")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var account interface{} = this.Account()
			AddElementToObject(account, "free", this.SafeString(balance, "free"))
			AddElementToObject(account, "used", this.SafeString(balance, "locked"))
			AddElementToObject(result, code, account)
		}
	} else {
		var linearSwapData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var linearSwapBalance interface{} = this.SafeDict(linearSwapData, "balance")
		if IsTrue(linearSwapBalance) {
			var currencyId interface{} = this.SafeString(linearSwapBalance, "asset")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var account interface{} = this.Account()
			AddElementToObject(account, "free", this.SafeString(linearSwapBalance, "availableMargin"))
			AddElementToObject(account, "used", this.SafeString(linearSwapBalance, "usedMargin"))
			AddElementToObject(result, code, account)
		}
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name bingx#fetchPositionHistory
 * @description fetches historical positions
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Position%20History
 * @param {string} symbol unified contract symbol
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum amount of records to fetch
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] the latest time in ms to fetch positions for
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bingx) FetchPositionHistory(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes24648 := (<-this.LoadMarkets())
		PanicOnError(retRes24648)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTs", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTs", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(GetValue(market, "linear")) {

			response = (<-this.SwapV1PrivateGetTradePositionHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchPositionHistory() is not supported for inverse swap positions")))
		}
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//             "positionHistory": [
		//                 {
		//                     "positionId": "1861675561156571136",
		//                     "symbol": "LTC-USDT",
		//                     "isolated": false,
		//                     "positionSide": "LONG",
		//                     "openTime": 1732693017000,
		//                     "updateTime": 1733310292000,
		//                     "avgPrice": "95.18",
		//                     "avgClosePrice": "129.48",
		//                     "realisedProfit": "102.89",
		//                     "netProfit": "99.63",
		//                     "positionAmt": "30.0",
		//                     "closePositionAmt": "30.0",
		//                     "leverage": 6,
		//                     "closeAllPositions": true,
		//                     "positionCommission": "-0.33699650000000003",
		//                     "totalFunding": "-2.921461693902908"
		//                 },
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var records interface{} = this.SafeList(data, "positionHistory", []interface{}{})
		var positions interface{} = this.ParsePositions(records)

		ch <- this.FilterBySymbolSinceLimit(positions, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchPositions
 * @description fetch all open positions
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20position%20data
 * @see https://bingx-api.github.io/docs/#/en-us/standard/contract-interface.html#position
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20warehouse
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.standard] whether to fetch standard contract positions
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bingx) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes25298 := (<-this.LoadMarkets())
		PanicOnError(retRes25298)
		symbols = this.MarketSymbols(symbols)
		var standard interface{} = nil
		standardparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "standard", false)
		standard = GetValue(standardparamsVariable, 0)
		params = GetValue(standardparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(standard) {

			response = (<-this.ContractV1PrivateGetAllPosition(params))
			PanicOnError(response)
		} else {
			var market interface{} = nil
			if IsTrue(!IsEqual(symbols, nil)) {
				symbols = this.MarketSymbols(symbols)
				var firstSymbol interface{} = this.SafeString(symbols, 0)
				if IsTrue(!IsEqual(firstSymbol, nil)) {
					market = this.Market(firstSymbol)
				}
			}
			var subType interface{} = nil
			subTypeparamsVariable := this.HandleSubTypeAndParams("fetchPositions", market, params)
			subType = GetValue(subTypeparamsVariable, 0)
			params = GetValue(subTypeparamsVariable, 1)
			if IsTrue(IsEqual(subType, "inverse")) {

				response = (<-this.CswapV1PrivateGetUserPositions(params))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivateGetUserPositions(params))
				PanicOnError(response)
			}
		}
		var positions interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(positions, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20position%20data
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20warehouse
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bingx) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes26258 := (<-this.LoadMarkets())
		PanicOnError(retRes26258)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadRequest(Add(this.Id, " fetchPosition() supports swap markets only")))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.CswapV1PrivateGetUserPositions(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PrivateGetUserPositions(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParsePosition(first, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// inverse swap
	//
	//     {
	//         "symbol": "SOL-USD",
	//         "positionId": "1813080351385337856",
	//         "positionSide": "LONG",
	//         "isolated": false,
	//         "positionAmt": "1",
	//         "availableAmt": "1",
	//         "unrealizedProfit": "-0.00009074",
	//         "initialMargin": "0.00630398",
	//         "liquidationPrice": 23.968303426677032,
	//         "avgPrice": "158.63",
	//         "leverage": 10,
	//         "markPrice": "158.402",
	//         "riskRate": "0.00123783",
	//         "maxMarginReduction": "0",
	//         "updateTime": 1721107015848
	//     }
	//
	// linear swap
	//
	//     {
	//         "positionId": "1792480725958881280",
	//         "symbol": "LTC-USDT",
	//         "currency": "USDT",
	//         "positionAmt": "0.1",
	//         "availableAmt": "0.1",
	//         "positionSide": "LONG",
	//         "isolated": false,
	//         "avgPrice": "83.53",
	//         "initialMargin": "1.3922",
	//         "margin": "0.3528",
	//         "leverage": 6,
	//         "unrealizedProfit": "-1.0393",
	//         "realisedProfit": "-0.2119",
	//         "liquidationPrice": 0,
	//         "pnlRatio": "-0.7465",
	//         "maxMarginReduction": "0.0000",
	//         "riskRate": "0.0008",
	//         "markPrice": "73.14",
	//         "positionValue": "7.3136",
	//         "onlyOnePosition": true,
	//         "updateTime": 1721088016688
	//     }
	//
	// standard position
	//
	//     {
	//         "currentPrice": "82.91",
	//         "symbol": "LTC/USDT",
	//         "initialMargin": "5.00000000000000000000",
	//         "unrealizedProfit": "-0.26464500",
	//         "leverage": "20.000000000",
	//         "isolated": true,
	//         "entryPrice": "83.13",
	//         "positionSide": "LONG",
	//         "positionAmt": "1.20365912",
	//     }
	//
	// linear swap fetchPositionHistory
	//
	//     {
	//         "positionId": "1861675561156571136",
	//         "symbol": "LTC-USDT",
	//         "isolated": false,
	//         "positionSide": "LONG",
	//         "openTime": 1732693017000,
	//         "updateTime": 1733310292000,
	//         "avgPrice": "95.18",
	//         "avgClosePrice": "129.48",
	//         "realisedProfit": "102.89",
	//         "netProfit": "99.63",
	//         "positionAmt": "30.0",
	//         "closePositionAmt": "30.0",
	//         "leverage": 6,
	//         "closeAllPositions": true,
	//         "positionCommission": "-0.33699650000000003",
	//         "totalFunding": "-2.921461693902908"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "symbol", "")
	marketId = Replace(marketId, "/", "-") // standard return different format
	var isolated interface{} = this.SafeBool(position, "isolated")
	var marginMode interface{} = nil
	if IsTrue(!IsEqual(isolated, nil)) {
		marginMode = Ternary(IsTrue(isolated), "isolated", "cross")
	}
	var timestamp interface{} = this.SafeInteger(position, "openTime")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          this.SafeString(position, "positionId"),
		"symbol":                      this.SafeSymbol(marketId, market, "-", "swap"),
		"notional":                    this.SafeNumber(position, "positionValue"),
		"marginMode":                  marginMode,
		"liquidationPrice":            nil,
		"entryPrice":                  this.SafeNumber2(position, "avgPrice", "entryPrice"),
		"unrealizedPnl":               this.SafeNumber(position, "unrealizedProfit"),
		"realizedPnl":                 this.SafeNumber(position, "realisedProfit"),
		"percentage":                  nil,
		"contracts":                   this.SafeNumber(position, "positionAmt"),
		"contractSize":                nil,
		"markPrice":                   this.SafeNumber(position, "markPrice"),
		"lastPrice":                   nil,
		"side":                        this.SafeStringLower(position, "positionSide"),
		"hedged":                      nil,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"lastUpdateTimestamp":         this.SafeInteger(position, "updateTime"),
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": nil,
		"collateral":                  nil,
		"initialMargin":               this.SafeNumber(position, "initialMargin"),
		"initialMarginPercentage":     nil,
		"leverage":                    this.SafeNumber(position, "leverage"),
		"marginRatio":                 nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name bingx#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		AddElementToObject(params, "quoteOrderQty", cost)

		retRes283615 := (<-this.CreateOrder(symbol, "market", side, cost, nil, params))
		PanicOnError(retRes283615)
		ch <- retRes283615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		AddElementToObject(params, "quoteOrderQty", cost)

		retRes285015 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
		PanicOnError(retRes285015)
		ch <- retRes285015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		AddElementToObject(params, "quoteOrderQty", cost)

		retRes286415 := (<-this.CreateOrder(symbol, "market", "sell", cost, nil, params))
		PanicOnError(retRes286415)
		ch <- retRes286415
		return nil

	}()
	return ch
}
func (this *bingx) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @ignore
	 * @name bingx#createOrderRequest
	 * @description helper function to build request
	 * @param {string} symbol unified symbol of the market to create an order in
	 * @param {string} type 'market' or 'limit'
	 * @param {string} side 'buy' or 'sell'
	 * @param {float} amount how much you want to trade in units of the base currency
	 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @returns {object} request to be sent to the exchange
	 */
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var postOnly interface{} = nil
	var marketType interface{} = nil
	marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params)
	marketType = GetValue(marketTypeparamsVariable, 0)
	params = GetValue(marketTypeparamsVariable, 1)
	typeVar = ToUpper(typeVar)
	var request interface{} = map[string]interface{}{
		"symbol": GetValue(market, "id"),
		"type":   typeVar,
		"side":   ToUpper(side),
	}
	var isMarketOrder interface{} = IsEqual(typeVar, "MARKET")
	var isSpot interface{} = IsEqual(marketType, "spot")
	var isTwapOrder interface{} = IsEqual(typeVar, "TWAP")
	if IsTrue(IsTrue(isTwapOrder) && IsTrue(isSpot)) {
		panic(BadSymbol(Add(this.Id, " createOrder() twap order supports swap contracts only")))
	}
	var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
	var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
	var triggerPrice interface{} = this.SafeString2(params, "stopPrice", "triggerPrice")
	var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
	var isStopLossPriceOrder interface{} = !IsEqual(stopLossPrice, nil)
	var isTakeProfitPriceOrder interface{} = !IsEqual(takeProfitPrice, nil)
	var exchangeClientOrderId interface{} = Ternary(IsTrue(isSpot), "newClientOrderId", "clientOrderID")
	var clientOrderId interface{} = this.SafeString2(params, exchangeClientOrderId, "clientOrderId")
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(request, exchangeClientOrderId, clientOrderId)
	}
	var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
	postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(timeInForce, "PostOnly"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(IsTrue(postOnly) || IsTrue((IsEqual(timeInForce, "PostOnly")))) {
		AddElementToObject(request, "timeInForce", "PostOnly")
	} else if IsTrue(IsEqual(timeInForce, "IOC")) {
		AddElementToObject(request, "timeInForce", "IOC")
	} else if IsTrue(IsEqual(timeInForce, "GTC")) {
		AddElementToObject(request, "timeInForce", "GTC")
	}
	if IsTrue(isSpot) {
		var cost interface{} = this.SafeString2(params, "cost", "quoteOrderQty")
		params = this.Omit(params, "cost")
		if IsTrue(!IsEqual(cost, nil)) {
			AddElementToObject(request, "quoteOrderQty", this.ParseToNumeric(this.CostToPrecision(symbol, cost)))
		} else {
			if IsTrue(IsTrue(isMarketOrder) && IsTrue((!IsEqual(price, nil)))) {
				// keep the legacy behavior, to avoid  breaking the old spot-market-buying code
				var calculatedCost interface{} = Precise.StringMul(this.NumberToString(amount), this.NumberToString(price))
				AddElementToObject(request, "quoteOrderQty", this.ParseToNumeric(calculatedCost))
			} else {
				AddElementToObject(request, "quantity", this.ParseToNumeric(this.AmountToPrecision(symbol, amount)))
			}
		}
		if !IsTrue(isMarketOrder) {
			AddElementToObject(request, "price", this.ParseToNumeric(this.PriceToPrecision(symbol, price)))
		}
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			if IsTrue(IsTrue(isMarketOrder) && IsTrue(IsEqual(this.SafeString(request, "quoteOrderQty"), nil))) {
				panic(ArgumentsRequired(Add(this.Id, " createOrder() requires the cost parameter (or the amount + price) for placing spot market-buy trigger orders")))
			}
			AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
			if IsTrue(IsEqual(typeVar, "LIMIT")) {
				AddElementToObject(request, "type", "TRIGGER_LIMIT")
			} else if IsTrue(IsEqual(typeVar, "MARKET")) {
				AddElementToObject(request, "type", "TRIGGER_MARKET")
			}
		} else if IsTrue(IsTrue((!IsEqual(stopLossPrice, nil))) || IsTrue((!IsEqual(takeProfitPrice, nil)))) {
			var stopTakePrice interface{} = Ternary(IsTrue((!IsEqual(stopLossPrice, nil))), stopLossPrice, takeProfitPrice)
			if IsTrue(IsEqual(typeVar, "LIMIT")) {
				AddElementToObject(request, "type", "TAKE_STOP_LIMIT")
			} else if IsTrue(IsEqual(typeVar, "MARKET")) {
				AddElementToObject(request, "type", "TAKE_STOP_MARKET")
			}
			AddElementToObject(request, "stopPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, stopTakePrice)))
		}
	} else {
		if IsTrue(isTwapOrder) {
			var twapRequest interface{} = map[string]interface{}{
				"symbol":       GetValue(request, "symbol"),
				"side":         GetValue(request, "side"),
				"positionSide": Ternary(IsTrue((IsEqual(side, "buy"))), "LONG", "SHORT"),
				"triggerPrice": this.ParseToNumeric(this.PriceToPrecision(symbol, triggerPrice)),
				"totalAmount":  this.ParseToNumeric(this.AmountToPrecision(symbol, amount)),
			}
			//     {
			//         "symbol": "LTC-USDT",
			//         "side": "BUY",
			//         "positionSide": "LONG",
			//         "priceType": "constant",
			//         "priceVariance": "10",
			//         "triggerPrice": "120",
			//         "interval": 8,
			//         "amountPerOrder": "0.5",
			//         "totalAmount": "1"
			//     }
			return this.Extend(twapRequest, params)
		}
		if IsTrue(IsEqual(timeInForce, "FOK")) {
			AddElementToObject(request, "timeInForce", "FOK")
		}
		var trailingAmount interface{} = this.SafeString(params, "trailingAmount")
		var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "priceRate")
		var trailingType interface{} = this.SafeString(params, "trailingType", "TRAILING_STOP_MARKET")
		var isTrailingAmountOrder interface{} = !IsEqual(trailingAmount, nil)
		var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
		var isTrailing interface{} = IsTrue(isTrailingAmountOrder) || IsTrue(isTrailingPercentOrder)
		var stopLoss interface{} = this.SafeValue(params, "stopLoss")
		var takeProfit interface{} = this.SafeValue(params, "takeProfit")
		var isStopLoss interface{} = !IsEqual(stopLoss, nil)
		var isTakeProfit interface{} = !IsEqual(takeProfit, nil)
		if IsTrue(IsTrue((IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "LIMIT"))) || IsTrue((IsEqual(typeVar, "TRIGGER_LIMIT")))) || IsTrue((IsEqual(typeVar, "STOP")))) || IsTrue((IsEqual(typeVar, "TAKE_PROFIT"))))) && !IsTrue(isTrailing)) {
			AddElementToObject(request, "price", this.ParseToNumeric(this.PriceToPrecision(symbol, price)))
		}
		var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
		if IsTrue(isTriggerOrder) {
			AddElementToObject(request, "stopPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, triggerPrice)))
			if IsTrue(IsTrue(isMarketOrder) || IsTrue((IsEqual(typeVar, "TRIGGER_MARKET")))) {
				AddElementToObject(request, "type", "TRIGGER_MARKET")
			} else if IsTrue(IsTrue((IsEqual(typeVar, "LIMIT"))) || IsTrue((IsEqual(typeVar, "TRIGGER_LIMIT")))) {
				AddElementToObject(request, "type", "TRIGGER_LIMIT")
			}
		} else if IsTrue(IsTrue(isStopLossPriceOrder) || IsTrue(isTakeProfitPriceOrder)) {
			// This can be used to set the stop loss and take profit, but the position needs to be opened first
			reduceOnly = true
			if IsTrue(isStopLossPriceOrder) {
				AddElementToObject(request, "stopPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
				if IsTrue(IsTrue(isMarketOrder) || IsTrue((IsEqual(typeVar, "STOP_MARKET")))) {
					AddElementToObject(request, "type", "STOP_MARKET")
				} else if IsTrue(IsTrue((IsEqual(typeVar, "LIMIT"))) || IsTrue((IsEqual(typeVar, "STOP")))) {
					AddElementToObject(request, "type", "STOP")
				}
			} else if IsTrue(isTakeProfitPriceOrder) {
				AddElementToObject(request, "stopPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
				if IsTrue(IsTrue(isMarketOrder) || IsTrue((IsEqual(typeVar, "TAKE_PROFIT_MARKET")))) {
					AddElementToObject(request, "type", "TAKE_PROFIT_MARKET")
				} else if IsTrue(IsTrue((IsEqual(typeVar, "LIMIT"))) || IsTrue((IsEqual(typeVar, "TAKE_PROFIT")))) {
					AddElementToObject(request, "type", "TAKE_PROFIT")
				}
			}
		} else if IsTrue(isTrailing) {
			AddElementToObject(request, "type", trailingType)
			if IsTrue(isTrailingAmountOrder) {
				AddElementToObject(request, "price", this.ParseToNumeric(trailingAmount))
			} else if IsTrue(isTrailingPercentOrder) {
				var requestTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
				AddElementToObject(request, "priceRate", this.ParseToNumeric(requestTrailingPercent))
			}
		}
		if IsTrue(IsTrue(isStopLoss) || IsTrue(isTakeProfit)) {
			var stringifiedAmount interface{} = this.NumberToString(amount)
			if IsTrue(isStopLoss) {
				var slTriggerPrice interface{} = this.SafeString2(stopLoss, "triggerPrice", "stopPrice", stopLoss)
				var slWorkingType interface{} = this.SafeString(stopLoss, "workingType", "MARK_PRICE")
				var slType interface{} = this.SafeString(stopLoss, "type", "STOP_MARKET")
				var slRequest interface{} = map[string]interface{}{
					"stopPrice":   this.ParseToNumeric(this.PriceToPrecision(symbol, slTriggerPrice)),
					"workingType": slWorkingType,
					"type":        slType,
				}
				var slPrice interface{} = this.SafeString(stopLoss, "price")
				if IsTrue(!IsEqual(slPrice, nil)) {
					AddElementToObject(slRequest, "price", this.ParseToNumeric(this.PriceToPrecision(symbol, slPrice)))
				}
				var slQuantity interface{} = this.SafeString(stopLoss, "quantity", stringifiedAmount)
				AddElementToObject(slRequest, "quantity", this.ParseToNumeric(this.AmountToPrecision(symbol, slQuantity)))
				AddElementToObject(request, "stopLoss", this.Json(slRequest))
			}
			if IsTrue(isTakeProfit) {
				var tkTriggerPrice interface{} = this.SafeString2(takeProfit, "triggerPrice", "stopPrice", takeProfit)
				var tkWorkingType interface{} = this.SafeString(takeProfit, "workingType", "MARK_PRICE")
				var tpType interface{} = this.SafeString(takeProfit, "type", "TAKE_PROFIT_MARKET")
				var tpRequest interface{} = map[string]interface{}{
					"stopPrice":   this.ParseToNumeric(this.PriceToPrecision(symbol, tkTriggerPrice)),
					"workingType": tkWorkingType,
					"type":        tpType,
				}
				var slPrice interface{} = this.SafeString(takeProfit, "price")
				if IsTrue(!IsEqual(slPrice, nil)) {
					AddElementToObject(tpRequest, "price", this.ParseToNumeric(this.PriceToPrecision(symbol, slPrice)))
				}
				var tkQuantity interface{} = this.SafeString(takeProfit, "quantity", stringifiedAmount)
				AddElementToObject(tpRequest, "quantity", this.ParseToNumeric(this.AmountToPrecision(symbol, tkQuantity)))
				AddElementToObject(request, "takeProfit", this.Json(tpRequest))
			}
		}
		var positionSide interface{} = nil
		var hedged interface{} = this.SafeBool(params, "hedged", false)
		if IsTrue(hedged) {
			params = this.Omit(params, "reduceOnly")
			if IsTrue(reduceOnly) {
				positionSide = Ternary(IsTrue((IsEqual(side, "buy"))), "SHORT", "LONG")
			} else {
				positionSide = Ternary(IsTrue((IsEqual(side, "buy"))), "LONG", "SHORT")
			}
		} else {
			positionSide = "BOTH"
		}
		AddElementToObject(request, "positionSide", positionSide)
		var amountReq interface{} = amount
		if !IsTrue(GetValue(market, "inverse")) {
			amountReq = this.ParseToNumeric(this.AmountToPrecision(symbol, amount))
		}
		AddElementToObject(request, "quantity", amountReq) // precision not available for inverse contracts
	}
	params = this.Omit(params, []interface{}{"hedged", "triggerPrice", "stopLossPrice", "takeProfitPrice", "trailingAmount", "trailingPercent", "trailingType", "takeProfit", "stopLoss", "clientOrderId"})
	return this.Extend(request, params)
}

/**
 * @method
 * @name bingx#createOrder
 * @description create a trade order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Trade%20order
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Create%20an%20Order
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Trade%20order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Place%20TWAP%20Order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @param {bool} [params.postOnly] true to place a post only order
 * @param {string} [params.timeInForce] spot supports 'PO', 'GTC' and 'IOC', swap supports 'PO', 'GTC', 'IOC' and 'FOK'
 * @param {bool} [params.reduceOnly] *swap only* true or false whether the order is reduce only
 * @param {float} [params.triggerPrice] triggerPrice at which the attached take profit / stop loss order will be triggered
 * @param {float} [params.stopLossPrice] stop loss trigger price
 * @param {float} [params.takeProfitPrice] take profit trigger price
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount
 * @param {float} [params.trailingAmount] *swap only* the quote amount to trail away from the current market price
 * @param {float} [params.trailingPercent] *swap only* the percent to trail away from the current market price
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {boolean} [params.test] *swap only* whether to use the test endpoint or not, default is false
 * @param {string} [params.positionSide] *contracts only* "BOTH" for one way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
 * @param {boolean} [params.hedged] *swap only* whether the order is in hedged mode or one way mode
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes31208 := (<-this.LoadMarkets())
		PanicOnError(retRes31208)
		var market interface{} = this.Market(symbol)
		var test interface{} = this.SafeBool(params, "test", false)
		params = this.Omit(params, "test")
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			if IsTrue(test) {

				response = (<-this.SwapV2PrivatePostTradeOrderTest(request))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PrivatePostTradeOrder(request))
				PanicOnError(response)
			} else if IsTrue(IsEqual(typeVar, "twap")) {

				response = (<-this.SwapV1PrivatePostTwapOrder(request))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivatePostTradeOrder(request))
				PanicOnError(response)
			}
		} else {

			response = (<-this.SpotV1PrivatePostTradeOrder(request))
			PanicOnError(response)
		}
		//
		// spot
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": {
		//            "symbol": "XRP-USDT",
		//            "orderId": 1514090846268424192,
		//            "transactTime": 1649822362855,
		//            "price": "0.5",
		//            "origQty": "10",
		//            "executedQty": "0",
		//            "cummulativeQuoteQty": "0",
		//            "status": "PENDING",
		//            "type": "LIMIT",
		//            "side": "BUY"
		//        }
		//    }
		//
		// linear swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//             "order": {
		//                 "symbol": "BTC-USDT",
		//                 "orderId": 1709036527545438208,
		//                 "side": "BUY",
		//                 "positionSide": "LONG",
		//                 "type": "TRIGGER_LIMIT",
		//                 "clientOrderID": "",
		//                 "workingType": ""
		//             }
		//         }
		//     }
		//
		// inverse swap
		//
		//     {
		//         "orderId": 1809841379603398656,
		//         "symbol": "SOL-USD",
		//         "positionSide": "LONG",
		//         "side": "BUY",
		//         "type": "LIMIT",
		//         "price": 100,
		//         "quantity": 1,
		//         "stopPrice": 0,
		//         "workingType": "",
		//         "timeInForce": ""
		//     }
		//
		// twap order
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1732693774386,
		//         "data": {
		//             "mainOrderId": "4633860139993029715"
		//         }
		//     }
		//
		if IsTrue(IsString(response)) {
			// broken api engine : order-ids are too long numbers (i.e. 1742930526912864656)
			// and JSON.parse can not handle them in JS, so we have to use .parseJson
			// however, when order has an attached SL/TP, their value types need extra parsing
			response = this.FixStringifiedJsonMembers(response)
			response = this.ParseJson(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var result interface{} = map[string]interface{}{}
		if IsTrue(GetValue(market, "swap")) {
			if IsTrue(GetValue(market, "inverse")) {
				result = response
			} else {
				result = this.SafeDict(data, "order", data)
			}
		} else {
			result = data
		}

		ch <- this.ParseOrder(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#createOrders
 * @description create a list of trade orders
 * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Batch%20Placing%20Orders
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Bulk%20order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.sync] *spot only* if true, multiple orders are ordered serially and all orders do not require the same symbol/side/type
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes32368 := (<-this.LoadMarkets())
		PanicOnError(retRes32368)
		var ordersRequests interface{} = []interface{}{}
		var marketIds interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			AppendToArray(&marketIds, marketId)
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeNumber(rawOrder, "amount")
			var price interface{} = this.SafeNumber(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var symbols interface{} = this.MarketSymbols(marketIds, nil, false, true, true)
		var symbolsLength interface{} = GetArrayLength(symbols)
		var market interface{} = this.Market(GetValue(symbols, 0))
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			if IsTrue(IsGreaterThan(symbolsLength, 5)) {
				panic(InvalidOrder(Add(this.Id, " createOrders() can not create more than 5 orders at once for swap markets")))
			}
			AddElementToObject(request, "batchOrders", this.Json(ordersRequests))

			response = (<-this.SwapV2PrivatePostTradeBatchOrders(request))
			PanicOnError(response)
		} else {
			var sync interface{} = this.SafeBool(params, "sync", false)
			if IsTrue(sync) {
				AddElementToObject(request, "sync", true)
			}
			AddElementToObject(request, "data", this.Json(ordersRequests))

			response = (<-this.SpotV1PrivatePostTradeBatchOrders(request))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "debugMsg": "",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "symbol": "BTC-USDT",
		//                     "orderId": 1720661389564968960,
		//                     "transactTime": 1699072618272,
		//                     "price": "25000",
		//                     "origQty": "0.0002",
		//                     "executedQty": "0",
		//                     "cummulativeQuoteQty": "0",
		//                     "status": "PENDING",
		//                     "type": "LIMIT",
		//                     "side": "BUY"
		//                 },
		//             ]
		//         }
		//     }
		//
		// swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "symbol": "BTC-USDT",
		//                     "orderId": 1720657081994006528,
		//                     "side": "BUY",
		//                     "positionSide": "LONG",
		//                     "type": "LIMIT",
		//                     "clientOrderID": "",
		//                     "workingType": ""
		//                 },
		//             ]
		//         }
		//     }
		//
		if IsTrue(IsString(response)) {
			// broken api engine : order-ids are too long numbers (i.e. 1742930526912864656)
			// and JSON.parse can not handle them in JS, so we have to use .parseJson
			// however, when order has an attached SL/TP, their value types need extra parsing
			response = this.FixStringifiedJsonMembers(response)
			response = this.ParseJson(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var result interface{} = this.SafeList(data, "orders", []interface{}{})

		ch <- this.ParseOrders(result, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseOrderSide(side interface{}) interface{} {
	var sides interface{} = map[string]interface{}{
		"BUY":   "buy",
		"SELL":  "sell",
		"SHORT": "sell",
		"LONG":  "buy",
		"ask":   "sell",
		"bid":   "buy",
	}
	return this.SafeString(sides, side, side)
}
func (this *bingx) ParseOrderType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"trigger_market":     "market",
		"trigger_limit":      "limit",
		"stop_limit":         "limit",
		"stop_market":        "market",
		"take_profit_market": "market",
		"stop":               "limit",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *bingx) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	// createOrder, createOrders, cancelOrder
	//
	//    {
	//        "symbol": "XRP-USDT",
	//        "orderId": 1514090846268424192,
	//        "transactTime": 1649822362855,
	//        "price": "0.5",
	//        "origQty": "10",
	//        "executedQty": "0",
	//        "cummulativeQuoteQty": "0",
	//        "status": "PENDING",
	//        "type": "LIMIT",
	//        "side": "BUY"
	//    }
	//
	// fetchOrder
	//
	//    {
	//        "symbol": "ETH-USDT",
	//        "orderId": "1660602123001266176",
	//        "price": "1700",
	//        "origQty": "0.003",
	//        "executedQty": "0",
	//        "cummulativeQuoteQty": "0",
	//        "status": "PENDING",
	//        "type": "LIMIT",
	//        "side": "BUY",
	//        "time": "1684753373276",
	//        "updateTime": "1684753373276",
	//        "origQuoteOrderQty": "0",
	//        "fee": "0",
	//        "feeAsset": "ETH"
	//    }
	//
	// fetchOpenOrders, fetchClosedOrders
	//
	//   {
	//       "symbol": "XRP-USDT",
	//       "orderId": 1514073325788200960,
	//       "price": "0.5",
	//       "StopPrice": "0",
	//       "origQty": "20",
	//       "executedQty": "10",
	//       "cummulativeQuoteQty": "5",
	//       "status": "PENDING",
	//       "type": "LIMIT",
	//       "side": "BUY",
	//       "time": 1649818185647,
	//       "updateTime": 1649818185647,
	//       "origQuoteOrderQty": "0"
	//       "fee": "-0.01"
	//   }
	//
	//
	// linear swap
	// createOrder, createOrders
	//
	//    {
	//      "symbol": "BTC-USDT",
	//      "orderId": 1590973236294713344,
	//      "side": "BUY",
	//      "positionSide": "LONG",
	//      "type": "LIMIT"
	//    }
	//
	// inverse swap createOrder
	//
	//     {
	//         "orderId": 1809841379603398656,
	//         "symbol": "SOL-USD",
	//         "positionSide": "LONG",
	//         "side": "BUY",
	//         "type": "LIMIT",
	//         "price": 100,
	//         "quantity": 1,
	//         "stopPrice": 0,
	//         "workingType": "",
	//         "timeInForce": ""
	//     }
	//
	// fetchOrder, fetchOpenOrders, fetchClosedOrders
	//
	//     {
	//         "symbol": "BTC-USDT",
	//         "orderId": 1709036527545438208,
	//         "side": "BUY",
	//         "positionSide": "LONG",
	//         "type": "TRIGGER_LIMIT",
	//         "origQty": "0.0010",
	//         "price": "22000.0",
	//         "executedQty": "0.0000",
	//         "avgPrice": "0.0",
	//         "cumQuote": "",
	//         "stopPrice": "23000.0",
	//         "profit": "",
	//         "commission": "",
	//         "status": "NEW",
	//         "time": 1696301035187,
	//         "updateTime": 1696301035187,
	//         "clientOrderId": "",
	//         "leverage": "",
	//         "takeProfit": "",
	//         "stopLoss": "",
	//         "advanceAttr": 0,
	//         "positionID": 0,
	//         "takeProfitEntrustPrice": 0,
	//         "stopLossEntrustPrice": 0,
	//         "orderType": "",
	//         "workingType": "MARK_PRICE"
	//     }
	// with tp and sl
	//    {
	//        orderId: 1741440894764281900,
	//        symbol: 'LTC-USDT',
	//        positionSide: 'LONG',
	//        side: 'BUY',
	//        type: 'MARKET',
	//        price: 0,
	//        quantity: 1,
	//        stopPrice: 0,
	//        workingType: 'MARK_PRICE',
	//        clientOrderID: '',
	//        timeInForce: 'GTC',
	//        priceRate: 0,
	//        stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
	//        takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
	//        reduceOnly: false
	//    }
	//
	// editOrder (swap)
	//
	//    {
	//        cancelResult: 'true',
	//        cancelMsg: '',
	//        cancelResponse: {
	//            cancelClientOrderId: '',
	//            cancelOrderId: '1755336244265705472',
	//            symbol: 'SOL-USDT',
	//            orderId: '1755336244265705472',
	//            side: 'SELL',
	//            positionSide: 'SHORT',
	//            type: 'LIMIT',
	//            origQty: '1',
	//            price: '100.000',
	//            executedQty: '0',
	//            avgPrice: '0.000',
	//            cumQuote: '0',
	//            stopPrice: '',
	//            profit: '0.0000',
	//            commission: '0.000000',
	//            status: 'PENDING',
	//            time: '1707339747860',
	//            updateTime: '1707339747860',
	//            clientOrderId: '',
	//            leverage: '20X',
	//            workingType: 'MARK_PRICE',
	//            onlyOnePosition: false,
	//            reduceOnly: false
	//        },
	//        replaceResult: 'true',
	//        replaceMsg: '',
	//        newOrderResponse: {
	//            orderId: '1755338440612995072',
	//            symbol: 'SOL-USDT',
	//            positionSide: 'SHORT',
	//            side: 'SELL',
	//            type: 'LIMIT',
	//            price: '99',
	//            quantity: '2',
	//            stopPrice: '0',
	//            workingType: 'MARK_PRICE',
	//            clientOrderID: '',
	//            timeInForce: 'GTC',
	//            priceRate: '0',
	//            stopLoss: '',
	//            takeProfit: '',
	//            reduceOnly: false
	//        }
	//    }
	//
	// editOrder (spot)
	//
	//    {
	//        cancelResult: { code: '0', msg: '', result: true },
	//        openResult: { code: '0', msg: '', result: true },
	//        orderOpenResponse: {
	//            symbol: 'SOL-USDT',
	//            orderId: '1755334007697866752',
	//            transactTime: '1707339214620',
	//            price: '99',
	//            stopPrice: '0',
	//            origQty: '0.2',
	//            executedQty: '0',
	//            cummulativeQuoteQty: '0',
	//            status: 'PENDING',
	//            type: 'LIMIT',
	//            side: 'SELL',
	//            clientOrderID: ''
	//        },
	//        orderCancelResponse: {
	//            symbol: 'SOL-USDT',
	//            orderId: '1755117055251480576',
	//            price: '100',
	//            stopPrice: '0',
	//            origQty: '0.2',
	//            executedQty: '0',
	//            cummulativeQuoteQty: '0',
	//            status: 'CANCELED',
	//            type: 'LIMIT',
	//            side: 'SELL'
	//        }
	//    }
	//
	// stop loss order
	//
	//    {
	//        "symbol": "ETH-USDT",
	//        "orderId": "1792461744476422144",
	//        "price": "2775.65",
	//        "StopPrice": "2778.42",
	//        "origQty": "0.032359",
	//        "executedQty": "0",
	//        "cummulativeQuoteQty": "0",
	//        "status": "NEW",
	//        "type": "TAKE_STOP_LIMIT",
	//        "side": "SELL",
	//        "time": "1716191156868",
	//        "updateTime": "1716191156868",
	//        "origQuoteOrderQty": "0",
	//        "fee": "0",
	//        "feeAsset": "USDT",
	//        "clientOrderID": ""
	//    }
	//
	// inverse swap cancelAllOrders, cancelOrder, fetchOrder, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
	//
	//     {
	//         "symbol": "SOL-USD",
	//         "orderId": "1809845251327672320",
	//         "side": "BUY",
	//         "positionSide": "LONG",
	//         "type": "LIMIT",
	//         "quantity": 1,
	//         "origQty": "0",
	//         "price": "90",
	//         "executedQty": "0",
	//         "avgPrice": "0",
	//         "cumQuote": "0",
	//         "stopPrice": "",
	//         "profit": "0.0000",
	//         "commission": "0.000000",
	//         "status": "CANCELLED",
	//         "time": 1720335707872,
	//         "updateTime": 1720335707912,
	//         "clientOrderId": "",
	//         "leverage": "",
	//         "takeProfit": {
	//             "type": "",
	//             "quantity": 0,
	//             "stopPrice": 0,
	//             "price": 0,
	//             "workingType": "",
	//             "stopGuaranteed": ""
	//         },
	//         "stopLoss": {
	//             "type": "",
	//             "quantity": 0,
	//             "stopPrice": 0,
	//             "price": 0,
	//             "workingType": "",
	//             "stopGuaranteed": ""
	//         },
	//         "advanceAttr": 0,
	//         "positionID": 0,
	//         "takeProfitEntrustPrice": 0,
	//         "stopLossEntrustPrice": 0,
	//         "orderType": "",
	//         "workingType": ""
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var info interface{} = order
	var newOrder interface{} = this.SafeDict2(order, "newOrderResponse", "orderOpenResponse")
	if IsTrue(!IsEqual(newOrder, nil)) {
		order = newOrder
	}
	var positionSide interface{} = this.SafeString2(order, "positionSide", "ps")
	var marketType interface{} = Ternary(IsTrue((IsEqual(positionSide, nil))), "spot", "swap")
	var marketId interface{} = this.SafeString2(order, "symbol", "s")
	if IsTrue(IsEqual(market, nil)) {
		market = this.SafeMarket(marketId, nil, nil, marketType)
	}
	var side interface{} = this.SafeStringLower2(order, "side", "S")
	var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"time", "transactTime", "E", "createdTime"})
	var lastTradeTimestamp interface{} = this.SafeInteger2(order, "updateTime", "T")
	var statusId interface{} = this.SafeStringUpperN(order, []interface{}{"status", "X", "orderStatus"})
	var feeCurrencyCode interface{} = this.SafeString2(order, "feeAsset", "N")
	var feeCost interface{} = this.SafeStringN(order, []interface{}{"fee", "commission", "n"})
	if IsTrue((IsEqual(feeCurrencyCode, nil))) {
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(IsEqual(side, "buy")) {
				feeCurrencyCode = GetValue(market, "base")
			} else {
				feeCurrencyCode = GetValue(market, "quote")
			}
		} else {
			feeCurrencyCode = GetValue(market, "quote")
		}
	}
	var stopLoss interface{} = this.SafeValue(order, "stopLoss")
	var stopLossPrice interface{} = nil
	if IsTrue(IsTrue((!IsEqual(stopLoss, nil))) && IsTrue((!IsEqual(stopLoss, "")))) {
		stopLossPrice = this.OmitZero(this.SafeString(stopLoss, "stopLoss"))
	}
	if IsTrue(IsTrue(IsTrue((!IsEqual(stopLoss, nil))) && IsTrue((!IsNumber(stopLoss)))) && IsTrue((!IsEqual(stopLoss, "")))) {
		//  stopLoss: '{"stopPrice":50,"workingType":"MARK_PRICE","type":"STOP_MARKET","quantity":1}',
		if IsTrue(IsString(stopLoss)) {
			stopLoss = this.ParseJson(stopLoss)
		}
		stopLossPrice = this.OmitZero(this.SafeString(stopLoss, "stopPrice"))
	}
	var takeProfit interface{} = this.SafeValue(order, "takeProfit")
	var takeProfitPrice interface{} = nil
	if IsTrue(IsTrue(!IsEqual(takeProfit, nil)) && IsTrue((!IsEqual(takeProfit, "")))) {
		takeProfitPrice = this.OmitZero(this.SafeString(takeProfit, "takeProfit"))
	}
	if IsTrue(IsTrue(IsTrue((!IsEqual(takeProfit, nil))) && IsTrue((!IsNumber(takeProfit)))) && IsTrue((!IsEqual(takeProfit, "")))) {
		//  takeProfit: '{"stopPrice":150,"workingType":"MARK_PRICE","type":"TAKE_PROFIT_MARKET","quantity":1}',
		if IsTrue(IsString(takeProfit)) {
			takeProfit = this.ParseJson(takeProfit)
		}
		takeProfitPrice = this.OmitZero(this.SafeString(takeProfit, "stopPrice"))
	}
	var rawType interface{} = this.SafeStringLower2(order, "type", "o")
	var stopPrice interface{} = this.OmitZero(this.SafeString2(order, "StopPrice", "stopPrice"))
	var triggerPrice interface{} = stopPrice
	if IsTrue(!IsEqual(stopPrice, nil)) {
		if IsTrue(IsTrue((IsGreaterThan(GetIndexOf(rawType, "stop"), OpNeg(1)))) && IsTrue((IsEqual(stopLossPrice, nil)))) {
			stopLossPrice = stopPrice
			triggerPrice = nil
		}
		if IsTrue(IsTrue((IsGreaterThan(GetIndexOf(rawType, "take"), OpNeg(1)))) && IsTrue((IsEqual(takeProfitPrice, nil)))) {
			takeProfitPrice = stopPrice
			triggerPrice = nil
		}
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                info,
		"id":                  this.SafeStringN(order, []interface{}{"orderId", "i", "mainOrderId"}),
		"clientOrderId":       this.SafeStringN(order, []interface{}{"clientOrderID", "clientOrderId", "origClientOrderId", "c"}),
		"symbol":              this.SafeSymbol(marketId, market, "-", marketType),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  lastTradeTimestamp,
		"lastUpdateTimestamp": this.SafeInteger(order, "updateTime"),
		"type":                this.ParseOrderType(rawType),
		"timeInForce":         this.SafeString(order, "timeInForce"),
		"postOnly":            nil,
		"side":                this.ParseOrderSide(side),
		"price":               this.SafeString2(order, "price", "p"),
		"triggerPrice":        triggerPrice,
		"stopLossPrice":       stopLossPrice,
		"takeProfitPrice":     takeProfitPrice,
		"average":             this.SafeString2(order, "avgPrice", "ap"),
		"cost":                this.SafeString(order, "cummulativeQuoteQty"),
		"amount":              this.SafeStringN(order, []interface{}{"origQty", "q", "quantity", "totalAmount"}),
		"filled":              this.SafeString2(order, "executedQty", "z"),
		"remaining":           nil,
		"status":              this.ParseOrderStatus(statusId),
		"fee": map[string]interface{}{
			"currency": feeCurrencyCode,
			"cost":     Precise.StringAbs(feeCost),
		},
		"trades":     nil,
		"reduceOnly": this.SafeBool2(order, "reduceOnly", "ro"),
	}, market)
}
func (this *bingx) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"NEW":              "open",
		"PENDING":          "open",
		"PARTIALLY_FILLED": "open",
		"RUNNING":          "open",
		"FILLED":           "closed",
		"CANCELED":         "canceled",
		"CANCELLED":        "canceled",
		"FAILED":           "canceled",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bingx#cancelOrder
 * @description cancels an open order
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20Order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20Order
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Cancel%20an%20Order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20TWAP%20Order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes37608 := (<-this.LoadMarkets())
		PanicOnError(retRes37608)
		var isTwapOrder interface{} = this.SafeBool(params, "twap", false)
		params = this.Omit(params, "twap")
		var response interface{} = nil
		var market interface{} = nil
		if IsTrue(isTwapOrder) {
			var twapRequest interface{} = map[string]interface{}{
				"mainOrderId": id,
			}

			response = (<-this.SwapV1PrivatePostTwapCancelOrder(this.Extend(twapRequest, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
			}
			market = this.Market(symbol)
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}
			var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "clientOrderID")
			params = this.Omit(params, []interface{}{"clientOrderId"})
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "clientOrderID", clientOrderId)
			} else {
				AddElementToObject(request, "orderId", id)
			}
			var typeVar interface{} = nil
			var subType interface{} = nil
			typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params)
			typeVar = GetValue(typeVarparamsVariable, 0)
			params = GetValue(typeVarparamsVariable, 1)
			subTypeparamsVariable := this.HandleSubTypeAndParams("cancelOrder", market, params)
			subType = GetValue(subTypeparamsVariable, 0)
			params = GetValue(subTypeparamsVariable, 1)
			if IsTrue(IsEqual(typeVar, "spot")) {

				response = (<-this.SpotV1PrivatePostTradeCancel(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				if IsTrue(IsEqual(subType, "inverse")) {

					response = (<-this.CswapV1PrivateDeleteTradeCancelOrder(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.SwapV2PrivateDeleteTradeOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		}
		//
		// spot
		//
		//   {
		//       "code": 0,
		//       "msg": "",
		//       "data": {
		//           "symbol": "XRP-USDT",
		//           "orderId": 1514090846268424192,
		//           "price": "0.5",
		//           "origQty": "10",
		//           "executedQty": "0",
		//           "cummulativeQuoteQty": "0",
		//           "status": "CANCELED",
		//           "type": "LIMIT",
		//           "side": "BUY"
		//       }
		//   }
		//
		// inverse swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//             "order": {
		//                 "symbol": "SOL-USD",
		//                 "orderId": "1816002957423951872",
		//                 "side": "BUY",
		//                 "positionSide": "Long",
		//                 "type": "Pending",
		//                 "quantity": 0,
		//                 "origQty": "0",
		//                 "price": "150",
		//                 "executedQty": "0",
		//                 "avgPrice": "0",
		//                 "cumQuote": "0",
		//                 "stopPrice": "",
		//                 "profit": "0.0000",
		//                 "commission": "0.000000",
		//                 "status": "CANCELLED",
		//                 "time": 1721803819410,
		//                 "updateTime": 1721803819427,
		//                 "clientOrderId": "",
		//                 "leverage": "",
		//                 "takeProfit": {
		//                     "type": "",
		//                     "quantity": 0,
		//                     "stopPrice": 0,
		//                     "price": 0,
		//                     "workingType": "",
		//                     "stopGuaranteed": ""
		//                 },
		//                 "stopLoss": {
		//                     "type": "",
		//                     "quantity": 0,
		//                     "stopPrice": 0,
		//                     "price": 0,
		//                     "workingType": "",
		//                     "stopGuaranteed": ""
		//                 },
		//                 "advanceAttr": 0,
		//                 "positionID": 0,
		//                 "takeProfitEntrustPrice": 0,
		//                 "stopLossEntrustPrice": 0,
		//                 "orderType": "",
		//                 "workingType": ""
		//             }
		//         }
		//     }
		//
		// linear swap
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": {
		//          "order": {
		//            "symbol": "LINK-USDT",
		//            "orderId": 1597783850786750464,
		//            "side": "BUY",
		//            "positionSide": "LONG",
		//            "type": "TRIGGER_MARKET",
		//            "origQty": "5.0",
		//            "price": "5.0000",
		//            "executedQty": "0.0",
		//            "avgPrice": "0.0000",
		//            "cumQuote": "0",
		//            "stopPrice": "5.0000",
		//            "profit": "",
		//            "commission": "",
		//            "status": "CANCELLED",
		//            "time": 1669776330000,
		//            "updateTime": 1669776330000
		//          }
		//        }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var order interface{} = this.SafeDict(data, "order", data)

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#cancelAllOrders
 * @description cancel all open orders
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20orders%20by%20symbol
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20All%20Orders
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Cancel%20all%20orders
 * @param {string} [symbol] unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}

		retRes39418 := (<-this.LoadMarkets())
		PanicOnError(retRes39418)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.SpotV1PrivatePostTradeCancelOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "swap")) {
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PrivateDeleteTradeAllOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivateDeleteTradeAllOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			panic(BadRequest(Add(this.Id, " cancelAllOrders is only supported for spot and swap markets.")))
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList2(data, "success", "orders", []interface{}{})

		ch <- this.ParseOrders(orders)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#cancelOrders
 * @description cancel multiple orders
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Cancel%20a%20Batch%20of%20Orders
 * @see https://bingx-api.github.io/docs/#/spot/trade-api.html#Cancel%20a%20Batch%20of%20Orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderIds] client order ids
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes40858 := (<-this.LoadMarkets())
		PanicOnError(retRes40858)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var clientOrderIds interface{} = this.SafeValue(params, "clientOrderIds")
		params = this.Omit(params, "clientOrderIds")
		var idsToParse interface{} = ids
		var areClientOrderIds interface{} = (!IsEqual(clientOrderIds, nil))
		if IsTrue(areClientOrderIds) {
			idsToParse = clientOrderIds
		}
		var parsedIds interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(idsToParse)); i++ {
			var id interface{} = GetValue(idsToParse, i)
			var stringId interface{} = ToString(id)
			AppendToArray(&parsedIds, stringId)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			var spotReqKey interface{} = Ternary(IsTrue(areClientOrderIds), "clientOrderIDs", "orderIds")
			AddElementToObject(request, spotReqKey, Join(parsedIds, ","))

			response = (<-this.SpotV1PrivatePostTradeCancelOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(areClientOrderIds) {
				AddElementToObject(request, "clientOrderIDList", this.Json(parsedIds))
			} else {
				AddElementToObject(request, "orderIdList", parsedIds)
			}

			response = (<-this.SwapV2PrivateDeleteTradeBatchOrders(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var success interface{} = this.SafeList2(data, "success", "orders", []interface{}{})

		ch <- this.ParseOrders(success)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20all%20orders%20in%20countdown
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20all%20orders%20in%20countdown
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] spot or swap market
 * @returns {object} the api result
 */
func (this *bingx) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes41888 := (<-this.LoadMarkets())
		PanicOnError(retRes41888)
		var isActive interface{} = (IsGreaterThan(timeout, 0))
		var request interface{} = map[string]interface{}{
			"type":    Ternary(IsTrue((isActive)), "ACTIVATE", "CLOSE"),
			"timeOut": Ternary(IsTrue((isActive)), (this.ParseToInt(Divide(timeout, 1000))), 0),
		}
		var response interface{} = nil
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrdersAfter", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.SpotV1PrivatePostTradeCancelAllAfter(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "swap")) {

			response = (<-this.SwapV2PrivatePostTradeCancelAllAfter(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " cancelAllOrdersAfter() is not supported for "), typeVar), " markets")))
		}

		//
		//     {
		//         code: '0',
		//         msg: '',
		//         data: {
		//             triggerTime: '1712645434',
		//             status: 'ACTIVATED',
		//             note: 'All your perpetual pending orders will be closed automatically at 2024-04-09 06:50:34 UTC(+0),before that you can cancel the timer, or extend triggerTime time by this request'
		//         }
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20details
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20details
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#TWAP%20Order%20Details
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.twap] if fetching twap order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes42338 := (<-this.LoadMarkets())
		PanicOnError(retRes42338)
		var isTwapOrder interface{} = this.SafeBool(params, "twap", false)
		params = this.Omit(params, "twap")
		var response interface{} = nil
		var market interface{} = nil
		if IsTrue(isTwapOrder) {
			var twapRequest interface{} = map[string]interface{}{
				"mainOrderId": id,
			}

			response = (<-this.SwapV1PrivateGetTwapOrderDetail(this.Extend(twapRequest, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
			}
			market = this.Market(symbol)
			var request interface{} = map[string]interface{}{
				"symbol":  GetValue(market, "id"),
				"orderId": id,
			}
			var typeVar interface{} = nil
			var subType interface{} = nil
			typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params)
			typeVar = GetValue(typeVarparamsVariable, 0)
			params = GetValue(typeVarparamsVariable, 1)
			subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOrder", market, params)
			subType = GetValue(subTypeparamsVariable, 0)
			params = GetValue(subTypeparamsVariable, 1)
			if IsTrue(IsEqual(typeVar, "spot")) {

				response = (<-this.SpotV1PrivateGetTradeQuery(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				if IsTrue(IsEqual(subType, "inverse")) {

					response = (<-this.CswapV1PrivateGetTradeOrderDetail(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.SwapV2PrivateGetTradeOrder(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var order interface{} = this.SafeDict(data, "order", data)

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#All%20Orders
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history (returns less fields than above)
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {int} [params.orderId] Only return subsequent orders, and return the latest order by default
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes44108 := (<-this.LoadMarkets())
		PanicOnError(retRes44108)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(!IsEqual(typeVar, "swap")) {
			panic(NotSupported(Add(this.Id, " fetchOrders() is only supported for swap markets")))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.SwapV1PrivateGetTradeFullOrder(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//         "orders": [
		//           {
		//             "symbol": "PYTH-USDT",
		//             "orderId": 1736007506620112100,
		//             "side": "SELL",
		//             "positionSide": "SHORT",
		//             "type": "LIMIT",
		//             "origQty": "33",
		//             "price": "0.3916",
		//             "executedQty": "33",
		//             "avgPrice": "0.3916",
		//             "cumQuote": "13",
		//             "stopPrice": "",
		//             "profit": "0.0000",
		//             "commission": "-0.002585",
		//             "status": "FILLED",
		//             "time": 1702731418000,
		//             "updateTime": 1702731470000,
		//             "clientOrderId": "",
		//             "leverage": "15X",
		//             "takeProfit": {
		//                 "type": "TAKE_PROFIT",
		//                 "quantity": 0,
		//                 "stopPrice": 0,
		//                 "price": 0,
		//                 "workingType": ""
		//             },
		//             "stopLoss": {
		//                 "type": "STOP",
		//                 "quantity": 0,
		//                 "stopPrice": 0,
		//                 "price": 0,
		//                 "workingType": ""
		//             },
		//             "advanceAttr": 0,
		//             "positionID": 0,
		//             "takeProfitEntrustPrice": 0,
		//             "stopLossEntrustPrice": 0,
		//             "orderType": "",
		//             "workingType": "MARK_PRICE",
		//             "stopGuaranteed": false,
		//             "triggerOrderId": 1736012449498123500
		//           }
		//         ]
		//       }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList(data, "orders", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Current%20Open%20Orders
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Current%20All%20Open%20Orders
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20all%20current%20pending%20orders
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20TWAP%20Entrusted%20Order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.twap] if fetching twap open orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes45038 := (<-this.LoadMarkets())
		PanicOnError(retRes45038)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var typeVar interface{} = nil
		var subType interface{} = nil
		var response interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOpenOrders", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.SpotV1PrivateGetTradeOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var isTwapOrder interface{} = this.SafeBool(params, "twap", false)
			params = this.Omit(params, "twap")
			if IsTrue(isTwapOrder) {

				response = (<-this.SwapV1PrivateGetTwapOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(subType, "inverse")) {

				response = (<-this.CswapV1PrivateGetTradeOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivateGetTradeOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//  spot
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": {
		//            "orders": [
		//                {
		//                    "symbol": "XRP-USDT",
		//                    "orderId": 1514073325788200960,
		//                    "price": "0.5",
		//                    "origQty": "20",
		//                    "executedQty": "0",
		//                    "cummulativeQuoteQty": "0",
		//                    "status": "PENDING",
		//                    "type": "LIMIT",
		//                    "side": "BUY",
		//                    "time": 1649818185647,
		//                    "updateTime": 1649818185647,
		//                    "origQuoteOrderQty": "0"
		//                }
		//            ]
		//        }
		//    }
		//
		// inverse swap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "symbol": "SOL-USD",
		//                     "orderId": "1816013900044320768",
		//                     "side": "BUY",
		//                     "positionSide": "Long",
		//                     "type": "LIMIT",
		//                     "quantity": 1,
		//                     "origQty": "",
		//                     "price": "150",
		//                     "executedQty": "0",
		//                     "avgPrice": "0.000",
		//                     "cumQuote": "",
		//                     "stopPrice": "",
		//                     "profit": "0.0000",
		//                     "commission": "0.0000",
		//                     "status": "Pending",
		//                     "time": 1721806428334,
		//                     "updateTime": 1721806428352,
		//                     "clientOrderId": "",
		//                     "leverage": "",
		//                     "takeProfit": {
		//                         "type": "TAKE_PROFIT",
		//                         "quantity": 0,
		//                         "stopPrice": 0,
		//                         "price": 0,
		//                         "workingType": "MARK_PRICE",
		//                         "stopGuaranteed": ""
		//                     },
		//                     "stopLoss": {
		//                         "type": "STOP",
		//                         "quantity": 0,
		//                         "stopPrice": 0,
		//                         "price": 0,
		//                         "workingType": "MARK_PRICE",
		//                         "stopGuaranteed": ""
		//                     },
		//                     "advanceAttr": 0,
		//                     "positionID": 0,
		//                     "takeProfitEntrustPrice": 0,
		//                     "stopLossEntrustPrice": 0,
		//                     "orderType": "",
		//                     "workingType": "MARK_PRICE"
		//                 }
		//             ]
		//         }
		//     }
		//
		// linear swap
		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "data": {
		//          "orders": [
		//            {
		//              "symbol": "LINK-USDT",
		//              "orderId": 1585839271162413056,
		//              "side": "BUY",
		//              "positionSide": "LONG",
		//              "type": "TRIGGER_MARKET",
		//              "origQty": "5.0",
		//              "price": "9",
		//              "executedQty": "0.0",
		//              "avgPrice": "0",
		//              "cumQuote": "0",
		//              "stopPrice": "5",
		//              "profit": "0.0000",
		//              "commission": "0.000000",
		//              "status": "CANCELLED",
		//              "time": 1667631605000,
		//              "updateTime": 1667631605000
		//            },
		//          ]
		//        }
		//    }
		//
		// twap
		//
		//     {
		//         "code": 0,
		//         "msg": "",
		//         "timestamp": 1702731661854,
		//         "data": {
		//             "list": [
		//                 {
		//                     "symbol": "BNB-USDT",
		//                     "side": "BUY",
		//                     "positionSide": "LONG",
		//                     "priceType": "constant",
		//                     "priceVariance": "2000",
		//                     "triggerPrice": "68000",
		//                     "interval": 8,
		//                     "amountPerOrder": "0.111",
		//                     "totalAmount": "0.511",
		//                     "orderStatus": "Running",
		//                     "executedQty": "0.1",
		//                     "duration": 800,
		//                     "maxDuration": 9000,
		//                     "createdTime": 1702731661854,
		//                     "updateTime": 1702731661854
		//                 }
		//             ],
		//             "total": 1
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList2(data, "orders", "list", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
 * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {boolean} [params.standard] whether to fetch standard contract orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes46898 := (<-this.LoadMarkets())
		PanicOnError(retRes46898)

		orders := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(orders)

		ch <- this.FilterBy(orders, "status", "closed")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
 * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
 * @param {string} symbol unified market symbol of the canceled orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of canceled orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {boolean} [params.standard] whether to fetch standard contract orders
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes47118 := (<-this.LoadMarkets())
		PanicOnError(retRes47118)

		orders := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(orders)

		ch <- this.FilterBy(orders, "status", "canceled")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchCanceledAndClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Order%20history
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#User's%20History%20Orders
 * @see https://bingx-api.github.io/docs/#/standard/contract-interface.html#Historical%20order
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20TWAP%20Historical%20Orders
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {boolean} [params.standard] whether to fetch standard contract orders
 * @param {boolean} [params.twap] if fetching twap orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes47358 := (<-this.LoadMarkets())
		PanicOnError(retRes47358)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var typeVar interface{} = nil
		var subType interface{} = nil
		var standard interface{} = nil
		var response interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchClosedOrders", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		standardparamsVariable := this.HandleOptionAndParams(params, "fetchClosedOrders", "standard", false)
		standard = GetValue(standardparamsVariable, 0)
		params = GetValue(standardparamsVariable, 1)
		if IsTrue(standard) {

			response = (<-this.ContractV1PrivateGetAllOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "spot")) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "pageSize", limit)
			}

			response = (<-this.SpotV1PrivateGetTradeHistoryOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var isTwapOrder interface{} = this.SafeBool(params, "twap", false)
			params = this.Omit(params, "twap")
			if IsTrue(isTwapOrder) {
				AddElementToObject(request, "pageIndex", 1)
				AddElementToObject(request, "pageSize", Ternary(IsTrue((IsEqual(limit, nil))), 100, limit))
				AddElementToObject(request, "startTime", Ternary(IsTrue((IsEqual(since, nil))), 1, since))
				var until interface{} = this.SafeInteger(params, "until", this.Milliseconds())
				params = this.Omit(params, "until")
				AddElementToObject(request, "endTime", until)

				response = (<-this.SwapV1PrivateGetTwapHistoryOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(subType, "inverse")) {

				response = (<-this.CswapV1PrivateGetTradeOrderHistory(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivateGetTradeAllOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList2(data, "orders", "list", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://bingx-api.github.io/docs/#/en-us/common/account-api.html#Asset%20Transfer%20New
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from (spot, swap, futures, or funding)
 * @param {string} toAccount account to transfer to (spot, swap (linear or inverse), future, or funding)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *bingx) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes49258 := (<-this.LoadMarkets())
		PanicOnError(retRes49258)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("transfer", nil, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		if IsTrue(IsEqual(fromId, "swap")) {
			if IsTrue(IsEqual(subType, "inverse")) {
				fromId = "coinMPerp"
			} else {
				fromId = "USDTMPerp"
			}
		}
		if IsTrue(IsEqual(toId, "swap")) {
			if IsTrue(IsEqual(subType, "inverse")) {
				toId = "coinMPerp"
			} else {
				toId = "USDTMPerp"
			}
		}
		var request interface{} = map[string]interface{}{
			"fromAccount": fromId,
			"toAccount":   toId,
			"asset":       GetValue(currency, "id"),
			"amount":      this.CurrencyToPrecision(code, amount),
		}

		response := (<-this.ApiAssetV1PrivatePostTransfer(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "tranId": 1933130865269936128,
		//         "transferId": "1051450703949464903736"
		//     }
		//
		ch <- map[string]interface{}{
			"info":        response,
			"id":          this.SafeString(response, "transferId"),
			"timestamp":   nil,
			"datetime":    nil,
			"currency":    code,
			"amount":      amount,
			"fromAccount": fromAccount,
			"toAccount":   toAccount,
			"status":      nil,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://bingx-api.github.io/docs/#/en-us/common/account-api.html#Asset%20transfer%20records%20new
 * @param {string} [code] unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve (default 10, max 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.fromAccount (mandatory) transfer from (spot, swap (linear or inverse), future, or funding)
 * @param {string} params.toAccount (mandatory) transfer to (spot, swap(linear or inverse), future, or funding)
 * @param {boolean} [params.paginate] whether to paginate the results (default false)
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *bingx) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes49878 := (<-this.LoadMarkets())
		PanicOnError(retRes49878)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromAccount interface{} = this.SafeString(params, "fromAccount")
		var toAccount interface{} = this.SafeString(params, "toAccount")
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		if IsTrue(IsTrue(IsEqual(fromId, nil)) || IsTrue(IsEqual(toId, nil))) {
			panic(ExchangeError(Add(this.Id, " fromAccount & toAccount parameters are required")))
		}
		if IsTrue(!IsEqual(fromAccount, nil)) {
			AddElementToObject(request, "fromAccount", fromId)
		}
		if IsTrue(!IsEqual(toAccount, nil)) {
			AddElementToObject(request, "toAccount", toId)
		}
		params = this.Omit(params, []interface{}{"fromAccount", "toAccount"})
		var maxLimit interface{} = 100
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTransfers", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes501219 := (<-this.FetchPaginatedCallDynamic("fetchTransfers", nil, since, limit, params, maxLimit))
			PanicOnError(retRes501219)
			ch <- retRes501219
			return nil
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.ApiV3PrivateGetAssetTransferRecord(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "total": 2,
		//         "rows": [
		//             {
		//                 "asset": "LTC",
		//                 "amount": "0.05000000000000000000",
		//                 "status": "CONFIRMED",
		//                 "transferId": "1051461075661819338791",
		//                 "timestamp": 1752202092000,
		//                 "fromAccount": "spot",
		//                 "toAccount": "USDTMPerp"
		//             }
		//         ]
		//     }
		//
		var rows interface{} = this.SafeList(response, "rows", []interface{}{})

		ch <- this.ParseTransfers(rows, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var tranId interface{} = this.SafeString(transfer, "transferId")
	var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
	var currencyId interface{} = this.SafeString(transfer, "asset")
	var currencyCode interface{} = this.SafeCurrencyCode(currencyId, currency)
	var status interface{} = this.SafeString(transfer, "status")
	var accountsById interface{} = this.SafeDict(this.Options, "accountsById", map[string]interface{}{})
	var fromId interface{} = this.SafeString(transfer, "fromAccount")
	var toId interface{} = this.SafeString(transfer, "toAccount")
	var fromAccount interface{} = this.SafeString(accountsById, fromId, fromId)
	var toAccount interface{} = this.SafeString(accountsById, toId, toId)
	return map[string]interface{}{
		"info":        transfer,
		"id":          tranId,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    currencyCode,
		"amount":      this.SafeNumber(transfer, "amount"),
		"fromAccount": fromAccount,
		"toAccount":   toAccount,
		"status":      this.ParseTransferStatus(status),
	}
}
func (this *bingx) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"CONFIRMED": "ok",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bingx#fetchDepositAddressesByNetwork
 * @description fetch the deposit addresses for a currency associated with this account
 * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
 */
func (this *bingx) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes50838 := (<-this.LoadMarkets())
		PanicOnError(retRes50838)
		var currency interface{} = this.Currency(code)
		var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
		var recvWindow interface{} = this.SafeInteger(this.ParseParams, "recvWindow", defaultRecvWindow)
		var request interface{} = map[string]interface{}{
			"coin":       GetValue(currency, "id"),
			"offset":     0,
			"limit":      1000,
			"recvWindow": recvWindow,
		}

		response := (<-this.WalletsV1PrivateGetCapitalDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "timestamp": "1695200226859",
		//         "data": {
		//           "data": [
		//             {
		//               "coinId": "799",
		//               "coin": "USDT",
		//               "network": "BEP20",
		//               "address": "6a7eda2817462dabb6493277a2cfe0f5c3f2550b",
		//               "tag": ''
		//             }
		//           ],
		//           "total": "1"
		//         }
		//     }
		//
		var data interface{} = this.SafeList(this.SafeDict(response, "data"), "data")
		var parsed interface{} = this.ParseDepositAddresses(data, []interface{}{GetValue(currency, "code")}, false)

		ch <- this.IndexBy(parsed, "network")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://bingx-api.github.io/docs/#/en-us/common/wallet-api.html#Query%20Main%20Account%20Deposit%20Address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *bingx) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var network interface{} = this.SafeString(params, "network")
		params = this.Omit(params, []interface{}{"network"})

		addressStructures := (<-this.FetchDepositAddressesByNetwork(code, params))
		PanicOnError(addressStructures)
		if IsTrue(!IsEqual(network, nil)) {

			ch <- this.SafeDict(addressStructures, network)
			return nil
		} else {
			var options interface{} = this.SafeDict(this.Options, "defaultNetworks")
			var defaultNetworkForCurrency interface{} = this.SafeString(options, code)
			if IsTrue(!IsEqual(defaultNetworkForCurrency, nil)) {

				ch <- this.SafeDict(addressStructures, defaultNetworkForCurrency)
				return nil
			} else {
				var keys interface{} = ObjectKeys(addressStructures)
				var key interface{} = this.SafeString(keys, 0)

				ch <- this.SafeDict(addressStructures, key)
				return nil
			}
		}

	}()
	return ch
}
func (this *bingx) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {
	//     "coinId":"4",
	//     "coin":"USDT",
	//     "network":"OMNI",
	//     "address":"1HXyx8HVQRY7Nhqz63nwnRB7SpS9xQPzLN",
	//     "addressWithPrefix":"1HXyx8HVQRY7Nhqz63nwnRB7SpS9xQPzLN"
	// }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var tag interface{} = this.SafeString(depositAddress, "tag")
	var currencyId interface{} = this.SafeString(depositAddress, "coin")
	currency = this.SafeCurrency(currencyId, currency)
	var code interface{} = GetValue(currency, "code")
	var address interface{} = this.SafeString(depositAddress, "addressWithPrefix")
	var networkdId interface{} = this.SafeString(depositAddress, "network")
	var networkCode interface{} = this.NetworkIdToCode(networkdId, code)
	this.CheckAddress(address)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": code,
		"network":  networkCode,
		"address":  address,
		"tag":      tag,
	}
}

/**
 * @method
 * @name bingx#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Deposit%20History(supporting%20network)
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bingx) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes51858 := (<-this.LoadMarkets())
		PanicOnError(retRes51858)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 1000
		}

		response := (<-this.SpotV3PrivateGetCapitalDepositHisrec(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "amount":"0.00999800",
		//            "coin":"PAXG",
		//            "network":"ETH",
		//            "status":1,
		//            "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
		//            "addressTag":"",
		//            "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
		//            "insertTime":1599621997000,
		//            "transferType":0,
		//            "unlockConfirm":"12/12", // confirm times for unlocking
		//            "confirmTimes":"12/12"
		//        },
		//    ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://bingx-api.github.io/docs/#/spot/account-api.html#Withdraw%20History%20(supporting%20network)
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bingx) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes52328 := (<-this.LoadMarkets())
		PanicOnError(retRes52328)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 1000
		}

		response := (<-this.SpotV3PrivateGetCapitalWithdrawHistory(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
		//            "amount": "8.91000000",
		//            "applyTime": "2019-10-12 11:12:02",
		//            "coin": "USDT",
		//            "id": "b6ae22b3aa844210a7041aee7589627c",
		//            "withdrawOrderId": "WITHDRAWtest123",
		//            "network": "ETH",
		//            "transferType": 0
		//            "status": 6,
		//            "transactionFee": "0.004",
		//            "confirmNo":3,
		//            "info": "The address is not valid. Please confirm with the recipient",
		//            "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
		//        },
		//    ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//    {
	//        "amount":"0.00999800",
	//        "coin":"PAXG",
	//        "network":"ETH",
	//        "status":1,
	//        "address":"0x788cabe9236ce061e5a892e1a59395a81fc8d62c",
	//        "addressTag":"",
	//        "txId":"0xaad4654a3234aa6118af9b4b335f5ae81c360b2394721c019b5d1e75328b09f3",
	//        "insertTime":1599621997000,
	//        "transferType":0,
	//        "unlockConfirm":"12/12", // confirm times for unlocking
	//        "confirmTimes":"12/12"
	//    }
	//
	// fetchWithdrawals
	//
	//    {
	//        "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
	//        "amount": "8.91000000",
	//        "applyTime": "2019-10-12 11:12:02",
	//        "coin": "USDT",
	//        "id": "b6ae22b3aa844210a7041aee7589627c",
	//        "withdrawOrderId": "WITHDRAWtest123",
	//        "network": "ETH",
	//        "transferType": 0
	//        "status": 6,
	//        "transactionFee": "0.004",
	//        "confirmNo":3,
	//        "info": "The address is not valid. Please confirm with the recipient",
	//        "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268"
	//    }
	//
	// withdraw
	//
	//     {
	//         "code":0,
	//         "timestamp":1705274263621,
	//         "data":{
	//             "id":"1264246141278773252"
	//         }
	//     }
	//
	// parse withdraw-type output first...
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var data interface{} = this.SafeValue(transaction, "data")
	var dataId interface{} = Ternary(IsTrue((IsEqual(data, nil))), nil, this.SafeString(data, "id"))
	var id interface{} = this.SafeString(transaction, "id", dataId)
	var address interface{} = this.SafeString(transaction, "address")
	var tag interface{} = this.SafeString(transaction, "addressTag")
	var timestamp interface{} = this.SafeInteger2(transaction, "insertTime", "timestamp")
	var datetime interface{} = this.Iso8601(timestamp)
	if IsTrue(IsEqual(timestamp, nil)) {
		datetime = this.SafeString(transaction, "applyTime")
		timestamp = this.Parse8601(datetime)
	}
	var network interface{} = this.SafeString(transaction, "network")
	var currencyId interface{} = this.SafeString(transaction, "coin")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	if IsTrue(IsTrue(IsTrue((!IsEqual(code, nil))) && IsTrue((!IsEqual(code, network)))) && IsTrue(IsGreaterThanOrEqual(GetIndexOf(code, network), 0))) {
		if IsTrue(!IsEqual(network, nil)) {
			code = Replace(code, network, "")
		}
	}
	var rawType interface{} = this.SafeString(transaction, "transferType")
	var typeVar interface{} = Ternary(IsTrue((IsEqual(rawType, "0"))), "deposit", "withdrawal")
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        this.SafeString(transaction, "txId"),
		"type":        typeVar,
		"currency":    code,
		"network":     this.NetworkIdToCode(network),
		"amount":      this.SafeNumber(transaction, "amount"),
		"status":      this.ParseTransactionStatus(this.SafeString(transaction, "status")),
		"timestamp":   timestamp,
		"datetime":    datetime,
		"address":     address,
		"addressFrom": nil,
		"addressTo":   address,
		"tag":         tag,
		"tagFrom":     tag,
		"tagTo":       nil,
		"updated":     nil,
		"comment":     this.SafeString(transaction, "info"),
		"fee": map[string]interface{}{
			"currency": code,
			"cost":     this.SafeNumber(transaction, "transactionFee"),
			"rate":     nil,
		},
		"internal": nil,
	}
}
func (this *bingx) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"0":  "pending",
		"1":  "ok",
		"10": "pending",
		"20": "rejected",
		"30": "ok",
		"40": "rejected",
		"50": "ok",
		"60": "pending",
		"70": "rejected",
		"2":  "pending",
		"3":  "rejected",
		"4":  "pending",
		"5":  "rejected",
		"6":  "ok",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bingx#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Change%20Margin%20Type
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Set%20Margin%20Type
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *bingx) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}

		retRes54018 := (<-this.LoadMarkets())
		PanicOnError(retRes54018)
		var market interface{} = this.Market(symbol)
		if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
			panic(BadSymbol(Add(this.Id, " setMarginMode() supports swap contracts only")))
		}
		marginMode = ToUpper(marginMode)
		if IsTrue(IsEqual(marginMode, "CROSS")) {
			marginMode = "CROSSED"
		}
		if IsTrue(IsTrue(!IsEqual(marginMode, "ISOLATED")) && IsTrue(!IsEqual(marginMode, "CROSSED"))) {
			panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
		}
		var request interface{} = map[string]interface{}{
			"symbol":     GetValue(market, "id"),
			"marginType": marginMode,
		}
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("setMarginMode", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(IsEqual(subType, "inverse")) {

			retRes542019 := (<-this.CswapV1PrivatePostTradeMarginType(this.Extend(request, params)))
			PanicOnError(retRes542019)
			ch <- retRes542019
			return nil
		} else {

			retRes542219 := (<-this.SwapV2PrivatePostTradeMarginType(this.Extend(request, params)))
			PanicOnError(retRes542219)
			ch <- retRes542219
			return nil
		}

	}()
	return ch
}
func (this *bingx) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": 1,
		}

		retRes543015 := (<-this.SetMargin(symbol, amount, this.Extend(request, params)))
		PanicOnError(retRes543015)
		ch <- retRes543015
		return nil

	}()
	return ch
}
func (this *bingx) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": 2,
		}

		retRes543715 := (<-this.SetMargin(symbol, amount, this.Extend(request, params)))
		PanicOnError(retRes543715)
		ch <- retRes543715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#setMargin
 * @description Either adds or reduces margin in an isolated position in order to set the margin to a specific value
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Adjust%20isolated%20margin
 * @param {string} symbol unified market symbol of the market to set margin in
 * @param {float} amount the amount to set the margin to
 * @param {object} [params] parameters specific to the bingx api endpoint
 * @returns {object} A [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func (this *bingx) SetMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var typeVar interface{} = this.SafeInteger(params, "type") // 1 increase margin 2 decrease margin
		if IsTrue(IsEqual(typeVar, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")))
		}
		if !IsTrue(this.InArray(typeVar, []interface{}{1, 2})) {
			panic(ArgumentsRequired(Add(this.Id, " setMargin() requires a type parameter either 1 (increase margin) or 2 (decrease margin)")))
		}

		retRes54588 := (<-this.LoadMarkets())
		PanicOnError(retRes54588)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"amount": this.AmountToPrecision(GetValue(market, "symbol"), amount),
			"type":   typeVar,
		}

		response := (<-this.SwapV2PrivatePostTradePositionMargin(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//        "code": 0,
		//        "msg": "",
		//        "amount": 1,
		//        "type": 1
		//    }
		//
		ch <- this.ParseMarginModification(response, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "code": 0,
	//        "msg": "",
	//        "amount": 1,
	//        "type": 1
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var typeVar interface{} = this.SafeString(data, "type")
	return map[string]interface{}{
		"info":       data,
		"symbol":     this.SafeString(market, "symbol"),
		"type":       Ternary(IsTrue((IsEqual(typeVar, "1"))), "add", "reduce"),
		"marginMode": "isolated",
		"amount":     this.SafeNumber(data, "amount"),
		"total":      this.SafeNumber(data, "margin"),
		"code":       this.SafeString(market, "settle"),
		"status":     nil,
		"timestamp":  nil,
		"datetime":   nil,
	}
}

/**
 * @method
 * @name bingx#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Query%20Leverage
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *bingx) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes55128 := (<-this.LoadMarkets())
		PanicOnError(retRes55128)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.CswapV1PrivateGetTradeLeverage(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PrivateGetTradeLeverage(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	//
	// linear swap
	//
	//     {
	//         "longLeverage": 5,
	//         "shortLeverage": 5,
	//         "maxLongLeverage": 125,
	//         "maxShortLeverage": 125,
	//         "availableLongVol": "0.0000",
	//         "availableShortVol": "0.0000",
	//         "availableLongVal": "0.0",
	//         "availableShortVal": "0.0",
	//         "maxPositionLongVal": "0.0",
	//         "maxPositionShortVal": "0.0"
	//     }
	//
	// inverse swap
	//
	//     {
	//         "symbol": "SOL-USD",
	//         "longLeverage": 5,
	//         "shortLeverage": 5,
	//         "maxLongLeverage": 50,
	//         "maxShortLeverage": 50,
	//         "availableLongVol": "4000000",
	//         "availableShortVol": "4000000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(leverage, "symbol")
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        this.SafeSymbol(marketId, market),
		"marginMode":    nil,
		"longLeverage":  this.SafeInteger(leverage, "longLeverage"),
		"shortLeverage": this.SafeInteger(leverage, "shortLeverage"),
	}
}

/**
 * @method
 * @name bingx#setLeverage
 * @description set the level of leverage for a market
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#Switch%20Leverage
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Modify%20Leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] hedged: ['long' or 'short']. one way: ['both']
 * @returns {object} response from the exchange
 */
func (this *bingx) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}
		var side interface{} = this.SafeStringUpper(params, "side")
		this.CheckRequiredArgument("setLeverage", side, "side", []interface{}{"LONG", "SHORT", "BOTH"})

		retRes56188 := (<-this.LoadMarkets())
		PanicOnError(retRes56188)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"side":     side,
			"leverage": leverage,
		}
		if IsTrue(GetValue(market, "inverse")) {

			retRes562619 := (<-this.CswapV1PrivatePostTradeLeverage(this.Extend(request, params)))
			PanicOnError(retRes562619)
			ch <- retRes562619
			return nil
		} else {

			retRes564419 := (<-this.SwapV2PrivatePostTradeLeverage(this.Extend(request, params)))
			PanicOnError(retRes564419)
			ch <- retRes564419
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20transaction%20details
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20historical%20transaction%20orders
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20historical%20transaction%20details
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Order%20Trade%20Detail
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is undefined
 * @param {string} params.trandingUnit COIN (directly represent assets such as BTC and ETH) or CONT (represents the number of contract sheets)
 * @param {string} params.orderId the order id required for inverse swap
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *bingx) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes56858 := (<-this.LoadMarkets())
		PanicOnError(retRes56858)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var fills interface{} = nil
		var response interface{} = nil
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMyTrades", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(IsEqual(subType, "inverse")) {
			var orderId interface{} = this.SafeString(params, "orderId")
			if IsTrue(IsEqual(orderId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires an orderId argument for inverse swap trades")))
			}

			response = (<-this.CswapV1PrivateGetTradeAllFillOrders(this.Extend(request, params)))
			PanicOnError(response)
			fills = this.SafeList(response, "data", []interface{}{})
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			var now interface{} = this.Milliseconds()
			if IsTrue(!IsEqual(since, nil)) {
				var startTimeReq interface{} = Ternary(IsTrue(GetValue(market, "spot")), "startTime", "startTs")
				AddElementToObject(request, startTimeReq, since)
			} else if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "startTs", Subtract(now, Multiply(Multiply(Multiply(Multiply(30, 24), 60), 60), 1000))) // 30 days for swap
			}
			var until interface{} = this.SafeInteger(params, "until")
			params = this.Omit(params, "until")
			if IsTrue(!IsEqual(until, nil)) {
				var endTimeReq interface{} = Ternary(IsTrue(GetValue(market, "spot")), "endTime", "endTs")
				AddElementToObject(request, endTimeReq, until)
			} else if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "endTs", now)
			}
			if IsTrue(GetValue(market, "spot")) {
				if IsTrue(!IsEqual(limit, nil)) {
					AddElementToObject(request, "limit", limit) // default 500, maximum 1000
				}

				response = (<-this.SpotV1PrivateGetTradeMyTrades(this.Extend(request, params)))
				PanicOnError(response)
				var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
				fills = this.SafeList(data, "fills", []interface{}{})
			} else {
				var tradingUnit interface{} = this.SafeStringUpper(params, "tradingUnit", "CONT")
				params = this.Omit(params, "tradingUnit")
				AddElementToObject(request, "tradingUnit", tradingUnit)

				response = (<-this.SwapV2PrivateGetTradeAllFillOrders(this.Extend(request, params)))
				PanicOnError(response)
				var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
				fills = this.SafeList(data, "fill_orders", []interface{}{})
			}
		}

		ch <- this.ParseTrades(fills, market, since, limit, params)
		return nil

	}()
	return ch
}
func (this *bingx) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	// currencie structure
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var networks interface{} = this.SafeDict(fee, "networks", map[string]interface{}{})
	var networkCodes interface{} = ObjectKeys(networks)
	var networksLength interface{} = GetArrayLength(networkCodes)
	var result interface{} = map[string]interface{}{
		"info": networks,
		"withdraw": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"networks": map[string]interface{}{},
	}
	if IsTrue(!IsEqual(networksLength, 0)) {
		for i := 0; IsLessThan(i, networksLength); i++ {
			var networkCode interface{} = GetValue(networkCodes, i)
			var network interface{} = GetValue(networks, networkCode)
			AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
				"deposit": map[string]interface{}{
					"fee":        nil,
					"percentage": nil,
				},
				"withdraw": map[string]interface{}{
					"fee":        this.SafeNumber(network, "fee"),
					"percentage": false,
				},
			})
			if IsTrue(IsEqual(networksLength, 1)) {
				AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(network, "withdrawFee"))
				AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
			}
		}
	}
	return result
}

/**
 * @method
 * @name bingx#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://bingx-api.github.io/docs/#/common/account-api.html#All%20Coins'%20Information
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *bingx) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes58518 := (<-this.LoadMarkets())
		PanicOnError(retRes58518)

		response := (<-this.FetchCurrencies(params))
		PanicOnError(response)
		var depositWithdrawFees interface{} = map[string]interface{}{}
		var responseCodes interface{} = ObjectKeys(response)
		for i := 0; IsLessThan(i, GetArrayLength(responseCodes)); i++ {
			var code interface{} = GetValue(responseCodes, i)
			if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
				var entry interface{} = GetValue(response, code)
				AddElementToObject(depositWithdrawFees, code, this.ParseDepositWithdrawFee(entry))
			}
		}

		ch <- depositWithdrawFees
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#withdraw
 * @description make a withdrawal
 * @see https://bingx-api.github.io/docs/#/en-us/spot/wallet-api.html#Withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} [tag]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.walletType] 1 fund account, 2 standard account, 3 perpetual account, 15 spot account
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *bingx) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)
		this.CheckAddress(address)

		retRes58818 := (<-this.LoadMarkets())
		PanicOnError(retRes58818)
		var currency interface{} = this.Currency(code)
		var walletType interface{} = this.SafeInteger(params, "walletType", 1)
		var request interface{} = map[string]interface{}{
			"coin":       GetValue(currency, "id"),
			"address":    address,
			"amount":     this.CurrencyToPrecision(code, amount),
			"walletType": walletType,
		}
		var network interface{} = this.SafeStringUpper(params, "network")
		if IsTrue(!IsEqual(network, nil)) {
			AddElementToObject(request, "network", this.NetworkCodeToId(network))
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "addressTag", tag)
		}
		params = this.Omit(params, []interface{}{"walletType", "network"})

		response := (<-this.WalletsV1PrivatePostCapitalWithdrawApply(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeValue(response, "data")

		//    {
		//        "code":0,
		//        "timestamp":1689258953651,
		//        "data":{
		//           "id":"1197073063359000577"
		//        }
		//    }
		ch <- this.ParseTransaction(data)
		return nil

	}()
	return ch
}
func (this *bingx) ParseParams(params interface{}) interface{} {
	// const sortedParams = this.keysort (params);
	var rawKeys interface{} = ObjectKeys(params)
	var keys interface{} = this.Sort(rawKeys)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var key interface{} = GetValue(keys, i)
		var value interface{} = GetValue(params, key)
		if IsTrue(IsArray(value)) {
			var arrStr interface{} = "["
			for j := 0; IsLessThan(j, GetArrayLength(value)); j++ {
				var arrayElement interface{} = GetValue(value, j)
				if IsTrue(IsGreaterThan(j, 0)) {
					arrStr = Add(arrStr, ",")
				}
				arrStr = Add(arrStr, ToString(arrayElement))
			}
			arrStr = Add(arrStr, "]")
			AddElementToObject(params, key, arrStr)
		}
	}
	return params
}

/**
 * @method
 * @name bingx#fetchMyLiquidations
 * @description retrieves the users liquidated positions
 * @see https://bingx-api.github.io/docs/#/swapV2/trade-api.html#User's%20Force%20Orders
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20force%20orders
 * @param {string} [symbol] unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bingx api endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func (this *bingx) FetchMyLiquidations(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes59478 := (<-this.LoadMarkets())
		PanicOnError(retRes59478)
		var request interface{} = map[string]interface{}{
			"autoCloseType": "LIQUIDATION",
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMyLiquidations", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var response interface{} = nil
		var liquidations interface{} = nil
		if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.CswapV1PrivateGetTradeForceOrders(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": 0,
			//         "msg": "",
			//         "timestamp": 1721280071678,
			//         "data": [
			//             {
			//                 "orderId": "string",
			//                 "symbol": "string",
			//                 "type": "string",
			//                 "side": "string",
			//                 "positionSide": "string",
			//                 "price": "string",
			//                 "quantity": "float64",
			//                 "stopPrice": "string",
			//                 "workingType": "string",
			//                 "status": "string",
			//                 "time": "int64",
			//                 "avgPrice": "string",
			//                 "executedQty": "string",
			//                 "profit": "string",
			//                 "commission": "string",
			//                 "updateTime": "string"
			//             }
			//         ]
			//     }
			//
			liquidations = this.SafeList(response, "data", []interface{}{})
		} else {

			response = (<-this.SwapV2PrivateGetTradeForceOrders(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": 0,
			//         "msg": "",
			//         "data": {
			//             "orders": [
			//                 {
			//                     "time": "int64",
			//                     "symbol": "string",
			//                     "side": "string",
			//                     "type": "string",
			//                     "positionSide": "string",
			//                     "cumQuote": "string",
			//                     "status": "string",
			//                     "stopPrice": "string",
			//                     "price": "string",
			//                     "origQty": "string",
			//                     "avgPrice": "string",
			//                     "executedQty": "string",
			//                     "orderId": "int64",
			//                     "profit": "string",
			//                     "commission": "string",
			//                     "workingType": "string",
			//                     "updateTime": "int64"
			//                 },
			//             ]
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			liquidations = this.SafeList(data, "orders", []interface{}{})
		}

		ch <- this.ParseLiquidations(liquidations, market, since, limit)
		return nil

	}()
	return ch
}
func (this *bingx) ParseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "time": "int64",
	//         "symbol": "string",
	//         "side": "string",
	//         "type": "string",
	//         "positionSide": "string",
	//         "cumQuote": "string",
	//         "status": "string",
	//         "stopPrice": "string",
	//         "price": "string",
	//         "origQty": "string",
	//         "avgPrice": "string",
	//         "executedQty": "string",
	//         "orderId": "int64",
	//         "profit": "string",
	//         "commission": "string",
	//         "workingType": "string",
	//         "updateTime": "int64"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(liquidation, "symbol")
	var timestamp interface{} = this.SafeInteger(liquidation, "time")
	var contractsString interface{} = this.SafeString(liquidation, "executedQty")
	var contractSizeString interface{} = this.SafeString(market, "contractSize")
	var priceString interface{} = this.SafeString(liquidation, "avgPrice")
	var baseValueString interface{} = Precise.StringMul(contractsString, contractSizeString)
	var quoteValueString interface{} = Precise.StringMul(baseValueString, priceString)
	return this.SafeLiquidation(map[string]interface{}{
		"info":         liquidation,
		"symbol":       this.SafeSymbol(marketId, market),
		"contracts":    this.ParseNumber(contractsString),
		"contractSize": this.ParseNumber(contractSizeString),
		"price":        this.ParseNumber(priceString),
		"baseValue":    this.ParseNumber(baseValueString),
		"quoteValue":   this.ParseNumber(quoteValueString),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
	})
}

/**
 * @method
 * @name bingx#closePosition
 * @description closes open positions for a market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Close%20all%20positions%20in%20bulk
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} [side] not used by bingx
 * @param {object} [params] extra parameters specific to the bingx api endpoint
 * @param {string|undefined} [params.positionId] the id of the position you would like to close
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes60898 := (<-this.LoadMarkets())
		PanicOnError(retRes60898)
		var market interface{} = this.Market(symbol)
		var positionId interface{} = this.SafeString(params, "positionId")
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(!IsEqual(positionId, nil)) {

			response = (<-this.SwapV1PrivatePostTradeClosePosition(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PrivatePostTradeCloseAllPositions(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.SwapV2PrivatePostTradeCloseAllPositions(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitget#closePositions
 * @description closes open positions for a market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#One-Click%20Close%20All%20Positions
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Close%20all%20positions%20in%20bulk
 * @param {object} [params] extra parameters specific to the bingx api endpoint
 * @param {string} [params.recvWindow] request valid time window value
 * @returns {object[]} [a list of position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *bingx) CloseAllPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes61588 := (<-this.LoadMarkets())
		PanicOnError(retRes61588)
		var defaultRecvWindow interface{} = this.SafeInteger(this.Options, "recvWindow")
		var recvWindow interface{} = this.SafeInteger(this.ParseParams, "recvWindow", defaultRecvWindow)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("closeAllPositions", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("closeAllPositions", nil, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "margin")) {
			panic(BadRequest(Add(Add(Add(this.Id, " closePositions () cannot be used for "), marketType), " markets")))
		}
		var request interface{} = map[string]interface{}{
			"recvWindow": recvWindow,
		}
		var response interface{} = nil
		if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.CswapV1PrivatePostTradeCloseAllPositions(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PrivatePostTradeCloseAllPositions(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var success interface{} = this.SafeList(data, "success", []interface{}{})
		var positions interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(success)); i++ {
			var position interface{} = this.ParsePosition(map[string]interface{}{
				"positionId": GetValue(success, i),
			})
			AppendToArray(&positions, position)
		}

		ch <- positions
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Get%20Position%20Mode
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func (this *bingx) FetchPositionMode(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		response := (<-this.SwapV1PrivateGetPositionSideDual(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "timeStamp": "1709002057516",
		//         "data": {
		//             "dualSidePosition": "false"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var dualSidePosition interface{} = this.SafeString(data, "dualSidePosition")

		ch <- map[string]interface{}{
			"info":   response,
			"hedged": (IsEqual(dualSidePosition, "true")),
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Set%20Position%20Mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by bingx setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *bingx) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var dualSidePosition interface{} = nil
		if IsTrue(hedged) {
			dualSidePosition = "true"
		} else {
			dualSidePosition = "false"
		}
		var request interface{} = map[string]interface{}{
			"dualSidePosition": dualSidePosition,
		}

		retRes626815 := (<-this.SwapV1PrivatePostPositionSideDual(this.Extend(request, params)))
		PanicOnError(retRes626815)
		//
		//     {
		//         code: '0',
		//         msg: '',
		//         timeStamp: '1703327432734',
		//         data: { dualSidePosition: 'false' }
		//     }
		//
		ch <- retRes626815
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#editOrder
 * @description cancels an order and places a new order
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Cancel%20order%20and%20place%20a%20new%20order  // spot
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Cancel%20an%20order%20and%20then%20Place%20a%20new%20order  // swap
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.triggerPrice] Trigger price used for TAKE_STOP_LIMIT, TAKE_STOP_MARKET, TRIGGER_LIMIT, TRIGGER_MARKET order types.
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.cancelClientOrderID] the user-defined id of the order to be canceled, 1-40 characters, different orders cannot use the same clientOrderID, only supports a query range of 2 hours
 * @param {string} [params.cancelRestrictions] cancel orders with specified status, NEW: New order, PENDING: Pending order, PARTIALLY_FILLED: Partially filled
 * @param {string} [params.cancelReplaceMode] STOP_ON_FAILURE - if the cancel order fails, it will not continue to place a new order, ALLOW_FAILURE - regardless of whether the cancel order succeeds or fails, it will continue to place a new order
 * @param {float} [params.quoteOrderQty] order amount
 * @param {string} [params.newClientOrderId] custom order id consisting of letters, numbers, and _, 1-40 characters, different orders cannot use the same newClientOrderId.
 * @param {string} [params.positionSide] *contract only* position direction, required for single position as BOTH, for both long and short positions only LONG or SHORT can be chosen, defaults to LONG if empty
 * @param {string} [params.reduceOnly] *contract only* true or false, default=false for single position mode. this parameter is not accepted for both long and short positions mode
 * @param {float} [params.priceRate] *contract only* for type TRAILING_STOP_Market or TRAILING_TP_SL, Max = 1
 * @param {string} [params.workingType] *contract only* StopPrice trigger price types, MARK_PRICE (default), CONTRACT_PRICE, or INDEX_PRICE
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *bingx) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes63038 := (<-this.LoadMarkets())
		PanicOnError(retRes63038)
		var market interface{} = this.Market(symbol)
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		AddElementToObject(request, "cancelOrderId", id)
		AddElementToObject(request, "cancelReplaceMode", "STOP_ON_FAILURE")
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {

			response = (<-this.SwapV1PrivatePostTradeCancelReplace(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SpotV1PrivatePostTradeOrderCancelReplace(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bingx#fetchMarginMode
 * @description fetches the margin mode of the trading pair
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Query%20Margin%20Type
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Margin%20Type
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func (this *bingx) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes64208 := (<-this.LoadMarkets())
		PanicOnError(retRes64208)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var subType interface{} = nil
		var response interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchMarginMode", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.CswapV1PrivateGetTradeMarginType(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SwapV2PrivateGetTradeMarginType(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginMode(data, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(marginMode, "symbol")
	var marginType interface{} = this.SafeStringLower(marginMode, "marginType")
	marginType = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", marginType)
	return map[string]interface{}{
		"info":       marginMode,
		"symbol":     this.SafeSymbol(marketId, market, "-", "swap"),
		"marginMode": marginType,
	}
}

/**
 * @method
 * @name bingx#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://bingx-api.github.io/docs/#/en-us/spot/trade-api.html#Query%20Trading%20Commission%20Rate
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/account-api.html#Query%20Trading%20Commission%20Rate
 * @see https://bingx-api.github.io/docs/#/en-us/cswap/trade-api.html#Query%20Trade%20Commission%20Rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *bingx) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes64808 := (<-this.LoadMarkets())
		PanicOnError(retRes64808)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		var commission interface{} = map[string]interface{}{}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.SpotV1PrivateGetUserCommissionRate(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": 0,
			//         "msg": "",
			//         "debugMsg": "",
			//         "data": {
			//             "takerCommissionRate": 0.001,
			//             "makerCommissionRate": 0.001
			//         }
			//     }
			//
			commission = data
		} else {
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.CswapV1PrivateGetUserCommissionRate(params))
				PanicOnError(response)
				//
				//     {
				//         "code": 0,
				//         "msg": "",
				//         "timestamp": 1721365261438,
				//         "data": {
				//             "takerCommissionRate": "0.0005",
				//             "makerCommissionRate": "0.0002"
				//         }
				//     }
				//
				commission = data
			} else {

				response = (<-this.SwapV2PrivateGetUserCommissionRate(params))
				PanicOnError(response)
				//
				//     {
				//         "code": 0,
				//         "msg": "",
				//         "data": {
				//             "commission": {
				//                 "takerCommissionRate": 0.0005,
				//                 "makerCommissionRate": 0.0002
				//             }
				//         }
				//     }
				//
				commission = this.SafeDict(data, "commission", map[string]interface{}{})
			}
		}

		ch <- this.ParseTradingFee(commission, market)
		return nil

	}()
	return ch
}
func (this *bingx) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "takerCommissionRate": 0.001,
	//         "makerCommissionRate": 0.001
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var symbol interface{} = Ternary(IsTrue((!IsEqual(market, nil))), GetValue(market, "symbol"), nil)
	return map[string]interface{}{
		"info":       fee,
		"symbol":     symbol,
		"maker":      this.SafeNumber(fee, "makerCommissionRate"),
		"taker":      this.SafeNumber(fee, "takerCommissionRate"),
		"percentage": false,
		"tierBased":  false,
	}
}
func (this *bingx) CustomEncode(params interface{}) interface{} {
	// const sortedParams = this.keysort (params);
	var rawKeys interface{} = ObjectKeys(params)
	var keys interface{} = this.Sort(rawKeys)
	var adjustedValue interface{} = nil
	var result interface{} = nil
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var key interface{} = GetValue(keys, i)
		var value interface{} = GetValue(params, key)
		if IsTrue(IsArray(value)) {
			var arrStr interface{} = nil
			for j := 0; IsLessThan(j, GetArrayLength(value)); j++ {
				var arrayElement interface{} = GetValue(value, j)
				var isString interface{} = (IsString(arrayElement))
				if IsTrue(isString) {
					if IsTrue(IsGreaterThan(j, 0)) {
						arrStr = Add(arrStr, Add(Add(Add(",", "\""), ToString(arrayElement)), "\""))
					} else {
						arrStr = Add(Add("\"", ToString(arrayElement)), "\"")
					}
				} else {
					if IsTrue(IsGreaterThan(j, 0)) {
						arrStr = Add(arrStr, Add(",", ToString(arrayElement)))
					} else {
						arrStr = ToString(arrayElement)
					}
				}
			}
			adjustedValue = Add(Add("[", arrStr), "]")
			value = adjustedValue
		}
		if IsTrue(IsEqual(i, 0)) {
			result = Add(Add(key, "="), value)
		} else {
			result = Add(result, Add(Add(Add("&", key), "="), value))
		}
	}
	return result
}
func (this *bingx) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	section := GetArg(optionalArgs, 0, "public")
	_ = section
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var typeVar interface{} = GetValue(section, 0)
	var version interface{} = GetValue(section, 1)
	var access interface{} = GetValue(section, 2)
	var isSandbox interface{} = this.SafeBool(this.Options, "sandboxMode", false)
	if IsTrue(IsTrue(isSandbox) && IsTrue((!IsEqual(typeVar, "swap")))) {
		panic(NotSupported(Add(Add(Add(this.Id, " does not have a testnet/sandbox URL for "), typeVar), " endpoints")))
	}
	var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), typeVar))
	path = this.ImplodeParams(path, params)
	var versionIsTransfer interface{} = (IsEqual(version, "transfer"))
	var versionIsAsset interface{} = (IsEqual(version, "asset"))
	if IsTrue(IsTrue(versionIsTransfer) || IsTrue(versionIsAsset)) {
		if IsTrue(versionIsTransfer) {
			typeVar = "account/transfer"
		} else {
			typeVar = "api/asset"
		}
		version = GetValue(section, 2)
		access = GetValue(section, 3)
	}
	if IsTrue(!IsEqual(path, "account/apiPermissions")) {
		if IsTrue(IsTrue(IsEqual(typeVar, "spot")) && IsTrue(IsEqual(version, "v3"))) {
			url = Add(url, "/api")
		} else {
			url = Add(url, Add("/", typeVar))
		}
	}
	url = Add(url, Add(Add(Add("/", version), "/"), path))
	params = this.Omit(params, this.ExtractParams(path))
	AddElementToObject(params, "timestamp", this.Nonce())
	params = this.Keysort(params)
	if IsTrue(IsEqual(access, "public")) {
		if IsTrue(GetArrayLength(ObjectKeys(params))) {
			url = Add(url, Add("?", this.Urlencode(params)))
		}
	} else if IsTrue(IsEqual(access, "private")) {
		this.CheckRequiredCredentials()
		var isJsonContentType interface{} = (IsTrue((IsTrue((IsEqual(typeVar, "subAccount"))) || IsTrue((IsEqual(typeVar, "account/transfer"))))) && IsTrue((IsEqual(method, "POST"))))
		var parsedParams interface{} = nil
		var encodeRequest interface{} = nil
		if IsTrue(isJsonContentType) {
			encodeRequest = this.CustomEncode(params)
		} else {
			parsedParams = this.ParseParams(params)
			encodeRequest = this.Rawencode(parsedParams, true)
		}
		var signature interface{} = this.Hmac(this.Encode(encodeRequest), this.Encode(this.Secret), sha256)
		headers = map[string]interface{}{
			"X-BX-APIKEY":  this.ApiKey,
			"X-SOURCE-KEY": this.SafeString(this.Options, "broker", "CCXT"),
		}
		if IsTrue(isJsonContentType) {
			AddElementToObject(headers, "Content-Type", "application/json")
			AddElementToObject(params, "signature", signature)
			body = this.Json(params)
		} else {
			var query interface{} = this.Urlencode(parsedParams, true)
			url = Add(url, Add(Add(Add(Add("?", query), "&"), "signature="), signature))
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *bingx) Nonce() interface{} {
	return this.Milliseconds()
}
func (this *bingx) SetSandboxMode(enable interface{}) {
	this.Exchange.SetSandboxMode(enable)
	AddElementToObject(this.Options, "sandboxMode", enable)
}
func (this *bingx) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	//
	//    {
	//        "code": 80014,
	//        "msg": "Invalid parameters, err:Key: 'GetTickerRequest.Symbol' Error:Field validation for "Symbol" failed on the "len=0|endswith=-USDT" tag",
	//        "data": {
	//        }
	//    }
	//
	var code interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString(response, "msg")
	var transferErrorMsg interface{} = this.SafeString(response, "transferErrorMsg") // handling with errors from transfer endpoint
	if IsTrue(IsTrue((!IsEqual(transferErrorMsg, nil))) || IsTrue((IsTrue(!IsEqual(code, nil)) && IsTrue(!IsEqual(code, "0"))))) {
		if IsTrue(!IsEqual(transferErrorMsg, nil)) {
			message = transferErrorMsg
		}
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *bingx) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
