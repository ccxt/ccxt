package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type woo struct {
    Exchange

}

func NewWooCore() *woo {
    p := &woo{}
    setDefaults(p)
    return p
}

func  (this *woo) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "woo",
        "name": "WOO X",
        "countries": []interface{}{"KY"},
        "rateLimit": 100,
        "version": "v1",
        "certified": true,
        "pro": true,
        "hostname": "woox.io",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": true,
            "cancelOrder": true,
            "cancelWithdraw": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": true,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": true,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": false,
            "createStopLossOrder": true,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": true,
            "createTrailingAmountOrder": true,
            "createTrailingPercentOrder": true,
            "createTriggerOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchConvertCurrencies": true,
            "fetchConvertQuote": true,
            "fetchConvertTrade": true,
            "fetchConvertTradeHistory": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": false,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": true,
            "setLeverage": true,
            "setMargin": false,
            "setPositionMode": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1mon",
            "1y": "1y",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",
            "api": map[string]interface{} {
                "pub": "https://api-pub.woox.io",
                "public": "https://api.{hostname}",
                "private": "https://api.{hostname}",
            },
            "test": map[string]interface{} {
                "pub": "https://api-pub.staging.woox.io",
                "public": "https://api.staging.woox.io",
                "private": "https://api.staging.woox.io",
            },
            "www": "https://woox.io/",
            "doc": []interface{}{"https://docs.woox.io/"},
            "fees": []interface{}{"https://support.woox.io/hc/en-001/articles/4404611795353--Trading-Fees"},
            "referral": map[string]interface{} {
                "url": "https://woox.io/register?ref=DIJT0CNL",
                "discount": 0.35,
            },
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "pub": map[string]interface{} {
                    "get": map[string]interface{} {
                        "hist/kline": 10,
                        "hist/trades": 10,
                    },
                },
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "info": 1,
                        "info/{symbol}": 1,
                        "system_info": 1,
                        "market_trades": 1,
                        "token": 1,
                        "token_network": 1,
                        "funding_rates": 1,
                        "funding_rate/{symbol}": 1,
                        "funding_rate_history": 1,
                        "futures": 1,
                        "futures/{symbol}": 1,
                        "orderbook/{symbol}": 1,
                        "kline": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "client/token": 1,
                        "order/{oid}": 1,
                        "client/order/{client_order_id}": 1,
                        "orders": 1,
                        "client/trade/{tid}": 1,
                        "order/{oid}/trades": 1,
                        "client/trades": 1,
                        "client/hist_trades": 1,
                        "staking/yield_history": 1,
                        "client/holding": 1,
                        "asset/deposit": 10,
                        "asset/history": 60,
                        "sub_account/all": 60,
                        "sub_account/assets": 60,
                        "sub_account/asset_detail": 60,
                        "sub_account/ip_restriction": 10,
                        "asset/main_sub_transfer_history": 30,
                        "token_interest": 60,
                        "token_interest/{token}": 60,
                        "interest/history": 60,
                        "interest/repay": 60,
                        "funding_fee/history": 30,
                        "positions": 3.33,
                        "position/{symbol}": 3.33,
                        "client/transaction_history": 60,
                        "client/futures_leverage": 60,
                    },
                    "post": map[string]interface{} {
                        "order": 1,
                        "order/cancel_all_after": 1,
                        "asset/main_sub_transfer": 30,
                        "asset/ltv": 30,
                        "asset/withdraw": 30,
                        "asset/internal_withdraw": 30,
                        "interest/repay": 60,
                        "client/account_mode": 120,
                        "client/position_mode": 5,
                        "client/leverage": 120,
                        "client/futures_leverage": 30,
                        "client/isolated_margin": 30,
                    },
                    "delete": map[string]interface{} {
                        "order": 1,
                        "client/order": 1,
                        "orders": 1,
                        "asset/withdraw": 120,
                    },
                },
            },
            "v2": map[string]interface{} {
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "client/holding": 1,
                    },
                },
            },
            "v3": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "systemInfo": 1,
                        "instruments": 1,
                        "token": 1,
                        "tokenNetwork": 1,
                        "tokenInfo": 1,
                        "marketTrades": 1,
                        "marketTradesHistory": 1,
                        "orderbook": 1,
                        "kline": 1,
                        "klineHistory": 1,
                        "futures": 1,
                        "fundingRate": 1,
                        "fundingRateHistory": 1,
                        "insuranceFund": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "trade/order": 2,
                        "trade/orders": 1,
                        "trade/algoOrder": 1,
                        "trade/algoOrders": 1,
                        "trade/transaction": 1,
                        "trade/transactionHistory": 5,
                        "trade/tradingFee": 5,
                        "account/info": 60,
                        "account/tokenConfig": 1,
                        "account/symbolConfig": 1,
                        "account/subAccounts/all": 60,
                        "account/referral/summary": 60,
                        "account/referral/rewardHistory": 60,
                        "account/credentials": 60,
                        "asset/balances": 1,
                        "asset/token/history": 60,
                        "asset/transfer/history": 30,
                        "asset/wallet/history": 60,
                        "asset/wallet/deposit": 60,
                        "asset/staking/yieldHistory": 60,
                        "futures/positions": 3.33,
                        "futures/leverage": 60,
                        "futures/defaultMarginMode": 60,
                        "futures/fundingFee/history": 30,
                        "spotMargin/interestRate": 60,
                        "spotMargin/interestHistory": 60,
                        "spotMargin/maxMargin": 60,
                        "algo/order/{oid}": 1,
                        "algo/orders": 1,
                        "balances": 1,
                        "positions": 3.33,
                        "buypower": 1,
                        "convert/exchangeInfo": 1,
                        "convert/assetInfo": 1,
                        "convert/rfq": 60,
                        "convert/trade": 1,
                        "convert/trades": 1,
                    },
                    "post": map[string]interface{} {
                        "trade/order": 2,
                        "trade/algoOrder": 5,
                        "trade/cancelAllAfter": 1,
                        "account/tradingMode": 120,
                        "account/listenKey": 20,
                        "asset/transfer": 30,
                        "asset/wallet/withdraw": 60,
                        "spotMargin/leverage": 120,
                        "spotMargin/interestRepay": 60,
                        "algo/order": 5,
                        "convert/rft": 60,
                    },
                    "put": map[string]interface{} {
                        "trade/order": 2,
                        "trade/algoOrder": 2,
                        "futures/leverage": 60,
                        "futures/positionMode": 120,
                        "order/{oid}": 2,
                        "order/client/{client_order_id}": 2,
                        "algo/order/{oid}": 2,
                        "algo/order/client/{client_order_id}": 2,
                    },
                    "delete": map[string]interface{} {
                        "trade/order": 1,
                        "trade/orders": 1,
                        "trade/algoOrder": 1,
                        "trade/algoOrders": 1,
                        "trade/allOrders": 1,
                        "algo/order/{order_id}": 1,
                        "algo/orders/pending": 1,
                        "algo/orders/pending/{symbol}": 1,
                        "orders/pending": 1,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0002"),
                "taker": this.ParseNumber("0.0005"),
            },
        },
        "options": map[string]interface{} {
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "sandboxMode": false,
            "createMarketBuyOrderRequiresPrice": true,
            "network-aliases-for-tokens": map[string]interface{} {
                "HT": "ERC20",
                "OMG": "ERC20",
                "UATOM": "ATOM",
                "ZRX": "ZRX",
            },
            "networks": map[string]interface{} {
                "TRX": "TRON",
                "TRC20": "TRON",
                "ERC20": "ETH",
                "BEP20": "BSC",
                "ARB": "Arbitrum",
            },
            "networksById": map[string]interface{} {
                "TRX": "TRC20",
                "TRON": "TRC20",
            },
            "defaultNetworkCodeForCurrencies": map[string]interface{} {},
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "brokerId": "bc830de7-50f3-460b-9ee0-f430f83f9dad",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 90,
                    "untilDays": 10000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forSwap": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "hedged": true,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forSwap",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1000": OperationFailed,
                "-1001": AuthenticationError,
                "-1002": AuthenticationError,
                "-1003": RateLimitExceeded,
                "-1004": BadRequest,
                "-1005": BadRequest,
                "-1006": BadRequest,
                "-1007": BadRequest,
                "-1008": InvalidOrder,
                "-1009": BadRequest,
                "-1012": BadRequest,
                "-1101": InvalidOrder,
                "-1102": InvalidOrder,
                "-1103": InvalidOrder,
                "-1104": InvalidOrder,
                "-1105": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "Can not place": ExchangeError,
                "maintenance": OnMaintenance,
                "symbol must not be blank": BadRequest,
                "The token is not supported": BadRequest,
                "Your order and symbol are not valid or already canceled": BadRequest,
                "Insufficient WOO. Please enable margin trading for leverage trading": BadRequest,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name woo#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://developer.woox.io/api-reference/endpoint/public_data/systemInfo
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *woo) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V3PublicGetSystemInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": 0,
            //             "msg": "System is functioning properly.",
            //             "estimatedEndTime": 1749963600362
            //         },
            //         "timestamp": 1751442989564
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var status interface{} = this.SafeString(data, "status")
            if IsTrue(IsEqual(status, nil)) {
                status = "error"
            } else if IsTrue(IsEqual(status, "0")) {
                status = "ok"
            } else {
                status = "maintenance"
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://developer.woox.io/api-reference/endpoint/public_data/systemInfo
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *woo) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V3PublicGetSystemInfo(params))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": 0,
            //             "msg": "System is functioning properly.",
            //             "estimatedEndTime": 1749963600362
            //         },
            //         "timestamp": 1751442989564
            //     }
            //
        ch <- this.SafeInteger(response, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchMarkets
 * @description retrieves data on all markets for woo
 * @see https://developer.woox.io/api-reference/endpoint/public_data/instruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *woo) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes57512 := (<-this.LoadTimeDifference())
                PanicOnError(retRes57512)
            }
        
            response:= (<-this.V3PublicGetInstruments(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "SPOT_AAVE_USDT",
            //                     "status": "TRADING",
            //                     "baseAsset": "AAVE",
            //                     "baseAssetMultiplier": 1,
            //                     "quoteAsset": "USDT",
            //                     "quoteMin": "0",
            //                     "quoteMax": "100000",
            //                     "quoteTick": "0.01",
            //                     "baseMin": "0.005",
            //                     "baseMax": "5000",
            //                     "baseTick": "0.0001",
            //                     "minNotional": "1",
            //                     "bidCapRatio": "1.1",
            //                     "bidFloorRatio": null,
            //                     "askCapRatio": null,
            //                     "askFloorRatio": "0.9",
            //                     "orderMode": "NORMAL",
            //                     "impactNotional": null,
            //                     "isAllowedRpi": false,
            //                     "tickGranularity": null
            //                 }
            //             ]
            //         },
            //         "timestamp": 1751512951338
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseMarkets(rows)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseMarket(market interface{}) interface{}  {
    var marketId interface{} = this.SafeString(market, "symbol")
    var parts interface{} = Split(marketId, "_")
    var first interface{} = this.SafeString(parts, 0)
    var marketType interface{} = nil
    var spot interface{} = false
    var swap interface{} = false
    if IsTrue(IsEqual(first, "SPOT")) {
        spot = true
        marketType = "spot"
    } else if IsTrue(IsEqual(first, "PERP")) {
        swap = true
        marketType = "swap"
    }
    var baseId interface{} = this.SafeString(parts, 1)
    var quoteId interface{} = this.SafeString(parts, 2)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = nil
    var settle interface{} = nil
    var symbol interface{} = Add(Add(base, "/"), quote)
    var contractSize interface{} = nil
    var linear interface{} = nil
    var inverse interface{} = nil
    var margin interface{} = true
    var contract interface{} = swap
    if IsTrue(contract) {
        margin = false
        settleId = this.SafeString(parts, 2)
        settle = this.SafeCurrencyCode(settleId)
        symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
        contractSize = this.ParseNumber("1")
        linear = true
        inverse = false
    }
    var active interface{} = IsEqual(this.SafeString(market, "status"), "TRADING")
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": marketType,
        "spot": spot,
        "margin": margin,
        "swap": swap,
        "future": false,
        "option": false,
        "active": active,
        "contract": contract,
        "linear": linear,
        "inverse": inverse,
        "contractSize": contractSize,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "baseTick"),
            "price": this.SafeNumber(market, "quoteTick"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "baseMin"),
                "max": this.SafeNumber(market, "baseMax"),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "quoteMin"),
                "max": this.SafeNumber(market, "quoteMax"),
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "minNotional"),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name woo#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://developer.woox.io/api-reference/endpoint/public_data/marketTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *woo) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7148 := (<-this.LoadMarkets())
            PanicOnError(retRes7148)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V3PublicGetMarketTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "SPOT_BTC_USDT",
            //                     "side": "SELL",
            //                     "source": 0,
            //                     "executedPrice": "108741.01",
            //                     "executedQuantity": "0.02477",
            //                     "executedTimestamp": 1751513940144
            //                 }
            //             ]
            //         },
            //         "timestamp": 1751513988543
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTrades(rows, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public/market_trades
    //
    //     {
    //         "symbol": "SPOT_BTC_USDT",
    //         "side": "SELL",
    //         "source": 0,
    //         "executedPrice": "108741.01",
    //         "executedQuantity": "0.02477",
    //         "executedTimestamp": 1751513940144
    //     }
    //
    // fetchOrderTrades, fetchOrder
    //
    //     {
    //         "id": 1734947821,
    //         "symbol": "SPOT_LTC_USDT",
    //         "orderId": 60780383217,
    //         "executedPrice": 87.86,
    //         "executedQuantity": 0.1,
    //         "fee": 0.0001,
    //         "realizedPnl": null,
    //         "feeAsset": "LTC",
    //         "orderTag": "default",
    //         "side": "BUY",
    //         "executedTimestamp": "1752055173.630",
    //         "isMaker": 0
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var isFromFetchOrder interface{} =     (InOp(trade, "id"))
    var timestampString interface{} = this.SafeString2(trade, "executed_timestamp", "executedTimestamp")
    var timestamp interface{} = nil
    if IsTrue(!IsEqual(timestampString, nil)) {
        if IsTrue(IsGreaterThan(GetIndexOf(timestampString, "."), OpNeg(1))) {
            timestamp = this.SafeTimestamp2(trade, "executed_timestamp", "executedTimestamp")
        } else {
            timestamp = this.SafeInteger(trade, "executedTimestamp")
        }
    }
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString2(trade, "executed_price", "executedPrice")
    var amount interface{} = this.SafeString2(trade, "executed_quantity", "executedQuantity")
    var order_id interface{} = this.SafeString2(trade, "order_id", "orderId")
    var fee interface{} = this.ParseTokenAndFeeTemp(trade, []interface{}{"fee_asset", "feeAsset"}, []interface{}{"fee"})
    var feeCost interface{} = this.SafeString(fee, "cost")
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "cost", feeCost)
    }
    var cost interface{} = Precise.StringMul(price, amount)
    var side interface{} = this.SafeStringLower(trade, "side")
    var id interface{} = this.SafeString(trade, "id")
    var takerOrMaker interface{} = nil
    if IsTrue(isFromFetchOrder) {
        var isMaker interface{} = IsEqual(this.SafeString2(trade, "is_maker", "isMaker"), "1")
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": order_id,
        "takerOrMaker": takerOrMaker,
        "type": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *woo) ParseTokenAndFeeTemp(item interface{}, feeTokenKeys interface{}, feeAmountKeys interface{}) interface{}  {
    var feeCost interface{} = this.SafeStringN(item, feeAmountKeys)
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeStringN(item, feeTokenKeys)
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    return fee
}
func  (this *woo) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "makerFee"), "100")),
        "taker": this.ParseNumber(Precise.StringDiv(this.SafeString(fee, "takerFee"), "100")),
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name woo#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_tradingFee
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch trading fees in a portfolio margin account
 * @param {string} [params.subType] "linear" or "inverse"
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *woo) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8618 := (<-this.LoadMarkets())
            PanicOnError(retRes8618)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V3PrivateGetTradeTradingFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "symbol": "SPOT_BTC_USDT",
            //             "takerFee": "10",
            //             "makerFee": "8"
            //         },
            //         "timestamp": 1751858977368
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTradingFee(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *woo) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8918 := (<-this.LoadMarkets())
            PanicOnError(retRes8918)
        
            response:= (<-this.V3PrivateGetAccountInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
            //             "account": "carlos_jose_lima@yahoo.com",
            //             "alias": "carlos_jose_lima@yahoo.com",
            //             "otpauth": true,
            //             "accountMode": "FUTURES",
            //             "positionMode": "ONE_WAY",
            //             "leverage": 0,
            //             "makerFeeRate": 0,
            //             "takerFeeRate": 0,
            //             "marginRatio": "10",
            //             "openMarginRatio": "10",
            //             "initialMarginRatio": "10",
            //             "maintenanceMarginRatio": "0.03",
            //             "totalCollateral": "165.55629469",
            //             "freeCollateral": "165.55629469",
            //             "totalAccountValue": "167.32418611",
            //             "totalTradingValue": "167.32418611",
            //             "totalVaultValue": "0",
            //             "totalStakingValue": "0",
            //             "totalLaunchpadValue": "0",
            //             "totalEarnValue": "0",
            //             "referrerID": null,
            //             "accountType": "Main"
            //         },
            //         "timestamp": 1752062807915
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var maker interface{} = this.SafeString(data, "makerFeeRate")
            var taker interface{} = this.SafeString(data, "takerFeeRate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(Precise.StringDiv(maker, "10000")),
            "taker": this.ParseNumber(Precise.StringDiv(taker, "10000")),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.woox.io/#available-token-public
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *woo) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var result interface{} = map[string]interface{} {}
            var tokenResponsePromise interface{} = this.V1PublicGetToken(params)
            //
            //    {
            //      "rows": [
            //         {
            //             "token": "ETH_USDT",
            //             "fullname": "Tether",
            //             "network": "ETH",
            //             "decimals": "6",
            //             "delisted": false,
            //             "balance_token": "USDT",
            //             "created_time": "1710123398",
            //             "updated_time": "1746528481",
            //             "can_collateral": true,
            //             "can_short": true
            //         },
            //         {
            //             "token": "BSC_USDT",
            //             "fullname": "Tether",
            //             "network": "BSC",
            //             "decimals": "18",
            //             "delisted": false,
            //             "balance_token": "USDT",
            //             "created_time": "1710123395",
            //             "updated_time": "1746528601",
            //             "can_collateral": true,
            //             "can_short": true
            //         },
            //         {
            //             "token": "ALGO",
            //             "fullname": "Algorand",
            //             "network": "ALGO",
            //             "decimals": "6",
            //             "delisted": false,
            //             "balance_token": "ALGO",
            //             "created_time": "1710123394",
            //             "updated_time": "1723087518",
            //             "can_collateral": true,
            //             "can_short": true
            //         },
            //         ...
            //     ],
            //     "success": true
            // }
            //
            // only make one request for currrencies...
            var tokenNetworkResponsePromise interface{} = this.V1PublicGetTokenNetwork(params)
            //
            // {
            //     "rows": [
            //         {
            //             "protocol": "ERC20",
            //             "network": "ETH",
            //             "token": "USDT",
            //             "name": "Ethereum (ERC20)",
            //             "minimum_withdrawal": "10.00000000",
            //             "withdrawal_fee": "2.00000000",
            //             "allow_deposit": "1",
            //             "allow_withdraw": "1"
            //         },
            //         {
            //             "protocol": "TRC20",
            //             "network": "TRX",
            //             "token": "USDT",
            //             "name": "Tron (TRC20)",
            //             "minimum_withdrawal": "10.00000000",
            //             "withdrawal_fee": "4.50000000",
            //             "allow_deposit": "1",
            //             "allow_withdraw": "1"
            //         },
            //         ...
            //     ],
            //     "success": true
            // }
            //
            tokenResponsetokenNetworkResponseVariable := (<-promiseAll([]interface{}{tokenResponsePromise, tokenNetworkResponsePromise}));
            tokenResponse := GetValue(tokenResponsetokenNetworkResponseVariable,0);
            tokenNetworkResponse := GetValue(tokenResponsetokenNetworkResponseVariable,1)
            var tokenRows interface{} = this.SafeList(tokenResponse, "rows", []interface{}{})
            var tokenNetworkRows interface{} = this.SafeList(tokenNetworkResponse, "rows", []interface{}{})
            var networksById interface{} = this.GroupBy(tokenNetworkRows, "token")
            var tokensById interface{} = this.GroupBy(tokenRows, "balance_token")
            var currencyIds interface{} = ObjectKeys(tokensById)
            for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
                var currencyId interface{} = GetValue(currencyIds, i)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var tokensByNetworkId interface{} = this.IndexBy(GetValue(tokensById, currencyId), "network")
                var chainsByNetworkId interface{} = this.IndexBy(GetValue(networksById, currencyId), "network")
                var keys interface{} = ObjectKeys(chainsByNetworkId)
                var resultingNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(keys)); j++ {
                    var networkId interface{} = GetValue(keys, j)
                    var tokenEntry interface{} = this.SafeDict(tokensByNetworkId, networkId, map[string]interface{} {})
                    var networkEntry interface{} = this.SafeDict(chainsByNetworkId, networkId, map[string]interface{} {})
                    var networkCode interface{} = this.NetworkIdToCode(networkId, code)
                    var specialNetworkId interface{} = this.SafeString(tokenEntry, "token")
                    AddElementToObject(resultingNetworks, networkCode, map[string]interface{} {
            "id": networkId,
            "currencyNetworkId": specialNetworkId,
            "network": networkCode,
            "active": nil,
            "deposit": IsEqual(this.SafeString(networkEntry, "allow_deposit"), "1"),
            "withdraw": IsEqual(this.SafeString(networkEntry, "allow_withdraw"), "1"),
            "fee": this.SafeNumber(networkEntry, "withdrawal_fee"),
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(tokenEntry, "decimals"))),
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(networkEntry, "minimum_withdrawal"),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "info": []interface{}{networkEntry, tokenEntry},
        })
                }
                AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": currencyId,
            "name": nil,
            "code": code,
            "precision": nil,
            "active": nil,
            "fee": nil,
            "networks": resultingNetworks,
            "deposit": nil,
            "withdraw": nil,
            "type": "crypto",
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "info": []interface{}{tokensByNetworkId, chainsByNetworkId},
        }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://docs.woox.io/#send-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11068 := (<-this.LoadMarkets())
            PanicOnError(retRes11068)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
        
                retRes111115 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, 1, params))
                PanicOnError(retRes111115)
                ch <- retRes111115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://docs.woox.io/#send-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11258 := (<-this.LoadMarkets())
            PanicOnError(retRes11258)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketSellOrderWithCost() supports spot orders only")))
            }
        
                retRes113015 :=  (<-this.CreateOrder(symbol, "market", "sell", cost, 1, params))
                PanicOnError(retRes113015)
                ch <- retRes113015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createTrailingAmountOrder
 * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
 * @see https://docs.woox.io/#send-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
 * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
 * @param {float} trailingAmount the quote amount to trail away from the current market price
 * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateTrailingAmountOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            trailingAmount := GetArg(optionalArgs, 1, nil)
            _ = trailingAmount
            trailingTriggerPrice := GetArg(optionalArgs, 2, nil)
            _ = trailingTriggerPrice
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(trailingAmount, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingAmountOrder() requires a trailingAmount argument")))
            }
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingAmountOrder() requires a trailingTriggerPrice argument")))
            }
            AddElementToObject(params, "trailingAmount", trailingAmount)
            AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
        
                retRes115715 :=  (<-this.CreateOrder(symbol, typeVar, side, amount, price, params))
                PanicOnError(retRes115715)
                ch <- retRes115715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createTrailingPercentOrder
 * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
 * @see https://docs.woox.io/#send-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
 * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
 * @param {float} trailingPercent the percent to trail away from the current market price
 * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateTrailingPercentOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            trailingPercent := GetArg(optionalArgs, 1, nil)
            _ = trailingPercent
            trailingTriggerPrice := GetArg(optionalArgs, 2, nil)
            _ = trailingTriggerPrice
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(trailingPercent, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingPercent argument")))
            }
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")))
            }
            AddElementToObject(params, "trailingPercent", trailingPercent)
            AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
        
                retRes118415 :=  (<-this.CreateOrder(symbol, typeVar, side, amount, price, params))
                PanicOnError(retRes118415)
                ch <- retRes118415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createOrder
 * @description create a trade order
 * @see https://developer.woox.io/api-reference/endpoint/trading/post_order
 * @see https://developer.woox.io/api-reference/endpoint/trading/post_algo_order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated', default 'cross'
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.algoType] 'STOP' or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
 * @param {string} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @param {string} [params.position_side] 'SHORT' or 'LONG' - if position mode is HEDGE_MODE and the trading involves futures, then is required, otherwise this parameter is not required
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
            params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only"})
            var orderType interface{} = ToUpper(typeVar)
        
            retRes12178 := (<-this.LoadMarkets())
            PanicOnError(retRes12178)
            var market interface{} = this.Market(symbol)
            var orderSide interface{} = ToUpper(side)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": orderSide,
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(!IsEqual(marginMode, nil)) {
                AddElementToObject(request, "marginMode", this.EncodeMarginMode(marginMode))
            }
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            var stopLoss interface{} = this.SafeValue(params, "stopLoss")
            var takeProfit interface{} = this.SafeValue(params, "takeProfit")
            var algoType interface{} = this.SafeString(params, "algoType")
            var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activatedPrice", this.NumberToString(price))
            var trailingAmount interface{} = this.SafeString2(params, "trailingAmount", "callbackValue")
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRate")
            var isTrailingAmountOrder interface{} = !IsEqual(trailingAmount, nil)
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            var isTrailing interface{} = IsTrue(isTrailingAmountOrder) || IsTrue(isTrailingPercentOrder)
            var isConditional interface{} = IsTrue(IsTrue(IsTrue(IsTrue(isTrailing) || IsTrue(!IsEqual(triggerPrice, nil))) || IsTrue(!IsEqual(stopLoss, nil))) || IsTrue(!IsEqual(takeProfit, nil))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var isMarket interface{} = IsEqual(orderType, "MARKET")
            var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
            var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
            var clientOrderIdKey interface{} = Ternary(IsTrue(isConditional), "clientAlgoOrderId", "clientOrderId")
            AddElementToObject(request, "type", orderType) // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
            if !IsTrue(isConditional) {
                if IsTrue(postOnly) {
                    AddElementToObject(request, "type", "POST_ONLY")
                } else if IsTrue(IsEqual(timeInForce, "fok")) {
                    AddElementToObject(request, "type", "FOK")
                } else if IsTrue(IsEqual(timeInForce, "ioc")) {
                    AddElementToObject(request, "type", "IOC")
                }
            }
            if IsTrue(reduceOnly) {
                AddElementToObject(request, "reduceOnly", reduceOnly)
            }
            if IsTrue(!IsTrue(isMarket) && IsTrue(!IsEqual(price, nil))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(IsTrue(isMarket) && !IsTrue(isConditional)) {
                // for market buy it requires the amount of quote currency to spend
                var cost interface{} = this.SafeStringN(params, []interface{}{"cost", "order_amount", "orderAmount"})
                params = this.Omit(params, []interface{}{"cost", "order_amount", "orderAmount"})
                var isPriceProvided interface{} = !IsEqual(price, nil)
                if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue((IsTrue(isPriceProvided) || IsTrue((!IsEqual(cost, nil)))))) {
                    var quoteAmount interface{} = nil
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else {
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var costRequest interface{} = Precise.StringMul(amountString, priceString)
                        quoteAmount = this.CostToPrecision(symbol, costRequest)
                    }
                    AddElementToObject(request, "amount", quoteAmount)
                } else {
                    AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
                }
            } else if IsTrue(!IsEqual(algoType, "POSITIONAL_TP_SL")) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, clientOrderIdKey, clientOrderId)
            }
            if IsTrue(isTrailing) {
                if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a trailingTriggerPrice parameter for trailing orders")))
                }
                AddElementToObject(request, "activatedPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
                AddElementToObject(request, "algoType", "TRAILING_STOP")
                if IsTrue(isTrailingAmountOrder) {
                    AddElementToObject(request, "callbackValue", trailingAmount)
                } else if IsTrue(isTrailingPercentOrder) {
                    var convertedTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
                    AddElementToObject(request, "callbackRate", convertedTrailingPercent)
                }
            } else if IsTrue(!IsEqual(triggerPrice, nil)) {
                if IsTrue(!IsEqual(algoType, "TRAILING_STOP")) {
                    AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                    AddElementToObject(request, "algoType", "STOP")
                }
            } else if IsTrue(IsTrue((!IsEqual(stopLoss, nil))) || IsTrue((!IsEqual(takeProfit, nil)))) {
                AddElementToObject(request, "algoType", "BRACKET")
                var outterOrder interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                    "reduceOnly": false,
                    "algoType": "POSITIONAL_TP_SL",
                    "childOrders": []interface{}{},
                }
                var childOrders interface{} = GetValue(outterOrder, "childOrders")
                var closeSide interface{} = Ternary(IsTrue((IsEqual(orderSide, "BUY"))), "SELL", "BUY")
                if IsTrue(!IsEqual(stopLoss, nil)) {
                    var stopLossPrice interface{} = this.SafeString(stopLoss, "triggerPrice", stopLoss)
                    var stopLossOrder interface{} = map[string]interface{} {
                        "side": closeSide,
                        "algoType": "STOP_LOSS",
                        "triggerPrice": this.PriceToPrecision(symbol, stopLossPrice),
                        "type": "CLOSE_POSITION",
                        "reduceOnly": true,
                    }
                    AppendToArray(&childOrders, stopLossOrder)
                }
                if IsTrue(!IsEqual(takeProfit, nil)) {
                    var takeProfitPrice interface{} = this.SafeString(takeProfit, "triggerPrice", takeProfit)
                    var takeProfitOrder interface{} = map[string]interface{} {
                        "side": closeSide,
                        "algoType": "TAKE_PROFIT",
                        "triggerPrice": this.PriceToPrecision(symbol, takeProfitPrice),
                        "type": "CLOSE_POSITION",
                        "reduceOnly": true,
                    }
                    AppendToArray(&childOrders, takeProfitOrder)
                }
                AddElementToObject(request, "childOrders", []interface{}{outterOrder})
            }
            params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "trailingPercent", "trailingAmount", "trailingTriggerPrice"})
            var response interface{} = nil
            if IsTrue(isConditional) {
                
            response = (<-this.V3PrivatePostTradeAlgoOrder(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.V3PrivatePostTradeOrder(this.Extend(request, params)))
                    PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            data = this.SafeDict(this.SafeList(data, "rows"), 0, data)
            AddElementToObject(data, "timestamp", this.SafeString(response, "timestamp"))
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *woo) EncodeMarginMode(mode interface{}) interface{}  {
    var modes interface{} = map[string]interface{} {
        "cross": "CROSS",
        "isolated": "ISOLATED",
    }
    return this.SafeString(modes, mode, mode)
}
/**
 * @method
 * @name woo#editOrder
 * @description edit a trade order
 * @see https://docs.woox.io/#edit-order
 * @see https://docs.woox.io/#edit-order-by-client_order_id
 * @see https://docs.woox.io/#edit-algo-order
 * @see https://docs.woox.io/#edit-algo-order-by-client_order_id
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
 * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
 * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
 * @param {string} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14138 := (<-this.LoadMarkets())
            PanicOnError(retRes14138)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            var clientOrderIdUnified interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "client_order_id", clientOrderIdUnified)
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activatedPrice", this.NumberToString(price))
            var trailingAmount interface{} = this.SafeString2(params, "trailingAmount", "callbackValue")
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRate")
            var isTrailingAmountOrder interface{} = !IsEqual(trailingAmount, nil)
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            var isTrailing interface{} = IsTrue(isTrailingAmountOrder) || IsTrue(isTrailingPercentOrder)
            if IsTrue(isTrailing) {
                if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
                    AddElementToObject(request, "activatedPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
                }
                if IsTrue(isTrailingAmountOrder) {
                    AddElementToObject(request, "callbackValue", trailingAmount)
                } else if IsTrue(isTrailingPercentOrder) {
                    var convertedTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
                    AddElementToObject(request, "callbackRate", convertedTrailingPercent)
                }
            }
            params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id", "stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"})
            var isConditional interface{} = IsTrue(IsTrue(isTrailing) || IsTrue((!IsEqual(triggerPrice, nil)))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var response interface{} = nil
            if IsTrue(isByClientOrder) {
                AddElementToObject(request, "client_order_id", clientOrderIdExchangeSpecific)
                if IsTrue(isConditional) {
                    
            response = (<-this.V3PrivatePutAlgoOrderClientClientOrderId(this.Extend(request, params)))
                        PanicOnError(response)
                } else {
                    
            response = (<-this.V3PrivatePutOrderClientClientOrderId(this.Extend(request, params)))
                        PanicOnError(response)
                }
            } else {
                AddElementToObject(request, "oid", id)
                if IsTrue(isConditional) {
                    
            response = (<-this.V3PrivatePutAlgoOrderOid(this.Extend(request, params)))
                        PanicOnError(response)
                } else {
                    
            response = (<-this.V3PrivatePutOrderOid(this.Extend(request, params)))
                        PanicOnError(response)
                }
            }
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "status": "string",
            //             "success": true
            //         },
            //         "message": "string",
            //         "success": true,
            //         "timestamp": 0
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelOrder
 * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_order
 * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_algo_order
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            if IsTrue(!IsTrue(isTrigger) && IsTrue((IsEqual(symbol, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes15018 := (<-this.LoadMarkets())
            PanicOnError(retRes15018)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var clientOrderIdUnified interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "client_order_id", clientOrderIdUnified)
            params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var response interface{} = nil
            if IsTrue(isTrigger) {
                if IsTrue(isByClientOrder) {
                    AddElementToObject(request, "clientAlgoOrderId", clientOrderIdExchangeSpecific)
                } else {
                    AddElementToObject(request, "algoOrderId", id)
                }
                
            response = (<-this.V3PrivateDeleteTradeAlgoOrder(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                if IsTrue(isByClientOrder) {
                    AddElementToObject(request, "clientOrderId", clientOrderIdExchangeSpecific)
                } else {
                    AddElementToObject(request, "orderId", id)
                }
                
            response = (<-this.V3PrivateDeleteTradeOrder(this.Extend(request, params)))
                    PanicOnError(response)
            }
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": "CANCEL_SENT"
            //         },
            //         "timestamp": 1751940315838
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            AddElementToObject(data, "timestamp", this.SafeString(response, "timestamp"))
            if IsTrue(isByClientOrder) {
                AddElementToObject(data, "clientOrderId", clientOrderIdExchangeSpecific)
            } else {
                AddElementToObject(data, "orderId", id)
            }
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelAllOrders
 * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_all_order
 * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_algo_orders
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15598 := (<-this.LoadMarkets())
            PanicOnError(retRes15598)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(trigger) {
                
            response = (<-this.V3PrivateDeleteTradeAlgoOrders(params))
                    PanicOnError(response)
            } else {
                
            response = (<-this.V3PrivateDeleteTradeOrders(this.Extend(request, params)))
                    PanicOnError(response)
            }
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": "CANCEL_ALL_SENT"
            //         },
            //         "timestamp": 1751941988134
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": data,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://developer.woox.io/api-reference/endpoint/trading/cancel_all_after
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the api result
 */
func  (this *woo) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15968 := (<-this.LoadMarkets())
            PanicOnError(retRes15968)
            var request interface{} = map[string]interface{} {
                "triggerAfter": Ternary(IsTrue((IsGreaterThan(timeout, 0))), mathMin(timeout, 900000), 0),
            }
        
            response:= (<-this.V3PrivatePostTradeCancelAllAfter(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "success": true,
            //     "timestamp": 123,
            //     "data": {
            //         "expectedTriggerTime": 123
            //     }
            // }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOrder
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_order
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_order
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16268 := (<-this.LoadMarkets())
            PanicOnError(retRes16268)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var response interface{} = nil
            if IsTrue(trigger) {
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "clientAlgoOrderId", id)
                } else {
                    AddElementToObject(request, "algoOrderId", id)
                }
                
            response = (<-this.V3PrivateGetTradeAlgoOrder(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    AddElementToObject(request, "clientOrderId", clientOrderId)
                } else {
                    AddElementToObject(request, "orderId", id)
                }
                
            response = (<-this.V3PrivateGetTradeOrder(this.Extend(request, params)))
                    PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17398 := (<-this.LoadMarkets())
            PanicOnError(retRes17398)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes174319 :=  (<-this.FetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes174319)
                    ch <- retRes174319
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 500))
            }
            var response interface{} = nil
            if IsTrue(trigger) {
                
            response = (<-this.V3PrivateGetTradeAlgoOrders(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.V3PrivateGetTradeOrders(this.Extend(request, params)))
                    PanicOnError(response)
            }
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18788 := (<-this.LoadMarkets())
            PanicOnError(retRes18788)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "INCOMPLETE",
            })
        
                retRes188015 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes188015)
                ch <- retRes188015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchClosedOrders
 * @description fetches information on multiple orders made by the user
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_orders
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_algo_orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19018 := (<-this.LoadMarkets())
            PanicOnError(retRes19018)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "COMPLETED",
            })
        
                retRes190315 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes190315)
                ch <- retRes190315
                return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "ioc": "IOC",
        "fok": "FOK",
        "post_only": "PO",
    }
    return this.SafeString(timeInForces, timeInForce, nil)
}
func  (this *woo) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //     {
    //         "orderId": 60667653330,
    //         "clientOrderId": 0,
    //         "type": "LIMIT",
    //         "price": 60,
    //         "quantity": 0.1,
    //         "amount": null,
    //         "bidAskLevel": null,
    //         "timestamp": 1751871779855
    //     }
    //
    // createOrder - algo
    //     {
    //         "orderId": "1578938",
    //         "clientOrderId": "0",
    //         "algoType": "STOP_LOSS",
    //         "quantity": "0.1",
    //         "timestamp": "1686149372216"
    //     }
    //
    // fetchOrder
    //     {
    //         "orderId": 60780315704,
    //         "clientOrderId": 0,
    //         "symbol": "SPOT_LTC_USDT",
    //         "orderTag": "default",
    //         "side": "BUY",
    //         "quantity": 0.1,
    //         "amount": null,
    //         "type": "LIMIT",
    //         "status": "NEW",
    //         "price": 60,
    //         "executed": 0,
    //         "visible": 0.1,
    //         "averageExecutedPrice": 0,
    //         "totalFee": 0,
    //         "feeAsset": "LTC",
    //         "totalRebate": 0,
    //         "rebateAsset": "USDT",
    //         "reduceOnly": false,
    //         "createdTime": "1752049062.496",
    //         "realizedPnl": null,
    //         "positionSide": "BOTH",
    //         "bidAskLevel": null
    //     }
    //
    // fetchOrder - algo
    //     {
    //         "algoOrderId": 10399260,
    //         "clientAlgoOrderId": 0,
    //         "rootAlgoOrderId": 10399260,
    //         "parentAlgoOrderId": 0,
    //         "symbol": "SPOT_LTC_USDT",
    //         "algoOrderTag": "default",
    //         "algoType": "TAKE_PROFIT",
    //         "side": "BUY",
    //         "quantity": 0.1,
    //         "isTriggered": false,
    //         "triggerPrice": 65,
    //         "triggerStatus": "USELESS",
    //         "type": "LIMIT",
    //         "rootAlgoStatus": "NEW",
    //         "algoStatus": "NEW",
    //         "triggerPriceType": "MARKET_PRICE",
    //         "price": 60,
    //         "triggerTime": "0",
    //         "totalExecutedQuantity": 0,
    //         "visibleQuantity": 0.1,
    //         "averageExecutedPrice": 0,
    //         "totalFee": 0,
    //         "feeAsset": "",
    //         "totalRebate": 0,
    //         "rebateAsset": "",
    //         "reduceOnly": false,
    //         "createdTime": "1752049747.732",
    //         "updatedTime": "1752049747.732",
    //         "positionSide": "BOTH"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp(order, "createdTime")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.SafeInteger(order, "timestamp")
    }
    var orderId interface{} = this.SafeString2(order, "orderId", "algoOrderId")
    var clientOrderId interface{} = this.OmitZero(this.SafeString2(order, "clientOrderId", "clientAlgoOrderId")) // Somehow, this always returns 0 for limit order
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "quantity") // This is base amount
    var cost interface{} = this.SafeString(order, "amount") // This is quote amount
    var orderType interface{} = this.SafeStringLower(order, "type")
    var status interface{} = this.SafeValue2(order, "status", "algoStatus")
    var side interface{} = this.SafeStringLower(order, "side")
    var filled interface{} = this.OmitZero(this.SafeValue2(order, "executed", "totalExecutedQuantity"))
    var average interface{} = this.OmitZero(this.SafeString(order, "averageExecutedPrice"))
    // const remaining = Precise.stringSub (cost, filled);
    var fee interface{} = this.SafeNumber(order, "totalFee")
    var feeCurrency interface{} = this.SafeString(order, "feeAsset")
    var triggerPrice interface{} = this.SafeNumber(order, "triggerPrice")
    var lastUpdateTimestamp interface{} = this.SafeTimestamp(order, "updatedTime")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": orderType,
        "timeInForce": this.ParseTimeInForce(orderType),
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "reduceOnly"),
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": cost,
        "trades": nil,
        "fee": map[string]interface{} {
            "cost": fee,
            "currency": feeCurrency,
        },
        "info": order,
    }, market)
}
func  (this *woo) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "NEW": "open",
            "FILLED": "closed",
            "CANCEL_SENT": "canceled",
            "CANCEL_ALL_SENT": "canceled",
            "CANCELLED": "canceled",
            "PARTIAL_FILLED": "open",
            "REJECTED": "rejected",
            "INCOMPLETE": "open",
            "COMPLETED": "closed",
        }
        return this.SafeString(statuses, status, status)
    }
    return status
}
/**
 * @method
 * @name woo#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developer.woox.io/api-reference/endpoint/public_data/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *woo) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20808 := (<-this.LoadMarkets())
            PanicOnError(retRes20808)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "maxLevel", limit)
            }
        
            response:= (<-this.V3PublicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            // }
            //     {
            //         "success": true,
            //         "timestamp": 1751620923344,
            //         "data": {
            //             "asks": [
            //                 {
            //                     "price": "108924.86",
            //                     "quantity": "0.032126"
            //                 }
            //             ],
            //             "bids": [
            //                 {
            //                     "price": "108924.85",
            //                     "quantity": "1.714147"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "quantity")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOHLCV
 * @see https://developer.woox.io/api-reference/endpoint/public_data/klineHistory
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *woo) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21298 := (<-this.LoadMarkets())
            PanicOnError(retRes21298)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "before", until)
            }
        
            response:= (<-this.V3PublicGetKlineHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "SPOT_BTC_USDT",
            //                     "open": "108994.16",
            //                     "close": "108994.16",
            //                     "high": "108994.16",
            //                     "low": "108994.16",
            //                     "volume": "0",
            //                     "amount": "0",
            //                     "type": "1m",
            //                     "startTimestamp": 1751622120000,
            //                     "endTimestamp": 1751622180000
            //                 }
            //             ]
            //         },
            //         "timestamp": 1751622205410
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseOHLCVs(rows, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "startTimestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name woo#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.woox.io/#get-trades
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woo) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21988 := (<-this.LoadMarkets())
            PanicOnError(retRes21988)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "oid": id,
            }
        
            response:= (<-this.V1PrivateGetOrderOidTrades(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "success": true,
            //     "rows": [
            //       {
            //         "id": "99111647",
            //         "symbol": "SPOT_WOO_USDT",
            //         "fee": "0.0024",
            //         "side": "BUY",
            //         "executed_timestamp": "1641482113.084",
            //         "order_id": "87541111",
            //         "order_tag": "default",
            //         "executed_price": "1",
            //         "executed_quantity": "12",
            //         "fee_asset": "WOO",
            //         "is_maker": "1"
            //       }
            //     ]
            // }
            var trades interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://developer.woox.io/api-reference/endpoint/trading/get_transactions
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woo) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22428 := (<-this.LoadMarkets())
            PanicOnError(retRes22428)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes224619 :=  (<-this.FetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes224619)
                    ch <- retRes224619
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V3PrivateGetTradeTransactionHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "id": 1734947821,
            //                     "symbol": "SPOT_LTC_USDT",
            //                     "orderId": 60780383217,
            //                     "executedPrice": 87.86,
            //                     "executedQuantity": 0.1,
            //                     "fee": 0.0001,
            //                     "realizedPnl": null,
            //                     "feeAsset": "LTC",
            //                     "orderTag": "default",
            //                     "side": "BUY",
            //                     "executedTimestamp": "1752055173.630",
            //                     "isMaker": 0
            //                 }
            //             ],
            //             "meta": {
            //                 "total": 1,
            //                 "recordsPerPage": 100,
            //                 "currentPage": 1
            //             }
            //         },
            //         "timestamp": 1752055545121
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
 * @see https://developer.woox.io/api-reference/endpoint/account/sub_accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *woo) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var mainAccountPromise interface{} = this.V3PrivateGetAccountInfo(params)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
            //             "account": "carlos_jose_lima@yahoo.com",
            //             "alias": "carlos_jose_lima@yahoo.com",
            //             "otpauth": true,
            //             "accountMode": "FUTURES",
            //             "positionMode": "ONE_WAY",
            //             "leverage": 0,
            //             "marginRatio": "10",
            //             "openMarginRatio": "10",
            //             "initialMarginRatio": "10",
            //             "maintenanceMarginRatio": "0.03",
            //             "totalCollateral": "165.55629469",
            //             "freeCollateral": "165.55629469",
            //             "totalAccountValue": "167.32418611",
            //             "totalTradingValue": "167.32418611",
            //             "totalVaultValue": "0",
            //             "totalStakingValue": "0",
            //             "totalLaunchpadValue": "0",
            //             "totalEarnValue": "0",
            //             "referrerID": null,
            //             "accountType": "Main"
            //         },
            //         "timestamp": 1752062807915
            //     }
            //
            var subAccountPromise interface{} = this.V3PrivateGetAccountSubAccountsAll(params)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "applicationId": "6b43de5c-0955-4887-9862-d84e4689f9fe",
            //                     "name": "sub_account_2",
            //                     "createdTime": "1606897264.994"
            //                 },
            //             ]
            //         },
            //         "timestamp": 1721295317627
            //     }
            //
            mainAccountResponsesubAccountResponseVariable := (<-promiseAll([]interface{}{mainAccountPromise, subAccountPromise}));
            mainAccountResponse := GetValue(mainAccountResponsesubAccountResponseVariable,0);
            subAccountResponse := GetValue(mainAccountResponsesubAccountResponseVariable,1)
            var mainData interface{} = this.SafeDict(mainAccountResponse, "data", map[string]interface{} {})
            var mainRows interface{} = []interface{}{mainData}
            var subData interface{} = this.SafeDict(subAccountResponse, "data", map[string]interface{} {})
            var subRows interface{} = this.SafeList(subData, "rows", []interface{}{})
            var rows interface{} = this.ArrayConcat(mainRows, subRows)
        
            ch <- this.ParseAccounts(rows, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseAccount(account interface{}) interface{}  {
    //
    //     {
    //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
    //         "account": "carlos_jose_lima@yahoo.com",
    //         "alias": "carlos_jose_lima@yahoo.com",
    //         "otpauth": true,
    //         "accountMode": "FUTURES",
    //         "positionMode": "ONE_WAY",
    //         "leverage": 0,
    //         "marginRatio": "10",
    //         "openMarginRatio": "10",
    //         "initialMarginRatio": "10",
    //         "maintenanceMarginRatio": "0.03",
    //         "totalCollateral": "165.55629469",
    //         "freeCollateral": "165.55629469",
    //         "totalAccountValue": "167.32418611",
    //         "totalTradingValue": "167.32418611",
    //         "totalVaultValue": "0",
    //         "totalStakingValue": "0",
    //         "totalLaunchpadValue": "0",
    //         "totalEarnValue": "0",
    //         "referrerID": null,
    //         "accountType": "Main"
    //     }
    //
    //     {
    //         "applicationId": "6b43de5c-0955-4887-9862-d84e4689f9fe",
    //         "name": "sub_account_2",
    //         "createdTime": "1606897264.994"
    //     }
    //
    return map[string]interface{} {
        "info": account,
        "id": this.SafeString(account, "applicationId"),
        "name": this.SafeStringN(account, []interface{}{"name", "account", "alias"}),
        "code": nil,
        "type": this.SafeStringLower(account, "accountType", "subaccount"),
    }
}
/**
 * @method
 * @name woo#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.woox.io/#get-current-holding-get-balance-new
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *woo) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24158 := (<-this.LoadMarkets())
            PanicOnError(retRes24158)
        
            response:= (<-this.V3PrivateGetBalances(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "holding": [
            //                 {
            //                     "token": "0_token",
            //                     "holding": 1,
            //                     "frozen": 0,
            //                     "staked": 0,
            //                     "unbonding": 0,
            //                     "vault": 0,
            //                     "interest": 0,
            //                     "pendingShortQty": 0,
            //                     "pendingLongQty": 0,
            //                     "availableBalance": 0,
            //                     "updatedTime": 312321.121
            //                 }
            //             ]
            //         },
            //         "timestamp": 1673323746259
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeList(response, "holding", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "token"))
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "holding"))
        AddElementToObject(account, "free", this.SafeString(balance, "availableBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name woo#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_deposit
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *woo) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is TODO because of networks unification
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24718 := (<-this.LoadMarkets())
            PanicOnError(retRes24718)
            var currency interface{} = this.Currency(code)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "token": GetValue(currency, "id"),
                "network": this.NetworkCodeToId(networkCode),
            }
        
            response:= (<-this.V3PrivateGetAssetWalletDeposit(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "address": "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
            //             "extra": ""
            //         },
            //         "timestamp": 1721300689532
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *woo) GetDedicatedNetworkId(currency interface{}, params interface{}) interface{}  {
    var networkCode interface{} = nil
    networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
    networkCode = GetValue(networkCodeparamsVariable,0);
    params = GetValue(networkCodeparamsVariable,1)
    networkCode = this.NetworkIdToCode(networkCode, GetValue(currency, "code"))
    var networkEntry interface{} = this.SafeDict(GetValue(currency, "networks"), networkCode)
    if IsTrue(IsEqual(networkEntry, nil)) {
        var supportedNetworks interface{} = ObjectKeys(GetValue(currency, "networks"))
        panic(BadRequest(Add(Add(this.Id, "  can not determine a network code, please provide unified \"network\" param, one from the following: "), this.Json(supportedNetworks))))
    }
    var currentyNetworkId interface{} = this.SafeString(networkEntry, "currencyNetworkId")
    return []interface{}{currentyNetworkId, params}
}
func  (this *woo) ParseDepositAddress(depositEntry interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositEntry, "address")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositEntry,
        "currency": this.SafeString(currency, "code"),
        "network": nil,
        "address": address,
        "tag": this.SafeString(depositEntry, "extra"),
    }
}
func  (this *woo) GetAssetHistoryRows(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes25208 := (<-this.LoadMarkets())
            PanicOnError(retRes25208)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "token", GetValue(currency, "id"))
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "network", this.NetworkCodeToId(networkCode))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 1000))
            }
            var transactionType interface{} = this.SafeString(params, "type")
            params = this.Omit(params, "type")
            if IsTrue(!IsEqual(transactionType, nil)) {
                AddElementToObject(request, "type", transactionType)
            }
        
            response:= (<-this.V3PrivateGetAssetWalletHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "createdTime": "1734964440.523",
            //                     "updatedTime": "1734964614.081",
            //                     "id": "24122314340000585",
            //                     "externalId": "241223143600621",
            //                     "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
            //                     "token": "ARB_USDCNATIVE",
            //                     "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
            //                     "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
            //                     "extra": "",
            //                     "type": "BALANCE",
            //                     "tokenSide": "WITHDRAW",
            //                     "amount": "10.00000000",
            //                     "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
            //                     "feeToken": "USDC",
            //                     "feeAmount": "2",
            //                     "status": "COMPLETED",
            //                     "confirmingThreshold": null,
            //                     "confirmedNumber": null
            //                 }
            //             ],
            //             "meta": {
            //                 "total": 1,
            //                 "records_per_page": 25,
            //                 "current_page": 1
            //             }
            //         },
            //         "timestamp": 1752485344719
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- []interface{}{currency, this.SafeList(data, "rows", []interface{}{})}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *woo) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, params))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
            ch <- this.ParseLedger(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "createdTime": "1734964440.523",
    //         "updatedTime": "1734964614.081",
    //         "id": "24122314340000585",
    //         "externalId": "241223143600621",
    //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
    //         "token": "ARB_USDCNATIVE",
    //         "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
    //         "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
    //         "extra": "",
    //         "type": "BALANCE",
    //         "tokenSide": "WITHDRAW",
    //         "amount": "10.00000000",
    //         "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
    //         "feeToken": "USDC",
    //         "feeAmount": "2",
    //         "status": "COMPLETED",
    //         "confirmingThreshold": null,
    //         "confirmedNumber": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkizedCode interface{} = this.SafeString(item, "token")
    var code interface{} = this.SafeCurrencyCode(networkizedCode, currency)
    currency = this.SafeCurrency(code, currency)
    var amount interface{} = this.SafeNumber(item, "amount")
    var side interface{} = this.SafeString(item, "tokenSide")
    var direction interface{} = Ternary(IsTrue((IsEqual(side, "DEPOSIT"))), "in", "out")
    var timestamp interface{} = this.SafeTimestamp(item, "createdTime")
    var fee interface{} = this.ParseTokenAndFeeTemp(item, []interface{}{"feeToken"}, []interface{}{"feeAmount"})
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "id"),
        "currency": code,
        "account": this.SafeString(item, "account"),
        "referenceAccount": nil,
        "referenceId": this.SafeString(item, "txId"),
        "status": this.ParseTransactionStatus(this.SafeString(item, "status")),
        "amount": amount,
        "before": nil,
        "after": nil,
        "direction": direction,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "fee": fee,
    }, currency)
}
func  (this *woo) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "BALANCE": "transaction",
        "COLLATERAL": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *woo) GetCurrencyFromChaincode(networkizedCode interface{}, currency interface{}) interface{}  {
    if IsTrue(!IsEqual(currency, nil)) {
        return currency
    } else {
        var parts interface{} = Split(networkizedCode, "_")
        var partsLength interface{} =         GetArrayLength(parts)
        var firstPart interface{} = this.SafeString(parts, 0)
        var currencyId interface{} = this.SafeString(parts, 1, firstPart)
        if IsTrue(IsGreaterThan(partsLength, 2)) {
            currencyId = Add(currencyId, Add("_", this.SafeString(parts, 2)))
        }
        currency = this.SafeCurrency(currencyId)
    }
    return currency
}
/**
 * @method
 * @name woo#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "tokenSide": "DEPOSIT",
            }
        
                retRes269015 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes269015)
                ch <- retRes269015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "tokenSide": "WITHDRAW",
            }
        
                retRes270815 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes270815)
                ch <- retRes270815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_wallet_history
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "BALANCE",
            }
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, this.Extend(request, params)))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
            ch <- this.ParseTransactions(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "createdTime": "1734964440.523",
    //         "updatedTime": "1734964614.081",
    //         "id": "24122314340000585",
    //         "externalId": "241223143600621",
    //         "applicationId": "251bf5c4-f3c8-4544-bb8b-80001007c3c0",
    //         "token": "ARB_USDCNATIVE",
    //         "targetAddress": "0x4d6802d2736daa85e6242ef0dc0f00aa0e68f635",
    //         "sourceAddress": "0x63DFE4e34A3bFC00eB0220786238a7C6cEF8Ffc4",
    //         "extra": "",
    //         "type": "BALANCE",
    //         "tokenSide": "WITHDRAW",
    //         "amount": "10.00000000",
    //         "txId": "0x891ade0a47fd55466bb9d06702bea4edcb75ed9367d9afbc47b93a84f496d2e6",
    //         "feeToken": "USDC",
    //         "feeAmount": "2",
    //         "status": "COMPLETED",
    //         "confirmingThreshold": null,
    //         "confirmedNumber": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkizedCode interface{} = this.SafeString(transaction, "token")
    var currencyDefined interface{} = this.GetCurrencyFromChaincode(networkizedCode, currency)
    var code interface{} = GetValue(currencyDefined, "code")
    var movementDirection interface{} = this.SafeStringLower2(transaction, "token_side", "tokenSide")
    if IsTrue(IsEqual(movementDirection, "withdraw")) {
        movementDirection = "withdrawal"
    }
    var fee interface{} = this.ParseTokenAndFeeTemp(transaction, []interface{}{"fee_token", "feeToken"}, []interface{}{"fee_amount", "feeAmount"})
    var addressTo interface{} = this.SafeString2(transaction, "target_address", "targetAddress")
    var addressFrom interface{} = this.SafeString2(transaction, "source_address", "sourceAddress")
    var timestamp interface{} = this.SafeTimestamp2(transaction, "created_time", "createdTime")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeStringN(transaction, []interface{}{"id", "withdraw_id", "withdrawId"}),
        "txid": this.SafeString2(transaction, "tx_id", "txId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "tag": this.SafeString(transaction, "extra"),
        "tagFrom": nil,
        "tagTo": nil,
        "type": movementDirection,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": this.SafeTimestamp2(transaction, "updated_time", "updatedTime"),
        "comment": nil,
        "internal": nil,
        "fee": fee,
        "network": nil,
    }
}
func  (this *woo) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "pending",
        "CONFIRMING": "pending",
        "PROCESSING": "pending",
        "COMPLETED": "ok",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name woo#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://docs.woox.io/#get-transfer-history
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *woo) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28148 := (<-this.LoadMarkets())
            PanicOnError(retRes28148)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "token": GetValue(currency, "id"),
                "amount": this.ParseToNumeric(amount),
                "from_application_id": fromAccount,
                "to_application_id": toAccount,
            }
        
            response:= (<-this.V1PrivatePostAssetMainSubTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "id": 200
            //     }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
            var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "amount", amount)
                AddElementToObject(transfer, "fromAccount", fromAccount)
                AddElementToObject(transfer, "toAccount", toAccount)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://developer.woox.io/api-reference/endpoint/assets/get_transfer_history
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *woo) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.V3PrivateGetAssetTransferHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "id": 225,
            //                     "token": "USDT",
            //                     "amount": "1000000",
            //                     "status": "COMPLETED",
            //                     "from": {
            //                         "applicationId": "046b5c5c-5b44-4d27-9593-ddc32c0a08ae",
            //                         "accountName": "Main"
            //                     },
            //                     "to": {
            //                         "applicationId": "082ae5ae-e26a-4fb1-be5b-03e5b4867663",
            //                         "accountName": "sub001"
            //                     },
            //                     "createdTime": "1642660941.534",
            //                     "updatedTime": "1642660941.950"
            //                 }
            //             ],
            //             "meta": {
            //                 "total": 46,
            //                 "recordsPerPage": 1,
            //                 "currentPage": 1
            //             }
            //         },
            //         "timestamp": 1721295317627
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseTransfers(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    fetchTransfers
    //     {
    //         "id": 46704,
    //         "token": "USDT",
    //         "amount": 30000.00000000,
    //         "status": "COMPLETED",
    //         "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
    //         "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
    //         "from_user": "LeverageLow",
    //         "to_user": "dev",
    //         "created_time": "1709022325.427",
    //         "updated_time": "1709022325.542"
    //     }
    //     {
    //         "id": 225,
    //         "token": "USDT",
    //         "amount": "1000000",
    //         "status": "COMPLETED",
    //         "from": {
    //             "applicationId": "046b5c5c-5b44-4d27-9593-ddc32c0a08ae",
    //             "accountName": "Main"
    //         },
    //         "to": {
    //             "applicationId": "082ae5ae-e26a-4fb1-be5b-03e5b4867663",
    //             "accountName": "sub001"
    //         },
    //         "createdTime": "1642660941.534",
    //         "updatedTime": "1642660941.950"
    //     }
    //
    //    transfer
    //        {
    //            "success": true,
    //            "id": 200
    //        }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var code interface{} = this.SafeCurrencyCode(this.SafeString(transfer, "token"), currency)
    var timestamp interface{} = this.SafeTimestamp(transfer, "createdTime")
    var success interface{} = this.SafeBool(transfer, "success")
    var status interface{} = nil
    if IsTrue(!IsEqual(success, nil)) {
        status = Ternary(IsTrue(success), "ok", "failed")
    }
    var fromAccount interface{} = this.SafeDict(transfer, "from", map[string]interface{} {})
    var toAccount interface{} = this.SafeDict(transfer, "to", map[string]interface{} {})
    return map[string]interface{} {
        "id": this.SafeString(transfer, "id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": code,
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.SafeString(fromAccount, "applicationId"),
        "toAccount": this.SafeString(toAccount, "applicationId"),
        "status": this.ParseTransferStatus(this.SafeString(transfer, "status", status)),
        "info": transfer,
    }
}
func  (this *woo) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "pending",
        "CONFIRMING": "pending",
        "PROCESSING": "pending",
        "COMPLETED": "ok",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name woo#withdraw
 * @description make a withdrawal
 * @see https://docs.woox.io/#token-withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes29918 := (<-this.LoadMarkets())
            PanicOnError(retRes29918)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "extra", tag)
            }
            var specialNetworkId interface{} = nil
            specialNetworkIdparamsVariable := this.GetDedicatedNetworkId(currency, params);
            specialNetworkId = GetValue(specialNetworkIdparamsVariable,0);
            params = GetValue(specialNetworkIdparamsVariable,1)
            AddElementToObject(request, "token", specialNetworkId)
        
            response:= (<-this.V1PrivatePostAssetWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "withdraw_id": "20200119145703654"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#repayMargin
 * @description repay borrowed margin and interest
 * @see https://docs.woox.io/#repay-interest
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {string} symbol not used by woo.repayMargin ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *woo) RepayMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30268 := (<-this.LoadMarkets())
            PanicOnError(retRes30268)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = GetValue(market, "symbol")
            }
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "token": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.V1PrivatePostInterestRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //     }
            //
            var transaction interface{} = this.ParseMarginLoan(response, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "success": true,
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "id": nil,
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "symbol": nil,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
func  (this *woo) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *woo) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    section := GetArg(optionalArgs, 0, "public")
    _ = section
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(section, 0)
    var access interface{} = GetValue(section, 1)
    var pathWithParams interface{} = this.ImplodeParams(path, params)
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), access))
    url = Add(url, Add(Add("/", version), "/"))
    params = this.Omit(params, this.ExtractParams(path))
    params = this.Keysort(params)
    if IsTrue(IsEqual(access, "public")) {
        url = Add(url, Add(Add(access, "/"), pathWithParams))
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else if IsTrue(IsEqual(access, "pub")) {
        url = Add(url, pathWithParams)
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        if IsTrue(IsTrue(IsEqual(method, "POST")) && IsTrue((IsTrue(IsEqual(path, "trade/algoOrder")) || IsTrue(IsEqual(path, "trade/order"))))) {
            var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            if !IsTrue(isSandboxMode) {
                var applicationId interface{} = "bc830de7-50f3-460b-9ee0-f430f83f9dad"
                var brokerId interface{} = this.SafeString(this.Options, "brokerId", applicationId)
                var isTrigger interface{} = IsGreaterThan(GetIndexOf(path, "algo"), OpNeg(1))
                if IsTrue(isTrigger) {
                    AddElementToObject(params, "brokerId", brokerId)
                } else {
                    AddElementToObject(params, "broker_id", brokerId)
                }
            }
            params = this.Keysort(params)
        }
        var auth interface{} = ""
        var ts interface{} = ToString(this.Nonce())
        url = Add(url, pathWithParams)
        headers = map[string]interface{} {
            "x-api-key": this.ApiKey,
            "x-api-timestamp": ts,
        }
        if IsTrue(IsEqual(version, "v3")) {
            auth = Add(Add(Add(Add(Add(ts, method), "/"), version), "/"), pathWithParams)
            if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) {
                body = this.Json(params)
                auth = Add(auth, body)
                AddElementToObject(headers, "content-type", "application/json")
            } else {
                if IsTrue(GetArrayLength(ObjectKeys(params))) {
                    var query interface{} = this.Urlencode(params)
                    url = Add(url, Add("?", query))
                    auth = Add(auth, Add("?", query))
                }
            }
        } else {
            auth = this.Urlencode(params)
            if IsTrue(IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) || IsTrue(IsEqual(method, "DELETE"))) {
                body = auth
            } else {
                if IsTrue(GetArrayLength(ObjectKeys(params))) {
                    url = Add(url, Add("?", auth))
                }
            }
            auth = Add(auth, Add("|", ts))
            AddElementToObject(headers, "content-type", "application/x-www-form-urlencoded")
        }
        AddElementToObject(headers, "x-api-signature", this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *woo) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
    //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
    //
    var success interface{} = this.SafeBool(response, "success")
    var errorCode interface{} = this.SafeString(response, "code")
    if !IsTrue(success) {
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    }
    return nil
}
func  (this *woo) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": 1286360,
    //         "symbol": "PERP_BTC_USDT",
    //         "fundingRate": -0.00001445,
    //         "markPrice": "26930.60000000",
    //         "fundingFee": "9.56021744",
    //         "fundingIntervalHours": 8,
    //         "paymentType": "Pay",
    //         "status": "COMPLETED",
    //         "createdTime": 1696060873259,
    //         "updatedTime": 1696060873286
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var amount interface{} = this.SafeString(income, "fundingFee")
    var code interface{} = this.SafeCurrencyCode("USD")
    var id interface{} = this.SafeString(income, "id")
    var timestamp interface{} = this.SafeInteger(income, "updatedTime")
    var rate interface{} = this.SafeNumber(income, "fundingRate")
    var paymentType interface{} = this.SafeString(income, "paymentType")
    amount = Ternary(IsTrue((IsEqual(paymentType, "Pay"))), Precise.StringNeg(amount), amount)
    return map[string]interface{} {
        "info": income,
        "symbol": symbol,
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": id,
        "amount": this.ParseNumber(amount),
        "rate": rate,
    }
}
/**
 * @method
 * @name woo#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://developer.woox.io/api-reference/endpoint/futures/get_fundingFee_history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *woo) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes32098 := (<-this.LoadMarkets())
            PanicOnError(retRes32098)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes321319 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes321319)
                    ch <- retRes321319
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 500))
            }
        
            response:= (<-this.V3PrivateGetFuturesFundingFeeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "meta": {
            //                 "total": 670,
            //                 "recordsPerPage": 25,
            //                 "currentPage": 1
            //             },
            //             "rows": [
            //                 {
            //                     "id": 1286360,
            //                     "symbol": "PERP_BTC_USDT",
            //                     "fundingRate": -0.00001445,
            //                     "markPrice": "26930.60000000",
            //                     "fundingFee": "9.56021744",
            //                     "fundingIntervalHours": 8,
            //                     "paymentType": "Pay",
            //                     "status": "COMPLETED",
            //                     "createdTime": 1696060873259,
            //                     "updatedTime": 1696060873286
            //                 }
            //             ]
            //         },
            //         "timestamp": 1721351502594
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseIncomes(rows, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseFundingRate(fundingRate interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "PERP_BTC_USDT",
    //         "estFundingRate": "-0.00000441",
    //         "estFundingRateTimestamp": 1751623979022,
    //         "lastFundingRate": "-0.00004953",
    //         "lastFundingRateTimestamp": 1751616000000,
    //         "nextFundingTime": 1751644800000,
    //         "lastFundingIntervalHours": 8,
    //         "estFundingIntervalHours": 8
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(fundingRate, "symbol")
    market = this.Market(symbol)
    var nextFundingTimestamp interface{} = this.SafeInteger(fundingRate, "nextFundingTime")
    var estFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "estFundingRateTimestamp")
    var lastFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "lastFundingRateTimestamp")
    var intervalString interface{} = this.SafeString(fundingRate, "estFundingIntervalHours")
    return map[string]interface{} {
        "info": fundingRate,
        "symbol": GetValue(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": this.ParseNumber("0"),
        "estimatedSettlePrice": nil,
        "timestamp": estFundingRateTimestamp,
        "datetime": this.Iso8601(estFundingRateTimestamp),
        "fundingRate": this.SafeNumber(fundingRate, "estFundingRate"),
        "fundingTimestamp": nextFundingTimestamp,
        "fundingDatetime": this.Iso8601(nextFundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": this.SafeNumber(fundingRate, "lastFundingRate"),
        "previousFundingTimestamp": lastFundingRateTimestamp,
        "previousFundingDatetime": this.Iso8601(lastFundingRateTimestamp),
        "interval": Add(intervalString, "h"),
    }
}
/**
 * @method
 * @name woo#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woo) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes331615 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes331615)
                ch <- retRes331615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woo) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33298 := (<-this.LoadMarkets())
            PanicOnError(retRes33298)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V3PublicGetFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "PERP_BTC_USDT",
            //                     "estFundingRate": "-0.00000441",
            //                     "estFundingRateTimestamp": 1751623979022,
            //                     "lastFundingRate": "-0.00004953",
            //                     "lastFundingRateTimestamp": 1751616000000,
            //                     "nextFundingTime": 1751644800000,
            //                     "lastFundingIntervalHours": 8,
            //                     "estFundingIntervalHours": 8
            //                 }
            //             ]
            //         },
            //         "timestamp": 1751624037798
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
            var first interface{} = this.SafeDict(rows, 0, map[string]interface{} {})
        
            ch <- this.ParseFundingRate(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRate
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *woo) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33718 := (<-this.LoadMarkets())
            PanicOnError(retRes33718)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V3PublicGetFundingRate(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "PERP_BTC_USDT",
            //                     "estFundingRate": "-0.00000441",
            //                     "estFundingRateTimestamp": 1751623979022,
            //                     "lastFundingRate": "-0.00004953",
            //                     "lastFundingRateTimestamp": 1751616000000,
            //                     "nextFundingTime": 1751644800000,
            //                     "lastFundingIntervalHours": 8,
            //                     "estFundingIntervalHours": 8
            //                 }
            //             ]
            //         },
            //         "timestamp": 1751624037798
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
            ch <- this.ParseFundingRates(rows, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://developer.woox.io/api-reference/endpoint/public_data/fundingRateHistory
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *woo) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes34138 := (<-this.LoadMarkets())
            PanicOnError(retRes34138)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes341719 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, "page", 25))
                    PanicOnError(retRes341719)
                    ch <- retRes341719
                    return nil
            }
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            symbol = GetValue(market, "symbol")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V3PublicGetFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "rows": [
            //                 {
            //                     "symbol": "PERP_BTC_USDT",
            //                     "fundingRate": "-0.00004953",
            //                     "fundingRateTimestamp": 1751616000000,
            //                     "nextFundingTime": 1751644800000,
            //                     "markPrice": "108708"
            //                 }
            //             ],
            //             "meta": {
            //                 "total": 11690,
            //                 "recordsPerPage": 25,
            //                 "currentPage": 1
            //             }
            //         },
            //         "timestamp": 1751632390031
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "rows", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
                var entry interface{} = GetValue(rows, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var timestamp interface{} = this.SafeInteger(entry, "fundingRateTimestamp")
                AppendToArray(&rates, map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(marketId),
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://developer.woox.io/api-reference/endpoint/futures/position_mode
 * @param {bool} hedged set to true to use HEDGE_MODE, false for ONE_WAY
 * @param {string} symbol not used by woo setPositionMode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *woo) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var hedgeMode interface{} = nil
            if IsTrue(hedged) {
                hedgeMode = "HEDGE_MODE"
            } else {
                hedgeMode = "ONE_WAY"
            }
            var request interface{} = map[string]interface{} {
                "positionMode": hedgeMode,
            }
        
            response:= (<-this.V3PrivatePutFuturesPositionMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "timestamp": 1752550492845
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://developer.woox.io/api-reference/endpoint/account/get_account_info
 * @see https://developer.woox.io/api-reference/endpoint/futures/get_leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
 * @param {string} [params.positionMode] *for swap markets only* 'ONE_WAY' or 'HEDGE_MODE'
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *woo) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes35168 := (<-this.LoadMarkets())
            PanicOnError(retRes35168)
            var market interface{} = this.Market(symbol)
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
            response = (<-this.V3PrivateGetAccountInfo(params))
                    PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                var request interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                }
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params, "cross");
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                AddElementToObject(request, "marginMode", this.EncodeMarginMode(marginMode))
                
            response = (<-this.V3PrivateGetFuturesLeverage(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchLeverage() is not supported for "), GetValue(market, "type")), " markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    market = this.SafeMarket(marketId, market)
    var marginMode interface{} = this.SafeStringLower(leverage, "marginMode")
    var spotLeverage interface{} = this.SafeInteger(leverage, "leverage")
    if IsTrue(IsEqual(spotLeverage, 0)) {
        spotLeverage = nil
    }
    var longLeverage interface{} = spotLeverage
    var shortLeverage interface{} = spotLeverage
    var details interface{} = this.SafeList(leverage, "details", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
        var position interface{} = this.SafeDict(details, i, map[string]interface{} {})
        var positionLeverage interface{} = this.SafeInteger(position, "leverage")
        var side interface{} = this.SafeString(position, "positionSide")
        if IsTrue(IsEqual(side, "BOTH")) {
            longLeverage = positionLeverage
            shortLeverage = positionLeverage
        } else if IsTrue(IsEqual(side, "LONG")) {
            longLeverage = positionLeverage
        } else if IsTrue(IsEqual(side, "SHORT")) {
            shortLeverage = positionLeverage
        }
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
/**
 * @method
 * @name woo#setLeverage
 * @description set the level of leverage for a market
 * @see https://developer.woox.io/api-reference/endpoint/spot_margin/set_leverage
 * @see https://developer.woox.io/api-reference/endpoint/futures/set_leverage
 * @param {float} leverage the rate of leverage (1, 2, 3, 4 or 5 for spot markets, 1, 2, 3, 4, 5, 10, 15, 20 for swap markets)
 * @param {string} [symbol] unified market symbol (is mandatory for swap markets)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
 * @param {string} [params.positionMode] *for swap markets only* 'ONE_WAY' or 'HEDGE_MODE'
 * @returns {object} response from the exchange
 */
func  (this *woo) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes36528 := (<-this.LoadMarkets())
            PanicOnError(retRes36528)
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(IsTrue((IsEqual(symbol, nil))) || IsTrue(GetValue(market, "spot"))) {
        
                    retRes366119 :=  (<-this.V3PrivatePostSpotMarginLeverage(this.Extend(request, params)))
                    PanicOnError(retRes366119)
                    ch <- retRes366119
                    return nil
            } else if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params, "cross");
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                AddElementToObject(request, "marginMode", this.EncodeMarginMode(marginMode))
        
                    retRes366719 :=  (<-this.V3PrivatePutFuturesLeverage(this.Extend(request, params)))
                    PanicOnError(retRes366719)
                    ch <- retRes366719
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchLeverage() is not supported for "), GetValue(market, "type")), " markets")))
            }
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#addMargin
 * @description add margin
 * @see https://docs.woox.io/#update-isolated-margin-setting
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *woo) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes368515 :=  (<-this.ModifyMarginHelper(symbol, amount, "ADD", params))
                PanicOnError(retRes368515)
                ch <- retRes368515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#reduceMargin
 * @description remove margin from a position
 * @see https://docs.woox.io/#update-isolated-margin-setting
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *woo) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes370015 :=  (<-this.ModifyMarginHelper(symbol, amount, "REDUCE", params))
                PanicOnError(retRes370015)
                ch <- retRes370015
                return nil
        
            }()
            return ch
        }
func  (this *woo) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37048 := (<-this.LoadMarkets())
            PanicOnError(retRes37048)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "adjust_token": "USDT",
                "adjust_amount": amount,
                "action": typeVar,
            }
        
                retRes371215 :=  (<-this.V1PrivatePostClientIsolatedMargin(this.Extend(request, params)))
                PanicOnError(retRes371215)
                ch <- retRes371215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchPosition
 * @description fetch data on an open position
 * @see https://developer.woox.io/api-reference/endpoint/futures/get_positions
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *woo) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37258 := (<-this.LoadMarkets())
            PanicOnError(retRes37258)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V3PrivateGetFuturesPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "positions": [
            //                 {
            //                     "symbol": "PERP_LTC_USDT",
            //                     "holding": "0.1",
            //                     "pendingLongQty": "0",
            //                     "pendingShortQty": "0",
            //                     "settlePrice": "96.87",
            //                     "averageOpenPrice": "96.87",
            //                     "pnl24H": "0",
            //                     "fee24H": "0.0048435",
            //                     "markPrice": "96.83793449",
            //                     "estLiqPrice": "0",
            //                     "timestamp": 1752500555823,
            //                     "adlQuantile": 2,
            //                     "positionSide": "BOTH",
            //                     "marginMode": "CROSS",
            //                     "isolatedMarginToken": "",
            //                     "isolatedMarginAmount": "0",
            //                     "isolatedFrozenLong": "0",
            //                     "isolatedFrozenShort": "0",
            //                     "leverage": 10
            //                 }
            //             ]
            //         },
            //         "timestamp": 1752500579848
            //     }
            //
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(result, "positions", []interface{}{})
            var first interface{} = this.SafeDict(positions, 0, map[string]interface{} {})
        
            ch <- this.ParsePosition(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchPositions
 * @description fetch all open positions
 * @see https://developer.woox.io/api-reference/endpoint/futures/get_positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *woo) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes37788 := (<-this.LoadMarkets())
            PanicOnError(retRes37788)
        
            response:= (<-this.V3PrivateGetFuturesPositions(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "positions": [
            //                 {
            //                     "symbol": "PERP_LTC_USDT",
            //                     "holding": "0.1",
            //                     "pendingLongQty": "0",
            //                     "pendingShortQty": "0",
            //                     "settlePrice": "96.87",
            //                     "averageOpenPrice": "96.87",
            //                     "pnl24H": "0",
            //                     "fee24H": "0.0048435",
            //                     "markPrice": "96.83793449",
            //                     "estLiqPrice": "0",
            //                     "timestamp": 1752500555823,
            //                     "adlQuantile": 2,
            //                     "positionSide": "BOTH",
            //                     "marginMode": "CROSS",
            //                     "isolatedMarginToken": "",
            //                     "isolatedMarginAmount": "0",
            //                     "isolatedFrozenLong": "0",
            //                     "isolatedFrozenShort": "0",
            //                     "leverage": 10
            //                 }
            //             ]
            //         },
            //         "timestamp": 1752500579848
            //     }
            //
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(result, "positions", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // v1PrivateGetPositionSymbol
    //     {
    //         "symbol": "PERP_ETH_USDT",
    //         "position_side": "BOTH",
    //         "leverage": 10,
    //         "margin_mode": "CROSS",
    //         "average_open_price": 3139.9,
    //         "isolated_margin_amount": 0.0,
    //         "isolated_margin_token": "",
    //         "opening_time": "1720627963.094",
    //         "mark_price": 3155.19169891,
    //         "pending_short_qty": 0.0,
    //         "pending_long_qty": 0.0,
    //         "holding": -0.7,
    //         "pnl_24_h": 0.0,
    //         "est_liq_price": 9107.40055552,
    //         "settle_price": 3151.0319904,
    //         "success": true,
    //         "fee_24_h": 0.0,
    //         "isolated_frozen_long": 0.0,
    //         "isolated_frozen_short": 0.0,
    //         "timestamp": "1720867502.544"
    //     }
    //
    // v3PrivateGetPositions
    //     {
    //         "symbol": "PERP_LTC_USDT",
    //         "holding": "0.1",
    //         "pendingLongQty": "0",
    //         "pendingShortQty": "0",
    //         "settlePrice": "96.87",
    //         "averageOpenPrice": "96.87",
    //         "pnl24H": "0",
    //         "fee24H": "0.0048435",
    //         "markPrice": "96.83793449",
    //         "estLiqPrice": "0",
    //         "timestamp": 1752500555823,
    //         "adlQuantile": 2,
    //         "positionSide": "BOTH",
    //         "marginMode": "CROSS",
    //         "isolatedMarginToken": "",
    //         "isolatedMarginAmount": "0",
    //         "isolatedFrozenLong": "0",
    //         "isolatedFrozenShort": "0",
    //         "leverage": 10
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var contract interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(contract, market)
    var size interface{} = this.SafeString(position, "holding")
    var side interface{} = nil
    if IsTrue(Precise.StringGt(size, "0")) {
        side = "long"
    } else {
        side = "short"
    }
    var contractSize interface{} = this.SafeString(market, "contractSize")
    var markPrice interface{} = this.SafeString2(position, "markPrice", "mark_price")
    var timestampString interface{} = this.SafeString(position, "timestamp")
    var timestamp interface{} = nil
    if IsTrue(!IsEqual(timestampString, nil)) {
        if IsTrue(IsGreaterThan(GetIndexOf(timestampString, "."), OpNeg(1))) {
            timestamp = this.SafeTimestamp(position, "timestamp")
        } else {
            timestamp = this.SafeInteger(position, "timestamp")
        }
    }
    var entryPrice interface{} = this.SafeString2(position, "averageOpenPrice", "average_open_price")
    var priceDifference interface{} = Precise.StringSub(markPrice, entryPrice)
    var unrealisedPnl interface{} = Precise.StringMul(priceDifference, size)
    size = Precise.StringAbs(size)
    var notional interface{} = Precise.StringMul(size, markPrice)
    var positionSide interface{} = this.SafeString(position, "positionSide") // 'SHORT' or 'LONG' for hedged, 'BOTH' for non-hedged
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "entryPrice": this.ParseNumber(entryPrice),
        "notional": this.ParseNumber(notional),
        "leverage": this.SafeNumber(position, "leverage"),
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(size),
        "contractSize": this.ParseNumber(contractSize),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber2(position, "estLiqPrice", "est_liq_price"),
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": this.SafeStringLower2(position, "marginMode", "margin_mode"),
        "side": side,
        "percentage": nil,
        "hedged": !IsEqual(positionSide, "BOTH"),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name woo#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://docs.woox.io/#get-quote-rfq
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes39348 := (<-this.LoadMarkets())
            PanicOnError(retRes39348)
            var request interface{} = map[string]interface{} {
                "sellToken": ToUpper(fromCode),
                "buyToken": ToUpper(toCode),
                "sellQuantity": this.NumberToString(amount),
            }
        
            response:= (<-this.V3PrivateGetConvertRfq(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 123123123,
            //             "counterPartyId": "",
            //             "sellToken": "ETH",
            //             "sellQuantity": "0.0445",
            //             "buyToken": "USDT",
            //             "buyQuantity": "33.45",
            //             "buyPrice": "6.77",
            //             "expireTimestamp": 1659084466000,
            //             "message": 1659084466000
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fromCurrencyId interface{} = this.SafeString(data, "sellToken", fromCode)
            var fromCurrency interface{} = this.Currency(fromCurrencyId)
            var toCurrencyId interface{} = this.SafeString(data, "buyToken", toCode)
            var toCurrency interface{} = this.Currency(toCurrencyId)
        
            ch <- this.ParseConversion(data, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createConvertTrade
 * @description convert from one currency to another
 * @see https://docs.woox.io/#send-quote-rft
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes39788 := (<-this.LoadMarkets())
            PanicOnError(retRes39788)
            var request interface{} = map[string]interface{} {
                "quoteId": id,
            }
        
            response:= (<-this.V3PrivatePostConvertRft(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 123123123,
            //             "counterPartyId": "",
            //             "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseConversion(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchConvertTrade
 * @description fetch the data for a conversion trade
 * @see https://docs.woox.io/#get-quote-trade
 * @param {string} id the id of the trade that you want to fetch
 * @param {string} [code] the unified currency code of the conversion trade
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertTrade(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes40088 := (<-this.LoadMarkets())
            PanicOnError(retRes40088)
            var request interface{} = map[string]interface{} {
                "quoteId": id,
            }
        
            response:= (<-this.V3PrivateGetConvertTrade(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 12,
            //             "buyAsset": "",
            //             "sellAsset": "",
            //             "buyAmount": 12.11,
            //             "sellAmount": 12.11,
            //             "tradeStatus": 12,
            //             "createdTime": ""
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fromCurrencyId interface{} = this.SafeString(data, "sellAsset")
            var toCurrencyId interface{} = this.SafeString(data, "buyAsset")
            var fromCurrency interface{} = nil
            var toCurrency interface{} = nil
            if IsTrue(!IsEqual(fromCurrencyId, nil)) {
                fromCurrency = this.Currency(fromCurrencyId)
            }
            if IsTrue(!IsEqual(toCurrencyId, nil)) {
                toCurrency = this.Currency(toCurrencyId)
            }
        
            ch <- this.ParseConversion(data, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://docs.woox.io/#get-quote-trades
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertTradeHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes40548 := (<-this.LoadMarkets())
            PanicOnError(retRes40548)
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.V3PrivateGetConvertTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "count": 12,
            //             "tradeVos":[
            //                 {
            //                     "quoteId": 12,
            //                     "buyAsset": "",
            //                     "sellAsset": "",
            //                     "buyAmount": 12.11,
            //                     "sellAmount": 12.11,
            //                     "tradeStatus": 12,
            //                     "createdTime": ""
            //                 }
            //                 ...
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "tradeVos", []interface{}{})
        
            ch <- this.ParseConversions(rows, code, "sellAsset", "buyAsset", since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchConvertQuote
    //
    //     {
    //         "quoteId": 123123123,
    //         "counterPartyId": "",
    //         "sellToken": "ETH",
    //         "sellQuantity": "0.0445",
    //         "buyToken": "USDT",
    //         "buyQuantity": "33.45",
    //         "buyPrice": "6.77",
    //         "expireTimestamp": 1659084466000,
    //         "message": 1659084466000
    //     }
    //
    // createConvertTrade
    //
    //     {
    //         "quoteId": 123123123,
    //         "counterPartyId": "",
    //         "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
    //     }
    //
    // fetchConvertTrade, fetchConvertTradeHistory
    //
    //     {
    //         "quoteId": 12,
    //         "buyAsset": "",
    //         "sellAsset": "",
    //         "buyAmount": 12.11,
    //         "sellAmount": 12.11,
    //         "tradeStatus": 12,
    //         "createdTime": ""
    //     }
    //
    fromCurrency := GetArg(optionalArgs, 0, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 1, nil)
    _ = toCurrency
    var timestamp interface{} = this.SafeInteger2(conversion, "expireTimestamp", "createdTime")
    var fromCurr interface{} = this.SafeString2(conversion, "sellToken", "buyAsset")
    var fromCode interface{} = this.SafeCurrencyCode(fromCurr, fromCurrency)
    var to interface{} = this.SafeString2(conversion, "buyToken", "sellAsset")
    var toCode interface{} = this.SafeCurrencyCode(to, toCurrency)
    return map[string]interface{} {
        "info": conversion,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(conversion, "quoteId"),
        "fromCurrency": fromCode,
        "fromAmount": this.SafeNumber2(conversion, "sellQuantity", "sellAmount"),
        "toCurrency": toCode,
        "toAmount": this.SafeNumber2(conversion, "buyQuantity", "buyAmount"),
        "price": this.SafeNumber(conversion, "buyPrice"),
        "fee": nil,
    }
}
/**
 * @method
 * @name woo#fetchConvertCurrencies
 * @description fetches all available currencies that can be converted
 * @see https://docs.woox.io/#get-quote-asset-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *woo) FetchConvertCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes41538 := (<-this.LoadMarkets())
            PanicOnError(retRes41538)
        
            response:= (<-this.V3PrivateGetConvertAssetInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "rows": [
            //             {
            //                 "token": "BTC",
            //                 "tick": 0.0001,
            //                 "createdTime": "1575014248.99", // Unix epoch time in seconds
            //                 "updatedTime": "1575014248.99"  // Unix epoch time in seconds
            //             },
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var data interface{} = this.SafeList(response, "rows", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(entry, "token")
                var code interface{} = this.SafeCurrencyCode(id)
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "id": id,
            "code": code,
            "networks": nil,
            "type": nil,
            "name": nil,
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": this.SafeNumber(entry, "tick"),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "created": this.SafeTimestamp(entry, "createdTime"),
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *woo) DefaultNetworkCodeForCurrency(code interface{}) interface{}  {
    var currencyItem interface{} = this.Currency(code)
    var networks interface{} = GetValue(currencyItem, "networks")
    var networkKeys interface{} = ObjectKeys(networks)
    for i := 0; IsLessThan(i, GetArrayLength(networkKeys)); i++ {
        var network interface{} = GetValue(networkKeys, i)
        if IsTrue(IsEqual(network, "ETH")) {
            return network
        }
    }
    // if it was not returned according to above options, then return the first network of currency
    return this.SafeValue(networkKeys, 0)
}
func  (this *woo) SetSandboxMode(enable interface{})  {
    this.Exchange.SetSandboxMode(enable)
    AddElementToObject(this.Options, "sandboxMode", enable)
}


func (this *woo) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
