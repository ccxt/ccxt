package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type woo struct {
    Exchange

}

func NewWooCore() woo {
   p := woo{}
   setDefaults(&p)
   return p
}

func  (this *woo) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "woo",
        "name": "WOO X",
        "countries": []interface{}{"KY"},
        "rateLimit": 100,
        "version": "v1",
        "certified": true,
        "pro": true,
        "hostname": "woox.io",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": true,
            "cancelOrder": true,
            "cancelWithdraw": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": true,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": true,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": false,
            "createStopLossOrder": true,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": true,
            "createTrailingAmountOrder": true,
            "createTrailingPercentOrder": true,
            "createTriggerOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchConvertCurrencies": true,
            "fetchConvertQuote": true,
            "fetchConvertTrade": true,
            "fetchConvertTradeHistory": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": false,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": true,
            "setLeverage": true,
            "setMargin": false,
            "setPositionMode": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1mon",
            "1y": "1y",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg",
            "api": map[string]interface{} {
                "pub": "https://api-pub.woox.io",
                "public": "https://api.{hostname}",
                "private": "https://api.{hostname}",
            },
            "test": map[string]interface{} {
                "pub": "https://api-pub.staging.woox.io",
                "public": "https://api.staging.woox.io",
                "private": "https://api.staging.woox.io",
            },
            "www": "https://woox.io/",
            "doc": []interface{}{"https://docs.woox.io/"},
            "fees": []interface{}{"https://support.woox.io/hc/en-001/articles/4404611795353--Trading-Fees"},
            "referral": map[string]interface{} {
                "url": "https://woox.io/register?ref=DIJT0CNL",
                "discount": 0.35,
            },
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "pub": map[string]interface{} {
                    "get": map[string]interface{} {
                        "hist/kline": 10,
                        "hist/trades": 10,
                    },
                },
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "info": 1,
                        "info/{symbol}": 1,
                        "system_info": 1,
                        "market_trades": 1,
                        "token": 1,
                        "token_network": 1,
                        "funding_rates": 1,
                        "funding_rate/{symbol}": 1,
                        "funding_rate_history": 1,
                        "futures": 1,
                        "futures/{symbol}": 1,
                        "orderbook/{symbol}": 1,
                        "kline": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "client/token": 1,
                        "order/{oid}": 1,
                        "client/order/{client_order_id}": 1,
                        "orders": 1,
                        "client/trade/{tid}": 1,
                        "order/{oid}/trades": 1,
                        "client/trades": 1,
                        "client/hist_trades": 1,
                        "staking/yield_history": 1,
                        "client/holding": 1,
                        "asset/deposit": 10,
                        "asset/history": 60,
                        "sub_account/all": 60,
                        "sub_account/assets": 60,
                        "sub_account/asset_detail": 60,
                        "sub_account/ip_restriction": 10,
                        "asset/main_sub_transfer_history": 30,
                        "token_interest": 60,
                        "token_interest/{token}": 60,
                        "interest/history": 60,
                        "interest/repay": 60,
                        "funding_fee/history": 30,
                        "positions": 3.33,
                        "position/{symbol}": 3.33,
                        "client/transaction_history": 60,
                        "client/futures_leverage": 60,
                    },
                    "post": map[string]interface{} {
                        "order": 1,
                        "order/cancel_all_after": 1,
                        "asset/main_sub_transfer": 30,
                        "asset/ltv": 30,
                        "asset/withdraw": 30,
                        "asset/internal_withdraw": 30,
                        "interest/repay": 60,
                        "client/account_mode": 120,
                        "client/position_mode": 5,
                        "client/leverage": 120,
                        "client/futures_leverage": 30,
                        "client/isolated_margin": 30,
                    },
                    "delete": map[string]interface{} {
                        "order": 1,
                        "client/order": 1,
                        "orders": 1,
                        "asset/withdraw": 120,
                    },
                },
            },
            "v2": map[string]interface{} {
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "client/holding": 1,
                    },
                },
            },
            "v3": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "insuranceFund": 3,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "algo/order/{oid}": 1,
                        "algo/orders": 1,
                        "balances": 1,
                        "accountinfo": 60,
                        "positions": 3.33,
                        "buypower": 1,
                        "referrals": 60,
                        "referral_rewards": 60,
                        "convert/exchangeInfo": 1,
                        "convert/assetInfo": 1,
                        "convert/rfq": 60,
                        "convert/trade": 1,
                        "convert/trades": 1,
                    },
                    "post": map[string]interface{} {
                        "algo/order": 5,
                        "convert/rft": 60,
                    },
                    "put": map[string]interface{} {
                        "order/{oid}": 2,
                        "order/client/{client_order_id}": 2,
                        "algo/order/{oid}": 2,
                        "algo/order/client/{client_order_id}": 2,
                    },
                    "delete": map[string]interface{} {
                        "algo/order/{order_id}": 1,
                        "algo/orders/pending": 1,
                        "algo/orders/pending/{symbol}": 1,
                        "orders/pending": 1,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0002"),
                "taker": this.ParseNumber("0.0005"),
            },
        },
        "options": map[string]interface{} {
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "sandboxMode": false,
            "createMarketBuyOrderRequiresPrice": true,
            "network-aliases-for-tokens": map[string]interface{} {
                "HT": "ERC20",
                "OMG": "ERC20",
                "UATOM": "ATOM",
                "ZRX": "ZRX",
            },
            "networks": map[string]interface{} {
                "TRX": "TRON",
                "TRC20": "TRON",
                "ERC20": "ETH",
                "BEP20": "BSC",
            },
            "defaultNetworkCodeForCurrencies": map[string]interface{} {},
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "brokerId": "bc830de7-50f3-460b-9ee0-f430f83f9dad",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 90,
                    "untilDays": 10000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": true,
                    "trailing": true,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forSwap": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "hedged": true,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forSwap",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1000": OperationFailed,
                "-1001": AuthenticationError,
                "-1002": AuthenticationError,
                "-1003": RateLimitExceeded,
                "-1004": BadRequest,
                "-1005": BadRequest,
                "-1006": BadRequest,
                "-1007": BadRequest,
                "-1008": InvalidOrder,
                "-1009": BadRequest,
                "-1012": BadRequest,
                "-1101": InvalidOrder,
                "-1102": InvalidOrder,
                "-1103": InvalidOrder,
                "-1104": InvalidOrder,
                "-1105": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "Can not place": ExchangeError,
                "maintenance": OnMaintenance,
                "symbol must not be blank": BadRequest,
                "The token is not supported": BadRequest,
                "Your order and symbol are not valid or already canceled": BadRequest,
                "Insufficient WOO. Please enable margin trading for leverage trading": BadRequest,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name woo#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.woox.io/#get-system-maintenance-status-public
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *woo) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetSystemInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": "0",
            //             "msg": "System is functioning properly."
            //         },
            //         "timestamp": "1709274106602"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var status interface{} = this.SafeString(data, "status")
            if IsTrue(IsEqual(status, nil)) {
                status = "error"
            } else if IsTrue(IsEqual(status, "0")) {
                status = "ok"
            } else {
                status = "maintenance"
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.woox.io/#get-system-maintenance-status-public
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *woo) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PublicGetSystemInfo(params))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "data": {
            //             "status": "0",
            //             "msg": "System is functioning properly."
            //         },
            //         "timestamp": "1709274106602"
            //     }
            //
        ch <- this.SafeInteger(response, "timestamp")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchMarkets
 * @description retrieves data on all markets for woo
 * @see https://docs.woox.io/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *woo) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes51312 := (<-this.LoadTimeDifference())
                PanicOnError(retRes51312)
            }
        
            response:= (<-this.V1PublicGetInfo(params))
            PanicOnError(response)
            //
            // {
            //     "rows": [
            //         {
            //             "symbol": "SPOT_AAVE_USDT",
            //             "quote_min": 0,
            //             "quote_max": 100000,
            //             "quote_tick": 0.01,
            //             "base_min": 0.01,
            //             "base_max": 7284,
            //             "base_tick": 0.0001,
            //             "min_notional": 10,
            //             "price_range": 0.1,
            //             "created_time": "0",
            //             "updated_time": "1639107647.988",
            //             "is_stable": 0
            //         },
            //         ...
            //     "success": true
            // }
            //
            var data interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseMarket(market interface{}) interface{}  {
    var marketId interface{} = this.SafeString(market, "symbol")
    var parts interface{} = Split(marketId, "_")
    var first interface{} = this.SafeString(parts, 0)
    var marketType interface{} = nil
    var spot interface{} = false
    var swap interface{} = false
    if IsTrue(IsEqual(first, "SPOT")) {
        spot = true
        marketType = "spot"
    } else if IsTrue(IsEqual(first, "PERP")) {
        swap = true
        marketType = "swap"
    }
    var baseId interface{} = this.SafeString(parts, 1)
    var quoteId interface{} = this.SafeString(parts, 2)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = nil
    var settle interface{} = nil
    var symbol interface{} = Add(Add(base, "/"), quote)
    var contractSize interface{} = nil
    var linear interface{} = nil
    var inverse interface{} = nil
    var margin interface{} = true
    var contract interface{} = swap
    if IsTrue(contract) {
        margin = false
        settleId = this.SafeString(parts, 2)
        settle = this.SafeCurrencyCode(settleId)
        symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
        contractSize = this.ParseNumber("1")
        linear = true
        inverse = false
    }
    var active interface{} = IsEqual(this.SafeString(market, "is_trading"), "1")
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": marketType,
        "spot": spot,
        "margin": margin,
        "swap": swap,
        "future": false,
        "option": false,
        "active": active,
        "contract": contract,
        "linear": linear,
        "inverse": inverse,
        "contractSize": contractSize,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "base_tick"),
            "price": this.SafeNumber(market, "quote_tick"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "base_min"),
                "max": this.SafeNumber(market, "base_max"),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "quote_min"),
                "max": this.SafeNumber(market, "quote_max"),
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_notional"),
                "max": nil,
            },
        },
        "created": this.SafeTimestamp(market, "created_time"),
        "info": market,
    }
}
/**
 * @method
 * @name woo#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.woox.io/#market-trades-public
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *woo) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6408 := (<-this.LoadMarkets())
            PanicOnError(retRes6408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1PublicGetMarketTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "success": true,
            //     "rows": [
            //         {
            //             "symbol": "SPOT_BTC_USDT",
            //             "side": "SELL",
            //             "executed_price": 46222.35,
            //             "executed_quantity": 0.0012,
            //             "executed_timestamp": "1641241162.329"
            //         },
            //         {
            //             "symbol": "SPOT_BTC_USDT",
            //             "side": "SELL",
            //             "executed_price": 46222.35,
            //             "executed_quantity": 0.0012,
            //             "executed_timestamp": "1641241162.329"
            //         },
            //         {
            //             "symbol": "SPOT_BTC_USDT",
            //             "side": "BUY",
            //             "executed_price": 46224.32,
            //             "executed_quantity": 0.00039,
            //             "executed_timestamp": "1641241162.287"
            //         },
            //         ...
            //      ]
            // }
            //
            var resultResponse interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseTrades(resultResponse, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public/market_trades
    //
    //     {
    //         "symbol": "SPOT_BTC_USDT",
    //         "side": "SELL",
    //         "executed_price": 46222.35,
    //         "executed_quantity": 0.0012,
    //         "executed_timestamp": "1641241162.329"
    //     }
    //
    // fetchOrderTrades, fetchOrder
    //
    //     {
    //         "id": "99119876",
    //         "symbol": "SPOT_WOO_USDT",
    //         "fee": "0.0024",
    //         "side": "BUY",
    //         "executed_timestamp": "1641481113.084",
    //         "order_id": "87001234",
    //         "order_tag": "default", <-- this param only in "fetchOrderTrades"
    //         "executed_price": "1",
    //         "executed_quantity": "12",
    //         "fee_asset": "WOO",
    //         "is_maker": "1"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var isFromFetchOrder interface{} =     (InOp(trade, "id"))
    var timestamp interface{} = this.SafeTimestamp(trade, "executed_timestamp")
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(trade, "executed_price")
    var amount interface{} = this.SafeString(trade, "executed_quantity")
    var order_id interface{} = this.SafeString(trade, "order_id")
    var fee interface{} = this.ParseTokenAndFeeTemp(trade, "fee_asset", "fee")
    var feeCost interface{} = this.SafeString(fee, "cost")
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "cost", feeCost)
    }
    var cost interface{} = Precise.StringMul(price, amount)
    var side interface{} = this.SafeStringLower(trade, "side")
    var id interface{} = this.SafeString(trade, "id")
    var takerOrMaker interface{} = nil
    if IsTrue(isFromFetchOrder) {
        var isMaker interface{} = IsEqual(this.SafeString(trade, "is_maker"), "1")
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": order_id,
        "takerOrMaker": takerOrMaker,
        "type": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *woo) ParseTokenAndFeeTemp(item interface{}, feeTokenKey interface{}, feeAmountKey interface{}) interface{}  {
    var feeCost interface{} = this.SafeString(item, feeAmountKey)
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(item, feeTokenKey)
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    return fee
}
/**
 * @method
 * @name woo#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.woox.io/#get-account-information-new
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *woo) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7718 := (<-this.LoadMarkets())
            PanicOnError(retRes7718)
        
            response:= (<-this.V3PrivateGetAccountinfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "applicationId": "dsa",
            //             "account": "dsa",
            //             "alias": "haha",
            //             "accountMode": "MARGIN",
            //             "leverage": 1,
            //             "takerFeeRate": 1,
            //             "makerFeeRate": 1,
            //             "interestRate": 1,
            //             "futuresTakerFeeRate": 1,
            //             "futuresMakerFeeRate": 1,
            //             "otpauth": true,
            //             "marginRatio": 1,
            //             "openMarginRatio": 1,
            //             "initialMarginRatio": 1,
            //             "maintenanceMarginRatio": 1,
            //             "totalCollateral": 1,
            //             "freeCollateral": 1,
            //             "totalAccountValue": 1,
            //             "totalVaultValue": 1,
            //             "totalStakingValue": 1
            //         },
            //         "timestamp": 1673323685109
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var maker interface{} = this.SafeString(data, "makerFeeRate")
            var taker interface{} = this.SafeString(data, "takerFeeRate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(Precise.StringDiv(maker, "10000")),
            "taker": this.ParseNumber(Precise.StringDiv(taker, "10000")),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.woox.io/#available-token-public
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *woo) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var result interface{} = map[string]interface{} {}
        
            tokenResponse:= (<-this.V1PublicGetToken(params))
            PanicOnError(tokenResponse)
            //
            // {
            //     "rows": [
            //         {
            //             "token": "ETH_USDT",
            //             "fullname": "Tether",
            //             "decimals": 6,
            //             "balance_token": "USDT",
            //             "created_time": "0",
            //             "updated_time": "0"
            //         },
            //         {
            //             "token": "BSC_USDT",
            //             "fullname": "Tether",
            //             "decimals": 18,
            //             "balance_token": "USDT",
            //             "created_time": "0",
            //             "updated_time": "0"
            //         },
            //         {
            //             "token": "ZEC",
            //             "fullname": "ZCash",
            //             "decimals": 8,
            //             "balance_token": "ZEC",
            //             "created_time": "0",
            //             "updated_time": "0"
            //         },
            //         ...
            //     ],
            //     "success": true
            // }
            //
            // only make one request for currrencies...
            // const tokenNetworkResponse = await this.v1PublicGetTokenNetwork (params);
            //
            // {
            //     "rows": [
            //         {
            //             "protocol": "ERC20",
            //             "token": "USDT",
            //             "name": "Ethereum",
            //             "minimum_withdrawal": 30,
            //             "withdrawal_fee": 25,
            //             "allow_deposit": 1,
            //             "allow_withdraw": 1
            //         },
            //         {
            //             "protocol": "TRC20",
            //             "token": "USDT",
            //             "name": "Tron",
            //             "minimum_withdrawal": 30,
            //             "withdrawal_fee": 1,
            //             "allow_deposit": 1,
            //             "allow_withdraw": 1
            //         },
            //         ...
            //     ],
            //     "success": true
            // }
            //
            var tokenRows interface{} = this.SafeList(tokenResponse, "rows", []interface{}{})
            var networksByCurrencyId interface{} = this.GroupBy(tokenRows, "balance_token")
            var currencyIds interface{} = ObjectKeys(networksByCurrencyId)
            for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
                var currencyId interface{} = GetValue(currencyIds, i)
                var networks interface{} = GetValue(networksByCurrencyId, currencyId)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var name interface{} = nil
                var minPrecision interface{} = nil
                var resultingNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
                    var network interface{} = GetValue(networks, j)
                    name = this.SafeString(network, "fullname")
                    var networkId interface{} = this.SafeString(network, "token")
                    var splitted interface{} = Split(networkId, "_")
                    var unifiedNetwork interface{} = GetValue(splitted, 0)
                    var precision interface{} = this.ParsePrecision(this.SafeString(network, "decimals"))
                    if IsTrue(!IsEqual(precision, nil)) {
                        minPrecision = Ternary(IsTrue((IsEqual(minPrecision, nil))), precision, Precise.StringMin(precision, minPrecision))
                    }
                    AddElementToObject(resultingNetworks, unifiedNetwork, map[string]interface{} {
            "id": networkId,
            "network": unifiedNetwork,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": this.ParseNumber(precision),
            "info": network,
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "name": name,
            "code": code,
            "precision": this.ParseNumber(minPrecision),
            "active": nil,
            "fee": nil,
            "networks": resultingNetworks,
            "deposit": nil,
            "withdraw": nil,
            "type": "crypto",
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "info": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://docs.woox.io/#send-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9698 := (<-this.LoadMarkets())
            PanicOnError(retRes9698)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
        
                retRes97415 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, 1, params))
                PanicOnError(retRes97415)
                ch <- retRes97415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://docs.woox.io/#send-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9888 := (<-this.LoadMarkets())
            PanicOnError(retRes9888)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketSellOrderWithCost() supports spot orders only")))
            }
        
                retRes99315 :=  (<-this.CreateOrder(symbol, "market", "sell", cost, 1, params))
                PanicOnError(retRes99315)
                ch <- retRes99315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createTrailingAmountOrder
 * @description create a trailing order by providing the symbol, type, side, amount, price and trailingAmount
 * @see https://docs.woox.io/#send-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
 * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
 * @param {float} trailingAmount the quote amount to trail away from the current market price
 * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateTrailingAmountOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            trailingAmount := GetArg(optionalArgs, 1, nil)
            _ = trailingAmount
            trailingTriggerPrice := GetArg(optionalArgs, 2, nil)
            _ = trailingTriggerPrice
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(trailingAmount, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingAmountOrder() requires a trailingAmount argument")))
            }
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingAmountOrder() requires a trailingTriggerPrice argument")))
            }
            AddElementToObject(params, "trailingAmount", trailingAmount)
            AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
        
                retRes102015 :=  (<-this.CreateOrder(symbol, typeVar, side, amount, price, params))
                PanicOnError(retRes102015)
                ch <- retRes102015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createTrailingPercentOrder
 * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
 * @see https://docs.woox.io/#send-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
 * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
 * @param {float} trailingPercent the percent to trail away from the current market price
 * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateTrailingPercentOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            trailingPercent := GetArg(optionalArgs, 1, nil)
            _ = trailingPercent
            trailingTriggerPrice := GetArg(optionalArgs, 2, nil)
            _ = trailingTriggerPrice
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(trailingPercent, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingPercent argument")))
            }
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")))
            }
            AddElementToObject(params, "trailingPercent", trailingPercent)
            AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)
        
                retRes104715 :=  (<-this.CreateOrder(symbol, typeVar, side, amount, price, params))
                PanicOnError(retRes104715)
                ch <- retRes104715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createOrder
 * @description create a trade order
 * @see https://docs.woox.io/#send-order
 * @see https://docs.woox.io/#send-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated', default 'cross'
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.algoType] 'STOP' or 'TRAILING_STOP' or 'OCO' or 'CLOSE_POSITION'
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
 * @param {string} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @param {string} [params.position_side] 'SHORT' or 'LONG' - if position mode is HEDGE_MODE and the trading involves futures, then is required, otherwise this parameter is not required
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
            params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only"})
            var orderType interface{} = ToUpper(typeVar)
        
            retRes10808 := (<-this.LoadMarkets())
            PanicOnError(retRes10808)
            var market interface{} = this.Market(symbol)
            var orderSide interface{} = ToUpper(side)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": orderSide,
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(!IsEqual(marginMode, nil)) {
                AddElementToObject(request, "margin_mode", this.EncodeMarginMode(marginMode))
            }
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            var stopLoss interface{} = this.SafeValue(params, "stopLoss")
            var takeProfit interface{} = this.SafeValue(params, "takeProfit")
            var algoType interface{} = this.SafeString(params, "algoType")
            var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activatedPrice", this.NumberToString(price))
            var trailingAmount interface{} = this.SafeString2(params, "trailingAmount", "callbackValue")
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRate")
            var isTrailingAmountOrder interface{} = !IsEqual(trailingAmount, nil)
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            var isTrailing interface{} = IsTrue(isTrailingAmountOrder) || IsTrue(isTrailingPercentOrder)
            var isConditional interface{} = IsTrue(IsTrue(IsTrue(IsTrue(isTrailing) || IsTrue(!IsEqual(triggerPrice, nil))) || IsTrue(!IsEqual(stopLoss, nil))) || IsTrue(!IsEqual(takeProfit, nil))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var isMarket interface{} = IsEqual(orderType, "MARKET")
            var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
            var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
            var reduceOnlyKey interface{} = Ternary(IsTrue(isConditional), "reduceOnly", "reduce_only")
            var clientOrderIdKey interface{} = Ternary(IsTrue(isConditional), "clientOrderId", "client_order_id")
            var orderQtyKey interface{} = Ternary(IsTrue(isConditional), "quantity", "order_quantity")
            var priceKey interface{} = Ternary(IsTrue(isConditional), "price", "order_price")
            var typeKey interface{} = Ternary(IsTrue(isConditional), "type", "order_type")
            AddElementToObject(request, typeKey, orderType) // LIMIT/MARKET/IOC/FOK/POST_ONLY/ASK/BID
            if !IsTrue(isConditional) {
                if IsTrue(postOnly) {
                    AddElementToObject(request, "order_type", "POST_ONLY")
                } else if IsTrue(IsEqual(timeInForce, "fok")) {
                    AddElementToObject(request, "order_type", "FOK")
                } else if IsTrue(IsEqual(timeInForce, "ioc")) {
                    AddElementToObject(request, "order_type", "IOC")
                }
            }
            if IsTrue(reduceOnly) {
                AddElementToObject(request, reduceOnlyKey, reduceOnly)
            }
            if IsTrue(!IsTrue(isMarket) && IsTrue(!IsEqual(price, nil))) {
                AddElementToObject(request, priceKey, this.PriceToPrecision(symbol, price))
            }
            if IsTrue(IsTrue(isMarket) && !IsTrue(isConditional)) {
                // for market buy it requires the amount of quote currency to spend
                var cost interface{} = this.SafeString2(params, "cost", "order_amount")
                params = this.Omit(params, []interface{}{"cost", "order_amount"})
                var isPriceProvided interface{} = !IsEqual(price, nil)
                if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue((IsTrue(isPriceProvided) || IsTrue((!IsEqual(cost, nil)))))) {
                    var quoteAmount interface{} = nil
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else {
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var costRequest interface{} = Precise.StringMul(amountString, priceString)
                        quoteAmount = this.CostToPrecision(symbol, costRequest)
                    }
                    AddElementToObject(request, "order_amount", quoteAmount)
                } else {
                    AddElementToObject(request, "order_quantity", this.AmountToPrecision(symbol, amount))
                }
            } else if IsTrue(!IsEqual(algoType, "POSITIONAL_TP_SL")) {
                AddElementToObject(request, orderQtyKey, this.AmountToPrecision(symbol, amount))
            }
            var clientOrderId interface{} = this.SafeStringN(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, clientOrderIdKey, clientOrderId)
            }
            if IsTrue(isTrailing) {
                if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a trailingTriggerPrice parameter for trailing orders")))
                }
                AddElementToObject(request, "activatedPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
                AddElementToObject(request, "algoType", "TRAILING_STOP")
                if IsTrue(isTrailingAmountOrder) {
                    AddElementToObject(request, "callbackValue", trailingAmount)
                } else if IsTrue(isTrailingPercentOrder) {
                    var convertedTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
                    AddElementToObject(request, "callbackRate", convertedTrailingPercent)
                }
            } else if IsTrue(!IsEqual(triggerPrice, nil)) {
                if IsTrue(!IsEqual(algoType, "TRAILING_STOP")) {
                    AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                    AddElementToObject(request, "algoType", "STOP")
                }
            } else if IsTrue(IsTrue((!IsEqual(stopLoss, nil))) || IsTrue((!IsEqual(takeProfit, nil)))) {
                AddElementToObject(request, "algoType", "BRACKET")
                var outterOrder interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                    "reduceOnly": false,
                    "algoType": "POSITIONAL_TP_SL",
                    "childOrders": []interface{}{},
                }
                var childOrders interface{} = GetValue(outterOrder, "childOrders")
                var closeSide interface{} = Ternary(IsTrue((IsEqual(orderSide, "BUY"))), "SELL", "BUY")
                if IsTrue(!IsEqual(stopLoss, nil)) {
                    var stopLossPrice interface{} = this.SafeString(stopLoss, "triggerPrice", stopLoss)
                    var stopLossOrder interface{} = map[string]interface{} {
                        "side": closeSide,
                        "algoType": "STOP_LOSS",
                        "triggerPrice": this.PriceToPrecision(symbol, stopLossPrice),
                        "type": "CLOSE_POSITION",
                        "reduceOnly": true,
                    }
                    AppendToArray(&childOrders,stopLossOrder)
                }
                if IsTrue(!IsEqual(takeProfit, nil)) {
                    var takeProfitPrice interface{} = this.SafeString(takeProfit, "triggerPrice", takeProfit)
                    var takeProfitOrder interface{} = map[string]interface{} {
                        "side": closeSide,
                        "algoType": "TAKE_PROFIT",
                        "triggerPrice": this.PriceToPrecision(symbol, takeProfitPrice),
                        "type": "CLOSE_POSITION",
                        "reduceOnly": true,
                    }
                    AppendToArray(&childOrders,takeProfitOrder)
                }
                AddElementToObject(request, "childOrders", []interface{}{outterOrder})
            }
            params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id", "postOnly", "timeInForce", "stopPrice", "triggerPrice", "stopLoss", "takeProfit", "trailingPercent", "trailingAmount", "trailingTriggerPrice"})
            var response interface{} = nil
            if IsTrue(isConditional) {
                
        response = (<-this.V3PrivatePostAlgoOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivatePostOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            // {
            //     "success": true,
            //     "timestamp": "1641383206.489",
            //     "order_id": "86980774",
            //     "order_type": "LIMIT",
            //     "order_price": "1", // null for "MARKET" order
            //     "order_quantity": "12", // null for "MARKET" order
            //     "order_amount": null, // NOT-null for "MARKET" order
            //     "client_order_id": "0"
            // }
            // stop orders
            // {
            //     "success": true,
            //     "data": {
            //       "rows": [
            //         {
            //           "orderId": "1578938",
            //           "clientOrderId": "0",
            //           "algoType": "STOP_LOSS",
            //           "quantity": "0.1"
            //         }
            //       ]
            //     },
            //     "timestamp": "1686149372216"
            // }
            var data interface{} = this.SafeDict(response, "data")
            if IsTrue(!IsEqual(data, nil)) {
                var rows interface{} = this.SafeList(data, "rows", []interface{}{})
        
                ch <- this.ParseOrder(GetValue(rows, 0), market)
                return nil
            }
            var order interface{} = this.ParseOrder(response, market)
            AddElementToObject(order, "type", typeVar)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
func  (this *woo) EncodeMarginMode(mode interface{}) interface{}  {
    var modes interface{} = map[string]interface{} {
        "cross": "CROSS",
        "isolated": "ISOLATED",
    }
    return this.SafeString(modes, mode, mode)
}
/**
 * @method
 * @name woo#editOrder
 * @description edit a trade order
 * @see https://docs.woox.io/#edit-order
 * @see https://docs.woox.io/#edit-order-by-client_order_id
 * @see https://docs.woox.io/#edit-algo-order
 * @see https://docs.woox.io/#edit-algo-order-by-client_order_id
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {float} [params.stopLossPrice] price to trigger stop-loss orders
 * @param {float} [params.takeProfitPrice] price to trigger take-profit orders
 * @param {string} [params.trailingAmount] the quote amount to trail away from the current market price
 * @param {string} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12788 := (<-this.LoadMarkets())
            PanicOnError(retRes12788)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            var clientOrderIdUnified interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "client_order_id", clientOrderIdUnified)
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "takeProfitPrice", "stopLossPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activatedPrice", this.NumberToString(price))
            var trailingAmount interface{} = this.SafeString2(params, "trailingAmount", "callbackValue")
            var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRate")
            var isTrailingAmountOrder interface{} = !IsEqual(trailingAmount, nil)
            var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
            var isTrailing interface{} = IsTrue(isTrailingAmountOrder) || IsTrue(isTrailingPercentOrder)
            if IsTrue(isTrailing) {
                if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
                    AddElementToObject(request, "activatedPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
                }
                if IsTrue(isTrailingAmountOrder) {
                    AddElementToObject(request, "callbackValue", trailingAmount)
                } else if IsTrue(isTrailingPercentOrder) {
                    var convertedTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
                    AddElementToObject(request, "callbackRate", convertedTrailingPercent)
                }
            }
            params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id", "stopPrice", "triggerPrice", "takeProfitPrice", "stopLossPrice", "trailingTriggerPrice", "trailingAmount", "trailingPercent"})
            var isConditional interface{} = IsTrue(IsTrue(isTrailing) || IsTrue((!IsEqual(triggerPrice, nil)))) || IsTrue((!IsEqual(this.SafeValue(params, "childOrders"), nil)))
            var response interface{} = nil
            if IsTrue(isByClientOrder) {
                AddElementToObject(request, "client_order_id", clientOrderIdExchangeSpecific)
                if IsTrue(isConditional) {
                    
        response = (<-this.V3PrivatePutAlgoOrderClientClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V3PrivatePutOrderClientClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                AddElementToObject(request, "oid", id)
                if IsTrue(isConditional) {
                    
        response = (<-this.V3PrivatePutAlgoOrderOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.V3PrivatePutOrderOid(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "status": "string",
            //             "success": true
            //         },
            //         "message": "string",
            //         "success": true,
            //         "timestamp": 0
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelOrder
 * @see https://docs.woox.io/#cancel-algo-order
 * @see https://docs.woox.io/#cancel-order
 * @see https://docs.woox.io/#cancel-order-by-client_order_id
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            if IsTrue(!IsTrue(isTrigger) && IsTrue((IsEqual(symbol, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes13678 := (<-this.LoadMarkets())
            PanicOnError(retRes13678)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var clientOrderIdUnified interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "client_order_id", clientOrderIdUnified)
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var response interface{} = nil
            if IsTrue(isTrigger) {
                AddElementToObject(request, "order_id", id)
                
        response = (<-this.V3PrivateDeleteAlgoOrderOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                if IsTrue(isByClientOrder) {
                    AddElementToObject(request, "client_order_id", clientOrderIdExchangeSpecific)
                    params = this.Omit(params, []interface{}{"clOrdID", "clientOrderId", "client_order_id"})
                    
        response = (<-this.V1PrivateDeleteClientOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    AddElementToObject(request, "order_id", id)
                    
        response = (<-this.V1PrivateDeleteOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // { success: true, status: "CANCEL_SENT" }
            //
            var extendParams interface{} = map[string]interface{} {
                "symbol": symbol,
            }
            if IsTrue(isByClientOrder) {
                AddElementToObject(extendParams, "client_order_id", clientOrderIdExchangeSpecific)
            } else {
                AddElementToObject(extendParams, "id", id)
            }
        
            ch <- this.Extend(this.ParseOrder(response), extendParams)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelAllOrders
 * @see https://docs.woox.io/#cancel-all-pending-orders
 * @see https://docs.woox.io/#cancel-orders
 * @see https://docs.woox.io/#cancel-all-pending-algo-orders
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14168 := (<-this.LoadMarkets())
            PanicOnError(retRes14168)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            if IsTrue(trigger) {
        
                    retRes142019 :=  (<-this.V3PrivateDeleteAlgoOrdersPending(params))
                    PanicOnError(retRes142019)
                    ch <- retRes142019
                    return nil
            }
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success":true,
            //         "status":"CANCEL_ALL_SENT"
            //     }
            //
        ch <- []interface{}{this.SafeOrder(response)}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://docs.woox.io/#cancel-all-after
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the api result
 */
func  (this *woo) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14518 := (<-this.LoadMarkets())
            PanicOnError(retRes14518)
            var request interface{} = map[string]interface{} {
                "trigger_after": Ternary(IsTrue((IsGreaterThan(timeout, 0))), timeout, 0),
            }
        
            response:= (<-this.V1PrivatePostOrderCancelAllAfter(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "data": {
            //             "expected_trigger_time": 1711534302938
            //         },
            //         "timestamp": 1711534302943
            //     }
            //
        ch <- []interface{}{this.SafeOrder(response)}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOrder
 * @see https://docs.woox.io/#get-algo-order
 * @see https://docs.woox.io/#get-order
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14838 := (<-this.LoadMarkets())
            PanicOnError(retRes14838)
            var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clOrdID", "clientOrderId")
            var response interface{} = nil
            if IsTrue(trigger) {
                AddElementToObject(request, "oid", id)
                
        response = (<-this.V3PrivateGetAlgoOrderOid(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(clientOrderId) {
                AddElementToObject(request, "client_order_id", clientOrderId)
                
        response = (<-this.V1PrivateGetClientOrderClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "oid", id)
                
        response = (<-this.V1PrivateGetOrderOid(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // {
            //     "success": true,
            //     "symbol": "SPOT_WOO_USDT",
            //     "status": "FILLED", // FILLED, NEW
            //     "side": "BUY",
            //     "created_time": "1641480933.000",
            //     "order_id": "87541111",
            //     "order_tag": "default",
            //     "price": "1",
            //     "type": "LIMIT",
            //     "quantity": "12",
            //     "amount": null,
            //     "visible": "12",
            //     "executed": "12", // or any partial amount
            //     "total_fee": "0.0024",
            //     "fee_asset": "WOO",
            //     "client_order_id": null,
            //     "average_executed_price": "1",
            //     "Transactions": [
            //       {
            //         "id": "99111647",
            //         "symbol": "SPOT_WOO_USDT",
            //         "fee": "0.0024",
            //         "side": "BUY",
            //         "executed_timestamp": "1641482113.084",
            //         "order_id": "87541111",
            //         "executed_price": "1",
            //         "executed_quantity": "12",
            //         "fee_asset": "WOO",
            //         "is_maker": "1"
            //       }
            //     ]
            // }
            //
            var orders interface{} = this.SafeDict(response, "data", response)
        
            ch <- this.ParseOrder(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.woox.io/#get-orders
 * @see https://docs.woox.io/#get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15578 := (<-this.LoadMarkets())
            PanicOnError(retRes15578)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes156119 :=  (<-this.FetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes156119)
                    ch <- retRes156119
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
            var trailing interface{} = this.SafeBool(params, "trailing", false)
            params = this.Omit(params, []interface{}{"stop", "trailing", "trigger"})
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                if IsTrue(IsTrue(trigger) || IsTrue(trailing)) {
                    AddElementToObject(request, "createdTimeStart", since)
                } else {
                    AddElementToObject(request, "start_t", since)
                }
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            } else {
                AddElementToObject(request, "size", 500)
            }
            if IsTrue(trigger) {
                AddElementToObject(request, "algoType", "stop")
            } else if IsTrue(trailing) {
                AddElementToObject(request, "algoType", "TRAILING_STOP")
            }
            var response interface{} = nil
            if IsTrue(IsTrue(trigger) || IsTrue(trailing)) {
                
        response = (<-this.V3PrivateGetAlgoOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivateGetOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "success":true,
            //         "meta":{
            //             "total":1,
            //             "records_per_page":100,
            //             "current_page":1
            //         },
            //         "rows":[
            //             {
            //                 "symbol":"PERP_BTC_USDT",
            //                 "status":"FILLED",
            //                 "side":"SELL",
            //                 "created_time":"1611617776.000",
            //                 "updated_time":"1611617776.000",
            //                 "order_id":52121167,
            //                 "order_tag":"default",
            //                 "price":null,
            //                 "type":"MARKET",
            //                 "quantity":0.002,
            //                 "amount":null,
            //                 "visible":0,
            //                 "executed":0.002,
            //                 "total_fee":0.01732885,
            //                 "fee_asset":"USDT",
            //                 "client_order_id":null,
            //                 "average_executed_price":28881.41
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", response)
            var orders interface{} = this.SafeList(data, "rows")
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.woox.io/#get-orders
 * @see https://docs.woox.io/#get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16498 := (<-this.LoadMarkets())
            PanicOnError(retRes16498)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "INCOMPLETE",
            })
        
                retRes165115 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes165115)
                ch <- retRes165115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchClosedOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.woox.io/#get-orders
 * @see https://docs.woox.io/#get-algo-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {boolean} [params.isTriggered] whether the order has been triggered (false by default)
 * @param {string} [params.side] 'buy' or 'sell'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *woo) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16728 := (<-this.LoadMarkets())
            PanicOnError(retRes16728)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "COMPLETED",
            })
        
                retRes167415 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes167415)
                ch <- retRes167415
                return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "ioc": "IOC",
        "fok": "FOK",
        "post_only": "PO",
    }
    return this.SafeString(timeInForces, timeInForce, nil)
}
func  (this *woo) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Possible input functions:
    // * createOrder
    // * cancelOrder
    // * fetchOrder
    // * fetchOrders
    // const isFromFetchOrder = ('order_tag' in order); TO_DO
    //
    // stop order after creating it:
    //   {
    //     "orderId": "1578938",
    //     "clientOrderId": "0",
    //     "algoType": "STOP_LOSS",
    //     "quantity": "0.1"
    //   }
    // stop order after fetching it:
    //   {
    //       "algoOrderId": "1578958",
    //       "clientOrderId": "0",
    //       "rootAlgoOrderId": "1578958",
    //       "parentAlgoOrderId": "0",
    //       "symbol": "SPOT_LTC_USDT",
    //       "orderTag": "default",
    //       "algoType": "STOP_LOSS",
    //       "side": "BUY",
    //       "quantity": "0.1",
    //       "isTriggered": false,
    //       "triggerPrice": "100",
    //       "triggerStatus": "USELESS",
    //       "type": "LIMIT",
    //       "rootAlgoStatus": "CANCELLED",
    //       "algoStatus": "CANCELLED",
    //       "triggerPriceType": "MARKET_PRICE",
    //       "price": "75",
    //       "triggerTime": "0",
    //       "totalExecutedQuantity": "0",
    //       "averageExecutedPrice": "0",
    //       "totalFee": "0",
    //       "feeAsset": '',
    //       "reduceOnly": false,
    //       "createdTime": "1686149609.744",
    //       "updatedTime": "1686149903.362"
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestampN(order, []interface{}{"timestamp", "created_time", "createdTime"})
    var orderId interface{} = this.SafeStringN(order, []interface{}{"order_id", "orderId", "algoOrderId"})
    var clientOrderId interface{} = this.OmitZero(this.SafeString2(order, "client_order_id", "clientOrderId")) // Somehow, this always returns 0 for limit order
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString2(order, "order_price", "price")
    var amount interface{} = this.SafeString2(order, "order_quantity", "quantity") // This is base amount
    var cost interface{} = this.SafeString2(order, "order_amount", "amount") // This is quote amount
    var orderType interface{} = this.SafeStringLower2(order, "order_type", "type")
    var status interface{} = this.SafeValue2(order, "status", "algoStatus")
    var side interface{} = this.SafeStringLower(order, "side")
    var filled interface{} = this.OmitZero(this.SafeValue2(order, "executed", "totalExecutedQuantity"))
    var average interface{} = this.OmitZero(this.SafeString2(order, "average_executed_price", "averageExecutedPrice"))
    // const remaining = Precise.stringSub (cost, filled);
    var fee interface{} = this.SafeNumber2(order, "total_fee", "totalFee")
    var feeCurrency interface{} = this.SafeString2(order, "fee_asset", "feeAsset")
    var transactions interface{} = this.SafeValue(order, "Transactions")
    var triggerPrice interface{} = this.SafeNumber(order, "triggerPrice")
    var takeProfitPrice interface{} = nil
    var stopLossPrice interface{} = nil
    var childOrders interface{} = this.SafeValue(order, "childOrders")
    if IsTrue(!IsEqual(childOrders, nil)) {
        var first interface{} = this.SafeValue(childOrders, 0)
        var innerChildOrders interface{} = this.SafeValue(first, "childOrders", []interface{}{})
        var innerChildOrdersLength interface{} =         GetArrayLength(innerChildOrders)
        if IsTrue(IsGreaterThan(innerChildOrdersLength, 0)) {
            var takeProfitOrder interface{} = this.SafeValue(innerChildOrders, 0)
            var stopLossOrder interface{} = this.SafeValue(innerChildOrders, 1)
            takeProfitPrice = this.SafeNumber(takeProfitOrder, "triggerPrice")
            stopLossPrice = this.SafeNumber(stopLossOrder, "triggerPrice")
        }
    }
    var lastUpdateTimestamp interface{} = this.SafeTimestamp2(order, "updatedTime", "updated_time")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": orderType,
        "timeInForce": this.ParseTimeInForce(orderType),
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "reduce_only"),
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": cost,
        "trades": transactions,
        "fee": map[string]interface{} {
            "cost": fee,
            "currency": feeCurrency,
        },
        "info": order,
    }, market)
}
func  (this *woo) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "NEW": "open",
            "FILLED": "closed",
            "CANCEL_SENT": "canceled",
            "CANCEL_ALL_SENT": "canceled",
            "CANCELLED": "canceled",
            "PARTIAL_FILLED": "open",
            "REJECTED": "rejected",
            "INCOMPLETE": "open",
            "COMPLETED": "closed",
        }
        return this.SafeString(statuses, status, status)
    }
    return status
}
/**
 * @method
 * @name woo#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.woox.io/#orderbook-snapshot-public
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *woo) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18268 := (<-this.LoadMarkets())
            PanicOnError(retRes18268)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                limit = mathMin(limit, 1000)
                AddElementToObject(request, "max_level", limit)
            }
        
            response:= (<-this.V1PublicGetOrderbookSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //   "success": true,
            //   "timestamp": "1641562961192",
            //   "asks": [
            //     { price: '0.921', quantity: "76.01" },
            //     { price: '0.933', quantity: "477.10" },
            //     ...
            //   ],
            //   "bids": [
            //     { price: '0.940', quantity: "13502.47" },
            //     { price: '0.932', quantity: "43.91" },
            //     ...
            //   ]
            // }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "bids", "asks", "price", "quantity")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchOHLCV
 * @see https://docs.woox.io/#kline-public
 * @see https://docs.woox.io/#kline-historical-data-public
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] max=1000, max=100 when since is defined and is less than (now - (999 * (timeframe in ms)))
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *woo) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18708 := (<-this.LoadMarkets())
            PanicOnError(retRes18708)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var useHistEndpoint interface{} = !IsEqual(since, nil)
            if IsTrue(IsTrue((!IsEqual(limit, nil))) && IsTrue((!IsEqual(since, nil)))) {
                var oneThousandCandles interface{} = Multiply(Multiply(this.ParseTimeframe(timeframe), 1000), 999) // 999 because there will be delay between this and the request, causing the latest candle to be excluded sometimes
                var startWithLimit interface{} = Subtract(this.Milliseconds(), oneThousandCandles)
                useHistEndpoint = IsLessThan(since, startWithLimit)
            }
            if IsTrue(useHistEndpoint) {
                AddElementToObject(request, "start_time", since)
            } else if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            var response interface{} = nil
            if !IsTrue(useHistEndpoint) {
                
        response = (<-this.V1PublicGetKline(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PubGetHistKline(this.Extend(request, params)))
                PanicOnError(response)
                response = this.SafeDict(response, "data")
            }
            var rows interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseOHLCVs(rows, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // example response in fetchOHLCV
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "start_timestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name woo#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.woox.io/#get-trades
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woo) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19658 := (<-this.LoadMarkets())
            PanicOnError(retRes19658)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "oid": id,
            }
        
            response:= (<-this.V1PrivateGetOrderOidTrades(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "success": true,
            //     "rows": [
            //       {
            //         "id": "99111647",
            //         "symbol": "SPOT_WOO_USDT",
            //         "fee": "0.0024",
            //         "side": "BUY",
            //         "executed_timestamp": "1641482113.084",
            //         "order_id": "87541111",
            //         "order_tag": "default",
            //         "executed_price": "1",
            //         "executed_quantity": "12",
            //         "fee_asset": "WOO",
            //         "is_maker": "1"
            //       }
            //     ]
            // }
            var trades interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.woox.io/#get-trade-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *woo) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20098 := (<-this.LoadMarkets())
            PanicOnError(retRes20098)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes201319 :=  (<-this.FetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes201319)
                    ch <- retRes201319
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            requestparamsVariable := this.HandleUntilOption("end_t", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            } else {
                AddElementToObject(request, "size", 500)
            }
        
            response:= (<-this.V1PrivateGetClientTrades(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "success": true,
            //     "meta": {
            //         "records_per_page": 25,
            //         "current_page": 1
            //     },
            //     "rows": [
            //         {
            //             "id": 5,
            //             "symbol": "SPOT_BTC_USDT",
            //             "order_id": 211,
            //             "order_tag": "default",
            //             "executed_price": 10892.84,
            //             "executed_quantity": 0.002,
            //             "is_maker": 0,
            //             "side": "SELL",
            //             "fee": 0,
            //             "fee_asset": "USDT",
            //             "executed_timestamp": "1566264290.250"
            //         },
            //         ...
            //     ]
            // }
            var trades interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.woox.io/#get-assets-of-subaccounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *woo) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1PrivateGetSubAccountAssets(params))
            PanicOnError(response)
            //
            //     {
            //         "rows": [{
            //                 "application_id": "13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365",
            //                 "account": "Main",
            //                 "usdt_balance": "4.0"
            //             },
            //             {
            //                 "application_id": "432952aa-a401-4e26-aff6-972920aebba3",
            //                 "account": "subaccount",
            //                 "usdt_balance": "1.0"
            //             }
            //         ],
            //         "success": true
            //     }
            //
            var rows interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseAccounts(rows, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseAccount(account interface{}) interface{}  {
    //
    //     {
    //         "application_id": "336952aa-a401-4e26-aff6-972920aebba3",
    //         "account": "subaccount",
    //         "usdt_balance": "1.0",
    //     }
    //
    var accountId interface{} = this.SafeString(account, "account")
    return map[string]interface{} {
        "info": account,
        "id": this.SafeString(account, "application_id"),
        "name": accountId,
        "code": nil,
        "type": Ternary(IsTrue(IsEqual(accountId, "Main")), "main", "subaccount"),
    }
}
/**
 * @method
 * @name woo#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.woox.io/#get-current-holding-get-balance-new
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *woo) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21158 := (<-this.LoadMarkets())
            PanicOnError(retRes21158)
        
            response:= (<-this.V3PrivateGetBalances(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "holding": [
            //                 {
            //                     "token": "0_token",
            //                     "holding": 1,
            //                     "frozen": 0,
            //                     "staked": 0,
            //                     "unbonding": 0,
            //                     "vault": 0,
            //                     "interest": 0,
            //                     "pendingShortQty": 0,
            //                     "pendingLongQty": 0,
            //                     "availableBalance": 0,
            //                     "updatedTime": 312321.121
            //                 }
            //             ]
            //         },
            //         "timestamp": 1673323746259
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeList(response, "holding", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "token"))
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "holding"))
        AddElementToObject(account, "free", this.SafeString(balance, "availableBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name woo#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.woox.io/#get-token-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *woo) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is TODO because of networks unification
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes21718 := (<-this.LoadMarkets())
            PanicOnError(retRes21718)
            var currency interface{} = this.Currency(code)
            var networkCodeDefault interface{} = this.DefaultNetworkCodeForCurrency(code)
            var networkCode interface{} = this.SafeString(params, "network", networkCodeDefault)
            params = this.Omit(params, "network")
            var codeForExchange interface{} = Add(Add(networkCode, "_"), GetValue(currency, "code"))
            var request interface{} = map[string]interface{} {
                "token": codeForExchange,
            }
        
            response:= (<-this.V1PrivateGetAssetDeposit(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "success": true,
            //     "address": "3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP",
            //     "extra": ''
            // }
            var tag interface{} = this.SafeString(response, "extra")
            var address interface{} = this.SafeString(response, "address")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": networkCode,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *woo) GetAssetHistoryRows(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21998 := (<-this.LoadMarkets())
            PanicOnError(retRes21998)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "balance_token", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            var transactionType interface{} = this.SafeString(params, "type")
            params = this.Omit(params, "type")
            if IsTrue(!IsEqual(transactionType, nil)) {
                AddElementToObject(request, "type", transactionType)
            }
        
            response:= (<-this.V1PrivateGetAssetHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "rows": [
            //       {
            //         "id": "22010508193900165",
            //         "token": "TRON_USDT",
            //         "extra": '',
            //         "amount": "13.75848500",
            //         "status": "COMPLETED",
            //         "account": null,
            //         "description": null,
            //         "user_id": "42222",
            //         "application_id": "6ad2b303-f354-45c0-8105-9f5f19d0e335",
            //         "external_id": "220105081900134",
            //         "target_address": "TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK",
            //         "source_address": "TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6",
            //         "type": "BALANCE",
            //         "token_side": "DEPOSIT",
            //         "tx_id": "35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee",
            //         "fee_token": '',
            //         "fee_amount": "0.00000000",
            //         "created_time": "1641370779.442",
            //         "updated_time": "1641370779.465",
            //         "is_new_target_address": null,
            //         "confirmed_number": "29",
            //         "confirming_threshold": "27",
            //         "audit_tag": "1",
            //         "audit_result": "0",
            //         "balance_token": null, // TODO -write to support, that this seems broken. here should be the token id
            //         "network_name": null // TODO -write to support, that this seems broken. here should be the network id
            //       }
            //     ],
            //     "meta": { total: '1', records_per_page: "25", current_page: "1" },
            //     "success": true
            // }
        ch <- []interface{}{currency, this.SafeList(response, "rows", []interface{}{})}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://docs.woox.io/#get-asset-history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *woo) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, params))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
            ch <- this.ParseLedger(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkizedCode interface{} = this.SafeString(item, "token")
    var currencyDefined interface{} = this.GetCurrencyFromChaincode(networkizedCode, currency)
    var code interface{} = GetValue(currencyDefined, "code")
    currency = this.SafeCurrency(code, currency)
    var amount interface{} = this.SafeNumber(item, "amount")
    var side interface{} = this.SafeString(item, "token_side")
    var direction interface{} = Ternary(IsTrue((IsEqual(side, "DEPOSIT"))), "in", "out")
    var timestamp interface{} = this.SafeTimestamp(item, "created_time")
    var fee interface{} = this.ParseTokenAndFeeTemp(item, "fee_token", "fee_amount")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "id"),
        "currency": code,
        "account": this.SafeString(item, "account"),
        "referenceAccount": nil,
        "referenceId": this.SafeString(item, "tx_id"),
        "status": this.ParseTransactionStatus(this.SafeString(item, "status")),
        "amount": amount,
        "before": nil,
        "after": nil,
        "direction": direction,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "fee": fee,
    }, currency)
}
func  (this *woo) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "BALANCE": "transaction",
        "COLLATERAL": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *woo) GetCurrencyFromChaincode(networkizedCode interface{}, currency interface{}) interface{}  {
    if IsTrue(!IsEqual(currency, nil)) {
        return currency
    } else {
        var parts interface{} = Split(networkizedCode, "_")
        var partsLength interface{} =         GetArrayLength(parts)
        var firstPart interface{} = this.SafeString(parts, 0)
        var currencyId interface{} = this.SafeString(parts, 1, firstPart)
        if IsTrue(IsGreaterThan(partsLength, 2)) {
            currencyId = Add(currencyId, Add("_", this.SafeString(parts, 2)))
        }
        currency = this.SafeCurrency(currencyId)
    }
    return currency
}
/**
 * @method
 * @name woo#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.woox.io/#get-asset-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "token_side": "DEPOSIT",
            }
        
                retRes234115 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes234115)
                ch <- retRes234115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.woox.io/#get-asset-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "token_side": "WITHDRAW",
            }
        
                retRes235915 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes235915)
                ch <- retRes235915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.woox.io/#get-asset-history
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "BALANCE",
            }
        
            currencyRows:= (<-this.GetAssetHistoryRows(code, since, limit, this.Extend(request, params)))
            PanicOnError(currencyRows)
            var currency interface{} = this.SafeValue(currencyRows, 0)
            var rows interface{} = this.SafeList(currencyRows, 1)
        
                //
            //     {
            //         "rows":[],
            //         "meta":{
            //             "total":0,
            //             "records_per_page":25,
            //             "current_page":1
            //         },
            //         "success":true
            //     }
            //
        ch <- this.ParseTransactions(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    // example in fetchLedger
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkizedCode interface{} = this.SafeString(transaction, "token")
    var currencyDefined interface{} = this.GetCurrencyFromChaincode(networkizedCode, currency)
    var code interface{} = GetValue(currencyDefined, "code")
    var movementDirection interface{} = this.SafeStringLower(transaction, "token_side")
    if IsTrue(IsEqual(movementDirection, "withdraw")) {
        movementDirection = "withdrawal"
    }
    var fee interface{} = this.ParseTokenAndFeeTemp(transaction, "fee_token", "fee_amount")
    var addressTo interface{} = this.SafeString(transaction, "target_address")
    var addressFrom interface{} = this.SafeString(transaction, "source_address")
    var timestamp interface{} = this.SafeTimestamp(transaction, "created_time")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "id", "withdraw_id"),
        "txid": this.SafeString(transaction, "tx_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "tag": this.SafeString(transaction, "extra"),
        "tagFrom": nil,
        "tagTo": nil,
        "type": movementDirection,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": this.SafeTimestamp(transaction, "updated_time"),
        "comment": nil,
        "internal": nil,
        "fee": fee,
        "network": nil,
    }
}
func  (this *woo) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "pending",
        "CONFIRMING": "pending",
        "PROCESSING": "pending",
        "COMPLETED": "ok",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name woo#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://docs.woox.io/#get-transfer-history
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *woo) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24558 := (<-this.LoadMarkets())
            PanicOnError(retRes24558)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "token": GetValue(currency, "id"),
                "amount": this.ParseToNumeric(amount),
                "from_application_id": fromAccount,
                "to_application_id": toAccount,
            }
        
            response:= (<-this.V1PrivatePostAssetMainSubTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "id": 200
            //     }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
            var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "amount", amount)
                AddElementToObject(transfer, "fromAccount", fromAccount)
                AddElementToObject(transfer, "toAccount", toAccount)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://docs.woox.io/#get-transfer-history
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *woo) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_t", until)
            }
        
            response:= (<-this.V1PrivateGetAssetMainSubTransferHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rows": [
            //             {
            //                 "id": 46704,
            //                 "token": "USDT",
            //                 "amount": 30000.00000000,
            //                 "status": "COMPLETED",
            //                 "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
            //                 "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
            //                 "from_user": "LeverageLow",
            //                 "to_user": "dev",
            //                 "created_time": "1709022325.427",
            //                 "updated_time": "1709022325.542"
            //             }
            //         ],
            //         "meta": {
            //             "total": 50,
            //             "records_per_page": 25,
            //             "current_page": 1
            //         },
            //         "success": true
            //     }
            //
            var data interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseTransfers(data, nil, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    fetchTransfers
    //     {
    //         "id": 46704,
    //         "token": "USDT",
    //         "amount": 30000.00000000,
    //         "status": "COMPLETED",
    //         "from_application_id": "0f1bd3cd-dba2-4563-b8bb-0adb1bfb83a3",
    //         "to_application_id": "c01e6940-a735-4022-9b6c-9d3971cdfdfa",
    //         "from_user": "LeverageLow",
    //         "to_user": "dev",
    //         "created_time": "1709022325.427",
    //         "updated_time": "1709022325.542"
    //     }
    //
    //    transfer
    //        {
    //            "success": true,
    //            "id": 200
    //        }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkizedCode interface{} = this.SafeString(transfer, "token")
    var currencyDefined interface{} = this.GetCurrencyFromChaincode(networkizedCode, currency)
    var code interface{} = GetValue(currencyDefined, "code")
    var timestamp interface{} = this.SafeTimestamp(transfer, "created_time")
    var success interface{} = this.SafeBool(transfer, "success")
    var status interface{} = nil
    if IsTrue(!IsEqual(success, nil)) {
        status = Ternary(IsTrue(success), "ok", "failed")
    }
    return map[string]interface{} {
        "id": this.SafeString(transfer, "id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": code,
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.SafeString(transfer, "from_application_id"),
        "toAccount": this.SafeString(transfer, "to_application_id"),
        "status": this.ParseTransferStatus(this.SafeString(transfer, "status", status)),
        "info": transfer,
    }
}
func  (this *woo) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "pending",
        "CONFIRMING": "pending",
        "PROCESSING": "pending",
        "COMPLETED": "ok",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name woo#withdraw
 * @description make a withdrawal
 * @see https://docs.woox.io/#token-withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *woo) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes26048 := (<-this.LoadMarkets())
            PanicOnError(retRes26048)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "extra", tag)
            }
            var networks interface{} = this.SafeDict(this.Options, "networks", map[string]interface{} {})
            var currencyNetworks interface{} = this.SafeDict(currency, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network")
            var networkId interface{} = this.SafeString(networks, network, network)
            var coinNetwork interface{} = this.SafeDict(currencyNetworks, networkId, map[string]interface{} {})
            var coinNetworkId interface{} = this.SafeString(coinNetwork, "id")
            if IsTrue(IsEqual(coinNetworkId, nil)) {
                panic(BadRequest(Add(this.Id, " withdraw() require network parameter")))
            }
            AddElementToObject(request, "token", coinNetworkId)
        
            response:= (<-this.V1PrivatePostAssetWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "withdraw_id": "20200119145703654"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#repayMargin
 * @description repay borrowed margin and interest
 * @see https://docs.woox.io/#repay-interest
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {string} symbol not used by woo.repayMargin ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *woo) RepayMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26468 := (<-this.LoadMarkets())
            PanicOnError(retRes26468)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = GetValue(market, "symbol")
            }
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "token": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.V1PrivatePostInterestRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //     }
            //
            var transaction interface{} = this.ParseMarginLoan(response, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "success": true,
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "id": nil,
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "symbol": nil,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
func  (this *woo) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *woo) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    section := GetArg(optionalArgs, 0, "public")
    _ = section
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(section, 0)
    var access interface{} = GetValue(section, 1)
    var pathWithParams interface{} = this.ImplodeParams(path, params)
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), access))
    url = Add(url, Add(Add("/", version), "/"))
    params = this.Omit(params, this.ExtractParams(path))
    params = this.Keysort(params)
    if IsTrue(IsEqual(access, "public")) {
        url = Add(url, Add(Add(access, "/"), pathWithParams))
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else if IsTrue(IsEqual(access, "pub")) {
        url = Add(url, pathWithParams)
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        if IsTrue(IsTrue(IsEqual(method, "POST")) && IsTrue((IsTrue(IsEqual(path, "algo/order")) || IsTrue(IsEqual(path, "order"))))) {
            var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            if !IsTrue(isSandboxMode) {
                var applicationId interface{} = "bc830de7-50f3-460b-9ee0-f430f83f9dad"
                var brokerId interface{} = this.SafeString(this.Options, "brokerId", applicationId)
                var isTrigger interface{} = IsGreaterThan(GetIndexOf(path, "algo"), OpNeg(1))
                if IsTrue(isTrigger) {
                    AddElementToObject(params, "brokerId", brokerId)
                } else {
                    AddElementToObject(params, "broker_id", brokerId)
                }
            }
            params = this.Keysort(params)
        }
        var auth interface{} = ""
        var ts interface{} = ToString(this.Nonce())
        url = Add(url, pathWithParams)
        headers = map[string]interface{} {
            "x-api-key": this.ApiKey,
            "x-api-timestamp": ts,
        }
        if IsTrue(IsEqual(version, "v3")) {
            auth = Add(Add(Add(Add(Add(ts, method), "/"), version), "/"), pathWithParams)
            if IsTrue(IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) || IsTrue(IsEqual(method, "DELETE"))) {
                body = this.Json(params)
                auth = Add(auth, body)
            } else {
                if IsTrue(GetArrayLength(ObjectKeys(params))) {
                    var query interface{} = this.Urlencode(params)
                    url = Add(url, Add("?", query))
                    auth = Add(auth, Add("?", query))
                }
            }
            AddElementToObject(headers, "content-type", "application/json")
        } else {
            auth = this.Urlencode(params)
            if IsTrue(IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) || IsTrue(IsEqual(method, "DELETE"))) {
                body = auth
            } else {
                if IsTrue(GetArrayLength(ObjectKeys(params))) {
                    url = Add(url, Add("?", auth))
                }
            }
            auth = Add(auth, Add("|", ts))
            AddElementToObject(headers, "content-type", "application/x-www-form-urlencoded")
        }
        AddElementToObject(headers, "x-api-signature", this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *woo) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    //
    //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
    //                     {"code":"-1011","message":"The system is under maintenance.","success":false}
    //
    var success interface{} = this.SafeBool(response, "success")
    var errorCode interface{} = this.SafeString(response, "code")
    if !IsTrue(success) {
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    }
    return nil
}
func  (this *woo) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id":666666,
    //         "symbol":"PERP_BTC_USDT",
    //         "funding_rate":0.00001198,
    //         "mark_price":28941.04000000,
    //         "funding_fee":0.00069343,
    //         "payment_type":"Pay",
    //         "status":"COMPLETED",
    //         "created_time":"1653616000.666",
    //         "updated_time":"1653616000.605"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var amount interface{} = this.SafeString(income, "funding_fee")
    var code interface{} = this.SafeCurrencyCode("USD")
    var id interface{} = this.SafeString(income, "id")
    var timestamp interface{} = this.SafeTimestamp(income, "updated_time")
    var rate interface{} = this.SafeNumber(income, "funding_rate")
    var paymentType interface{} = this.SafeString(income, "payment_type")
    amount = Ternary(IsTrue((IsEqual(paymentType, "Pay"))), Precise.StringNeg(amount), amount)
    return map[string]interface{} {
        "info": income,
        "symbol": symbol,
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": id,
        "amount": this.ParseNumber(amount),
        "rate": rate,
    }
}
/**
 * @method
 * @name woo#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://docs.woox.io/#get-funding-fee-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *woo) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28288 := (<-this.LoadMarkets())
            PanicOnError(retRes28288)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes283219 :=  (<-this.FetchPaginatedCallCursor("fetchFundingHistory", symbol, since, limit, params, "page", "page", 1, 500))
                    PanicOnError(retRes283219)
                    ch <- retRes283219
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            } else {
                AddElementToObject(request, "size", 5000)
            }
        
            response:= (<-this.V1PrivateGetFundingFeeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "rows":[
            //             {
            //                 "id":666666,
            //                 "symbol":"PERP_BTC_USDT",
            //                 "funding_rate":0.00001198,
            //                 "mark_price":28941.04000000,
            //                 "funding_fee":0.00069343,
            //                 "payment_type":"Pay",
            //                 "status":"COMPLETED",
            //                 "created_time":"1653616000.666",
            //                 "updated_time":"1653616000.605"
            //             }
            //         ],
            //         "meta":{
            //             "total":235,
            //             "records_per_page":25,
            //             "current_page":1
            //         },
            //         "success":true
            //     }
            //
            var meta interface{} = this.SafeDict(response, "meta", map[string]interface{} {})
            var cursor interface{} = this.SafeInteger(meta, "current_page")
            var result interface{} = this.SafeList(response, "rows", []interface{}{})
            var resultLength interface{} =     GetArrayLength(result)
            if IsTrue(IsGreaterThan(resultLength, 0)) {
                var lastItem interface{} = GetValue(result, Subtract(resultLength, 1))
                AddElementToObject(lastItem, "page", cursor)
                AddElementToObject(result, Subtract(resultLength, 1), lastItem)
            }
        
            ch <- this.ParseIncomes(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseFundingRate(fundingRate interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "success": true,
    //         "timestamp": 1727427915529,
    //         "symbol": "PERP_BTC_USDT",
    //         "est_funding_rate": -0.00092719,
    //         "est_funding_rate_timestamp": 1727427899060,
    //         "last_funding_rate": -0.00092610,
    //         "last_funding_rate_timestamp": 1727424000000,
    //         "next_funding_time": 1727452800000,
    //         "last_funding_rate_interval": 8,
    //         "est_funding_rate_interval": 8
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(fundingRate, "symbol")
    market = this.Market(symbol)
    var nextFundingTimestamp interface{} = this.SafeInteger(fundingRate, "next_funding_time")
    var estFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "est_funding_rate_timestamp")
    var lastFundingRateTimestamp interface{} = this.SafeInteger(fundingRate, "last_funding_rate_timestamp")
    var intervalString interface{} = this.SafeString(fundingRate, "est_funding_rate_interval")
    return map[string]interface{} {
        "info": fundingRate,
        "symbol": GetValue(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": this.ParseNumber("0"),
        "estimatedSettlePrice": nil,
        "timestamp": estFundingRateTimestamp,
        "datetime": this.Iso8601(estFundingRateTimestamp),
        "fundingRate": this.SafeNumber(fundingRate, "est_funding_rate"),
        "fundingTimestamp": nextFundingTimestamp,
        "fundingDatetime": this.Iso8601(nextFundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": this.SafeNumber(fundingRate, "last_funding_rate"),
        "previousFundingTimestamp": lastFundingRateTimestamp,
        "previousFundingDatetime": this.Iso8601(lastFundingRateTimestamp),
        "interval": Add(intervalString, "h"),
    }
}
/**
 * @method
 * @name woo#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://docs.woox.io/#get-predicted-funding-rate-for-one-market-public
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woo) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes293715 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes293715)
                ch <- retRes293715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.woox.io/#get-predicted-funding-rate-for-one-market-public
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *woo) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes29508 := (<-this.LoadMarkets())
            PanicOnError(retRes29508)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetFundingRateSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "timestamp": 1727428037877,
            //         "symbol": "PERP_BTC_USDT",
            //         "est_funding_rate": -0.00092674,
            //         "est_funding_rate_timestamp": 1727428019064,
            //         "last_funding_rate": -0.00092610,
            //         "last_funding_rate_timestamp": 1727424000000,
            //         "next_funding_time": 1727452800000,
            //         "last_funding_rate_interval": 8,
            //         "est_funding_rate_interval": 8
            //     }
            //
        ch <- this.ParseFundingRate(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://docs.woox.io/#get-predicted-funding-rate-for-all-markets-public
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *woo) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29838 := (<-this.LoadMarkets())
            PanicOnError(retRes29838)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V1PublicGetFundingRates(params))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "rows":[
            //             {
            //                 "symbol":"PERP_AAVE_USDT",
            //                 "est_funding_rate":-0.00003447,
            //                 "est_funding_rate_timestamp":1653633959001,
            //                 "last_funding_rate":-0.00002094,
            //                 "last_funding_rate_timestamp":1653631200000,
            //                 "next_funding_time":1653634800000
            //             }
            //         ],
            //         "timestamp":1653633985646
            //     }
            //
            var rows interface{} = this.SafeList(response, "rows", []interface{}{})
        
            ch <- this.ParseFundingRates(rows, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.woox.io/#get-funding-rate-history-for-one-market-public
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *woo) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes30208 := (<-this.LoadMarkets())
            PanicOnError(retRes30208)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes302419 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingRateHistory", symbol, since, limit, params, "page", 25))
                    PanicOnError(retRes302419)
                    ch <- retRes302419
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                symbol = GetValue(market, "symbol")
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_t", this.ParseToInt(Divide(since, 1000)))
            }
            requestparamsVariable := this.HandleUntilOption("end_t", request, params, 0.001);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.V1PublicGetFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "meta":{
            //             "total":2464,
            //             "records_per_page":25,
            //             "current_page":1
            //         },
            //         "rows":[
            //             {
            //                 "symbol":"PERP_BTC_USDT",
            //                 "funding_rate":0.00000629,
            //                 "funding_rate_timestamp":1653638400000,
            //                 "next_funding_time":1653642000000
            //             }
            //         ],
            //         "timestamp":1653640814885
            //     }
            //
            var result interface{} = this.SafeList(response, "rows")
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var timestamp interface{} = this.SafeInteger(entry, "funding_rate_timestamp")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(marketId),
                    "fundingRate": this.SafeNumber(entry, "funding_rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://docs.woox.io/#update-position-mode
 * @param {bool} hedged set to true to use HEDGE_MODE, false for ONE_WAY
 * @param {string} symbol not used by woo setPositionMode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *woo) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var hedgeMode interface{} = nil
            if IsTrue(hedged) {
                hedgeMode = "HEDGE_MODE"
            } else {
                hedgeMode = "ONE_WAY"
            }
            var request interface{} = map[string]interface{} {
                "position_mode": hedgeMode,
            }
        
            response:= (<-this.V1PrivatePostClientPositionMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "data": {},
            //         "timestamp": "1709195608551"
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://docs.woox.io/#get-account-information-new
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
 * @param {string} [params.position_mode] *for swap markets only* 'ONE_WAY' or 'HEDGE_MODE'
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *woo) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes31178 := (<-this.LoadMarkets())
            PanicOnError(retRes31178)
            var market interface{} = this.Market(symbol)
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.V3PrivateGetAccountinfo(params))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                var request interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                }
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params, "cross");
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                AddElementToObject(request, "margin_mode", this.EncodeMarginMode(marginMode))
                
        response = (<-this.V1PrivateGetClientFuturesLeverage(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchLeverage() is not supported for "), GetValue(market, "type")), " markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    market = this.SafeMarket(marketId, market)
    var marginMode interface{} = this.SafeStringLower(leverage, "default_margin_mode")
    var spotLeverage interface{} = this.SafeInteger(leverage, "leverage")
    var longLeverage interface{} = spotLeverage
    var shortLeverage interface{} = spotLeverage
    var details interface{} = this.SafeList(leverage, "details", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
        var position interface{} = this.SafeDict(details, i, map[string]interface{} {})
        var positionLeverage interface{} = this.SafeInteger(position, "leverage")
        var side interface{} = this.SafeString(position, "position_side")
        if IsTrue(IsEqual(side, "BOTH")) {
            longLeverage = positionLeverage
            shortLeverage = positionLeverage
        } else if IsTrue(IsEqual(side, "LONG")) {
            longLeverage = positionLeverage
        } else if IsTrue(IsEqual(side, "SHORT")) {
            shortLeverage = positionLeverage
        }
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
/**
 * @method
 * @name woo#setLeverage
 * @description set the level of leverage for a market
 * @see https://docs.woox.io/#update-leverage-setting
 * @see https://docs.woox.io/#update-futures-leverage-setting
 * @param {float} leverage the rate of leverage (1, 2, 3, 4 or 5 for spot markets, 1, 2, 3, 4, 5, 10, 15, 20 for swap markets)
 * @param {string} [symbol] unified market symbol (is mandatory for swap markets)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *for swap markets only* 'cross' or 'isolated'
 * @param {string} [params.position_side] *for swap markets only* 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode.
 * @returns {object} response from the exchange
 */
func  (this *woo) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32498 := (<-this.LoadMarkets())
            PanicOnError(retRes32498)
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(IsTrue((IsEqual(symbol, nil))) || IsTrue(GetValue(market, "spot"))) {
        
                    retRes325819 :=  (<-this.V1PrivatePostClientLeverage(this.Extend(request, params)))
                    PanicOnError(retRes325819)
                    ch <- retRes325819
                    return nil
            } else if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params, "cross");
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                AddElementToObject(request, "margin_mode", this.EncodeMarginMode(marginMode))
        
                    retRes326419 :=  (<-this.V1PrivatePostClientFuturesLeverage(this.Extend(request, params)))
                    PanicOnError(retRes326419)
                    ch <- retRes326419
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchLeverage() is not supported for "), GetValue(market, "type")), " markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name woo#addMargin
 * @description add margin
 * @see https://docs.woox.io/#update-isolated-margin-setting
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *woo) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes328215 :=  (<-this.ModifyMarginHelper(symbol, amount, "ADD", params))
                PanicOnError(retRes328215)
                ch <- retRes328215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#reduceMargin
 * @description remove margin from a position
 * @see https://docs.woox.io/#update-isolated-margin-setting
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.position_side] 'LONG' or 'SHORT' in hedge mode, 'BOTH' in one way mode
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *woo) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes329715 :=  (<-this.ModifyMarginHelper(symbol, amount, "REDUCE", params))
                PanicOnError(retRes329715)
                ch <- retRes329715
                return nil
        
            }()
            return ch
        }
func  (this *woo) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33018 := (<-this.LoadMarkets())
            PanicOnError(retRes33018)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "adjust_token": "USDT",
                "adjust_amount": amount,
                "action": typeVar,
            }
        
                retRes330915 :=  (<-this.V1PrivatePostClientIsolatedMargin(this.Extend(request, params)))
                PanicOnError(retRes330915)
                ch <- retRes330915
                return nil
        
            }()
            return ch
        }
func  (this *woo) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33138 := (<-this.LoadMarkets())
            PanicOnError(retRes33138)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PrivateGetPositionSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "symbol": "PERP_ETH_USDT",
            //         "position_side": "BOTH",
            //         "leverage": 10,
            //         "margin_mode": "CROSS",
            //         "average_open_price": 3139.9,
            //         "isolated_margin_amount": 0.0,
            //         "isolated_margin_token": "",
            //         "opening_time": "1720627963.094",
            //         "mark_price": 3155.19169891,
            //         "pending_short_qty": 0.0,
            //         "pending_long_qty": 0.0,
            //         "holding": -0.7,
            //         "pnl_24_h": 0.0,
            //         "est_liq_price": 9107.40055552,
            //         "settle_price": 3151.0319904,
            //         "success": true,
            //         "fee_24_h": 0.0,
            //         "isolated_frozen_long": 0.0,
            //         "isolated_frozen_short": 0.0,
            //         "timestamp": "1720867502.544"
            //     }
            //
        ch <- this.ParsePosition(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *woo) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33478 := (<-this.LoadMarkets())
            PanicOnError(retRes33478)
        
            response:= (<-this.V3PrivateGetPositions(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data":
            //         {
            //             "positions": [
            //                 {
            //                     "symbol": "PERP_ETH_USDT",
            //                     "holding": -1.0,
            //                     "pendingLongQty": 0.0,
            //                     "pendingShortQty": 0.0,
            //                     "settlePrice": 3143.2,
            //                     "averageOpenPrice": 3143.2,
            //                     "pnl24H": 0.0,
            //                     "fee24H": 1.5716,
            //                     "markPrice": 3134.97984158,
            //                     "estLiqPrice": 3436.176349,
            //                     "timestamp": 1720628031.463,
            //                     "adlQuantile": 5,
            //                     "positionSide": "BOTH",
            //                     "marginMode": "ISOLATED",
            //                     "isolatedMarginToken": "USDT",
            //                     "isolatedMarginAmount": 314.62426,
            //                     "isolatedFrozenLong": 0.0,
            //                     "isolatedFrozenShort": 0.0,
            //                     "leverage": 10
            //                 },
            //                 {
            //                     "symbol": "PERP_SOL_USDT",
            //                     "holding": -1.0,
            //                     "pendingLongQty": 0.0,
            //                     "pendingShortQty": 0.0,
            //                     "settlePrice": 141.89933923,
            //                     "averageOpenPrice": 171.38,
            //                     "pnl24H": 0.0,
            //                     "fee24H": 0.0,
            //                     "markPrice": 141.65155427,
            //                     "estLiqPrice": 4242.73548551,
            //                     "timestamp": 1720616702.68,
            //                     "adlQuantile": 5,
            //                     "positionSide": "BOTH",
            //                     "marginMode": "CROSS",
            //                     "isolatedMarginToken": "",
            //                     "isolatedMarginAmount": 0.0,
            //                     "isolatedFrozenLong": 0.0,
            //                     "isolatedFrozenShort": 0.0,
            //                     "leverage": 10
            //                 }
            //             ]
            //         },
            //         "timestamp": 1720628675078
            //     }
            //
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var positions interface{} = this.SafeList(result, "positions", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // v1PrivateGetPositionSymbol
    //     {
    //         "symbol": "PERP_ETH_USDT",
    //         "position_side": "BOTH",
    //         "leverage": 10,
    //         "margin_mode": "CROSS",
    //         "average_open_price": 3139.9,
    //         "isolated_margin_amount": 0.0,
    //         "isolated_margin_token": "",
    //         "opening_time": "1720627963.094",
    //         "mark_price": 3155.19169891,
    //         "pending_short_qty": 0.0,
    //         "pending_long_qty": 0.0,
    //         "holding": -0.7,
    //         "pnl_24_h": 0.0,
    //         "est_liq_price": 9107.40055552,
    //         "settle_price": 3151.0319904,
    //         "success": true,
    //         "fee_24_h": 0.0,
    //         "isolated_frozen_long": 0.0,
    //         "isolated_frozen_short": 0.0,
    //         "timestamp": "1720867502.544"
    //     }
    //
    // v3PrivateGetPositions
    //     {
    //         "symbol": "PERP_ETH_USDT",
    //         "holding": -1.0,
    //         "pendingLongQty": 0.0, // todo: check
    //         "pendingShortQty": 0.0, // todo: check
    //         "settlePrice": 3143.2,
    //         "averageOpenPrice": 3143.2,
    //         "pnl24H": 0.0, // todo: check
    //         "fee24H": 1.5716, // todo: check
    //         "markPrice": 3134.97984158,
    //         "estLiqPrice": 3436.176349,
    //         "timestamp": 1720628031.463,
    //         "adlQuantile": 5,
    //         "positionSide": "BOTH",
    //         "marginMode": "ISOLATED",
    //         "isolatedMarginToken": "USDT", // todo: check
    //         "isolatedMarginAmount": 314.62426, // todo: check
    //         "isolatedFrozenLong": 0.0, // todo: check
    //         "isolatedFrozenShort": 0.0, // todo: check
    //         "leverage": 10
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var contract interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(contract, market)
    var size interface{} = this.SafeString(position, "holding")
    var side interface{} = nil
    if IsTrue(Precise.StringGt(size, "0")) {
        side = "long"
    } else {
        side = "short"
    }
    var contractSize interface{} = this.SafeString(market, "contractSize")
    var markPrice interface{} = this.SafeString2(position, "markPrice", "mark_price")
    var timestamp interface{} = this.SafeTimestamp(position, "timestamp")
    var entryPrice interface{} = this.SafeString2(position, "averageOpenPrice", "average_open_price")
    var priceDifference interface{} = Precise.StringSub(markPrice, entryPrice)
    var unrealisedPnl interface{} = Precise.StringMul(priceDifference, size)
    size = Precise.StringAbs(size)
    var notional interface{} = Precise.StringMul(size, markPrice)
    var positionSide interface{} = this.SafeString(position, "positionSide") // 'SHORT' or 'LONG' for hedged, 'BOTH' for non-hedged
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "entryPrice": this.ParseNumber(entryPrice),
        "notional": this.ParseNumber(notional),
        "leverage": this.SafeNumber(position, "leverage"),
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(size),
        "contractSize": this.ParseNumber(contractSize),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber2(position, "estLiqPrice", "est_liq_price"),
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": this.SafeStringLower2(position, "marginMode", "margin_mode"),
        "side": side,
        "percentage": nil,
        "hedged": !IsEqual(positionSide, "BOTH"),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name woo#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://docs.woox.io/#get-quote-rfq
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35178 := (<-this.LoadMarkets())
            PanicOnError(retRes35178)
            var request interface{} = map[string]interface{} {
                "sellToken": ToUpper(fromCode),
                "buyToken": ToUpper(toCode),
                "sellQuantity": this.NumberToString(amount),
            }
        
            response:= (<-this.V3PrivateGetConvertRfq(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 123123123,
            //             "counterPartyId": "",
            //             "sellToken": "ETH",
            //             "sellQuantity": "0.0445",
            //             "buyToken": "USDT",
            //             "buyQuantity": "33.45",
            //             "buyPrice": "6.77",
            //             "expireTimestamp": 1659084466000,
            //             "message": 1659084466000
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fromCurrencyId interface{} = this.SafeString(data, "sellToken", fromCode)
            var fromCurrency interface{} = this.Currency(fromCurrencyId)
            var toCurrencyId interface{} = this.SafeString(data, "buyToken", toCode)
            var toCurrency interface{} = this.Currency(toCurrencyId)
        
            ch <- this.ParseConversion(data, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#createConvertTrade
 * @description convert from one currency to another
 * @see https://docs.woox.io/#send-quote-rft
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35618 := (<-this.LoadMarkets())
            PanicOnError(retRes35618)
            var request interface{} = map[string]interface{} {
                "quoteId": id,
            }
        
            response:= (<-this.V3PrivatePostConvertRft(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 123123123,
            //             "counterPartyId": "",
            //             "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseConversion(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchConvertTrade
 * @description fetch the data for a conversion trade
 * @see https://docs.woox.io/#get-quote-trade
 * @param {string} id the id of the trade that you want to fetch
 * @param {string} [code] the unified currency code of the conversion trade
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertTrade(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35918 := (<-this.LoadMarkets())
            PanicOnError(retRes35918)
            var request interface{} = map[string]interface{} {
                "quoteId": id,
            }
        
            response:= (<-this.V3PrivateGetConvertTrade(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "quoteId": 12,
            //             "buyAsset": "",
            //             "sellAsset": "",
            //             "buyAmount": 12.11,
            //             "sellAmount": 12.11,
            //             "tradeStatus": 12,
            //             "createdTime": ""
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fromCurrencyId interface{} = this.SafeString(data, "sellAsset")
            var toCurrencyId interface{} = this.SafeString(data, "buyAsset")
            var fromCurrency interface{} = nil
            var toCurrency interface{} = nil
            if IsTrue(!IsEqual(fromCurrencyId, nil)) {
                fromCurrency = this.Currency(fromCurrencyId)
            }
            if IsTrue(!IsEqual(toCurrencyId, nil)) {
                toCurrency = this.Currency(toCurrencyId)
            }
        
            ch <- this.ParseConversion(data, fromCurrency, toCurrency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name woo#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://docs.woox.io/#get-quote-trades
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
 */
func  (this *woo) FetchConvertTradeHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes36378 := (<-this.LoadMarkets())
            PanicOnError(retRes36378)
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.V3PrivateGetConvertTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "data": {
            //             "count": 12,
            //             "tradeVos":[
            //                 {
            //                     "quoteId": 12,
            //                     "buyAsset": "",
            //                     "sellAsset": "",
            //                     "buyAmount": 12.11,
            //                     "sellAmount": 12.11,
            //                     "tradeStatus": 12,
            //                     "createdTime": ""
            //                 }
            //                 ...
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "tradeVos", []interface{}{})
        
            ch <- this.ParseConversions(rows, code, "sellAsset", "buyAsset", since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *woo) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchConvertQuote
    //
    //     {
    //         "quoteId": 123123123,
    //         "counterPartyId": "",
    //         "sellToken": "ETH",
    //         "sellQuantity": "0.0445",
    //         "buyToken": "USDT",
    //         "buyQuantity": "33.45",
    //         "buyPrice": "6.77",
    //         "expireTimestamp": 1659084466000,
    //         "message": 1659084466000
    //     }
    //
    // createConvertTrade
    //
    //     {
    //         "quoteId": 123123123,
    //         "counterPartyId": "",
    //         "rftAccepted": 1 // 1 -> success; 2 -> processing; 3 -> fail
    //     }
    //
    // fetchConvertTrade, fetchConvertTradeHistory
    //
    //     {
    //         "quoteId": 12,
    //         "buyAsset": "",
    //         "sellAsset": "",
    //         "buyAmount": 12.11,
    //         "sellAmount": 12.11,
    //         "tradeStatus": 12,
    //         "createdTime": ""
    //     }
    //
    fromCurrency := GetArg(optionalArgs, 0, nil)
    _ = fromCurrency
    toCurrency := GetArg(optionalArgs, 1, nil)
    _ = toCurrency
    var timestamp interface{} = this.SafeInteger2(conversion, "expireTimestamp", "createdTime")
    var fromCurr interface{} = this.SafeString2(conversion, "sellToken", "buyAsset")
    var fromCode interface{} = this.SafeCurrencyCode(fromCurr, fromCurrency)
    var to interface{} = this.SafeString2(conversion, "buyToken", "sellAsset")
    var toCode interface{} = this.SafeCurrencyCode(to, toCurrency)
    return map[string]interface{} {
        "info": conversion,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(conversion, "quoteId"),
        "fromCurrency": fromCode,
        "fromAmount": this.SafeNumber2(conversion, "sellQuantity", "sellAmount"),
        "toCurrency": toCode,
        "toAmount": this.SafeNumber2(conversion, "buyQuantity", "buyAmount"),
        "price": this.SafeNumber(conversion, "buyPrice"),
        "fee": nil,
    }
}
/**
 * @method
 * @name woo#fetchConvertCurrencies
 * @description fetches all available currencies that can be converted
 * @see https://docs.woox.io/#get-quote-asset-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *woo) FetchConvertCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37368 := (<-this.LoadMarkets())
            PanicOnError(retRes37368)
        
            response:= (<-this.V3PrivateGetConvertAssetInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "rows": [
            //             {
            //                 "token": "BTC",
            //                 "tick": 0.0001,
            //                 "createdTime": "1575014248.99", // Unix epoch time in seconds
            //                 "updatedTime": "1575014248.99"  // Unix epoch time in seconds
            //             },
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var data interface{} = this.SafeList(response, "rows", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(entry, "token")
                var code interface{} = this.SafeCurrencyCode(id)
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "id": id,
            "code": code,
            "networks": nil,
            "type": nil,
            "name": nil,
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": this.SafeNumber(entry, "tick"),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "created": this.SafeTimestamp(entry, "createdTime"),
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *woo) DefaultNetworkCodeForCurrency(code interface{}) interface{}  {
    var currencyItem interface{} = this.Currency(code)
    var networks interface{} = GetValue(currencyItem, "networks")
    var networkKeys interface{} = ObjectKeys(networks)
    for i := 0; IsLessThan(i, GetArrayLength(networkKeys)); i++ {
        var network interface{} = GetValue(networkKeys, i)
        if IsTrue(IsEqual(network, "ETH")) {
            return network
        }
    }
    // if it was not returned according to above options, then return the first network of currency
    return this.SafeValue(networkKeys, 0)
}
func  (this *woo) SetSandboxMode(enable interface{})  {
    this.Exchange.SetSandboxMode(enable)
    AddElementToObject(this.Options, "sandboxMode", enable)
}


func (this *woo) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
