package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BitrueCore struct {
	Exchange
}

func NewBitrueCore() *BitrueCore {
	p := &BitrueCore{}
	setDefaults(p)
	return p
}

func (this *BitrueCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bitrue",
		"name":      "Bitrue",
		"countries": []interface{}{"SG"},
		"rateLimit": 10,
		"certified": false,
		"version":   "v1",
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                   nil,
			"spot":                                   true,
			"margin":                                 false,
			"swap":                                   true,
			"future":                                 false,
			"option":                                 false,
			"addMargin":                              false,
			"borrowCrossMargin":                      false,
			"borrowIsolatedMargin":                   false,
			"borrowMargin":                           false,
			"cancelAllOrders":                        true,
			"cancelOrder":                            true,
			"closeAllPositions":                      false,
			"closePosition":                          false,
			"createMarketBuyOrderWithCost":           true,
			"createMarketOrderWithCost":              false,
			"createMarketSellOrderWithCost":          false,
			"createOrder":                            true,
			"createOrderWithTakeProfitAndStopLoss":   false,
			"createOrderWithTakeProfitAndStopLossWs": false,
			"createReduceOnlyOrder":                  true,
			"createStopLimitOrder":                   true,
			"createStopMarketOrder":                  true,
			"createStopOrder":                        true,
			"fetchBalance":                           true,
			"fetchBidsAsks":                          true,
			"fetchBorrowInterest":                    false,
			"fetchBorrowRate":                        false,
			"fetchBorrowRateHistories":               false,
			"fetchBorrowRateHistory":                 false,
			"fetchBorrowRates":                       false,
			"fetchBorrowRatesPerSymbol":              false,
			"fetchClosedOrders":                      true,
			"fetchCrossBorrowRate":                   false,
			"fetchCrossBorrowRates":                  false,
			"fetchCurrencies":                        true,
			"fetchDepositAddress":                    false,
			"fetchDeposits":                          true,
			"fetchDepositsWithdrawals":               false,
			"fetchDepositWithdrawFee":                "emulated",
			"fetchDepositWithdrawFees":               true,
			"fetchFundingHistory":                    false,
			"fetchFundingInterval":                   false,
			"fetchFundingIntervals":                  false,
			"fetchFundingRate":                       false,
			"fetchFundingRateHistory":                false,
			"fetchFundingRates":                      false,
			"fetchGreeks":                            false,
			"fetchIndexOHLCV":                        false,
			"fetchIsolatedBorrowRate":                false,
			"fetchIsolatedBorrowRates":               false,
			"fetchIsolatedPositions":                 false,
			"fetchLeverage":                          false,
			"fetchLeverages":                         false,
			"fetchLeverageTiers":                     false,
			"fetchLiquidations":                      false,
			"fetchLongShortRatio":                    false,
			"fetchLongShortRatioHistory":             false,
			"fetchMarginAdjustmentHistory":           false,
			"fetchMarginMode":                        false,
			"fetchMarginModes":                       false,
			"fetchMarketLeverageTiers":               false,
			"fetchMarkets":                           true,
			"fetchMarkOHLCV":                         false,
			"fetchMarkPrices":                        false,
			"fetchMyLiquidations":                    false,
			"fetchMySettlementHistory":               false,
			"fetchMyTrades":                          true,
			"fetchOHLCV":                             true,
			"fetchOpenInterest":                      false,
			"fetchOpenInterestHistory":               false,
			"fetchOpenInterests":                     false,
			"fetchOpenOrders":                        true,
			"fetchOption":                            false,
			"fetchOptionChain":                       false,
			"fetchOrder":                             true,
			"fetchOrderBook":                         true,
			"fetchOrders":                            false,
			"fetchPosition":                          false,
			"fetchPositionHistory":                   false,
			"fetchPositionMode":                      false,
			"fetchPositions":                         false,
			"fetchPositionsHistory":                  false,
			"fetchPositionsRisk":                     false,
			"fetchPremiumIndexOHLCV":                 false,
			"fetchSettlementHistory":                 false,
			"fetchStatus":                            true,
			"fetchTicker":                            true,
			"fetchTickers":                           true,
			"fetchTime":                              true,
			"fetchTrades":                            true,
			"fetchTradingFee":                        false,
			"fetchTradingFees":                       false,
			"fetchTransactionFees":                   false,
			"fetchTransactions":                      false,
			"fetchTransfers":                         true,
			"fetchVolatilityHistory":                 false,
			"fetchWithdrawals":                       true,
			"reduceMargin":                           false,
			"repayCrossMargin":                       false,
			"repayIsolatedMargin":                    false,
			"setLeverage":                            true,
			"setMargin":                              true,
			"setMarginMode":                          false,
			"setPositionMode":                        false,
			"transfer":                               true,
			"withdraw":                               true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1H",
			"2h":  "2H",
			"4h":  "4H",
			"1d":  "1D",
			"1w":  "1W",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/67abe346-1273-461a-bd7c-42fa32907c8e",
			"api": map[string]interface{}{
				"spot":  "https://www.bitrue.com/api",
				"fapi":  "https://fapi.bitrue.com/fapi",
				"dapi":  "https://fapi.bitrue.com/dapi",
				"kline": "https://www.bitrue.com/kline-api",
			},
			"www":      "https://www.bitrue.com",
			"referral": "https://www.bitrue.com/affiliate/landing?cn=600000&inviteCode=EZWETQE",
			"doc":      []interface{}{"https://github.com/Bitrue-exchange/bitrue-official-api-docs", "https://www.bitrue.com/api-docs"},
			"fees":     "https://bitrue.zendesk.com/hc/en-001/articles/4405479952537",
		},
		"api": map[string]interface{}{
			"spot": map[string]interface{}{
				"kline": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"public.json":           0.24,
							"public{currency}.json": 0.24,
						},
					},
				},
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"ping":         0.24,
							"time":         0.24,
							"exchangeInfo": 0.24,
							"depth": map[string]interface{}{
								"cost":    1,
								"byLimit": []interface{}{[]interface{}{100, 0.24}, []interface{}{500, 1.2}, []interface{}{1000, 2.4}},
							},
							"trades":           0.24,
							"historicalTrades": 1.2,
							"aggTrades":        0.24,
							"ticker/24hr": map[string]interface{}{
								"cost":     0.24,
								"noSymbol": 9.6,
							},
							"ticker/price":      0.24,
							"ticker/bookTicker": 0.24,
							"market/kline":      0.24,
						},
					},
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"order":                  5,
							"openOrders":             5,
							"allOrders":              25,
							"account":                25,
							"myTrades":               25,
							"etf/net-value/{symbol}": 0.24,
							"withdraw/history":       120,
							"deposit/history":        120,
						},
						"post": map[string]interface{}{
							"order":           5,
							"withdraw/commit": 120,
						},
						"delete": map[string]interface{}{
							"order": 5,
						},
					},
				},
				"v2": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"myTrades": 1.2,
						},
					},
				},
			},
			"fapi": map[string]interface{}{
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"ping":      0.24,
							"time":      0.24,
							"contracts": 0.24,
							"depth":     0.24,
							"ticker":    0.24,
							"klines":    0.24,
						},
					},
				},
				"v2": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"myTrades":                 5,
							"openOrders":               5,
							"order":                    5,
							"account":                  5,
							"leverageBracket":          5,
							"commissionRate":           5,
							"futures_transfer_history": 5,
							"forceOrdersHistory":       5,
						},
						"post": map[string]interface{}{
							"positionMargin":   5,
							"level_edit":       5,
							"cancel":           5,
							"order":            25,
							"allOpenOrders":    5,
							"futures_transfer": 5,
						},
					},
				},
			},
			"dapi": map[string]interface{}{
				"v1": map[string]interface{}{
					"public": map[string]interface{}{
						"get": map[string]interface{}{
							"ping":      0.24,
							"time":      0.24,
							"contracts": 0.24,
							"depth":     0.24,
							"ticker":    0.24,
							"klines":    0.24,
						},
					},
				},
				"v2": map[string]interface{}{
					"private": map[string]interface{}{
						"get": map[string]interface{}{
							"myTrades":                 5,
							"openOrders":               5,
							"order":                    5,
							"account":                  5,
							"leverageBracket":          5,
							"commissionRate":           5,
							"futures_transfer_history": 5,
							"forceOrdersHistory":       5,
						},
						"post": map[string]interface{}{
							"positionMargin":   5,
							"level_edit":       5,
							"cancel":           5,
							"order":            5,
							"allOpenOrders":    5,
							"futures_transfer": 5,
						},
					},
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"feeSide":    "get",
				"tierBased":  false,
				"percentage": true,
				"taker":      this.ParseNumber("0.00098"),
				"maker":      this.ParseNumber("0.00098"),
			},
			"future": map[string]interface{}{
				"trading": map[string]interface{}{
					"feeSide":    "quote",
					"tierBased":  true,
					"percentage": true,
					"taker":      this.ParseNumber("0.000400"),
					"maker":      this.ParseNumber("0.000200"),
					"tiers": map[string]interface{}{
						"taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.000400")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.000400")}, []interface{}{this.ParseNumber("2500"), this.ParseNumber("0.000350")}, []interface{}{this.ParseNumber("7500"), this.ParseNumber("0.000320")}, []interface{}{this.ParseNumber("22500"), this.ParseNumber("0.000300")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.000270")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.000250")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("0.000220")}, []interface{}{this.ParseNumber("400000"), this.ParseNumber("0.000200")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.000170")}},
						"maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.000200")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.000160")}, []interface{}{this.ParseNumber("2500"), this.ParseNumber("0.000140")}, []interface{}{this.ParseNumber("7500"), this.ParseNumber("0.000120")}, []interface{}{this.ParseNumber("22500"), this.ParseNumber("0.000100")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.000080")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.000060")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("0.000040")}, []interface{}{this.ParseNumber("400000"), this.ParseNumber("0.000020")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0")}},
					},
				},
			},
			"delivery": map[string]interface{}{
				"trading": map[string]interface{}{
					"feeSide":    "base",
					"tierBased":  true,
					"percentage": true,
					"taker":      this.ParseNumber("0.000500"),
					"maker":      this.ParseNumber("0.000100"),
					"tiers": map[string]interface{}{
						"taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.000500")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.000450")}, []interface{}{this.ParseNumber("2500"), this.ParseNumber("0.000400")}, []interface{}{this.ParseNumber("7500"), this.ParseNumber("0.000300")}, []interface{}{this.ParseNumber("22500"), this.ParseNumber("0.000250")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.000240")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.000240")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("0.000240")}, []interface{}{this.ParseNumber("400000"), this.ParseNumber("0.000240")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.000240")}},
						"maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.000100")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.000080")}, []interface{}{this.ParseNumber("2500"), this.ParseNumber("0.000050")}, []interface{}{this.ParseNumber("7500"), this.ParseNumber("0.0000030")}, []interface{}{this.ParseNumber("22500"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("-0.000050")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("-0.000060")}, []interface{}{this.ParseNumber("200000"), this.ParseNumber("-0.000070")}, []interface{}{this.ParseNumber("400000"), this.ParseNumber("-0.000080")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("-0.000090")}},
					},
				},
			},
		},
		"options": map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": true,
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "linear", "inverse"},
			},
			"fetchMyTradesMethod":                 "v2PrivateGetMyTrades",
			"hasAlreadyAuthenticatedSuccessfully": false,
			"currencyToPrecisionRoundingMode":     TRUNCATE,
			"recvWindow":                          Multiply(5, 1000),
			"timeDifference":                      0,
			"adjustForTimeDifference":             false,
			"parseOrderToPrecision":               false,
			"newOrderRespType": map[string]interface{}{
				"market": "FULL",
				"limit":  "FULL",
			},
			"networks": map[string]interface{}{
				"ERC20":            "ETH",
				"TRC20":            "TRX",
				"AETERNITY":        "Aeternity",
				"AION":             "AION",
				"ALGO":             "Algorand",
				"ASK":              "ASK",
				"ATOM":             "ATOM",
				"AVAXC":            "AVAX C-Chain",
				"BCH":              "BCH",
				"BEP2":             "BEP2",
				"BEP20":            "BEP20",
				"Bitcoin":          "Bitcoin",
				"BRP20":            "BRP20",
				"ADA":              "Cardano",
				"CASINOCOIN":       "CasinoCoin",
				"CASINOCOIN-XRPL":  "CasinoCoin XRPL",
				"CONTENTOS":        "Contentos",
				"DASH":             "Dash",
				"DECOIN":           "Decoin",
				"DFI":              "DeFiChain",
				"DGB":              "DGB",
				"DIVI":             "Divi",
				"DOGE":             "dogecoin",
				"EOS":              "EOS",
				"ETC":              "ETC",
				"FILECOIN":         "Filecoin",
				"FREETON":          "FREETON",
				"HBAR":             "HBAR",
				"HEDERA":           "Hedera Hashgraph",
				"HRC20":            "HRC20",
				"ICON":             "ICON",
				"ICP":              "ICP",
				"IGNIS":            "Ignis",
				"INTERNETCOMPUTER": "Internet Computer",
				"IOTA":             "IOTA",
				"KAVA":             "KAVA",
				"KSM":              "KSM",
				"LTC":              "LiteCoin",
				"LUNA":             "Luna",
				"MATIC":            "MATIC",
				"MOBILECOIN":       "Mobile Coin",
				"MONACOIN":         "MonaCoin",
				"XMR":              "Monero",
				"NEM":              "NEM",
				"NEP5":             "NEP5",
				"OMNI":             "OMNI",
				"PAC":              "PAC",
				"DOT":              "Polkadot",
				"RAVEN":            "Ravencoin",
				"SAFEX":            "Safex",
				"SOL":              "SOLANA",
				"SGB":              "Songbird",
				"XML":              "Stellar Lumens",
				"XYM":              "Symbol",
				"XTZ":              "Tezos",
				"theta":            "theta",
				"THETA":            "THETA",
				"VECHAIN":          "VeChain",
				"WANCHAIN":         "Wanchain",
				"XINFIN":           "XinFin Network",
				"XRP":              "XRP",
				"XRPL":             "XRPL",
				"ZIL":              "ZIL",
			},
			"defaultType": "spot",
			"timeframes": map[string]interface{}{
				"spot": map[string]interface{}{
					"1m":  "1m",
					"5m":  "5m",
					"15m": "15m",
					"30m": "30m",
					"1h":  "1H",
					"2h":  "2H",
					"4h":  "4H",
					"12h": "12H",
					"1d":  "1D",
					"1w":  "1W",
				},
				"future": map[string]interface{}{
					"1m":  "1min",
					"5m":  "5min",
					"15m": "15min",
					"30m": "30min",
					"1h":  "1h",
					"1d":  "1day",
					"1w":  "1week",
					"1M":  "1month",
				},
			},
			"accountsByType": map[string]interface{}{
				"spot":     "wallet",
				"future":   "contract",
				"swap":     "contract",
				"funding":  "wallet",
				"fund":     "wallet",
				"contract": "contract",
			},
		},
		"commonCurrencies": map[string]interface{}{
			"MIM": "MIM Swarm",
		},
		"precisionMode": TICK_SIZE,
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           nil,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyRequiresPrice": true,
					"marketBuyByCost":        true,
					"selfTradePrevention":    false,
					"iceberg":                true,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       100000,
					"untilDays":      100000,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            1000,
					"daysBack":         90,
					"daysBackCanceled": 1,
					"untilDays":        90,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1440,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"forDerivatives": map[string]interface{}{
				"extends": "default",
				"createOrder": map[string]interface{}{
					"marginMode":             true,
					"leverage":               true,
					"marketBuyRequiresPrice": false,
					"marketBuyByCost":        false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 300,
				},
				"fetchClosedOrders": nil,
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forDerivatives",
				},
				"inverse": map[string]interface{}{
					"extends": "forDerivatives",
				},
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"System is under maintenance.":                           OnMaintenance,
				"System abnormality":                                     ExchangeError,
				"You are not authorized to execute this request.":        PermissionDenied,
				"API key does not exist":                                 AuthenticationError,
				"Order would trigger immediately.":                       OrderImmediatelyFillable,
				"Stop price would trigger immediately.":                  OrderImmediatelyFillable,
				"Order would immediately match and take.":                OrderImmediatelyFillable,
				"Account has insufficient balance for requested action.": InsufficientFunds,
				"Rest API trading is not enabled.":                       ExchangeNotAvailable,
				"You don\\'t have permission.":                           PermissionDenied,
				"Market is closed.":                                      ExchangeNotAvailable,
				"Too many requests. Please try again later.":             DDoSProtection,
				"-1000":  ExchangeNotAvailable,
				"-1001":  ExchangeNotAvailable,
				"-1002":  AuthenticationError,
				"-1003":  RateLimitExceeded,
				"-1013":  InvalidOrder,
				"-1015":  RateLimitExceeded,
				"-1016":  ExchangeNotAvailable,
				"-1020":  BadRequest,
				"-1021":  InvalidNonce,
				"-1022":  AuthenticationError,
				"-1100":  BadRequest,
				"-1101":  BadRequest,
				"-1102":  BadRequest,
				"-1103":  BadRequest,
				"-1104":  BadRequest,
				"-1105":  BadRequest,
				"-1106":  BadRequest,
				"-1111":  BadRequest,
				"-1112":  InvalidOrder,
				"-1114":  BadRequest,
				"-1115":  BadRequest,
				"-1116":  BadRequest,
				"-1117":  BadRequest,
				"-1166":  InvalidOrder,
				"-1118":  BadRequest,
				"-1119":  BadRequest,
				"-1120":  BadRequest,
				"-1121":  BadSymbol,
				"-1125":  AuthenticationError,
				"-1127":  BadRequest,
				"-1128":  BadRequest,
				"-1130":  BadRequest,
				"-1131":  BadRequest,
				"-1160":  InvalidOrder,
				"-1156":  InvalidOrder,
				"-2008":  AuthenticationError,
				"-2010":  ExchangeError,
				"-2011":  OrderNotFound,
				"-2013":  OrderNotFound,
				"-2014":  AuthenticationError,
				"-2015":  AuthenticationError,
				"-2017":  InsufficientFunds,
				"-2019":  InsufficientFunds,
				"-3005":  InsufficientFunds,
				"-3006":  InsufficientFunds,
				"-3008":  InsufficientFunds,
				"-3010":  ExchangeError,
				"-3015":  ExchangeError,
				"-3022":  AccountSuspended,
				"-4028":  BadRequest,
				"-3020":  InsufficientFunds,
				"-3041":  InsufficientFunds,
				"-5013":  InsufficientFunds,
				"-11008": InsufficientFunds,
				"-4051":  InsufficientFunds,
			},
			"broad": map[string]interface{}{
				"Insufficient account balance": InsufficientFunds,
				"has no operation privilege":   PermissionDenied,
				"MAX_POSITION":                 InvalidOrder,
			},
		},
	})
}
func (this *BitrueCore) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}

/**
 * @method
 * @name bitrue#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#test-connectivity
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *BitrueCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SpotV1PublicGetPing(params))
		PanicOnError(response)
		//
		// empty means working status.
		//
		//     {}
		//
		var keys interface{} = ObjectKeys(response)
		var keysLength interface{} = GetArrayLength(keys)
		var formattedStatus interface{} = Ternary(IsTrue(keysLength), "maintenance", "ok")

		ch <- map[string]interface{}{
			"status":  formattedStatus,
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *BitrueCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SpotV1PublicGetTime(params))
		PanicOnError(response)

		//
		//     {
		//         "serverTime":1635467280514
		//     }
		//
		ch <- this.SafeInteger(response, "serverTime")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *BitrueCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SpotV1PublicGetExchangeInfo(params))
		PanicOnError(response)
		//
		//     {
		//         "timezone":"CTT",
		//         "serverTime":1635464889117,
		//         "rateLimits":[
		//             {"rateLimitType":"REQUESTS_WEIGHT","interval":"MINUTES","limit":6000},
		//             {"rateLimitType":"ORDERS","interval":"SECONDS","limit":150},
		//             {"rateLimitType":"ORDERS","interval":"DAYS","limit":288000},
		//         ],
		//         "exchangeFilters":[],
		//         "symbols":[
		//             {
		//                 "symbol":"SHABTC",
		//                 "status":"TRADING",
		//                 "baseAsset":"sha",
		//                 "baseAssetPrecision":0,
		//                 "quoteAsset":"btc",
		//                 "quotePrecision":10,
		//                 "orderTypes":["MARKET","LIMIT"],
		//                 "icebergAllowed":false,
		//                 "filters":[
		//                     {"filterType":"PRICE_FILTER","minPrice":"0.00000001349","maxPrice":"0.00000017537","priceScale":10},
		//                     {"filterType":"LOT_SIZE","minQty":"1.0","minVal":"0.00020","maxQty":"1000000000","volumeScale":0},
		//                 ],
		//                 "defaultPrice":"0.0000006100",
		//             },
		//         ],
		//         "coins":[
		//           {
		//               "coin": "near",
		//               "coinFulName": "NEAR Protocol",
		//               "chains": [ "BEP20", ],
		//               "chainDetail": [
		//                 {
		//                     "chain": "BEP20",
		//                     "enableWithdraw": true,
		//                     "enableDeposit": true,
		//                     "withdrawFee": "0.2000",
		//                     "minWithdraw": "5.0000",
		//                     "maxWithdraw": "1000000000000000.0000",
		//                 },
		//               ],
		//           },
		//         ],
		//     }
		//
		var result interface{} = map[string]interface{}{}
		var coins interface{} = this.SafeList(response, "coins", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(coins)); i++ {
			var currency interface{} = GetValue(coins, i)
			var id interface{} = this.SafeString(currency, "coin")
			var name interface{} = this.SafeString(currency, "coinFulName")
			var code interface{} = this.SafeCurrencyCode(id)
			var networkDetails interface{} = this.SafeList(currency, "chainDetail", []interface{}{})
			var networks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(networkDetails)); j++ {
				var entry interface{} = GetValue(networkDetails, j)
				var networkId interface{} = this.SafeString(entry, "chain")
				var network interface{} = this.NetworkIdToCode(networkId, code)
				AddElementToObject(networks, network, map[string]interface{}{
					"info":      entry,
					"id":        networkId,
					"network":   network,
					"deposit":   this.SafeBool(entry, "enableDeposit"),
					"withdraw":  this.SafeBool(entry, "enableWithdraw"),
					"active":    nil,
					"fee":       this.SafeNumber(entry, "withdrawFee"),
					"precision": nil,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(entry, "minWithdraw"),
							"max": this.SafeNumber(entry, "maxWithdraw"),
						},
					},
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        id,
				"name":      name,
				"code":      code,
				"precision": nil,
				"info":      currency,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"networks":  networks,
				"fee":       nil,
				"fees":      nil,
				"type":      "crypto",
				"limits": map[string]interface{}{
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchMarkets
 * @description retrieves data on all markets for bitrue
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#exchangeInfo_endpoint
 * @see https://www.bitrue.com/api-docs#current-open-contract
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#current-open-contract
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *BitrueCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var promisesRaw interface{} = []interface{}{}
		var types interface{} = nil
		var defaultTypes interface{} = []interface{}{"spot", "linear", "inverse"}
		var fetchMarketsOptions interface{} = this.SafeDict(this.Options, "fetchMarkets")
		if IsTrue(!IsEqual(fetchMarketsOptions, nil)) {
			types = this.SafeList(fetchMarketsOptions, "types", defaultTypes)
		} else {
			// for backward-compatibility
			types = this.SafeList(this.Options, "fetchMarkets", defaultTypes)
		}
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			var marketType interface{} = GetValue(types, i)
			if IsTrue(IsEqual(marketType, "spot")) {
				AppendToArray(&promisesRaw, this.SpotV1PublicGetExchangeInfo(params))
			} else if IsTrue(IsEqual(marketType, "linear")) {
				AppendToArray(&promisesRaw, this.FapiV1PublicGetContracts(params))
			} else if IsTrue(IsEqual(marketType, "inverse")) {
				AppendToArray(&promisesRaw, this.DapiV1PublicGetContracts(params))
			} else {
				panic(ExchangeError(Add(Add(Add(this.Id, " fetchMarkets() this.options fetchMarkets \""), marketType), "\" is not a supported market type")))
			}
		}

		promises := (<-promiseAll(promisesRaw))
		PanicOnError(promises)
		var spotMarkets interface{} = this.SafeValue(this.SafeValue(promises, 0), "symbols", []interface{}{})
		var futureMarkets interface{} = this.SafeValue(promises, 1)
		var deliveryMarkets interface{} = this.SafeValue(promises, 2)
		var markets interface{} = spotMarkets
		markets = this.ArrayConcat(markets, futureMarkets)
		markets = this.ArrayConcat(markets, deliveryMarkets)
		//
		// spot
		//
		//     {
		//         "timezone":"CTT",
		//         "serverTime":1635464889117,
		//         "rateLimits":[
		//             {"rateLimitType":"REQUESTS_WEIGHT","interval":"MINUTES","limit":6000},
		//             {"rateLimitType":"ORDERS","interval":"SECONDS","limit":150},
		//             {"rateLimitType":"ORDERS","interval":"DAYS","limit":288000},
		//         ],
		//         "exchangeFilters":[],
		//         "symbols":[
		//             {
		//                 "symbol":"SHABTC",
		//                 "status":"TRADING",
		//                 "baseAsset":"sha",
		//                 "baseAssetPrecision":0,
		//                 "quoteAsset":"btc",
		//                 "quotePrecision":10,
		//                 "orderTypes":["MARKET","LIMIT"],
		//                 "icebergAllowed":false,
		//                 "filters":[
		//                     {"filterType":"PRICE_FILTER","minPrice":"0.00000001349","maxPrice":"0.00000017537","priceScale":10},
		//                     {"filterType":"LOT_SIZE","minQty":"1.0","minVal":"0.00020","maxQty":"1000000000","volumeScale":0},
		//                 ],
		//                 "defaultPrice":"0.0000006100",
		//             },
		//         ],
		//         "coins":[
		//             {
		//                 "coin":"sbr",
		//                 "coinFulName":"Saber",
		//                 "enableWithdraw":true,
		//                 "enableDeposit":true,
		//                 "chains":["SOLANA"],
		//                 "withdrawFee":"2.0",
		//                 "minWithdraw":"5.0",
		//                 "maxWithdraw":"1000000000000000",
		//             },
		//         ],
		//     }
		//
		// swap / delivery
		//
		//     [
		//         {
		//           "symbol": "H-HT-USDT",
		//           "pricePrecision": 8,
		//           "side": 1,
		//           "maxMarketVolume": 100000,
		//           "multiplier": 6,
		//           "minOrderVolume": 1,
		//           "maxMarketMoney": 10000000,
		//           "type": "H", // E: perpetual contract, S: test contract, others are mixed contract
		//           "maxLimitVolume": 1000000,
		//           "maxValidOrder": 20,
		//           "multiplierCoin": "HT",
		//           "minOrderMoney": 0.001,
		//           "maxLimitMoney": 1000000,
		//           "status": 1
		//         }
		//     ]
		//
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes92812 := (<-this.LoadTimeDifference())
			PanicOnError(retRes92812)
		}

		ch <- this.ParseMarkets(markets)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseMarket(market interface{}) interface{} {
	var id interface{} = this.SafeString(market, "symbol")
	var lowercaseId interface{} = this.SafeStringLower(market, "symbol")
	var side interface{} = this.SafeInteger(market, "side") // 1 linear, 0 inverse, undefined spot
	var typeVar interface{} = nil
	var isLinear interface{} = nil
	var isInverse interface{} = nil
	if IsTrue(IsEqual(side, nil)) {
		typeVar = "spot"
	} else {
		typeVar = "swap"
		isLinear = (IsEqual(side, 1))
		isInverse = (IsEqual(side, 0))
	}
	var isContract interface{} = (!IsEqual(typeVar, "spot"))
	var baseId interface{} = this.SafeString(market, "baseAsset")
	var quoteId interface{} = this.SafeString(market, "quoteAsset")
	var settleId interface{} = nil
	var settle interface{} = nil
	if IsTrue(isContract) {
		var symbolSplit interface{} = Split(id, "-")
		baseId = this.SafeString(symbolSplit, 1)
		quoteId = this.SafeString(symbolSplit, 2)
		if IsTrue(isLinear) {
			settleId = quoteId
		} else {
			settleId = baseId
		}
		settle = this.SafeCurrencyCode(settleId)
	}
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	if IsTrue(!IsEqual(settle, nil)) {
		symbol = Add(symbol, Add(":", settle))
	}
	var filters interface{} = this.SafeList(market, "filters", []interface{}{})
	var filtersByType interface{} = this.IndexBy(filters, "filterType")
	var status interface{} = this.SafeString(market, "status")
	var priceFilter interface{} = this.SafeDict(filtersByType, "PRICE_FILTER", map[string]interface{}{})
	var amountFilter interface{} = this.SafeDict(filtersByType, "LOT_SIZE", map[string]interface{}{})
	var defaultPricePrecision interface{} = this.SafeString(market, "pricePrecision")
	var defaultAmountPrecision interface{} = this.SafeString(market, "quantityPrecision")
	var pricePrecision interface{} = this.SafeString(priceFilter, "priceScale", defaultPricePrecision)
	var amountPrecision interface{} = this.SafeString(amountFilter, "volumeScale", defaultAmountPrecision)
	var multiplier interface{} = this.SafeString(market, "multiplier")
	var maxQuantity interface{} = this.SafeNumber(amountFilter, "maxQty")
	if IsTrue(IsEqual(maxQuantity, nil)) {
		maxQuantity = this.SafeNumber(market, "maxValidOrder")
	}
	var minCost interface{} = this.SafeNumber(amountFilter, "minVal")
	if IsTrue(IsEqual(minCost, nil)) {
		minCost = this.SafeNumber(market, "minOrderMoney")
	}
	return map[string]interface{}{
		"id":             id,
		"lowercaseId":    lowercaseId,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           typeVar,
		"spot":           (IsEqual(typeVar, "spot")),
		"margin":         false,
		"swap":           isContract,
		"future":         false,
		"option":         false,
		"active":         (IsEqual(status, "TRADING")),
		"contract":       isContract,
		"linear":         isLinear,
		"inverse":        isInverse,
		"contractSize":   this.ParseNumber(Precise.StringAbs(multiplier)),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": this.ParseNumber(this.ParsePrecision(amountPrecision)),
			"price":  this.ParseNumber(this.ParsePrecision(pricePrecision)),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"amount": map[string]interface{}{
				"min": this.SafeNumber(amountFilter, "minQty"),
				"max": maxQuantity,
			},
			"price": map[string]interface{}{
				"min": this.SafeNumber(priceFilter, "minPrice"),
				"max": this.SafeNumber(priceFilter, "maxPrice"),
			},
			"cost": map[string]interface{}{
				"min": minCost,
				"max": nil,
			},
		},
		"created": nil,
		"info":    market,
	}
}
func (this *BitrueCore) ParseBalance(response interface{}) interface{} {
	//
	// spot
	//
	//     {
	//         "makerCommission":0,
	//         "takerCommission":0,
	//         "buyerCommission":0,
	//         "sellerCommission":0,
	//         "updateTime":null,
	//         "balances":[
	//             {"asset":"sbr","free":"0","locked":"0"},
	//             {"asset":"ksm","free":"0","locked":"0"},
	//             {"asset":"neo3s","free":"0","locked":"0"},
	//         ],
	//         "canTrade":false,
	//         "canWithdraw":false,
	//         "canDeposit":false
	//     }
	//
	// swap
	//
	//     {
	//         "account":[
	//             {
	//                 "marginCoin":"USDT",
	//                 "coinPrecious":4,
	//                 "accountNormal":1010.4043400372839856,
	//                 "accountLock":2.9827889600000006,
	//                 "partPositionNormal":0,
	//                 "totalPositionNormal":0,
	//                 "achievedAmount":0,
	//                 "unrealizedAmount":0,
	//                 "totalMarginRate":0,
	//                 "totalEquity":1010.4043400372839856,
	//                 "partEquity":0,
	//                 "totalCost":0,
	//                 "sumMarginRate":0,
	//                 "sumOpenRealizedAmount":0,
	//                 "canUseTrialFund":0,
	//                 "sumMaintenanceMargin":null,
	//                 "futureModel":null,
	//                 "positionVos":[]
	//             }
	//         ]
	//     }
	//
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	var timestamp interface{} = this.SafeInteger(response, "updateTime")
	var balances interface{} = this.SafeValue2(response, "balances", "account", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var currencyId interface{} = this.SafeString2(balance, "asset", "marginCoin")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		AddElementToObject(account, "free", this.SafeString2(balance, "free", "accountNormal"))
		AddElementToObject(account, "used", this.SafeString2(balance, "locked", "accountLock"))
		AddElementToObject(result, code, account)
	}
	AddElementToObject(result, "timestamp", timestamp)
	AddElementToObject(result, "datetime", this.Iso8601(timestamp))
	return this.SafeBalance(result)
}

/**
 * @method
 * @name bitrue#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#account-information-user_data
 * @see https://www.bitrue.com/api-docs#account-information-v2-user_data-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#account-information-v2-user_data-hmac-sha256
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'future', 'delivery', 'spot', 'swap'
 * @param {string} [params.subType] 'linear', 'inverse'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *BitrueCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes11188 := (<-this.LoadMarkets())
		PanicOnError(retRes11188)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchBalance", nil, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var response interface{} = nil
		var result interface{} = nil
		if IsTrue(IsEqual(typeVar, "swap")) {
			if IsTrue(IsTrue(!IsEqual(subType, nil)) && IsTrue(IsEqual(subType, "inverse"))) {

				response = (<-this.DapiV2PrivateGetAccount(params))
				PanicOnError(response)
				result = this.SafeDict(response, "data", map[string]interface{}{})
			} else {

				response = (<-this.FapiV2PrivateGetAccount(params))
				PanicOnError(response)
				result = this.SafeDict(response, "data", map[string]interface{}{})
			}
		} else {

			response = (<-this.SpotV1PrivateGetAccount(params))
			PanicOnError(response)
			result = response
		}

		ch <- this.ParseBalance(result)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#order-book
 * @see https://www.bitrue.com/api-docs#order-book
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *BitrueCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes12308 := (<-this.LoadMarkets())
		PanicOnError(retRes12308)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			var request interface{} = map[string]interface{}{
				"contractName": GetValue(market, "id"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				if IsTrue(IsGreaterThan(limit, 100)) {
					limit = 100
				}
				AddElementToObject(request, "limit", limit) // default 100, max 100, see https://www.bitrue.com/api-docs#order-book
			}
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV1PublicGetDepth(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV1PublicGetDepth(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "spot")) {
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				if IsTrue(IsGreaterThan(limit, 1000)) {
					limit = 1000
				}
				AddElementToObject(request, "limit", limit) // default 100, max 1000, see https://github.com/Bitrue-exchange/bitrue-official-api-docs#order-book
			}

			response = (<-this.SpotV1PublicGetDepth(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchOrderBook only support spot & swap markets")))
		}
		//
		// spot
		//
		//     {
		//         "lastUpdateId":1635474910177,
		//         "bids":[
		//             ["61436.84","0.05",[]],
		//             ["61435.77","0.0124",[]],
		//             ["61434.88","0.012",[]],
		//         ],
		//         "asks":[
		//             ["61452.46","0.0001",[]],
		//             ["61452.47","0.0597",[]],
		//             ["61452.76","0.0713",[]],
		//         ]
		//     }
		//
		// swap
		//
		//     {
		//         "asks": [[34916.5, 2582], [34916.6, 2193], [34916.7, 2629], [34916.8, 3478], [34916.9, 2718]],
		//         "bids": [[34916.4, 92065], [34916.3, 25703], [34916.2, 37259], [34916.1, 26446], [34916, 44456]],
		//         "time": 1699338305000
		//     }
		//
		var timestamp interface{} = this.SafeInteger2(response, "time", "lastUpdateId")
		var orderbook interface{} = this.ParseOrderBook(response, symbol, timestamp)
		AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))

		ch <- orderbook
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchBidsAsks
	//
	//     {
	//         "symbol": "LTCBTC",
	//         "bidPrice": "4.00000000",
	//         "bidQty": "431.00000000",
	//         "askPrice": "4.00000200",
	//         "askQty": "9.00000000"
	//     }
	//
	// fetchTicker
	//
	//     {
	//         "symbol": "BNBBTC",
	//         "priceChange": "0.000248",
	//         "priceChangePercent": "3.5500",
	//         "weightedAvgPrice": null,
	//         "prevClosePrice": null,
	//         "lastPrice": "0.007226",
	//         "lastQty": null,
	//         "bidPrice": "0.007208",
	//         "askPrice": "0.007240",
	//         "openPrice": "0.006978",
	//         "highPrice": "0.007295",
	//         "lowPrice": "0.006935",
	//         "volume": "11749.86",
	//         "quoteVolume": "84.1066211",
	//         "openTime": 0,
	//         "closeTime": 0,
	//         "firstId": 0,
	//         "lastId": 0,
	//         "count": 0
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var symbol interface{} = this.SafeSymbol(nil, market)
	var last interface{} = this.SafeString2(ticker, "lastPrice", "last")
	var timestamp interface{} = this.SafeInteger(ticker, "time")
	var percentage interface{} = nil
	if IsTrue(GetValue(market, "swap")) {
		percentage = Precise.StringMul(this.SafeString(ticker, "rose"), "100")
	} else {
		percentage = this.SafeString(ticker, "priceChangePercent")
	}
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString2(ticker, "highPrice", "high"),
		"low":           this.SafeString2(ticker, "lowPrice", "low"),
		"bid":           this.SafeString2(ticker, "bidPrice", "buy"),
		"bidVolume":     this.SafeString(ticker, "bidQty"),
		"ask":           this.SafeString2(ticker, "askPrice", "sell"),
		"askVolume":     this.SafeString(ticker, "askQty"),
		"vwap":          this.SafeString(ticker, "weightedAvgPrice"),
		"open":          this.SafeString(ticker, "openPrice"),
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        this.SafeString(ticker, "priceChange"),
		"percentage":    percentage,
		"average":       nil,
		"baseVolume":    this.SafeString2(ticker, "volume", "vol"),
		"quoteVolume":   this.SafeString(ticker, "quoteVolume"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name bitrue#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#24hr-ticker-price-change-statistics
 * @see https://www.bitrue.com/api-docs#ticker
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BitrueCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes13748 := (<-this.LoadMarkets())
		PanicOnError(retRes13748)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			var request interface{} = map[string]interface{}{
				"contractName": GetValue(market, "id"),
			}
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV1PublicGetTicker(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV1PublicGetTicker(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = response
		} else if IsTrue(GetValue(market, "spot")) {
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}

			response = (<-this.SpotV1PublicGetTicker24hr(this.Extend(request, params)))
			PanicOnError(response)
			data = this.SafeDict(response, 0, map[string]interface{}{})
		} else {
			panic(NotSupported(Add(this.Id, " fetchTicker only support spot & swap markets")))
		}

		//
		// spot
		//
		//     [{
		//         symbol: 'BTCUSDT',
		//         priceChange: '105.20',
		//         priceChangePercent: '0.3000',
		//         weightedAvgPrice: null,
		//         prevClosePrice: null,
		//         lastPrice: '34905.21',
		//         lastQty: null,
		//         bidPrice: '34905.21',
		//         askPrice: '34905.22',
		//         openPrice: '34800.01',
		//         highPrice: '35276.33',
		//         lowPrice: '34787.51',
		//         volume: '12549.6481',
		//         quoteVolume: '439390492.917',
		//         openTime: '0',
		//         closeTime: '0',
		//         firstId: '0',
		//         lastId: '0',
		//         count: '0'
		//     }]
		//
		// swap
		//
		//     {
		//         "high": "35296",
		//         "vol": "779308354",
		//         "last": "34884.1",
		//         "low": "34806.7",
		//         "buy": 34883.9,
		//         "sell": 34884,
		//         "rose": "-0.0027957315",
		//         "time": 1699348013000
		//     }
		//
		ch <- this.ParseTicker(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#kline-data
 * @see https://www.bitrue.com/api_docs_includes_file/futures/index.html#kline-candlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *BitrueCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14538 := (<-this.LoadMarkets())
		PanicOnError(retRes14538)
		var market interface{} = this.Market(symbol)
		var timeframes interface{} = this.SafeDict(this.Options, "timeframes", map[string]interface{}{})
		var response interface{} = nil
		var data interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			var timeframesFuture interface{} = this.SafeDict(timeframes, "future", map[string]interface{}{})
			var request interface{} = map[string]interface{}{
				"contractName": GetValue(market, "id"),
				"interval":     this.SafeString(timeframesFuture, timeframe, "1min"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV1PublicGetKlines(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV1PublicGetKlines(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = response
		} else if IsTrue(GetValue(market, "spot")) {
			var timeframesSpot interface{} = this.SafeDict(timeframes, "spot", map[string]interface{}{})
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
				"scale":  this.SafeString(timeframesSpot, timeframe, "1m"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			var until interface{} = this.SafeInteger(params, "until")
			if IsTrue(!IsEqual(until, nil)) {
				params = this.Omit(params, "until")
				AddElementToObject(request, "fromIdx", until)
			}

			response = (<-this.SpotV1PublicGetMarketKline(this.Extend(request, params)))
			PanicOnError(response)
			data = this.SafeList(response, "data", []interface{}{})
		} else {
			panic(NotSupported(Add(this.Id, " fetchOHLCV only support spot & swap markets")))
		}

		//
		// spot
		//
		//       {
		//           "symbol":"BTCUSDT",
		//           "scale":"KLINE_1MIN",
		//           "data":[
		//                {
		//                   "i":"1660825020",
		//                   "a":"93458.778",
		//                   "v":"3.9774",
		//                   "c":"23494.99",
		//                   "h":"23509.63",
		//                   "l":"23491.93",
		//                   "o":"23508.34"
		//                }
		//           ]
		//       }
		//
		// swap
		//
		//     [
		//         {
		//           "high": "35360.7",
		//           "vol": "110288",
		//           "low": "35347.9",
		//           "idx": 1699411680000,
		//           "close": "35347.9",
		//           "open": "35349.4"
		//         }
		//     ]
		//
		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	//
	//      {
	//         "i":"1660825020",
	//         "a":"93458.778",
	//         "v":"3.9774",
	//         "c":"23494.99",
	//         "h":"23509.63",
	//         "l":"23491.93",
	//         "o":"23508.34"
	//      }
	//
	// swap
	//
	//     {
	//         "high": "35360.7",
	//         "vol": "110288",
	//         "low": "35347.9",
	//         "idx": 1699411680000,
	//         "close": "35347.9",
	//         "open": "35349.4"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeTimestamp(ohlcv, "i")
	if IsTrue(IsEqual(timestamp, nil)) {
		timestamp = this.SafeInteger(ohlcv, "idx")
	}
	return []interface{}{timestamp, this.SafeNumber2(ohlcv, "o", "open"), this.SafeNumber2(ohlcv, "h", "high"), this.SafeNumber2(ohlcv, "l", "low"), this.SafeNumber2(ohlcv, "c", "close"), this.SafeNumber2(ohlcv, "v", "vol")}
}

/**
 * @method
 * @name bitrue#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#symbol-order-book-ticker
 * @see https://www.bitrue.com/api-docs#ticker
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BitrueCore) FetchBidsAsks(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes15808 := (<-this.LoadMarkets())
		PanicOnError(retRes15808)
		symbols = this.MarketSymbols(symbols, nil, false)
		var first interface{} = this.SafeString(symbols, 0)
		var market interface{} = this.Market(first)
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			var request interface{} = map[string]interface{}{
				"contractName": GetValue(market, "id"),
			}
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV1PublicGetTicker(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV1PublicGetTicker(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "spot")) {
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}

			response = (<-this.SpotV1PublicGetTickerBookTicker(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchBidsAsks only support spot & swap markets")))
		}
		//
		// spot
		//
		//     {
		//         "symbol": "LTCBTC",
		//         "bidPrice": "4.00000000",
		//         "bidQty": "431.00000000",
		//         "askPrice": "4.00000200",
		//         "askQty": "9.00000000"
		//     }
		//
		// swap
		//
		//     {
		//         "high": "35296",
		//         "vol": "779308354",
		//         "last": "34884.1",
		//         "low": "34806.7",
		//         "buy": 34883.9,
		//         "sell": 34884,
		//         "rose": "-0.0027957315",
		//         "time": 1699348013000
		//     }
		//
		var data interface{} = map[string]interface{}{}
		AddElementToObject(data, GetValue(market, "id"), response)

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#24hr-ticker-price-change-statistics
 * @see https://www.bitrue.com/api-docs#ticker
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BitrueCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes16438 := (<-this.LoadMarkets())
		PanicOnError(retRes16438)
		symbols = this.MarketSymbols(symbols)
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{}
		var typeVar interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var first interface{} = this.SafeString(symbols, 0)
			var market interface{} = this.Market(first)
			if IsTrue(GetValue(market, "swap")) {
				panic(NotSupported(Add(this.Id, " fetchTickers does not support swap markets, please use fetchTicker instead")))
			} else if IsTrue(GetValue(market, "spot")) {

				response = (<-this.SpotV1PublicGetTicker24hr(this.Extend(request, params)))
				PanicOnError(response)
				data = response
			} else {
				panic(NotSupported(Add(this.Id, " fetchTickers only support spot & swap markets")))
			}
		} else {
			typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", nil, params)
			typeVar = GetValue(typeVarparamsVariable, 0)
			params = GetValue(typeVarparamsVariable, 1)
			if IsTrue(!IsEqual(typeVar, "spot")) {
				panic(NotSupported(Add(this.Id, " fetchTickers only support spot when symbols are not proved")))
			}

			response = (<-this.SpotV1PublicGetTicker24hr(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		}
		//
		// spot
		//
		//     [{
		//         symbol: 'BTCUSDT',
		//         priceChange: '105.20',
		//         priceChangePercent: '0.3000',
		//         weightedAvgPrice: null,
		//         prevClosePrice: null,
		//         lastPrice: '34905.21',
		//         lastQty: null,
		//         bidPrice: '34905.21',
		//         askPrice: '34905.22',
		//         openPrice: '34800.01',
		//         highPrice: '35276.33',
		//         lowPrice: '34787.51',
		//         volume: '12549.6481',
		//         quoteVolume: '439390492.917',
		//         openTime: '0',
		//         closeTime: '0',
		//         firstId: '0',
		//         lastId: '0',
		//         count: '0'
		//     }]
		//
		// swap
		//
		//     {
		//         "high": "35296",
		//         "vol": "779308354",
		//         "last": "34884.1",
		//         "low": "34806.7",
		//         "buy": 34883.9,
		//         "sell": 34884,
		//         "rose": "-0.0027957315",
		//         "time": 1699348013000
		//     }
		//
		// the exchange returns market ids with an underscore from the tickers endpoint
		// the market ids do not have an underscore, so it has to be removed
		// https://github.com/ccxt/ccxt/issues/13856
		var tickers interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var ticker interface{} = this.SafeDict(data, i, map[string]interface{}{})
			var market interface{} = this.SafeMarket(this.SafeString(ticker, "symbol"))
			AddElementToObject(tickers, GetValue(market, "id"), ticker)
		}

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//
	//     {
	//         "id": 28457,
	//         "price": "4.00000100",
	//         "qty": "12.00000000",
	//         "time": 1499865549590,  // Actual timestamp of trade
	//         "isBuyerMaker": true,
	//         "isBestMatch": true
	//     }
	//
	// fetchTrades - spot
	//
	//     {
	//         "symbol":"USDCUSDT",
	//         "id":20725156,
	//         "orderId":2880918576,
	//         "origClientOrderId":null,
	//         "price":"0.9996000000000000",
	//         "qty":"100.0000000000000000",
	//         "commission":null,
	//         "commissionAssert":null,
	//         "time":1635558511000,
	//         "isBuyer":false,
	//         "isMaker":false,
	//         "isBestMatch":true
	//     }
	//
	// fetchTrades - future
	//
	//     {
	//         "tradeId":12,
	//         "price":0.9,
	//         "qty":1,
	//         "amount":9,
	//         "contractName":"E-SAND-USDT",
	//         "side":"BUY",
	//         "fee":"0.0018",
	//         "bidId":1558124009467904992,
	//         "askId":1558124043827644908,
	//         "bidUserId":10294,
	//         "askUserId":10467,
	//         "isBuyer":true,
	//         "isMaker":true,
	//         "ctime":1678426306000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(trade, "ctime", "time")
	var priceString interface{} = this.SafeString(trade, "price")
	var amountString interface{} = this.SafeString(trade, "qty")
	var marketId interface{} = this.SafeString2(trade, "symbol", "contractName")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var orderId interface{} = this.SafeString(trade, "orderId")
	var id interface{} = this.SafeString2(trade, "id", "tradeId")
	var side interface{} = nil
	var buyerMaker interface{} = this.SafeBool(trade, "isBuyerMaker") // ignore "m" until Bitrue fixes api
	var isBuyer interface{} = this.SafeBool(trade, "isBuyer")
	if IsTrue(!IsEqual(buyerMaker, nil)) {
		side = Ternary(IsTrue(buyerMaker), "sell", "buy")
	}
	if IsTrue(!IsEqual(isBuyer, nil)) {
		side = Ternary(IsTrue(isBuyer), "buy", "sell") // this is a true side
	}
	var fee interface{} = nil
	if IsTrue(InOp(trade, "commission")) {
		fee = map[string]interface{}{
			"cost":     this.SafeString2(trade, "commission", "fee"),
			"currency": this.SafeCurrencyCode(this.SafeString(trade, "commissionAssert")),
		}
	}
	var takerOrMaker interface{} = nil
	var isMaker interface{} = this.SafeBool(trade, "isMaker")
	if IsTrue(!IsEqual(isMaker, nil)) {
		takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"id":           id,
		"order":        orderId,
		"type":         nil,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        priceString,
		"amount":       amountString,
		"cost":         nil,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name bitrue#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#recent-trades-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *BitrueCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes18248 := (<-this.LoadMarkets())
		PanicOnError(retRes18248)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit) // default 100, max 1000
			}

			response = (<-this.SpotV1PublicGetTrades(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchTrades only support spot markets")))
		}

		//
		// spot
		//
		//     [
		//         {
		//             "id": 28457,
		//             "price": "4.00000100",
		//             "qty": "12.00000000",
		//             "time": 1499865549590,
		//             "isBuyerMaker": true,
		//             "isBestMatch": true
		//         }
		//     ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"INIT":             "open",
		"PENDING_CREATE":   "open",
		"NEW":              "open",
		"PARTIALLY_FILLED": "open",
		"FILLED":           "closed",
		"CANCELED":         "canceled",
		"PENDING_CANCEL":   "canceling",
		"REJECTED":         "rejected",
		"EXPIRED":          "expired",
	}
	return this.SafeString(statuses, status, status)
}
func (this *BitrueCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder - spot
	//
	//     {
	//         "symbol":"USDCUSDT",
	//         "orderId":2878854881,
	//         "clientOrderId":"",
	//         "transactTime":1635551031276
	//     }
	//
	// createOrder - future
	//
	//     {
	//         "orderId":1690615676032452985,
	//     }
	//
	// fetchOrders - spot
	//
	//     {
	//         "symbol":"USDCUSDT",
	//         "orderId":"2878854881",
	//         "clientOrderId":"",
	//         "price":"1.1000000000000000",
	//         "origQty":"100.0000000000000000",
	//         "executedQty":"0.0000000000000000",
	//         "cummulativeQuoteQty":"0.0000000000000000",
	//         "status":"NEW",
	//         "timeInForce":"",
	//         "type":"LIMIT",
	//         "side":"SELL",
	//         "stopPrice":"",
	//         "icebergQty":"",
	//         "time":1635551031000,
	//         "updateTime":1635551031000,
	//         "isWorking":false
	//     }
	//
	// fetchOrders - future
	//
	//     {
	//         "orderId":1917641,
	//         "price":100,
	//         "origQty":10,
	//         "origAmount":10,
	//         "executedQty":1,
	//         "avgPrice":10000,
	//         "status":"INIT",
	//         "type":"LIMIT",
	//         "side":"BUY",
	//         "action":"OPEN",
	//         "transactTime":1686716571425
	//         "clientOrderId":4949299210
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var status interface{} = this.ParseOrderStatus(this.SafeString2(order, "status", "orderStatus"))
	var marketId interface{} = this.SafeString(order, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var filled interface{} = this.SafeString(order, "executedQty")
	var timestamp interface{} = nil
	var lastTradeTimestamp interface{} = nil
	if IsTrue(InOp(order, "time")) {
		timestamp = this.SafeInteger(order, "time")
	} else if IsTrue(InOp(order, "transactTime")) {
		timestamp = this.SafeInteger(order, "transactTime")
	} else if IsTrue(InOp(order, "updateTime")) {
		if IsTrue(IsEqual(status, "open")) {
			if IsTrue(Precise.StringGt(filled, "0")) {
				lastTradeTimestamp = this.SafeInteger(order, "updateTime")
			} else {
				timestamp = this.SafeInteger(order, "updateTime")
			}
		}
	}
	var average interface{} = this.SafeString(order, "avgPrice")
	var price interface{} = this.SafeString(order, "price")
	var amount interface{} = this.SafeString(order, "origQty")
	// - Spot/Margin market: cummulativeQuoteQty
	// - Futures market: cumQuote.
	//   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
	var cost interface{} = this.SafeString2(order, "cummulativeQuoteQty", "cumQuote")
	var id interface{} = this.SafeString(order, "orderId")
	var typeVar interface{} = this.SafeStringLower(order, "type")
	var side interface{} = this.SafeStringLower(order, "side")
	var fills interface{} = this.SafeList(order, "fills", []interface{}{})
	var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
	var timeInForce interface{} = this.SafeString(order, "timeInForce")
	var postOnly interface{} = IsTrue(IsTrue((IsEqual(typeVar, "limit_maker"))) || IsTrue((IsEqual(timeInForce, "GTX")))) || IsTrue((IsEqual(typeVar, "post_only")))
	if IsTrue(IsEqual(typeVar, "limit_maker")) {
		typeVar = "limit"
	}
	var triggerPrice interface{} = this.ParseNumber(this.OmitZero(this.SafeString(order, "stopPrice")))
	return this.SafeOrder(map[string]interface{}{
		"info":               order,
		"id":                 id,
		"clientOrderId":      clientOrderId,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": lastTradeTimestamp,
		"symbol":             symbol,
		"type":               typeVar,
		"timeInForce":        timeInForce,
		"postOnly":           postOnly,
		"side":               side,
		"price":              price,
		"triggerPrice":       triggerPrice,
		"amount":             amount,
		"cost":               cost,
		"average":            average,
		"filled":             filled,
		"remaining":          nil,
		"status":             status,
		"fee":                nil,
		"trades":             fills,
	}, market)
}

/**
 * @method
 * @name bitrue#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.bitrue.com/api-docs#new-order-trade-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#new-order-trade-hmac-sha256
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20008 := (<-this.LoadMarkets())
		PanicOnError(retRes20008)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports swap orders only")))
		}
		AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)

		retRes200615 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
		PanicOnError(retRes200615)
		ch <- retRes200615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#createOrder
 * @description create a trade order
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#new-order-trade
 * @see https://www.bitrue.com/api_docs_includes_file/futures/index.html#new-order-trade-hmac-sha256
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] *spot only* the price at which a trigger order is triggered at
 * @param {string} [params.clientOrderId] a unique id for the order, automatically generated if not sent
 * @param {decimal} [params.leverage] in future order, the leverage value of the order should consistent with the user contract configuration, default is 1
 * @param {string} [params.timeInForce] 'fok', 'ioc' or 'po'
 * @param {bool} [params.postOnly] default false
 * @param {bool} [params.reduceOnly] default false
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {decimal} [params.icebergQty]
 * @param {long} [params.recvWindow]
 * @param {float} [params.cost] *swap market buy only* the quote quantity that can be used as an alternative for the amount
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes20348 := (<-this.LoadMarkets())
		PanicOnError(retRes20348)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		var uppercaseType interface{} = ToUpper(typeVar)
		var request interface{} = map[string]interface{}{
			"side": ToUpper(side),
			"type": uppercaseType,
		}
		if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
			if IsTrue(IsEqual(price, nil)) {
				panic(InvalidOrder(Add(this.Id, " createOrder() requires a price argument")))
			}
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}
		if IsTrue(GetValue(market, "swap")) {
			var isMarket interface{} = IsEqual(uppercaseType, "MARKET")
			var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
			var postOnly interface{} = this.IsPostOnly(isMarket, nil, params)
			if IsTrue(postOnly) {
				AddElementToObject(request, "type", "POST_ONLY")
			} else if IsTrue(IsEqual(timeInForce, "fok")) {
				AddElementToObject(request, "type", "FOK")
			} else if IsTrue(IsEqual(timeInForce, "ioc")) {
				AddElementToObject(request, "type", "IOC")
			}
			AddElementToObject(request, "contractName", GetValue(market, "id"))
			var createMarketBuyOrderRequiresPrice interface{} = true
			createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
			createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
			params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
			if IsTrue(IsTrue(IsTrue(isMarket) && IsTrue((IsEqual(side, "buy")))) && IsTrue(createMarketBuyOrderRequiresPrice)) {
				var cost interface{} = this.SafeString(params, "cost")
				params = this.Omit(params, "cost")
				if IsTrue(IsTrue(IsEqual(price, nil)) && IsTrue(IsEqual(cost, nil))) {
					panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument with swap market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\"createMarketBuyOrderRequiresPrice\"] = false to supply the cost in the amount argument (the exchange-specific behaviour)")))
				} else {
					var amountString interface{} = this.NumberToString(amount)
					var priceString interface{} = this.NumberToString(price)
					var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
					var requestAmount interface{} = Ternary(IsTrue((!IsEqual(cost, nil))), cost, quoteAmount)
					AddElementToObject(request, "amount", this.CostToPrecision(symbol, requestAmount))
					AddElementToObject(request, "volume", this.CostToPrecision(symbol, requestAmount))
				}
			} else {
				AddElementToObject(request, "amount", this.ParseToNumeric(amount))
				AddElementToObject(request, "volume", this.ParseToNumeric(amount))
			}
			AddElementToObject(request, "positionType", 1)
			var reduceOnly interface{} = this.SafeValue2(params, "reduceOnly", "reduce_only")
			AddElementToObject(request, "open", Ternary(IsTrue(reduceOnly), "CLOSE", "OPEN"))
			var leverage interface{} = this.SafeString(params, "leverage", "1")
			AddElementToObject(request, "leverage", this.ParseToNumeric(leverage))
			params = this.Omit(params, []interface{}{"leverage", "reduceOnly", "reduce_only", "timeInForce"})
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivatePostOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivatePostOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeDict(response, "data", map[string]interface{}{})
		} else if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
			var validOrderTypes interface{} = this.SafeValue(GetValue(market, "info"), "orderTypes")
			if !IsTrue(this.InArray(uppercaseType, validOrderTypes)) {
				panic(InvalidOrder(Add(Add(Add(Add(this.Id, " "), typeVar), " is not a valid order type in market "), symbol)))
			}
			var clientOrderId interface{} = this.SafeString2(params, "newClientOrderId", "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				params = this.Omit(params, []interface{}{"newClientOrderId", "clientOrderId"})
				AddElementToObject(request, "newClientOrderId", clientOrderId)
			}
			var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
			if IsTrue(!IsEqual(triggerPrice, nil)) {
				params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice"})
				AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
			}

			response = (<-this.SpotV1PrivatePostOrder(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		} else {
			panic(NotSupported(Add(this.Id, " createOrder only support spot & swap markets")))
		}

		//
		// spot
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "orderId": 307650651173648896,
		//         "orderIdStr": "307650651173648896",
		//         "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
		//         "transactTime": 1507725176595
		//     }
		//
		// swap
		//
		//     {
		//         "code": "0",
		//         "msg": "Success",
		//         "data": {
		//             "orderId": 1690615676032452985
		//         }
		//     }
		//
		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#query-order-user_data
 * @see https://www.bitrue.com/api_docs_includes_file/futures/index.html#query-order-user_data-hmac-sha256
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
		}

		retRes21588 := (<-this.LoadMarkets())
		PanicOnError(retRes21588)
		var market interface{} = this.Market(symbol)
		var origClientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
		params = this.Omit(params, []interface{}{"origClientOrderId", "clientOrderId"})
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsEqual(origClientOrderId, nil)) {
			AddElementToObject(request, "orderId", id)
		} else {
			if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "clientOrderId", origClientOrderId)
			} else {
				AddElementToObject(request, "origClientOrderId", origClientOrderId)
			}
		}
		if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contractName", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivateGetOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivateGetOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeDict(response, "data", map[string]interface{}{})
		} else if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "orderId", id) // spot market id is mandatory
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotV1PrivateGetOrder(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		} else {
			panic(NotSupported(Add(this.Id, " fetchOrder only support spot & swap markets")))
		}

		//
		// spot
		//
		//     {
		//         "symbol": "LTCBTC",
		//         "orderId": 1,
		//         "clientOrderId": "myOrder1",
		//         "price": "0.1",
		//         "origQty": "1.0",
		//         "executedQty": "0.0",
		//         "cummulativeQuoteQty": "0.0",
		//         "status": "NEW",
		//         "timeInForce": "GTC",
		//         "type": "LIMIT",
		//         "side": "BUY",
		//         "stopPrice": "0.0",
		//         "icebergQty": "0.0",
		//         "time": 1499827319559,
		//         "updateTime": 1499827319559,
		//         "isWorking": true
		//     }
		//
		// swap
		//
		//     {
		//         "code":0,
		//         "msg":"success",
		//         "data":{
		//             "orderId":1917641,
		//             "price":100,
		//             "origQty":10,
		//             "origAmount":10,
		//             "executedQty":1,
		//             "avgPrice":10000,
		//             "status":"INIT",
		//             "type":"LIMIT",
		//             "side":"BUY",
		//             "action":"OPEN",
		//             "transactTime":1686716571425
		//             "clientOrderId":4949299210
		//         }
		//     }
		//
		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#all-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrders() requires a symbol argument")))
		}

		retRes22518 := (<-this.LoadMarkets())
		PanicOnError(retRes22518)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " fetchClosedOrders only support spot markets")))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 1000
		}

		response := (<-this.SpotV1PrivateGetAllOrders(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "symbol": "LTCBTC",
		//             "orderId": 1,
		//             "clientOrderId": "myOrder1",
		//             "price": "0.1",
		//             "origQty": "1.0",
		//             "executedQty": "0.0",
		//             "cummulativeQuoteQty": "0.0",
		//             "status": "NEW",
		//             "timeInForce": "GTC",
		//             "type": "LIMIT",
		//             "side": "BUY",
		//             "stopPrice": "0.0",
		//             "icebergQty": "0.0",
		//             "time": 1499827319559,
		//             "updateTime": 1499827319559,
		//             "isWorking": true
		//         }
		//     ]
		//
		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#current-open-orders-user_data
 * @see https://www.bitrue.com/api_docs_includes_file/futures/index.html#cancel-all-open-orders-trade-hmac-sha256
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
		}

		retRes23118 := (<-this.LoadMarkets())
		PanicOnError(retRes23118)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contractName", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivateGetOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivateGetOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeList(response, "data", []interface{}{})
		} else if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotV1PrivateGetOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		} else {
			panic(NotSupported(Add(this.Id, " fetchOpenOrders only support spot & swap markets")))
		}

		//
		// spot
		//
		//     [
		//         {
		//             "symbol":"USDCUSDT",
		//             "orderId":"2878854881",
		//             "clientOrderId":"",
		//             "price":"1.1000000000000000",
		//             "origQty":"100.0000000000000000",
		//             "executedQty":"0.0000000000000000",
		//             "cummulativeQuoteQty":"0.0000000000000000",
		//             "status":"NEW",
		//             "timeInForce":"",
		//             "type":"LIMIT",
		//             "side":"SELL",
		//             "stopPrice":"",
		//             "icebergQty":"",
		//             "time":1635551031000,
		//             "updateTime":1635551031000,
		//             "isWorking":false
		//         }
		//     ]
		//
		// swap
		//
		//      {
		//          "code": "0",
		//          "msg": "Success",
		//          "data": [{
		//                  "orderId": 1917641,
		//                  "clientOrderId": "2488514315",
		//                  "price": 100,
		//                  "origQty": 10,
		//                  "origAmount": 10,
		//                  "executedQty": 1,
		//                  "avgPrice": 12451,
		//                  "status": "INIT",
		//                  "type": "LIMIT",
		//                  "side": "BUY",
		//                  "action": "OPEN",
		//                  "transactTime": 1686717303975
		//              }
		//          ]
		//      }
		//
		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#cancelOrder
 * @description cancels an open order
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#cancel-order-trade
 * @see https://www.bitrue.com/api-docs#cancel-order-trade-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#cancel-order-trade-hmac-sha256
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BitrueCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}

		retRes23968 := (<-this.LoadMarkets())
		PanicOnError(retRes23968)
		var market interface{} = this.Market(symbol)
		var origClientOrderId interface{} = this.SafeValue2(params, "origClientOrderId", "clientOrderId")
		params = this.Omit(params, []interface{}{"origClientOrderId", "clientOrderId"})
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsEqual(origClientOrderId, nil)) {
			AddElementToObject(request, "orderId", id)
		} else {
			if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "clientOrderId", origClientOrderId)
			} else {
				AddElementToObject(request, "origClientOrderId", origClientOrderId)
			}
		}
		if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contractName", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivatePostCancel(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivatePostCancel(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeDict(response, "data", map[string]interface{}{})
		} else if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotV1PrivateDeleteOrder(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		} else {
			panic(NotSupported(Add(this.Id, " cancelOrder only support spot & swap markets")))
		}

		//
		// spot
		//
		//     {
		//         "symbol": "LTCBTC",
		//         "origClientOrderId": "myOrder1",
		//         "orderId": 1,
		//         "clientOrderId": "cancelMyOrder1"
		//     }
		//
		// swap
		//
		//     {
		//         "code": "0",
		//         "msg": "Success",
		//         "data": {
		//             "orderId": 1690615847831143154
		//         }
		//     }
		//
		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://www.bitrue.com/api-docs#cancel-all-open-orders-trade-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#cancel-all-open-orders-trade-hmac-sha256
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
 * @returns {object[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func (this *BitrueCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes24628 := (<-this.LoadMarkets())
		PanicOnError(retRes24628)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			var request interface{} = map[string]interface{}{
				"contractName": GetValue(market, "id"),
			}
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivatePostAllOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivatePostAllOpenOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeList(response, "data", []interface{}{})
		} else {
			panic(NotSupported(Add(this.Id, " cancelAllOrders only support future markets")))
		}

		//
		// swap
		//
		//      {
		//          'code': '0',
		//          'msg': 'Success',
		//          'data': null
		//      }
		//
		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.bitrue.com/api_docs_includes_file/spot/index.html#account-trade-list-user_data
 * @see https://www.bitrue.com/api_docs_includes_file/futures/index.html#account-trade-list-user_data-hmac-sha256
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *BitrueCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes25048 := (<-this.LoadMarkets())
		PanicOnError(retRes25048)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(IsGreaterThan(limit, 1000)) {
				limit = 1000
			}
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contractName", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.FapiV2PrivateGetMyTrades(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.DapiV2PrivateGetMyTrades(this.Extend(request, params)))
				PanicOnError(response)
			}
			data = this.SafeList(response, "data", []interface{}{})
		} else if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotV2PrivateGetMyTrades(this.Extend(request, params)))
			PanicOnError(response)
			data = response
		} else {
			panic(NotSupported(Add(this.Id, " fetchMyTrades only support spot & swap markets")))
		}

		//
		// spot
		//
		//     [
		//         {
		//             "symbol":"USDCUSDT",
		//             "id":20725156,
		//             "orderId":2880918576,
		//             "origClientOrderId":null,
		//             "price":"0.9996000000000000",
		//             "qty":"100.0000000000000000",
		//             "commission":null,
		//             "commissionAssert":null,
		//             "time":1635558511000,
		//             "isBuyer":false,
		//             "isMaker":false,
		//             "isBestMatch":true
		//         }
		//     ]
		//
		// swap
		//
		//     {
		//         "code":"0",
		//         "msg":"Success",
		//         "data":[
		//             {
		//                 "tradeId":12,
		//                 "price":0.9,
		//                 "qty":1,
		//                 "amount":9,
		//                 "contractName":"E-SAND-USDT",
		//                 "side":"BUY",
		//                 "fee":"0.0018",
		//                 "bidId":1558124009467904992,
		//                 "askId":1558124043827644908,
		//                 "bidUserId":10294,
		//                 "askUserId":10467,
		//                 "isBuyer":true,
		//                 "isMaker":true,
		//                 "ctime":1678426306000
		//             }
		//         ]
		//     }
		//
		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#deposit-history--withdraw_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BitrueCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchDeposits() requires a code argument")))
		}

		retRes25998 := (<-this.LoadMarkets())
		PanicOnError(retRes25998)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":   GetValue(currency, "id"),
			"status": 1,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.SpotV1PrivateGetDepositHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":200,
		//         "msg":"succ",
		//         "data":[
		//             {
		//                 "id":2659137,
		//                 "symbol":"USDC",
		//                 "amount":"200.0000000000000000",
		//                 "fee":"0.0E-15",
		//                 "createdAt":1635503169000,
		//                 "updatedAt":1635503202000,
		//                 "addressFrom":"0x2faf487a4414fe77e2327f0bf4ae2a264a776ad2",
		//                 "addressTo":"0x190ceccb1f8bfbec1749180f0ba8922b488d865b",
		//                 "txid":"0x9970aec41099ac385568859517308707bc7d716df8dabae7b52f5b17351c3ed0",
		//                 "confirmations":5,
		//                 "status":0,
		//                 "tagType":null,
		//             },
		//             {
		//                 "id":2659137,
		//                 "symbol": "XRP",
		//                 "amount": "20.0000000000000000",
		//                 "fee": "0.0E-15",
		//                 "createdAt": 1544669393000,
		//                 "updatedAt": 1544669413000,
		//                 "addressFrom": "",
		//                 "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
		//                 "txid": "515B23E1F9864D3AF7F5B4C4FCBED784BAE861854FAB95F4031922B6AAEFC7AC",
		//                 "confirmations": 7,
		//                 "status": 1,
		//                 "tagType": "Tag"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#withdraw-history--withdraw_data
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BitrueCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchWithdrawals() requires a code argument")))
		}

		retRes26728 := (<-this.LoadMarkets())
		PanicOnError(retRes26728)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":   GetValue(currency, "id"),
			"status": 5,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.SpotV1PrivateGetWithdrawHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": 200,
		//        "msg": "succ",
		//        "data": [
		//            {
		//                "id": 183745,
		//                "symbol": "usdt_erc20",
		//                "amount": "8.4000000000000000",
		//                "fee": "1.6000000000000000",
		//                "payAmount": "0.0000000000000000",
		//                "createdAt": 1595336441000,
		//                "updatedAt": 1595336576000,
		//                "addressFrom": "",
		//                "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83",
		//                "txid": "",
		//                "confirmations": 0,
		//                "status": 6,
		//                "tagType": null
		//            }
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseTransactionStatusByType(status interface{}, optionalArgs ...interface{}) interface{} {
	typeVar := GetArg(optionalArgs, 0, nil)
	_ = typeVar
	var statusesByType interface{} = map[string]interface{}{
		"deposit": map[string]interface{}{
			"0": "pending",
			"1": "ok",
		},
		"withdrawal": map[string]interface{}{
			"0": "pending",
			"5": "ok",
			"6": "canceled",
		},
	}
	var statuses interface{} = this.SafeDict(statusesByType, typeVar, map[string]interface{}{})
	return this.SafeString(statuses, status, status)
}
func (this *BitrueCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "symbol": "XRP",
	//         "amount": "261.3361000000000000",
	//         "fee": "0.0E-15",
	//         "createdAt": 1548816979000,
	//         "updatedAt": 1548816999000,
	//         "addressFrom": "",
	//         "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
	//         "txid": "86D6EB68A7A28938BCE06BD348F8C07DEF500C5F7FE92069EF8C0551CE0F2C7D",
	//         "confirmations": 8,
	//         "status": 1,
	//         "tagType": "Tag"
	//     },
	//     {
	//         "symbol": "XRP",
	//         "amount": "20.0000000000000000",
	//         "fee": "0.0E-15",
	//         "createdAt": 1544669393000,
	//         "updatedAt": 1544669413000,
	//         "addressFrom": "",
	//         "addressTo": "raLPjTYeGezfdb6crXZzcC8RkLBEwbBHJ5_18113641",
	//         "txid": "515B23E1F9864D3AF7F5B4C4FCBED784BAE861854FAB95F4031922B6AAEFC7AC",
	//         "confirmations": 7,
	//         "status": 1,
	//         "tagType": "Tag"
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "id": 183745,
	//         "symbol": "usdt_erc20",
	//         "amount": "8.4000000000000000",
	//         "fee": "1.6000000000000000",
	//         "payAmount": "0.0000000000000000",
	//         "createdAt": 1595336441000,
	//         "updatedAt": 1595336576000,
	//         "addressFrom": "",
	//         "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83",
	//         "txid": "",
	//         "confirmations": 0,
	//         "status": 6,
	//         "tagType": null
	//     }
	//
	// withdraw
	//
	//     {
	//         "msg": null,
	//         "amount": 1000,
	//         "fee": 1,
	//         "ctime": null,
	//         "coin": "usdt_erc20",
	//         "withdrawId": 1156423,
	//         "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString2(transaction, "id", "withdrawId")
	var tagType interface{} = this.SafeString(transaction, "tagType")
	var addressTo interface{} = this.SafeString(transaction, "addressTo")
	var addressFrom interface{} = this.SafeString(transaction, "addressFrom")
	var tagTo interface{} = nil
	var tagFrom interface{} = nil
	if IsTrue(!IsEqual(tagType, nil)) {
		if IsTrue(!IsEqual(addressTo, nil)) {
			var parts interface{} = Split(addressTo, "_")
			addressTo = this.SafeString(parts, 0)
			tagTo = this.SafeString(parts, 1)
		}
		if IsTrue(!IsEqual(addressFrom, nil)) {
			var parts interface{} = Split(addressFrom, "_")
			addressFrom = this.SafeString(parts, 0)
			tagFrom = this.SafeString(parts, 1)
		}
	}
	var txid interface{} = this.SafeString(transaction, "txid")
	var timestamp interface{} = this.SafeInteger(transaction, "createdAt")
	var updated interface{} = this.SafeInteger(transaction, "updatedAt")
	var payAmount interface{} = (InOp(transaction, "payAmount"))
	var ctime interface{} = (InOp(transaction, "ctime"))
	var typeVar interface{} = Ternary(IsTrue((IsTrue(payAmount) || IsTrue(ctime))), "withdrawal", "deposit")
	var status interface{} = this.ParseTransactionStatusByType(this.SafeString(transaction, "status"), typeVar)
	var amount interface{} = this.SafeNumber(transaction, "amount")
	var network interface{} = nil
	var currencyId interface{} = this.SafeString2(transaction, "symbol", "coin")
	if IsTrue(!IsEqual(currencyId, nil)) {
		var parts interface{} = Split(currencyId, "_")
		currencyId = this.SafeString(parts, 0)
		var networkId interface{} = this.SafeString(parts, 1)
		if IsTrue(!IsEqual(networkId, nil)) {
			network = ToUpper(networkId)
		}
	}
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var feeCost interface{} = this.SafeNumber(transaction, "fee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": code,
			"cost":     feeCost,
		}
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     network,
		"address":     addressTo,
		"addressTo":   addressTo,
		"addressFrom": addressFrom,
		"tag":         tagTo,
		"tagTo":       tagTo,
		"tagFrom":     tagFrom,
		"type":        typeVar,
		"amount":      amount,
		"currency":    code,
		"status":      status,
		"updated":     updated,
		"internal":    false,
		"comment":     nil,
		"fee":         fee,
	}
}

/**
 * @method
 * @name bitrue#withdraw
 * @description make a withdrawal
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#withdraw-commit--withdraw_data
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BitrueCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)
		this.CheckAddress(address)

		retRes28758 := (<-this.LoadMarkets())
		PanicOnError(retRes28758)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":      GetValue(currency, "id"),
			"amount":    amount,
			"addressTo": address,
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chainName", this.NetworkCodeToId(networkCode))
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "tag", tag)
		}

		response := (<-this.SpotV1PrivatePostWithdrawCommit(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "msg": "succ",
		//         "data": {
		//             "msg": null,
		//             "amount": 1000,
		//             "fee": 1,
		//             "ctime": null,
		//             "coin": "usdt_erc20",
		//             "withdrawId": 1156423,
		//             "addressTo": "0x2edfae3878d7b6db70ce4abed177ab2636f60c83"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTransaction(data, currency)
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//   {
	//       "coin": "adx",
	//       "coinFulName": "Ambire AdEx",
	//       "chains": [ "BSC" ],
	//       "chainDetail": [ [Object] ]
	//   }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var chainDetails interface{} = this.SafeList(fee, "chainDetail", []interface{}{})
	var chainDetailLength interface{} = GetArrayLength(chainDetails)
	var result interface{} = map[string]interface{}{
		"info": fee,
		"withdraw": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"networks": map[string]interface{}{},
	}
	if IsTrue(!IsEqual(chainDetailLength, 0)) {
		for i := 0; IsLessThan(i, chainDetailLength); i++ {
			var chainDetail interface{} = GetValue(chainDetails, i)
			var networkId interface{} = this.SafeString(chainDetail, "chain")
			var currencyCode interface{} = this.SafeString(currency, "code")
			var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
			AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
				"deposit": map[string]interface{}{
					"fee":        nil,
					"percentage": nil,
				},
				"withdraw": map[string]interface{}{
					"fee":        this.SafeNumber(chainDetail, "withdrawFee"),
					"percentage": false,
				},
			})
			if IsTrue(IsEqual(chainDetailLength, 1)) {
				AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(chainDetail, "withdrawFee"))
				AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
			}
		}
	}
	return result
}

/**
 * @method
 * @name bitrue#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://github.com/Bitrue-exchange/Spot-official-api-docs#exchangeInfo_endpoint
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *BitrueCore) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes29668 := (<-this.LoadMarkets())
		PanicOnError(retRes29668)

		response := (<-this.SpotV1PublicGetExchangeInfo(params))
		PanicOnError(response)
		var coins interface{} = this.SafeList(response, "coins")

		ch <- this.ParseDepositWithdrawFees(coins, codes, "coin")
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     fetchTransfers
	//
	//     {
	//         'transferType': 'wallet_to_contract',
	//         'symbol': 'USDT',
	//         'amount': 1.0,
	//         'status': 1,
	//         'ctime': 1685404575000
	//     }
	//
	//     transfer
	//
	//     {}
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var transferType interface{} = this.SafeString(transfer, "transferType")
	var fromAccount interface{} = nil
	var toAccount interface{} = nil
	if IsTrue(!IsEqual(transferType, nil)) {
		var accountSplit interface{} = Split(transferType, "_to_")
		fromAccount = this.SafeString(accountSplit, 0)
		toAccount = this.SafeString(accountSplit, 1)
	}
	var timestamp interface{} = this.SafeInteger(transfer, "ctime")
	return map[string]interface{}{
		"info":        transfer,
		"id":          nil,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    this.SafeString(currency, "code"),
		"amount":      this.SafeNumber(transfer, "amount"),
		"fromAccount": fromAccount,
		"toAccount":   toAccount,
		"status":      "ok",
	}
}

/**
 * @method
 * @name bitrue#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://www.bitrue.com/api-docs#get-future-account-transfer-history-list-user_data-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#get-future-account-transfer-history-list-user_data-hmac-sha256
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for
 * @param {string} [params.type] transfer type wallet_to_contract or contract_to_wallet
 * @returns {object[]} a list of [transfer structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#transfer-structure}
 */
func (this *BitrueCore) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes30258 := (<-this.LoadMarkets())
		PanicOnError(retRes30258)
		var typeVar interface{} = this.SafeString2(params, "type", "transferType")
		var request interface{} = map[string]interface{}{
			"transferType": typeVar,
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coinSymbol", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "beginTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(IsGreaterThan(limit, 200)) {
				limit = 200
			}
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, "until")
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.FapiV2PrivateGetFuturesTransferHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         'code': '0',
		//         'msg': 'Success',
		//         'data': [{
		//             'transferType': 'wallet_to_contract',
		//             'symbol': 'USDT',
		//             'amount': 1.0,
		//             'status': 1,
		//             'ctime': 1685404575000
		//         }]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransfers(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.bitrue.com/api-docs#new-future-account-transfer-user_data-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#user-commission-rate-user_data-hmac-sha256
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transfer-structure}
 */
func (this *BitrueCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes30818 := (<-this.LoadMarkets())
		PanicOnError(retRes30818)
		var currency interface{} = this.Currency(code)
		var accountTypes interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountTypes, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountTypes, toAccount, toAccount)
		var request interface{} = map[string]interface{}{
			"coinSymbol":   GetValue(currency, "id"),
			"amount":       this.CurrencyToPrecision(code, amount),
			"transferType": Add(Add(fromId, "_to_"), toId),
		}

		response := (<-this.FapiV2PrivatePostFuturesTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         'code': '0',
		//         'msg': 'Success',
		//         'data': null
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTransfer(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bitrue#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.bitrue.com/api-docs#change-initial-leverage-trade-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#change-initial-leverage-trade-hmac-sha256
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *BitrueCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}
		if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 125)))) {
			panic(BadRequest(Add(this.Id, " leverage should be between 1 and 125")))
		}

		retRes31218 := (<-this.LoadMarkets())
		PanicOnError(retRes31218)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var request interface{} = map[string]interface{}{
			"contractName": GetValue(market, "id"),
			"leverage":     leverage,
		}
		if !IsTrue(GetValue(market, "swap")) {
			panic(NotSupported(Add(this.Id, " setLeverage only support swap markets")))
		}
		if IsTrue(GetValue(market, "linear")) {

			response = (<-this.FapiV2PrivatePostLevelEdit(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.DapiV2PrivatePostLevelEdit(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- response
		return nil

	}()
	return ch
}
func (this *BitrueCore) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{} {
	//
	// setMargin
	//
	//     {
	//         "code": 0,
	//         "msg": "success"
	//         "data": null
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return map[string]interface{}{
		"info":       data,
		"symbol":     GetValue(market, "symbol"),
		"type":       nil,
		"marginMode": "isolated",
		"amount":     nil,
		"total":      nil,
		"code":       nil,
		"status":     nil,
		"timestamp":  nil,
		"datetime":   nil,
	}
}

/**
 * @method
 * @name bitrue#setMargin
 * @description Either adds or reduces margin in an isolated position in order to set the margin to a specific value
 * @see https://www.bitrue.com/api-docs#modify-isolated-position-margin-trade-hmac-sha256
 * @see https://www.bitrue.com/api_docs_includes_file/delivery.html#modify-isolated-position-margin-trade-hmac-sha256
 * @param {string} symbol unified market symbol of the market to set margin in
 * @param {float} amount the amount to set the margin to
 * @param {object} [params] parameters specific to the exchange API endpoint
 * @returns {object} A [margin structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#add-margin-structure}
 */
func (this *BitrueCore) SetMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes31758 := (<-this.LoadMarkets())
		PanicOnError(retRes31758)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(NotSupported(Add(this.Id, " setMargin only support swap markets")))
		}
		var response interface{} = nil
		var request interface{} = map[string]interface{}{
			"contractName": GetValue(market, "id"),
			"amount":       this.ParseToNumeric(amount),
		}
		if IsTrue(GetValue(market, "linear")) {

			response = (<-this.FapiV2PrivatePostPositionMargin(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.DapiV2PrivatePostPositionMargin(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//     {
		//         "code": 0,
		//         "msg": "success"
		//         "data": null
		//     }
		//
		ch <- this.ParseMarginModification(response, market)
		return nil

	}()
	return ch
}
func (this *BitrueCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var typeVar interface{} = this.SafeString(api, 0)
	var version interface{} = this.SafeString(api, 1)
	var access interface{} = this.SafeString(api, 2)
	var url interface{} = nil
	if IsTrue(IsTrue((IsTrue(IsEqual(typeVar, "api")) && IsTrue(IsEqual(version, "kline")))) || IsTrue((IsTrue(IsEqual(typeVar, "open")) && IsTrue(IsGreaterThanOrEqual(GetIndexOf(path, "listenKey"), 0))))) {
		url = GetValue(GetValue(this.Urls, "api"), typeVar)
	} else {
		url = Add(Add(GetValue(GetValue(this.Urls, "api"), typeVar), "/"), version)
	}
	url = Add(Add(url, "/"), this.ImplodeParams(path, params))
	params = this.Omit(params, this.ExtractParams(path))
	if IsTrue(IsEqual(access, "private")) {
		this.CheckRequiredCredentials()
		var recvWindow interface{} = this.SafeInteger(this.Options, "recvWindow", 5000)
		if IsTrue(IsTrue(IsEqual(typeVar, "spot")) || IsTrue(IsEqual(typeVar, "open"))) {
			var query interface{} = this.Urlencode(this.Extend(map[string]interface{}{
				"timestamp":  this.Nonce(),
				"recvWindow": recvWindow,
			}, params))
			var signature interface{} = this.Hmac(this.Encode(query), this.Encode(this.Secret), sha256)
			query = Add(query, Add(Add("&", "signature="), signature))
			headers = map[string]interface{}{
				"X-MBX-APIKEY": this.ApiKey,
			}
			if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
				url = Add(url, Add("?", query))
			} else {
				body = query
				AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
			}
		} else {
			var timestamp interface{} = ToString(this.Nonce())
			var signPath interface{} = nil
			if IsTrue(IsEqual(typeVar, "fapi")) {
				signPath = "/fapi"
			} else if IsTrue(IsEqual(typeVar, "dapi")) {
				signPath = "/dapi"
			}
			signPath = Add(Add(Add(Add(signPath, "/"), version), "/"), path)
			var signMessage interface{} = Add(Add(timestamp, method), signPath)
			if IsTrue(IsEqual(method, "GET")) {
				var keys interface{} = ObjectKeys(params)
				var keysLength interface{} = GetArrayLength(keys)
				if IsTrue(IsGreaterThan(keysLength, 0)) {
					signMessage = Add(signMessage, Add("?", this.Urlencode(params)))
				}
				var signature interface{} = this.Hmac(this.Encode(signMessage), this.Encode(this.Secret), sha256)
				headers = map[string]interface{}{
					"X-CH-APIKEY": this.ApiKey,
					"X-CH-SIGN":   signature,
					"X-CH-TS":     timestamp,
				}
				url = Add(url, Add("?", this.Urlencode(params)))
			} else {
				var query interface{} = this.Extend(map[string]interface{}{
					"recvWindow": recvWindow,
				}, params)
				body = this.Json(query)
				signMessage = Add(signMessage, body)
				var signature interface{} = this.Hmac(this.Encode(signMessage), this.Encode(this.Secret), sha256)
				headers = map[string]interface{}{
					"Content-Type": "application/json",
					"X-CH-APIKEY":  this.ApiKey,
					"X-CH-SIGN":    signature,
					"X-CH-TS":      timestamp,
				}
			}
		}
	} else {
		if IsTrue(GetArrayLength(ObjectKeys(params))) {
			url = Add(url, Add("?", this.Urlencode(params)))
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *BitrueCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsTrue((IsEqual(code, 418))) || IsTrue((IsEqual(code, 429)))) {
		panic(DDoSProtection(Add(Add(Add(Add(Add(Add(this.Id, " "), ToString(code)), " "), reason), " "), body)))
	}
	// error response in a form: { "code": -1013, "msg": "Invalid quantity." }
	// following block cointains legacy checks against message patterns in "msg" property
	// will switch "code" checks eventually, when we know all of them
	if IsTrue(IsGreaterThanOrEqual(code, 400)) {
		if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "Price * QTY is zero or less"), 0)) {
			panic(InvalidOrder(Add(Add(this.Id, " order cost = amount * price is zero or less "), body)))
		}
		if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "LOT_SIZE"), 0)) {
			panic(InvalidOrder(Add(Add(this.Id, " order amount should be evenly divisible by lot size "), body)))
		}
		if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "PRICE_FILTER"), 0)) {
			panic(InvalidOrder(Add(Add(this.Id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "), body)))
		}
	}
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	// check success value for wapi endpoints
	// response in format {'msg': 'The coin does not exist.', 'success': true/false}
	var success interface{} = this.SafeBool(response, "success", true)
	if !IsTrue(success) {
		var messageInner interface{} = this.SafeString(response, "msg")
		var parsedMessage interface{} = nil
		if IsTrue(!IsEqual(messageInner, nil)) {

			{
				func(this *BitrueCore) (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func(this *BitrueCore) interface{} {
								// catch block:
								// do nothing
								parsedMessage = nil
								return nil
							}(this)
						}
					}()
					// try block:
					parsedMessage = JsonParse(messageInner)
					return nil
				}(this)

			}
			if IsTrue(!IsEqual(parsedMessage, nil)) {
				response = parsedMessage
			}
		}
	}
	var message interface{} = this.SafeString(response, "msg")
	if IsTrue(!IsEqual(message, nil)) {
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, Add(Add(this.Id, " "), message))
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, Add(Add(this.Id, " "), message))
	}
	// checks against error codes
	var error interface{} = this.SafeString(response, "code")
	if IsTrue(!IsEqual(error, nil)) {
		// https://github.com/ccxt/ccxt/issues/6501
		// https://github.com/ccxt/ccxt/issues/7742
		if IsTrue(IsTrue((IsEqual(error, "200"))) || IsTrue(Precise.StringEquals(error, "0"))) {
			return nil
		}
		// a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
		// despite that their message is very confusing, it is raised by Binance
		// on a temporary ban, the API key is valid, but disabled for a while
		if IsTrue(IsTrue((IsEqual(error, "-2015"))) && IsTrue(GetValue(this.Options, "hasAlreadyAuthenticatedSuccessfully"))) {
			panic(DDoSProtection(Add(Add(this.Id, " temporary banned: "), body)))
		}
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
		panic(ExchangeError(feedback))
	}
	if !IsTrue(success) {
		panic(ExchangeError(Add(Add(this.Id, " "), body)))
	}
	return nil
}
func (this *BitrueCore) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{} {
	config := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = config
	if IsTrue(IsTrue((InOp(config, "noSymbol"))) && !IsTrue((InOp(params, "symbol")))) {
		return GetValue(config, "noSymbol")
	} else if IsTrue(IsTrue((InOp(config, "byLimit"))) && IsTrue((InOp(params, "limit")))) {
		var limit interface{} = GetValue(params, "limit")
		var byLimit interface{} = GetValue(config, "byLimit")
		for i := 0; IsLessThan(i, GetArrayLength(byLimit)); i++ {
			var entry interface{} = GetValue(byLimit, i)
			if IsTrue(IsLessThanOrEqual(limit, GetValue(entry, 0))) {
				return GetValue(entry, 1)
			}
		}
	}
	return this.SafeValue(config, "cost", 1)
}

func (this *BitrueCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
