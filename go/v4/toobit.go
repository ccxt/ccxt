package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type toobit struct {
	Exchange
}

func NewToobitCore() *toobit {
	p := &toobit{}
	setDefaults(p)
	return p
}

func (this *toobit) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "toobit",
		"name":      "Toobit",
		"countries": []interface{}{"KY"},
		"version":   "v1",
		"rateLimit": 20,
		"certified": false,
		"pro":       false,
		"has": map[string]interface{}{
			"CORS":                    nil,
			"spot":                    true,
			"margin":                  false,
			"swap":                    true,
			"future":                  false,
			"option":                  false,
			"cancelAllOrders":         true,
			"cancelOrder":             true,
			"cancelOrders":            true,
			"createOrder":             true,
			"fetchBalance":            true,
			"fetchBidsAsks":           true,
			"fetchCurrencies":         true,
			"fetchDepositAddress":     true,
			"fetchDeposits":           true,
			"fetchFundingRateHistory": true,
			"fetchFundingRates":       true,
			"fetchIndexOHLCV":         true,
			"fetchLastPrices":         true,
			"fetchLedger":             true,
			"fetchMarkets":            true,
			"fetchMarkOHLCV":          true,
			"fetchMyTrades":           true,
			"fetchOHLCV":              true,
			"fetchOpenOrders":         true,
			"fetchOrder":              true,
			"fetchOrderBook":          true,
			"fetchOrders":             true,
			"fetchStatus":             true,
			"fetchTickers":            true,
			"fetchTime":               true,
			"fetchTrades":             true,
			"fetchWithdrawals":        true,
			"setMarginMode":           true,
			"transfer":                true,
			"withdraw":                true,
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/3fc13870-5406-431b-8be0-2aab69c4f225",
			"api": map[string]interface{}{
				"common":  "https://api.toobit.com",
				"private": "https://api.toobit.com",
			},
			"www": "https://www.toobit.com/",
			"doc": []interface{}{"https://toobit-docs.github.io/apidocs/spot/v1/en/", "https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/"},
			"referral": map[string]interface{}{
				"url":      "https://www.toobit.com/en-US/r?i=IFFPy0",
				"discount": 0.1,
			},
			"fees": "https://www.toobit.com/fee",
		},
		"api": map[string]interface{}{
			"common": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/time":                       1,
					"api/v1/ping":                       1,
					"api/v1/exchangeInfo":               1,
					"quote/v1/depth":                    1,
					"quote/v1/depth/merged":             1,
					"quote/v1/trades":                   1,
					"quote/v1/klines":                   1,
					"quote/v1/index/klines":             1,
					"quote/v1/markPrice/klines":         1,
					"quote/v1/markPrice":                1,
					"quote/v1/index":                    1,
					"quote/v1/ticker/24hr":              40,
					"quote/v1/contract/ticker/24hr":     40,
					"quote/v1/ticker/price":             1,
					"quote/v1/ticker/bookTicker":        1,
					"api/v1/futures/fundingRate":        1,
					"api/v1/futures/historyFundingRate": 1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/account":                 5,
					"api/v1/account/checkApiKey":     1,
					"api/v1/spot/order":              Multiply(1, 1.67),
					"api/v1/spot/openOrders":         Multiply(1, 1.67),
					"api/v1/futures/openOrders":      Multiply(1, 1.67),
					"api/v1/spot/tradeOrders":        Multiply(5, 1.67),
					"api/v1/futures/historyOrders":   Multiply(5, 1.67),
					"api/v1/account/trades":          Multiply(5, 1.67),
					"api/v1/account/balanceFlow":     5,
					"api/v1/account/depositOrders":   5,
					"api/v1/account/withdrawOrders":  5,
					"api/v1/account/deposit/address": 1,
					"api/v1/subAccount":              5,
					"api/v1/futures/accountLeverage": 1,
					"api/v1/futures/order":           Multiply(1, 1.67),
					"api/v1/futures/positions":       Multiply(5, 1.67),
					"api/v1/futures/balance":         5,
					"api/v1/futures/userTrades":      Multiply(5, 1.67),
					"api/v1/futures/balanceFlow":     5,
					"api/v1/futures/commissionRate":  5,
					"api/v1/futures/todayPnl":        5,
				},
				"post": map[string]interface{}{
					"api/v1/spot/orderTest":                Multiply(1, 1.67),
					"api/v1/spot/order":                    Multiply(1, 1.67),
					"api/v1/futures/order":                 Multiply(1, 1.67),
					"api/v1/spot/batchOrders":              Multiply(2, 1.67),
					"api/v1/subAccount/transfer":           1,
					"api/v1/account/withdraw":              1,
					"api/v1/futures/marginType":            1,
					"api/v1/futures/leverage":              1,
					"api/v1/futures/batchOrders":           Multiply(2, 1.67),
					"api/v1/futures/position/trading-stop": Multiply(3, 1.67),
					"api/v1/futures/positionMargin":        1,
					"api/v1/userDataStream":                1,
					"api/v1/listenKey":                     1,
				},
				"delete": map[string]interface{}{
					"api/v1/spot/order":               Multiply(1, 1.67),
					"api/v1/futures/order":            Multiply(1, 1.67),
					"api/v1/spot/openOrders":          Multiply(5, 1.67),
					"api/v1/futures/batchOrders":      Multiply(5, 1.67),
					"api/v1/spot/cancelOrderByIds":    Multiply(5, 1.67),
					"api/v1/futures/cancelOrderByIds": Multiply(5, 1.67),
					"api/v1/listenKey":                1,
				},
				"put": map[string]interface{}{
					"api/v1/listenKey": 1,
				},
			},
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"8h":  "8h",
			"12h": "12h",
			"1d":  "1d",
			"1w":  "1w",
			"1M":  "1M",
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"-1000": OperationFailed,
				"-1001": OperationFailed,
				"-1002": PermissionDenied,
				"-1003": RateLimitExceeded,
				"-1004": BadRequest,
				"-1006": OperationFailed,
				"-1007": OperationFailed,
				"-1014": OperationFailed,
				"-1015": RateLimitExceeded,
				"-1016": OperationRejected,
				"-1020": OperationRejected,
				"-1021": OperationRejected,
				"-1022": OperationRejected,
				"-1100": BadRequest,
				"-1101": BadRequest,
				"-1102": BadRequest,
				"-1103": BadRequest,
				"-1104": BadRequest,
				"-1105": BadRequest,
				"-1106": BadRequest,
				"-1111": BadRequest,
				"-1112": OperationRejected,
				"-1114": BadRequest,
				"-1115": BadRequest,
				"-1116": BadRequest,
				"-1117": BadRequest,
				"-1118": InvalidOrder,
				"-1119": InvalidOrder,
				"-1120": BadRequest,
				"-1121": BadRequest,
				"-1125": OperationRejected,
				"-1127": OperationRejected,
				"-1128": BadRequest,
				"-1130": BadRequest,
				"-1132": OperationRejected,
				"-1133": OperationRejected,
				"-1134": OperationRejected,
				"-1135": OperationRejected,
				"-1136": OperationRejected,
				"-1137": OperationRejected,
				"-1138": OperationRejected,
				"-1139": OperationRejected,
				"-1140": OperationRejected,
				"-1141": InvalidOrder,
				"-1142": InvalidOrder,
				"-1143": InvalidOrder,
				"-1144": OperationRejected,
				"-1145": OperationRejected,
				"-1146": OperationFailed,
				"-1147": OperationFailed,
				"-1193": OperationRejected,
				"-1194": OperationRejected,
				"-1195": OperationRejected,
				"-1196": OperationRejected,
				"-1197": OperationRejected,
				"-1198": OperationRejected,
				"-1199": OperationRejected,
				"-1200": OperationRejected,
				"-1201": OperationRejected,
				"-1202": OperationRejected,
				"-1203": OperationRejected,
				"-1206": OperationRejected,
				"-2010": OperationFailed,
				"-2011": OperationFailed,
				"-2013": InvalidOrder,
				"-2014": PermissionDenied,
				"-2015": PermissionDenied,
				"-2016": BadRequest,
				"-3050": ExchangeError,
				"-3101": OperationRejected,
				"-3102": OperationRejected,
				"-3103": BadRequest,
				"-3105": OperationRejected,
				"-3107": OperationRejected,
				"-3108": OperationRejected,
				"-3109": OperationRejected,
				"-3110": InsufficientFunds,
				"-3116": OperationRejected,
				"-3117": OperationRejected,
				"-3120": OperationRejected,
				"-3124": OperationRejected,
				"-3125": OperationRejected,
				"-3126": OperationRejected,
				"-3127": OperationFailed,
				"-3128": OperationRejected,
				"-3129": BadRequest,
				"-3130": OperationRejected,
				"-3131": NotSupported,
			},
			"broad": map[string]interface{}{
				"Unknown order sent":   OrderNotFound,
				"Duplicate order sent": InvalidOrder,
				"Market is closed":     OperationRejected,
				"Account has insufficient balance for requested action":      InsufficientFunds,
				"Market orders are not supported for this symbol":            OperationRejected,
				"Iceberg orders are not supported for this symbol":           OperationRejected,
				"Stop loss orders are not supported for this symbol":         OperationRejected,
				"Stop loss limit orders are not supported for this symbol":   OperationRejected,
				"Take profit orders are not supported for this symbol":       OperationRejected,
				"Take profit limit orders are not supported for this symbol": OperationRejected,
				"QTY is zero or less":                                    BadRequest,
				"IcebergQty exceeds QTY":                                 OperationRejected,
				"This action disabled is on this account":                PermissionDenied,
				"Unsupported order combination":                          BadRequest,
				"Order would trigger immediately":                        OperationRejected,
				"Cancel order is invalid. Check origClOrdId and orderId": OperationRejected,
				"Order would immediately match and take":                 OperationRejected,
			},
		},
		"commonCurrencies": map[string]interface{}{},
		"options": map[string]interface{}{
			"defaultType": "spot",
			"accountsByType": map[string]interface{}{
				"spot": "MAIN",
				"swap": "FUTURES",
			},
			"networks": map[string]interface{}{
				"BTC":    "BTC",
				"ERC20":  "ETH",
				"ETH":    "ETH",
				"BEP20":  "BSC",
				"TRC20":  "TRX",
				"SOL":    "SOL",
				"MATIC":  "MATIC",
				"ARBONE": "ARBITRUM",
				"BASE":   "BASE",
				"TON":    "TON",
				"AVAXC":  "AVAXC",
				"DOGE":   "DOGE",
				"XRP":    "XRP",
				"DOT":    "DOT",
				"ADA":    "ADA",
				"LTC":    "LTC",
				"APT":    "APT",
				"ATOM":   "ATOM",
				"ALGO":   "ALGO",
				"NEAR":   "NEAR",
				"XLM":    "XLM",
				"SUI":    "SUI",
				"ETC":    "ETC",
				"EOS":    "EOS",
				"WAVES":  "WAVES",
				"ICP":    "ICP",
				"ONE":    "ONE",
			},
			"networksById": map[string]interface{}{
				"ETH":   "ERC20",
				"ERC20": "ERC20",
			},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           false,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyRequiresPrice": false,
					"marketBuyByCost":        false,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": nil,
				"fetchOHLCV": map[string]interface{}{
					"limit": 1000,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"daysBack":       100000,
					"untilDays":      100000,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          1000,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          500,
					"daysBack":       100000,
					"untilDays":      100000,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchClosedOrders": nil,
			},
			"forDerivatives": map[string]interface{}{
				"createOrders": nil,
			},
			"swap": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
	})
}

/**
 * @method
 * @name toobit#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#test-connectivity
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func (this *toobit) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.CommonGetApiV1Ping(params))
		PanicOnError(response)

		ch <- map[string]interface{}{
			"status":  "ok",
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#check-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *toobit) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.CommonGetApiV1Time(params))
		PanicOnError(response)

		//
		//     {
		//         "serverTime": 1699827319559
		//     }
		//
		ch <- this.SafeInteger(response, "serverTime")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *toobit) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.CommonGetApiV1ExchangeInfo(params))
		PanicOnError(response)
		AddElementToObject(this.Options, "exchangeInfo", response) // we store it in options for later use in fetchMarkets
		//
		//    {
		//        "timezone": "UTC",
		//        "serverTime": "1755583099926",
		//        "brokerFilters": [],
		//        "symbols": [
		//            {
		//                "filters": [
		//                    {
		//                        "minPrice": "0.01",
		//                        "maxPrice": "10000000.00000000",
		//                        "tickSize": "0.01",
		//                        "filterType": "PRICE_FILTER"
		//                    },
		//                    {
		//                        "minQty": "0.0001",
		//                        "maxQty": "4000",
		//                        "stepSize": "0.0001",
		//                        "filterType": "LOT_SIZE"
		//                    },
		//                    {
		//                        "minNotional": "5",
		//                        "filterType": "MIN_NOTIONAL"
		//                    },
		//                    {
		//                        "minAmount": "5",
		//                        "maxAmount": "6600000",
		//                        "minBuyPrice": "0.01",
		//                        "filterType": "TRADE_AMOUNT"
		//                    },
		//                    {
		//                        "maxSellPrice": "99999999",
		//                        "buyPriceUpRate": "0.1",
		//                        "sellPriceDownRate": "0.1",
		//                        "filterType": "LIMIT_TRADING"
		//                    },
		//                    {
		//                        "buyPriceUpRate": "0.1",
		//                        "sellPriceDownRate": "0.1",
		//                        "filterType": "MARKET_TRADING"
		//                    },
		//                    {
		//                        "noAllowMarketStartTime": "0",
		//                        "noAllowMarketEndTime": "0",
		//                        "limitOrderStartTime": "0",
		//                        "limitOrderEndTime": "0",
		//                        "limitMinPrice": "0",
		//                        "limitMaxPrice": "0",
		//                        "filterType": "OPEN_QUOTE"
		//                    }
		//                ],
		//                "exchangeId": "301",
		//                "symbol": "ETHUSDT",
		//                "symbolName": "ETHUSDT",
		//                "status": "TRADING",
		//                "baseAsset": "ETH",
		//                "baseAssetName": "ETH",
		//                "baseAssetPrecision": "0.0001",
		//                "quoteAsset": "USDT",
		//                "quoteAssetName": "USDT",
		//                "quotePrecision": "0.01",
		//                "icebergAllowed": false,
		//                "isAggregate": false,
		//                "allowMargin": true,
		//             }
		//        ],
		//        "options": [],
		//        "contracts": [
		//            {
		//                 "filters": [ ... ],
		//                 "exchangeId": "301",
		//                 "symbol": "BTC-SWAP-USDT",
		//                 "symbolName": "BTC-SWAP-USDTUSDT",
		//                 "status": "TRADING",
		//                 "baseAsset": "BTC-SWAP-USDT",
		//                 "baseAssetPrecision": "0.001",
		//                 "quoteAsset": "USDT",
		//                 "quoteAssetPrecision": "0.1",
		//                 "icebergAllowed": false,
		//                 "inverse": false,
		//                 "index": "BTC",
		//                 "indexToken": "BTCUSDT",
		//                 "marginToken": "USDT",
		//                 "marginPrecision": "0.0001",
		//                 "contractMultiplier": "0.001",
		//                 "underlying": "BTC",
		//                 "riskLimits": [
		//                     {
		//                         "riskLimitId": "200020911",
		//                         "quantity": "42000.0",
		//                         "initialMargin": "0.02",
		//                         "maintMargin": "0.01",
		//                         "isWhite": false
		//                     },
		//                     {
		//                         "riskLimitId": "200020912",
		//                         "quantity": "84000.0",
		//                         "initialMargin": "0.04",
		//                         "maintMargin": "0.02",
		//                         "isWhite": false
		//                     },
		//                     ...
		//                 ]
		//            },
		//        ],
		//        "coins": [
		//            {
		//                "orgId": "9001",
		//                "coinId": "TCOM",
		//                "coinName": "TCOM",
		//                "coinFullName": "TCOM",
		//                "allowWithdraw": true,
		//                "allowDeposit": true,
		//                "chainTypes": [
		//                    {
		//                        "chainType": "BSC",
		//                        "withdrawFee": "49.55478",
		//                        "minWithdrawQuantity": "77",
		//                        "maxWithdrawQuantity": "0",
		//                        "minDepositQuantity": "48",
		//                        "allowDeposit": true,
		//                        "allowWithdraw": false
		//                    }
		//                ],
		//                "isVirtual": false
		//            },
		//          ...
		//
		var coins interface{} = this.SafeList(response, "coins", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(coins)); i++ {
			var coin interface{} = GetValue(coins, i)
			var parsed interface{} = this.ParseCurrency(coin)
			var code interface{} = GetValue(parsed, "code")
			AddElementToObject(result, code, parsed)
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *toobit) ParseCurrency(rawCurrency interface{}) interface{} {
	var id interface{} = this.SafeString(rawCurrency, "coinId")
	var code interface{} = this.SafeCurrencyCode(id)
	var networks interface{} = map[string]interface{}{}
	var rawNetworks interface{} = this.SafeList(rawCurrency, "chainTypes")
	for j := 0; IsLessThan(j, GetArrayLength(rawNetworks)); j++ {
		var rawNetwork interface{} = GetValue(rawNetworks, j)
		var networkId interface{} = this.SafeString(rawNetwork, "chainType")
		var networkCode interface{} = this.NetworkIdToCode(networkId)
		AddElementToObject(networks, networkCode, map[string]interface{}{
			"id":        networkId,
			"network":   networkCode,
			"margin":    nil,
			"deposit":   this.SafeBool(rawNetwork, "allowDeposit"),
			"withdraw":  this.SafeBool(rawNetwork, "allowWithdraw"),
			"active":    nil,
			"fee":       this.SafeNumber(rawNetwork, "withdrawFee"),
			"precision": nil,
			"limits": map[string]interface{}{
				"deposit": map[string]interface{}{
					"min": this.SafeNumber(rawNetwork, "minDepositQuantity"),
					"max": nil,
				},
				"withdraw": map[string]interface{}{
					"min": this.SafeNumber(rawNetwork, "minWithdrawQuantity"),
					"max": this.SafeNumber(rawNetwork, "maxWithdrawQuantity"),
				},
			},
			"info": rawNetwork,
		})
	}
	return this.SafeCurrencyStructure(map[string]interface{}{
		"id":        id,
		"code":      code,
		"name":      this.SafeString(rawCurrency, "coinFullName"),
		"type":      nil,
		"active":    nil,
		"deposit":   this.SafeBool(rawCurrency, "allowDeposit"),
		"withdraw":  this.SafeBool(rawCurrency, "allowWithdraw"),
		"fee":       nil,
		"precision": nil,
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"withdraw": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"networks": networks,
		"info":     rawCurrency,
	})
}

/**
 * @method
 * @name toobit#fetchMarkets
 * @description retrieves data on all markets for toobit
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#exchange-information
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *toobit) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var response interface{} = this.SafeDict(this.Options, "exchangeInfo")
		if IsTrue(!IsEqual(response, nil)) {
			AddElementToObject(this.Options, "exchangeInfo", nil) // reset it to avoid using old cached data
		} else {

			response = (<-this.CommonGetApiV1ExchangeInfo(params))
			PanicOnError(response)
		}
		//
		//    {
		//        "timezone": "UTC",
		//        "serverTime": "1755583099926",
		//        "brokerFilters": [],
		//        "symbols": [
		//            {
		//                "filters": [
		//                    {
		//                        "minPrice": "0.01",
		//                        "maxPrice": "10000000.00000000",
		//                        "tickSize": "0.01",
		//                        "filterType": "PRICE_FILTER"
		//                    },
		//                    {
		//                        "minQty": "0.0001",
		//                        "maxQty": "4000",
		//                        "stepSize": "0.0001",
		//                        "filterType": "LOT_SIZE"
		//                    },
		//                    {
		//                        "minNotional": "5",
		//                        "filterType": "MIN_NOTIONAL"
		//                    },
		//                    {
		//                        "minAmount": "5",
		//                        "maxAmount": "6600000",
		//                        "minBuyPrice": "0.01",
		//                        "filterType": "TRADE_AMOUNT"
		//                    },
		//                    {
		//                        "maxSellPrice": "99999999",
		//                        "buyPriceUpRate": "0.1",
		//                        "sellPriceDownRate": "0.1",
		//                        "filterType": "LIMIT_TRADING"
		//                    },
		//                    {
		//                        "buyPriceUpRate": "0.1",
		//                        "sellPriceDownRate": "0.1",
		//                        "filterType": "MARKET_TRADING"
		//                    },
		//                    {
		//                        "noAllowMarketStartTime": "0",
		//                        "noAllowMarketEndTime": "0",
		//                        "limitOrderStartTime": "0",
		//                        "limitOrderEndTime": "0",
		//                        "limitMinPrice": "0",
		//                        "limitMaxPrice": "0",
		//                        "filterType": "OPEN_QUOTE"
		//                    }
		//                ],
		//                "exchangeId": "301",
		//                "symbol": "ETHUSDT",
		//                "symbolName": "ETHUSDT",
		//                "status": "TRADING",
		//                "baseAsset": "ETH",
		//                "baseAssetName": "ETH",
		//                "baseAssetPrecision": "0.0001",
		//                "quoteAsset": "USDT",
		//                "quoteAssetName": "USDT",
		//                "quotePrecision": "0.01",
		//                "icebergAllowed": false,
		//                "isAggregate": false,
		//                "allowMargin": true,
		//             }
		//        ],
		//        "options": [],
		//        "contracts": [
		//            {
		//                 "filters": [ ... ],
		//                 "exchangeId": "301",
		//                 "symbol": "BTC-SWAP-USDT",
		//                 "symbolName": "BTC-SWAP-USDTUSDT",
		//                 "status": "TRADING",
		//                 "baseAsset": "BTC-SWAP-USDT",
		//                 "baseAssetPrecision": "0.001",
		//                 "quoteAsset": "USDT",
		//                 "quoteAssetPrecision": "0.1",
		//                 "icebergAllowed": false,
		//                 "inverse": false,
		//                 "index": "BTC",
		//                 "indexToken": "BTCUSDT",
		//                 "marginToken": "USDT",
		//                 "marginPrecision": "0.0001",
		//                 "contractMultiplier": "0.001",
		//                 "underlying": "BTC",
		//                 "riskLimits": [
		//                     {
		//                         "riskLimitId": "200020911",
		//                         "quantity": "42000.0",
		//                         "initialMargin": "0.02",
		//                         "maintMargin": "0.01",
		//                         "isWhite": false
		//                     },
		//                     {
		//                         "riskLimitId": "200020912",
		//                         "quantity": "84000.0",
		//                         "initialMargin": "0.04",
		//                         "maintMargin": "0.02",
		//                         "isWhite": false
		//                     },
		//                     ...
		//                 ]
		//            },
		//        ],
		//        "coins": [
		//            {
		//                "orgId": "9001",
		//                "coinId": "TCOM",
		//                "coinName": "TCOM",
		//                "coinFullName": "TCOM",
		//                "allowWithdraw": true,
		//                "allowDeposit": true,
		//                "chainTypes": [
		//                    {
		//                        "chainType": "BSC",
		//                        "withdrawFee": "49.55478",
		//                        "minWithdrawQuantity": "77",
		//                        "maxWithdrawQuantity": "0",
		//                        "minDepositQuantity": "48",
		//                        "allowDeposit": true,
		//                        "allowWithdraw": false
		//                    }
		//                ],
		//                "isVirtual": false
		//            },
		//          ...
		//
		var symbols interface{} = this.SafeList(response, "symbols", []interface{}{})
		var contracts interface{} = this.SafeList(response, "contracts", []interface{}{})
		var all interface{} = this.ArrayConcat(symbols, contracts)
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(all)); i++ {
			var market interface{} = GetValue(all, i)
			var parsed interface{} = this.ParseMarket(market)
			AppendToArray(&result, parsed)
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *toobit) ParseMarket(market interface{}) interface{} {
	var id interface{} = this.SafeString(market, "symbol")
	var baseId interface{} = this.SafeString(market, "baseAsset")
	var quoteId interface{} = this.SafeString(market, "quoteAsset")
	var baseParts interface{} = Split(baseId, "-")
	var baseIdClean interface{} = GetValue(baseParts, 0)
	var base interface{} = this.SafeCurrencyCode(baseIdClean)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var settleId interface{} = this.SafeString(market, "marginToken")
	var settle interface{} = this.SafeCurrencyCode(settleId)
	var status interface{} = this.SafeString(market, "status")
	var active interface{} = (IsEqual(status, "TRADING"))
	var filters interface{} = this.SafeList(market, "filters", []interface{}{})
	var filtersByType interface{} = this.IndexBy(filters, "filterType")
	var priceFilter interface{} = this.SafeDict(filtersByType, "PRICE_FILTER", map[string]interface{}{})
	var lotSizeFilter interface{} = this.SafeDict(filtersByType, "LOT_SIZE", map[string]interface{}{})
	var minNotionalFilter interface{} = this.SafeDict(filtersByType, "MIN_NOTIONAL", map[string]interface{}{})
	var symbol interface{} = Add(Add(base, "/"), quote)
	var isContract interface{} = (InOp(market, "contractMultiplier"))
	var inverse interface{} = this.SafeBool2(market, "isInverse", "inverse")
	if IsTrue(isContract) {
		symbol = Add(symbol, Add(":", settle))
	}
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           Ternary(IsTrue(isContract), "swap", "spot"),
		"spot":           !IsTrue(isContract),
		"margin":         false,
		"swap":           isContract,
		"future":         false,
		"option":         false,
		"active":         active,
		"contract":       isContract,
		"linear":         Ternary(IsTrue(isContract), !IsTrue(inverse), nil),
		"inverse":        Ternary(IsTrue(isContract), inverse, nil),
		"contractSize":   this.SafeNumber(market, "contractMultiplier"),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": this.SafeNumber(lotSizeFilter, "stepSize"),
			"price":  this.SafeNumber(priceFilter, "tickSize"),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"amount": map[string]interface{}{
				"min": this.SafeNumber(lotSizeFilter, "minQty"),
				"max": this.SafeNumber(lotSizeFilter, "maxQty"),
			},
			"price": map[string]interface{}{
				"min": this.SafeNumber(priceFilter, "minPrice"),
				"max": this.SafeNumber(priceFilter, "maxPrice"),
			},
			"cost": map[string]interface{}{
				"min": this.SafeNumber(minNotionalFilter, "minNotional"),
				"max": nil,
			},
		},
		"created": nil,
		"info":    market,
	})
}

/**
 * @method
 * @name toobit#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#order-book
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *toobit) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes8878 := (<-this.LoadMarkets())
		PanicOnError(retRes8878)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.CommonGetQuoteV1Depth(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "t": "1755593995237",
		//        "b": [
		//            [
		//                "115186.47",
		//                "4.184864"
		//            ],
		//            [
		//                "115186.46",
		//                "0.002756"
		//            ],
		//            ...
		//        ],
		//        "a": [
		//            [
		//                "115186.48",
		//                "6.137369"
		//            ],
		//            [
		//                "115186.49",
		//                "0.002914"
		//            ],
		//            ...
		//        ]
		//    }
		//
		var timestamp interface{} = this.SafeInteger(response, "t")

		ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp, "b", "a")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchTrades
 * @description get a list of the most recent trades for a particular symbol
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#recent-trades-list
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#recent-trades-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *toobit) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes9408 := (<-this.LoadMarkets())
		PanicOnError(retRes9408)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.CommonGetQuoteV1Trades(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "t": "1755594277287",
		//            "p": "115276.99",
		//            "q": "0.001508",
		//            "ibm": true
		//        },
		//    ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *toobit) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//
	//        {
	//            "t": "1755594277287",
	//            "p": "115276.99",
	//            "q": "0.001508",
	//            "ibm": true
	//        },
	//        // watchTrades have also an additional fields:
	//             "v": "4864732022868004630",   // trade id
	//             "m": true,                    // is the buyer taker
	//
	// fetchMyTrades
	//
	//        {
	//            "id": "2024934575206059008",
	//            "symbol": "ETHUSDT",
	//            "orderId": "2024934575097029888",
	//            "ticketId": "4864450547563401875",
	//            "price": "4641.21",
	//            "qty": "0.001",
	//            "time": "1756127012094",
	//            "isMaker": false,
	//            "commission": "0.00464121",
	//            "commissionAsset": "USDT",
	//            "makerRebate": "0",
	//            "symbolName": "ETHUSDT",                 // only in SPOT
	//            "isBuyer": false,                        // only in SPOT
	//            "feeAmount": "0.00464121",               // only in SPOT
	//            "feeCoinId": "USDT",                     // only in SPOT
	//            "fee": {                                 // only in SPOT
	//                "feeCoinId": "USDT",
	//                "feeCoinName": "USDT",
	//                "fee": "0.00464121"
	//            },
	//            "type": "LIMIT",                         // only in CONTRACT
	//            "side": "BUY_OPEN",                      // only in CONTRACT
	//            "realizedPnl": "0",                      // only in CONTRACT
	//        },
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(trade, "t", "time")
	var priceString interface{} = this.SafeString2(trade, "p", "price")
	var amountString interface{} = this.SafeString2(trade, "q", "qty")
	var isBuyer interface{} = this.SafeBool(trade, "isBuyer")
	var side interface{} = nil
	var isBuyerMaker interface{} = this.SafeBool(trade, "ibm")
	if IsTrue(IsEqual(isBuyerMaker, nil)) {
		var isBuyerTaker interface{} = this.SafeBool(trade, "m")
		if IsTrue(!IsEqual(isBuyerTaker, nil)) {
			isBuyerMaker = !IsTrue(isBuyerTaker)
		}
	}
	if IsTrue(!IsEqual(isBuyerMaker, nil)) {
		if IsTrue(isBuyerMaker) {
			side = "sell"
		} else {
			side = "buy"
		}
	} else {
		if IsTrue(isBuyer) {
			side = "buy"
		} else {
			side = "sell"
		}
	}
	var feeCurrencyId interface{} = this.SafeString(trade, "feeCoinId")
	var feeAmount interface{} = this.SafeString(trade, "feeAmount")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeAmount, nil)) {
		fee = map[string]interface{}{
			"currency": this.SafeCurrencyCode(feeCurrencyId),
			"cost":     feeAmount,
		}
	}
	var isMaker interface{} = this.SafeBool(trade, "isMaker")
	var takerOrMaker interface{} = nil
	if IsTrue(!IsEqual(isMaker, nil)) {
		takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
	}
	market = this.SafeMarket(nil, market)
	var symbol interface{} = GetValue(market, "symbol")
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"id":           this.SafeString2(trade, "id", "v"),
		"order":        this.SafeString(trade, "orderId"),
		"type":         nil,
		"side":         side,
		"amount":       amountString,
		"price":        priceString,
		"cost":         nil,
		"takerOrMaker": takerOrMaker,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name toobit#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#kline-candlestick-data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#kline-candlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *toobit) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10768 := (<-this.LoadMarkets())
		PanicOnError(retRes10768)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, "until")
			AddElementToObject(request, "endTime", until)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		var endpoint interface{} = nil
		endpointparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "price")
		endpoint = GetValue(endpointparamsVariable, 0)
		params = GetValue(endpointparamsVariable, 1)
		if IsTrue(IsEqual(endpoint, "index")) {

			response = (<-this.CommonGetQuoteV1IndexKlines(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(endpoint, "mark")) {

			response = (<-this.CommonGetQuoteV1MarkPriceKlines(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.CommonGetQuoteV1Klines(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *toobit) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeIntegerN(ohlcv, []interface{}{0, "time", "t"}), this.SafeNumberN(ohlcv, []interface{}{1, "open", "o"}), this.SafeNumberN(ohlcv, []interface{}{2, "high", "h"}), this.SafeNumberN(ohlcv, []interface{}{3, "low", "l"}), this.SafeNumberN(ohlcv, []interface{}{4, "close", "c"}), this.SafeNumberN(ohlcv, []interface{}{5, "volume", "v"})}
}

/**
 * @method
 * @name toobit#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#24hr-ticker-price-change-statistics
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#24hr-ticker-price-change-statistics
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *toobit) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11898 := (<-this.LoadMarkets())
		PanicOnError(retRes11898)
		symbols = this.MarketSymbols(symbols)
		var typeVar interface{} = nil
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbol interface{} = this.SafeString(symbols, 0)
			market = this.Market(symbol)
			var length interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(length, 1)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.CommonGetQuoteV1Ticker24hr(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.CommonGetQuoteV1ContractTicker24hr(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//    [
		//        {
		//            "t": "1755601440162",
		//            "s": "GRDRUSDT",
		//            "o": "0.38",
		//            "h": "0.38",
		//            "l": "0.38",
		//            "c": "0.38",
		//            "v": "0",
		//            "qv": "0",
		//            "pc": "0",
		//            "pcp": "0"
		//        },
		//        ...
		//
		ch <- this.ParseTickers(response, symbols, params)
		return nil

	}()
	return ch
}
func (this *toobit) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "s")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(ticker, "t")
	var last interface{} = this.SafeString(ticker, "c")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "h"),
		"low":           this.SafeString(ticker, "l"),
		"bid":           nil,
		"bidVolume":     nil,
		"ask":           nil,
		"askVolume":     nil,
		"vwap":          nil,
		"open":          this.SafeString(ticker, "o"),
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        this.SafeString(ticker, "pc"),
		"percentage":    this.SafeString(ticker, "pcp"),
		"average":       nil,
		"baseVolume":    this.SafeString(ticker, "v"),
		"quoteVolume":   this.SafeString(ticker, "qv"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name toobit#fetchLastPrices
 * @description fetches the last price for multiple markets
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#symbol-price-ticker
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#symbol-price-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the last prices
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of lastprices structures
 */
func (this *toobit) FetchLastPrices(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes12688 := (<-this.LoadMarkets())
		PanicOnError(retRes12688)
		symbols = this.MarketSymbols(symbols)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(length, 1)) {
				var market interface{} = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}

		response := (<-this.CommonGetQuoteV1TickerPrice(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "s": "BNTUSDT",
		//            "si": "BNTUSDT",
		//            "p": "0.823"
		//        },
		//
		ch <- this.ParseLastPrices(response, symbols)
		return nil

	}()
	return ch
}
func (this *toobit) ParseLastPrice(entry interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(entry, "s")
	market = this.SafeMarket(marketId, market)
	return map[string]interface{}{
		"symbol":    GetValue(market, "symbol"),
		"timestamp": nil,
		"datetime":  nil,
		"price":     this.SafeNumberOmitZero(entry, "price"),
		"side":      nil,
		"info":      entry,
	}
}

/**
 * @method
 * @name toobit#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#symbol-order-book-ticker
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#symbol-order-book-ticker
 * @param {string[]} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *toobit) FetchBidsAsks(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13148 := (<-this.LoadMarkets())
		PanicOnError(retRes13148)
		symbols = this.MarketSymbols(symbols)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(length, 1)) {
				var market interface{} = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}

		response := (<-this.CommonGetQuoteV1TickerBookTicker(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "s": "GRDRUSDT",
		//            "b": "0",
		//            "bq": "0",
		//            "a": "0",
		//            "aq": "0",
		//            "t": "1755936610506"
		//        }, ...
		//
		ch <- this.ParseBidsAsksCustom(response, symbols)
		return nil

	}()
	return ch
}
func (this *toobit) ParseBidsAsksCustom(tickers interface{}, optionalArgs ...interface{}) interface{} {
	symbols := GetArg(optionalArgs, 0, nil)
	_ = symbols
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var results interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
		var parsedTicker interface{} = this.ParseBidAskCustom(GetValue(tickers, i))
		var ticker interface{} = this.Extend(parsedTicker, params)
		AppendToArray(&results, ticker)
	}
	symbols = this.MarketSymbols(symbols)
	return this.FilterByArray(results, "symbol", symbols)
}
func (this *toobit) ParseBidAskCustom(ticker interface{}) interface{} {
	return map[string]interface{}{
		"timestamp": this.SafeString(ticker, "t"),
		"symbol":    this.SafeString(ticker, "s"),
		"bid":       this.SafeNumber(ticker, "b"),
		"bidVolume": this.SafeNumber(ticker, "bq"),
		"ask":       this.SafeNumber(ticker, "a"),
		"askVolume": this.SafeNumber(ticker, "aq"),
		"info":      ticker,
	}
}

/**
 * @method
 * @name toobit#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#funding-rate
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
 */
func (this *toobit) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13728 := (<-this.LoadMarkets())
		PanicOnError(retRes13728)
		symbols = this.MarketSymbols(symbols)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(length, 1)) {
				var market interface{} = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}

		response := (<-this.CommonGetApiV1FuturesFundingRate(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "BTC-SWAP-USDT",
		//            "rate": "0.0001071148112848",
		//            "nextFundingTime": "1755964800000"
		//        },...
		//
		ch <- this.ParseFundingRates(response, symbols)
		return nil

	}()
	return ch
}
func (this *toobit) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var nextFundingRate interface{} = this.SafeNumber(contract, "rate")
	var nextFundingRateTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"previousFundingRate":      nil,
		"nextFundingRate":          nil,
		"previousFundingTimestamp": nil,
		"nextFundingTimestamp":     nil,
		"previousFundingDatetime":  nil,
		"nextFundingDatetime":      nil,
		"fundingRate":              nextFundingRate,
		"fundingTimestamp":         nextFundingRateTimestamp,
		"fundingDatetime":          this.Iso8601(nextFundingRateTimestamp),
		"interval":                 nil,
	}
}

/**
 * @method
 * @name toobit#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *toobit) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14358 := (<-this.LoadMarkets())
		PanicOnError(retRes14358)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes143919 := (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params))
			PanicOnError(retRes143919)
			ch <- retRes143919
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.CommonGetApiV1FuturesHistoryFundingRate(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "id": "869931",
		//            "symbol": "BTC-SWAP-USDT",
		//            "settleTime": "1755936000000",
		//            "settleRate": "0.0001"
		//        }, ...
		//
		ch <- this.ParseFundingRateHistories(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *toobit) ParseFundingRateHistory(contract interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(contract, "settleTime")
	var marketId interface{} = this.SafeString(contract, "symbol")
	return map[string]interface{}{
		"info":        contract,
		"symbol":      this.SafeSymbol(marketId, market),
		"fundingRate": this.SafeNumber(contract, "settleRate"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name toobit#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#account-information-user_data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#futures-account-balance-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpointinvalid
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *toobit) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14838 := (<-this.LoadMarkets())
		PanicOnError(retRes14838)
		var response interface{} = nil
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(this.InArray(marketType, []interface{}{"swap", "future"})) {

			response = (<-this.PrivateGetApiV1FuturesBalance())
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetApiV1Account())
			PanicOnError(response)
		}

		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *toobit) ParseBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	var balances interface{} = this.SafeList(response, "balances", response)
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "asset"))
		var account interface{} = this.Account()
		AddElementToObject(account, "free", this.SafeString2(balance, "free", "availableBalance"))
		AddElementToObject(account, "total", this.SafeString2(balance, "total", "balance"))
		AddElementToObject(account, "used", this.SafeString(balance, "locked"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name toobit#createOrder
 * @description create a trade order
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#new-order-trade
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#new-order-trade
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes15568 := (<-this.LoadMarkets())
		PanicOnError(retRes15568)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			requestparamsVariable := this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
			request = GetValue(requestparamsVariable, 0)
			params = GetValue(requestparamsVariable, 1)

			response = (<-this.PrivatePostApiV1SpotOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			requestparamsVariable := this.CreateContractOrderRequest(symbol, typeVar, side, amount, price, params)
			request = GetValue(requestparamsVariable, 0)
			params = GetValue(requestparamsVariable, 1)

			response = (<-this.PrivatePostApiV1FuturesOrder(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//     {
		//         "symbol": "ETHUSDT",
		//         "price": "0",
		//         "origQty": "0.001",
		//         "orderId": "2024837825254460160",
		//         "clientOrderId": "1756115478113679",
		//         "executedQty": "0",
		//         "status": "PENDING_NEW",
		//         "timeInForce": "GTC",
		//         "type": "MARKET",
		//         "side": "SELL"
		//         "accountId": "1783404067076253952",    // only in spot
		//         "symbolName": "ETHUSDT",               // only in spot
		//         "transactTime": "1756115478604",       // only in spot
		//         "time": "1668418485058",               // only in contract
		//         "updateTime": "1668418485058",         // only in contract
		//         "leverage": "2",                       // only in contract
		//         "avgPrice": "0",                       // only in contract
		//         "marginLocked": "9.5",                 // only in contract
		//         "priceType": "INPUT"                   // only in contract
		//     }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}
func (this *toobit) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var id interface{} = GetValue(market, "id")
	var request interface{} = map[string]interface{}{
		"symbol": id,
		"side":   ToUpper(side),
	}
	if IsTrue(!IsEqual(price, nil)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var cost interface{} = nil
	costparamsVariable := this.HandleParamString(params, "cost")
	cost = GetValue(costparamsVariable, 0)
	params = GetValue(costparamsVariable, 1)
	if IsTrue(IsEqual(typeVar, "market")) {
		if IsTrue(IsTrue(IsEqual(cost, nil)) && IsTrue(IsEqual(side, "buy"))) {
			panic(ArgumentsRequired(Add(this.Id, " createOrder() requires params[\"cost\"] for market buy order")))
		} else {
			AddElementToObject(request, "quantity", this.CostToPrecision(symbol, cost))
		}
	} else {
		AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
	}
	var isPostOnly interface{} = nil
	isPostOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), false, params)
	isPostOnly = GetValue(isPostOnlyparamsVariable, 0)
	params = GetValue(isPostOnlyparamsVariable, 1)
	if IsTrue(isPostOnly) {
		AddElementToObject(request, "type", "LIMIT_MAKER")
	} else {
		AddElementToObject(request, "type", ToUpper(typeVar))
	}
	return []interface{}{request, params}
}
func (this *toobit) CreateContractOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"symbol":   GetValue(market, "id"),
		"quantity": this.AmountToPrecision(symbol, amount),
	}
	var reduceOnly interface{} = nil
	reduceOnlyparamsVariable := this.HandleParamBool(params, "reduceOnly")
	reduceOnly = GetValue(reduceOnlyparamsVariable, 0)
	params = GetValue(reduceOnlyparamsVariable, 1)
	if IsTrue(IsEqual(side, "buy")) {
		side = Ternary(IsTrue(reduceOnly), "SELL_CLOSE", "BUY_OPEN")
	} else if IsTrue(IsEqual(side, "sell")) {
		side = Ternary(IsTrue(reduceOnly), "BUY_CLOSE", "SELL_OPEN")
	}
	AddElementToObject(request, "side", side)
	if IsTrue(!IsEqual(price, nil)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	if IsTrue(this.InArray(typeVar, []interface{}{"limit", "LIMIT"})) {
		AddElementToObject(request, "type", ToUpper(typeVar))
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	} else if IsTrue(IsEqual(typeVar, "market")) {
		AddElementToObject(request, "type", "LIMIT") // weird, but exchange works this way
		AddElementToObject(request, "priceType", "MARKET")
	}
	var isPostOnly interface{} = nil
	isPostOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), false, params)
	isPostOnly = GetValue(isPostOnlyparamsVariable, 0)
	params = GetValue(isPostOnlyparamsVariable, 1)
	if IsTrue(isPostOnly) {
		AddElementToObject(request, "timeInForce", "LIMIT_MAKER")
	}
	var values interface{} = this.HandleTriggerPricesAndParams(symbol, params)
	var triggerPrice interface{} = GetValue(values, 0)
	params = GetValue(values, 3)
	if IsTrue(!IsEqual(triggerPrice, nil)) {
		AddElementToObject(request, "stopPrice", triggerPrice)
	}
	var stopLoss interface{} = this.SafeDict(params, "stopLoss")
	var takeProfit interface{} = this.SafeDict(params, "takeProfit")
	var triggerPriceTypes interface{} = map[string]interface{}{
		"mark": "MARK_PRICE",
		"last": "CONTRACT_PRICE",
	}
	if IsTrue(!IsEqual(stopLoss, nil)) {
		AddElementToObject(request, "stopLoss", this.SafeValue(stopLoss, "triggerPrice"))
		var limitPrice interface{} = this.SafeValue(stopLoss, "price")
		if IsTrue(!IsEqual(limitPrice, nil)) {
			AddElementToObject(request, "slOrderType", "LIMIT")
			AddElementToObject(request, "slLimitPrice", this.PriceToPrecision(symbol, limitPrice))
		}
		var triggerPriceType interface{} = this.SafeString(stopLoss, "triggerPriceType")
		if IsTrue(!IsEqual(triggerPriceType, nil)) {
			AddElementToObject(request, "slTriggerBy", this.SafeString(triggerPriceTypes, triggerPriceType, triggerPriceType))
		}
		params = this.Omit(params, "stopLoss")
	}
	if IsTrue(!IsEqual(takeProfit, nil)) {
		AddElementToObject(request, "takeProfit", this.SafeValue(takeProfit, "triggerPrice"))
		var limitPrice interface{} = this.SafeValue(takeProfit, "price")
		if IsTrue(!IsEqual(limitPrice, nil)) {
			AddElementToObject(request, "tpOrderType", "LIMIT")
			AddElementToObject(request, "tpLimitPrice", this.PriceToPrecision(symbol, limitPrice))
		}
		var triggerPriceType interface{} = this.SafeString(takeProfit, "triggerPriceType")
		if IsTrue(!IsEqual(triggerPriceType, nil)) {
			AddElementToObject(request, "tpTriggerBy", this.SafeString(triggerPriceTypes, triggerPriceType, triggerPriceType))
		}
		params = this.Omit(params, "takeProfit")
	}
	if !IsTrue((InOp(params, "newClientOrderId"))) {
		AddElementToObject(request, "newClientOrderId", this.Uuid())
	}
	return []interface{}{request, params}
}
func (this *toobit) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder, cancelOrder
	//
	//     {
	//         "symbol": "ETHUSDT",
	//         "price": "0",
	//         "origQty": "0.001",
	//         "orderId": "2024837825254460160",
	//         "clientOrderId": "1756115478113679",
	//         "executedQty": "0",
	//         "status": "PENDING_NEW",
	//         "timeInForce": "GTC",
	//         "type": "MARKET",
	//         "side": "SELL"
	//         "accountId": "1783404067076253952",    // only in spot
	//         "symbolName": "ETHUSDT",               // only in spot
	//         "transactTime": "1756115478604",       // only in spot
	//         "time": "1668418485058",               // only in contract
	//         "updateTime": "1668418485058",         // only in contract
	//         "leverage": "2",                       // only in contract
	//         "avgPrice": "0",                       // only in contract
	//         "marginLocked": "9.5",                 // only in contract
	//         "priceType": "INPUT"                   // only in contract
	//     }
	//
	//
	// fetchOrder, fetchOrders, fetchOpenOrders
	//
	//    {
	//        "time": "1756140208069",
	//        "updateTime": "1756140208078",
	//        "orderId": "2025045271033977089",
	//        "clientOrderId": "17561402075722006",
	//        "symbol": "ETHUSDT",
	//        "price": "3000",
	//        "origQty": "0.002",
	//        "executedQty": "0",
	//        "avgPrice": "0",
	//        "type": "LIMIT",
	//        "side": "BUY",
	//        "timeInForce": "GTC",
	//        "status": "NEW",
	//        "accountId": "1783404067076253952",  // only in SPOT
	//        "exchangeId": "301",                 // only in SPOT
	//        "symbolName": "ETHUSDT",             // only in SPOT
	//        "cummulativeQuoteQty": "0",          // only in SPOT
	//        "cumulativeQuoteQty": "0",           // only in SPOT
	//        "stopPrice": "0.0",                  // only in SPOT
	//        "icebergQty": "0.0",                 // only in SPOT
	//        "isWorking": true                    // only in SPOT
	//        "leverage": "2",                     // only in CONTRACT
	//        "marginLocked": "9.5",               // only in CONTRACT
	//        "priceType": "INPUT"                 // only in CONTRACT
	//        "triggerType": "0",                  // only in CONTRACT fetchClosedOrders
	//        "fallType": "0",                     // only in CONTRACT fetchClosedOrders
	//        "activeStatus": "0"                  // only in CONTRACT fetchClosedOrders
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(order, "transactTime", "time")
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var rawType interface{} = this.SafeString(order, "type")
	var rawSideLower interface{} = this.SafeStringLower(order, "side")
	var triggerPrice interface{} = this.OmitZero(this.SafeString(order, "stopPrice"))
	if IsTrue(IsEqual(triggerPrice, "0.0")) {
		triggerPrice = nil
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                order,
		"id":                  this.SafeString(order, "orderId"),
		"clientOrderId":       this.SafeString(order, "clientOrderId"),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  nil,
		"lastUpdateTimestamp": this.SafeInteger(order, "updateTime"),
		"status":              this.ParseOrderStatus(this.SafeString(order, "status")),
		"symbol":              GetValue(market, "symbol"),
		"type":                this.ParseOrderType(rawType),
		"timeInForce":         this.SafeString(order, "timeInForce"),
		"postOnly":            (IsEqual(rawType, "LIMIT_MAKER")),
		"side":                rawSideLower,
		"price":               this.OmitZero(this.SafeString(order, "price")),
		"triggerPrice":        triggerPrice,
		"cost":                this.OmitZero(this.SafeString(order, "cumulativeQuoteQty")),
		"average":             this.SafeString(order, "avgPrice"),
		"amount":              this.SafeString(order, "origQty"),
		"filled":              this.SafeString(order, "executedQty"),
		"remaining":           nil,
		"trades":              nil,
		"fee":                 nil,
		"marginMode":          nil,
		"reduceOnly":          nil,
		"leverage":            nil,
		"hedged":              nil,
	}, market)
}
func (this *toobit) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"PENDING_NEW":      "open",
		"NEW":              "open",
		"PARTIALLY_FILLED": "open",
		"FILLED":           "closed",
		"PENDING_CANCEL":   "canceled",
		"CANCELED":         "canceled",
		"REJECTED":         "canceled",
	}
	return this.SafeString(statuses, status, status)
}
func (this *toobit) ParseOrderType(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"MARKET":      "market",
		"LIMIT":       "limit",
		"LIMIT_MAKER": "limit",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name toobit#cancelOrder
 * @description cancels an open order
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-order-trade
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-order-trade
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsEqual(this.SafeString(params, "clientOrderId"), nil)) {
			AddElementToObject(request, "orderId", id)
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params, "none")
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "none")) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")))
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateDeleteApiV1SpotOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateDeleteApiV1FuturesOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		// response same as in `createOrder`
		var status interface{} = this.ParseOrderStatus(this.SafeString(response, "status"))
		if IsTrue(!IsEqual(status, "open")) {
			panic(OrderNotFound(Add(Add(Add(Add(this.Id, " order "), id), " can not be canceled, "), this.Json(response))))
		}

		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-all-open-orders-trade
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-orders-trade
 * @param {string} symbol unified symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18688 := (<-this.LoadMarkets())
		PanicOnError(retRes18688)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params, "none")
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "none")) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")))
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateDeleteApiV1SpotOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateDeleteApiV1FuturesBatchOrders(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- []interface{}{this.SafeOrder(map[string]interface{}{
			"info": response,
		})}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#cancelOrders
 * @description cancel multiple orders
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#cancel-multiple-orders-trade
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#cancel-multiple-orders-trade
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes19118 := (<-this.LoadMarkets())
		PanicOnError(retRes19118)
		var idsString interface{} = Join(ids, ",")
		var request interface{} = map[string]interface{}{
			"ids": idsString,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrders", market, params, "none")
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "none")) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument or the \"defaultType\" parameter to be set to \"spot\" or \"swap\"")))
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateDeleteApiV1SpotCancelOrderByIds(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateDeleteApiV1FuturesCancelOrderByIds(this.Extend(request, params)))
			PanicOnError(response)
		}
		var result interface{} = this.SafeList(response, "result", []interface{}{})

		ch <- this.ParseOrders(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#query-order-user_data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-order-user_data
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
		}

		retRes19698 := (<-this.LoadMarkets())
		PanicOnError(retRes19698)
		var request interface{} = map[string]interface{}{
			"orderId": id,
		}
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PrivateGetApiV1SpotOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetApiV1FuturesOrder(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//    {
		//        "time": "1756140208069",
		//        "updateTime": "1756140208078",
		//        "orderId": "2025045271033977089",
		//        "clientOrderId": "17561402075722006",
		//        "symbol": "ETHUSDT",
		//        "price": "3000",
		//        "origQty": "0.002",
		//        "executedQty": "0",
		//        "avgPrice": "0",
		//        "type": "LIMIT",
		//        "side": "BUY",
		//        "timeInForce": "GTC",
		//        "status": "NEW",
		//        "accountId": "1783404067076253952",  // only in SPOT
		//        "exchangeId": "301",                 // only in SPOT
		//        "symbolName": "ETHUSDT",             // only in SPOT
		//        "cummulativeQuoteQty": "0",          // only in SPOT
		//        "cumulativeQuoteQty": "0",           // only in SPOT
		//        "stopPrice": "0.0",                  // only in SPOT
		//        "icebergQty": "0.0",                 // only in SPOT
		//        "isWorking": true                    // only in SPOT
		//        "leverage": "2",                     // only in CONTRACT
		//        "marginLocked": "9.5",               // only in CONTRACT
		//        "priceType": "INPUT"                 // only in CONTRACT
		//    }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#current-open-orders-user_data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-current-open-order-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes20248 := (<-this.LoadMarkets())
		PanicOnError(retRes20248)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateGetApiV1SpotOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetApiV1FuturesOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#all-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes20848 := (<-this.LoadMarkets())
		PanicOnError(retRes20848)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateGetApiV1SpotTradeOrders(request))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchOrders() is not supported for "), marketType), " markets")))
		}

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-history-orders-user_data
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *toobit) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// returns the most recent closed or canceled orders up to circa two weeks ago
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes21498 := (<-this.LoadMarkets())
		PanicOnError(retRes21498)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchOrders() is not supported for "), marketType), " markets")))
		} else {

			response = (<-this.PrivateGetApiV1FuturesHistoryOrders(request))
			PanicOnError(response)
		}
		var ordersList interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			AppendToArray(&ordersList, map[string]interface{}{
				"result": GetValue(response, i),
			})
		}

		ch <- this.ParseOrders(ordersList, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#account-trade-list-user_data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#account-trade-list-user_data
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *toobit) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes22188 := (<-this.LoadMarkets())
		PanicOnError(retRes22188)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var market interface{} = this.Market(symbol)
		AddElementToObject(request, "symbol", GetValue(market, "id"))
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateGetApiV1AccountTrades(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetApiV1FuturesUserTrades(request))
			PanicOnError(response)
		}

		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://open.big.one/docs/spot_transfer.html#transfer-of-user
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'spot', 'swap'
 * @param {string} toAccount 'spot', 'swap'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *toobit) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22988 := (<-this.LoadMarkets())
		PanicOnError(retRes22988)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		var request interface{} = map[string]interface{}{
			"asset":           GetValue(currency, "id"),
			"quantity":        this.CurrencyToPrecision(code, amount),
			"fromAccountType": fromId,
			"toAccountType":   toId,
		}

		response := (<-this.PrivatePostApiV1SubAccountTransfer(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//     "code": 200, // 200 = success
		//     "msg": "success" // response message
		//    }
		//
		ch <- this.ParseTransfer(response, currency)
		return nil

	}()
	return ch
}
func (this *toobit) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//     "code": 200, // 200 = success
	//     "msg": "success" // response message
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	return map[string]interface{}{
		"info":        transfer,
		"id":          nil,
		"timestamp":   nil,
		"datetime":    nil,
		"currency":    nil,
		"amount":      nil,
		"fromAccount": nil,
		"toAccount":   nil,
		"status":      nil,
	}
}

/**
 * @method
 * @name toobit#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#get-account-transaction-history-list-user_data
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-future-account-transaction-history-list-user_data
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func (this *toobit) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes23538 := (<-this.LoadMarkets())
		PanicOnError(retRes23538)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.PrivateGetApiV1AccountBalanceFlow(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetApiV1FuturesBalanceFlow(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		// both answers are same format
		//
		// [
		//     {
		//         "id": "539870570957903104",
		//         "accountId": "122216245228131",
		//         "coin": "BTC",
		//         "coinId": "BTC",
		//         "coinName": "BTC",
		//         "flowTypeValue": 51,
		//         "flowType": "USER_ACCOUNT_TRANSFER",
		//         "flowName": "Transfer",
		//         "change": "-12.5",
		//         "total": "379.624059937852365",
		//         "created": "1579093587214"
		//     },
		//
		ch <- this.ParseLedger(response, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *toobit) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(item, "coinId")
	currency = this.SafeCurrency(currencyId, currency)
	var timestamp interface{} = this.SafeInteger(item, "created")
	var after interface{} = this.SafeNumber(item, "total")
	var amountRaw interface{} = this.SafeString(item, "change")
	var amount interface{} = this.ParseNumber(Precise.StringAbs(amountRaw))
	var direction interface{} = "in"
	if IsTrue(StartsWith(amountRaw, "-")) {
		direction = "out"
	}
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "id"),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"direction":        direction,
		"account":          nil,
		"referenceId":      nil,
		"referenceAccount": nil,
		"type":             this.ParseLedgerType(this.SafeString(item, "flowType")),
		"currency":         GetValue(currency, "code"),
		"amount":           amount,
		"before":           nil,
		"after":            after,
		"status":           nil,
		"fee":              nil,
	}, currency)
}
func (this *toobit) ParseLedgerType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"USER_ACCOUNT_TRANSFER": "transfer",
		"AIRDROP":               "rebate",
	}
	return this.SafeString(types, typeVar, typeVar)
}

/**
 * @method
 * @name toobit#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#user-trade-fee-rate-user_data
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func (this *toobit) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes24438 := (<-this.LoadMarkets())
		PanicOnError(retRes24438)
		var response interface{} = nil
		var marketType interface{} = nil
		var market interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchTradingFees(): does not support "), marketType), " markets")))
		} else if IsTrue(this.InArray(marketType, []interface{}{"swap", "future"})) {
			var symbol interface{} = nil
			symbolparamsVariable := this.HandleParamString(params, "symbol")
			symbol = GetValue(symbolparamsVariable, 0)
			params = GetValue(symbolparamsVariable, 1)
			if IsTrue(IsEqual(symbol, nil)) {
				panic(BadRequest(Add(this.Id, " fetchTradingFees requires a params[\"symbol\"]")))
			}
			market = this.Market(symbol)
			var request interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}

			response = (<-this.PrivateGetApiV1FuturesCommissionRate(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// {
		//     "openMakerFee": "0.000006", // The trade fee rate for opening pending orders
		//     "openTakerFee": "0.0001", // The trade fee rate for open position taker
		//     "closeMakerFee": "0.0002", // The trade fee rate for closing pending orders
		//     "closeTakerFee": "0.0004" // The trade fee rate for closing a taker order
		// }
		//
		var result interface{} = map[string]interface{}{}
		var entry interface{} = response
		var marketId interface{} = this.SafeString(entry, "symbol")
		market = this.SafeMarket(marketId, market)
		var fee interface{} = this.ParseTradingFee(entry, market)
		AddElementToObject(result, GetValue(market, "symbol"), fee)

		ch <- result
		return nil

	}()
	return ch
}
func (this *toobit) ParseTradingFee(data interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(data, "symbol")
	return map[string]interface{}{
		"info":       data,
		"symbol":     this.SafeSymbol(marketId, market),
		"maker":      this.SafeNumber(data, "closeMakerFee"),
		"taker":      this.SafeNumber(data, "closeTakerFee"),
		"percentage": nil,
		"tierBased":  nil,
	}
}

/**
 * @method
 * @name toobit#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#deposit-history-user_data
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposit structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *toobit) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes250315 := (<-this.FetchDepositsOrWithdrawalsHelper("deposits", code, since, limit, params))
		PanicOnError(retRes250315)
		ch <- retRes250315
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#withdrawal-records-user_data
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *toobit) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes251815 := (<-this.FetchDepositsOrWithdrawalsHelper("withdrawals", code, since, limit, params))
		PanicOnError(retRes251815)
		ch <- retRes251815
		return nil

	}()
	return ch
}
func (this *toobit) FetchDepositsOrWithdrawalsHelper(typeVar interface{}, code interface{}, since interface{}, limit interface{}, params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		retRes25228 := (<-this.LoadMarkets())
		PanicOnError(retRes25228)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "deposits")) {

			response = (<-this.PrivateGetApiV1AccountDepositOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "withdrawals")) {

			response = (<-this.PrivateGetApiV1AccountWithdrawOrders(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.ParseTransactions(response, currency, since, limit, params)
		return nil

	}()
	return ch
}
func (this *toobit) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits & fetchWithdrawals
	//
	//     {
	//         "time": 1499865549590,
	//         "id": 100234,
	//         "coinName": "EOS",
	//         "statusCode": "DEPOSIT_CAN_WITHDRAW",
	//         "status": "2", // 2=SUCCESS, 11=REJECT, 12=AUDIT
	//         "address": "deposit2bb",
	//         "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
	//         "txIdUrl": "",
	//         "requiredConfirmTimes": "5",
	//         "confirmTimes": "5",
	//         "quantity": "1.01",
	//         "coin": "EOS",                     // present in "fetchDeposits"
	//         "coinId ":"BHC",                   // present in "fetchWithdrawals"
	//         "addressTag": "19012584",          // present in "fetchDeposits"
	//         "addressExt":"address tag",        // present in "fetchWithdrawals"
	//         "fromAddress": "clarkkent",        // present in "fetchDeposits"
	//         "fromAddressTag": "19029901"       // present in "fetchDeposits"
	//         "arriveQuantity":"14",             // present in "fetchWithdrawals"
	//         "walletHandleTime":"1536232111669",// present in "fetchWithdrawals"
	//         "feeCoinId ":"BHC",                // present in "fetchWithdrawals"
	//         "feeCoinName ":"BHC",              // present in "fetchWithdrawals"
	//         "fee":"0.1",                       // present in "fetchWithdrawals"
	//         "kernelId":"",                     // present in "fetchWithdrawals"
	//         "isInternalTransfer": false        // present in "fetchWithdrawals"
	//     }
	//
	// withdraw
	//
	//     {
	//         "status": 0,
	//         "success": true,
	//         "needBrokerAudit": false, // Do you need a brokerage review?
	//         "id": "423885103582776064",
	//         "refuseReason":"" // failure rejection reason
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transaction, "time")
	var currencyId interface{} = this.SafeString2(transaction, "coin", "coinId")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var feeString interface{} = this.SafeString(transaction, "fee")
	var feeCoin interface{} = this.SafeString(transaction, "feeCoinName")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeString, nil)) {
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeString),
			"currency": this.SafeCurrencyCode(feeCoin),
		}
	}
	var tagTo interface{} = this.SafeString2(transaction, "addressTag", "addressExt")
	var tagFrom interface{} = this.SafeString(transaction, "fromAddressTag")
	var addressTo interface{} = this.SafeString(transaction, "address")
	var addressFrom interface{} = this.SafeString(transaction, "fromAddress")
	var isWithdraw interface{} = (InOp(transaction, "arriveQuantity"))
	var typeVar interface{} = Ternary(IsTrue(isWithdraw), "withdrawal", "deposit")
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString(transaction, "id"),
		"txid":        this.SafeString(transaction, "txId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     nil,
		"address":     nil,
		"addressTo":   addressTo,
		"addressFrom": addressFrom,
		"tag":         nil,
		"tagTo":       tagTo,
		"tagFrom":     tagFrom,
		"type":        typeVar,
		"amount":      this.SafeNumber(transaction, "quantity"),
		"currency":    code,
		"status":      this.ParseTransactionStatus(this.SafeString(transaction, "status")),
		"updated":     nil,
		"fee":         fee,
		"comment":     nil,
		"internal":    nil,
	}
}
func (this *toobit) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"2":  "pending",
		"12": "pending",
		"11": "failed",
		"3":  "ok",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name toobit#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#deposit-address-user_data
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *toobit) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes26968 := (<-this.LoadMarkets())
		PanicOnError(retRes26968)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin": GetValue(currency, "id"),
		}
		networkCodeparamsOmittedVariable := this.HandleNetworkCodeAndParams(this.Extend(request, params))
		networkCode := GetValue(networkCodeparamsOmittedVariable, 0)
		paramsOmitted := GetValue(networkCodeparamsOmittedVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() : param[\"network\"] is required")))
		}
		AddElementToObject(request, "chainType", this.NetworkCodeToId(networkCode))

		response := (<-this.PrivateGetApiV1AccountDepositAddress(this.Extend(request, paramsOmitted)))
		PanicOnError(response)

		//
		//     {
		//         "canDeposit":false,//Is it possible to recharge
		//         "address":"0x815bF1c3cc0f49b8FC66B21A7e48fCb476051209",
		//         "addressExt":"address tag",
		//         "minQuantity":"100",//minimum amount
		//         "requiredConfirmTimes ":1,//Arrival confirmation number
		//         "canWithdrawConfirmNum ":12,//Withdrawal confirmation number
		//         "coinType":"ERC20_TOKEN"
		//     }
		//
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}
func (this *toobit) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "address")
	this.CheckAddress(address)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": this.SafeString(currency, "code"),
		"network":  nil,
		"address":  address,
		"tag":      this.SafeString(depositAddress, "addressExt"),
	}
}

/**
 * @method
 * @name toobit#withdraw
 * @description make a withdrawal
 * @see https://toobit-docs.github.io/apidocs/spot/v1/en/#withdraw-user_data
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag a memo for the transaction
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *toobit) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		this.CheckAddress(address)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " withdraw() : param[\"network\"] is required")))
		}

		retRes27528 := (<-this.LoadMarkets())
		PanicOnError(retRes27528)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin":     GetValue(currency, "id"),
			"address":  address,
			"quantity": this.CurrencyToPrecision(GetValue(currency, "code"), amount),
			"network":  networkCode,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "addressExt", tag)
		}

		response := (<-this.PrivatePostApiV1AccountWithdraw(this.Extend(request, params)))
		PanicOnError(response)

		//
		// {
		//     "status": 0,
		//     "success": true,
		//     "needBrokerAudit": false, // Do you need a brokerage review?
		//     "id": "423885103582776064", // Withdrawal successful order id
		//     "refuseReason":"" // failure rejection reason
		// }
		//
		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#change-margin-type-trade
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *toobit) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}

		retRes27908 := (<-this.LoadMarkets())
		PanicOnError(retRes27908)
		var market interface{} = this.Market(symbol)
		if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
			panic(BadSymbol(Add(this.Id, " setMarginMode() supports swap contracts only")))
		}
		marginMode = ToUpper(marginMode)
		var request interface{} = map[string]interface{}{
			"symbol":     GetValue(market, "id"),
			"marginType": marginMode,
		}

		response := (<-this.PrivatePostApiV1FuturesMarginType(this.Extend(request, params)))
		PanicOnError(response)

		//
		// {"code":200,"symbolId":"BTC-SWAP-USDT","marginType":"ISOLATED"}
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#setLeverage
 * @description set the level of leverage for a market
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#change-initial-leverage-trade
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *toobit) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes28218 := (<-this.LoadMarkets())
		PanicOnError(retRes28218)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"leverage": leverage,
		}

		response := (<-this.PrivatePostApiV1FuturesLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		// {"code":200,"symbolId":"BTC-SWAP-USDT","leverage":"19"}
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name toobit#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#get-the-leverage-multiple-and-position-mode-user_data
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *toobit) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes28448 := (<-this.LoadMarkets())
		PanicOnError(retRes28448)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateGetApiV1FuturesAccountLeverage(this.Extend(request, params)))
		PanicOnError(response)
		//
		// [
		//     {
		//         "symbol":"BTC-SWAP-USDT", //symbol
		//         "leverage":"20",  // leverage
		//         "marginType":"CROSS" // CROSS;ISOLATED
		//     }
		// ]
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *toobit) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(leverage, "symbol")
	var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
	var marginType interface{} = this.SafeString(leverage, "marginType")
	var marginMode interface{} = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", "isolated")
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        this.SafeSymbol(marketId, market),
		"marginMode":    marginMode,
		"longLeverage":  leverageValue,
		"shortLeverage": leverageValue,
	}
}

/**
 * @method
 * @name toobit#fetchPositions
 * @description fetch all open positions
 * @see https://toobit-docs.github.io/apidocs/usdt_swap/v1/en/#query-position-user_data
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *toobit) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes28878 := (<-this.LoadMarkets())
		PanicOnError(retRes28878)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			if IsTrue(IsGreaterThan(length, 1)) {
				panic(BadRequest(Add(this.Id, " fetchPositions() only accepts an array with a single symbol or without symbols argument")))
			}
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			if IsTrue(!IsEqual(firstSymbol, nil)) {
				market = this.Market(firstSymbol)
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}

		response := (<-this.PrivateGetApiV1FuturesPositions(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "DOGE-SWAP-USDT",
		//            "side": "LONG",
		//            "avgPrice": "0.21191",
		//            "position": "63",
		//            "available": "63",
		//            "leverage": "25",
		//            "lastPrice": "0.20932",
		//            "positionValue": "13.3503",
		//            "flp": "0.05471",
		//            "margin": "0.5262",
		//            "marginRate": "",
		//            "unrealizedPnL": "-0.1701",
		//            "profitRate": "-0.3185",
		//            "realizedPnL": "-0.008",
		//            "minMargin": "0",
		//            "maxNotionalValue": "10000000",
		//            "markPrice": "0.20921"
		//        }
		//    ]
		//
		ch <- this.ParsePositions(response, symbols)
		return nil

	}()
	return ch
}
func (this *toobit) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "symbol")
	market = this.SafeMarket(marketId, market)
	var side interface{} = this.SafeStringLower(position, "side")
	var quantity interface{} = this.SafeString(position, "position")
	var leverage interface{} = this.SafeInteger(position, "leverage")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          this.SafeString(position, "id"),
		"symbol":                      GetValue(market, "symbol"),
		"entryPrice":                  this.SafeString(position, "avgPrice"),
		"markPrice":                   this.SafeString(position, "markPrice"),
		"lastPrice":                   this.SafeString(position, "lastPrice"),
		"notional":                    this.SafeString(position, "positionValue"),
		"collateral":                  nil,
		"unrealizedPnl":               this.SafeString(position, "unrealizedPnL"),
		"side":                        side,
		"contracts":                   this.ParseNumber(quantity),
		"contractSize":                nil,
		"timestamp":                   nil,
		"datetime":                    nil,
		"hedged":                      nil,
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": nil,
		"initialMargin":               this.SafeString(position, "margin"),
		"initialMarginPercentage":     nil,
		"leverage":                    leverage,
		"liquidationPrice":            nil,
		"marginRatio":                 nil,
		"marginMode":                  nil,
		"percentage":                  nil,
	})
}
func (this *toobit) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.ImplodeParams(path, params))
	var isPost interface{} = IsEqual(method, "POST")
	var isDelete interface{} = IsEqual(method, "DELETE")
	var extraQuery interface{} = map[string]interface{}{}
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	if IsTrue(!IsEqual(api, "private")) {
		// Public endpoints
		if !IsTrue(isPost) {
			if IsTrue(GetArrayLength(ObjectKeys(query))) {
				url = Add(url, Add("?", this.Urlencode(query)))
			}
		}
	} else {
		this.CheckRequiredCredentials()
		var timestamp interface{} = this.Milliseconds()
		// Add timestamp to parameters for signed endpoints
		AddElementToObject(extraQuery, "recvWindow", this.SafeString(this.Options, "recvWindow", "5000"))
		AddElementToObject(extraQuery, "timestamp", ToString(timestamp))
		var queryExtended interface{} = this.Extend(query, extraQuery)
		var queryString interface{} = ""
		if IsTrue(IsTrue(isPost) || IsTrue(isDelete)) {
			// everything else except Batch-Orders
			if !IsTrue(IsArray(params)) {
				body = this.Urlencode(queryExtended)
			} else {
				queryString = this.Urlencode(extraQuery)
				body = this.Json(query)
			}
		} else {
			queryString = this.Urlencode(queryExtended)
		}
		var payload interface{} = queryString
		if IsTrue(!IsEqual(body, nil)) {
			payload = Add(body, payload)
		}
		var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "hex")
		if IsTrue(!IsEqual(queryString, "")) {
			queryString = Add(queryString, Add("&signature=", signature))
			url = Add(url, Add("?", queryString))
		} else {
			body = Add(body, Add("&signature=", signature))
		}
		headers = map[string]interface{}{
			"X-BB-APIKEY":  this.ApiKey,
			"Content-Type": "application/x-www-form-urlencoded",
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *toobit) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	var errorCode interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString(response, "msg")
	if IsTrue(IsTrue(IsTrue(errorCode) && IsTrue(!IsEqual(errorCode, "200"))) && IsTrue(!IsEqual(errorCode, "0"))) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *toobit) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
