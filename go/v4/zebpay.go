package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ZebpayCore struct {
	Exchange
}

func NewZebpayCore() *ZebpayCore {
	p := &ZebpayCore{}
	setDefaults(p)
	return p
}

func (this *ZebpayCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "zebpay",
		"name":      "Zebpay",
		"countries": []interface{}{"IN"},
		"rateLimit": 50,
		"version":   "v1",
		"certified": false,
		"pro":       false,
		"has": map[string]interface{}{
			"CORS":                      nil,
			"spot":                      true,
			"margin":                    false,
			"swap":                      true,
			"future":                    false,
			"option":                    nil,
			"addMargin":                 true,
			"borrowCrossMargin":         false,
			"borrowIsolatedMargin":      false,
			"borrowMargin":              false,
			"cancelAllOrders":           true,
			"cancelOrder":               true,
			"cancelOrders":              false,
			"closePosition":             true,
			"createOrder":               true,
			"fetchBalance":              true,
			"fetchBorrowInterest":       false,
			"fetchBorrowRate":           false,
			"fetchBorrowRateHistories":  false,
			"fetchBorrowRateHistory":    false,
			"fetchBorrowRates":          false,
			"fetchBorrowRatesPerSymbol": false,
			"fetchCrossBorrowRate":      false,
			"fetchCrossBorrowRates":     false,
			"fetchCurrencies":           true,
			"fetchIsolatedBorrowRate":   false,
			"fetchIsolatedBorrowRates":  false,
			"fetchLeverage":             true,
			"fetchLeverages":            true,
			"fetchMarkets":              true,
			"fetchMyTrades":             true,
			"fetchOHLCV":                true,
			"fetchOpenOrders":           true,
			"fetchOrder":                true,
			"fetchOrderBook":            true,
			"fetchOrderTrades":          true,
			"fetchPositions":            true,
			"fetchTicker":               true,
			"fetchTickers":              true,
			"fetchTrades":               true,
			"fetchTradingFee":           true,
			"reduceMargin":              true,
			"repayCrossMargin":          false,
			"repayIsolatedMargin":       false,
			"setLeverage":               true,
		},
		"timeframes": map[string]interface{}{
			"1m":  1,
			"5m":  5,
			"15m": 15,
			"30m": 30,
			"1h":  60,
			"2h":  120,
			"4h":  480,
			"12h": 720,
			"1d":  1440,
			"1w":  10080,
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/8094e7be-55a7-46f4-a087-0ca31b48ecad",
			"api": map[string]interface{}{
				"spot": "https://sapi.zebpay.com",
				"swap": "https://futuresbe.zebpay.com",
			},
			"test": map[string]interface{}{
				"spot": "https://www.zebstage.com",
				"swap": "https://dev-futuresbe.zebstage.com",
			},
			"www":  "https://www.zebpay.com",
			"doc":  "https://github.com/zebpay/zebpay-api-references",
			"fees": "https://zebpay.com/in/features/pricing",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"spot": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/system/time":       10,
						"v2/system/status":     10,
						"v2/market/orderbook":  10,
						"v2/market/trades":     10,
						"v2/market/ticker":     10,
						"v2/market/allTickers": 10,
						"v2/ex/exchangeInfo":   10,
						"v2/ex/currencies":     10,
						"v2/market/klines":     10,
						"v2/ex/tradefees":      10,
					},
				},
				"swap": map[string]interface{}{
					"get": map[string]interface{}{
						"v1/system/time":        10,
						"v1/system/status":      10,
						"v1/exchange/tradefee":  10,
						"v1/exchange/tradefees": 10,
						"v1/market/orderBook":   10,
						"v1/market/ticker24Hr":  10,
						"v1/market/markets":     10,
						"v1/market/aggTrade":    10,
					},
					"post": map[string]interface{}{
						"v1/market/klines": 10,
					},
				},
			},
			"private": map[string]interface{}{
				"spot": map[string]interface{}{
					"post": map[string]interface{}{
						"v2/ex/orders": 10,
					},
					"get": map[string]interface{}{
						"v2/ex/orders":       10,
						"v2/account/balance": 10,
						"v2/ex/tradefee":     10,
						"v2/ex/order":        10,
						"v2/ex/order/fills":  10,
					},
					"delete": map[string]interface{}{
						"v2/ex/order":            10,
						"v2/ex/orders":           10,
						"v2/ex/orders/cancelAll": 10,
					},
				},
				"swap": map[string]interface{}{
					"get": map[string]interface{}{
						"v1/wallet/balance":          10,
						"v1/trade/order":             10,
						"v1/trade/order/open-orders": 10,
						"v1/trade/userLeverages":     10,
						"v1/trade/userLeverage":      10,
						"v1/trade/positions":         10,
						"v1/trade/history":           10,
					},
					"post": map[string]interface{}{
						"v1/trade/order":               10,
						"v1/trade/order/addTPSL":       10,
						"v1/trade/addMargin":           10,
						"v1/trade/reduceMargin":        10,
						"v1/trade/position/close":      10,
						"v1/trade/update/userLeverage": 10,
					},
					"delete": map[string]interface{}{
						"v1/trade/order": 10,
					},
				},
			},
		},
		"precisionMode":    TICK_SIZE,
		"fees":             map[string]interface{}{},
		"commonCurrencies": map[string]interface{}{},
		"requiredCredentials": map[string]interface{}{
			"apiKey": true,
			"secret": true,
		},
		"options": map[string]interface{}{
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "swap"},
			},
			"defaultType": "spot",
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"fetchOHLCV": map[string]interface{}{
					"limit": 100,
				},
			},
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"77":                              InvalidOrder,
				"400":                             BadRequest,
				"401":                             AuthenticationError,
				"403":                             NotSupported,
				"404":                             NotSupported,
				"429":                             RateLimitExceeded,
				"500":                             ExchangeNotAvailable,
				"503":                             ExchangeNotAvailable,
				"3013":                            OrderNotFound,
				"Order quantity is out of range":  InvalidOrder,
				"Invalid trade order type":        InvalidOrder,
				"Insufficient margin":             InsufficientFunds,
				"insufficient balance":            InsufficientFunds,
				"leverage must be in [1,8]":       BadRequest,
				"the request you sent is invalid": BadRequest,
			},
			"broad": map[string]interface{}{
				"InvalidOrder": InvalidOrder,
			},
		},
	})
}

/**
 * @method
 * @name zebpay#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#system-status
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/system.md#get-system-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *ZebpayCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchStatus", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var response interface{} = nil
		var data interface{} = map[string]interface{}{}
		if IsTrue(isSpot) {

			response = (<-this.PublicSpotGetV2SystemStatus(params))
			PanicOnError(response)
			data = response
		} else {

			response = (<-this.PublicSwapGetV1SystemStatus(params))
			PanicOnError(response)
			data = this.SafeDict(response, "data", map[string]interface{}{})
		}
		//
		// {
		//     "statusDescription": "OK",
		//     "data":
		//      {
		//        "systemStatus": "ok"
		//       }
		//     "statusCode": 200,
		//     "customMessage": ["OK"]
		// }
		//
		var status interface{} = this.SafeString2(data, "systemStatus", "status")

		ch <- map[string]interface{}{
			"status":  status,
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpayfutures#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the poloniexfutures server
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-server-time
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/system.md#get-system-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the poloniexfutures server
 */
func (this *ZebpayCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTime", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var response interface{} = nil
		var data interface{} = map[string]interface{}{}
		if IsTrue(isSpot) {

			response = (<-this.PublicSpotGetV2SystemTime(params))
			PanicOnError(response)
			data = response
		} else {

			response = (<-this.PublicSwapGetV1SystemTime(params))
			PanicOnError(response)
			data = this.SafeDict(response, "data", map[string]interface{}{})
		}
		//
		// {
		//     "statusDescription": "OK",
		//     "data":
		//      {
		//        "timestamp": 1546837113087
		//      }
		//     "statusCode": 200,
		//     "customMessage": ["OK"]
		// }
		//
		var time interface{} = this.SafeInteger(data, "timestamp")

		ch <- time
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchMarkets
 * @description retrieves data on all markets for zebpay
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-trading-pairs
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#fetch-markets
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *ZebpayCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var promisesUnresolved interface{} = []interface{}{}
		var fetchMarketsOptions interface{} = this.SafeDict(this.Options, "fetchMarkets")
		var defaultMarkets interface{} = []interface{}{"spot", "swap"}
		var types interface{} = this.SafeList(fetchMarketsOptions, "types", defaultMarkets)
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			var typeVar interface{} = GetValue(types, i)
			if IsTrue(IsEqual(typeVar, "spot")) {
				AppendToArray(&promisesUnresolved, this.FetchSpotMarkets(params))
			} else if IsTrue(IsEqual(typeVar, "swap")) {
				AppendToArray(&promisesUnresolved, this.FetchSwapMarkets(params))
			} else {
				panic(ExchangeError(Add(Add(Add(this.Id, " fetchMarkets() this.options fetchMarkets \""), typeVar), "\" is not a supported market type")))
			}
		}

		promises := (<-promiseAll(promisesUnresolved))
		PanicOnError(promises)
		var spotMarkets interface{} = this.SafeList(promises, 0, []interface{}{})
		var futureMarkets interface{} = this.SafeList(promises, 1, []interface{}{})

		ch <- this.ArrayConcat(spotMarkets, futureMarkets)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-coin-settings
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *ZebpayCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicSpotGetV2ExCurrencies(params))
		PanicOnError(response)
		//
		//     {
		//             "data": [
		//                 {
		//                     "currency": "BTC",
		//                     "name": "BTC",
		//                     "fullName": "150",
		//                     "precision": "0.2",
		//                     "type": "fiat",
		//                     "isDebitEnabled": false,
		//                     "chains": [
		//                         {
		//                             "chainName": "Bitcoin",
		//                             "withdrawalMinSize": "0.000482",
		//                             "depositMinSize": "0.00000001",
		//                             "withdrawalFee": "0.00040000",
		//                             "isWithdrawEnabled": "true",
		//                             "isDepositEnabled": "true",
		//                             "contractAddress": "0x095418A82BC2439703b69fbE1210824F2247D77c",
		//                             "withdrawPrecision": "8",
		//                             "maxWithdraw": "2.43090487000000",
		//                             "maxDeposit": "100.00000000",
		//                             "needTag": "false",
		//                             "chainId": "bitcoin",
		//                             "AddressRegex": "^tb1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{39,59}|m[a-zA-Z0-9]{25,34}|n[a-zA-Z0-9]{25,34}|^2[a-zA-Z0-9]{25,34}$"
		//                          }
		//                     ]
		//                 }
		//             ]
		//     }
		//
		var rows interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(rows)); i++ {
			var currency interface{} = GetValue(rows, i)
			var currencyId interface{} = this.SafeString(currency, "currency")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var name interface{} = this.SafeString(currency, "name")
			var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "precision")))
			var chains interface{} = this.SafeList(currency, "chains", []interface{}{})
			var networks interface{} = map[string]interface{}{}
			var minWithdrawFeeString interface{} = nil
			var minWithdrawString interface{} = nil
			var minDepositString interface{} = nil
			var deposit interface{} = false
			var withdraw interface{} = false
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString(chain, "chainId")
				var networkCode interface{} = this.NetworkIdToCode(networkId)
				var depositAllowed interface{} = IsEqual(this.SafeBool(chain, "isDepositEnabled"), true)
				deposit = Ternary(IsTrue((depositAllowed)), depositAllowed, deposit)
				var withdrawAllowed interface{} = IsEqual(this.SafeBool(chain, "isWithdrawEnabled"), true)
				withdraw = Ternary(IsTrue((withdrawAllowed)), withdrawAllowed, withdraw)
				var withdrawFeeString interface{} = this.SafeString(chain, "withdrawalFee")
				if IsTrue(!IsEqual(withdrawFeeString, nil)) {
					minWithdrawFeeString = Ternary(IsTrue((IsEqual(minWithdrawFeeString, nil))), withdrawFeeString, Precise.StringMin(withdrawFeeString, minWithdrawFeeString))
				}
				var minNetworkWithdrawString interface{} = this.SafeString(chain, "withdrawalMinSize")
				if IsTrue(!IsEqual(minNetworkWithdrawString, nil)) {
					minWithdrawString = Ternary(IsTrue((IsEqual(minWithdrawString, nil))), minNetworkWithdrawString, Precise.StringMin(minNetworkWithdrawString, minWithdrawString))
				}
				var minNetworkDepositString interface{} = this.SafeString(chain, "depositMinSize")
				if IsTrue(!IsEqual(minNetworkDepositString, nil)) {
					minDepositString = Ternary(IsTrue((IsEqual(minDepositString, nil))), minNetworkDepositString, Precise.StringMin(minNetworkDepositString, minDepositString))
				}
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"info":      chain,
					"id":        networkId,
					"network":   networkCode,
					"active":    IsTrue(depositAllowed) && IsTrue(withdrawAllowed),
					"deposit":   depositAllowed,
					"withdraw":  withdrawAllowed,
					"fee":       this.ParseNumber(withdrawFeeString),
					"precision": precision,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.ParseNumber(minNetworkWithdrawString),
							"max": nil,
						},
						"deposit": map[string]interface{}{
							"min": this.ParseNumber(minNetworkDepositString),
							"max": nil,
						},
					},
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      currency,
				"code":      code,
				"id":        currencyId,
				"name":      name,
				"active":    IsTrue(deposit) && IsTrue(withdraw),
				"deposit":   deposit,
				"withdraw":  withdraw,
				"fee":       this.ParseNumber(minWithdrawFeeString),
				"precision": precision,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": this.ParseNumber(minWithdrawString),
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": this.ParseNumber(minDepositString),
						"max": nil,
					},
				},
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-exchange-fee
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/exchange.md#get-trade-fee-single-symbol
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.side] side to fetch trading fee
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *ZebpayCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes4678 := (<-this.LoadMarkets())
		PanicOnError(retRes4678)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var data interface{} = nil
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PrivateSpotGetV2ExTradefee(this.Extend(request, params)))
			PanicOnError(response)
			//
			// {
			//     "statusDescription": "Success",
			//     "data":
			//       {
			//         "symbol": "BTCINR",
			//         "takerFeeRate": "0.01",
			//         "makerFeeRate": "0.05",
			//         "percentage": true
			//       } ,
			//     "statusCode": 200,
			// }
			data = this.SafeDict(response, "data", map[string]interface{}{})
		} else {

			response = (<-this.PublicSwapGetV1ExchangeTradefee(this.Extend(request, params)))
			PanicOnError(response)
			//
			// {
			//     "statusDescription": "OK",
			//     "data":
			//     [
			//       {
			//         "symbol": "BTCINR",
			//         "takerFee": "0.01",
			//         "makerFee": "0.05"
			//       }
			//     ] ,
			//     "statusCode": 200,
			//     "customMessage": ["OK"]
			// }
			//
			var responseData interface{} = this.SafeList(response, "data", []interface{}{})
			data = this.SafeDict(responseData, 0)
		}

		ch <- this.ParseTradingFee(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay(futures)#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/exchange.md#get-trade-fees-all-symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *ZebpayCore) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.PublicSpotGetV2ExTradefees(params))
			PanicOnError(response)
		} else {

			response = (<-this.PublicSwapGetV1ExchangeTradefees(params))
			PanicOnError(response)
		}
		//
		// {
		//     "statusDescription": "OK",
		//     "data": [
		//         {
		//             "symbol": "BTCINR",
		//             "takerFee": "0.01",
		//             "makerFee": "0.05"
		//         }
		//     ],
		//     "statusCode": 200,
		//     "customMessage": ["OK"]
		// }
		//
		var fees interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
			var fee interface{} = this.ParseTradingFee(GetValue(fees, i))
			var symbol interface{} = GetValue(fee, "symbol")
			AddElementToObject(result, symbol, fee)
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-order-book
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *ZebpayCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes5658 := (<-this.LoadMarkets())
		PanicOnError(retRes5658)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			//
			//       {
			//         "asks": [
			//                 [5000, 1000],           //Price, quantity
			//                 [6000, 1983]            //Price, quantity
			//         ],
			//         "bids": [
			//                 [3200, 800],            //Price, quantity
			//                 [3100, 100]             //Price, quantity
			//         ],
			//       }
			// }

			response = (<-this.PublicSpotGetV2MarketOrderbook(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicSwapGetV1MarketOrderBook(this.Extend(request, params)))
			PanicOnError(response)
		}
		var bookData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orderbook interface{} = this.ParseOrderBook(bookData, GetValue(market, "symbol"), nil, "bids", "asks", 0, 1)
		AddElementToObject(orderbook, "nonce", this.SafeInteger(bookData, "nonce"))

		ch <- orderbook
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-ticker
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-24hr-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *ZebpayCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes6088 := (<-this.LoadMarkets())
		PanicOnError(retRes6088)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PublicSpotGetV2MarketTicker(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicSwapGetV1MarketTicker24Hr(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTicker(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-all-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *ZebpayCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(!IsEqual(typeVar, "spot")) {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchTickers() does not support "), typeVar), " markets")))
		}

		retRes6568 := (<-this.LoadMarkets())
		PanicOnError(retRes6568)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.PublicSpotGetV2MarketAllTickers(params))
		PanicOnError(response)
		//
		//     [
		//        {
		//            "symbol": "BTC-INR",
		//            "bestBid": "4900000",
		//            "bestBidQty": "0.00014938",
		//            "bestAsk": "",
		//            "bestAskQty": "0",
		//            "priceChange": "-98134.56",
		//            "priceChangePercent": "-1.84",
		//            "high": "5433400",
		//            "low": "5333400",
		//            "vol": "0.0002",
		//            "volValue": "1066.68",
		//            "last": "5333400"
		//        }
		//     ]
		//
		var tickerList interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(tickerList, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-klinescandlesticks
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#-get-k-lines-ohlcv-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.endtime] the latest time in ms to fetch orders for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *ZebpayCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes6968 := (<-this.LoadMarkets())
		PanicOnError(retRes6968)
		var market interface{} = this.Market(symbol)
		if IsTrue(IsEqual(limit, nil)) {
			limit = 100 // default is 200
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "interval", this.SafeString(this.Timeframes, timeframe, timeframe))
		} else {
			AddElementToObject(request, "interval", timeframe)
		}
		if IsTrue(IsTrue(GetValue(market, "contract")) && IsTrue((!IsEqual(limit, nil)))) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsEqual(since, nil)) {
			if IsTrue(GetValue(market, "spot")) {
				AddElementToObject(request, "startTime", since)
			} else {
				AddElementToObject(request, "since", since)
			}
		}
		var until interface{} = this.SafeInteger2(params, "until", "endtime")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, []interface{}{"endtime", "until"})
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(IsTrue(IsEqual(until, nil)) || IsTrue(IsEqual(since, nil))) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOHLCV() requires a both a since and until/endtime parameter for spot markets")))
			}

			response = (<-this.PublicSpotGetV2MarketKlines(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicSwapPostV1MarketKlines(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//             [
		//                 [
		//                     "1670608800000",
		//                     "17071",
		//                     "17073",
		//                     "17027",
		//                     "17055.5",
		//                     "268611",
		//                     "15.74462667"
		//                 ],
		//                 [
		//                     "1670605200000",
		//                     "17071.5",
		//                     "17071.5",
		//                     "17061",
		//                     "17071",
		//                     "4177",
		//                     "0.24469757"
		//                 ],
		//                 [
		//                     "1670601600000",
		//                     "17086.5",
		//                     "17088",
		//                     "16978",
		//                     "17071.5",
		//                     "6356",
		//                     "0.37288112"
		//                 ]
		//             ]
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/public-endpoints.md#get-recent-trades
 * @see https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/public-endpoints/market.md#get-aggregate-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *ZebpayCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes7818 := (<-this.LoadMarkets())
		PanicOnError(retRes7818)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(IsTrue(GetValue(market, "spot")) && IsTrue(!IsEqual(limit, nil))) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PublicSpotGetV2MarketTrades(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicSwapGetV1MarketAggTrade(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     [
		//         {
		//             "id" : "60014521",
		//             "price" : "23162.94",
		//             "qty" : "0.00009",
		//             "side" : "SELL",
		//             "time" : 1659684602042,
		//             "isBuyerMaker" : 1659684602036
		//         }
		//     ]
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchMyTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-trade-history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *ZebpayCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes8238 := (<-this.LoadMarkets())
		PanicOnError(retRes8238)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "spot")) {
			panic(NotSupported(Add(this.Id, " fetchMyTrades() does not support spot markets")))
		} else {

			response = (<-this.PrivateSwapGetV1TradeHistory(params))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var items interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseTrades(items, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpatspot#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-order-fills
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *ZebpayCore) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrderTrades", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(!IsEqual(typeVar, "spot")) {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchOrderTrades() does not support "), typeVar), " markets")))
		}

		retRes8598 := (<-this.LoadMarkets())
		PanicOnError(retRes8598)
		var request interface{} = map[string]interface{}{
			"orderId": id,
		}

		response := (<-this.PrivateSpotGetV2ExOrderFills(this.Extend(request, params)))
		PanicOnError(response)
		//
		//         {
		//             "orderId": "456789",
		//             "symbol": "LINK_USDT",
		//             "origQty": "1.5",
		//             "orderId": "30249408733945856",
		//             "side": "BUY",
		//             "type": "LIMIT",
		//             "matchRole": "MAKER",
		//             "createTime": 1648200366864,
		//             "price": "3.1",
		//             "avgExecutedPrice": "2.3456"
		//             "openQty": "1",
		//             "filledQty": "0",
		//             "fees": "0.00145",
		//         }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var trades interface{} = []interface{}{data}

		ch <- this.ParseTrades(trades)
		return nil

	}()
	return ch
}
func (this *ZebpayCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchMyTrades
	//
	//     {
	//         "id": "32164924331503616",
	//         "symbol": "LINK_USDT",
	//         "accountType": "SPOT",
	//         "orderId": "32164923987566592",
	//         "side": "SELL",
	//         "type": "MARKET",
	//         "matchRole": "TAKER",
	//         "createTime": 1648635115525,
	//         "price": "11",
	//         "quantity": "0.5",
	//         "amount": "5.5",
	//         "feeCurrency": "USDT",
	//         "feeAmount": "0.007975",
	//         "pageId": "32164924331503616",
	//         "clientOrderId": "myOwnId-321"
	//     }
	//   {
	//     aggregateTradeId: '2659115835',
	//     symbol: 'ETHINR',
	//     price: '292848',
	//     quantity: '0.147',
	//     firstTradeId: '7018766077',
	//     lastTradeId: '7018766081',
	//     tradeTime: '1765381971447',
	//     isBuyerMarketMaker: true
	//   }
	//
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString2(trade, "id", "aggregateTradeId")
	var orderId interface{} = this.SafeString2(trade, "id", "order")
	var timestamp interface{} = this.SafeInteger2(trade, "timestamp", "tradeTime")
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market, "_")
	var symbol interface{} = GetValue(market, "symbol")
	var side interface{} = this.SafeStringLower(trade, "side")
	var priceString interface{} = this.SafeString(trade, "price")
	var amountString interface{} = this.SafeString2(trade, "amount", "quantity")
	return this.SafeTrade(map[string]interface{}{
		"id":           id,
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"order":        orderId,
		"type":         this.SafeStringLower(trade, "type"),
		"side":         side,
		"takerOrMaker": nil,
		"price":        priceString,
		"amount":       amountString,
		"cost":         this.SafeString(trade, "cost"),
		"fee":          this.SafeDict(trade, "fee"),
	}, market)
}

/**
 * @method
 * @name zebpay#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-account-balance
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/wallet.md#get-wallet-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *ZebpayCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes9558 := (<-this.LoadMarkets())
		PanicOnError(retRes9558)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var response interface{} = nil
		if IsTrue(isSpot) {

			response = (<-this.PrivateSpotGetV2AccountBalance(params))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateSwapGetV1WalletBalance(params))
			PanicOnError(response)
		}

		//
		//     {
		//         "data": [
		//              {
		//                 "free": 200,
		//                 "used": 100,
		//                 "total": 300,
		//                 "currency": "INR"
		//              },
		//              {
		//                 "free": 0,
		//                 "used": 0,
		//                 "total": 0,
		//                 "currency": "USDT"
		//              }
		//         ]
		//     }
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#createOrder
 * @description Create an order on the exchange
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#place-new-order
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#--create-order
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {string} [params.formType] The price at which a trigger order is triggered at
 * @param {string} [params.marginAsset] The asset the order creates, default is INR.
 * @param {boolean} [params.takeProfit] Takeprofit flag for the order.
 * @param {boolean} [params.stopLoss] Stop loss flag for the order.
 * @param {string} [params.positionId] PositionId of the order.
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *ZebpayCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes10068 := (<-this.LoadMarkets())
		PanicOnError(retRes10068)
		var market interface{} = this.Market(symbol)
		var upperCaseType interface{} = ToUpper(typeVar)
		var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
		var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
		params = this.Omit(params, []interface{}{"marginAsset", "takeProfitPrice", "takeProfitPrice"})
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"side":   ToUpper(side),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			requestparamsVariable := this.OrderRequest(symbol, typeVar, amount, request, price, params)
			request = GetValue(requestparamsVariable, 0)
			params = GetValue(requestparamsVariable, 1)

			response = (<-this.PrivateSpotPostV2ExOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var marginAsset interface{} = this.SafeString(params, "marginAsset", "INR")
			var formType interface{} = this.SafeStringUpper(params, "formType", "ORDER_FORM")
			AddElementToObject(request, "formType", formType)
			AddElementToObject(request, "amount", this.ParseToNumeric(this.AmountToPrecision(GetValue(market, "id"), amount)))
			AddElementToObject(request, "marginAsset", marginAsset)
			var hasTP interface{} = !IsEqual(takeProfitPrice, nil)
			var hasSL interface{} = !IsEqual(stopLossPrice, nil)
			if IsTrue(IsTrue(hasTP) || IsTrue(hasSL)) {
				if IsTrue(hasTP) {
					AddElementToObject(request, "takeProfitPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, takeProfitPrice)))
				}
				if IsTrue(hasSL) {
					AddElementToObject(request, "stopLossPrice", this.ParseToNumeric(this.PriceToPrecision(symbol, stopLossPrice)))
				}

				response = (<-this.PrivateSwapPostV1TradeOrderAddTPSL(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				AddElementToObject(request, "type", upperCaseType)
				if IsTrue(IsEqual(typeVar, "limit")) {
					if IsTrue(IsEqual(price, nil)) {
						panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument for limit orders")))
					}
					AddElementToObject(request, "price", this.ParseToNumeric(this.PriceToPrecision(symbol, price)))
				}

				response = (<-this.PrivateSwapPostV1TradeOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//    {
		//        "data": {
		//            "clientOrderId": "619717484f1d010001510cde",
		//        },
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *ZebpayCore) OrderRequest(symbol interface{}, typeVar interface{}, amount interface{}, request interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var upperCaseType interface{} = ToUpper(typeVar)
	var triggerPrice interface{} = this.SafeString(params, "stopLossPrice", nil)
	var quoteOrderQty interface{} = this.SafeString2(params, "quoteOrderQty", "cost", nil)
	var timeInForce interface{} = this.SafeString(params, "timeInForce", "GTC")
	var clientOrderId interface{} = this.SafeString(params, "clientOrderId", this.Uuid())
	params = this.Omit(params, []interface{}{"stopLossPrice", "cost", "timeInForce", "clientOrderId"})
	AddElementToObject(request, "type", upperCaseType)
	AddElementToObject(request, "clientOrderId", clientOrderId)
	AddElementToObject(request, "timeInForce", timeInForce)
	if IsTrue(IsEqual(upperCaseType, "MARKET")) {
		if IsTrue(IsEqual(quoteOrderQty, nil)) {
			panic(ExchangeError(Add(this.Id, " spot market orders require cost in params")))
		}
		AddElementToObject(request, "quoteOrderAmount", this.CostToPrecision(symbol, quoteOrderQty))
	} else {
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			AddElementToObject(request, "stopLossPrice", this.PriceToPrecision(symbol, triggerPrice))
		}
		AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	return []interface{}{request, params}
}

/**
 * @method
 * @name zebpay#cancelOrder
 * @description cancels an open order
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#cancel-order
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timestamp] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *ZebpayCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes10968 := (<-this.LoadMarkets())
		PanicOnError(retRes10968)
		var market interface{} = this.Market(symbol)
		var response interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "orderId", id)

			response = (<-this.PrivateSpotDeleteV2ExOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a clientOrderId parameter for swap orders")))
			}
			AddElementToObject(request, "clientOrderId", clientOrderId)
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.PrivateSwapDeleteV1TradeOrder(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//    {
		//        "data": {
		//            "clientOrderId": "619714b8b6353000014c505a",
		//            "status": "canceled"
		//        },
		//    }
		//
		ch <- this.ParseOrder(this.SafeDict(response, "data"))
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#cancelOrders
 * @description cancels all open orders
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#cancel-all-orders
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.timestamp] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *ZebpayCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(!IsEqual(typeVar, "spot")) {
			panic(NotSupported(Add(Add(Add(this.Id, " cancelAllOrders() does not support "), typeVar), " markets")))
		}

		retRes11398 := (<-this.LoadMarkets())
		PanicOnError(retRes11398)

		response := (<-this.PrivateSpotDeleteV2ExOrdersCancelAll(params))
		PanicOnError(response)
		//
		//    {
		//        "data": {
		//            "orderId": "12345",
		//            "symbol": 'BTC-INR
		//        },
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var parsedOrder interface{} = this.ParseOrder(data)

		ch <- []interface{}{parsedOrder}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchOpenOrders
 * @description fetches information on multiple open orders made by the user
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-orders
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-open-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *ZebpayCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11678 := (<-this.LoadMarkets())
		PanicOnError(retRes11678)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var response interface{} = nil
		var orders interface{} = []interface{}{}
		if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "currentPage", 1)
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "pageSize", limit)
			}

			response = (<-this.PrivateSpotGetV2ExOrders(this.Extend(request, params)))
			PanicOnError(response)
			var responseData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			orders = this.SafeList(responseData, "items", []interface{}{})
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "since", since)
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}

			response = (<-this.PrivateSwapGetV1TradeOrderOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
			var responseData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
			orders = this.SafeList(responseData, "data", []interface{}{})
		}

		//
		//     {
		//         "data": {
		//             "nextTimeStamp": null,
		//             "totalCount": 100,
		//             "data": [
		//                 {
		//                     "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
		//                     "datetime": "2025-03-14T14:34:34.4567",
		//                     "timestamp": 1741962557553,
		//                     "status": "open",
		//                     "symbol": "BTCINR",
		//                     "type": "market",
		//                     "timeInForce": "GTC",
		//                     "side": "buy",
		//                     "price": 700000,
		//                     "amount": 0.002,
		//                     "filled": null,
		//                     "remaining": 0.002,
		//                     "trades": []
		//                 }
		//             ]
		//         }
		//     }
		//
		ch <- this.ParseOrders(orders, market, nil, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchOrder
 * @description fetches information on an order made by the user
 * @see [Spot] https://github.com/zebpay/zebpay-api-references/blob/main/spot/api-reference/private-endpoints.md#get-order-details
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-order-details
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] cancel order by client order id
 * @param {string} [params.timestamp] cancel order by client order id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *ZebpayCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes12358 := (<-this.LoadMarkets())
		PanicOnError(retRes12358)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "orderId", id)

			response = (<-this.PrivateSpotGetV2ExOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "id", id)

			response = (<-this.PrivateSwapGetV1TradeOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "data": {
		//             "nextTimeStamp": null,
		//             "totalCount": 100,
		//             "data": [
		//                 {
		//                     "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
		//                     "datetime": "2025-03-14T14:34:34.4567",
		//                     "timestamp": 1741962557553,
		//                     "status": "open",
		//                     "symbol": "BTCINR",
		//                     "type": "market",
		//                     "timeInForce": "GTC",
		//                     "side": "buy",
		//                     "price": 700000,
		//                     "amount": 0.002,
		//                     "filled": null,
		//                     "remaining": 0.002,
		//                     "trades": []
		//                 }
		//             ]
		//         }
		//     }
		//
		var responseData interface{} = this.SafeDict(response, "data")

		ch <- this.ParseOrder(responseData, market)
		return nil

	}()
	return ch
}
func (this *ZebpayCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	//      {
	//          "clientOrderId": "64507d02921f1c0001ff6892-123-zeb",
	//          "datetime": "2025-03-14T14:34:34.4567",
	//          "timestamp": 1741962557553,
	//          "status": "open",
	//          "symbol": "BTCINR",
	//          "type": "market",
	//          "timeInForce": "GTC",
	//          "side": "buy",
	//          "price": 700000,
	//          "amount": 0.002,
	//          "filled": null,
	//          "remaining": 0.002,
	//          "trades": []
	//      }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var typeVar interface{} = this.SafeString(order, "type")
	var timestamp interface{} = this.SafeNumber(order, "timestamp")
	var datetime interface{} = this.Iso8601(timestamp)
	var price interface{} = this.SafeString(order, "price")
	var side interface{} = this.SafeString(order, "side")
	var amount interface{} = this.SafeString(order, "amount")
	var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
	var timeInForce interface{} = this.SafeString(order, "timeInForce")
	var status interface{} = this.SafeStringLower(order, "status")
	var orderId interface{} = this.SafeString(order, "orderId", nil)
	var parsedOrder interface{} = this.SafeOrder(map[string]interface{}{
		"id":                  orderId,
		"clientOrderId":       clientOrderId,
		"symbol":              symbol,
		"type":                typeVar,
		"timeInForce":         timeInForce,
		"postOnly":            nil,
		"reduceOnly":          nil,
		"side":                side,
		"amount":              amount,
		"price":               price,
		"triggerPrice":        nil,
		"cost":                nil,
		"filled":              nil,
		"remaining":           nil,
		"timestamp":           timestamp,
		"datetime":            datetime,
		"fee":                 nil,
		"status":              status,
		"info":                order,
		"lastTradeTimestamp":  nil,
		"lastUpdateTimestamp": nil,
		"average":             nil,
		"trades":              nil,
	}, market)
	return parsedOrder
}

/**
 * @method
 * @name zebpay#closePosition
 * @description closes open positions for a market
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-close-position
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} side not used by kucoinfutures closePositions
 * @param {object} [params] extra parameters specific to the okx api endpoint
 * @param {string} [params.positionId] client order id of the order
 * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *ZebpayCore) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13468 := (<-this.LoadMarkets())
		PanicOnError(retRes13468)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateSwapPostV1TradePositionClose(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchLeverages
 * @description fetch the set leverage for all contract and margin markets
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-get-all-user-leverages
 * @param {string[]} [symbols] a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/?id=leverage-structure}
 */
func (this *ZebpayCore) FetchLeverages(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13668 := (<-this.LoadMarkets())
		PanicOnError(retRes13668)

		response := (<-this.PrivateSwapGetV1TradeUserLeverages(params))
		PanicOnError(response)
		//
		//     {
		//         "leveragePreferences": [
		//             {
		//                 "symbol": "ETHINR",
		//                 "shortLeverage": 1,
		//                 "longLeverage": 10,
		//                 "marginMode": "isolated"
		//             },
		//         ]
		//     }
		//
		var leveragePreferences interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLeverages(leveragePreferences, symbols, "symbol")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchLeverage
 * @description fetch the set leverage for a market
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#get-user-leverage-single-symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
 */
func (this *ZebpayCore) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes13948 := (<-this.LoadMarkets())
		PanicOnError(retRes13948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": ToUpper(GetValue(market, "id")),
		}

		response := (<-this.PrivateSwapGetV1TradeUserLeverage(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "data": { symbol: "ETHINR", longLeverage: 1, shortLeverage: 1, marginMode: "isolated" }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#setLeverage
 * @description set the level of leverage for a market
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-update-user-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *ZebpayCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes14238 := (<-this.LoadMarkets())
		PanicOnError(retRes14238)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"leverage": leverage,
			"symbol":   GetValue(market, "id"),
		}
		//
		// { data: { "symbol", "longLeverage": 10, "shortLeverage": 1, "marginMode": "isolated" }
		//

		response := (<-this.PrivateSwapPostV1TradeUpdateUserLeverage(this.Extend(request, params)))
		PanicOnError(response)

		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpay#fetchPositions
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#--get-positions
 * @description Fetches current contract trading positions
 * @param {string[]} symbols List of unified symbols
 * @param {object} [params] Not used by krakenfutures
 * @returns Parsed exchange response for positions
 */
func (this *ZebpayCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14468 := (<-this.LoadMarkets())
		PanicOnError(retRes14468)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			AddElementToObject(request, "symbols", this.MarketIds(symbols))
		}

		response := (<-this.PrivateSwapGetV1TradePositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "data": [
		//            {
		//                "id": "31998678-6056-413f-9d0d-fc3678641650",
		//                "symbol": "ETHINR",
		//                "entryPrice": "0.7533",
		//                "datetime": "2022-03-03T22:51:16.566Z",
		//                "contractSize": "230"
		//            }
		//        ],
		//    }
		//
		var positions interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.ParsePositions(positions)

		ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpayfutures#addMargin
 * @description add margin
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-add-margin-to-position
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint.
 * @param {string} [params.positionId] PositionId of the order to add margin.
 * @param {string} [params.timestamp] Tiemstamp.
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=add-margin-structure}
 */
func (this *ZebpayCore) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14838 := (<-this.LoadMarkets())
		PanicOnError(retRes14838)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"amount": amount,
		}

		response := (<-this.PrivateSwapPostV1TradeAddMargin(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "200000",
		//        "data": {
		//            "symbol": "BTCINR",
		//            "type": "add",
		//            "amount": 1000,
		//            "code": "INR",
		//            "status": "ok"
		//        }
		//    }
		//
		//
		//    {
		//        "code":"200000",
		//        "msg":"Position does not exist"
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.Extend(this.ParseMarginModification(data, market), map[string]interface{}{
			"amount":    amount,
			"direction": "in",
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name zebpayfutures#reduceMargin
 * @description add margin
 * @see [Swap] https://github.com/zebpay/zebpay-api-references/blob/main/futures/api-reference/private-endpoints/trade.md#-reduce-margin-from-position
 * @param {string} symbol unified market symbol.
 * @param {float} amount amount of margin to add.
 * @param {object} [params] extra parameters specific to the exchange API endpoint.
 * @param {string} [params.positionId] PositionId of the order to add margin.
 * @param {string} [params.timestamp] Tiemstamp.
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=add-margin-structure}
 */
func (this *ZebpayCore) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes15288 := (<-this.LoadMarkets())
		PanicOnError(retRes15288)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"amount": amount,
		}

		response := (<-this.PrivateSwapPostV1TradeReduceMargin(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "200000",
		//        "data": {
		//            "symbol": "BTCINR",
		//            "type": "reduce",
		//            "amount": 1000,
		//            "code": "INR",
		//            "status": "ok"
		//        }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.Extend(this.ParseMarginModification(data, market), map[string]interface{}{
			"amount":    amount,
			"direction": "out",
		})
		return nil

	}()
	return ch
}
func (this *ZebpayCore) FetchSpotMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicSpotGetV2ExExchangeInfo(params))
		PanicOnError(response)
		//
		//    {
		//        "data": {
		//            "symbol": "ETH-INR",
		//            "name": "ETH-INR",
		//            "baseCurrency": "ETH",
		//            "quoteCurrency": "INR",
		//            "feeCurrency": "INR",
		//            "baseMinSize": "",
		//            "quoteMinSize": "100",
		//            "baseMaxSize": "",
		//            "quoteMaxSize": "2000",
		//            "baseIncrement": "0.00001"
		//            "quoteIncrement": "0.00001",
		//            "enableTrading": true
		//        }
		//    }
		//
		var result interface{} = []interface{}{}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var markets interface{} = this.SafeList(data, "symbols", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseAsset")
			var quoteId interface{} = this.SafeString(market, "quoteAsset")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var symbol interface{} = Add(Add(base, "/"), quote)
			AppendToArray(&result, map[string]interface{}{
				"id":         id,
				"symbol":     symbol,
				"base":       base,
				"quote":      quote,
				"baseId":     baseId,
				"quoteId":    quoteId,
				"type":       "spot",
				"spot":       true,
				"swap":       false,
				"margin":     false,
				"future":     false,
				"option":     false,
				"active":     nil,
				"contract":   nil,
				"taker":      this.SafeNumber(market, "takerFee"),
				"maker":      this.SafeNumber(market, "makerFee"),
				"strike":     nil,
				"optionType": nil,
				"precision": map[string]interface{}{
					"amount": this.SafeNumber(market, "lotSz"),
					"price":  this.SafeNumber(market, "tickSz"),
				},
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"info": market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *ZebpayCore) FetchSwapMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicSwapGetV1MarketMarkets(params))
		PanicOnError(response)
		//
		//    {
		//        "data": {
		//            "symbol": "ETHUSDT",
		//            "status": "TRADING",
		//            "mainMarginPercent": "10",
		//            "baseAsset": "ETH",
		//            "quoteAsset": "USDT",
		//            "pricePrecision": 1,
		//            "quantityPrecision": 0.05,
		//            "baseAssetPrecision": 0,
		//            "quotePrecision": 0,
		//            "orderType": ["LIMIT", "MARKET" ]
		//            "timeInForce": ["GTC"],
		//            "makerFee": "0.01",
		//            "takerFee": "0.01",
		//            "minLeverage": "1",
		//            "maxLeverage": "20"
		//            "tickSz": "0.1",
		//            "lotSz": "0.1"
		//        }
		//    }
		//
		var result interface{} = []interface{}{}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var markets interface{} = this.SafeList(data, "symbols", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseAsset")
			var quoteId interface{} = this.SafeString(market, "quoteAsset")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var settle interface{} = this.SafeCurrencyCode(quoteId)
			var status interface{} = this.SafeString(market, "status")
			var symbol interface{} = Add(Add(base, "/"), quote)
			AppendToArray(&result, this.SafeMarketStructure(map[string]interface{}{
				"id":         id,
				"symbol":     Add(Add(symbol, ":"), settle),
				"base":       base,
				"quote":      quote,
				"baseId":     baseId,
				"quoteId":    quoteId,
				"spot":       false,
				"margin":     false,
				"swap":       true,
				"future":     false,
				"type":       "swap",
				"option":     false,
				"active":     (IsEqual(status, "Open")),
				"contract":   true,
				"taker":      this.SafeNumber(market, "takerFee"),
				"maker":      this.SafeNumber(market, "makerFee"),
				"strike":     nil,
				"optionType": nil,
				"precision": map[string]interface{}{
					"amount": this.SafeNumber(market, "lotSz"),
					"price":  this.SafeNumber(market, "tickSz"),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": this.SafeNumber(market, "minLeverage"),
						"max": this.SafeNumber(market, "maxLeverage"),
					},
				},
				"info": market,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *ZebpayCore) ParseBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	var currencyList interface{} = this.SafeList(response, "data", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(currencyList)); i++ {
		var entry interface{} = GetValue(currencyList, i)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(entry, "total"))
		AddElementToObject(account, "free", this.SafeString(entry, "free"))
		AddElementToObject(account, "used", this.SafeString(entry, "used"))
		var currencyId interface{} = this.SafeString(entry, "currency")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}
func (this *ZebpayCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// isolated
	//    {
	//        "id":"long",
	//        "symbol":"pf_ftmusd",
	//        "entryPrice":"0.4921",
	//        "datetime":"2023-02-22T11:37:16.685Z",
	//        "contractSize":"1",
	//        "leverage":"1.0"
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var leverage interface{} = this.SafeNumber(position, "leverage")
	var datetime interface{} = this.SafeString(position, "datetime")
	var marketId interface{} = this.SafeString(position, "symbol")
	market = this.SafeMarket(marketId, market)
	return map[string]interface{}{
		"info":                        position,
		"symbol":                      marketId,
		"timestamp":                   this.Parse8601(datetime),
		"datetime":                    datetime,
		"initialMargin":               this.SafeNumber(position, "initialMargin"),
		"initialMarginPercentage":     nil,
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": nil,
		"entryPrice":                  this.SafeNumber(position, "entryPrice"),
		"notional":                    this.SafeNumber(position, "notional"),
		"leverage":                    leverage,
		"unrealizedPnl":               nil,
		"contracts":                   this.SafeNumber(position, "contracts"),
		"contractSize":                this.SafeNumber(market, "contractSize"),
		"marginRatio":                 nil,
		"liquidationPrice":            this.SafeNumber(position, "liquidationPrice"),
		"markPrice":                   nil,
		"collateral":                  nil,
		"marginType":                  "isolated",
		"side":                        this.SafeString(position, "side"),
		"percentage":                  nil,
	}
}
func (this *ZebpayCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(leverage, "symbol")
	var info interface{} = this.SafeDict(leverage, "info")
	var leverageValue interface{} = this.SafeInteger(leverage, "longLeverage")
	var leverageValueShort interface{} = this.SafeInteger(leverage, "shortLeverage")
	var marginMode interface{} = this.SafeString(leverage, "marginMode")
	return map[string]interface{}{
		"info":          info,
		"symbol":        marketId,
		"marginMode":    marginMode,
		"longLeverage":  leverageValue,
		"shortLeverage": leverageValueShort,
	}
}
func (this *ZebpayCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(fee, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	return map[string]interface{}{
		"info":       fee,
		"symbol":     symbol,
		"maker":      this.SafeNumber2(fee, "makerFeeRate", "makerFee"),
		"taker":      this.SafeNumber2(fee, "takerFeeRate", "takerFee"),
		"percentage": nil,
		"tierBased":  nil,
	}
}
func (this *ZebpayCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//        {
	//            "symbol": "BTC-INR",
	//            "bestBid": "4900000",
	//            "bestBidQty": "0.00014938",
	//            "bestAsk": "",
	//            "bestAskQty": "0",
	//            "priceChange": "-98134.56",
	//            "priceChangePercent": "-1.84",
	//            "high": "5433400",
	//            "low": "5333400",
	//            "vol": "0.0002",
	//            "volValue": "1066.68",
	//            "last": "5333400"
	//        }
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger2(ticker, "timestamp", "ts", nil)
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId)
	var close interface{} = this.SafeString(ticker, "close", nil)
	var last interface{} = this.SafeString(ticker, "last", nil)
	var percentage interface{} = this.SafeString(ticker, "percentage")
	var bidVolume interface{} = this.SafeString(ticker, "bidVolume")
	var askVolume interface{} = this.SafeString(ticker, "askVolume")
	return this.SafeTicker(map[string]interface{}{
		"id":            marketId,
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "high"),
		"low":           this.SafeString(ticker, "low"),
		"bid":           this.SafeString(ticker, "bid"),
		"bidVolume":     bidVolume,
		"ask":           this.SafeString(ticker, "ask"),
		"askVolume":     askVolume,
		"vwap":          nil,
		"open":          nil,
		"close":         close,
		"last":          last,
		"previousClose": this.SafeString(ticker, "previousClose"),
		"change":        this.SafeString(ticker, "change"),
		"percentage":    percentage,
		"average":       this.SafeString(ticker, "average"),
		"baseVolume":    this.SafeString(ticker, "baseVolume"),
		"quoteVolume":   this.SafeString(ticker, "quoteVolume"),
		"markPrice":     nil,
		"info":          ticker,
	}, market)
}
func (this *ZebpayCore) ParseMarginModification(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//         "symbol": "BTCINR",
	//         "type": "reduce",
	//         "amount": 1000,
	//         "code": "INR",
	//         "status": "ok"
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.Milliseconds()
	return map[string]interface{}{
		"info":       info,
		"symbol":     GetValue(market, "id"),
		"type":       nil,
		"marginMode": nil,
		"amount":     this.SafeNumber(info, "amount"),
		"total":      nil,
		"code":       this.SafeString(info, "code"),
		"status":     this.SafeString(info, "status"),
		"timestamp":  timestamp,
		"datetime":   this.Iso8601(timestamp),
	}
}
func (this *ZebpayCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	params = this.Omit(params, "defaultType")
	var isV1 interface{} = IsGreaterThan(GetIndexOf(path, "v1/"), OpNeg(1))
	var marketType interface{} = Ternary(IsTrue(isV1), "swap", "spot")
	var url interface{} = GetValue(GetValue(this.Urls, "api"), marketType)
	var tail interface{} = Add("/api/", this.ImplodeParams(path, params))
	url = Add(url, tail)
	var timestamp interface{} = ToString(this.Milliseconds())
	var signature interface{} = ""
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	var queryLength interface{} = GetArrayLength(ObjectKeys(query))
	var access interface{} = this.SafeString(api, 0, "public")
	if IsTrue(IsEqual(access, "public")) {
		if IsTrue(IsTrue(IsEqual(method, "GET")) || IsTrue(IsEqual(method, "DELETE"))) {
			if IsTrue(queryLength) {
				url = Add(url, Add("?", this.Urlencode(query)))
			}
		} else {
			body = JsonStringify(params)
			headers = map[string]interface{}{
				"Referrer":     "ccxt",
				"Content-Type": "application/json",
			}
		}
	} else {
		this.CheckRequiredCredentials()
		var isSpot interface{} = IsEqual(marketType, "spot")
		AddElementToObject(params, "timestamp", timestamp)
		if IsTrue(IsTrue(IsEqual(method, "GET")) || IsTrue((IsTrue(IsEqual(method, "DELETE")) && IsTrue(isSpot)))) {
			// For GET/DELETE: Append params to URL and sign the query string
			var queryString interface{} = this.Urlencode(params)
			signature = this.Hmac(this.Encode(queryString), this.Encode(this.Secret), sha256, "hex")
			url = Add(url, Add("?", queryString))
		} else {
			// For POST/PUT: Convert body to JSON and sign the stringified payload
			body = this.Json(params)
			signature = this.Hmac(this.Encode(body), this.Encode(this.Secret), sha256, "hex")
		}
		headers = map[string]interface{}{
			"Referrer":         "ccxt",
			"X-AUTH-APIKEY":    this.ApiKey,
			"X-AUTH-SIGNATURE": signature,
		}
		AddElementToObject(headers, "Content-Type", "application/json")
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *ZebpayCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if !IsTrue(response) {
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, body)
		return nil
	}
	//
	// bad
	//     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
	// good
	//     { code: "200000", data: { ... }}
	// {"statusDescription":"Order quantity is out of range","data":{},"statusCode":400,"customMessage":["Order quantity is out of range"]}
	//
	var errorCode interface{} = this.SafeString2(response, "code", "statusCode")
	var message interface{} = this.SafeString2(response, "msg", "statusDescription")
	var feedback interface{} = Add(Add(this.Id, " "), message)
	this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
	this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
	this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
	return nil
}

func (this *ZebpayCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
