package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitbns struct {
    Exchange

}

func NewBitbnsCore() bitbns {
   p := bitbns{}
   setDefaults(&p)
   return p
}

func  (this *bitbns) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitbns",
        "name": "Bitbns",
        "countries": []interface{}{"IN"},
        "rateLimit": 1000,
        "certified": false,
        "version": "v2",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": nil,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "createOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "fetchBalance": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPositionMode": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": "emulated",
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "transfer": false,
            "withdraw": false,
        },
        "hostname": "bitbns.com",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/a5b9a562-cdd8-4bea-9fa7-fd24c1dad3d9",
            "api": map[string]interface{} {
                "www": "https://{hostname}",
                "v1": "https://api.{hostname}/api/trade/v1",
                "v2": "https://api.{hostname}/api/trade/v2",
            },
            "www": "https://bitbns.com",
            "referral": "https://ref.bitbns.com/1090961",
            "doc": []interface{}{"https://bitbns.com/trade/#/api-trading/"},
            "fees": "https://bitbns.com/fees",
        },
        "api": map[string]interface{} {
            "www": map[string]interface{} {
                "get": []interface{}{"order/fetchMarkets", "order/fetchTickers", "order/fetchOrderbook", "order/getTickerWithVolume", "exchangeData/ohlc", "exchangeData/orderBook", "exchangeData/tradedetails"},
            },
            "v1": map[string]interface{} {
                "get": []interface{}{"platform/status", "tickers", "orderbook/sell/{symbol}", "orderbook/buy/{symbol}"},
                "post": []interface{}{"currentCoinBalance/EVERYTHING", "getApiUsageStatus/USAGE", "getOrderSocketToken/USAGE", "currentCoinBalance/{symbol}", "orderStatus/{symbol}", "depositHistory/{symbol}", "withdrawHistory/{symbol}", "withdrawHistoryAll/{symbol}", "depositHistoryAll/{symbol}", "listOpenOrders/{symbol}", "listOpenStopOrders/{symbol}", "getCoinAddress/{symbol}", "placeSellOrder/{symbol}", "placeBuyOrder/{symbol}", "buyStopLoss/{symbol}", "sellStopLoss/{symbol}", "cancelOrder/{symbol}", "cancelStopLossOrder/{symbol}", "listExecutedOrders/{symbol}", "placeMarketOrder/{symbol}", "placeMarketOrderQnty/{symbol}"},
            },
            "v2": map[string]interface{} {
                "post": []interface{}{"orders", "cancel", "getordersnew", "marginOrders"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "quote",
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.0025"),
                "maker": this.ParseNumber("0.0025"),
            },
        },
        "precisionMode": TICK_SIZE,
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 100,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400": BadRequest,
                "409": BadSymbol,
                "416": InsufficientFunds,
                "417": OrderNotFound,
            },
            "broad": map[string]interface{} {},
        },
    })
}
/**
 * @method
 * @name bitbns#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *bitbns) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V1GetPlatformStatus(params))
            PanicOnError(response)
            //
            //     {
            //         "data":{
            //             "BTC":{"status":1},
            //             "ETH":{"status":1},
            //             "XRP":{"status":1},
            //         },
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            var statusRaw interface{} = this.SafeString(response, "status")
        
            ch <- map[string]interface{} {
                "status": this.SafeString(map[string]interface{} {
                    "1": "ok",
                }, statusRaw, statusRaw),
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchMarkets
 * @description retrieves data on all markets for bitbns
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitbns) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.WwwGetOrderFetchMarkets(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id":"BTC",
            //             "symbol":"BTC/INR",
            //             "base":"BTC",
            //             "quote":"INR",
            //             "baseId":"BTC",
            //             "quoteId":"",
            //             "active":true,
            //             "limits":{
            //                 "amount":{"min":"0.00017376","max":20},
            //                 "price":{"min":2762353.2359999996,"max":6445490.883999999},
            //                 "cost":{"min":800,"max":128909817.67999998}
            //             },
            //             "precision":{
            //                 "amount":8,
            //                 "price":2
            //             },
            //             "info":{}
            //         },
            //     ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var market interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(market, "id")
                var baseId interface{} = this.SafeString(market, "base")
                var quoteId interface{} = this.SafeString(market, "quote")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var marketPrecision interface{} = this.SafeDict(market, "precision", map[string]interface{} {})
                var marketLimits interface{} = this.SafeDict(market, "limits", map[string]interface{} {})
                var amountLimits interface{} = this.SafeDict(marketLimits, "amount", map[string]interface{} {})
                var priceLimits interface{} = this.SafeDict(marketLimits, "price", map[string]interface{} {})
                var costLimits interface{} = this.SafeDict(marketLimits, "cost", map[string]interface{} {})
                var usdt interface{} =         (IsEqual(quoteId, "USDT"))
                // INR markets don't need a _INR prefix
                var uppercaseId interface{} = Ternary(IsTrue(usdt), (Add(Add(baseId, "_"), quoteId)), baseId)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "uppercaseId": uppercaseId,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": this.SafeBool(market, "active"),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(marketPrecision, "amount"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(marketPrecision, "price"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(amountLimits, "min"),
                            "max": this.SafeNumber(amountLimits, "max"),
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(priceLimits, "min"),
                            "max": this.SafeNumber(priceLimits, "max"),
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(costLimits, "min"),
                            "max": this.SafeNumber(costLimits, "max"),
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitbns) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3668 := (<-this.LoadMarkets())
            PanicOnError(retRes3668)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100, max 5000, see https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#order-book
            }
        
            response:= (<-this.WwwGetOrderFetchOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "bids":[
            //             [49352.04,0.843948],
            //             [49352.03,0.742048],
            //             [49349.78,0.686239],
            //         ],
            //         "asks":[
            //             [49443.59,0.065137],
            //             [49444.63,0.098211],
            //             [49449.01,0.066309],
            //         ],
            //         "timestamp":1619172786577,
            //         "datetime":"2021-04-23T10:13:06.577Z",
            //         "nonce":""
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"BTC/INR",
    //         "info":{
    //             "highest_buy_bid":4368494.31,
    //             "lowest_sell_bid":4374835.09,
    //             "last_traded_price":4374835.09,
    //             "yes_price":4531016.27,
    //             "volume":{"max":"4569119.23","min":"4254552.13","volume":62.17722344}
    //         },
    //         "timestamp":1619100020845,
    //         "datetime":1619100020845,
    //         "high":"4569119.23",
    //         "low":"4254552.13",
    //         "bid":4368494.31,
    //         "bidVolume":"",
    //         "ask":4374835.09,
    //         "askVolume":"",
    //         "vwap":"",
    //         "open":4531016.27,
    //         "close":4374835.09,
    //         "last":4374835.09,
    //         "baseVolume":62.17722344,
    //         "quoteVolume":"",
    //         "previousClose":"",
    //         "change":-156181.1799999997,
    //         "percentage":-3.446934874943623,
    //         "average":4452925.68
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": this.SafeString(ticker, "bidVolume"),
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": this.SafeString(ticker, "askVolume"),
        "vwap": this.SafeString(ticker, "vwap"),
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": this.SafeString(ticker, "previousClose"),
        "change": this.SafeString(ticker, "change"),
        "percentage": this.SafeString(ticker, "percentage"),
        "average": this.SafeString(ticker, "average"),
        "baseVolume": this.SafeString(ticker, "baseVolume"),
        "quoteVolume": this.SafeString(ticker, "quoteVolume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitbns#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitbns) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4648 := (<-this.LoadMarkets())
            PanicOnError(retRes4648)
        
            response:= (<-this.WwwGetOrderFetchTickers(params))
            PanicOnError(response)
        
                //
            //     {
            //         "BTC/INR":{
            //             "symbol":"BTC/INR",
            //             "info":{
            //                 "highest_buy_bid":4368494.31,
            //                 "lowest_sell_bid":4374835.09,
            //                 "last_traded_price":4374835.09,
            //                 "yes_price":4531016.27,
            //                 "volume":{"max":"4569119.23","min":"4254552.13","volume":62.17722344}
            //             },
            //             "timestamp":1619100020845,
            //             "datetime":1619100020845,
            //             "high":"4569119.23",
            //             "low":"4254552.13",
            //             "bid":4368494.31,
            //             "bidVolume":"",
            //             "ask":4374835.09,
            //             "askVolume":"",
            //             "vwap":"",
            //             "open":4531016.27,
            //             "close":4374835.09,
            //             "last":4374835.09,
            //             "baseVolume":62.17722344,
            //             "quoteVolume":"",
            //             "previousClose":"",
            //             "change":-156181.1799999997,
            //             "percentage":-3.446934874943623,
            //             "average":4452925.68
            //         }
            //     }
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) ParseBalance(response interface{}) interface{}  {
    var timestamp interface{} = nil
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
    var keys interface{} = ObjectKeys(data)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        var parts interface{} = Split(key, "availableorder")
        var numParts interface{} =         GetArrayLength(parts)
        if IsTrue(IsGreaterThan(numParts, 1)) {
            var currencyId interface{} = this.SafeString(parts, 1)
            // note that "Money" stands for INR - the only fiat in bitbns
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(data, key))
            AddElementToObject(account, "used", this.SafeString(data, Add("inorder", currencyId)))
            if IsTrue(IsEqual(currencyId, "Money")) {
                currencyId = "INR"
            }
            var code interface{} = this.SafeCurrencyCode(currencyId)
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bitbns#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitbns) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5388 := (<-this.LoadMarkets())
            PanicOnError(retRes5388)
        
            response:= (<-this.V1PostCurrentCoinBalanceEVERYTHING(params))
            PanicOnError(response)
        
                //
            //     {
            //         "data":{
            //             "availableorderMoney":12.34, // INR
            //             "availableorderBTC":0,
            //             "availableorderXRP":0,
            //             "inorderMoney":0, // INR
            //             "inorderBTC":0,
            //             "inorderXRP":0,
            //             "inorderNEO":0,
            //         },
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            // note that "Money" stands for INR - the only fiat in bitbns
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) ParseStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "-1": "cancelled",
        "0": "open",
        "1": "open",
        "2": "done",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitbns) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "data": "Successfully placed bid to purchase currency",
    //         "status": 1,
    //         "error": null,
    //         "id": 5424475,
    //         "code": 200
    //     }
    //
    // fetchOpenOrders, fetchOrder
    //
    //    {
    //        "entry_id": 5424475,
    //        "btc": 0.01,
    //        "rate": 2000,
    //        "time": "2021-04-25T17:05:42.000Z",
    //        "type": 0,
    //        "status": 0
    //        "t_rate": 0.45,                       // only stop orders
    //        "trail": 0                            // only stop orders
    //    }
    //
    // cancelOrder
    //
    //    {
    //        "data": "Successfully cancelled the order",
    //        "status": 1,
    //        "error": null,
    //        "code": 200
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString2(order, "id", "entry_id")
    var datetime interface{} = this.SafeString(order, "time")
    var triggerPrice interface{} = this.SafeString(order, "t_rate")
    var side interface{} = this.SafeString(order, "type")
    if IsTrue(IsEqual(side, "0")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "1")) {
        side = "sell"
    }
    var data interface{} = this.SafeString(order, "data")
    var status interface{} = this.SafeString(order, "status")
    if IsTrue(IsEqual(data, "Successfully cancelled the order")) {
        status = "cancelled"
    } else {
        status = this.ParseStatus(status)
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastTradeTimestamp": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "rate"),
        "triggerPrice": triggerPrice,
        "amount": this.SafeString(order, "btc"),
        "cost": nil,
        "average": nil,
        "filled": nil,
        "remaining": nil,
        "status": status,
        "fee": map[string]interface{} {
            "cost": nil,
            "currency": nil,
            "rate": nil,
        },
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name bitbns#createOrder
 * @description create a trade order
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-2/place-orders
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-1/market-orders-quantity  // market orders
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {float} [params.target_rate] *requires params.trail_rate when set, type must be 'limit'* a bracket order is placed when set
 * @param {float} [params.trail_rate] *requires params.target_rate when set, type must be 'limit'* a bracket order is placed when set
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbns) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6748 := (<-this.LoadMarkets())
            PanicOnError(retRes6748)
            var market interface{} = this.Market(symbol)
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "t_rate"})
            var targetRate interface{} = this.SafeString(params, "target_rate")
            var trailRate interface{} = this.SafeString(params, "trail_rate")
            params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice", "trail_rate", "target_rate", "t_rate"})
            var request interface{} = map[string]interface{} {
                "side": ToUpper(side),
                "symbol": GetValue(market, "uppercaseId"),
                "quantity": this.AmountToPrecision(symbol, amount),
            }
            var method interface{} = "v2PostOrders"
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "rate", this.PriceToPrecision(symbol, price))
            } else {
                method = "v1PostPlaceMarketOrderQntySymbol"
                AddElementToObject(request, "market", GetValue(market, "quoteId"))
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "t_rate", this.PriceToPrecision(symbol, triggerPrice))
            }
            if IsTrue(!IsEqual(targetRate, nil)) {
                AddElementToObject(request, "target_rate", this.PriceToPrecision(symbol, targetRate))
            }
            if IsTrue(!IsEqual(trailRate, nil)) {
                AddElementToObject(request, "trail_rate", this.PriceToPrecision(symbol, trailRate))
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "data":"Successfully placed bid to purchase currency",
            //         "status":1,
            //         "error":null,
            //         "id":5424475,
            //         "code":200
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#cancelOrder
 * @description cancels an open order
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-2/cancel-orders
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-1/cancel-stop-loss-orders
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if cancelling a trigger order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbns) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes7338 := (<-this.LoadMarkets())
            PanicOnError(retRes7338)
            var market interface{} = this.Market(symbol)
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var request interface{} = map[string]interface{} {
                "entry_id": id,
                "symbol": GetValue(market, "uppercaseId"),
            }
            var response interface{} = nil
            var tail interface{} = Ternary(IsTrue(isTrigger), "StopLossOrder", "Order")
            var quoteSide interface{} = Ternary(IsTrue((IsEqual(GetValue(market, "quoteId"), "USDT"))), "usdtcancel", "cancel")
            quoteSide = Add(quoteSide, tail)
            AddElementToObject(request, "side", quoteSide)
            
        response = (<-this.V2PostCancel(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-1/order-status
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbns) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes7648 := (<-this.LoadMarkets())
            PanicOnError(retRes7648)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "entry_id": id,
            }
            var trigger interface{} = this.SafeBool2(params, "trigger", "stop")
            if IsTrue(trigger) {
                panic(BadRequest(Add(this.Id, " fetchOrder cannot fetch stop orders")))
            }
        
            response:= (<-this.V1PostOrderStatusSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "entry_id":5424475,
            //                 "btc":0.01,
            //                 "rate":2000,
            //                 "time":"2021-04-25T17:05:42.000Z",
            //                 "type":0,
            //                 "status":0,
            //                 "total":0.01,
            //                 "avg_cost":null,
            //                 "side":"BUY",
            //                 "amount":0.01,
            //                 "remaining":0.01,
            //                 "filled":0,
            //                 "cost":null,
            //                 "fee":0.05
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0)
        
            ch <- this.ParseOrder(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-2/order-status-limit
 * @see https://docs.bitbns.com/bitbns/rest-endpoints/order-apis/version-2/order-status-limit/order-status-stop-limit
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitbns) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes8228 := (<-this.LoadMarkets())
            PanicOnError(retRes8228)
            var market interface{} = this.Market(symbol)
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var quoteSide interface{} = Ternary(IsTrue((IsEqual(GetValue(market, "quoteId"), "USDT"))), "usdtListOpen", "listOpen")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "uppercaseId"),
                "page": 0,
                "side": Ternary(IsTrue(isTrigger), (Add(quoteSide, "StopOrders")), (Add(quoteSide, "Orders"))),
            }
        
            response:= (<-this.V2PostGetordersnew(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "entry_id":5424475,
            //                 "btc":0.01,
            //                 "rate":2000,
            //                 "time":"2021-04-25T17:05:42.000Z",
            //                 "type":0,
            //                 "status":0
            //                 "t_rate":0.45,                       // only stop orders
            //                 "type":1,                            // only stop orders
            //                 "trail":0                            // only stop orders
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchMyTrades
    //
    //     {
    //         "type": "BTC Sell order executed",
    //         "typeI": 6,
    //         "crypto": 5000,
    //         "amount": 35.4,
    //         "rate": 709800,
    //         "date": "2020-05-22T15:05:34.000Z",
    //         "unit": "INR",
    //         "factor": 100000000,
    //         "fee": 0.09,
    //         "delh_btc": -5000,
    //         "delh_inr": 0,
    //         "del_btc": 0,
    //         "del_inr": 35.4,
    //         "id": "2938823"
    //     }
    //
    // fetchTrades
    //
    //     {
    //         "tradeId":"1909151",
    //         "price":"61904.6300",
    //         "quote_volume":1618.05,
    //         "base_volume":0.02607254,
    //         "timestamp":1634548602000,
    //         "type":"buy"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(nil, market)
    var orderId interface{} = this.SafeString2(trade, "id", "tradeId")
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "date"))
    timestamp = this.SafeInteger(trade, "timestamp", timestamp)
    var priceString interface{} = this.SafeString2(trade, "rate", "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var side interface{} = this.SafeStringLower(trade, "type")
    if IsTrue(!IsEqual(side, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(side, "buy"), 0)) {
            side = "buy"
        } else if IsTrue(IsGreaterThanOrEqual(GetIndexOf(side, "sell"), 0)) {
            side = "sell"
        }
    }
    var factor interface{} = this.SafeString(trade, "factor")
    var costString interface{} = nil
    if IsTrue(!IsEqual(factor, nil)) {
        amountString = Precise.StringDiv(amountString, factor)
    } else {
        amountString = this.SafeString(trade, "base_volume")
        costString = this.SafeString(trade, "quote_volume")
    }
    var symbol interface{} = GetValue(market, "symbol")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyCode interface{} = GetValue(market, "quote")
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": orderId,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitbns#fetchMyTrades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitbns) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes9528 := (<-this.LoadMarkets())
            PanicOnError(retRes9528)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "page": 0,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", this.Iso8601(since))
            }
        
            response:= (<-this.V1PostListExecutedOrdersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "type": "BTC Sell order executed",
            //                 "typeI": 6,
            //                 "crypto": 5000,
            //                 "amount": 35.4,
            //                 "rate": 709800,
            //                 "date": "2020-05-22T15:05:34.000Z",
            //                 "unit": "INR",
            //                 "factor": 100000000,
            //                 "fee": 0.09,
            //                 "delh_btc": -5000,
            //                 "delh_inr": 0,
            //                 "del_btc": 0,
            //                 "del_inr": 35.4,
            //                 "id": "2938823"
            //             },
            //             {
            //                 "type": "BTC Sell order executed",
            //                 "typeI": 6,
            //                 "crypto": 195000,
            //                 "amount": 1380.58,
            //                 "rate": 709765.5,
            //                 "date": "2020-05-22T15:05:34.000Z",
            //                 "unit": "INR",
            //                 "factor": 100000000,
            //                 "fee": 3.47,
            //                 "delh_btc": -195000,
            //                 "delh_inr": 0,
            //                 "del_btc": 0,
            //                 "del_inr": 1380.58,
            //                 "id": "2938823"
            //             }
            //         ],
            //         "status": 1,
            //         "error": null,
            //         "code": 200
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitbns) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires a symbol argument")))
            }
        
            retRes10218 := (<-this.LoadMarkets())
            PanicOnError(retRes10218)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(market, "baseId"),
                "market": GetValue(market, "quoteId"),
            }
        
            response:= (<-this.WwwGetExchangeDataTradedetails(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {"tradeId":"1909151","price":"61904.6300","quote_volume":1618.05,"base_volume":0.02607254,"timestamp":1634548602000,"type":"buy"},
            //         {"tradeId":"1909153","price":"61893.9000","quote_volume":16384.42,"base_volume":0.26405767,"timestamp":1634548999000,"type":"sell"},
            //         {"tradeId":"1909155","price":"61853.1100","quote_volume":2304.37,"base_volume":0.03716263,"timestamp":1634549670000,"type":"sell"}
            //     }
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitbns) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDeposits() requires a currency code argument")))
            }
        
            retRes10528 := (<-this.LoadMarkets())
            PanicOnError(retRes10528)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "id"),
                "page": 0,
            }
        
            response:= (<-this.V1PostDepositHistorySymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "type":"USDT deposited",
            //                 "typeI":1,
            //                 "amount":100,
            //                 "date":"2021-04-24T14:56:04.000Z",
            //                 "unit":"USDT",
            //                 "factor":100,
            //                 "fee":0,
            //                 "delh_btc":0,
            //                 "delh_inr":0,
            //                 "rate":0,
            //                 "del_btc":10000,
            //                 "del_inr":0
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitbns#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitbns) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchWithdrawals() requires a currency code argument")))
            }
        
            retRes11008 := (<-this.LoadMarkets())
            PanicOnError(retRes11008)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "id"),
                "page": 0,
            }
        
            response:= (<-this.V1PostWithdrawHistorySymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     ...
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) ParseTransactionStatusByType(status interface{}, optionalArgs ...interface{}) interface{}  {
    typeVar := GetArg(optionalArgs, 0, nil)
    _ = typeVar
    var statusesByType interface{} = map[string]interface{} {
        "deposit": map[string]interface{} {
            "0": "pending",
            "1": "ok",
        },
        "withdrawal": map[string]interface{} {
            "0": "pending",
            "1": "canceled",
            "2": "pending",
            "3": "failed",
            "4": "pending",
            "5": "failed",
            "6": "ok",
        },
    }
    var statuses interface{} = this.SafeDict(statusesByType, typeVar, map[string]interface{} {})
    return this.SafeString(statuses, status, status)
}
func  (this *bitbns) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "type":"USDT deposited",
    //         "typeI":1,
    //         "amount":100,
    //         "date":"2021-04-24T14:56:04.000Z",
    //         "unit":"USDT",
    //         "factor":100,
    //         "fee":0,
    //         "delh_btc":0,
    //         "delh_inr":0,
    //         "rate":0,
    //         "del_btc":10000,
    //         "del_inr":0
    //     }
    //
    // fetchWithdrawals
    //
    //     ...
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "unit")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.Parse8601(this.SafeString2(transaction, "date", "timestamp"))
    var typeVar interface{} = this.SafeString(transaction, "type")
    var expTime interface{} = this.SafeString(transaction, "expTime", "")
    var status interface{} = nil
    if IsTrue(!IsEqual(typeVar, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(typeVar, "deposit"), 0)) {
            typeVar = "deposit"
            status = "ok"
        } else if IsTrue(IsTrue(IsGreaterThanOrEqual(GetIndexOf(typeVar, "withdraw"), 0)) || IsTrue(IsGreaterThanOrEqual(GetIndexOf(expTime, "withdraw"), 0))) {
            typeVar = "withdrawal"
        }
    }
    // const status = this.parseTransactionStatusByType (this.safeString (transaction, 'status'), type);
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": nil,
        "txid": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": nil,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
/**
 * @method
 * @name bitbns#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bitbns) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12118 := (<-this.LoadMarkets())
            PanicOnError(retRes12118)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "id"),
            }
        
            response:= (<-this.V1PostGetCoinAddressSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":{
            //             "token":"0x680dee9edfff0c397736e10b017cf6a0aee4ba31",
            //             "expiry":"2022-04-24 22:30:11"
            //         },
            //         "status":1,
            //         "error":null
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var address interface{} = this.SafeString(data, "token")
            var tag interface{} = this.SafeString(data, "tag")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": nil,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *bitbns) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *bitbns) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "www")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var urls interface{} = this.Urls
    if !IsTrue((InOp(GetValue(urls, "api"), api))) {
        panic(ExchangeError(Add(Add(Add(this.Id, " does not have a testnet/sandbox URL for "), api), " endpoints")))
    }
    if IsTrue(!IsEqual(api, "www")) {
        this.CheckRequiredCredentials()
        headers = map[string]interface{} {
            "X-BITBNS-APIKEY": this.ApiKey,
        }
    }
    var baseUrl interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api))
    var url interface{} = Add(Add(baseUrl, "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var nonce interface{} = ToString(this.Nonce())
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(method, "POST")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            body = this.Json(query)
        } else {
            body = "{}"
        }
        var auth interface{} = map[string]interface{} {
            "timeStamp_nonce": nonce,
            "body": body,
        }
        var payload interface{} = this.StringToBase64(this.Json(auth))
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha512)
        AddElementToObject(headers, "X-BITBNS-PAYLOAD", payload)
        AddElementToObject(headers, "X-BITBNS-SIGNATURE", signature)
        AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitbns) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"msg":"Invalid Request","status":-1,"code":400}
    //     {"data":[],"status":0,"error":"Nothing to show","code":417}
    //
    var code interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "msg")
    var error interface{} = IsTrue(IsTrue((!IsEqual(code, nil))) && IsTrue((!IsEqual(code, "200")))) && IsTrue((!IsEqual(code, "204")))
    if IsTrue(IsTrue(error) || IsTrue((!IsEqual(message, nil)))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bitbns) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
