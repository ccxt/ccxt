package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type FoxbitCore struct {
	Exchange
}

func NewFoxbitCore() *FoxbitCore {
	p := &FoxbitCore{}
	setDefaults(p)
	return p
}

func (this *FoxbitCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "foxbit",
		"name":      "Foxbit",
		"countries": []interface{}{"pt-BR"},
		"rateLimit": 33.334,
		"version":   "1",
		"comment":   "Foxbit Exchange",
		"certified": false,
		"pro":       false,
		"has": map[string]interface{}{
			"CORS":                  true,
			"spot":                  true,
			"margin":                nil,
			"swap":                  nil,
			"future":                nil,
			"option":                nil,
			"cancelAllOrders":       true,
			"cancelOrder":           true,
			"createLimitBuyOrder":   true,
			"createLimitSellOrder":  true,
			"createMarketBuyOrder":  true,
			"createMarketSellOrder": true,
			"createOrder":           true,
			"fecthOrderBook":        true,
			"fetchBalance":          true,
			"fetchCanceledOrders":   true,
			"fetchClosedOrders":     true,
			"fetchCurrencies":       true,
			"fetchDepositAddress":   true,
			"fetchDeposits":         true,
			"fetchL2OrderBook":      true,
			"fetchLedger":           true,
			"fetchMarkets":          true,
			"fetchMyTrades":         true,
			"fetchOHLCV":            true,
			"fetchOpenOrders":       true,
			"fetchOrder":            true,
			"fetchOrders":           true,
			"fetchTicker":           true,
			"fetchTickers":          true,
			"fetchTrades":           true,
			"fetchTradingFee":       true,
			"fetchTradingFees":      true,
			"fetchTransactions":     true,
			"fetchWithdrawals":      true,
			"loadMarkets":           true,
			"sandbox":               false,
			"withdraw":              true,
			"ws":                    false,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1d",
			"1w":  "1w",
			"2w":  "2w",
			"1M":  "1M",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/1f8faca2-ae2f-4222-b33e-5671e7d873dd",
			"api": map[string]interface{}{
				"public":  "https://api.foxbit.com.br",
				"private": "https://api.foxbit.com.br",
				"status":  "https://metadata-v2.foxbit.com.br/api",
			},
			"www": "https://app.foxbit.com.br",
			"doc": []interface{}{"https://docs.foxbit.com.br"},
		},
		"precisionMode": DECIMAL_PLACES,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"400":  BadRequest,
				"429":  RateLimitExceeded,
				"404":  BadRequest,
				"500":  ExchangeError,
				"2001": AuthenticationError,
				"2002": AuthenticationError,
				"2003": AuthenticationError,
				"2004": BadRequest,
				"2005": PermissionDenied,
				"3001": PermissionDenied,
				"3002": PermissionDenied,
				"3003": AccountSuspended,
				"4001": BadRequest,
				"4002": InsufficientFunds,
				"4003": InvalidOrder,
				"4004": BadSymbol,
				"4005": BadRequest,
				"4007": ExchangeError,
				"4008": InvalidOrder,
				"4009": PermissionDenied,
				"4011": RateLimitExceeded,
				"4012": ExchangeError,
				"5001": ExchangeNotAvailable,
				"5002": OnMaintenance,
				"5003": OnMaintenance,
				"5004": InvalidOrder,
				"5005": InvalidOrder,
				"5006": InvalidOrder,
			},
			"broad": map[string]interface{}{},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey": true,
			"secret": true,
		},
		"api": map[string]interface{}{
			"v3": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"currencies":                      5,
						"markets":                         5,
						"markets/ticker/24hr":             60,
						"markets/{market}/orderbook":      6,
						"markets/{market}/candlesticks":   12,
						"markets/{market}/trades/history": 12,
						"markets/{market}/ticker/24hr":    15,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"accounts":                       2,
						"accounts/{symbol}/transactions": 60,
						"orders":                         2,
						"orders/by-order-id/{id}":        2,
						"trades":                         6,
						"deposits/address":               10,
						"deposits":                       10,
						"withdrawals":                    10,
						"me/fees/trading":                60,
					},
					"post": map[string]interface{}{
						"orders":                2,
						"orders/batch":          7.5,
						"orders/cancel-replace": 3,
						"withdrawals":           10,
					},
					"put": map[string]interface{}{
						"orders/cancel": 2,
					},
				},
			},
			"status": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"status": 30,
					},
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"feeSide":    "get",
				"tierBased":  false,
				"percentage": true,
				"taker":      this.ParseNumber("0.005"),
				"maker":      this.ParseNumber("0.0025"),
			},
		},
		"options": map[string]interface{}{
			"sandboxMode": false,
			"networksById": map[string]interface{}{
				"algorand":        "ALGO",
				"arbitrum":        "ARBITRUM",
				"avalanchecchain": "AVAX",
				"bitcoin":         "BTC",
				"bitcoincash":     "BCH",
				"bsc":             "BEP20",
				"cardano":         "ADA",
				"cosmos":          "ATOM",
				"dogecoin":        "DOGE",
				"erc20":           "ETH",
				"hedera":          "HBAR",
				"litecoin":        "LTC",
				"near":            "NEAR",
				"optimism":        "OPTIMISM",
				"polkadot":        "DOT",
				"polygon":         "MATIC",
				"ripple":          "XRP",
				"solana":          "SOL",
				"stacks":          "STX",
				"stellar":         "XLM",
				"tezos":           "XTZ",
				"trc20":           "TRC20",
			},
			"networks": map[string]interface{}{
				"ALGO":     "algorand",
				"ARBITRUM": "arbitrum",
				"AVAX":     "avalanchecchain",
				"BTC":      "bitcoin",
				"BCH":      "bitcoincash",
				"BEP20":    "bsc",
				"ADA":      "cardano",
				"ATOM":     "cosmos",
				"DOGE":     "dogecoin",
				"ETH":      "erc20",
				"HBAR":     "hedera",
				"LTC":      "litecoin",
				"NEAR":     "near",
				"OPTIMISM": "optimism",
				"DOT":      "polkadot",
				"MATIC":    "polygon",
				"XRP":      "ripple",
				"SOL":      "solana",
				"STX":      "stacks",
				"XLM":      "stellar",
				"XTZ":      "tezos",
				"TRC20":    "trc20",
			},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":   false,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  false,
						"index": false,
					},
					"triggerDirection":           false,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"GTC": true,
						"FOK": true,
						"IOC": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"leverage":               false,
					"marketBuyByCost":        false,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention": map[string]interface{}{
						"expire_maker": true,
						"expire_taker": true,
						"expire_both":  true,
						"none":         true,
					},
					"trailing":      false,
					"icebergAmount": false,
				},
				"createOrders": map[string]interface{}{
					"max": 5,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"untilDays":      10000,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"limit":          1,
					"daysBack":       90,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          100,
					"daysBack":       90,
					"untilDays":      10000,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       true,
					"limit":            100,
					"daysBack":         90,
					"daysBackCanceled": 90,
					"untilDays":        10000,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 500,
				},
			},
		},
	})
}
func (this *FoxbitCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V3PublicGetCurrencies(params))
		PanicOnError(response)
		// {
		//   "data": [
		//     {
		//       "symbol": "btc",
		//       "name": "Bitcoin",
		//       "type": "CRYPTO",
		//       "precision": 8,
		//       "deposit_info": {
		//         "min_to_confirm": "1",
		//         "min_amount": "0.0001"
		//       },
		//       "withdraw_info": {
		//         "enabled": true,
		//         "min_amount": "0.0001",
		//         "fee": "0.0001"
		//       },
		//       "category": {
		//           "code": "cripto",
		//         "name": "Cripto"
		//       },
		//       "networks": [
		//           {
		//               "name": "Bitcoin",
		//               "code": "btc",
		//               "deposit_info": {
		//                  status: "ENABLED",
		//               },
		//               "withdraw_info": {
		//                  "status": "ENABLED",
		//                  "fee": "0.0001",
		//               },
		//               "has_destination_tag": false
		//           }
		//       ]
		//     }
		//   ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var currency interface{} = GetValue(data, i)
			var precision interface{} = this.SafeInteger(currency, "precision")
			var currencyId interface{} = this.SafeString(currency, "symbol")
			var name interface{} = this.SafeString(currency, "name")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var depositInfo interface{} = this.SafeDict(currency, "deposit_info")
			var withdrawInfo interface{} = this.SafeDict(currency, "withdraw_info")
			var networks interface{} = this.SafeList(currency, "networks", []interface{}{})
			var typeVar interface{} = this.SafeStringLower(currency, "type")
			var parsedNetworks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
				var network interface{} = GetValue(networks, j)
				var networkId interface{} = this.SafeString(network, "code")
				var networkCode interface{} = this.NetworkIdToCode(networkId, code)
				var networkWithdrawInfo interface{} = this.SafeDict(network, "withdraw_info")
				var networkDepositInfo interface{} = this.SafeDict(network, "deposit_info")
				var isWithdrawEnabled interface{} = IsEqual(this.SafeString(networkWithdrawInfo, "status"), "ENABLED")
				var isDepositEnabled interface{} = IsEqual(this.SafeString(networkDepositInfo, "status"), "ENABLED")
				AddElementToObject(parsedNetworks, networkCode, map[string]interface{}{
					"info":      currency,
					"id":        networkId,
					"network":   networkCode,
					"name":      this.SafeString(network, "name"),
					"deposit":   isDepositEnabled,
					"withdraw":  isWithdrawEnabled,
					"active":    true,
					"precision": precision,
					"fee":       this.SafeNumber(networkWithdrawInfo, "fee"),
					"limits": map[string]interface{}{
						"amount": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(depositInfo, "min_amount"),
							"max": nil,
						},
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(withdrawInfo, "min_amount"),
							"max": nil,
						},
					},
				})
			}
			if IsTrue(IsEqual(this.SafeDict(result, code), nil)) {
				AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
					"id":        currencyId,
					"code":      code,
					"info":      currency,
					"name":      name,
					"active":    true,
					"type":      typeVar,
					"deposit":   this.SafeBool(depositInfo, "enabled", false),
					"withdraw":  this.SafeBool(withdrawInfo, "enabled", false),
					"fee":       this.SafeNumber(withdrawInfo, "fee"),
					"precision": precision,
					"limits": map[string]interface{}{
						"amount": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(depositInfo, "min_amount"),
							"max": nil,
						},
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(withdrawInfo, "min_amount"),
							"max": nil,
						},
					},
					"networks": parsedNetworks,
				}))
			}
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchMarkets
 * @description Retrieves data on all markets for foxbit.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_index
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *FoxbitCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V3PublicGetMarkets(params))
		PanicOnError(response)
		// {
		//     "data": [
		//       {
		//         "symbol": "btcbrl",
		//         "quantity_min": "0.00000236",
		//         "quantity_increment": "0.00000001",
		//         "quantity_precision": 8,
		//         "price_min": "0.0001",
		//         "price_increment": "0.0001",
		//         "price_precision": 4,
		//         "default_fees": {
		//           "maker": "0.001",
		//           "taker": "0.001"
		//         },
		//         "base": {
		//           "symbol": "btc",
		//           "name": "Bitcoin",
		//           "type": "CRYPTO",
		//           "precision": 8,
		//           "category": {
		//             "code": "cripto",
		//             "name": "Cripto"
		//           },
		//           "deposit_info": {
		//             "min_to_confirm": "1",
		//             "min_amount": "0.0001",
		//             "enabled": true
		//           },
		//           "withdraw_info": {
		//             "enabled": true,
		//             "min_amount": "0.0001",
		//             "fee": "0.0001"
		//           },
		//           "networks": [
		//             {
		//               "name": "Bitcoin",
		//               "code": "bitcoin",
		//               "deposit_info": {
		//                 "status": "ENABLED"
		//               },
		//               "withdraw_info": {
		//                 "status": "ENABLED",
		//                 "fee": "0.0001"
		//               },
		//               "has_destination_tag": false
		//             }
		//           ],
		//           "default_network_code": "bitcoin"
		//         },
		//         "quote": {
		//           "symbol": "btc",
		//           "name": "Bitcoin",
		//           "type": "CRYPTO",
		//           "precision": 8,
		//           "category": {
		//             "code": "cripto",
		//             "name": "Cripto"
		//           },
		//           "deposit_info": {
		//             "min_to_confirm": "1",
		//             "min_amount": "0.0001",
		//             "enabled": true
		//           },
		//           "withdraw_info": {
		//             "enabled": true,
		//             "min_amount": "0.0001",
		//             "fee": "0.0001"
		//           },
		//           "networks": [
		//             {
		//               "name": "Bitcoin",
		//               "code": "bitcoin",
		//               "deposit_info": {
		//                 "status": "ENABLED"
		//               },
		//               "withdraw_info": {
		//                 "status": "ENABLED",
		//                 "fee": "0.0001"
		//               },
		//               "has_destination_tag": false
		//             }
		//           ],
		//           "default_network_code": "bitcoin"
		//         },
		//         "order_type": [
		//           "LIMIT",
		//           "MARKET",
		//           "INSTANT",
		//           "STOP_LIMIT",
		//           "STOP_MARKET"
		//         ]
		//       }
		//     ]
		//   }
		var markets interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(markets)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchTicker
 * @description Get last 24 hours ticker information, in real-time, for given market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *FoxbitCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes5668 := (<-this.LoadMarkets())
		PanicOnError(retRes5668)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"market": GetValue(market, "id"),
		}

		response := (<-this.V3PublicGetMarketsMarketTicker24hr(this.Extend(request, params)))
		PanicOnError(response)
		//  {
		//    "data": [
		//      {
		//        "market_symbol": "btcbrl",
		//        "last_trade": {
		//          "price": "358504.69340000",
		//          "volume": "0.00027893",
		//          "date": "2024-01-01T00:00:00.000Z"
		//        },
		//        "rolling_24h": {
		//          "price_change": "3211.87290000",
		//          "price_change_percent": "0.90400726",
		//          "volume": "20.03206866",
		//          "trades_count": "4376",
		//          "open": "355292.82050000",
		//          "high": "362999.99990000",
		//          "low": "355002.88880000"
		//        },
		//        "best": {
		//          "ask": {
		//            "price": "358504.69340000",
		//            "volume": "0.00027893"
		//          },
		//          "bid": {
		//            "price": "358504.69340000",
		//            "volume": "0.00027893"
		//          }
		//        }
		//      }
		//    ]
		//  }
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTicker(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchTickers
 * @description Retrieve the ticker data of all markets.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *FoxbitCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes6188 := (<-this.LoadMarkets())
		PanicOnError(retRes6188)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.V3PublicGetMarketsTicker24hr(params))
		PanicOnError(response)
		//  {
		//    "data": [
		//      {
		//        "market_symbol": "btcbrl",
		//        "last_trade": {
		//          "price": "358504.69340000",
		//          "volume": "0.00027893",
		//          "date": "2024-01-01T00:00:00.000Z"
		//        },
		//        "rolling_24h": {
		//          "price_change": "3211.87290000",
		//          "price_change_percent": "0.90400726",
		//          "volume": "20.03206866",
		//          "trades_count": "4376",
		//          "open": "355292.82050000",
		//          "high": "362999.99990000",
		//          "low": "355002.88880000"
		//        },
		//      }
		//    ]
		//  }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Member-Info/operation/MembersController_listTradingFees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/?id=fee-structure} indexed by market symbols
 */
func (this *FoxbitCore) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes6558 := (<-this.LoadMarkets())
		PanicOnError(retRes6558)

		response := (<-this.V3PrivateGetMeFeesTrading(params))
		PanicOnError(response)
		// [
		//     {
		//         "market_symbol": "btcbrl",
		//         "maker": "0.0025",
		//         "taker": "0.005"
		//     }
		// ]
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var marketId interface{} = this.SafeString(entry, "market_symbol")
			var market interface{} = this.SafeMarket(marketId)
			var symbol interface{} = GetValue(market, "symbol")
			AddElementToObject(result, symbol, this.ParseTradingFee(entry, market))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchOrderBook
 * @description Exports a copy of the order book of a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findOrderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return, the maximum is 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *FoxbitCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes6878 := (<-this.LoadMarkets())
		PanicOnError(retRes6878)
		var market interface{} = this.Market(symbol)
		var defaultLimit interface{} = 20
		var request interface{} = map[string]interface{}{
			"market": GetValue(market, "id"),
			"depth":  Ternary(IsTrue((IsEqual(limit, nil))), defaultLimit, limit),
		}

		response := (<-this.V3PublicGetMarketsMarketOrderbook(this.Extend(request, params)))
		PanicOnError(response)
		//  {
		//    "sequence_id": 1234567890,
		//    "timestamp": 1713187921336,
		//    "bids": [
		//      [
		//        "3.00000000",
		//        "300.00000000"
		//      ],
		//      [
		//        "1.70000000",
		//        "310.00000000"
		//      ]
		//    ],
		//    "asks": [
		//      [
		//        "3.00000000",
		//        "300.00000000"
		//      ],
		//      [
		//        "2.00000000",
		//        "321.00000000"
		//      ]
		//    ]
		//  }
		var timestamp interface{} = this.SafeInteger(response, "timestamp")

		ch <- this.ParseOrderBook(response, symbol, timestamp)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchTrades
 * @description Retrieve the trades of a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_publicTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *FoxbitCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes7358 := (<-this.LoadMarkets())
		PanicOnError(retRes7358)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"market": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 200)) {
				AddElementToObject(request, "page_size", 200)
			}
		}
		// [
		//     {
		//         "id": 1,
		//         "price": "329248.74700000",
		//         "volume": "0.00100000",
		//         "taker_side": "BUY",
		//         "created_at": "2024-01-01T00:00:00Z"
		//     }
		// ]

		response := (<-this.V3PublicGetMarketsMarketTradesHistory(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchOHLCV
 * @description Fetch historical candlestick data containing the open, high, low, and close price, and the volume of a market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findCandlesticks
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *FoxbitCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes7738 := (<-this.LoadMarkets())
		PanicOnError(retRes7738)
		var market interface{} = this.Market(symbol)
		var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
		var request interface{} = map[string]interface{}{
			"market":   GetValue(market, "id"),
			"interval": interval,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
			if IsTrue(IsGreaterThan(limit, 500)) {
				AddElementToObject(request, "limit", 500)
			}
		}

		response := (<-this.V3PublicGetMarketsMarketCandlesticks(this.Extend(request, params)))
		PanicOnError(response)

		// [
		//     [
		//         "1692918000000", // timestamp
		//         "127772.05150000", // open
		//         "128467.99980000", // high
		//         "127750.01000000", // low
		//         "128353.99990000", // close
		//         "1692918060000", // close timestamp
		//         "0.17080431", // base volume
		//         "21866.35948786", // quote volume
		//         66, // number of trades
		//         "0.12073605", // taker buy base volume
		//         "15466.34096391" // taker buy quote volume
		//     ]
		// ]
		ch <- this.ParseOHLCVs(response, market, interval, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchBalance
 * @description Query for balance and get the amount of funds available for trading or funds locked in orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_all
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *FoxbitCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8178 := (<-this.LoadMarkets())
		PanicOnError(retRes8178)

		response := (<-this.V3PrivateGetAccounts(params))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//         "currency_symbol": "btc",
		//         "balance": "10000.0",
		//         "balance_available": "9000.0",
		//         "balance_locked": "1000.0"
		//         }
		//     ]
		// }
		var accounts interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{
			"info": response,
		}
		for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
			var account interface{} = GetValue(accounts, i)
			var currencyId interface{} = this.SafeString(account, "currency_symbol")
			var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
			var total interface{} = this.SafeString(account, "balance")
			var used interface{} = this.SafeString(account, "balance_locked")
			var free interface{} = this.SafeString(account, "balance_available")
			var balanceObj interface{} = map[string]interface{}{
				"free":  free,
				"used":  used,
				"total": total,
			}
			AddElementToObject(result, currencyCode, balanceObj)
		}

		ch <- this.SafeBalance(result)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchOpenOrders
 * @description Fetch all unfilled currently open orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes86215 := (<-this.FetchOrdersByStatus("ACTIVE", symbol, since, limit, params))
		PanicOnError(retRes86215)
		ch <- retRes86215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchClosedOrders
 * @description Fetch all currently closed orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes87715 := (<-this.FetchOrdersByStatus("FILLED", symbol, since, limit, params))
		PanicOnError(retRes87715)
		ch <- retRes87715
		return nil

	}()
	return ch
}
func (this *FoxbitCore) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes88115 := (<-this.FetchOrdersByStatus("CANCELED", symbol, since, limit, params))
		PanicOnError(retRes88115)
		ch <- retRes88115
		return nil

	}()
	return ch
}
func (this *FoxbitCore) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes8858 := (<-this.LoadMarkets())
		PanicOnError(retRes8858)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{
			"state": status,
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "market_symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}

		response := (<-this.V3PrivateGetOrders(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#createOrder
 * @description Create an order with the specified characteristics
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_create
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_market', 'stop_limit', 'instant'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "FOK", "IOC", "PO"
 * @param {float} [params.triggerPrice] The time in force for the order. One of GTC, FOK, IOC, PO. See .features or foxbit's doc to see more details.
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {string} [params.clientOrderId] a unique identifier for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes9268 := (<-this.LoadMarkets())
		PanicOnError(retRes9268)
		var market interface{} = this.Market(symbol)
		typeVar = ToUpper(typeVar)
		if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_LIMIT"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
			panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: limit, market, stop_market, stop_limit, instant.")))
		}
		var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
		var postOnly interface{} = this.SafeBool(params, "postOnly", false)
		var triggerPrice interface{} = this.SafeNumber(params, "triggerPrice")
		var request interface{} = map[string]interface{}{
			"market_symbol": GetValue(market, "id"),
			"side":          ToUpper(side),
			"type":          typeVar,
		}
		if IsTrue(IsTrue(IsEqual(typeVar, "STOP_MARKET")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
			if IsTrue(IsEqual(triggerPrice, nil)) {
				panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must have triggerPrice.")))
			}
		}
		if IsTrue(!IsEqual(timeInForce, nil)) {
			if IsTrue(IsEqual(timeInForce, "PO")) {
				AddElementToObject(request, "post_only", true)
			} else {
				AddElementToObject(request, "time_in_force", timeInForce)
			}
		}
		if IsTrue(postOnly) {
			AddElementToObject(request, "post_only", true)
		}
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
		}
		if IsTrue(IsEqual(typeVar, "INSTANT")) {
			AddElementToObject(request, "amount", this.PriceToPrecision(symbol, amount))
		} else {
			AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
		}
		if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "client_order_id", clientOrderId)
		}
		params = this.Omit(params, []interface{}{"timeInForce", "postOnly", "triggerPrice", "clientOrderId"})

		response := (<-this.V3PrivatePostOrders(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "id": 1234567890,
		//     "sn": "OKMAKSDHRVVREK",
		//     "client_order_id": "451637946501"
		// }
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#createOrders
 * @description create a list of trade orders
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/createBatch
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes9908 := (<-this.LoadMarkets())
		PanicOnError(retRes9908)
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var order interface{} = this.SafeDict(orders, i)
			var symbol interface{} = this.SafeString(order, "symbol")
			var market interface{} = this.Market(symbol)
			var typeVar interface{} = this.SafeStringUpper(order, "type")
			var orderParams interface{} = this.SafeDict(order, "params", map[string]interface{}{})
			if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_LIMIT"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
				panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: limit, market, stop_market, stop_limit, instant.")))
			}
			var timeInForce interface{} = this.SafeStringUpper(orderParams, "timeInForce")
			var postOnly interface{} = this.SafeBool(orderParams, "postOnly", false)
			var triggerPrice interface{} = this.SafeNumber(orderParams, "triggerPrice")
			var request interface{} = map[string]interface{}{
				"market_symbol": GetValue(market, "id"),
				"side":          this.SafeStringUpper(order, "side"),
				"type":          typeVar,
			}
			if IsTrue(IsTrue(IsEqual(typeVar, "STOP_MARKET")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
				if IsTrue(IsEqual(triggerPrice, nil)) {
					panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must have triggerPrice.")))
				}
			}
			if IsTrue(!IsEqual(timeInForce, nil)) {
				if IsTrue(IsEqual(timeInForce, "PO")) {
					AddElementToObject(request, "post_only", true)
				} else {
					AddElementToObject(request, "time_in_force", timeInForce)
				}
				Remove(orderParams, "timeInForce")
			}
			if IsTrue(postOnly) {
				AddElementToObject(request, "post_only", true)
				Remove(orderParams, "postOnly")
			}
			if IsTrue(!IsEqual(triggerPrice, nil)) {
				AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
				Remove(orderParams, "triggerPrice")
			}
			if IsTrue(IsEqual(typeVar, "INSTANT")) {
				AddElementToObject(request, "amount", this.PriceToPrecision(symbol, this.SafeString(order, "amount")))
			} else {
				AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, this.SafeString(order, "amount")))
			}
			if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
				AddElementToObject(request, "price", this.PriceToPrecision(symbol, this.SafeString(order, "price")))
			}
			AppendToArray(&ordersRequests, this.Extend(request, orderParams))
		}
		var createOrdersRequest interface{} = map[string]interface{}{
			"data": ordersRequests,
		}

		response := (<-this.V3PrivatePostOrdersBatch(this.Extend(createOrdersRequest, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//         "side": "BUY",
		//         "type": "LIMIT",
		//         "market_symbol": "btcbrl",
		//         "client_order_id": "451637946501",
		//         "remark": "A remarkable note for the order.",
		//         "quantity": "0.42",
		//         "price": "250000.0",
		//         "post_only": true,
		//         "time_in_force": "GTC"
		//         }
		//     ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#cancelOrder
 * @description Cancel open orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes10728 := (<-this.LoadMarkets())
		PanicOnError(retRes10728)
		var request interface{} = map[string]interface{}{
			"id":   this.ParseNumber(id),
			"type": "ID",
		}

		response := (<-this.V3PrivatePutOrdersCancel(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//         "sn": "OKMAKSDHRVVREK",
		//         "id": 123456789
		//         }
		//     ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseOrder(result)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#cancelAllOrders
 * @description Cancel all open orders or all open orders for a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11018 := (<-this.LoadMarkets())
		PanicOnError(retRes11018)
		var request interface{} = map[string]interface{}{
			"type": "ALL",
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			var market interface{} = this.Market(symbol)
			AddElementToObject(request, "type", "MARKET")
			AddElementToObject(request, "market_symbol", GetValue(market, "id"))
		}

		response := (<-this.V3PrivatePutOrdersCancel(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "data": [
		//         {
		//           "sn": "OKMAKSDHRVVREK",
		//           "id": 123456789
		//         }
		//     ]
		// }
		ch <- []interface{}{this.SafeOrder(map[string]interface{}{
			"info": response,
		})}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchOrder
 * @description Get an order by ID.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_findByOrderId
 * @param id
 * @param {string} symbol it is not used in the foxbit API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11358 := (<-this.LoadMarkets())
		PanicOnError(retRes11358)
		var request interface{} = map[string]interface{}{
			"id": id,
		}

		response := (<-this.V3PrivateGetOrdersByOrderIdId(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "id": "1234567890",
		//     "sn": "OKMAKSDHRVVREK",
		//     "client_order_id": "451637946501",
		//     "market_symbol": "btcbrl",
		//     "side": "BUY",
		//     "type": "LIMIT",
		//     "state": "ACTIVE",
		//     "price": "290000.0",
		//     "price_avg": "295333.3333",
		//     "quantity": "0.42",
		//     "quantity_executed": "0.41",
		//     "instant_amount": "290.0",
		//     "instant_amount_executed": "290.0",
		//     "created_at": "2021-02-15T22:06:32.999Z",
		//     "trades_count": "2",
		//     "remark": "A remarkable note for the order.",
		//     "funds_received": "290.0"
		// }
		ch <- this.ParseOrder(response, nil)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.state] Enum: ACTIVE, CANCELED, FILLED, PARTIALLY_CANCELED, PARTIALLY_FILLED
 * @param {string} [params.side] Enum: BUY, SELL
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11768 := (<-this.LoadMarkets())
		PanicOnError(retRes11768)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "market_symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}

		response := (<-this.V3PrivateGetOrders(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//         "id": "1234567890",
		//         "sn": "OKMAKSDHRVVREK",
		//         "client_order_id": "451637946501",
		//         "market_symbol": "btcbrl",
		//         "side": "BUY",
		//         "type": "LIMIT",
		//         "state": "ACTIVE",
		//         "price": "290000.0",
		//         "price_avg": "295333.3333",
		//         "quantity": "0.42",
		//         "quantity_executed": "0.41",
		//         "instant_amount": "290.0",
		//         "instant_amount_executed": "290.0",
		//         "created_at": "2021-02-15T22:06:32.999Z",
		//         "trades_count": "2",
		//         "remark": "A remarkable note for the order.",
		//         "funds_received": "290.0"
		//         }
		//     ]
		// }
		var list interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(list, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchMyTrades
 * @description Trade history queries will only have data available for the last 3 months, in descending order (most recents trades first).
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/TradesController_all
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *FoxbitCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes12358 := (<-this.LoadMarkets())
		PanicOnError(retRes12358)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"market_symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}

		response := (<-this.V3PrivateGetTrades(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         "id": 1234567890,
		//         "sn": "TC5JZVW2LLJ3IW",
		//         "order_id": 1234567890,
		//         "market_symbol": "btcbrl",
		//         "side": "BUY",
		//         "price": "290000.0",
		//         "quantity": "1.0",
		//         "fee": "0.01",
		//         "fee_currency_symbol": "btc",
		//         "created_at": "2021-02-15T22:06:32.999Z"
		//     ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchDepositAddress
 * @description Fetch the deposit address for a currency associated with this account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_depositAddress
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.networkCode] the blockchain network to create a deposit address on
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *FoxbitCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes12798 := (<-this.LoadMarkets())
		PanicOnError(retRes12798)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency_symbol": GetValue(currency, "id"),
		}
		networkCodeparamsOmitedVariable := this.HandleNetworkCodeAndParams(params)
		networkCode := GetValue(networkCodeparamsOmitedVariable, 0)
		paramsOmited := GetValue(networkCodeparamsOmitedVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "network_code", this.NetworkCodeToId(networkCode, code))
		}

		response := (<-this.V3PrivateGetDepositsAddress(this.Extend(request, paramsOmited)))
		PanicOnError(response)

		// {
		//     "currency_symbol": "btc",
		//     "address": "2N9sS8LgrY19rvcCWDmE1ou1tTVmqk4KQAB",
		//     "message": "Address was retrieved successfully",
		//     "destination_tag": "string",
		//     "network": {
		//         "name": "Bitcoin Network",
		//         "code": "btc"
		//     }
		// }
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchDeposits
 * @description Fetch all deposits made to an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposit structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *FoxbitCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes13148 := (<-this.LoadMarkets())
		PanicOnError(retRes13148)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}

		response := (<-this.V3PrivateGetDeposits(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//             "sn": "OKMAKSDHRVVREK",
		//             "state": "ACCEPTED",
		//             "currency_symbol": "btc",
		//             "amount": "1.0",
		//             "fee": "0.1",
		//             "created_at": "2022-02-18T22:06:32.999Z",
		//             "details_crypto": {
		//                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
		//                 "receiving_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
		//             }
		//         }
		//     ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchWithdrawals
 * @description Fetch all withdrawals made from an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *FoxbitCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes13628 := (<-this.LoadMarkets())
		PanicOnError(retRes13628)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}

		response := (<-this.V3PrivateGetWithdrawals(this.Extend(request, params)))
		PanicOnError(response)
		// {
		//     "data": [
		//         {
		//             "sn": "OKMAKSDHRVVREK",
		//             "state": "ACCEPTED",
		//             "rejection_reason": "monthly_limit_exceeded",
		//             "currency_symbol": "btc",
		//             "amount": "1.0",
		//             "fee": "0.1",
		//             "created_at": "2022-02-18T22:06:32.999Z",
		//             "details_crypto": {
		//                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
		//                 "destination_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
		//             },
		//             "details_fiat": {
		//                 "bank": {
		//                     "code": "1",
		//                     "branch": {
		//                         "number": "1234567890",
		//                         "digit": "1"
		//                     },
		//                     "account": {
		//                         "number": "1234567890",
		//                         "digit": "1",
		//                         "type": "CHECK"
		//                     }
		//                 }
		//             }
		//         }
		//     ]
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchTransactions
 * @description Fetch all transactions (deposits and withdrawals) made from an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *FoxbitCore) FetchTransactions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		withdrawals := (<-this.FetchWithdrawals(code, since, limit, params))
		PanicOnError(withdrawals)

		deposits := (<-this.FetchDeposits(code, since, limit, params))
		PanicOnError(deposits)
		var allTransactions interface{} = this.ArrayConcat(withdrawals, deposits)
		var result interface{} = this.SortBy(allTransactions, "timestamp")

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchStatus
 * @description The latest known information on the availability of the exchange API.
 * @see https://status.foxbit.com/
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *FoxbitCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.StatusPublicGetStatus(params))
		PanicOnError(response)
		// {
		//     "data": {
		//       "id": 1,
		//       "attributes": {
		//         "status": "NORMAL",
		//         "createdAt": "2023-05-17T18:37:05.934Z",
		//         "updatedAt": "2024-04-17T02:33:50.945Z",
		//         "publishedAt": "2023-05-17T18:37:07.653Z",
		//         "locale": "pt-BR"
		//       }
		//     },
		//     "meta": {
		//     }
		// }
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var attributes interface{} = this.SafeDict(data, "attributes", map[string]interface{}{})
		var statusRaw interface{} = this.SafeString(attributes, "status")
		var statusMap interface{} = map[string]interface{}{
			"NORMAL":            "ok",
			"UNDER_MAINTENANCE": "maintenance",
		}

		ch <- map[string]interface{}{
			"status":  this.SafeString(statusMap, statusRaw, statusRaw),
			"updated": this.SafeString(attributes, "updatedAt"),
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#editOrder
 * @description Simultaneously cancel an existing order and create a new one.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancelReplace
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders, used as stop_price on stop market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *FoxbitCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a symbol argument")))
		}
		typeVar = ToUpper(typeVar)
		if IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
			panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: LIMIT, MARKET, STOP_MARKET, INSTANT.")))
		}

		retRes14958 := (<-this.LoadMarkets())
		PanicOnError(retRes14958)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"mode": "ALLOW_FAILURE",
			"cancel": map[string]interface{}{
				"type": "ID",
				"id":   this.ParseNumber(id),
			},
			"create": map[string]interface{}{
				"type":          typeVar,
				"side":          ToUpper(side),
				"market_symbol": GetValue(market, "id"),
			},
		}
		if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "MARKET"))) {
			AddElementToObject(GetValue(request, "create"), "quantity", this.AmountToPrecision(symbol, amount))
			if IsTrue(IsEqual(typeVar, "LIMIT")) {
				AddElementToObject(GetValue(request, "create"), "price", this.PriceToPrecision(symbol, price))
			}
		}
		if IsTrue(IsEqual(typeVar, "STOP_MARKET")) {
			AddElementToObject(GetValue(request, "create"), "stop_price", this.PriceToPrecision(symbol, price))
			AddElementToObject(GetValue(request, "create"), "quantity", this.AmountToPrecision(symbol, amount))
		}
		if IsTrue(IsEqual(typeVar, "INSTANT")) {
			AddElementToObject(GetValue(request, "create"), "amount", this.PriceToPrecision(symbol, amount))
		}

		response := (<-this.V3PrivatePostOrdersCancelReplace(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "cancel": {
		//         "id": 123456789
		//     },
		//     "create": {
		//         "id": 1234567890,
		//         "client_order_id": "451637946501"
		//     }
		// }
		ch <- this.ParseOrder(GetValue(response, "create"), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#withdraw
 * @description Make a withdrawal.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_createWithdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *FoxbitCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes15498 := (<-this.LoadMarkets())
		PanicOnError(retRes15498)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency_symbol":     GetValue(currency, "id"),
			"amount":              this.NumberToString(amount),
			"destination_address": address,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "destination_tag", tag)
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "network_code", this.NetworkCodeToId(networkCode))
		}

		response := (<-this.V3PrivatePostWithdrawals(this.Extend(request, params)))
		PanicOnError(response)

		// {
		//     "amount": "1",
		//     "currency_symbol": "xrp",
		//     "network_code": "ripple",
		//     "destination_address": "0x1234567890123456789012345678",
		//     "destination_tag": "123456"
		// }
		ch <- this.ParseTransaction(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name foxbit#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_getTransactions
 * @param {string} code unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entrys to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-structure}
 */
func (this *FoxbitCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes15878 := (<-this.LoadMarkets())
		PanicOnError(retRes15878)
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchLedger() requires a code argument")))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
			if IsTrue(IsGreaterThan(limit, 100)) {
				AddElementToObject(request, "page_size", 100)
			}
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", this.Iso8601(since))
		}
		var currency interface{} = this.Currency(code)
		AddElementToObject(request, "symbol", GetValue(currency, "id"))

		response := (<-this.V3PrivateGetAccountsSymbolTransactions(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLedger(data, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *FoxbitCore) ParseMarket(market interface{}) interface{} {
	var id interface{} = this.SafeString(market, "symbol")
	var baseAssets interface{} = this.SafeDict(market, "base")
	var baseId interface{} = this.SafeString(baseAssets, "symbol")
	var quoteAssets interface{} = this.SafeDict(market, "quote")
	var quoteId interface{} = this.SafeString(quoteAssets, "symbol")
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	var fees interface{} = this.SafeDict(market, "default_fees")
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"active":         true,
		"type":           "spot",
		"spot":           true,
		"margin":         false,
		"future":         false,
		"swap":           false,
		"option":         false,
		"contract":       false,
		"settle":         nil,
		"settleId":       nil,
		"contractSize":   nil,
		"linear":         nil,
		"inverse":        nil,
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"taker":          this.SafeNumber(fees, "taker"),
		"maker":          this.SafeNumber(fees, "maker"),
		"percentage":     true,
		"tierBased":      false,
		"feeSide":        "get",
		"precision": map[string]interface{}{
			"price":  this.SafeInteger(quoteAssets, "precision"),
			"amount": this.SafeInteger(baseAssets, "precision"),
			"cost":   this.SafeInteger(quoteAssets, "precision"),
		},
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": this.SafeNumber(market, "quantity_min"),
				"max": nil,
			},
			"price": map[string]interface{}{
				"min": this.SafeNumber(market, "price_min"),
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"info": market,
	})
}
func (this *FoxbitCore) ParseTradingFee(entry interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return map[string]interface{}{
		"info":       entry,
		"symbol":     GetValue(market, "symbol"),
		"maker":      this.SafeNumber(entry, "maker"),
		"taker":      this.SafeNumber(entry, "taker"),
		"percentage": true,
		"tierBased":  true,
	}
}
func (this *FoxbitCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "market_symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market, nil, "spot")
	var rolling_24h interface{} = GetValue(ticker, "rolling_24h")
	var best interface{} = this.SafeDict(ticker, "best")
	var bestAsk interface{} = this.SafeDict(best, "ask")
	var bestBid interface{} = this.SafeDict(best, "bid")
	var lastTrade interface{} = GetValue(ticker, "last_trade")
	var lastPrice interface{} = this.SafeString(lastTrade, "price")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     this.ParseDate(this.SafeString(lastTrade, "date")),
		"datetime":      this.Iso8601(this.ParseDate(this.SafeString(lastTrade, "date"))),
		"high":          this.SafeNumber(rolling_24h, "high"),
		"low":           this.SafeNumber(rolling_24h, "low"),
		"bid":           this.SafeNumber(bestBid, "price"),
		"bidVolume":     this.SafeNumber(bestBid, "volume"),
		"ask":           this.SafeNumber(bestAsk, "price"),
		"askVolume":     this.SafeNumber(bestAsk, "volume"),
		"vwap":          nil,
		"open":          this.SafeNumber(rolling_24h, "open"),
		"close":         lastPrice,
		"last":          lastPrice,
		"previousClose": nil,
		"change":        this.SafeString(rolling_24h, "price_change"),
		"percentage":    this.SafeString(rolling_24h, "price_change_percent"),
		"average":       nil,
		"baseVolume":    this.SafeString(rolling_24h, "volume"),
		"quoteVolume":   this.SafeString(rolling_24h, "quote_volume"),
		"info":          ticker,
	}, market)
}
func (this *FoxbitCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 6)}
}
func (this *FoxbitCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.ParseDate(this.SafeString(trade, "created_at"))
	var price interface{} = this.SafeString(trade, "price")
	var amount interface{} = this.SafeString(trade, "volume", this.SafeString(trade, "quantity"))
	var privateSideField interface{} = this.SafeStringLower(trade, "side")
	var side interface{} = this.SafeStringLower(trade, "taker_side", privateSideField)
	var cost interface{} = Precise.StringMul(price, amount)
	var fee interface{} = map[string]interface{}{
		"currency": this.SafeSymbol(this.SafeString(trade, "fee_currency_symbol")),
		"cost":     this.SafeNumber(trade, "fee"),
		"rate":     nil,
	}
	return this.SafeTrade(map[string]interface{}{
		"id":           this.SafeString(trade, "id"),
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"order":        nil,
		"type":         nil,
		"side":         side,
		"takerOrMaker": nil,
		"price":        price,
		"amount":       amount,
		"cost":         cost,
		"fee":          fee,
	}, market)
}
func (this *FoxbitCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"PARTIALLY_CANCELED": "open",
		"ACTIVE":             "open",
		"PARTIALLY_FILLED":   "open",
		"FILLED":             "closed",
		"PENDING_CANCEL":     "canceled",
		"CANCELED":           "canceled",
	}
	return this.SafeString(statuses, status, status)
}
func (this *FoxbitCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var symbol interface{} = this.SafeString(order, "market_symbol")
	if IsTrue(IsTrue(IsEqual(market, nil)) && IsTrue(!IsEqual(symbol, nil))) {
		market = this.Market(symbol)
	}
	if IsTrue(!IsEqual(market, nil)) {
		symbol = GetValue(market, "symbol")
	}
	var timestamp interface{} = this.ParseDate(this.SafeString(order, "created_at"))
	var price interface{} = this.SafeString(order, "price")
	var filled interface{} = this.SafeString(order, "quantity_executed")
	var remaining interface{} = this.SafeString(order, "quantity")
	// TODO: validate logic of amount here, should this be calculated?
	var amount interface{} = nil
	if IsTrue(IsTrue(!IsEqual(remaining, nil)) && IsTrue(!IsEqual(filled, nil))) {
		amount = Precise.StringAdd(remaining, filled)
	}
	var cost interface{} = this.SafeString(order, "funds_received")
	if !IsTrue(cost) {
		var priceAverage interface{} = this.SafeString(order, "price_avg")
		var priceToCalculate interface{} = this.SafeString(order, "price", priceAverage)
		cost = Precise.StringMul(priceToCalculate, amount)
	}
	var side interface{} = this.SafeStringLower(order, "side")
	var feeCurrency interface{} = this.SafeStringUpper(market, "quoteId")
	if IsTrue(IsEqual(side, "buy")) {
		feeCurrency = this.SafeStringUpper(market, "baseId")
	}
	return this.SafeOrder(map[string]interface{}{
		"id":                 this.SafeString(order, "id"),
		"info":               order,
		"clientOrderId":      this.SafeString(order, "client_order_id"),
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"status":             this.ParseOrderStatus(this.SafeString(order, "state")),
		"symbol":             this.SafeString(market, "symbol"),
		"type":               this.SafeString(order, "type"),
		"timeInForce":        this.SafeString(order, "time_in_force"),
		"postOnly":           this.SafeBool(order, "post_only"),
		"reduceOnly":         nil,
		"side":               side,
		"price":              this.ParseNumber(price),
		"triggerPrice":       this.SafeNumber(order, "stop_price"),
		"takeProfitPrice":    nil,
		"stopLossPrice":      nil,
		"cost":               this.ParseNumber(cost),
		"average":            this.SafeNumber(order, "price_avg"),
		"amount":             this.ParseNumber(amount),
		"filled":             this.ParseNumber(filled),
		"remaining":          this.ParseNumber(remaining),
		"trades":             nil,
		"fee": map[string]interface{}{
			"currency": feeCurrency,
			"cost":     this.SafeNumber(order, "fee_paid"),
		},
	})
}
func (this *FoxbitCore) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var network interface{} = this.SafeDict(depositAddress, "network")
	var networkId interface{} = this.SafeString(network, "code")
	var currencyCode interface{} = this.SafeCurrencyCode(nil, currency)
	var unifiedNetwork interface{} = this.NetworkIdToCode(networkId, currencyCode)
	return map[string]interface{}{
		"address":  this.SafeString(depositAddress, "address"),
		"tag":      this.SafeString(depositAddress, "tag"),
		"currency": currencyCode,
		"network":  unifiedNetwork,
		"info":     depositAddress,
	}
}
func (this *FoxbitCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"SUBMITTING": "pending",
		"SUBMITTED":  "pending",
		"REJECTED":   "failed",
		"CANCELLED":  "canceled",
		"ACCEPTED":   "ok",
		"WARNING":    "pending",
		"UNBLOCKED":  "pending",
		"BLOCKED":    "pending",
		"PROCESSING": "pending",
		"CANCELED":   "canceled",
		"FAILED":     "failed",
		"DONE":       "ok",
	}
	return this.SafeString(statuses, status, status)
}
func (this *FoxbitCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	since := GetArg(optionalArgs, 1, nil)
	_ = since
	limit := GetArg(optionalArgs, 2, nil)
	_ = limit
	var cryptoDetails interface{} = this.SafeDict(transaction, "details_crypto")
	var address interface{} = this.SafeString2(cryptoDetails, "receiving_address", "destination_address")
	var sn interface{} = this.SafeString(transaction, "sn")
	var typeVar interface{} = "withdrawal"
	if IsTrue(IsTrue(!IsEqual(sn, nil)) && IsTrue(IsEqual(GetValue(sn, 0), "D"))) {
		typeVar = "deposit"
	}
	var fee interface{} = this.SafeString(transaction, "fee", "0")
	var amount interface{} = this.SafeString(transaction, "amount")
	var currencySymbol interface{} = this.SafeString(transaction, "currency_symbol")
	var actualAmount interface{} = amount
	var currencyCode interface{} = this.SafeCurrencyCode(currencySymbol)
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
	var created_at interface{} = this.SafeString(transaction, "created_at")
	var timestamp interface{} = this.ParseDate(created_at)
	var datetime interface{} = this.Iso8601(timestamp)
	if IsTrue(IsTrue(!IsEqual(fee, nil)) && IsTrue(!IsEqual(amount, nil))) {
		// actualAmount = amount - fee;
		actualAmount = Precise.StringSub(amount, fee)
	}
	var feeRate interface{} = Precise.StringDiv(fee, actualAmount)
	var feeObj interface{} = map[string]interface{}{
		"cost":     this.ParseNumber(fee),
		"currency": currencyCode,
		"rate":     this.ParseNumber(feeRate),
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString(transaction, "sn"),
		"txid":        this.SafeString(cryptoDetails, "transaction_id"),
		"timestamp":   timestamp,
		"datetime":    datetime,
		"network":     this.SafeString(transaction, "network_code"),
		"address":     address,
		"addressTo":   address,
		"addressFrom": nil,
		"tag":         this.SafeString(transaction, "destination_tag"),
		"tagTo":       this.SafeString(transaction, "destination_tag"),
		"tagFrom":     nil,
		"type":        typeVar,
		"amount":      this.ParseNumber(amount),
		"currency":    currencyCode,
		"status":      status,
		"updated":     nil,
		"fee":         feeObj,
		"comment":     nil,
		"internal":    nil,
	}
}
func (this *FoxbitCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"DEPOSITING":           "transaction",
		"WITHDRAWING":          "transaction",
		"TRADING":              "trade",
		"INTERNAL_TRANSFERING": "transfer",
		"OTHERS":               "transaction",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *FoxbitCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	// {
	//     "uuid": "f8e9f2d6-3c1e-4f2d-8f8e-9f2d6c1e4f2d",
	//     "amount": "0.0001",
	//     "balance": "0.0002",
	//     "created_at": "2021-07-01T12:00:00Z",
	//     "currency_symbol": "btc",
	//     "fee": "0.0001",
	//     "locked": "0.0001",
	//     "locked_amount": "0.0001",
	//     "reason_type": "DEPOSITING"
	// }
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(item, "uuid")
	var createdAt interface{} = this.SafeString(item, "created_at")
	var timestamp interface{} = this.Parse8601(createdAt)
	var reasonType interface{} = this.SafeString(item, "reason_type")
	var typeVar interface{} = this.ParseLedgerEntryType(reasonType)
	var exchangeSymbol interface{} = this.SafeString(item, "currency_symbol")
	var currencySymbol interface{} = this.SafeCurrencyCode(exchangeSymbol)
	var direction interface{} = "in"
	var amount interface{} = this.SafeNumber(item, "amount")
	var realAmount interface{} = amount
	var balance interface{} = this.SafeNumber(item, "balance")
	var fee interface{} = map[string]interface{}{
		"cost":     this.SafeNumber(item, "fee"),
		"currency": currencySymbol,
	}
	if IsTrue(IsLessThan(amount, 0)) {
		direction = "out"
		realAmount = Multiply(amount, OpNeg(1))
	}
	return map[string]interface{}{
		"id":               id,
		"info":             item,
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"direction":        direction,
		"account":          nil,
		"referenceId":      nil,
		"referenceAccount": nil,
		"type":             typeVar,
		"currency":         currencySymbol,
		"amount":           realAmount,
		"before":           Subtract(balance, amount),
		"after":            balance,
		"status":           "ok",
		"fee":              fee,
	}
}
func (this *FoxbitCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, []interface{}{})
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var version interface{} = GetValue(api, 0)
	var urlPath interface{} = GetValue(api, 1)
	var fullPath interface{} = Add(Add(Add("/rest/", version), "/"), this.ImplodeParams(path, params))
	if IsTrue(IsEqual(version, "status")) {
		fullPath = "/status"
		urlPath = "status"
	}
	var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), urlPath), fullPath)
	params = this.Omit(params, this.ExtractParams(path))
	var timestamp interface{} = this.Milliseconds()
	var query interface{} = ""
	var signatureQuery interface{} = ""
	if IsTrue(IsEqual(method, "GET")) {
		var paramKeys interface{} = ObjectKeys(params)
		var paramKeysLength interface{} = GetArrayLength(paramKeys)
		if IsTrue(IsGreaterThan(paramKeysLength, 0)) {
			query = this.Urlencode(params)
			url = Add(url, Add("?", query))
		}
		for i := 0; IsLessThan(i, GetArrayLength(paramKeys)); i++ {
			var key interface{} = GetValue(paramKeys, i)
			var value interface{} = this.SafeString(params, key)
			if IsTrue(!IsEqual(value, nil)) {
				signatureQuery = Add(signatureQuery, Add(Add(key, "="), value))
			}
			if IsTrue(IsLessThan(i, Subtract(paramKeysLength, 1))) {
				signatureQuery = Add(signatureQuery, "&")
			}
		}
	}
	if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) {
		body = this.Json(params)
	}
	var bodyToSignature interface{} = ""
	if IsTrue(!IsEqual(body, nil)) {
		bodyToSignature = body
	}
	headers = map[string]interface{}{
		"Content-Type": "application/json",
	}
	if IsTrue(IsEqual(urlPath, "private")) {
		this.CheckRequiredCredentials()
		var preHash interface{} = Add(Add(Add(Add(this.NumberToString(timestamp), method), fullPath), signatureQuery), bodyToSignature)
		var signature interface{} = this.Hmac(this.Encode(preHash), this.Encode(this.Secret), sha256, "hex")
		AddElementToObject(headers, "X-FB-ACCESS-KEY", this.ApiKey)
		AddElementToObject(headers, "X-FB-ACCESS-TIMESTAMP", this.NumberToString(timestamp))
		AddElementToObject(headers, "X-FB-ACCESS-SIGNATURE", signature)
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *FoxbitCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	var error interface{} = this.SafeDict(response, "error")
	var code interface{} = this.SafeString(error, "code")
	var details interface{} = this.SafeList(error, "details")
	var message interface{} = this.SafeString(error, "message")
	var detailsString interface{} = ""
	if IsTrue(details) {
		for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
			detailsString = Add(Add(detailsString, GetValue(details, i)), " ")
		}
	}
	if IsTrue(!IsEqual(error, nil)) {
		var feedback interface{} = Add(Add(Add(Add(this.Id, " "), message), " details: "), detailsString)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), detailsString, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *FoxbitCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
