package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type foxbit struct {
    Exchange

}

func NewFoxbitCore() *foxbit {
    p := &foxbit{}
    setDefaults(p)
    return p
}

func  (this *foxbit) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "foxbit",
        "name": "Foxbit",
        "countries": []interface{}{"pt-BR"},
        "rateLimit": 33.334,
        "version": "1",
        "comment": "Foxbit Exchange",
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": nil,
            "swap": nil,
            "future": nil,
            "option": nil,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createLimitBuyOrder": true,
            "createLimitSellOrder": true,
            "createMarketBuyOrder": true,
            "createMarketSellOrder": true,
            "createOrder": true,
            "fecthOrderBook": true,
            "fetchBalance": true,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDeposits": true,
            "fetchL2OrderBook": true,
            "fetchLedger": true,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrders": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactions": true,
            "fetchWithdrawals": true,
            "loadMarkets": true,
            "sandbox": false,
            "withdraw": true,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1d",
            "1w": "1w",
            "2w": "2w",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/1f8faca2-ae2f-4222-b33e-5671e7d873dd",
            "api": map[string]interface{} {
                "public": "https://api.foxbit.com.br",
                "private": "https://api.foxbit.com.br",
                "status": "https://metadata-v2.foxbit.com.br/api",
            },
            "www": "https://app.foxbit.com.br",
            "doc": []interface{}{"https://docs.foxbit.com.br"},
        },
        "precisionMode": DECIMAL_PLACES,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400": BadRequest,
                "429": RateLimitExceeded,
                "404": BadRequest,
                "500": ExchangeError,
                "2001": AuthenticationError,
                "2002": AuthenticationError,
                "2003": AuthenticationError,
                "2004": BadRequest,
                "2005": PermissionDenied,
                "3001": PermissionDenied,
                "3002": PermissionDenied,
                "3003": AccountSuspended,
                "4001": BadRequest,
                "4002": InsufficientFunds,
                "4003": InvalidOrder,
                "4004": BadSymbol,
                "4005": BadRequest,
                "4007": ExchangeError,
                "4008": InvalidOrder,
                "4009": PermissionDenied,
                "4011": RateLimitExceeded,
                "4012": ExchangeError,
                "5001": ExchangeNotAvailable,
                "5002": OnMaintenance,
                "5003": OnMaintenance,
                "5004": InvalidOrder,
                "5005": InvalidOrder,
                "5006": InvalidOrder,
            },
            "broad": map[string]interface{} {},
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "api": map[string]interface{} {
            "v3": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "currencies": 5,
                        "markets": 5,
                        "markets/ticker/24hr": 60,
                        "markets/{market}/orderbook": 6,
                        "markets/{market}/candlesticks": 12,
                        "markets/{market}/trades/history": 12,
                        "markets/{market}/ticker/24hr": 15,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "accounts": 2,
                        "accounts/{symbol}/transactions": 60,
                        "orders": 2,
                        "orders/by-order-id/{id}": 2,
                        "trades": 6,
                        "deposits/address": 10,
                        "deposits": 10,
                        "withdrawals": 10,
                        "me/fees/trading": 60,
                    },
                    "post": map[string]interface{} {
                        "orders": 2,
                        "orders/batch": 7.5,
                        "orders/cancel-replace": 3,
                        "withdrawals": 10,
                    },
                    "put": map[string]interface{} {
                        "orders/cancel": 2,
                    },
                },
            },
            "status": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "status": 30,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.005"),
                "maker": this.ParseNumber("0.0025"),
            },
        },
        "options": map[string]interface{} {
            "sandboxMode": false,
            "networksById": map[string]interface{} {
                "algorand": "ALGO",
                "arbitrum": "ARBITRUM",
                "avalanchecchain": "AVAX",
                "bitcoin": "BTC",
                "bitcoincash": "BCH",
                "bsc": "BEP20",
                "cardano": "ADA",
                "cosmos": "ATOM",
                "dogecoin": "DOGE",
                "erc20": "ETH",
                "hedera": "HBAR",
                "litecoin": "LTC",
                "near": "NEAR",
                "optimism": "OPTIMISM",
                "polkadot": "DOT",
                "polygon": "MATIC",
                "ripple": "XRP",
                "solana": "SOL",
                "stacks": "STX",
                "stellar": "XLM",
                "tezos": "XTZ",
                "trc20": "TRC20",
            },
            "networks": map[string]interface{} {
                "ALGO": "algorand",
                "ARBITRUM": "arbitrum",
                "AVAX": "avalanchecchain",
                "BTC": "bitcoin",
                "BCH": "bitcoincash",
                "BEP20": "bsc",
                "ADA": "cardano",
                "ATOM": "cosmos",
                "DOGE": "dogecoin",
                "ETH": "erc20",
                "HBAR": "hedera",
                "LTC": "litecoin",
                "NEAR": "near",
                "OPTIMISM": "optimism",
                "DOT": "polkadot",
                "MATIC": "polygon",
                "XRP": "ripple",
                "SOL": "solana",
                "STX": "stacks",
                "XLM": "stellar",
                "XTZ": "tezos",
                "TRC20": "trc20",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": false,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "GTC": true,
                        "FOK": true,
                        "IOC": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": map[string]interface{} {
                        "expire_maker": true,
                        "expire_taker": true,
                        "expire_both": true,
                        "none": true,
                    },
                    "trailing": false,
                    "icebergAmount": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 5,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 90,
                    "untilDays": 10000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1,
                    "daysBack": 90,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 90,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 90,
                    "untilDays": 10000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 90,
                    "daysBackCanceled": 90,
                    "untilDays": 10000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
        },
    })
}
func  (this *foxbit) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V3PublicGetCurrencies(params))
            PanicOnError(response)
            // {
            //   "data": [
            //     {
            //       "symbol": "btc",
            //       "name": "Bitcoin",
            //       "type": "CRYPTO",
            //       "precision": 8,
            //       "deposit_info": {
            //         "min_to_confirm": "1",
            //         "min_amount": "0.0001"
            //       },
            //       "withdraw_info": {
            //         "enabled": true,
            //         "min_amount": "0.0001",
            //         "fee": "0.0001"
            //       },
            //       "category": {
            //           "code": "cripto",
            //         "name": "Cripto"
            //       },
            //       "networks": [
            //           {
            //               "name": "Bitcoin",
            //               "code": "btc",
            //               "deposit_info": {
            //                  status: "ENABLED",
            //               },
            //               "withdraw_info": {
            //                  "status": "ENABLED",
            //                  "fee": "0.0001",
            //               },
            //               "has_destination_tag": false
            //           }
            //       ]
            //     }
            //   ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var currency interface{} = GetValue(data, i)
                var precision interface{} = this.SafeInteger(currency, "precision")
                var currencyId interface{} = this.SafeString(currency, "symbol")
                var name interface{} = this.SafeString(currency, "name")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var depositInfo interface{} = this.SafeDict(currency, "deposit_info")
                var withdrawInfo interface{} = this.SafeDict(currency, "withdraw_info")
                var networks interface{} = this.SafeList(currency, "networks", []interface{}{})
                var typeVar interface{} = this.SafeStringLower(currency, "type")
                var parsedNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
                    var network interface{} = GetValue(networks, j)
                    var networkId interface{} = this.SafeString(network, "code")
                    var networkCode interface{} = this.NetworkIdToCode(networkId, code)
                    var networkWithdrawInfo interface{} = this.SafeDict(network, "withdraw_info")
                    var networkDepositInfo interface{} = this.SafeDict(network, "deposit_info")
                    var isWithdrawEnabled interface{} = IsEqual(this.SafeString(networkWithdrawInfo, "status"), "ENABLED")
                    var isDepositEnabled interface{} = IsEqual(this.SafeString(networkDepositInfo, "status"), "ENABLED")
                    AddElementToObject(parsedNetworks, networkCode, map[string]interface{} {
            "info": currency,
            "id": networkId,
            "network": networkCode,
            "name": this.SafeString(network, "name"),
            "deposit": isDepositEnabled,
            "withdraw": isWithdrawEnabled,
            "active": true,
            "precision": precision,
            "fee": this.SafeNumber(networkWithdrawInfo, "fee"),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(depositInfo, "min_amount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(withdrawInfo, "min_amount"),
                    "max": nil,
                },
            },
        })
                }
                if IsTrue(IsEqual(this.SafeDict(result, code), nil)) {
                    AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": currencyId,
            "code": code,
            "info": currency,
            "name": name,
            "active": true,
            "type": typeVar,
            "deposit": this.SafeBool(depositInfo, "enabled", false),
            "withdraw": this.SafeBool(withdrawInfo, "enabled", false),
            "fee": this.SafeNumber(withdrawInfo, "fee"),
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(depositInfo, "min_amount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(withdrawInfo, "min_amount"),
                    "max": nil,
                },
            },
            "networks": parsedNetworks,
        }))
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchMarkets
 * @description Retrieves data on all markets for foxbit.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_index
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *foxbit) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V3PublicGetMarkets(params))
            PanicOnError(response)
            // {
            //     "data": [
            //       {
            //         "symbol": "btcbrl",
            //         "quantity_min": "0.00000236",
            //         "quantity_increment": "0.00000001",
            //         "quantity_precision": 8,
            //         "price_min": "0.0001",
            //         "price_increment": "0.0001",
            //         "price_precision": 4,
            //         "default_fees": {
            //           "maker": "0.001",
            //           "taker": "0.001"
            //         },
            //         "base": {
            //           "symbol": "btc",
            //           "name": "Bitcoin",
            //           "type": "CRYPTO",
            //           "precision": 8,
            //           "category": {
            //             "code": "cripto",
            //             "name": "Cripto"
            //           },
            //           "deposit_info": {
            //             "min_to_confirm": "1",
            //             "min_amount": "0.0001",
            //             "enabled": true
            //           },
            //           "withdraw_info": {
            //             "enabled": true,
            //             "min_amount": "0.0001",
            //             "fee": "0.0001"
            //           },
            //           "networks": [
            //             {
            //               "name": "Bitcoin",
            //               "code": "bitcoin",
            //               "deposit_info": {
            //                 "status": "ENABLED"
            //               },
            //               "withdraw_info": {
            //                 "status": "ENABLED",
            //                 "fee": "0.0001"
            //               },
            //               "has_destination_tag": false
            //             }
            //           ],
            //           "default_network_code": "bitcoin"
            //         },
            //         "quote": {
            //           "symbol": "btc",
            //           "name": "Bitcoin",
            //           "type": "CRYPTO",
            //           "precision": 8,
            //           "category": {
            //             "code": "cripto",
            //             "name": "Cripto"
            //           },
            //           "deposit_info": {
            //             "min_to_confirm": "1",
            //             "min_amount": "0.0001",
            //             "enabled": true
            //           },
            //           "withdraw_info": {
            //             "enabled": true,
            //             "min_amount": "0.0001",
            //             "fee": "0.0001"
            //           },
            //           "networks": [
            //             {
            //               "name": "Bitcoin",
            //               "code": "bitcoin",
            //               "deposit_info": {
            //                 "status": "ENABLED"
            //               },
            //               "withdraw_info": {
            //                 "status": "ENABLED",
            //                 "fee": "0.0001"
            //               },
            //               "has_destination_tag": false
            //             }
            //           ],
            //           "default_network_code": "bitcoin"
            //         },
            //         "order_type": [
            //           "LIMIT",
            //           "MARKET",
            //           "INSTANT",
            //           "STOP_LIMIT",
            //           "STOP_MARKET"
            //         ]
            //       }
            //     ]
            //   }
            var markets interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchTicker
 * @description Get last 24 hours ticker information, in real-time, for given market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *foxbit) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5668 := (<-this.LoadMarkets())
            PanicOnError(retRes5668)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.V3PublicGetMarketsMarketTicker24hr(this.Extend(request, params)))
            PanicOnError(response)
            //  {
            //    "data": [
            //      {
            //        "market_symbol": "btcbrl",
            //        "last_trade": {
            //          "price": "358504.69340000",
            //          "volume": "0.00027893",
            //          "date": "2024-01-01T00:00:00.000Z"
            //        },
            //        "rolling_24h": {
            //          "price_change": "3211.87290000",
            //          "price_change_percent": "0.90400726",
            //          "volume": "20.03206866",
            //          "trades_count": "4376",
            //          "open": "355292.82050000",
            //          "high": "362999.99990000",
            //          "low": "355002.88880000"
            //        },
            //        "best": {
            //          "ask": {
            //            "price": "358504.69340000",
            //            "volume": "0.00027893"
            //          },
            //          "bid": {
            //            "price": "358504.69340000",
            //            "volume": "0.00027893"
            //          }
            //        }
            //      }
            //    ]
            //  }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchTickers
 * @description Retrieve the ticker data of all markets.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *foxbit) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6188 := (<-this.LoadMarkets())
            PanicOnError(retRes6188)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V3PublicGetMarketsTicker24hr(params))
            PanicOnError(response)
            //  {
            //    "data": [
            //      {
            //        "market_symbol": "btcbrl",
            //        "last_trade": {
            //          "price": "358504.69340000",
            //          "volume": "0.00027893",
            //          "date": "2024-01-01T00:00:00.000Z"
            //        },
            //        "rolling_24h": {
            //          "price_change": "3211.87290000",
            //          "price_change_percent": "0.90400726",
            //          "volume": "20.03206866",
            //          "trades_count": "4376",
            //          "open": "355292.82050000",
            //          "high": "362999.99990000",
            //          "low": "355002.88880000"
            //        },
            //      }
            //    ]
            //  }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Member-Info/operation/MembersController_listTradingFees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *foxbit) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6558 := (<-this.LoadMarkets())
            PanicOnError(retRes6558)
        
            response:= (<-this.V3PrivateGetMeFeesTrading(params))
            PanicOnError(response)
            // [
            //     {
            //         "market_symbol": "btcbrl",
            //         "maker": "0.0025",
            //         "taker": "0.005"
            //     }
            // ]
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(entry, "market_symbol")
                var market interface{} = this.SafeMarket(marketId)
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, this.ParseTradingFee(entry, market))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchOrderBook
 * @description Exports a copy of the order book of a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findOrderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return, the maximum is 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *foxbit) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6878 := (<-this.LoadMarkets())
            PanicOnError(retRes6878)
            var market interface{} = this.Market(symbol)
            var defaultLimit interface{} = 20
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "depth": Ternary(IsTrue((IsEqual(limit, nil))), defaultLimit, limit),
            }
        
            response:= (<-this.V3PublicGetMarketsMarketOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //  {
            //    "sequence_id": 1234567890,
            //    "timestamp": 1713187921336,
            //    "bids": [
            //      [
            //        "3.00000000",
            //        "300.00000000"
            //      ],
            //      [
            //        "1.70000000",
            //        "310.00000000"
            //      ]
            //    ],
            //    "asks": [
            //      [
            //        "3.00000000",
            //        "300.00000000"
            //      ],
            //      [
            //        "2.00000000",
            //        "321.00000000"
            //      ]
            //    ]
            //  }
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchTrades
 * @description Retrieve the trades of a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_publicTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *foxbit) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7358 := (<-this.LoadMarkets())
            PanicOnError(retRes7358)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 200)) {
                    AddElementToObject(request, "page_size", 200)
                }
            }
            // [
            //     {
            //         "id": 1,
            //         "price": "329248.74700000",
            //         "volume": "0.00100000",
            //         "taker_side": "BUY",
            //         "created_at": "2024-01-01T00:00:00Z"
            //     }
            // ]
        
            response:= (<-this.V3PublicGetMarketsMarketTradesHistory(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchOHLCV
 * @description Fetch historical candlestick data containing the open, high, low, and close price, and the volume of a market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Market-Data/operation/MarketsController_findCandlesticks
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *foxbit) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7738 := (<-this.LoadMarkets())
            PanicOnError(retRes7738)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "interval": interval,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
                if IsTrue(IsGreaterThan(limit, 500)) {
                    AddElementToObject(request, "limit", 500)
                }
            }
        
            response:= (<-this.V3PublicGetMarketsMarketCandlesticks(this.Extend(request, params)))
            PanicOnError(response)
        
                // [
            //     [
            //         "1692918000000", // timestamp
            //         "127772.05150000", // open
            //         "128467.99980000", // high
            //         "127750.01000000", // low
            //         "128353.99990000", // close
            //         "1692918060000", // close timestamp
            //         "0.17080431", // base volume
            //         "21866.35948786", // quote volume
            //         66, // number of trades
            //         "0.12073605", // taker buy base volume
            //         "15466.34096391" // taker buy quote volume
            //     ]
            // ]
        ch <- this.ParseOHLCVs(response, market, interval, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchBalance
 * @description Query for balance and get the amount of funds available for trading or funds locked in orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_all
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *foxbit) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8178 := (<-this.LoadMarkets())
            PanicOnError(retRes8178)
        
            response:= (<-this.V3PrivateGetAccounts(params))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //         "currency_symbol": "btc",
            //         "balance": "10000.0",
            //         "balance_available": "9000.0",
            //         "balance_locked": "1000.0"
            //         }
            //     ]
            // }
            var accounts interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {
                "info": response,
            }
            for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
                var account interface{} = GetValue(accounts, i)
                var currencyId interface{} = this.SafeString(account, "currency_symbol")
                var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
                var total interface{} = this.SafeString(account, "balance")
                var used interface{} = this.SafeString(account, "balance_locked")
                var free interface{} = this.SafeString(account, "balance_available")
                var balanceObj interface{} = map[string]interface{} {
                    "free": free,
                    "used": used,
                    "total": total,
                }
                AddElementToObject(result, currencyCode, balanceObj)
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchOpenOrders
 * @description Fetch all unfilled currently open orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes86215 :=  (<-this.FetchOrdersByStatus("ACTIVE", symbol, since, limit, params))
                PanicOnError(retRes86215)
                ch <- retRes86215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchClosedOrders
 * @description Fetch all currently closed orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes87715 :=  (<-this.FetchOrdersByStatus("FILLED", symbol, since, limit, params))
                PanicOnError(retRes87715)
                ch <- retRes87715
                return nil
        
            }()
            return ch
        }
func  (this *foxbit) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes88115 :=  (<-this.FetchOrdersByStatus("CANCELED", symbol, since, limit, params))
                PanicOnError(retRes88115)
                ch <- retRes88115
                return nil
        
            }()
            return ch
        }
func  (this *foxbit) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8858 := (<-this.LoadMarkets())
            PanicOnError(retRes8858)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "state": status,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market_symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
        
            response:= (<-this.V3PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#createOrder
 * @description Create an order with the specified characteristics
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_create
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit', 'stop_market', 'stop_limit', 'instant'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "FOK", "IOC", "PO"
 * @param {float} [params.triggerPrice] The time in force for the order. One of GTC, FOK, IOC, PO. See .features or foxbit's doc to see more details.
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {string} [params.clientOrderId] a unique identifier for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9268 := (<-this.LoadMarkets())
            PanicOnError(retRes9268)
            var market interface{} = this.Market(symbol)
            typeVar = ToUpper(typeVar)
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_LIMIT"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
                panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: limit, market, stop_market, stop_limit, instant.")))
            }
            var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            var triggerPrice interface{} = this.SafeNumber(params, "triggerPrice")
            var request interface{} = map[string]interface{} {
                "market_symbol": GetValue(market, "id"),
                "side": ToUpper(side),
                "type": typeVar,
            }
            if IsTrue(IsTrue(IsEqual(typeVar, "STOP_MARKET")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
                if IsTrue(IsEqual(triggerPrice, nil)) {
                    panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must have triggerPrice.")))
                }
            }
            if IsTrue(!IsEqual(timeInForce, nil)) {
                if IsTrue(IsEqual(timeInForce, "PO")) {
                    AddElementToObject(request, "post_only", true)
                } else {
                    AddElementToObject(request, "time_in_force", timeInForce)
                }
            }
            if IsTrue(postOnly) {
                AddElementToObject(request, "post_only", true)
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
            }
            if IsTrue(IsEqual(typeVar, "INSTANT")) {
                AddElementToObject(request, "amount", this.PriceToPrecision(symbol, amount))
            } else {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            }
            params = this.Omit(params, []interface{}{"timeInForce", "postOnly", "triggerPrice", "clientOrderId"})
        
            response:= (<-this.V3PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "id": 1234567890,
            //     "sn": "OKMAKSDHRVVREK",
            //     "client_order_id": "451637946501"
            // }
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#createOrders
 * @description create a list of trade orders
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/createBatch
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9908 := (<-this.LoadMarkets())
            PanicOnError(retRes9908)
            var ordersRequests interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var order interface{} = this.SafeDict(orders, i)
                var symbol interface{} = this.SafeString(order, "symbol")
                var market interface{} = this.Market(symbol)
                var typeVar interface{} = this.SafeStringUpper(order, "type")
                var orderParams interface{} = this.SafeDict(order, "params", map[string]interface{} {})
                if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_LIMIT"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
                    panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: limit, market, stop_market, stop_limit, instant.")))
                }
                var timeInForce interface{} = this.SafeStringUpper(orderParams, "timeInForce")
                var postOnly interface{} = this.SafeBool(orderParams, "postOnly", false)
                var triggerPrice interface{} = this.SafeNumber(orderParams, "triggerPrice")
                var request interface{} = map[string]interface{} {
                    "market_symbol": GetValue(market, "id"),
                    "side": this.SafeStringUpper(order, "side"),
                    "type": typeVar,
                }
                if IsTrue(IsTrue(IsEqual(typeVar, "STOP_MARKET")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
                    if IsTrue(IsEqual(triggerPrice, nil)) {
                        panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must have triggerPrice.")))
                    }
                }
                if IsTrue(!IsEqual(timeInForce, nil)) {
                    if IsTrue(IsEqual(timeInForce, "PO")) {
                        AddElementToObject(request, "post_only", true)
                    } else {
                        AddElementToObject(request, "time_in_force", timeInForce)
                    }
                    Remove(orderParams, "timeInForce")
                }
                if IsTrue(postOnly) {
                    AddElementToObject(request, "post_only", true)
                    Remove(orderParams, "postOnly")
                }
                if IsTrue(!IsEqual(triggerPrice, nil)) {
                    AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
                    Remove(orderParams, "triggerPrice")
                }
                if IsTrue(IsEqual(typeVar, "INSTANT")) {
                    AddElementToObject(request, "amount", this.PriceToPrecision(symbol, this.SafeString(order, "amount")))
                } else {
                    AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, this.SafeString(order, "amount")))
                }
                if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "STOP_LIMIT"))) {
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, this.SafeString(order, "price")))
                }
                AppendToArray(&ordersRequests, this.Extend(request, orderParams))
            }
            var createOrdersRequest interface{} = map[string]interface{} {
                "data": ordersRequests,
            }
        
            response:= (<-this.V3PrivatePostOrdersBatch(this.Extend(createOrdersRequest, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //         "side": "BUY",
            //         "type": "LIMIT",
            //         "market_symbol": "btcbrl",
            //         "client_order_id": "451637946501",
            //         "remark": "A remarkable note for the order.",
            //         "quantity": "0.42",
            //         "price": "250000.0",
            //         "post_only": true,
            //         "time_in_force": "GTC"
            //         }
            //     ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#cancelOrder
 * @description Cancel open orders.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10728 := (<-this.LoadMarkets())
            PanicOnError(retRes10728)
            var request interface{} = map[string]interface{} {
                "id": this.ParseNumber(id),
                "type": "ID",
            }
        
            response:= (<-this.V3PrivatePutOrdersCancel(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //         "sn": "OKMAKSDHRVVREK",
            //         "id": 123456789
            //         }
            //     ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#cancelAllOrders
 * @description Cancel all open orders or all open orders for a specific market.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancel
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11018 := (<-this.LoadMarkets())
            PanicOnError(retRes11018)
            var request interface{} = map[string]interface{} {
                "type": "ALL",
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "type", "MARKET")
                AddElementToObject(request, "market_symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.V3PrivatePutOrdersCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "data": [
            //         {
            //           "sn": "OKMAKSDHRVVREK",
            //           "id": 123456789
            //         }
            //     ]
            // }
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchOrder
 * @description Get an order by ID.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_findByOrderId
 * @param id
 * @param {string} symbol it is not used in the foxbit API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11358 := (<-this.LoadMarkets())
            PanicOnError(retRes11358)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.V3PrivateGetOrdersByOrderIdId(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "id": "1234567890",
            //     "sn": "OKMAKSDHRVVREK",
            //     "client_order_id": "451637946501",
            //     "market_symbol": "btcbrl",
            //     "side": "BUY",
            //     "type": "LIMIT",
            //     "state": "ACTIVE",
            //     "price": "290000.0",
            //     "price_avg": "295333.3333",
            //     "quantity": "0.42",
            //     "quantity_executed": "0.41",
            //     "instant_amount": "290.0",
            //     "instant_amount_executed": "290.0",
            //     "created_at": "2021-02-15T22:06:32.999Z",
            //     "trades_count": "2",
            //     "remark": "A remarkable note for the order.",
            //     "funds_received": "290.0"
            // }
        ch <- this.ParseOrder(response, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.state] Enum: ACTIVE, CANCELED, FILLED, PARTIALLY_CANCELED, PARTIALLY_FILLED
 * @param {string} [params.side] Enum: BUY, SELL
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11768 := (<-this.LoadMarkets())
            PanicOnError(retRes11768)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market_symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
        
            response:= (<-this.V3PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //         "id": "1234567890",
            //         "sn": "OKMAKSDHRVVREK",
            //         "client_order_id": "451637946501",
            //         "market_symbol": "btcbrl",
            //         "side": "BUY",
            //         "type": "LIMIT",
            //         "state": "ACTIVE",
            //         "price": "290000.0",
            //         "price_avg": "295333.3333",
            //         "quantity": "0.42",
            //         "quantity_executed": "0.41",
            //         "instant_amount": "290.0",
            //         "instant_amount_executed": "290.0",
            //         "created_at": "2021-02-15T22:06:32.999Z",
            //         "trades_count": "2",
            //         "remark": "A remarkable note for the order.",
            //         "funds_received": "290.0"
            //         }
            //     ]
            // }
            var list interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(list, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchMyTrades
 * @description Trade history queries will only have data available for the last 3 months, in descending order (most recents trades first).
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/TradesController_all
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *foxbit) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes12358 := (<-this.LoadMarkets())
            PanicOnError(retRes12358)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
        
            response:= (<-this.V3PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         "id": 1234567890,
            //         "sn": "TC5JZVW2LLJ3IW",
            //         "order_id": 1234567890,
            //         "market_symbol": "btcbrl",
            //         "side": "BUY",
            //         "price": "290000.0",
            //         "quantity": "1.0",
            //         "fee": "0.01",
            //         "fee_currency_symbol": "btc",
            //         "created_at": "2021-02-15T22:06:32.999Z"
            //     ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchDepositAddress
 * @description Fetch the deposit address for a currency associated with this account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_depositAddress
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.networkCode] the blockchain network to create a deposit address on
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *foxbit) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12798 := (<-this.LoadMarkets())
            PanicOnError(retRes12798)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency_symbol": GetValue(currency, "id"),
            }
            networkCodeparamsOmitedVariable := this.HandleNetworkCodeAndParams(params);
            networkCode := GetValue(networkCodeparamsOmitedVariable,0);
            paramsOmited := GetValue(networkCodeparamsOmitedVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "network_code", this.NetworkCodeToId(networkCode, code))
            }
        
            response:= (<-this.V3PrivateGetDepositsAddress(this.Extend(request, paramsOmited)))
            PanicOnError(response)
        
                // {
            //     "currency_symbol": "btc",
            //     "address": "2N9sS8LgrY19rvcCWDmE1ou1tTVmqk4KQAB",
            //     "message": "Address was retrieved successfully",
            //     "destination_tag": "string",
            //     "network": {
            //         "name": "Bitcoin Network",
            //         "code": "btc"
            //     }
            // }
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchDeposits
 * @description Fetch all deposits made to an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposit structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *foxbit) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13148 := (<-this.LoadMarkets())
            PanicOnError(retRes13148)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
        
            response:= (<-this.V3PrivateGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //             "sn": "OKMAKSDHRVVREK",
            //             "state": "ACCEPTED",
            //             "currency_symbol": "btc",
            //             "amount": "1.0",
            //             "fee": "0.1",
            //             "created_at": "2022-02-18T22:06:32.999Z",
            //             "details_crypto": {
            //                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
            //                 "receiving_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
            //             }
            //         }
            //     ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchWithdrawals
 * @description Fetch all withdrawals made from an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *foxbit) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13628 := (<-this.LoadMarkets())
            PanicOnError(retRes13628)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
        
            response:= (<-this.V3PrivateGetWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //             "sn": "OKMAKSDHRVVREK",
            //             "state": "ACCEPTED",
            //             "rejection_reason": "monthly_limit_exceeded",
            //             "currency_symbol": "btc",
            //             "amount": "1.0",
            //             "fee": "0.1",
            //             "created_at": "2022-02-18T22:06:32.999Z",
            //             "details_crypto": {
            //                 "transaction_id": "e20f035387020c5d5ea18ad53244f09f3",
            //                 "destination_address": "2N2rTrnKEFcyJjEJqvVjgWZ3bKvKT7Aij61"
            //             },
            //             "details_fiat": {
            //                 "bank": {
            //                     "code": "1",
            //                     "branch": {
            //                         "number": "1234567890",
            //                         "digit": "1"
            //                     },
            //                     "account": {
            //                         "number": "1234567890",
            //                         "digit": "1",
            //                         "type": "CHECK"
            //                     }
            //                 }
            //             }
            //         }
            //     ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchTransactions
 * @description Fetch all transactions (deposits and withdrawals) made from an account.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_listWithdrawals
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Deposit/operation/DepositsController_listOrders
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *foxbit) FetchTransactions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            withdrawals:= (<-this.FetchWithdrawals(code, since, limit, params))
            PanicOnError(withdrawals)
        
            deposits:= (<-this.FetchDeposits(code, since, limit, params))
            PanicOnError(deposits)
            var allTransactions interface{} = this.ArrayConcat(withdrawals, deposits)
            var result interface{} = this.SortBy(allTransactions, "timestamp")
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchStatus
 * @description The latest known information on the availability of the exchange API.
 * @see https://status.foxbit.com/
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *foxbit) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.StatusPublicGetStatus(params))
            PanicOnError(response)
            // {
            //     "data": {
            //       "id": 1,
            //       "attributes": {
            //         "status": "NORMAL",
            //         "createdAt": "2023-05-17T18:37:05.934Z",
            //         "updatedAt": "2024-04-17T02:33:50.945Z",
            //         "publishedAt": "2023-05-17T18:37:07.653Z",
            //         "locale": "pt-BR"
            //       }
            //     },
            //     "meta": {
            //     }
            // }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var attributes interface{} = this.SafeDict(data, "attributes", map[string]interface{} {})
            var statusRaw interface{} = this.SafeString(attributes, "status")
            var statusMap interface{} = map[string]interface{} {
                "NORMAL": "ok",
                "UNDER_MAINTENANCE": "maintenance",
            }
        
            ch <- map[string]interface{} {
                "status": this.SafeString(statusMap, statusRaw, statusRaw),
                "updated": this.SafeString(attributes, "updatedAt"),
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#editOrder
 * @description Simultaneously cancel an existing order and create a new one.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Trading/operation/OrdersController_cancelReplace
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders, used as stop_price on stop market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *foxbit) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires a symbol argument")))
            }
            typeVar = ToUpper(typeVar)
            if IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(typeVar, "LIMIT")) && IsTrue(!IsEqual(typeVar, "MARKET"))) && IsTrue(!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue(!IsEqual(typeVar, "INSTANT"))) {
                panic(InvalidOrder(Add(Add("Invalid order type: ", typeVar), ". Must be one of: LIMIT, MARKET, STOP_MARKET, INSTANT.")))
            }
        
            retRes14958 := (<-this.LoadMarkets())
            PanicOnError(retRes14958)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "mode": "ALLOW_FAILURE",
                "cancel": map[string]interface{} {
                    "type": "ID",
                    "id": this.ParseNumber(id),
                },
                "create": map[string]interface{} {
                    "type": typeVar,
                    "side": ToUpper(side),
                    "market_symbol": GetValue(market, "id"),
                },
            }
            if IsTrue(IsTrue(IsEqual(typeVar, "LIMIT")) || IsTrue(IsEqual(typeVar, "MARKET"))) {
                AddElementToObject(GetValue(request, "create"), "quantity", this.AmountToPrecision(symbol, amount))
                if IsTrue(IsEqual(typeVar, "LIMIT")) {
                    AddElementToObject(GetValue(request, "create"), "price", this.PriceToPrecision(symbol, price))
                }
            }
            if IsTrue(IsEqual(typeVar, "STOP_MARKET")) {
                AddElementToObject(GetValue(request, "create"), "stop_price", this.PriceToPrecision(symbol, price))
                AddElementToObject(GetValue(request, "create"), "quantity", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(IsEqual(typeVar, "INSTANT")) {
                AddElementToObject(GetValue(request, "create"), "amount", this.PriceToPrecision(symbol, amount))
            }
        
            response:= (<-this.V3PrivatePostOrdersCancelReplace(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "cancel": {
            //         "id": 123456789
            //     },
            //     "create": {
            //         "id": 1234567890,
            //         "client_order_id": "451637946501"
            //     }
            // }
        ch <- this.ParseOrder(GetValue(response, "create"), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#withdraw
 * @description Make a withdrawal.
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Withdrawal/operation/WithdrawalsController_createWithdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *foxbit) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes15498 := (<-this.LoadMarkets())
            PanicOnError(retRes15498)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency_symbol": GetValue(currency, "id"),
                "amount": this.NumberToString(amount),
                "destination_address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "destination_tag", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "network_code", this.NetworkCodeToId(networkCode))
            }
        
            response:= (<-this.V3PrivatePostWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "amount": "1",
            //     "currency_symbol": "xrp",
            //     "network_code": "ripple",
            //     "destination_address": "0x1234567890123456789012345678",
            //     "destination_tag": "123456"
            // }
        ch <- this.ParseTransaction(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name foxbit#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://docs.foxbit.com.br/rest/v3/#tag/Account/operation/AccountsController_getTransactions
 * @param {string} code unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entrys to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
 */
func  (this *foxbit) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15878 := (<-this.LoadMarkets())
            PanicOnError(retRes15878)
            var request interface{} = map[string]interface{} {}
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchLedger() requires a code argument")))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
                if IsTrue(IsGreaterThan(limit, 100)) {
                    AddElementToObject(request, "page_size", 100)
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            var currency interface{} = this.Currency(code)
            AddElementToObject(request, "symbol", GetValue(currency, "id"))
        
            response:= (<-this.V3PrivateGetAccountsSymbolTransactions(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseLedger(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *foxbit) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseAssets interface{} = this.SafeDict(market, "base")
    var baseId interface{} = this.SafeString(baseAssets, "symbol")
    var quoteAssets interface{} = this.SafeDict(market, "quote")
    var quoteId interface{} = this.SafeString(quoteAssets, "symbol")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    var fees interface{} = this.SafeDict(market, "default_fees")
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "baseId": baseId,
        "quoteId": quoteId,
        "active": true,
        "type": "spot",
        "spot": true,
        "margin": false,
        "future": false,
        "swap": false,
        "option": false,
        "contract": false,
        "settle": nil,
        "settleId": nil,
        "contractSize": nil,
        "linear": nil,
        "inverse": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "taker": this.SafeNumber(fees, "taker"),
        "maker": this.SafeNumber(fees, "maker"),
        "percentage": true,
        "tierBased": false,
        "feeSide": "get",
        "precision": map[string]interface{} {
            "price": this.SafeInteger(quoteAssets, "precision"),
            "amount": this.SafeInteger(baseAssets, "precision"),
            "cost": this.SafeInteger(quoteAssets, "precision"),
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "quantity_min"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "price_min"),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "info": market,
    })
}
func  (this *foxbit) ParseTradingFee(entry interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return map[string]interface{} {
        "info": entry,
        "symbol": GetValue(market, "symbol"),
        "maker": this.SafeNumber(entry, "maker"),
        "taker": this.SafeNumber(entry, "taker"),
        "percentage": true,
        "tierBased": true,
    }
}
func  (this *foxbit) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "market_symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "spot")
    var rolling_24h interface{} = GetValue(ticker, "rolling_24h")
    var best interface{} = this.SafeDict(ticker, "best")
    var bestAsk interface{} = this.SafeDict(best, "ask")
    var bestBid interface{} = this.SafeDict(best, "bid")
    var lastTrade interface{} = GetValue(ticker, "last_trade")
    var lastPrice interface{} = this.SafeString(lastTrade, "price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": this.ParseDate(this.SafeString(lastTrade, "date")),
        "datetime": this.Iso8601(this.ParseDate(this.SafeString(lastTrade, "date"))),
        "high": this.SafeNumber(rolling_24h, "high"),
        "low": this.SafeNumber(rolling_24h, "low"),
        "bid": this.SafeNumber(bestBid, "price"),
        "bidVolume": this.SafeNumber(bestBid, "volume"),
        "ask": this.SafeNumber(bestAsk, "price"),
        "askVolume": this.SafeNumber(bestAsk, "volume"),
        "vwap": nil,
        "open": this.SafeNumber(rolling_24h, "open"),
        "close": lastPrice,
        "last": lastPrice,
        "previousClose": nil,
        "change": this.SafeString(rolling_24h, "price_change"),
        "percentage": this.SafeString(rolling_24h, "price_change_percent"),
        "average": nil,
        "baseVolume": this.SafeString(rolling_24h, "volume"),
        "quoteVolume": this.SafeString(rolling_24h, "quote_volume"),
        "info": ticker,
    }, market)
}
func  (this *foxbit) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 6)}
}
func  (this *foxbit) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.ParseDate(this.SafeString(trade, "created_at"))
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "volume", this.SafeString(trade, "quantity"))
    var privateSideField interface{} = this.SafeStringLower(trade, "side")
    var side interface{} = this.SafeStringLower(trade, "taker_side", privateSideField)
    var cost interface{} = Precise.StringMul(price, amount)
    var fee interface{} = map[string]interface{} {
        "currency": this.SafeSymbol(this.SafeString(trade, "fee_currency_symbol")),
        "cost": this.SafeNumber(trade, "fee"),
        "rate": nil,
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": nil,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    }, market)
}
func  (this *foxbit) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PARTIALLY_CANCELED": "open",
        "ACTIVE": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "PENDING_CANCEL": "canceled",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *foxbit) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(order, "market_symbol")
    if IsTrue(IsTrue(IsEqual(market, nil)) && IsTrue(!IsEqual(symbol, nil))) {
        market = this.Market(symbol)
    }
    if IsTrue(!IsEqual(market, nil)) {
        symbol = GetValue(market, "symbol")
    }
    var timestamp interface{} = this.ParseDate(this.SafeString(order, "created_at"))
    var price interface{} = this.SafeString(order, "price")
    var filled interface{} = this.SafeString(order, "quantity_executed")
    var remaining interface{} = this.SafeString(order, "quantity")
    // TODO: validate logic of amount here, should this be calculated?
    var amount interface{} = nil
    if IsTrue(IsTrue(!IsEqual(remaining, nil)) && IsTrue(!IsEqual(filled, nil))) {
        amount = Precise.StringAdd(remaining, filled)
    }
    var cost interface{} = this.SafeString(order, "funds_received")
    if !IsTrue(cost) {
        var priceAverage interface{} = this.SafeString(order, "price_avg")
        var priceToCalculate interface{} = this.SafeString(order, "price", priceAverage)
        cost = Precise.StringMul(priceToCalculate, amount)
    }
    var side interface{} = this.SafeStringLower(order, "side")
    var feeCurrency interface{} = this.SafeStringUpper(market, "quoteId")
    if IsTrue(IsEqual(side, "buy")) {
        feeCurrency = this.SafeStringUpper(market, "baseId")
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "id"),
        "info": order,
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": this.ParseOrderStatus(this.SafeString(order, "state")),
        "symbol": this.SafeString(market, "symbol"),
        "type": this.SafeString(order, "type"),
        "timeInForce": this.SafeString(order, "time_in_force"),
        "postOnly": this.SafeBool(order, "post_only"),
        "reduceOnly": nil,
        "side": side,
        "price": this.ParseNumber(price),
        "triggerPrice": this.SafeNumber(order, "stop_price"),
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
        "cost": this.ParseNumber(cost),
        "average": this.SafeNumber(order, "price_avg"),
        "amount": this.ParseNumber(amount),
        "filled": this.ParseNumber(filled),
        "remaining": this.ParseNumber(remaining),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": feeCurrency,
            "cost": this.SafeNumber(order, "fee_paid"),
        },
    })
}
func  (this *foxbit) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var network interface{} = this.SafeDict(depositAddress, "network")
    var networkId interface{} = this.SafeString(network, "code")
    var currencyCode interface{} = this.SafeCurrencyCode(nil, currency)
    var unifiedNetwork interface{} = this.NetworkIdToCode(networkId, currencyCode)
    return map[string]interface{} {
        "address": this.SafeString(depositAddress, "address"),
        "tag": this.SafeString(depositAddress, "tag"),
        "currency": currencyCode,
        "network": unifiedNetwork,
        "info": depositAddress,
    }
}
func  (this *foxbit) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUBMITTING": "pending",
        "SUBMITTED": "pending",
        "REJECTED": "failed",
        "CANCELLED": "canceled",
        "ACCEPTED": "ok",
        "WARNING": "pending",
        "UNBLOCKED": "pending",
        "BLOCKED": "pending",
        "PROCESSING": "pending",
        "CANCELED": "canceled",
        "FAILED": "failed",
        "DONE": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *foxbit) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    var cryptoDetails interface{} = this.SafeDict(transaction, "details_crypto")
    var address interface{} = this.SafeString2(cryptoDetails, "receiving_address", "destination_address")
    var sn interface{} = this.SafeString(transaction, "sn")
    var typeVar interface{} = "withdrawal"
    if IsTrue(IsTrue(!IsEqual(sn, nil)) && IsTrue(IsEqual(GetValue(sn, 0), "D"))) {
        typeVar = "deposit"
    }
    var fee interface{} = this.SafeString(transaction, "fee", "0")
    var amount interface{} = this.SafeString(transaction, "amount")
    var currencySymbol interface{} = this.SafeString(transaction, "currency_symbol")
    var actualAmount interface{} = amount
    var currencyCode interface{} = this.SafeCurrencyCode(currencySymbol)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
    var created_at interface{} = this.SafeString(transaction, "created_at")
    var timestamp interface{} = this.ParseDate(created_at)
    var datetime interface{} = this.Iso8601(timestamp)
    if IsTrue(IsTrue(!IsEqual(fee, nil)) && IsTrue(!IsEqual(amount, nil))) {
        // actualAmount = amount - fee;
        actualAmount = Precise.StringSub(amount, fee)
    }
    var feeRate interface{} = Precise.StringDiv(fee, actualAmount)
    var feeObj interface{} = map[string]interface{} {
        "cost": this.ParseNumber(fee),
        "currency": currencyCode,
        "rate": this.ParseNumber(feeRate),
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "sn"),
        "txid": this.SafeString(cryptoDetails, "transaction_id"),
        "timestamp": timestamp,
        "datetime": datetime,
        "network": this.SafeString(transaction, "network_code"),
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": this.SafeString(transaction, "destination_tag"),
        "tagTo": this.SafeString(transaction, "destination_tag"),
        "tagFrom": nil,
        "type": typeVar,
        "amount": this.ParseNumber(amount),
        "currency": currencyCode,
        "status": status,
        "updated": nil,
        "fee": feeObj,
        "comment": nil,
        "internal": nil,
    }
}
func  (this *foxbit) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "DEPOSITING": "transaction",
        "WITHDRAWING": "transaction",
        "TRADING": "trade",
        "INTERNAL_TRANSFERING": "transfer",
        "OTHERS": "transaction",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *foxbit) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //     "uuid": "f8e9f2d6-3c1e-4f2d-8f8e-9f2d6c1e4f2d",
    //     "amount": "0.0001",
    //     "balance": "0.0002",
    //     "created_at": "2021-07-01T12:00:00Z",
    //     "currency_symbol": "btc",
    //     "fee": "0.0001",
    //     "locked": "0.0001",
    //     "locked_amount": "0.0001",
    //     "reason_type": "DEPOSITING"
    // }
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "uuid")
    var createdAt interface{} = this.SafeString(item, "created_at")
    var timestamp interface{} = this.Parse8601(createdAt)
    var reasonType interface{} = this.SafeString(item, "reason_type")
    var typeVar interface{} = this.ParseLedgerEntryType(reasonType)
    var exchangeSymbol interface{} = this.SafeString(item, "currency_symbol")
    var currencySymbol interface{} = this.SafeCurrencyCode(exchangeSymbol)
    var direction interface{} = "in"
    var amount interface{} = this.SafeNumber(item, "amount")
    var realAmount interface{} = amount
    var balance interface{} = this.SafeNumber(item, "balance")
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeNumber(item, "fee"),
        "currency": currencySymbol,
    }
    if IsTrue(IsLessThan(amount, 0)) {
        direction = "out"
        realAmount = Multiply(amount, OpNeg(1))
    }
    return map[string]interface{} {
        "id": id,
        "info": item,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "direction": direction,
        "account": nil,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": currencySymbol,
        "amount": realAmount,
        "before": Subtract(balance, amount),
        "after": balance,
        "status": "ok",
        "fee": fee,
    }
}
func  (this *foxbit) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(api, 0)
    var urlPath interface{} = GetValue(api, 1)
    var fullPath interface{} = Add(Add(Add("/rest/", version), "/"), this.ImplodeParams(path, params))
    if IsTrue(IsEqual(version, "status")) {
        fullPath = "/status"
        urlPath = "status"
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), urlPath), fullPath)
    params = this.Omit(params, this.ExtractParams(path))
    var timestamp interface{} = this.Milliseconds()
    var query interface{} = ""
    var signatureQuery interface{} = ""
    if IsTrue(IsEqual(method, "GET")) {
        var paramKeys interface{} = ObjectKeys(params)
        var paramKeysLength interface{} =         GetArrayLength(paramKeys)
        if IsTrue(IsGreaterThan(paramKeysLength, 0)) {
            query = this.Urlencode(params)
            url = Add(url, Add("?", query))
        }
        for i := 0; IsLessThan(i, GetArrayLength(paramKeys)); i++ {
            var key interface{} = GetValue(paramKeys, i)
            var value interface{} = this.SafeString(params, key)
            if IsTrue(!IsEqual(value, nil)) {
                signatureQuery = Add(signatureQuery, Add(Add(key, "="), value))
            }
            if IsTrue(IsLessThan(i, Subtract(paramKeysLength, 1))) {
                signatureQuery = Add(signatureQuery, "&")
            }
        }
    }
    if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) {
        body = this.Json(params)
    }
    var bodyToSignature interface{} = ""
    if IsTrue(!IsEqual(body, nil)) {
        bodyToSignature = body
    }
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    if IsTrue(IsEqual(urlPath, "private")) {
        this.CheckRequiredCredentials()
        var preHash interface{} = Add(Add(Add(Add(this.NumberToString(timestamp), method), fullPath), signatureQuery), bodyToSignature)
        var signature interface{} = this.Hmac(this.Encode(preHash), this.Encode(this.Secret), sha256, "hex")
        AddElementToObject(headers, "X-FB-ACCESS-KEY", this.ApiKey)
        AddElementToObject(headers, "X-FB-ACCESS-TIMESTAMP", this.NumberToString(timestamp))
        AddElementToObject(headers, "X-FB-ACCESS-SIGNATURE", signature)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *foxbit) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var error interface{} = this.SafeDict(response, "error")
    var code interface{} = this.SafeString(error, "code")
    var details interface{} = this.SafeList(error, "details")
    var message interface{} = this.SafeString(error, "message")
    var detailsString interface{} = ""
    if IsTrue(details) {
        for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
            detailsString = Add(Add(detailsString, GetValue(details, i)), " ")
        }
    }
    if IsTrue(!IsEqual(error, nil)) {
        var feedback interface{} = Add(Add(Add(Add(this.Id, " "), message), " details: "), detailsString)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), detailsString, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *foxbit) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
