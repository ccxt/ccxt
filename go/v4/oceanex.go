package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type oceanex struct {
    Exchange

}

func NewOceanexCore() oceanex {
   p := oceanex{}
   setDefaults(&p)
   return p
}

func  (this *oceanex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "oceanex",
        "name": "OceanEx",
        "countries": []interface{}{"BS"},
        "version": "v1",
        "rateLimit": 3000,
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/58385970-794e2d80-8001-11e9-889c-0567cd79b78e.jpg",
            "api": map[string]interface{} {
                "rest": "https://api.oceanex.pro",
            },
            "www": "https://www.oceanex.pro.com",
            "doc": "https://api.oceanex.pro/doc/v1",
            "referral": "https://oceanex.pro/signup?referral=VE24QX",
        },
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": nil,
            "future": nil,
            "option": nil,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "createMarketOrder": true,
            "createOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": "emulated",
            "fetchDepositAddresses": nil,
            "fetchDepositAddressesByNetwork": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchMarkets": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": true,
            "fetchOrders": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactionFees": nil,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "2h": "120",
            "4h": "240",
            "6h": "360",
            "12h": "720",
            "1d": "1440",
            "3d": "4320",
            "1w": "10080",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"markets", "tickers/{pair}", "tickers_multi", "order_book", "order_book/multi", "fees/trading", "trades", "timestamp"},
                "post": []interface{}{"k"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"key", "members/me", "orders", "orders/filter"},
                "post": []interface{}{"orders", "orders/multi", "order/delete", "order/delete/multi", "orders/clear", "/withdraws/special/new", "/deposit_address", "/deposit_addresses", "/deposit_history", "/withdraw_history"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.001"),
                "taker": this.ParseNumber("0.001"),
            },
        },
        "commonCurrencies": map[string]interface{} {
            "PLA": "Plair",
        },
        "precisionMode": TICK_SIZE,
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": true,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 100,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "codes": map[string]interface{} {
                "-1": BadRequest,
                "-2": BadRequest,
                "1001": BadRequest,
                "1004": ArgumentsRequired,
                "1006": AuthenticationError,
                "1008": AuthenticationError,
                "1010": AuthenticationError,
                "1011": PermissionDenied,
                "2001": AuthenticationError,
                "2002": InvalidOrder,
                "2004": OrderNotFound,
                "9003": PermissionDenied,
            },
            "exact": map[string]interface{} {
                "market does not have a valid value": BadRequest,
                "side does not have a valid value": BadRequest,
                "Account::AccountError: Cannot lock funds": InsufficientFunds,
                "The account does not exist": AuthenticationError,
            },
        },
    })
}
/**
 * @method
 * @name oceanex#fetchMarkets
 * @description retrieves data on all markets for oceanex
 * @see https://api.oceanex.pro/doc/v1/#markets-post
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *oceanex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "show_details": true,
            }
        
            response:= (<-this.PublicGetMarkets(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "id": "xtzusdt",
            //        "name": "XTZ/USDT",
            //        "ask_precision": "8",
            //        "bid_precision": "8",
            //        "enabled": true,
            //        "price_precision": "4",
            //        "amount_precision": "3",
            //        "usd_precision": "4",
            //        "minimum_trading_amount": "1.0"
            //    },
            //
            var markets interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeValue(market, "id")
    var name interface{} = this.SafeValue(market, "name")
    baseIdquoteIdVariable := Split(name, "/");
    baseId := GetValue(baseIdquoteIdVariable,0);
    quoteId := GetValue(baseIdquoteIdVariable,1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    baseId = ToLower(baseId)
    quoteId = ToLower(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": nil,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount_precision"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_precision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "minimum_trading_amount"),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name oceanex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.oceanex.pro/doc/v1/#ticker-post
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *oceanex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3328 := (<-this.LoadMarkets())
            PanicOnError(retRes3328)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersPair(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "message":"Operation successful",
            //         "data": {
            //             "at":1559431729,
            //             "ticker": {
            //                 "buy":"0.0065",
            //                 "sell":"0.00677",
            //                 "low":"0.00677",
            //                 "high":"0.00677",
            //                 "last":"0.00677",
            //                 "vol":"2000.0"
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api.oceanex.pro/doc/v1/#multiple-tickers-post
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *oceanex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3698 := (<-this.LoadMarkets())
            PanicOnError(retRes3698)
            symbols = this.MarketSymbols(symbols)
            if IsTrue(IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var request interface{} = map[string]interface{} {
                "markets": marketIds,
            }
        
            response:= (<-this.PublicGetTickersMulti(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "message":"Operation successful",
            //         "data": {
            //             "at":1559431729,
            //             "ticker": {
            //                 "buy":"0.0065",
            //                 "sell":"0.00677",
            //                 "low":"0.00677",
            //                 "high":"0.00677",
            //                 "last":"0.00677",
            //                 "vol":"2000.0"
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var ticker interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(ticker, "market")
                var market interface{} = this.SafeMarket(marketId)
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, this.ParseTicker(ticker, market))
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseTicker(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //         {
    //             "at":1559431729,
    //             "ticker": {
    //                 "buy":"0.0065",
    //                 "sell":"0.00677",
    //                 "low":"0.00677",
    //                 "high":"0.00677",
    //                 "last":"0.00677",
    //                 "vol":"2000.0"
    //             }
    //         }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var ticker interface{} = this.SafeValue(data, "ticker", map[string]interface{} {})
    var timestamp interface{} = this.SafeTimestamp(data, "at")
    var symbol interface{} = this.SafeSymbol(nil, market)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": this.SafeString(ticker, "last"),
        "last": this.SafeString(ticker, "last"),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name oceanex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.oceanex.pro/doc/v1/#order-book-post
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *oceanex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4588 := (<-this.LoadMarkets())
            PanicOnError(retRes4588)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "message":"Operation successful",
            //         "data": {
            //             "timestamp":1559433057,
            //             "asks": [
            //                 ["100.0","20.0"],
            //                 ["4.74","2000.0"],
            //                 ["1.74","4000.0"],
            //             ],
            //             "bids":[
            //                 ["0.0065","5482873.4"],
            //                 ["0.00649","4781956.2"],
            //                 ["0.00648","2876006.8"],
            //             ],
            //         }
            //     }
            //
            var orderbook interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeTimestamp(orderbook, "timestamp")
        
            ch <- this.ParseOrderBook(orderbook, symbol, timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchOrderBooks
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
 * @see https://api.oceanex.pro/doc/v1/#multiple-order-books-post
 * @param {string[]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
 * @param {int} [limit] max number of entries per orderbook to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
 */
func  (this *oceanex) FetchOrderBooks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5028 := (<-this.LoadMarkets())
            PanicOnError(retRes5028)
            if IsTrue(IsEqual(symbols, nil)) {
                symbols = this.Symbols
            }
            var marketIds interface{} = this.MarketIds(symbols)
            var request interface{} = map[string]interface{} {
                "markets": marketIds,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetOrderBookMulti(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "message":"Operation successful",
            //         "data": [
            //             {
            //                 "timestamp":1559433057,
            //                 "market": "bagvet",
            //                 "asks": [
            //                     ["100.0","20.0"],
            //                     ["4.74","2000.0"],
            //                     ["1.74","4000.0"],
            //                 ],
            //                 "bids":[
            //                     ["0.0065","5482873.4"],
            //                     ["0.00649","4781956.2"],
            //                     ["0.00648","2876006.8"],
            //                 ],
            //             },
            //             ...,
            //         ],
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var orderbook interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(orderbook, "market")
                var symbol interface{} = this.SafeSymbol(marketId)
                var timestamp interface{} = this.SafeTimestamp(orderbook, "timestamp")
                AddElementToObject(result, symbol, this.ParseOrderBook(orderbook, symbol, timestamp))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.oceanex.pro/doc/v1/#trades-post
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *oceanex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5618 := (<-this.LoadMarkets())
            PanicOnError(retRes5618)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "code":0,
            //          "message":"Operation successful",
            //          "data": [
            //              {
            //                  "id":220247666,
            //                  "price":"3098.62",
            //                  "volume":"0.00196",
            //                  "funds":"6.0732952",
            //                  "market":"ethusdt",
            //                  "created_at":"2022-04-19T19:03:15Z",
            //                  "created_on":1650394994,
            //                  "side":"bid"
            //              },
            //          ]
            //      }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "id":220247666,
    //          "price":"3098.62",
    //          "volume":"0.00196",
    //          "funds":"6.0732952",
    //          "market":"ethusdt",
    //          "created_at":"2022-04-19T19:03:15Z",
    //          "created_on":1650394995,
    //          "side":"bid"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeValue(trade, "side")
    if IsTrue(IsEqual(side, "bid")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "ask")) {
        side = "sell"
    }
    var marketId interface{} = this.SafeValue(trade, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeTimestamp(trade, "created_on")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(this.SafeString(trade, "created_at"))
    }
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "volume")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": this.SafeString(trade, "id"),
        "order": nil,
        "type": "limit",
        "takerOrMaker": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name oceanex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api.oceanex.pro/doc/v1/#api-server-time-post
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *oceanex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTimestamp(params))
            PanicOnError(response)
        
                //
            //     {"code":0,"message":"Operation successful","data":1559433420}
            //
        ch <- this.SafeTimestamp(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://api.oceanex.pro/doc/v1/#trading-fees-post
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *oceanex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetFeesTrading(params))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var group interface{} = GetValue(data, i)
                var maker interface{} = this.SafeValue(group, "ask_fee", map[string]interface{} {})
                var taker interface{} = this.SafeValue(group, "bid_fee", map[string]interface{} {})
                var marketId interface{} = this.SafeString(group, "market")
                var symbol interface{} = this.SafeSymbol(marketId)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": group,
            "symbol": symbol,
            "maker": this.SafeNumber(maker, "value"),
            "taker": this.SafeNumber(taker, "value"),
            "percentage": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) FetchKey(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivateGetKey(params))
            PanicOnError(response)
        
            ch <- this.SafeValue(response, "data")
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseBalance(response interface{}) interface{}  {
    var data interface{} = this.SafeValue(response, "data")
    var balances interface{} = this.SafeValue(data, "accounts", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeValue(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "balance"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name oceanex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api.oceanex.pro/doc/v1/#account-info-post
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *oceanex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7138 := (<-this.LoadMarkets())
            PanicOnError(retRes7138)
        
            response:= (<-this.PrivateGetMembersMe(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#createOrder
 * @description create a trade order
 * @see https://api.oceanex.pro/doc/v1/#new-order-post
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7328 := (<-this.LoadMarkets())
            PanicOnError(retRes7328)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "side": side,
                "ord_type": typeVar,
                "volume": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api.oceanex.pro/doc/v1/#order-status-get
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7598 := (<-this.LoadMarkets())
            PanicOnError(retRes7598)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var ids interface{} = []interface{}{id}
            var request interface{} = map[string]interface{} {
                "ids": ids,
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data")
            var dataLength interface{} =     GetArrayLength(data)
            if IsTrue(IsEqual(data, nil)) {
                panic(OrderNotFound(Add(this.Id, " could not found matching order")))
            }
            if IsTrue(IsArray(id)) {
                var orders interface{} = this.ParseOrders(data, market)
        
                ch <- GetValue(orders, 0)
                return nil
            }
            if IsTrue(IsEqual(dataLength, 0)) {
                panic(OrderNotFound(Add(this.Id, " could not found matching order")))
            }
        
            ch <- this.ParseOrder(GetValue(data, 0), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api.oceanex.pro/doc/v1/#order-status-get
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "states": []interface{}{"wait"},
            }
        
                retRes79715 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes79715)
                ch <- retRes79715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://api.oceanex.pro/doc/v1/#order-status-get
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "states": []interface{}{"done", "cancel"},
            }
        
                retRes81515 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes81515)
                ch <- retRes81515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://api.oceanex.pro/doc/v1/#order-status-with-filters-post
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes8338 := (<-this.LoadMarkets())
            PanicOnError(retRes8338)
            var market interface{} = this.Market(symbol)
            var states interface{} = this.SafeValue(params, "states", []interface{}{"wait", "done", "cancel"})
            var query interface{} = this.Omit(params, "states")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "states": states,
                "need_price": "True",
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOrdersFilter(this.Extend(request, query)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var orders interface{} = this.SafeValue(GetValue(data, i), "orders", []interface{}{})
                var status interface{} = this.ParseOrderStatus(this.SafeValue(GetValue(data, i), "state"))
                var parsedOrders interface{} = this.ParseOrders(orders, market, since, limit, map[string]interface{} {
                    "status": status,
                })
                result = this.ArrayConcat(result, parsedOrders)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // [
    //    1559232000,
    //    8889.22,
    //    9028.52,
    //    8889.22,
    //    9028.52
    //    0.3121
    // ]
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name oceanex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api.oceanex.pro/doc/v1/#k-line-post
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *oceanex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8898 := (<-this.LoadMarkets())
            PanicOnError(retRes8898)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "timestamp", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 10000))
            }
        
            response:= (<-this.PublicPostK(this.Extend(request, params)))
            PanicOnError(response)
            var ohlcvs interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "created_at": "2019-01-18T00:38:18Z",
    //         "trades_count": 0,
    //         "remaining_volume": "0.2",
    //         "price": "1001.0",
    //         "created_on": "1547771898",
    //         "side": "buy",
    //         "volume": "0.2",
    //         "state": "wait",
    //         "ord_type": "limit",
    //         "avg_price": "0.0",
    //         "executed_volume": "0.0",
    //         "id": 473797,
    //         "market": "veteth"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.ParseOrderStatus(this.SafeValue(order, "state"))
    var marketId interface{} = this.SafeString2(order, "market", "market_id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeTimestamp(order, "created_on")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(this.SafeString(order, "created_at"))
    }
    var price interface{} = this.SafeString(order, "price")
    var average interface{} = this.SafeString(order, "avg_price")
    var amount interface{} = this.SafeString(order, "volume")
    var remaining interface{} = this.SafeString(order, "remaining_volume")
    var filled interface{} = this.SafeString(order, "executed_volume")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "id"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": this.SafeValue(order, "ord_type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeValue(order, "side"),
        "price": price,
        "triggerPrice": nil,
        "average": average,
        "amount": amount,
        "remaining": remaining,
        "filled": filled,
        "status": status,
        "cost": nil,
        "trades": nil,
        "fee": nil,
    }, market)
}
func  (this *oceanex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "wait": "open",
        "done": "closed",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name oceanex#cancelOrder
 * @description cancels an open order
 * @see https://api.oceanex.pro/doc/v1/#cancel-order-post
 * @param {string} id order id
 * @param {string} symbol not used by oceanex cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9818 := (<-this.LoadMarkets())
            PanicOnError(retRes9818)
        
            response:= (<-this.PrivatePostOrderDelete(this.Extend(map[string]interface{} {
            "id": id,
        }, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#cancelOrders
 * @description cancel multiple orders
 * @see https://api.oceanex.pro/doc/v1/#cancel-multiple-orders-post
 * @param {string[]} ids order ids
 * @param {string} symbol not used by oceanex cancelOrders ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9988 := (<-this.LoadMarkets())
            PanicOnError(retRes9988)
        
            response:= (<-this.PrivatePostOrderDeleteMulti(this.Extend(map[string]interface{} {
            "ids": ids,
        }, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#cancelAllOrders
 * @description cancel all open orders
 * @see https://api.oceanex.pro/doc/v1/#cancel-all-orders-post
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *oceanex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10148 := (<-this.LoadMarkets())
            PanicOnError(retRes10148)
        
            response:= (<-this.PrivatePostOrdersClear(params))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name oceanex#fetchDepositAddressesByNetwork
 * @description fetch the deposit addresses for a currency associated with this account
 * @see https://api.oceanex.pro/doc/v1/#deposit-addresses-post
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
 */
func  (this *oceanex) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10308 := (<-this.LoadMarkets())
            PanicOnError(retRes10308)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivatePostDepositAddresses(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        code: '0',
            //        message: 'Operation successful',
            //        data: {
            //          data: {
            //            currency_id: 'usdt',
            //            display_name: 'USDT',
            //            num_of_resources: '3',
            //            resources: [
            //              {
            //                chain_name: 'TRC20',
            //                currency_id: 'usdt',
            //                address: 'TPcS7VgKMFmpRrWY82GbJzDeMnemWxEbpg',
            //                memo: '',
            //                deposit_status: 'enabled'
            //              },
            //              ...
            //            ]
            //          }
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var data2 interface{} = this.SafeDict(data, "data", map[string]interface{} {})
            var resources interface{} = this.SafeList(data2, "resources", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(resources)); i++ {
                var resource interface{} = GetValue(resources, i)
                var enabled interface{} = this.SafeString(resource, "deposit_status")
                if IsTrue(IsEqual(enabled, "enabled")) {
                    var parsedAddress interface{} = this.ParseDepositAddress(resource, currency)
                    AddElementToObject(result, GetValue(parsedAddress, "currency"), parsedAddress)
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *oceanex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        chain_name: 'TRC20',
    //        currency_id: 'usdt',
    //        address: 'TPcS7VgKMFmpRrWY82GbJzDeMnemWxEbpg',
    //        memo: '',
    //        deposit_status: 'enabled'
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    var currencyId interface{} = this.SafeString(depositAddress, "currency_id")
    var networkId interface{} = this.SafeString(depositAddress, "chain_name")
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "network": this.NetworkIdToCode(networkId),
        "address": address,
        "tag": this.SafeString(depositAddress, "memo"),
    }
}
func  (this *oceanex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.Version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(IsTrue(IsEqual(path, "tickers_multi")) || IsTrue(IsEqual(path, "order_book/multi"))) {
            var request interface{} = "?"
            var markets interface{} = this.SafeValue(params, "markets")
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                request = Add(request, Add(Add("markets[]=", GetValue(markets, i)), "&"))
            }
            var limit interface{} = this.SafeValue(params, "limit")
            if IsTrue(!IsEqual(limit, nil)) {
                request = Add(request, Add("limit=", limit))
            }
            url = Add(url, request)
        } else if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var request interface{} = map[string]interface{} {
            "uid": this.ApiKey,
            "data": query,
        }
        // to set the private key:
        // const fs = require ('fs')
        // exchange.secret = fs.readFileSync ('oceanex.pem', 'utf8')
        var jwt_token interface{} = Jwt(request, this.Encode(this.Secret), sha256, true)
        url = Add(url, Add("?user_jwt=", jwt_token))
    }
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *oceanex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    //     {"code":1011,"message":"This IP 'x.x.x.x' is not allowed","data":{}}
    //
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "0")))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "codes"), errorCode, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *oceanex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
