package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bl3p struct {
    Exchange

}

func NewBl3pCore() bl3p {
   p := bl3p{}
   setDefaults(&p)
   return p
}

func  (this *bl3p) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bl3p",
        "name": "BL3P",
        "countries": []interface{}{"NL"},
        "rateLimit": 1000,
        "version": "1",
        "comment": "An exchange market by BitonicNL",
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": true,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchOpenInterestHistory": false,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "ws": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/75aeb14e-cd48-43c8-8492-dff002dea0be",
            "api": map[string]interface{} {
                "rest": "https://api.bl3p.eu",
            },
            "www": "https://bl3p.eu",
            "doc": []interface{}{"https://github.com/BitonicNL/bl3p-api/tree/master/docs", "https://bl3p.eu/api", "https://bitonic.nl/en/api"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"{market}/ticker", "{market}/orderbook", "{market}/trades"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"{market}/money/depth/full", "{market}/money/order/add", "{market}/money/order/cancel", "{market}/money/order/result", "{market}/money/orders", "{market}/money/orders/history", "{market}/money/trades/fetch", "GENMKT/money/info", "GENMKT/money/deposit_address", "GENMKT/money/new_deposit_address", "GENMKT/money/wallet/history", "GENMKT/money/withdraw"},
            },
        },
        "markets": map[string]interface{} {
            "BTC/EUR": this.SafeMarketStructure(map[string]interface{} {
                "id": "BTCEUR",
                "symbol": "BTC/EUR",
                "base": "BTC",
                "quote": "EUR",
                "baseId": "BTC",
                "quoteId": "EUR",
                "maker": 0.0025,
                "taker": 0.0025,
                "type": "spot",
                "spot": true,
            }),
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": nil,
                "fetchOpenOrders": nil,
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *bl3p) ParseBalance(response interface{}) interface{}  {
    var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
    var wallets interface{} = this.SafeValue(data, "wallets", map[string]interface{} {})
    var result interface{} = map[string]interface{} {
        "info": data,
    }
    var codes interface{} = ObjectKeys(this.Currencies)
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        var code interface{} = GetValue(codes, i)
        var currency interface{} = this.Currency(code)
        var currencyId interface{} = GetValue(currency, "id")
        var wallet interface{} = this.SafeValue(wallets, currencyId, map[string]interface{} {})
        var available interface{} = this.SafeValue(wallet, "available", map[string]interface{} {})
        var balance interface{} = this.SafeValue(wallet, "balance", map[string]interface{} {})
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(available, "value"))
        AddElementToObject(account, "total", this.SafeString(balance, "value"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bl3p#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/authenticated_api/http.md#35---get-account-info--balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bl3p) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes640830 := (<-this.LoadMarkets())
            PanicOnError(retRes640830)
        
            response:= (<-this.PrivatePostGENMKTMoneyInfo(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *bl3p) ParseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var price interface{} = this.SafeString(bidask, priceKey)
    var size interface{} = this.SafeString(bidask, amountKey)
    return []interface{}{this.ParseNumber(Precise.StringDiv(price, "100000.0")), this.ParseNumber(Precise.StringDiv(size, "100000000.0"))}
}
/**
 * @method
 * @name bl3p#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/public_api/http.md#22---orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bl3p) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            var orderbook interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "bids", "asks", "price_int", "amount_int")
            return nil
        
            }()
            return ch
        }
func  (this *bl3p) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "currency":"BTC",
    //     "last":32654.55595,
    //     "bid":32552.3642,
    //     "ask":32703.58231,
    //     "high":33500,
    //     "low":31943,
    //     "timestamp":1643372789,
    //     "volume":{
    //         "24h":2.27372413,
    //         "30d":320.79375456
    //     }
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeTimestamp(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    var volume interface{} = this.SafeValue(ticker, "volume", map[string]interface{} {})
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(volume, "24h"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bl3p#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/public_api/http.md#21---ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bl3p) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetMarketTicker(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            // {
            //     "currency":"BTC",
            //     "last":32654.55595,
            //     "bid":32552.3642,
            //     "ask":32703.58231,
            //     "high":33500,
            //     "low":31943,
            //     "timestamp":1643372789,
            //     "volume":{
            //         "24h":2.27372413,
            //         "30d":320.79375456
            //     }
            // }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *bl3p) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //     {
    //         "trade_id": "2518789",
    //         "date": "1694348697745",
    //         "amount_int": "2959153",
    //         "price_int": "2416231440"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "trade_id")
    var timestamp interface{} = this.SafeInteger(trade, "date")
    var price interface{} = this.SafeString(trade, "price_int")
    var amount interface{} = this.SafeString(trade, "amount_int")
    market = this.SafeMarket(nil, market)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "side": nil,
        "order": nil,
        "takerOrMaker": nil,
        "price": Precise.StringDiv(price, "100000"),
        "amount": Precise.StringDiv(amount, "100000000"),
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name bl3p#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/public_api/http.md#23---last-1000-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bl3p) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
        
            response:= (<-this.PublicGetMarketTrades(this.Extend(map[string]interface{} {
            "market": GetValue(market, "id"),
        }, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": "success",
            //        "data": {
            //            "trades": [
            //                {
            //                    "trade_id": "2518789",
            //                    "date": "1694348697745",
            //                    "amount_int": "2959153",
            //                    "price_int": "2416231440"
            //                },
            //            ]
            //        }
            //     }
            var result interface{} = this.ParseTrades(GetValue(GetValue(response, "data"), "trades"), market, since, limit)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bl3p#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/authenticated_api/http.md#35---get-account-info--balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *bl3p) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes735739 := (<-this.LoadMarkets())
            PanicOnError(retRes735739)
        
            response:= (<-this.PrivatePostGENMKTMoneyInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "data": {
            //             "user_id": "13396",
            //             "wallets": {
            //                 "BTC": {
            //                     "balance": {
            //                         "value_int": "0",
            //                         "display": "0.00000000 BTC",
            //                         "currency": "BTC",
            //                         "value": "0.00000000",
            //                         "display_short": "0.00 BTC"
            //                     },
            //                     "available": {
            //                         "value_int": "0",
            //                         "display": "0.00000000 BTC",
            //                         "currency": "BTC",
            //                         "value": "0.00000000",
            //                         "display_short": "0.00 BTC"
            //                     }
            //                 },
            //                 ...
            //             },
            //             "trade_fee": "0.25"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var feeString interface{} = this.SafeString(data, "trade_fee")
            var fee interface{} = this.ParseNumber(Precise.StringDiv(feeString, "100"))
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": data,
            "symbol": symbol,
            "maker": fee,
            "taker": fee,
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bl3p#createOrder
 * @description create a trade order
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/examples/nodejs/example.md#21---create-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.amount_funds] maximal EUR amount to spend (*1e5)
 * @param {string} [params.fee_currency] 'EUR' or 'BTC'
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bl3p) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
            var amountString interface{} = this.NumberToString(amount)
            var priceString interface{} = this.NumberToString(price)
            var order interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "amount_int": ParseInt(Precise.StringMul(amountString, "100000000")),
                "fee_currency": GetValue(market, "quote"),
                "type": Ternary(IsTrue((IsEqual(side, "buy"))), "bid", "ask"),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(order, "price_int", ParseInt(Precise.StringMul(priceString, "100000.0")))
            }
        
            response:= (<-this.PrivatePostMarketMoneyOrderAdd(this.Extend(order, params)))
            PanicOnError(response)
            var orderId interface{} = this.SafeString(GetValue(response, "data"), "order_id")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": orderId,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bl3p#cancelOrder
 * @description cancels an open order
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/authenticated_api/http.md#22---cancel-an-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bl3p) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivatePostMarketMoneyOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // "success"
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bl3p#createDepositAddress
 * @description create a currency deposit address
 * @see https://github.com/BitonicNL/bl3p-api/blob/master/docs/authenticated_api/http.md#32---create-a-new-deposit-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bl3p) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes224741 := (<-this.LoadMarkets())
            PanicOnError(retRes224741)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivatePostGENMKTMoneyNewDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": "success",
            //        "data": {
            //            "address": "36Udu9zi1uYicpXcJpoKfv3bewZeok5tpk"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bl3p) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "address": "36Udu9zi1uYicpXcJpoKfv3bewZeok5tpk"
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeString(currency, "code"),
        "address": address,
        "tag": nil,
        "network": nil,
    }
}
func  (this *bl3p) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = this.ImplodeParams(path, params)
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.Version), "/"), request)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Nonce()
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "nonce": nonce,
        }, query))
        var secret interface{} = this.Base64ToBinary(this.Secret)
        // eslint-disable-next-line quotes
        var auth interface{} = Add(Add(request, "//" + "0"), body)
        var signature interface{} = this.Hmac(this.Encode(auth), secret, sha512, "base64")
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "Rest-Key": this.ApiKey,
            "Rest-Sign": signature,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *bl3p) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
