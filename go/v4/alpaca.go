package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type alpaca struct {
    Exchange

}

func NewAlpacaCore() alpaca {
   p := alpaca{}
   setDefaults(&p)
   return p
}

func  (this *alpaca) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "alpaca",
        "name": "Alpaca",
        "countries": []interface{}{"US"},
        "rateLimit": 333,
        "hostname": "alpaca.markets",
        "pro": true,
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/e9476df8-a450-4c3e-ab9a-1a7794219e1b",
            "www": "https://alpaca.markets",
            "api": map[string]interface{} {
                "broker": "https://broker-api.{hostname}",
                "trader": "https://api.{hostname}",
                "market": "https://data.{hostname}",
            },
            "test": map[string]interface{} {
                "broker": "https://broker-api.sandbox.{hostname}",
                "trader": "https://paper-api.{hostname}",
                "market": "https://data.{hostname}",
            },
            "doc": "https://alpaca.markets/docs/",
            "fees": "https://docs.alpaca.markets/docs/crypto-fees",
        },
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketBuyOrder": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": true,
            "createOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "editOrder": true,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchClosedOrders": true,
            "fetchCurrencies": false,
            "fetchDepositAddress": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchL1OrderBook": true,
            "fetchL2OrderBook": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "api": map[string]interface{} {
            "broker": map[string]interface{} {},
            "trader": map[string]interface{} {
                "private": map[string]interface{} {
                    "get": []interface{}{"v2/account", "v2/orders", "v2/orders/{order_id}", "v2/positions", "v2/positions/{symbol_or_asset_id}", "v2/account/portfolio/history", "v2/watchlists", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/account/configurations", "v2/account/activities", "v2/account/activities/{activity_type}", "v2/calendar", "v2/clock", "v2/assets", "v2/assets/{symbol_or_asset_id}", "v2/corporate_actions/announcements/{id}", "v2/corporate_actions/announcements", "v2/wallets", "v2/wallets/transfers"},
                    "post": []interface{}{"v2/orders", "v2/watchlists", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/wallets/transfers"},
                    "put": []interface{}{"v2/orders/{order_id}", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name"},
                    "patch": []interface{}{"v2/orders/{order_id}", "v2/account/configurations"},
                    "delete": []interface{}{"v2/orders", "v2/orders/{order_id}", "v2/positions", "v2/positions/{symbol_or_asset_id}", "v2/watchlists/{watchlist_id}", "v2/watchlists:by_name", "v2/watchlists/{watchlist_id}/{symbol}"},
                },
            },
            "market": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": []interface{}{"v1beta3/crypto/{loc}/bars", "v1beta3/crypto/{loc}/latest/bars", "v1beta3/crypto/{loc}/latest/orderbooks", "v1beta3/crypto/{loc}/latest/quotes", "v1beta3/crypto/{loc}/latest/trades", "v1beta3/crypto/{loc}/quotes", "v1beta3/crypto/{loc}/snapshots", "v1beta3/crypto/{loc}/trades"},
                },
                "private": map[string]interface{} {
                    "get": []interface{}{"v1beta1/corporate-actions", "v1beta1/forex/latest/rates", "v1beta1/forex/rates", "v1beta1/logos/{symbol}", "v1beta1/news", "v1beta1/screener/stocks/most-actives", "v1beta1/screener/{market_type}/movers", "v2/stocks/auctions", "v2/stocks/bars", "v2/stocks/bars/latest", "v2/stocks/meta/conditions/{ticktype}", "v2/stocks/meta/exchanges", "v2/stocks/quotes", "v2/stocks/quotes/latest", "v2/stocks/snapshots", "v2/stocks/trades", "v2/stocks/trades/latest", "v2/stocks/{symbol}/auctions", "v2/stocks/{symbol}/bars", "v2/stocks/{symbol}/bars/latest", "v2/stocks/{symbol}/quotes", "v2/stocks/{symbol}/quotes/latest", "v2/stocks/{symbol}/snapshot", "v2/stocks/{symbol}/trades", "v2/stocks/{symbol}/trades/latest"},
                },
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "3m": "3min",
            "5m": "5min",
            "15m": "15min",
            "30m": "30min",
            "1h": "1H",
            "2h": "2H",
            "4h": "4H",
            "6h": "6H",
            "8h": "8H",
            "12h": "12H",
            "1d": "1D",
            "3d": "3D",
            "1w": "1W",
            "1M": "1M",
        },
        "precisionMode": TICK_SIZE,
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.0015"),
                "taker": this.ParseNumber("0.0025"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0022")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0020")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("25000000"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.001")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("25000000"), this.ParseNumber("0.0002")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0002")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00")}},
                },
            },
        },
        "headers": map[string]interface{} {
            "APCA-PARTNER-ID": "ccxt",
        },
        "options": map[string]interface{} {
            "defaultExchange": "CBSE",
            "exchanges": []interface{}{"CBSE", "FTX", "GNSS", "ERSX"},
            "defaultTimeInForce": "gtc",
            "clientOrderId": "ccxt_{id}",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": map[string]interface{} {
                            "last": true,
                            "mark": true,
                            "index": true,
                        },
                        "price": true,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "forbidden.": PermissionDenied,
                "40410000": InvalidOrder,
                "40010001": BadRequest,
                "40110000": PermissionDenied,
                "40310000": InsufficientFunds,
                "42910000": RateLimitExceeded,
            },
            "broad": map[string]interface{} {
                "Invalid format for parameter": BadRequest,
                "Invalid symbol": BadSymbol,
            },
        },
    })
}
/**
 * @method
 * @name alpaca#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *alpaca) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.TraderPrivateGetV2Clock(params))
            PanicOnError(response)
            //
            //     {
            //         timestamp: '2023-11-22T08:07:57.654738097-05:00',
            //         is_open: false,
            //         next_open: '2023-11-22T09:30:00-05:00',
            //         next_close: '2023-11-22T16:00:00-05:00'
            //     }
            //
            var timestamp interface{} = this.SafeString(response, "timestamp")
            var localTime interface{} = Slice(timestamp, 0, 23)
            var jetlagStrStart interface{} = Subtract(GetLength(timestamp), 6)
            var jetlagStrEnd interface{} = Subtract(GetLength(timestamp), 3)
            var jetlag interface{} = Slice(timestamp, jetlagStrStart, jetlagStrEnd)
            var iso interface{} = Subtract(this.Parse8601(localTime), Multiply(Multiply(this.ParseToNumeric(jetlag), 3600), 1000))
        
            ch <- iso
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchMarkets
 * @description retrieves data on all markets for alpaca
 * @see https://docs.alpaca.markets/reference/get-v2-assets
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *alpaca) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "asset_class": "crypto",
                "status": "active",
            }
        
            assets:= (<-this.TraderPrivateGetV2Assets(this.Extend(request, params)))
            PanicOnError(assets)
        
                //
            //     [
            //         {
            //             "id": "c150e086-1e75-44e6-9c2c-093bb1e93139",
            //             "class": "crypto",
            //             "exchange": "CRYPTO",
            //             "symbol": "BTC/USDT",
            //             "name": "Bitcoin / USD Tether",
            //             "status": "active",
            //             "tradable": true,
            //             "marginable": false,
            //             "maintenance_margin_requirement": 100,
            //             "shortable": false,
            //             "easy_to_borrow": false,
            //             "fractionable": true,
            //             "attributes": [],
            //             "min_order_size": "0.000026873",
            //             "min_trade_increment": "0.000000001",
            //             "price_increment": "1"
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(assets)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseMarket(asset interface{}) interface{}  {
    //
    //     {
    //         "id": "c150e086-1e75-44e6-9c2c-093bb1e93139",
    //         "class": "crypto",
    //         "exchange": "CRYPTO",
    //         "symbol": "BTC/USDT",
    //         "name": "Bitcoin / USD Tether",
    //         "status": "active",
    //         "tradable": true,
    //         "marginable": false,
    //         "maintenance_margin_requirement": 101,
    //         "shortable": false,
    //         "easy_to_borrow": false,
    //         "fractionable": true,
    //         "attributes": [],
    //         "min_order_size": "0.000026873",
    //         "min_trade_increment": "0.000000001",
    //         "price_increment": "1"
    //     }
    //
    var marketId interface{} = this.SafeString(asset, "symbol")
    var parts interface{} = Split(marketId, "/")
    var assetClass interface{} = this.SafeString(asset, "class")
    var baseId interface{} = this.SafeString(parts, 0)
    var quoteId interface{} = this.SafeString(parts, 1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    // Us equity markets do not include quote in symbol.
    // We can safely coerce us_equity quote to USD
    if IsTrue(IsTrue(IsEqual(quote, nil)) && IsTrue(IsEqual(assetClass, "us_equity"))) {
        quote = "USD"
    }
    var symbol interface{} = Add(Add(base, "/"), quote)
    var status interface{} = this.SafeString(asset, "status")
    var active interface{} =     (IsEqual(status, "active"))
    var minAmount interface{} = this.SafeNumber(asset, "min_order_size")
    var amount interface{} = this.SafeNumber(asset, "min_trade_increment")
    var price interface{} = this.SafeNumber(asset, "price_increment")
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": nil,
        "swap": false,
        "future": false,
        "option": false,
        "active": active,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": amount,
            "price": price,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": minAmount,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": asset,
    }
}
/**
 * @method
 * @name alpaca#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.alpaca.markets/reference/cryptotrades
 * @see https://docs.alpaca.markets/reference/cryptolatesttrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocTrades
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *alpaca) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5418 := (<-this.LoadMarkets())
            PanicOnError(retRes5418)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var loc interface{} = this.SafeString(params, "loc", "us")
            var method interface{} = this.SafeString(params, "method", "marketPublicGetV1beta3CryptoLocTrades")
            var request interface{} = map[string]interface{} {
                "symbols": marketId,
                "loc": loc,
            }
            params = this.Omit(params, []interface{}{"loc", "method"})
            var symbolTrades interface{} = nil
            if IsTrue(IsEqual(method, "marketPublicGetV1beta3CryptoLocTrades")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start", this.Iso8601(since))
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
        
                response:= (<-this.MarketPublicGetV1beta3CryptoLocTrades(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    {
                //        "next_page_token": null,
                //        "trades": {
                //            "BTC/USD": [
                //                {
                //                    "i": 36440704,
                //                    "p": 22625,
                //                    "s": 0.0001,
                //                    "t": "2022-07-21T11:47:31.073391Z",
                //                    "tks": "B"
                //                }
                //            ]
                //        }
                //    }
                //
                var trades interface{} = this.SafeDict(response, "trades", map[string]interface{} {})
                symbolTrades = this.SafeList(trades, marketId, []interface{}{})
            } else if IsTrue(IsEqual(method, "marketPublicGetV1beta3CryptoLocLatestTrades")) {
        
                response:= (<-this.MarketPublicGetV1beta3CryptoLocLatestTrades(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    {
                //       "trades": {
                //            "BTC/USD": {
                //                "i": 36440704,
                //                "p": 22625,
                //                "s": 0.0001,
                //                "t": "2022-07-21T11:47:31.073391Z",
                //                "tks": "B"
                //            }
                //        }
                //    }
                //
                var trades interface{} = this.SafeDict(response, "trades", map[string]interface{} {})
                symbolTrades = this.SafeDict(trades, marketId, map[string]interface{} {})
                symbolTrades = []interface{}{symbolTrades}
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTrades() does not support "), method), ", marketPublicGetV1beta3CryptoLocTrades and marketPublicGetV1beta3CryptoLocLatestTrades are supported")))
            }
        
            ch <- this.ParseTrades(symbolTrades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.alpaca.markets/reference/cryptolatestorderbooks
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func  (this *alpaca) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6148 := (<-this.LoadMarkets())
            PanicOnError(retRes6148)
            var market interface{} = this.Market(symbol)
            var id interface{} = GetValue(market, "id")
            var loc interface{} = this.SafeString(params, "loc", "us")
            var request interface{} = map[string]interface{} {
                "symbols": id,
                "loc": loc,
            }
        
            response:= (<-this.MarketPublicGetV1beta3CryptoLocLatestOrderbooks(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   {
            //       "orderbooks":{
            //          "BTC/USD":{
            //             "a":[
            //                {
            //                   "p":22208,
            //                   "s":0.0051
            //                },
            //                {
            //                   "p":22209,
            //                   "s":0.1123
            //                },
            //                {
            //                   "p":22210,
            //                   "s":0.2465
            //                }
            //             ],
            //             "b":[
            //                {
            //                   "p":22203,
            //                   "s":0.395
            //                },
            //                {
            //                   "p":22202,
            //                   "s":0.2465
            //                },
            //                {
            //                   "p":22201,
            //                   "s":0.6455
            //                }
            //             ],
            //             "t":"2022-07-19T13:41:55.13210112Z"
            //          }
            //       }
            //   }
            //
            var orderbooks interface{} = this.SafeDict(response, "orderbooks", map[string]interface{} {})
            var rawOrderbook interface{} = this.SafeDict(orderbooks, id, map[string]interface{} {})
            var timestamp interface{} = this.Parse8601(this.SafeString(rawOrderbook, "t"))
        
            ch <- this.ParseOrderBook(rawOrderbook, GetValue(market, "symbol"), timestamp, "b", "a", "p", "s")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.alpaca.markets/reference/cryptobars
 * @see https://docs.alpaca.markets/reference/cryptolatestbars
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the alpha api endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocBars
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *alpaca) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6828 := (<-this.LoadMarkets())
            PanicOnError(retRes6828)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var loc interface{} = this.SafeString(params, "loc", "us")
            var method interface{} = this.SafeString(params, "method", "marketPublicGetV1beta3CryptoLocBars")
            var request interface{} = map[string]interface{} {
                "symbols": marketId,
                "loc": loc,
            }
            params = this.Omit(params, []interface{}{"loc", "method"})
            var ohlcvs interface{} = nil
            if IsTrue(IsEqual(method, "marketPublicGetV1beta3CryptoLocBars")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start", this.Yyyymmdd(since))
                }
                AddElementToObject(request, "timeframe", this.SafeString(this.Timeframes, timeframe, timeframe))
        
                response:= (<-this.MarketPublicGetV1beta3CryptoLocBars(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    {
                //        "bars": {
                //           "BTC/USD": [
                //              {
                //                 "c": 22887,
                //                 "h": 22888,
                //                 "l": 22873,
                //                 "n": 11,
                //                 "o": 22883,
                //                 "t": "2022-07-21T05:00:00Z",
                //                 "v": 1.1138,
                //                 "vw": 22883.0155324116
                //              },
                //              {
                //                 "c": 22895,
                //                 "h": 22895,
                //                 "l": 22884,
                //                 "n": 6,
                //                 "o": 22884,
                //                 "t": "2022-07-21T05:01:00Z",
                //                 "v": 0.001,
                //                 "vw": 22889.5
                //              }
                //           ]
                //        },
                //        "next_page_token": "QlRDL1VTRHxNfDIwMjItMDctMjFUMDU6MDE6MDAuMDAwMDAwMDAwWg=="
                //     }
                //
                var bars interface{} = this.SafeDict(response, "bars", map[string]interface{} {})
                ohlcvs = this.SafeList(bars, marketId, []interface{}{})
            } else if IsTrue(IsEqual(method, "marketPublicGetV1beta3CryptoLocLatestBars")) {
        
                response:= (<-this.MarketPublicGetV1beta3CryptoLocLatestBars(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    {
                //        "bars": {
                //           "BTC/USD": {
                //              "c": 22887,
                //              "h": 22888,
                //              "l": 22873,
                //              "n": 11,
                //              "o": 22883,
                //              "t": "2022-07-21T05:00:00Z",
                //              "v": 1.1138,
                //              "vw": 22883.0155324116
                //           }
                //        }
                //     }
                //
                var bars interface{} = this.SafeDict(response, "bars", map[string]interface{} {})
                ohlcvs = this.SafeDict(bars, marketId, map[string]interface{} {})
                ohlcvs = []interface{}{ohlcvs}
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOHLCV() does not support "), method), ", marketPublicGetV1beta3CryptoLocBars and marketPublicGetV1beta3CryptoLocLatestBars are supported")))
            }
        
            ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //        "c":22895,
    //        "h":22895,
    //        "l":22884,
    //        "n":6,
    //        "o":22884,
    //        "t":"2022-07-21T05:01:00Z",
    //        "v":0.001,
    //        "vw":22889.5
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(ohlcv, "t")
    var timestamp interface{} = this.Parse8601(datetime)
    return []interface{}{timestamp, this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name alpaca#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.alpaca.markets/reference/cryptosnapshots-1
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *alpaca) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7968 := (<-this.LoadMarkets())
            PanicOnError(retRes7968)
            symbol = this.Symbol(symbol)
        
            tickers:= (<-this.FetchTickers([]interface{}{symbol}, params))
            PanicOnError(tickers)
        
            ch <- this.SafeDict(tickers, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.alpaca.markets/reference/cryptosnapshots-1
 * @param {string[]} symbols unified symbols of the markets to fetch tickers for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *alpaca) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbols, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTickers() requires a symbols argument")))
            }
        
            retRes8168 := (<-this.LoadMarkets())
            PanicOnError(retRes8168)
            symbols = this.MarketSymbols(symbols)
            var loc interface{} = this.SafeString(params, "loc", "us")
            var ids interface{} = this.MarketIds(symbols)
            var request interface{} = map[string]interface{} {
                "symbols": Join(ids, ","),
                "loc": loc,
            }
            params = this.Omit(params, "loc")
        
            response:= (<-this.MarketPublicGetV1beta3CryptoLocSnapshots(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "snapshots": {
            //             "BTC/USD": {
            //                 "dailyBar": {
            //                     "c": 69403.554,
            //                     "h": 69609.6515,
            //                     "l": 69013.26,
            //                     "n": 9,
            //                     "o": 69536.7,
            //                     "t": "2024-11-01T05:00:00Z",
            //                     "v": 0.210809181,
            //                     "vw": 69327.655393908
            //                 },
            //                 "latestQuote": {
            //                     "ap": 69424.19,
            //                     "as": 0.68149,
            //                     "bp": 69366.086,
            //                     "bs": 0.68312,
            //                     "t": "2024-11-01T08:31:41.880246926Z"
            //                 },
            //                 "latestTrade": {
            //                     "i": 5272941104897543146,
            //                     "p": 69416.9,
            //                     "s": 0.014017324,
            //                     "t": "2024-11-01T08:14:28.245088803Z",
            //                     "tks": "B"
            //                 },
            //                 "minuteBar": {
            //                     "c": 69403.554,
            //                     "h": 69403.554,
            //                     "l": 69399.125,
            //                     "n": 0,
            //                     "o": 69399.125,
            //                     "t": "2024-11-01T08:30:00Z",
            //                     "v": 0,
            //                     "vw": 0
            //                 },
            //                 "prevDailyBar": {
            //                     "c": 69515.1415,
            //                     "h": 72668.837,
            //                     "l": 68796.85,
            //                     "n": 129,
            //                     "o": 72258.9,
            //                     "t": "2024-10-31T05:00:00Z",
            //                     "v": 2.217683307,
            //                     "vw": 70782.6811608144
            //                 }
            //             },
            //         }
            //     }
            //
            var results interface{} = []interface{}{}
            var snapshots interface{} = this.SafeDict(response, "snapshots", map[string]interface{} {})
            var marketIds interface{} = ObjectKeys(snapshots)
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var market interface{} = this.SafeMarket(marketId)
                var entry interface{} = this.SafeDict(snapshots, marketId)
                var dailyBar interface{} = this.SafeDict(entry, "dailyBar", map[string]interface{} {})
                var prevDailyBar interface{} = this.SafeDict(entry, "prevDailyBar", map[string]interface{} {})
                var latestQuote interface{} = this.SafeDict(entry, "latestQuote", map[string]interface{} {})
                var latestTrade interface{} = this.SafeDict(entry, "latestTrade", map[string]interface{} {})
                var datetime interface{} = this.SafeString(latestQuote, "t")
                var ticker interface{} = this.SafeTicker(map[string]interface{} {
                    "info": entry,
                    "symbol": GetValue(market, "symbol"),
                    "timestamp": this.Parse8601(datetime),
                    "datetime": datetime,
                    "high": this.SafeString(dailyBar, "h"),
                    "low": this.SafeString(dailyBar, "l"),
                    "bid": this.SafeString(latestQuote, "bp"),
                    "bidVolume": this.SafeString(latestQuote, "bs"),
                    "ask": this.SafeString(latestQuote, "ap"),
                    "askVolume": this.SafeString(latestQuote, "as"),
                    "vwap": this.SafeString(dailyBar, "vw"),
                    "open": this.SafeString(dailyBar, "o"),
                    "close": this.SafeString(dailyBar, "c"),
                    "last": this.SafeString(latestTrade, "p"),
                    "previousClose": this.SafeString(prevDailyBar, "c"),
                    "change": nil,
                    "percentage": nil,
                    "average": nil,
                    "baseVolume": this.SafeString(dailyBar, "v"),
                    "quoteVolume": this.SafeString(dailyBar, "n"),
                }, market)
                AppendToArray(&results,ticker)
            }
        
            ch <- this.FilterByArray(results, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) GenerateClientOrderId(params interface{}) interface{}  {
    var clientOrderIdprefix interface{} = this.SafeString(this.Options, "clientOrderId")
    var uuid interface{} = this.Uuid()
    var parts interface{} = Split(uuid, "-")
    var random_id interface{} = Join(parts, "")
    var defaultClientId interface{} = this.ImplodeParams(clientOrderIdprefix, map[string]interface{} {
        "id": random_id,
    })
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId", defaultClientId)
    return clientOrderId
}
/**
 * @method
 * @name alpaca#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @see https://docs.alpaca.markets/reference/postorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9398 := (<-this.LoadMarkets())
            PanicOnError(retRes9398)
            var req interface{} = map[string]interface{} {
                "cost": cost,
            }
        
                retRes94315 :=  (<-this.CreateOrder(symbol, "market", side, 0, nil, this.Extend(req, params)))
                PanicOnError(retRes94315)
                ch <- retRes94315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://docs.alpaca.markets/reference/postorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9578 := (<-this.LoadMarkets())
            PanicOnError(retRes9578)
            var req interface{} = map[string]interface{} {
                "cost": cost,
            }
        
                retRes96115 :=  (<-this.CreateOrder(symbol, "market", "buy", 0, nil, this.Extend(req, params)))
                PanicOnError(retRes96115)
                ch <- retRes96115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://docs.alpaca.markets/reference/postorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9758 := (<-this.LoadMarkets())
            PanicOnError(retRes9758)
            var req interface{} = map[string]interface{} {
                "cost": cost,
            }
        
                retRes97915 :=  (<-this.CreateOrder(symbol, "market", "sell", cost, nil, this.Extend(req, params)))
                PanicOnError(retRes97915)
                ch <- retRes97915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#createOrder
 * @description create a trade order
 * @see https://docs.alpaca.markets/reference/postorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit' or 'stop_limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {float} [params.cost] *market orders only* the cost of the order in units of the quote currency
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9988 := (<-this.LoadMarkets())
            PanicOnError(retRes9988)
            var market interface{} = this.Market(symbol)
            var id interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "symbol": id,
                "side": side,
                "type": typeVar,
            }
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stop_price"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                var newType interface{} = nil
                if IsTrue(IsGreaterThanOrEqual(GetIndexOf(typeVar, "limit"), 0)) {
                    newType = "stop_limit"
                } else {
                    panic(NotSupported(Add(Add(Add(this.Id, " createOrder() does not support stop orders for "), typeVar), " orders, only stop_limit orders are supported")))
                }
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "type", newType)
            }
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(typeVar, "limit"), 0)) {
                AddElementToObject(request, "limit_price", this.PriceToPrecision(symbol, price))
            }
            var cost interface{} = this.SafeString(params, "cost")
            if IsTrue(!IsEqual(cost, nil)) {
                params = this.Omit(params, "cost")
                AddElementToObject(request, "notional", this.CostToPrecision(symbol, cost))
            } else {
                AddElementToObject(request, "qty", this.AmountToPrecision(symbol, amount))
            }
            var defaultTIF interface{} = this.SafeString(this.Options, "defaultTimeInForce")
            AddElementToObject(request, "time_in_force", this.SafeString(params, "timeInForce", defaultTIF))
            params = this.Omit(params, []interface{}{"timeInForce", "triggerPrice"})
            AddElementToObject(request, "client_order_id", this.GenerateClientOrderId(params))
            params = this.Omit(params, []interface{}{"clientOrderId"})
        
            order:= (<-this.TraderPrivatePostV2Orders(this.Extend(request, params)))
            PanicOnError(order)
        
                //
            //   {
            //      "id": "61e69015-8549-4bfd-b9c3-01e75843f47d",
            //      "client_order_id": "eb9e2aaa-f71a-4f51-b5b4-52a6c565dad4",
            //      "created_at": "2021-03-16T18:38:01.942282Z",
            //      "updated_at": "2021-03-16T18:38:01.942282Z",
            //      "submitted_at": "2021-03-16T18:38:01.937734Z",
            //      "filled_at": null,
            //      "expired_at": null,
            //      "canceled_at": null,
            //      "failed_at": null,
            //      "replaced_at": null,
            //      "replaced_by": null,
            //      "replaces": null,
            //      "asset_id": "b0b6dd9d-8b9b-48a9-ba46-b9d54906e415",
            //      "symbol": "AAPL",
            //      "asset_class": "us_equity",
            //      "notional": "500",
            //      "qty": null,
            //      "filled_qty": "0",
            //      "filled_avg_price": null,
            //      "order_class": "",
            //      "order_type": "market",
            //      "type": "market",
            //      "side": "buy",
            //      "time_in_force": "day",
            //      "limit_price": null,
            //      "stop_price": null,
            //      "status": "accepted",
            //      "extended_hours": false,
            //      "legs": null,
            //      "trail_percent": null,
            //      "trail_price": null,
            //      "hwm": null
            //   }
            //
        ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#cancelOrder
 * @description cancels an open order
 * @see https://docs.alpaca.markets/reference/deleteorderbyorderid
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.TraderPrivateDeleteV2OrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //   {
            //       "code": 40410000,
            //       "message": "order is not found."
            //   }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://docs.alpaca.markets/reference/deleteallorders
 * @param {string} symbol alpaca cancelAllOrders cannot setting symbol, it will cancel all open orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11068 := (<-this.LoadMarkets())
            PanicOnError(retRes11068)
        
            response:= (<-this.TraderPrivateDeleteV2Orders(params))
            PanicOnError(response)
            if IsTrue(IsArray(response)) {
        
                ch <- this.ParseOrders(response, nil)
                return nil
            } else {
        
                ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.alpaca.markets/reference/getorderbyorderid
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11308 := (<-this.LoadMarkets())
            PanicOnError(retRes11308)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            order:= (<-this.TraderPrivateGetV2OrdersOrderId(this.Extend(request, params)))
            PanicOnError(order)
            var marketId interface{} = this.SafeString(order, "symbol")
            var market interface{} = this.SafeMarket(marketId)
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.alpaca.markets/reference/getallorders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11538 := (<-this.LoadMarkets())
            PanicOnError(retRes11538)
            var request interface{} = map[string]interface{} {
                "status": "all",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbols", GetValue(market, "id"))
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "endTime", this.Iso8601(until))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.TraderPrivateGetV2Orders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //           "id": "cbaf12d7-69b8-49c0-a31b-b46af35c755c",
            //           "client_order_id": "ccxt_b36156ae6fd44d098ac9c179bab33efd",
            //           "created_at": "2023-11-17T04:21:42.234579Z",
            //           "updated_at": "2023-11-17T04:22:34.442765Z",
            //           "submitted_at": "2023-11-17T04:21:42.233357Z",
            //           "filled_at": null,
            //           "expired_at": null,
            //           "canceled_at": "2023-11-17T04:22:34.399019Z",
            //           "failed_at": null,
            //           "replaced_at": null,
            //           "replaced_by": null,
            //           "replaces": null,
            //           "asset_id": "77c6f47f-0939-4b23-b41e-47b4469c4bc8",
            //           "symbol": "LTC/USDT",
            //           "asset_class": "crypto",
            //           "notional": null,
            //           "qty": "0.001",
            //           "filled_qty": "0",
            //           "filled_avg_price": null,
            //           "order_class": "",
            //           "order_type": "limit",
            //           "type": "limit",
            //           "side": "sell",
            //           "time_in_force": "gtc",
            //           "limit_price": "1000",
            //           "stop_price": null,
            //           "status": "canceled",
            //           "extended_hours": false,
            //           "legs": null,
            //           "trail_percent": null,
            //           "trail_price": null,
            //           "hwm": null,
            //           "subtag": null,
            //           "source": "access_key"
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.alpaca.markets/reference/getallorders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "open",
            }
        
                retRes123315 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes123315)
                ch <- retRes123315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.alpaca.markets/reference/getallorders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "closed",
            }
        
                retRes125215 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes125215)
                ch <- retRes125215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#editOrder
 * @description edit a trade order
 * @see https://docs.alpaca.markets/reference/patchorderbyorderid-1
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market to create an order in
 * @param {string} [type] 'market', 'limit' or 'stop_limit'
 * @param {string} [side] 'buy' or 'sell'
 * @param {float} [amount] how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price for the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.triggerPrice] the price to trigger a stop order
 * @param {string} [params.timeInForce] for crypto trading either 'gtc' or 'ioc' can be used
 * @param {string} [params.clientOrderId] a unique identifier for the order, automatically generated if not sent
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *alpaca) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12738 := (<-this.LoadMarkets())
            PanicOnError(retRes12738)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "qty", this.AmountToPrecision(symbol, amount))
            }
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stop_price"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
                params = this.Omit(params, "triggerPrice")
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "limit_price", this.PriceToPrecision(symbol, price))
            }
            var timeInForce interface{} = nil
            timeInForceparamsVariable := this.HandleOptionAndParams2(params, "editOrder", "timeInForce", "defaultTimeInForce");
            timeInForce = GetValue(timeInForceparamsVariable,0);
            params = GetValue(timeInForceparamsVariable,1)
            if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "time_in_force", timeInForce)
            }
            AddElementToObject(request, "client_order_id", this.GenerateClientOrderId(params))
            params = this.Omit(params, []interface{}{"clientOrderId"})
        
            response:= (<-this.TraderPrivatePatchV2OrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id":"6ecfcc34-4bed-4b53-83ba-c564aa832a81",
    //        "client_order_id":"ccxt_1c6ceab0b5e84727b2f1c0394ba17560",
    //        "created_at":"2022-06-14T13:59:30.224037068Z",
    //        "updated_at":"2022-06-14T13:59:30.224037068Z",
    //        "submitted_at":"2022-06-14T13:59:30.221856828Z",
    //        "filled_at":null,
    //        "expired_at":null,
    //        "canceled_at":null,
    //        "failed_at":null,
    //        "replaced_at":null,
    //        "replaced_by":null,
    //        "replaces":null,
    //        "asset_id":"64bbff51-59d6-4b3c-9351-13ad85e3c752",
    //        "symbol":"BTCUSD",
    //        "asset_class":"crypto",
    //        "notional":null,
    //        "qty":"0.01",
    //        "filled_qty":"0",
    //        "filled_avg_price":null,
    //        "order_class":"",
    //        "order_type":"limit",
    //        "type":"limit",
    //        "side":"buy",
    //        "time_in_force":"day",
    //        "limit_price":"14000",
    //        "stop_price":null,
    //        "status":"accepted",
    //        "extended_hours":false,
    //        "legs":null,
    //        "trail_percent":null,
    //        "trail_price":null,
    //        "hwm":null,
    //        "commission":"0.42",
    //        "source":null
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var alpacaStatus interface{} = this.SafeString(order, "status")
    var status interface{} = this.ParseOrderStatus(alpacaStatus)
    var feeValue interface{} = this.SafeString(order, "commission")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeValue, nil)) {
        fee = map[string]interface{} {
            "cost": feeValue,
            "currency": "USD",
        }
    }
    var orderType interface{} = this.SafeString(order, "order_type")
    if IsTrue(!IsEqual(orderType, nil)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(orderType, "limit"), 0)) {
            // might be limit or stop-limit
            orderType = "limit"
        }
    }
    var datetime interface{} = this.SafeString(order, "submitted_at")
    var timestamp interface{} = this.Parse8601(datetime)
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "id"),
        "clientOrderId": this.SafeString(order, "client_order_id"),
        "timestamp": timestamp,
        "datetime": datetime,
        "lastTradeTimeStamp": nil,
        "status": status,
        "symbol": symbol,
        "type": orderType,
        "timeInForce": this.ParseTimeInForce(this.SafeString(order, "time_in_force")),
        "postOnly": nil,
        "side": this.SafeString(order, "side"),
        "price": this.SafeNumber(order, "limit_price"),
        "triggerPrice": this.SafeNumber(order, "stop_price"),
        "cost": nil,
        "average": this.SafeNumber(order, "filled_avg_price"),
        "amount": this.SafeNumber(order, "qty"),
        "filled": this.SafeNumber(order, "filled_qty"),
        "remaining": nil,
        "trades": nil,
        "fee": fee,
        "info": order,
    }, market)
}
func  (this *alpaca) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending_new": "open",
        "accepted": "open",
        "new": "open",
        "partially_filled": "open",
        "activated": "open",
        "filled": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *alpaca) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "day": "Day",
    }
    return this.SafeString(timeInForces, timeInForce, timeInForce)
}
/**
 * @method
 * @name alpaca#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.alpaca.markets/reference/getaccountactivitiesbyactivitytype-1
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {string} [params.page_token] page_token - used for paging
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *alpaca) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14228 := (<-this.LoadMarkets())
            PanicOnError(retRes14228)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "activity_type": "FILL",
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, "until")
                AddElementToObject(request, "until", this.Iso8601(until))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            requestparamsVariable := this.HandleUntilOption("until", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.TraderPrivateGetV2AccountActivitiesActivityType(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": "20221228071929579::ca2aafd0-1270-4b56-b0a9-85423b4a07c8",
            //             "activity_type": "FILL",
            //             "transaction_time": "2022-12-28T12:19:29.579352Z",
            //             "type": "fill",
            //             "price": "67.31",
            //             "qty": "0.07",
            //             "side": "sell",
            //             "symbol": "LTC/USD",
            //             "leaves_qty": "0",
            //             "order_id": "82eebcf7-6e66-4b7e-93f8-be0df0e4f12e",
            //             "cum_qty": "0.07",
            //             "order_status": "filled",
            //             "swap_rate": "1"
            //         },
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //   {
    //       "t":"2022-06-14T05:00:00.027869Z",
    //       "x":"CBSE",
    //       "p":"21942.15",
    //       "s":"0.0001",
    //       "tks":"S",
    //       "i":"355681339"
    //   }
    //
    // fetchMyTrades
    //
    //     {
    //         "id": "20221228071929579::ca2aafd0-1270-4b56-b0a9-85423b4a07c8",
    //         "activity_type": "FILL",
    //         "transaction_time": "2022-12-28T12:19:29.579352Z",
    //         "type": "fill",
    //         "price": "67.31",
    //         "qty": "0.07",
    //         "side": "sell",
    //         "symbol": "LTC/USD",
    //         "leaves_qty": "0",
    //         "order_id": "82eebcf7-6e66-4b7e-93f8-be0df0e4f12e",
    //         "cum_qty": "0.07",
    //         "order_status": "filled",
    //         "swap_rate": "1"
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(trade, "S", "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var datetime interface{} = this.SafeString2(trade, "t", "transaction_time")
    var timestamp interface{} = this.Parse8601(datetime)
    var alpacaSide interface{} = this.SafeString(trade, "tks")
    var side interface{} = this.SafeString(trade, "side")
    if IsTrue(IsEqual(alpacaSide, "B")) {
        side = "buy"
    } else if IsTrue(IsEqual(alpacaSide, "S")) {
        side = "sell"
    }
    var priceString interface{} = this.SafeString2(trade, "p", "price")
    var amountString interface{} = this.SafeString2(trade, "s", "qty")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString2(trade, "i", "id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": this.SafeString(trade, "order_id"),
        "type": nil,
        "side": side,
        "takerOrMaker": "taker",
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name alpaca#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.alpaca.markets/reference/listcryptofundingwallets
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *alpaca) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15368 := (<-this.LoadMarkets())
            PanicOnError(retRes15368)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
            }
        
            response:= (<-this.TraderPrivateGetV2Wallets(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "asset_id": "4fa30c85-77b7-4cbc-92dd-7b7513640aad",
            //         "address": "bc1q2fpskfnwem3uq9z8660e4z6pfv7aqfamysk75r",
            //         "created_at": "2024-11-03T07:30:05.609976344Z"
            //     }
            //
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "asset_id": "4fa30c85-77b7-4cbc-92dd-7b7513640aad",
    //         "address": "bc1q2fpskfnwem3uq9z8660e4z6pfv7aqfamysk75r",
    //         "created_at": "2024-11-03T07:30:05.609976344Z"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var parsedCurrency interface{} = nil
    if IsTrue(!IsEqual(currency, nil)) {
        parsedCurrency = GetValue(currency, "id")
    }
    return map[string]interface{} {
        "info": depositAddress,
        "currency": parsedCurrency,
        "network": nil,
        "address": this.SafeString(depositAddress, "address"),
        "tag": nil,
    }
}
/**
 * @method
 * @name alpaca#withdraw
 * @description make a withdrawal
 * @see https://docs.alpaca.markets/reference/createcryptotransferforaccount
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag a memo for the transaction
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *alpaca) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes15888 := (<-this.LoadMarkets())
            PanicOnError(retRes15888)
            var currency interface{} = this.Currency(code)
            if IsTrue(tag) {
                address = Add(Add(address, ":"), tag)
            }
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "address": address,
                "amount": this.NumberToString(amount),
            }
        
            response:= (<-this.TraderPrivatePostV2WalletsTransfers(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
            //         "tx_hash": null,
            //         "direction": "OUTGOING",
            //         "amount": "20",
            //         "usd_value": "19.99856",
            //         "chain": "ETH",
            //         "asset": "USDT",
            //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
            //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
            //         "status": "PROCESSING",
            //         "created_at": "2024-11-07T02:39:01.775495Z",
            //         "network_fee": "4",
            //         "fees": "0.1"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) FetchTransactionsHelper(typeVar interface{}, code interface{}, since interface{}, limit interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            retRes16208 := (<-this.LoadMarkets())
            PanicOnError(retRes16208)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.TraderPrivateGetV2WalletsTransfers(params))
            PanicOnError(response)
            //
            //     {
            //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
            //         "tx_hash": null,
            //         "direction": "OUTGOING",
            //         "amount": "20",
            //         "usd_value": "19.99856",
            //         "chain": "ETH",
            //         "asset": "USDT",
            //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
            //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
            //         "status": "PROCESSING",
            //         "created_at": "2024-11-07T02:39:01.775495Z",
            //         "network_fee": "4",
            //         "fees": "0.1"
            //     }
            //
            var results interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var direction interface{} = this.SafeString(entry, "direction")
                if IsTrue(IsEqual(direction, typeVar)) {
                    AppendToArray(&results,entry)
                } else if IsTrue(IsEqual(typeVar, "BOTH")) {
                    AppendToArray(&results,entry)
                }
            }
        
            ch <- this.ParseTransactions(results, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *alpaca) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes166815 :=  (<-this.FetchTransactionsHelper("BOTH", code, since, limit, params))
                PanicOnError(retRes166815)
                ch <- retRes166815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposit structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *alpaca) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes168315 :=  (<-this.FetchTransactionsHelper("INCOMING", code, since, limit, params))
                PanicOnError(retRes168315)
                ch <- retRes168315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name alpaca#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.alpaca.markets/reference/listcryptofundingtransfers
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *alpaca) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes169815 :=  (<-this.FetchTransactionsHelper("OUTGOING", code, since, limit, params))
                PanicOnError(retRes169815)
                ch <- retRes169815
                return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "e27b70a6-5610-40d7-8468-a516a284b776",
    //         "tx_hash": null,
    //         "direction": "OUTGOING",
    //         "amount": "20",
    //         "usd_value": "19.99856",
    //         "chain": "ETH",
    //         "asset": "USDT",
    //         "from_address": "0x123930E4dCA196E070d39B60c644C8Aae02f23",
    //         "to_address": "0x1232c0925196e4dcf05945f67f690153190fbaab",
    //         "status": "PROCESSING",
    //         "created_at": "2024-11-07T02:39:01.775495Z",
    //         "network_fee": "4",
    //         "fees": "0.1"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var datetime interface{} = this.SafeString(transaction, "created_at")
    var currencyId interface{} = this.SafeString(transaction, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var fees interface{} = this.SafeString(transaction, "fees")
    var networkFee interface{} = this.SafeString(transaction, "network_fee")
    var totalFee interface{} = Precise.StringAdd(fees, networkFee)
    var fee interface{} = map[string]interface{} {
        "cost": this.ParseNumber(totalFee),
        "currency": code,
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "tx_hash"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "network": this.SafeString(transaction, "chain"),
        "address": this.SafeString(transaction, "to_address"),
        "addressTo": this.SafeString(transaction, "to_address"),
        "addressFrom": this.SafeString(transaction, "from_address"),
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": this.ParseTransactionType(this.SafeString(transaction, "direction")),
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": nil,
        "fee": fee,
        "comment": nil,
        "internal": nil,
    }
}
func  (this *alpaca) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PROCESSING": "pending",
        "FAILED": "failed",
        "COMPLETE": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *alpaca) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "INCOMING": "deposit",
        "OUTGOING": "withdrawal",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name alpaca#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.alpaca.markets/reference/getaccount-1
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *alpaca) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17798 := (<-this.LoadMarkets())
            PanicOnError(retRes17798)
        
            response:= (<-this.TraderPrivateGetV2Account(params))
            PanicOnError(response)
        
                //
            //     {
            //         "id": "43a01bde-4eb1-64fssc26adb5",
            //         "admin_configurations": {
            //             "allow_instant_ach": true,
            //             "max_margin_multiplier": "4"
            //         },
            //         "user_configurations": {
            //             "fractional_trading": true,
            //             "max_margin_multiplier": "4"
            //         },
            //         "account_number": "744873727",
            //         "status": "ACTIVE",
            //         "crypto_status": "ACTIVE",
            //         "currency": "USD",
            //         "buying_power": "5.92",
            //         "regt_buying_power": "5.92",
            //         "daytrading_buying_power": "0",
            //         "effective_buying_power": "5.92",
            //         "non_marginable_buying_power": "5.92",
            //         "bod_dtbp": "0",
            //         "cash": "5.92",
            //         "accrued_fees": "0",
            //         "portfolio_value": "48.6",
            //         "pattern_day_trader": false,
            //         "trading_blocked": false,
            //         "transfers_blocked": false,
            //         "account_blocked": false,
            //         "created_at": "2022-06-13T14:59:18.318096Z",
            //         "trade_suspended_by_user": false,
            //         "multiplier": "1",
            //         "shorting_enabled": false,
            //         "equity": "48.6",
            //         "last_equity": "48.8014266",
            //         "long_market_value": "42.68",
            //         "short_market_value": "0",
            //         "position_market_value": "42.68",
            //         "initial_margin": "0",
            //         "maintenance_margin": "0",
            //         "last_maintenance_margin": "0",
            //         "sma": "5.92",
            //         "daytrade_count": 0,
            //         "balance_asof": "2024-12-10",
            //         "crypto_tier": 1,
            //         "intraday_adjustments": "0",
            //         "pending_reg_taf_fees": "0"
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *alpaca) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var account interface{} = this.Account()
    var currencyId interface{} = this.SafeString(response, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    AddElementToObject(account, "free", this.SafeString(response, "cash"))
    AddElementToObject(account, "total", this.SafeString(response, "equity"))
    AddElementToObject(result, code, account)
    return this.SafeBalance(result)
}
func  (this *alpaca) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), GetValue(api, 0)))
    headers = Ternary(IsTrue((!IsEqual(headers, nil))), headers, map[string]interface{} {})
    if IsTrue(IsEqual(GetValue(api, 1), "private")) {
        this.CheckRequiredCredentials()
        AddElementToObject(headers, "APCA-API-KEY-ID", this.ApiKey)
        AddElementToObject(headers, "APCA-API-SECRET-KEY", this.Secret)
    }
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(GetArrayLength(ObjectKeys(query))) {
        if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
            endpoint = Add(endpoint, Add("?", this.Urlencode(query)))
        } else {
            body = this.Json(query)
            AddElementToObject(headers, "Content-Type", "application/json")
        }
    }
    url = Add(url, endpoint)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *alpaca) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // default error handler
    }
    // {
    //     "code": 40110000,
    //     "message": "request is not authorized"
    // }
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var errorCode interface{} = this.SafeString(response, "code")
    if IsTrue(!IsEqual(code, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    }
    var message interface{} = this.SafeValue(response, "message", nil)
    if IsTrue(!IsEqual(message, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *alpaca) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
