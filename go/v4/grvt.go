package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type GrvtCore struct {
    Exchange

}

func NewGrvtCore() *GrvtCore {
    p := &GrvtCore{}
    setDefaults(p)
    return p
}

func  (this *GrvtCore) Describe() interface{}  {
    var rlOthers interface{} = 40
    var rlOrders interface{} = 20
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "grvt",
        "name": "GRVT",
        "countries": []interface{}{"SG"},
        "rateLimit": 10,
        "certified": false,
        "version": "v1",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createOrder": true,
            "fetchBalance": true,
            "fetchCurrencies": true,
            "fetchDeposits": true,
            "fetchFundingHistory": true,
            "fetchFundingRateHistory": true,
            "fetchLeverages": true,
            "fetchMarginModes": true,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPositions": true,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "setLeverage": true,
            "signIn": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "CI_1_M",
            "3m": "CI_3_M",
            "5m": "CI_5_M",
            "15m": "CI_15_M",
            "30m": "CI_30_M",
            "1h": "CI_1_H",
            "2h": "CI_2_H",
            "4h": "CI_4_H",
            "6h": "CI_6_H",
            "8h": "CI_8_H",
            "12h": "CI_12_H",
            "1d": "CI_1_D",
            "3d": "CI_3_D",
            "5d": "CI_5_D",
            "1w": "CI_1_W",
            "2w": "CI_2_W",
            "3w": "CI_3_W",
            "4w": "CI_4_W",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/67abe346-1273-461a-bd7c-42fa32907c8e",
            "api": map[string]interface{} {
                "privateEdge": "https://edge.grvt.io/",
                "privateTrading": "https://trades.grvt.io/",
                "publicMarket": "https://market-data.grvt.io/",
            },
            "www": "https://grvt.io",
            "referral": "----------------------------------------------------",
            "doc": []interface{}{"https://api-docs.grvt.io/"},
            "fees": "",
        },
        "api": map[string]interface{} {
            "privateEdge": map[string]interface{} {
                "post": map[string]interface{} {
                    "auth/api_key/login": 100,
                },
            },
            "publicMarket": map[string]interface{} {
                "post": map[string]interface{} {
                    "full/v1/instrument": 4,
                    "full/v1/all_instruments": 4,
                    "full/v1/instruments": 4,
                    "full/v1/currency": 12,
                    "full/v1/margin_rules": 12,
                    "full/v1/mini": 4,
                    "full/v1/ticker": 4,
                    "full/v1/book": 12,
                    "full/v1/trade": 12,
                    "full/v1/trade_history": 12,
                    "full/v1/kline": 12,
                    "full/v1/funding": 12,
                },
            },
            "privateTrading": map[string]interface{} {
                "post": map[string]interface{} {
                    "full/v1/create_order": 5,
                    "full/v1/cancel_order": 5,
                    "full/v1/cancel_on_disconnect": 100,
                    "full/v1/cancel_all_orders": 50,
                    "full/v1/order": rlOrders,
                    "full/v1/order_history": rlOrders,
                    "full/v1/open_orders": rlOrders,
                    "full/v1/fill_history": rlOrders,
                    "full/v1/positions": rlOrders,
                    "full/v1/funding_payment_history": rlOthers,
                    "full/v1/account_summary": rlOthers,
                    "full/v1/account_history": rlOthers,
                    "full/v1/aggregated_account_summary": rlOthers,
                    "full/v1/funding_account_summary": rlOthers,
                    "full/v1/transfer": 100,
                    "full/v1/deposit_history": 100,
                    "full/v1/transfer_history": 100,
                    "full/v1/withdrawal": 100,
                    "full/v1/withdrawal_history": 100,
                    "full/v1/add_position_margin": rlOthers,
                    "full/v1/get_position_margin_limits": rlOthers,
                    "full/v1/set_position_config": rlOthers,
                    "full/v1/set_initial_leverage": rlOthers,
                    "full/v1/get_all_initial_leverage": rlOthers,
                    "full/v1/set_derisk_mm_ratio": rlOthers,
                    "full/v1/vault_burn_tokens": rlOthers,
                    "full/v1/vault_invest": rlOthers,
                    "full/v1/vault_investor_summary": rlOthers,
                    "full/v1/vault_redeem": rlOthers,
                    "full/v1/vault_redeem_cancel": rlOthers,
                    "full/v1/vault_view_redemption_queue": rlOthers,
                    "full/v1/vault_manager_investor_history": rlOthers,
                    "full/v1/authorize_builder": rlOthers,
                    "full/v1/get_authorized_builders": rlOthers,
                    "full/v1/builder_fill_history": rlOthers,
                },
            },
        },
        "options": map[string]interface{} {
            "accountId": nil,
            "networks": map[string]interface{} {
                "ARBONE": "42161",
                "AVAXC": "43114",
                "BASE": "8453",
                "BSC": "56",
                "ETH": "1",
                "ERC20": "1",
                "OP": "10",
                "SOL": "900",
                "TRX": "728126428",
                "ZKSYNCERA": "324",
            },
            "networksById": map[string]interface{} {
                "1": "ERC20",
            },
            "builderFee": true,
            "builder": "0x21d2a053495994b1132a38cd1171acec40c6741e",
            "builderRate": 0.01,
        },
        "precisionMode": TICK_SIZE,
        "quoteJsonNumbers": false,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "1000": AuthenticationError,
                "1001": PermissionDenied,
                "1002": OperationFailed,
                "1003": BadRequest,
                "1004": OperationRejected,
                "1005": OperationFailed,
                "1006": RateLimitExceeded,
                "1008": PermissionDenied,
                "1009": OperationRejected,
                "1012": BadRequest,
                "1400": PermissionDenied,
                "2000": PermissionDenied,
                "2001": InvalidNonce,
                "2002": BadRequest,
                "2003": PermissionDenied,
                "2004": InvalidNonce,
                "2005": BadRequest,
                "2006": BadRequest,
                "2007": BadRequest,
                "2008": BadRequest,
                "2010": InvalidOrder,
                "2011": InvalidOrder,
                "2012": InvalidOrder,
                "2020": InvalidOrder,
                "2021": InvalidOrder,
                "2030": InvalidOrder,
                "2031": InvalidOrder,
                "2032": InvalidOrder,
                "2040": InvalidOrder,
                "2041": InvalidOrder,
                "2042": InvalidOrder,
                "2050": InvalidOrder,
                "2051": InvalidOrder,
                "2060": BadSymbol,
                "2061": BadSymbol,
                "2062": InvalidOrder,
                "2063": InvalidOrder,
                "2064": InvalidOrder,
                "2065": InvalidOrder,
                "2070": InvalidOrder,
                "2080": InsufficientFunds,
                "2081": OperationRejected,
                "2082": InvalidOrder,
                "2083": OperationRejected,
                "2090": RateLimitExceeded,
                "2100": BadRequest,
                "2101": BadRequest,
                "2102": OperationRejected,
                "2103": OperationRejected,
                "2104": BadRequest,
                "2105": BadRequest,
                "2107": BadRequest,
                "2108": BadRequest,
                "2110": InvalidOrder,
                "2111": InvalidOrder,
                "2112": InvalidOrder,
                "2113": InvalidOrder,
                "2114": InvalidOrder,
                "2115": InvalidOrder,
                "2116": InvalidOrder,
                "2117": InvalidOrder,
                "2300": OperationRejected,
                "2301": OperationRejected,
                "2400": OperationRejected,
                "2401": OperationRejected,
                "2402": OperationRejected,
                "3000": BadSymbol,
                "3004": OperationRejected,
                "3005": OperationRejected,
                "3006": OperationRejected,
                "3021": BadRequest,
                "3031": BadRequest,
                "4000": InsufficientFunds,
                "4002": OperationFailed,
                "4010": OperationRejected,
                "5000": OperationRejected,
                "5001": OperationRejected,
                "5002": OperationRejected,
                "5003": OperationRejected,
                "5004": OperationRejected,
                "5005": OperationRejected,
                "6000": OperationRejected,
                "6100": OperationRejected,
                "7000": OperationRejected,
                "7001": InsufficientFunds,
                "7002": OperationFailed,
                "7003": OperationRejected,
                "7004": OperationRejected,
                "7005": InsufficientFunds,
                "7006": OperationFailed,
                "7007": PermissionDenied,
                "7100": OperationFailed,
                "7101": OperationRejected,
                "7102": OperationRejected,
                "7103": OperationRejected,
                "7450": OperationRejected,
                "7451": OperationRejected,
                "7452": OperationRejected,
                "7453": OperationRejected,
                "7454": OperationRejected,
                "7455": OperationRejected,
                "7500": OperationRejected,
                "7501": BadRequest,
                "7502": OperationRejected,
                "7503": OperationRejected,
                "7504": OperationRejected,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *GrvtCore) EipDefinitions() interface{}  {
    return map[string]interface{} {
        "EIP712_ORDER_TYPE": map[string]interface{} {
            "Order": []interface{}{map[string]interface{} {
    "name": "subAccountID",
    "type": "uint64",
}, map[string]interface{} {
    "name": "isMarket",
    "type": "bool",
}, map[string]interface{} {
    "name": "timeInForce",
    "type": "uint8",
}, map[string]interface{} {
    "name": "postOnly",
    "type": "bool",
}, map[string]interface{} {
    "name": "reduceOnly",
    "type": "bool",
}, map[string]interface{} {
    "name": "legs",
    "type": "OrderLeg[]",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint32",
}, map[string]interface{} {
    "name": "expiration",
    "type": "int64",
}},
            "OrderLeg": []interface{}{map[string]interface{} {
    "name": "assetID",
    "type": "uint256",
}, map[string]interface{} {
    "name": "contractSize",
    "type": "uint64",
}, map[string]interface{} {
    "name": "limitPrice",
    "type": "uint64",
}, map[string]interface{} {
    "name": "isBuyingContract",
    "type": "bool",
}},
        },
        "EIP712_ORDER_WITH_BUILDER_TYPE": map[string]interface{} {
            "OrderWithBuilderFee": []interface{}{map[string]interface{} {
    "name": "subAccountID",
    "type": "uint64",
}, map[string]interface{} {
    "name": "isMarket",
    "type": "bool",
}, map[string]interface{} {
    "name": "timeInForce",
    "type": "uint8",
}, map[string]interface{} {
    "name": "postOnly",
    "type": "bool",
}, map[string]interface{} {
    "name": "reduceOnly",
    "type": "bool",
}, map[string]interface{} {
    "name": "legs",
    "type": "OrderLeg[]",
}, map[string]interface{} {
    "name": "builder",
    "type": "address",
}, map[string]interface{} {
    "name": "builderFee",
    "type": "uint32",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint32",
}, map[string]interface{} {
    "name": "expiration",
    "type": "int64",
}},
            "OrderLeg": []interface{}{map[string]interface{} {
    "name": "assetID",
    "type": "uint256",
}, map[string]interface{} {
    "name": "contractSize",
    "type": "uint64",
}, map[string]interface{} {
    "name": "limitPrice",
    "type": "uint64",
}, map[string]interface{} {
    "name": "isBuyingContract",
    "type": "bool",
}},
        },
        "EIP712_TRANSFER_TYPE": map[string]interface{} {
            "Transfer": []interface{}{map[string]interface{} {
    "name": "fromAccount",
    "type": "address",
}, map[string]interface{} {
    "name": "fromSubAccount",
    "type": "uint64",
}, map[string]interface{} {
    "name": "toAccount",
    "type": "address",
}, map[string]interface{} {
    "name": "toSubAccount",
    "type": "uint64",
}, map[string]interface{} {
    "name": "tokenCurrency",
    "type": "uint8",
}, map[string]interface{} {
    "name": "numTokens",
    "type": "uint64",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint32",
}, map[string]interface{} {
    "name": "expiration",
    "type": "int64",
}},
        },
        "EIP712_WITHDRAWAL_TYPE": map[string]interface{} {
            "Withdrawal": []interface{}{map[string]interface{} {
    "name": "fromAccount",
    "type": "address",
}, map[string]interface{} {
    "name": "toEthAddress",
    "type": "address",
}, map[string]interface{} {
    "name": "tokenCurrency",
    "type": "uint8",
}, map[string]interface{} {
    "name": "numTokens",
    "type": "uint64",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint32",
}, map[string]interface{} {
    "name": "expiration",
    "type": "int64",
}},
        },
        "EIP712_BUILDER_APPROVAL_TYPE": map[string]interface{} {
            "AuthorizeBuilder": []interface{}{map[string]interface{} {
    "name": "mainAccountID",
    "type": "address",
}, map[string]interface{} {
    "name": "builderAccountID",
    "type": "address",
}, map[string]interface{} {
    "name": "maxFutureFeeRate",
    "type": "uint32",
}, map[string]interface{} {
    "name": "maxSpotFeeRate",
    "type": "uint32",
}, map[string]interface{} {
    "name": "nonce",
    "type": "uint32",
}, map[string]interface{} {
    "name": "expiration",
    "type": "int64",
}},
        },
    }
}
func  (this *GrvtCore) LoadMarketsAndSignIn() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
        retRes3768 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.SignIn()}))
        PanicOnError(retRes3768)
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name grvt#signIn
 * @description sign in, must be called prior to using other authenticated methods
 * @see https://api-docs.grvt.io/#authentication
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns response from exchange
 */
func  (this *GrvtCore) SignIn(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // await this.sleep (10); // temporary workaround for allowing promise-all to prioritize loadMarkets
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var now interface{} = this.Milliseconds()
            // expires in 24 hours as CS suggested
            var expires interface{} = this.SafeInteger(this.Options, "signInExpiration", 0)
            // if previous sign-in not expired (give 10 seconds margin)
            if IsTrue(IsTrue(!IsEqual(expires, nil)) && IsTrue(IsGreaterThan(expires, Add(now, 10000)))) {
        
                return nil
            }
            var request interface{} = map[string]interface{} {
                "api_key": this.ApiKey,
            }
        
            response:= (<-this.PrivateEdgePostAuthApiKeyLogin(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "location": "",
            //        "status": "success"
            //    }
            //
            AddElementToObject(this.Options, "signInExpiration", Add(now, 86400000)) // 24 hours
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#fetchMarkets
 * @description retrieves data on all markets
 * @see https://api-docs.grvt.io/market_data_api/#get-instrument-prod
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *GrvtCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicMarketPostFullV1AllInstruments(params))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "instrument": "AAVE_USDT_Perp",
            //                "instrument_hash": "0x032201",
            //                "base": "AAVE",
            //                "quote": "USDT",
            //                "kind": "PERPETUAL",
            //                "venues": [
            //                    "ORDERBOOK",
            //                    "RFQ"
            //                ],
            //                "settlement_period": "PERPETUAL",
            //                "base_decimals": "9",
            //                "quote_decimals": "6",
            //                "tick_size": "0.01",
            //                "min_size": "0.1",
            //                "create_time": "1764303867576216941",
            //                "max_position_size": "3000.0",
            //                "funding_interval_hours": "8",
            //                "adjusted_funding_rate_cap": "0.75",
            //                "adjusted_funding_rate_floor": "-0.75"
            //            },
            //            ...
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseMarkets(result)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseMarket(market interface{}) interface{}  {
    //
    //    {
    //        "instrument": "BTC_USDT_Perp",
    //        "instrument_hash": "0x030501",
    //        "base": "BTC",
    //        "quote": "USDT",
    //        "kind": "PERPETUAL",
    //        "venues": [
    //            "ORDERBOOK",
    //            "RFQ"
    //        ],
    //        "settlement_period": "PERPETUAL",
    //        "base_decimals": 9,
    //        "quote_decimals": 6,
    //        "tick_size": "0.1",
    //        "min_size": "0.001",
    //        "create_time": "1768040726362828205",
    //        "max_position_size": "1000.0",
    //        "funding_interval_hours": 8,
    //        "adjusted_funding_rate_cap": "0.3",
    //        "adjusted_funding_rate_floor": "-0.3",
    //        "min_notional": "100.0"
    //    }
    //
    var marketId interface{} = this.SafeString(market, "instrument")
    var baseId interface{} = this.SafeString(market, "base")
    var quoteId interface{} = this.SafeString(market, "quote")
    var settleId interface{} = quoteId
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
    var typeVar interface{} = nil
    var typeRaw interface{} = this.SafeString(market, "kind")
    if IsTrue(IsEqual(typeRaw, "PERPETUAL")) {
        typeVar = "swap"
    }
    var isSpot interface{} =     (IsEqual(typeVar, "spot"))
    var isSwap interface{} =     (IsEqual(typeVar, "swap"))
    var isFuture interface{} =     (IsEqual(typeVar, "future"))
    var isContract interface{} = IsTrue(isSwap) || IsTrue(isFuture)
    return map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": typeVar,
        "spot": isSpot,
        "margin": false,
        "swap": isSwap,
        "future": isFuture,
        "option": false,
        "active": nil,
        "contract": isContract,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "min_size"),
            "price": this.SafeNumber(market, "tick_size"),
            "base": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "base_decimals"))),
            "quote": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quote_decimals"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "min_size"),
                "max": this.SafeNumber(market, "max_position_size"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_notional"),
                "max": nil,
            },
        },
        "created": this.SafeIntegerProduct(market, "create_time", 0.000001),
        "info": market,
    }
}
/**
 * @method
 * @name grvt#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api-docs.grvt.io/market_data_api/#get-currency-response
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *GrvtCore) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicMarketPostFullV1Currency(params))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "id": "4",
            //                "symbol": "ETH",
            //                "balance_decimals": "9",
            //                "quantity_multiplier": "1000000000"
            //            },
            //            ..
            //
            var responseResult interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseCurrencies(responseResult)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseCurrency(rawCurrency interface{}) interface{}  {
    //
    //            {
    //                "id": "4",
    //                "symbol": "ETH",
    //                "balance_decimals": "9",
    //                "quantity_multiplier": "1000000000"
    //            },
    //
    var id interface{} = this.SafeString(rawCurrency, "symbol")
    var code interface{} = this.SafeCurrencyCode(id)
    return this.SafeCurrencyStructure(map[string]interface{} {
        "info": rawCurrency,
        "id": id,
        "code": code,
        "name": nil,
        "active": nil,
        "deposit": nil,
        "withdraw": nil,
        "fee": nil,
        "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(rawCurrency, "balance_decimals"))),
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "deposit": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "type": "crypto",
        "networks": nil,
        "numericId": this.SafeInteger(rawCurrency, "id"),
    })
}
/**
 * @method
 * @name grvt#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.grvt.io/market_data_api/#ticker_1
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *GrvtCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6228 := (<-this.LoadMarkets())
            PanicOnError(retRes6228)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": this.MarketId(symbol),
            }
        
            response:= (<-this.PublicMarketPostFullV1Ticker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "event_time": "1764774730025055205",
            //            "instrument": "BTC_USDT_Perp",
            //            "mark_price": "92697.300078773",
            //            "index_price": "92727.818122278",
            //            "last_price": "92683.0",
            //            "last_size": "0.001",
            //            "mid_price": "92682.95",
            //            "best_bid_price": "92682.9",
            //            "best_bid_size": "5.332",
            //            "best_ask_price": "92683.0",
            //            "best_ask_size": "0.009",
            //            "funding_rate_8h_curr": "0.0037",
            //            "funding_rate_8h_avg": "0.0037",
            //            "interest_rate": "0.0",
            //            "forward_price": "0.0",
            //            "buy_volume_24h_b": "2893.898",
            //            "sell_volume_24h_b": "2907.847",
            //            "buy_volume_24h_q": "266955739.1606",
            //            "sell_volume_24h_q": "268170211.7109",
            //            "high_price": "93908.3",
            //            "low_price": "89900.1",
            //            "open_price": "90129.2",
            //            "open_interest": "1523.218935908",
            //            "long_short_ratio": "1.472543",
            //            "funding_rate": "0.0037",
            //            "next_funding_time": "1764777600000000000"
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTicker(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  {
    //            "event_time": "1764774730025055205",
    //            "instrument": "BTC_USDT_Perp",
    //            "mark_price": "92697.300078773",
    //            "index_price": "92727.818122278",
    //            "last_price": "92683.0",
    //            "last_size": "0.001",
    //            "mid_price": "92682.95",
    //            "best_bid_price": "92682.9",
    //            "best_bid_size": "5.332",
    //            "best_ask_price": "92683.0",
    //            "best_ask_size": "0.009",
    //            "funding_rate_8h_curr": "0.0037",
    //            "funding_rate_8h_avg": "0.0037",
    //            "interest_rate": "0.0",
    //            "forward_price": "0.0",
    //            "buy_volume_24h_b": "2893.898",
    //            "sell_volume_24h_b": "2907.847",
    //            "buy_volume_24h_q": "266955739.1606",
    //            "sell_volume_24h_q": "268170211.7109",
    //            "high_price": "93908.3",
    //            "low_price": "89900.1",
    //            "open_price": "90129.2",
    //            "open_interest": "1523.218935908",
    //            "long_short_ratio": "1.472543",
    //            "funding_rate": "0.0037",
    //            "next_funding_time": "1764777600000000000"
    //        }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instrument")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeSymbol(marketId, market),
        "open": this.SafeString(ticker, "open_price"),
        "high": this.SafeString(ticker, "high_price"),
        "low": this.SafeString(ticker, "low_price"),
        "last": this.SafeString(ticker, "last_price"),
        "bid": this.SafeString(ticker, "best_bid_price"),
        "bidVolume": this.SafeString(ticker, "best_bid_size"),
        "ask": this.SafeString(ticker, "best_ask_price"),
        "askVolume": this.SafeString(ticker, "best_ask_size"),
        "change": nil,
        "percentage": nil,
        "baseVolume": this.SafeString(ticker, "buy_volume_24h_b"),
        "quoteVolume": this.SafeString(ticker, "buy_volume_24h_q"),
        "markPrice": this.SafeString(ticker, "mark_price"),
        "indexPrice": this.SafeString(ticker, "index_price"),
        "vwap": nil,
        "average": nil,
        "previousClose": nil,
    })
}
/**
 * @method
 * @name grvt#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.grvt.io/market_data_api/#orderbook-levels
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func  (this *GrvtCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7318 := (<-this.LoadMarkets())
            PanicOnError(retRes7318)
            var request interface{} = map[string]interface{} {
                "instrument": this.MarketId(symbol),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            }
            if IsTrue(IsLessThanOrEqual(limit, 500)) {
                AddElementToObject(request, "depth", this.FindNearestCeiling([]interface{}{10, 50, 100, 500}, limit))
            }
        
            response:= (<-this.PublicMarketPostFullV1Book(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "event_time": "1764777396650000000",
            //            "instrument": "BTC_USDT_Perp",
            //            "bids": [
            //                { "price": "92336.0", "size": "0.005", "num_orders": "1" },
            //                ...
            //            ],
            //            "asks": [
            //                { "price": "92336.1", "size": "5.711", "num_orders": "37" },
            //                ...
            //            ]
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var timestamp interface{} = this.Parse8601(this.SafeString(result, "event_time"))
            var marketId interface{} = this.SafeString(result, "instrument")
        
            ch <- this.ParseOrderBook(result, this.SafeSymbol(marketId), timestamp, "bids", "asks", "price", "size")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs.grvt.io/market_data_api/#trade_1
 * @param {string} symbol unified symbol of the market
 * @param {int} [since] timestamp in ms of the earliest item to fetch
 * @param {int} [limit] the maximum amount of items to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *GrvtCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7778 := (<-this.LoadMarkets())
            PanicOnError(retRes7778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PublicMarketPostFullV1TradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "next": "eyJ0cmFkZUlkIjo2NDc5MTAyMywidHJhZGVJbmRleCI6MX0",
            //        "result": [
            //            {
            //                "event_time": "1764779531332118705",
            //                "instrument": "ETH_USDT_Perp",
            //                "is_taker_buyer": false,
            //                "size": "23.73",
            //                "price": "3089.88",
            //                "mark_price": "3089.360002315",
            //                "index_price": "3090.443723246",
            //                "interest_rate": "0.0",
            //                "forward_price": "0.0",
            //                "trade_id": "64796657-1",
            //                "venue": "ORDERBOOK",
            //                "is_rpi": false
            //            },
            //            ...
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //            {
    //                "event_time": "1764779531332118705",
    //                "instrument": "ETH_USDT_Perp",
    //                "size": "23.73",
    //                "price": "3089.88",
    //                "is_rpi": false,
    //                "mark_price": "3089.360002315",
    //                "index_price": "3090.443723246",
    //                "interest_rate": "0.0",
    //                "forward_price": "0.0",
    //                "trade_id": "64796657-1",
    //                "venue": "ORDERBOOK",
    //                "is_taker_buyer": false
    //            }
    //
    // fetchMyTrades
    //
    //            {
    //                "event_time": "1764945709702747558",
    //                "instrument": "BTC_USDT_Perp",
    //                "size": "0.001",
    //                "price": "90000.0",
    //                "is_rpi": false
    //                "mark_price": "90050.164063298",
    //                "index_price": "90089.803654938",
    //                "interest_rate": "0.0",
    //                "forward_price": "0.0",
    //                "trade_id": "65424692-2",
    //                "venue": "ORDERBOOK",
    //                "is_buyer": true,
    //                "is_taker": false,
    //                "broker": "UNSPECIFIED",
    //                "realized_pnl": "0.0",
    //                "fee": "-0.00009",
    //                "fee_rate": "0.0",
    //                "order_id": "0x01010105034cddc7000000006621285c",
    //                "client_order_id": "1375879248",
    //                "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
    //                "sub_account_id": "2147050003876484",
    //            }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "instrument")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeIntegerProduct(trade, "event_time", 0.000001)
    var takerOrMaker interface{} = nil
    var isTakerBuyer interface{} = this.SafeBool(trade, "is_taker_buyer")
    var side interface{} = nil
    if IsTrue(!IsEqual(isTakerBuyer, nil)) {
        side = Ternary(IsTrue(isTakerBuyer), "buy", "sell")
        takerOrMaker = "taker"
    } else {
        takerOrMaker = Ternary(IsTrue(this.SafeBool(trade, "is_taker")), "taker", "maker")
        side = Ternary(IsTrue(this.SafeBool(trade, "is_buyer")), "buy", "sell")
    }
    var fee interface{} = nil
    var feeString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeString, nil)) {
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeString),
            "currency": GetValue(market, "quote"),
            "rate": this.SafeNumber(trade, "fee_rate"),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "trade_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "size"),
        "cost": nil,
        "fee": fee,
        "order": this.SafeString(trade, "order_id"),
    }, market)
}
/**
 * @method
 * @name grvt#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.grvt.io/market_data_api/#candlestick_1
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest item to fetch
 * @param {int} [limit] the maximum amount of items to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *GrvtCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var maxLimit interface{} = 1000
        
            retRes9138 := (<-this.LoadMarkets())
            PanicOnError(retRes9138)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes91719 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
                    PanicOnError(retRes91719)
                    ch <- retRes91719
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var priceTypeMap interface{} = map[string]interface{} {
                "last": "TRADE",
                "mark": "MARK",
                "index": "INDEX",
            }
            var selectedPriceType interface{} = this.SafeString(params, "priceType", "last")
            AddElementToObject(request, "type", this.SafeString(priceTypeMap, selectedPriceType))
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PublicMarketPostFullV1Kline(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "open_time": "1767288240000000000",
            //                "close_time": "1767288300000000000",
            //                "open": "88178.8",
            //                "close": "88176.7",
            //                "high": "88192.7",
            //                "low": "88176.6",
            //                "volume_b": "15.32",
            //                "volume_q": "1350962.4782",
            //                "trades": 38,
            //                "instrument": "BTC_USDT_Perp"
            //            },
            //        ],
            //        "next": "eyJvcGVuVGltZSI6MTc2NzI1ODMwMDAwMDAwMDAwMH0"
            //    }
            //
            var candles interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //            {
    //                "open_time": "1767288240000000000",
    //                "close_time": "1767288300000000000",
    //                "open": "88178.8",
    //                "close": "88176.7",
    //                "high": "88192.7",
    //                "low": "88176.6",
    //                "volume_b": "15.32",
    //                "volume_q": "1350962.4782",
    //                "trades": 38,
    //                "instrument": "BTC_USDT_Perp"
    //            }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeIntegerProduct(ohlcv, "open_time", 0.000001), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume_b")}
}
/**
 * @method
 * @name grvt#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://api-docs.grvt.io/market_data_api/#funding-rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *GrvtCore) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes10058 := (<-this.LoadMarkets())
            PanicOnError(retRes10058)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes100919 :=  (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params))
                    PanicOnError(retRes100919)
                    ch <- retRes100919
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PublicMarketPostFullV1Funding(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "instrument": "BTC_USDT_Perp",
            //                "funding_rate": "-0.0034",
            //                "funding_time": "1760494260000000000",
            //                "mark_price": "112721.159060304",
            //                "funding_rate_8_h_avg": "-0.0038",
            //                "funding_interval_hours": "0"
            //            },
            //            ...
            //        ],
            //        "next": "eyJmdW5kaW5nVGltZSI6MTc2MDQ5NDI2MDAwMDAwMDAwMH0"
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseFundingRateHistories(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseFundingRateHistory(rawItem interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //            {
    //                "instrument": "BTC_USDT_Perp",
    //                "funding_rate": "-0.0034",
    //                "funding_time": "1760494260000000000",
    //                "mark_price": "112721.159060304",
    //                "funding_rate_8_h_avg": "-0.0038",
    //                "funding_interval_hours": "0"
    //            },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(rawItem, "instrument")
    var ts interface{} = this.SafeIntegerProduct(rawItem, "funding_time", 0.000001)
    return map[string]interface{} {
        "info": rawItem,
        "symbol": this.SafeSymbol(marketId, market),
        "fundingRate": this.SafeNumber(rawItem, "funding_rate"),
        "timestamp": ts,
        "datetime": this.Iso8601(ts),
    }
}
func  (this *GrvtCore) GetSubAccountId(params interface{}) interface{}  {
    var subAccountId interface{} = nil
    subAccountIdparamsVariable := this.HandleOptionAndParams(params, nil, "accountId");
    subAccountId = GetValue(subAccountIdparamsVariable,0);
    params = GetValue(subAccountIdparamsVariable,1)
    if IsTrue(IsEqual(subAccountId, nil)) {
        panic(ArgumentsRequired(Add(this.Id, " you should set params[\"accountId\"] = \"YOUR_TRADING_ACCOUNT_ID\", which can be found in the API-KEYS page")))
    }
    return ToString(subAccountId)
}
/**
 * @method
 * @name grvt#fetchBalance
 * @description query for account info
 * @see https://api-docs.grvt.io/trading_api/#sub-account-summary
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *GrvtCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10838 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes10838)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
        
            response:= (<-this.PrivateTradingPostFullV1AccountSummary(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "event_time": "1764863116142428457",
            //            "sub_account_id": "2147050003876484",
            //            "margin_type": "SIMPLE_CROSS_MARGIN",
            //            "settle_currency": "USDT",
            //            "unrealized_pnl": "0.0",
            //            "total_equity": "15.0",
            //            "initial_margin": "0.0",
            //            "maintenance_margin": "0.0",
            //            "available_balance": "15.0",
            //            "spot_balances": [
            //                {
            //                    "currency": "USDT",
            //                    "balance": "15.0",
            //                    "index_price": "1.000289735"
            //                }
            //            ],
            //            "positions": [],
            //            "settle_index_price": "1.000289735",
            //            "derisk_margin": "0.0",
            //            "derisk_to_maintenance_margin_ratio": "1.0",
            //            "total_cross_equity": "15.0",
            //            "cross_unrealized_pnl": "0.0"
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseBalance(response interface{}) interface{}  {
    //
    //        {
    //            "event_time": "1764863116142428457",
    //            "sub_account_id": "2147050003876484",
    //            "margin_type": "SIMPLE_CROSS_MARGIN",
    //            "settle_currency": "USDT",
    //            "unrealized_pnl": "0.0",
    //            "total_equity": "15.0",
    //            "initial_margin": "0.0",
    //            "maintenance_margin": "0.0",
    //            "available_balance": "15.0",
    //            "spot_balances": [
    //                {
    //                    "currency": "USDT",
    //                    "balance": "15.0",
    //                    "index_price": "1.000289735"
    //                }
    //            ],
    //            "positions": [],
    //            "settle_index_price": "1.000289735",
    //            "derisk_margin": "0.0",
    //            "derisk_to_maintenance_margin_ratio": "1.0",
    //            "total_cross_equity": "15.0",
    //            "cross_unrealized_pnl": "0.0"
    //        }
    //
    var timestamp interface{} = this.SafeIntegerProduct(response, "event_time", 0.000001)
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var spotBalances interface{} = this.SafeList(response, "spot_balances", []interface{}{})
    var availableBalance interface{} = this.SafeString(response, "available_balance")
    for i := 0; IsLessThan(i, GetArrayLength(spotBalances)); i++ {
        var balance interface{} = GetValue(spotBalances, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(account, "free", availableBalance) // todo: revise after API team clarification
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name grvt#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://api-docs.grvt.io/trading_api/#transfer
 * @param {string} [code] unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *GrvtCore) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11808 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes11808)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", []interface{}{GetValue(currency, "code")})
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
            var useTransfersEndpoint interface{} = this.SafeBool(this.Options, "useTransfersEndpointForDepositsWithdrawals", true)
            if IsTrue(useTransfersEndpoint) {
        
                transfers:= (<-this.InternalFetchTransfers(this.Extend(request, params), currency, since, limit))
                PanicOnError(transfers)
                var filteredResults interface{} = this.FilterTransfersByType(transfers, "deposit", true)
                var transactions interface{} = this.GetListFromObjectValues(GetValue(filteredResults, 0), "info")
        
                ch <- this.ParseTransactions(transactions, currency, since, limit)
                return nil
            } else {
        
                response:= (<-this.PrivateTradingPostFullV1DepositHistory(this.Extend(request, params)))
                PanicOnError(response)
                //
                // {
                //     "result": [{
                //         "l_1_hash": "0x10000101000203040506",
                //         "l_2_hash": "0x10000101000203040506",
                //         "to_account_id": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
                //         "currency": "USDT",
                //         "num_tokens": "1500.0",
                //         "initiated_time": "1697788800000000000",
                //         "confirmed_time": "1697788800000000000",
                //         "from_address": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0"
                //     }],
                //     "next": "Qw0918="
                // }
                //
                var result interface{} = this.SafeList(response, "result", []interface{}{})
        
                ch <- this.ParseTransactions(result, currency, since, limit)
                return nil
            }
        
            }()
            return ch
        }
/**
 * @method
 * @name grvrt#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.backpack.exchange/#tag/Capital/operation/get_withdrawals
 * @param {string} [code] unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *GrvtCore) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12358 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes12358)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(IsEqual(code, nil)) {
                AddElementToObject(request, "currency", nil)
            } else {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", []interface{}{GetValue(currency, "code")})
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
            var useTransfersEndpoint interface{} = this.SafeBool(this.Options, "useTransfersEndpointForDepositsWithdrawals", true)
            if IsTrue(useTransfersEndpoint) {
        
                transfers:= (<-this.InternalFetchTransfers(this.Extend(request, params), currency, since, limit))
                PanicOnError(transfers)
                var filteredResults interface{} = this.FilterTransfersByType(transfers, "withdrawal", true)
                var transactions interface{} = this.GetListFromObjectValues(GetValue(filteredResults, 0), "info")
        
                ch <- this.ParseTransactions(transactions, currency, since, limit)
                return nil
            } else {
        
                response:= (<-this.PrivateTradingPostFullV1WithdrawalHistory(this.Extend(request, params)))
                PanicOnError(response)
                //
                // {
                //     "result": [{
                //         "tx_id": "1028403",
                //         "from_account_id": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
                //         "to_eth_address": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
                //         "currency": "USDT",
                //         "num_tokens": "1500.0",
                //         "signature": {
                //             "signer": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
                //             "r": "0xb788d96fee91c7cdc35918e0441b756d4000ec1d07d900c73347d9abbc20acc8",
                //             "s": "0x3d786193125f7c29c958647da64d0e2875ece2c3f845a591bdd7dae8c475e26d",
                //             "v": 28,
                //             "expiration": "1697788800000000000",
                //             "nonce": 1234567890,
                //             "chain_id": "325"
                //         },
                //         "event_time": "1697788800000000000",
                //         "l_1_hash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                //         "l_2_hash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
                //     }],
                //     "next": "Qw0918="
                // }
                //
                var result interface{} = this.SafeList(response, "result", []interface{}{})
        
                ch <- this.ParseTransactions(result, currency, since, limit)
                return nil
            }
        
            }()
            return ch
        }
func  (this *GrvtCore) InternalFetchTransfers(req interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    currency := GetArg(optionalArgs, 0, nil)
            _ = currency
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
        
            response:= (<-this.PrivateTradingPostFullV1TransferHistory(req))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "tx_id": "65119836",
            //                "from_account_id": "0xc451b0191351ce308fdfd779d73814c910fc5ecb",
            //                "from_sub_account_id": "0",
            //                "to_account_id": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
            //                "to_sub_account_id": "0",
            //                "currency": "USDT",
            //                "num_tokens": "4.998",
            //                "signature": {
            //                    "signer": "0xf4fdbaf9655bfd607098f4f887aaca58c9667203",
            //                    "r": "0x5f780b99e5e8516f85e66af49b469eeeeeee724290d7f49f1e84b25ad038fa81",
            //                    "s": "0x66c76fdb37a25db8c6b368625d96ee91ab1ffca1786d84dc806b08d1460e97bc",
            //                    "v": "27",
            //                    "expiration": "1767455807929000000",
            //                    "nonce": "45905",
            //                    "chain_id": "0"
            //                },
            //                "event_time": "1764863808817370541",
            //                "transfer_type": "NON_NATIVE_BRIDGE_DEPOSIT",
            //                "transfer_metadata": "{\\"provider\\":\\"rhino\\",\\"direction\\":\\"deposit\\",\\"chainid\\":\\"8453\\",\\"endpoint\\":\\"0x01b89ac919ead1bd513b548962075137c683b9ab\\",\\"provider_tx_id\\":\\"0x1dff8c839f8e21b5af7e121a1ae926017e734aafe8c4ae9942756b3091793b4f\\",\\"provider_ref_id\\":\\"6931aefa5f1ab6fcf0d2f856\\"}"
            //            },
            //            ...
            //        ],
            //        "next": ""
            //    }
            //
            var rows interface{} = this.SafeList(response, "result", []interface{}{})
            var transfers interface{} = this.ParseTransfers(rows, currency, since, limit)
        
            ch <- transfers
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //    {
    //         "l_1_hash": "0x10000101000203040506",
    //         "l_2_hash": "0x10000101000203040506",
    //         "to_account_id": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
    //         "currency": "USDT",
    //         "num_tokens": "1500.0",
    //         "initiated_time": "1697788800000000000",
    //         "confirmed_time": "1697788800000000000",
    //         "from_address": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0"
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "tx_id": "1028403",
    //         "from_account_id": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
    //         "to_eth_address": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
    //         "currency": "USDT",
    //         "num_tokens": "1500.0",
    //         "signature": {
    //             "signer": "0xc73c0c2538fd9b833d20933ccc88fdaa74fcb0d0",
    //             "r": "0xb788d96fee91c7cdc35918e0441b756d4000ec1d07d900c73347d9abbc20acc8",
    //             "s": "0x3d786193125f7c29c958647da64d0e2875ece2c3f845a591bdd7dae8c475e26d",
    //             "v": 28,
    //             "expiration": "1697788800000000000",
    //             "nonce": 1234567890,
    //             "chain_id": "325"
    //         },
    //         "event_time": "1697788800000000000",
    //         "l_1_hash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
    //         "l_2_hash": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
    //     }
    //
    // fetchTransfers
    //
    //           {
    //                "tx_id": "65119836",
    //                "from_account_id": "0xc451b0191351ce308fdfd779d73814c910fc5ecb",
    //                "from_sub_account_id": "0",
    //                "to_account_id": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
    //                "to_sub_account_id": "0",
    //                "currency": "USDT",
    //                "num_tokens": "4.998",
    //                "signature": {
    //                    "signer": "0xf4fdbaf9655bfd607098f4f887aaca58c9667203",
    //                    "r": "0x5f780b99e5e8516f85e66af49b469eeeeeee724290d7f49f1e84b25ad038fa81",
    //                    "s": "0x66c76fdb37a25db8c6b368625d96ee91ab1ffca1786d84dc806b08d1460e97bc",
    //                    "v": "27",
    //                    "expiration": "1767455807929000000",
    //                    "nonce": "45905",
    //                    "chain_id": "0"
    //                },
    //                "event_time": "1764863808817370541",
    //                "transfer_type": "NON_NATIVE_BRIDGE_DEPOSIT",
    //                "transfer_metadata": "{\\"provider\\":\\"rhino\\",\\"direction\\":\\"deposit\\",\\"chainid\\":\\"8453\\",\\"endpoint\\":\\"0x01b89ac919ead1bd513b548962075137c683b9ab\\",\\"provider_tx_id\\":\\"0x1dff8c839f8e21b5af7e121a1ae926017e734aafe8c4ae9942756b3091793b4f\\",\\"provider_ref_id\\":\\"6931aefa5f1ab6fcf0d2f856\\"}"
    //            },
    //
    // withdraw
    //
    //    {
    //        "result": {
    //            "ack": "true"
    //        }
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var direction interface{} = nil
    var txId interface{} = nil
    var networkCode interface{} = nil
    var addressFrom interface{} = this.SafeString(transaction, "from_account_id")
    var addressTo interface{} = this.SafeString(transaction, "to_account_id")
    if IsTrue(InOp(transaction, "transfer_metadata")) {
        var metaData interface{} = this.OmitZero(this.SafeString(transaction, "transfer_metadata"))
        if IsTrue(!IsEqual(metaData, nil)) {
            var parsedMeta interface{} = this.ParseJson(metaData)
            direction = this.SafeStringLower(parsedMeta, "direction")
            txId = this.SafeString(parsedMeta, "provider_tx_id")
            var chainId interface{} = this.SafeString(parsedMeta, "chainid")
            networkCode = this.NetworkIdToCode(chainId)
            if IsTrue(IsEqual(direction, "withdrawal")) {
                addressTo = this.SafeString(parsedMeta, "endpoint")
            } else if IsTrue(IsEqual(direction, "deposit")) {
                addressFrom = this.SafeString(parsedMeta, "endpoint")
            }
        }
    }
    var timestamp interface{} = this.SafeIntegerProduct2(transaction, "event_time", "initiated_time", 0.000001)
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": transaction,
        "id": nil,
        "txid": txId,
        "type": direction,
        "currency": code,
        "network": networkCode,
        "amount": this.SafeNumber(transaction, "num_tokens"),
        "status": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "tag": nil,
        "tagFrom": nil,
        "tagTo": nil,
        "updated": nil,
        "comment": nil,
        "fee": nil,
    }
}
/**
 * @method
 * @name grvt#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://api-docs.grvt.io/trading_api/#transfer-history
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve (default 10, max 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] whether to paginate the results (default false)
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *GrvtCore) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTransfers() requires a code argument")))
            }
        
            retRes14558 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes14558)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = this.Currency(code)
            var maxLimit interface{} = 1000
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTransfers", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes146219 :=  (<-this.FetchPaginatedCallDynamic("fetchTransfers", nil, since, limit, params, maxLimit))
                    PanicOnError(retRes146219)
                    ch <- retRes146219
                    return nil
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PrivateTradingPostFullV1TransferHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "tx_id": "65119836",
            //                "from_account_id": "0xc451b0191351ce308fdfd779d73814c910fc5ecb",
            //                "from_sub_account_id": "0",
            //                "to_account_id": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
            //                "to_sub_account_id": "0",
            //                "currency": "USDT",
            //                "num_tokens": "4.998",
            //                "signature": {
            //                    "signer": "0xf4fdbaf9655bfd607098f4f887aaca58c9667203",
            //                    "r": "0x5f780b99e5e8516f85e66af49b469eeeeeee724290d7f49f1e84b25ad038fa81",
            //                    "s": "0x66c76fdb37a25db8c6b368625d96ee91ab1ffca1786d84dc806b08d1460e97bc",
            //                    "v": "27",
            //                    "expiration": "1767455807929000000",
            //                    "nonce": "45905",
            //                    "chain_id": "0"
            //                },
            //                "event_time": "1764863808817370541",
            //                "transfer_type": "NON_NATIVE_BRIDGE_DEPOSIT",
            //                "transfer_metadata": "{\\"provider\\":\\"rhino\\",\\"direction\\":\\"deposit\\",\\"chainid\\":\\"8453\\",\\"endpoint\\":\\"0x01b89ac919ead1bd513b548962075137c683b9ab\\",\\"provider_tx_id\\":\\"0x1dff8c839f8e21b5af7e121a1ae926017e734aafe8c4ae9942756b3091793b4f\\",\\"provider_ref_id\\":\\"6931aefa5f1ab6fcf0d2f856\\"}"
            //            },
            //            ...
            //        ],
            //        "next": ""
            //    }
            //
            var rows interface{} = this.SafeList(response, "result", []interface{}{})
            var transfers interface{} = this.ParseTransfers(rows, currency, since, limit)
            var filteredResults interface{} = this.FilterTransfersByType(transfers, "internal", false)
        
            ch <- GetValue(filteredResults, 1)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) FilterTransfersByType(transfers interface{}, transferType interface{}, optionalArgs ...interface{}) interface{}  {
    onlyMainAccount := GetArg(optionalArgs, 0, true)
    _ = onlyMainAccount
    var matchedResults interface{} = []interface{}{}
    var nonMatchedResults interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(transfers)); i++ {
        var transfer interface{} = GetValue(transfers, i)
        if IsTrue(IsTrue((IsTrue(IsTrue(onlyMainAccount) && IsTrue(IsEqual(GetValue(transfer, "fromAccount"), "0"))) && IsTrue(IsEqual(GetValue(transfer, "toAccount"), "0")))) || IsTrue((!IsTrue(onlyMainAccount) && IsTrue((IsTrue(!IsEqual(GetValue(transfer, "fromAccount"), "0")) || IsTrue(!IsEqual(GetValue(transfer, "toAccount"), "0"))))))) {
            var metadata interface{} = this.SafeString(GetValue(transfer, "info"), "transfer_metadata")
            var parsedMetadata interface{} = this.ParseJson(metadata)
            var direction interface{} = this.SafeString(parsedMetadata, "direction")
            if IsTrue(IsEqual(direction, transferType)) {
                AppendToArray(&matchedResults, transfer)
            } else {
                AppendToArray(&nonMatchedResults, transfer)
            }
        }
    }
    return []interface{}{matchedResults, nonMatchedResults}
}
/**
 * @method
 * @name grvt#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://api-docs.grvt.io/trading_api/#transfer_1
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *GrvtCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15398 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes15398)
        
            retRes15408 := (<-this.LoadAggregatedAccountSummary())
            PanicOnError(retRes15408)
            var currency interface{} = this.Currency(code)
            var defaultFromAccountId interface{} = this.SafeString(this.Options, "userMainAccountId")
            if IsTrue(IsTrue(this.InArray(fromAccount, []interface{}{"trading", "funding"})) && IsTrue(this.InArray(toAccount, []interface{}{"trading", "funding"}))) {
                var tradingAccountId interface{} = this.SafeString(this.Options, "tradingAccountId")
                var fundingAccountId interface{} = this.SafeString(this.Options, "fundingAccountId")
                if IsTrue(IsTrue(IsEqual(tradingAccountId, nil)) || IsTrue(IsEqual(fundingAccountId, nil))) {
                    panic(ArgumentsRequired(Add(this.Id, " transfer(): you should set .options[\"tradingAccountId\"] and exchange.options[\"fundingAccountId\"] to the corresponding account IDs or directly pass accountIds as fromAccount and toAccount arguments (use \"0\" as funding account id)")))
                }
                fromAccount = Ternary(IsTrue((IsEqual(fromAccount, "trading"))), tradingAccountId, fundingAccountId)
                toAccount = Ternary(IsTrue((IsEqual(toAccount, "trading"))), tradingAccountId, fundingAccountId)
            }
            var request interface{} = map[string]interface{} {
                "from_account_id": this.SafeString(params, "from_account_id", defaultFromAccountId),
                "from_sub_account_id": this.SafeString(params, "from_sub_account_id", fromAccount),
                "to_account_id": this.SafeString(params, "to_account_id", defaultFromAccountId),
                "to_sub_account_id": this.SafeString(params, "to_sub_account_id", toAccount),
                "currency": GetValue(currency, "id"),
                "num_tokens": this.CurrencyToPrecision(code, amount),
                "signature": this.DefaultSignature(),
                "transfer_type": "STANDARD",
                "transfer_metadata": nil,
            }
            request = this.CreateSignedRequest(request, "EIP712_TRANSFER_TYPE", currency)
        
            response:= (<-this.PrivateTradingPostFullV1Transfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "ack": "true",
            //         "tx_id": "1028403"
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTransfer(result, currency)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transfer
    //
    //     {
    //         "ack": "true",
    //         "tx_id": "1028403"
    //     }
    //
    // fetchTransfers
    //
    //            {
    //                "tx_id": "65119836",
    //                "from_account_id": "0xc451b0191351ce308fdfd779d73814c910fc5ecb",
    //                "from_sub_account_id": "0",
    //                "to_account_id": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
    //                "to_sub_account_id": "0",
    //                "currency": "USDT",
    //                "num_tokens": "4.998",
    //                "signature": {
    //                    "signer": "0xf4fdbaf9655bfd607098f4f887aaca58c9667203",
    //                    "r": "0x5f780b99e5e8516f85e66af49b469eeeeeee724290d7f49f1e84b25ad038fa81",
    //                    "s": "0x66c76fdb37a25db8c6b368625d96ee91ab1ffca1786d84dc806b08d1460e97bc",
    //                    "v": "27",
    //                    "expiration": "1767455807929000000",
    //                    "nonce": "45905",
    //                    "chain_id": "0"
    //                },
    //                "event_time": "1764863808817370541",
    //                "transfer_type": "NON_NATIVE_BRIDGE_DEPOSIT",
    //                "transfer_metadata": "{\\"provider\\":\\"rhino\\",\\"direction\\":\\"deposit\\",\\"chainid\\":\\"8453\\",\\"endpoint\\":\\"0x01b89ac919ead1bd513b548962075137c683b9ab\\",\\"provider_tx_id\\":\\"0x1dff8c839f8e21b5af7e121a1ae926017e734aafe8c4ae9942756b3091793b4f\\",\\"provider_ref_id\\":\\"6931aefa5f1ab6fcf0d2f856\\"}"
    //            }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.SafeIntegerProduct(transfer, "event_time", 0.000001)
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "tx_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": code,
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.SafeString(transfer, "from_sub_account_id"),
        "toAccount": this.SafeString(transfer, "to_sub_account_id"),
        "status": nil,
    }
}
func  (this *GrvtCore) LoadAggregatedAccountSummary() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                if IsTrue(!IsEqual(this.SafeString(this.Options, "userMainAccountId"), nil)) {
        
            return nil
        }
        
        response:= (<-this.PrivateTradingPostFullV1AggregatedAccountSummary())
        PanicOnError(response)
        var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        var mainAccountId interface{} = this.SafeString(result, "main_account_id")
        AddElementToObject(this.Options, "userMainAccountId", mainAccountId)
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name grvt#withdraw
 * @description make a withdrawal
 * @see https://api-docs.grvt.io/trading_api/#withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.network the network to withdraw on (mandatory)
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *GrvtCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckAddress(address)
        
            retRes16518 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes16518)
        
            retRes16528 := (<-this.LoadAggregatedAccountSummary())
            PanicOnError(retRes16528)
            var defaultFromAccountId interface{} = this.SafeString(this.Options, "userMainAccountId")
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "to_eth_address": address,
                "from_account_id": defaultFromAccountId,
                "currency": GetValue(currency, "id"),
                "num_tokens": this.CurrencyToPrecision(code, amount),
                "signature": this.DefaultSignature(),
            }
            networkCodequeryVariable := this.HandleNetworkCodeAndParams(params);
            networkCode := GetValue(networkCodequeryVariable,0);
            query := GetValue(networkCodequeryVariable,1)
            var networkId interface{} = this.NetworkCodeToId(networkCode)
            if IsTrue(IsEqual(networkId, nil)) {
                panic(BadRequest(Add(this.Id, " withdraw() requires a network parameter")))
            }
            AddElementToObject(GetValue(request, "signature"), "chainId", networkId)
            request = this.CreateSignedRequest(request, "EIP712_WITHDRAWAL_TYPE", currency)
        
            response:= (<-this.PrivateTradingPostFullV1Withdrawal(this.Extend(request, query)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "ack": "true"
            //     }
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTransaction(result, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#createOrder
 * @description create a trade order
 * @see https://api-docs.grvt.io/trading_api/#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {float} [params.stopLossPrice] The price a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price a take profit order is triggered at
 * @param {string} [params.timeInForce] "GTC", "IOC", or "POST_ONLY"
 * @param {bool} [params.postOnly] true or false
 * @param {bool} [params.reduceOnly] Ensures that the executed order does not flip the opened position.
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17028 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes17028)
            // await this.initializeClient (); // todo: after clarifying about another endpoint
            var market interface{} = this.Market(symbol)
            var orderLeg interface{} = map[string]interface{} {
                "instrument": GetValue(market, "id"),
                "size": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(orderLeg, "limit_price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(IsEqual(side, "sell")) {
                AddElementToObject(orderLeg, "is_buying_asset", false)
            } else if IsTrue(IsEqual(side, "buy")) {
                AddElementToObject(orderLeg, "is_buying_asset", true)
            } else {
                panic(InvalidOrder(Add(this.Id, " createOrder(): order side must be either \"buy\" or \"sell\"")))
            }
            var orderRequest interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
                "time_in_force": "GOOD_TILL_TIME",
                "legs": []interface{}{orderLeg},
                "signature": this.DefaultSignature(),
                "metadata": map[string]interface{} {
                    "client_order_id": ToString(this.Nonce()),
                },
                "is_market": false,
                "post_only": false,
                "reduce_only": false,
            }
            var eipType interface{} = "EIP712_ORDER_TYPE"
            if IsTrue(this.SafeBool(this.Options, "builderFee", true)) {
                eipType = "EIP712_ORDER_WITH_BUILDER_TYPE"
                AddElementToObject(orderRequest, "builder", this.SafeString(this.Options, "builder"))
                AddElementToObject(orderRequest, "builder_fee", this.SafeString(this.Options, "builderRate"))
            }
            // @ts-ignore
            var signedOrderRequest interface{} = this.CreateSignedRequest(orderRequest, eipType)
            var request interface{} = map[string]interface{} {
                "order": signedOrderRequest,
            }
        
            response:= (<-this.PrivateTradingPostFullV1CreateOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "order_id": "0x00",
            //            "sub_account_id": "2147050003876484",
            //            "is_market": false,
            //            "time_in_force": "GOOD_TILL_TIME",
            //            "post_only": false,
            //            "reduce_only": false,
            //            "legs": [
            //                {
            //                    "instrument": "BTC_USDT_Perp",
            //                    "size": "0.001",
            //                    "limit_price": "50000.0",
            //                    "is_buying_asset": true
            //                }
            //            ],
            //            "signature": {
            //                "signer": "0xbf465e6083a43b170791ea29393f60...",
            //                "r": "0x161826bc2fc43e07b4c1e4aeb01b3e58901f936af10b399e...",
            //                "s": "0x1b6d09609430ef73cb53dd87dbe73939824409296b3673719...",
            //                "v": 27,
            //                "expiration": "1766076771082000000",
            //                "nonce": 1766076671,
            //                "chain_id": "0"
            //            },
            //            "metadata": {
            //                "client_order_id": "1766076671",
            //                "create_time": "1766076671243762741",
            //                "trigger": {
            //                    "trigger_type": "UNSPECIFIED",
            //                    "tpsl": {
            //                        "trigger_by": "UNSPECIFIED",
            //                        "trigger_price": "0.0",
            //                        "close_position": false
            //                    }
            //                },
            //                "broker": "UNSPECIFIED",
            //                "is_position_transfer": false,
            //                "allow_crossing": false
            //            },
            //            "state": {
            //                "status": "PENDING",
            //                "reject_reason": "UNSPECIFIED",
            //                "book_size": [
            //                    "0.001"
            //                ],
            //                "traded_size": [
            //                    "0.0"
            //                ],
            //                "update_time": "1766076671243762741",
            //                "avg_fill_price": [
            //                    "0.0"
            //                ]
            //            },
            //            "builder": "0x00",
            //            "builder_fee": "0.0"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ConvertToBigIntCustom(x interface{}) interface{}  {
    return ParseInt(x)
}
func  (this *GrvtCore) EipMessageForOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    structureType := GetArg(optionalArgs, 0, nil)
    _ = structureType
    var priceMultiplier interface{} = "1000000000"
    var orderLegs interface{} = this.SafeList(order, "legs", []interface{}{})
    var legs interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(orderLegs)); i++ {
        var leg interface{} = GetValue(orderLegs, i)
        var market interface{} = this.Market(GetValue(leg, "instrument"))
        var bigInt10 interface{} = this.ConvertToBigIntCustom("10")
        var precisionValue interface{} = this.PrecisionFromString(this.SafeString(GetValue(market, "precision"), "base"))
        var sizeMultiplier interface{} = MathPow(bigInt10, this.ConvertToBigIntCustom(ToString(precisionValue)))
        var size interface{} = GetValue(leg, "size")
        var sizeParts interface{} = Split(size, ".")
        var sizeDec interface{} = this.SafeString(sizeParts, 1, "")
        var sizeDecLength interface{} =         GetLength(sizeDec)
        var sizeDecLengthStr interface{} = ToString(sizeDecLength)
        var sizeInteger interface{} = Divide(Multiply(this.ConvertToBigIntCustom(Replace(size, ".", "")), sizeMultiplier), (MathPow(bigInt10, this.ConvertToBigIntCustom(sizeDecLengthStr))))
        var legOrder interface{} = map[string]interface{} {
            "assetID": GetValue(GetValue(market, "info"), "instrument_hash"),
            "contractSize": this.ParseToInt(sizeInteger),
            "isBuyingContract": GetValue(leg, "is_buying_asset"),
        }
        if IsTrue(InOp(leg, "limit_price")) {
            var price interface{} = GetValue(leg, "limit_price")
            var limitParts interface{} = Split(price, ".")
            var limitDec interface{} = this.SafeString(limitParts, 1, "")
            var limitDecLength interface{} =             GetLength(limitDec)
            var limitDecLengthStr interface{} = ToString(limitDecLength)
            var powerNum interface{} = Ternary(IsTrue(IsEqual(limitDecLengthStr, "0")), 0, this.ConvertToBigIntCustom(limitDecLengthStr))
            var priceInteger interface{} =             (Divide(Multiply(this.ConvertToBigIntCustom(Replace(price, ".", "")), this.ConvertToBigIntCustom(priceMultiplier)), (MathPow(bigInt10, powerNum))))
            AddElementToObject(legOrder, "limitPrice", this.ParseToInt(priceInteger))
        }
        AppendToArray(&legs, legOrder)
    }
    var returnValue interface{} = map[string]interface{} {
        "subAccountID": GetValue(order, "sub_account_id"),
        "isMarket": GetValue(order, "is_market"),
        "timeInForce": 1,
        "postOnly": GetValue(order, "post_only"),
        "reduceOnly": GetValue(order, "reduce_only"),
        "legs": legs,
        "nonce": GetValue(GetValue(order, "signature"), "nonce"),
        "expiration": GetValue(GetValue(order, "signature"), "expiration"),
    }
    if IsTrue(IsTrue(IsEqual(structureType, "EIP712_ORDER_WITH_BUILDER_TYPE")) && IsTrue(this.SafeBool(this.Options, "builderFee", true))) {
        AddElementToObject(returnValue, "builder", GetValue(order, "builder"))
        AddElementToObject(returnValue, "builderFee", this.ParseToInt(Multiply(this.FeeAmountMultiplier(), ParseFloat(GetValue(order, "builder_fee"))))) // the order is matter for Multiply in go, b must be float64 otherwise the value would be 0
    }
    return returnValue
}
func  (this *GrvtCore) EipMessageForBuilderApproval(dataObj interface{}) interface{}  {
    var amountMultiplier interface{} = this.FeeAmountMultiplier()
    return map[string]interface{} {
        "mainAccountID": GetValue(dataObj, "main_account_id"),
        "builderAccountID": GetValue(dataObj, "builder_account_id"),
        "maxFutureFeeRate": this.ParseToInt(Multiply(ParseFloat(GetValue(dataObj, "max_futures_fee_rate")), amountMultiplier)),
        "maxSpotFeeRate": this.ParseToInt(Multiply(ParseFloat(GetValue(dataObj, "max_spot_fee_rate")), amountMultiplier)),
        "nonce": GetValue(GetValue(dataObj, "signature"), "nonce"),
        "expiration": GetValue(GetValue(dataObj, "signature"), "expiration"),
    }
}
func  (this *GrvtCore) EipMessageForWithdrawal(withdrawal interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var amountMultiplier interface{} = this.ConvertToBigIntCustom("1000000")
    return map[string]interface{} {
        "fromAccount": GetValue(withdrawal, "from_account_id"),
        "toEthAddress": GetValue(withdrawal, "to_eth_address"),
        "tokenCurrency": GetValue(currency, "numericId"),
        "numTokens": this.ParseToInt(Multiply(GetValue(withdrawal, "num_tokens"), amountMultiplier)),
        "nonce": GetValue(GetValue(withdrawal, "signature"), "nonce"),
        "expiration": GetValue(GetValue(withdrawal, "signature"), "expiration"),
    }
}
func  (this *GrvtCore) EipMessageForTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var amountMultiplier interface{} = this.ConvertToBigIntCustom("1000000")
    var amountInt interface{} = Multiply(GetValue(transfer, "num_tokens"), amountMultiplier)
    return map[string]interface{} {
        "fromAccount": GetValue(transfer, "from_account_id"),
        "fromSubAccount": GetValue(transfer, "from_sub_account_id"),
        "toAccount": GetValue(transfer, "to_account_id"),
        "toSubAccount": GetValue(transfer, "to_sub_account_id"),
        "tokenCurrency": GetValue(currency, "numericId"),
        "numTokens": this.ParseToInt(amountInt),
        "nonce": GetValue(GetValue(transfer, "signature"), "nonce"),
        "expiration": GetValue(GetValue(transfer, "signature"), "expiration"),
    }
}
func  (this *GrvtCore) FeeAmountMultiplier() interface{}  {
    return this.ConvertToBigIntCustom("10000")  // multiply needed https://t.me/c/3396937126/88
}
/**
 * @method
 * @name grvt#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api-docs.grvt.io/trading_api/#fill-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *GrvtCore) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19308 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes19308)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes193419 :=  (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
                    PanicOnError(retRes193419)
                    ch <- retRes193419
                    return nil
            }
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "base", []interface{}{})
                retRes194312 := GetValue(request, "base")
                AppendToArray(&retRes194312, GetValue(market, "baseId"))
                AddElementToObject(request, "quote", []interface{}{})
                retRes194512 := GetValue(request, "quote")
                AppendToArray(&retRes194512, GetValue(market, "quoteId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PrivateTradingPostFullV1FillHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "event_time": "1764945709702747558",
            //                "sub_account_id": "2147050003876484",
            //                "instrument": "BTC_USDT_Perp",
            //                "is_buyer": true,
            //                "is_taker": false,
            //                "size": "0.001",
            //                "price": "90000.0",
            //                "mark_price": "90050.164063298",
            //                "index_price": "90089.803654938",
            //                "interest_rate": "0.0",
            //                "forward_price": "0.0",
            //                "realized_pnl": "0.0",
            //                "fee": "-0.00009",
            //                "fee_rate": "0.0",
            //                "trade_id": "65424692-2",
            //                "order_id": "0x01010105034cddc7000000006621285c",
            //                "venue": "ORDERBOOK",
            //                "client_order_id": "1375879248",
            //                "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
            //                "broker": "UNSPECIFIED",
            //                "is_rpi": false
            //            },
            //            ...
            //        ],
            //        "next": ""
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(result, nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#fetchPositions
 * @description fetch all open positions
 * @see https://api-docs.grvt.io/trading_api/#positions-request
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *GrvtCore) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20008 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes20008)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
                AddElementToObject(request, "base", []interface{}{})
                AddElementToObject(request, "quote", []interface{}{})
                for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                    var symbol interface{} = GetValue(symbols, i)
                    var market interface{} = this.Market(symbol)
                    if IsTrue(!IsEqual(GetValue(market, "contract"), true)) {
                        panic(BadRequest(Add(this.Id, " fetchPositions() supports contract markets only")))
                    }
                    retRes201416 := GetValue(request, "base")
                    AppendToArray(&retRes201416, GetValue(market, "baseId"))
                    retRes201516 := GetValue(request, "quote")
                    AppendToArray(&retRes201516, GetValue(market, "quoteId"))
                }
            }
        
            response:= (<-this.PrivateTradingPostFullV1Positions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "event_time": "1765258069092857642",
            //                "sub_account_id": "2147050003876484",
            //                "instrument": "BTC_USDT_Perp",
            //                "size": "0.001",
            //                "notional": "89.8169",
            //                "entry_price": "90000.0",
            //                "exit_price": "0.0",
            //                "mark_price": "89816.900008979",
            //                "unrealized_pnl": "-0.183099",
            //                "realized_pnl": "0.0",
            //                "total_pnl": "-0.183099",
            //                "roi": "-0.2034",
            //                "quote_index_price": "1.00017885",
            //                "est_liquidation_price": "77951.450008979",
            //                "leverage": "28.0",
            //                "cumulative_fee": "-0.00009",
            //                "cumulative_realized_funding_payment": "0.033862"
            //            }
            //        ]
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParsePositions(result, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //            {
    //                "event_time": "1765258069092857642",
    //                "sub_account_id": "2147050003876484",
    //                "instrument": "BTC_USDT_Perp",
    //                "size": "0.001",
    //                "notional": "89.8169",
    //                "entry_price": "90000.0",
    //                "exit_price": "0.0",
    //                "mark_price": "89816.900008979",
    //                "unrealized_pnl": "-0.183099",
    //                "realized_pnl": "0.0",
    //                "total_pnl": "-0.183099",
    //                "roi": "-0.2034",
    //                "quote_index_price": "1.00017885",
    //                "est_liquidation_price": "77951.450008979",
    //                "leverage": "28.0",
    //                "cumulative_fee": "-0.00009",
    //                "cumulative_realized_funding_payment": "0.033862"
    //            }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "instrument")
    var timestamp interface{} = this.SafeIntegerProduct(position, "event_time", 0.000001)
    var sizeRaw interface{} = this.SafeString(position, "size")
    var isLong interface{} =     (Precise.StringGe(sizeRaw, "0"))
    var side interface{} = Ternary(IsTrue(isLong), "long", "short")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeSymbol(marketId, market),
        "notional": this.ParseNumber(Precise.StringAbs(this.SafeString(position, "notional"))),
        "marginMode": nil,
        "liquidationPrice": this.SafeNumber(position, "est_liquidation_price"),
        "entryPrice": this.SafeNumber(position, "entry_price"),
        "unrealizedPnl": this.SafeNumber(position, "unrealized_pnl"),
        "realizedPnl": this.SafeNumber(position, "realized_pnl"),
        "percentage": nil,
        "contracts": this.ParseNumber(Precise.StringAbs(sizeRaw)),
        "markPrice": this.SafeNumber(position, "mark_price"),
        "lastPrice": nil,
        "side": side,
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": this.SafeInteger(position, "lastUpdateTime"),
        "maintenanceMargin": this.SafeNumber(position, "maintenanceMargin"),
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": this.SafeNumber(position, "initialMargin"),
        "initialMarginPercentage": nil,
        "leverage": this.SafeNumber(position, "leverage"),
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name grvt#fetchLeverages
 * @description fetch the set leverage for all contract markets
 * @see https://api-docs.grvt.io/trading_api/#get-all-initial-leverage
 * @param {string[]} [symbols] a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/?id=leverage-structure}
 */
func  (this *GrvtCore) FetchLeverages(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21168 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes21168)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
        
            response:= (<-this.PrivateTradingPostFullV1GetAllInitialLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "results": [
            //            {
            //                "instrument": "AAVE_USDT_Perp",
            //                "leverage": "10.0",
            //                "min_leverage": "1.0",
            //                "max_leverage": "50.0",
            //                "margin_type": "CROSS"
            //            },
            //
            var results interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseLeverages(results, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#setLeverage
 * @description set the level of leverage for a market
 * @see https://api-docs.grvt.io/trading_api/#set-initial-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *GrvtCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes21508 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes21508)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
                "instrument": GetValue(market, "id"),
                "leverage": this.NumberToString(leverage),
            }
        
            response:= (<-this.PrivateTradingPostFullV1SetInitialLeverage(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "success": true
            //    }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // setLeverage
    //
    //     {
    //         "success": true
    //     }
    //
    // fetchLeverages
    //
    //     {
    //         "instrument": "AAVE_USDT_Perp",
    //         "leverage": "10.0",
    //         "min_leverage": "1.0",
    //         "max_leverage": "50.0",
    //         "margin_type": "CROSS"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "instrument")
    var leverageValue interface{} = this.SafeNumber(leverage, "leverage")
    var marginType interface{} = this.SafeStringLower(leverage, "margin_type")
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": marginType,
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name grvt#fetchMarginModes
 * @description fetches margin mode of the user
 * @see https://api-docs.grvt.io/trading_api/#get-all-initial-leverage
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/?id=margin-mode-structure}
 */
func  (this *GrvtCore) FetchMarginModes(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22068 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes22068)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
        
            response:= (<-this.PrivateTradingPostFullV1GetAllInitialLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "results": [
            //            {
            //                "instrument": "AAVE_USDT_Perp",
            //                "leverage": "10.0",
            //                "min_leverage": "1.0",
            //                "max_leverage": "50.0",
            //                "margin_type": "CROSS"
            //            },
            //
            var results interface{} = this.SafeList(response, "results", []interface{}{})
        
            ch <- this.ParseLeverages(results, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchMarginModes
    //
    //            {
    //                "instrument": "AAVE_USDT_Perp",
    //                "leverage": "10.0",
    //                "min_leverage": "1.0",
    //                "max_leverage": "50.0",
    //                "margin_type": "CROSS"
    //            },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(marginMode, "symbol")
    return map[string]interface{} {
        "info": marginMode,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": this.SafeStringLower(marginMode, "margin_type"),
    }
}
/**
 * @method
 * @name grvt#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://api-docs.grvt.io/trading_api/#funding-payment-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *GrvtCore) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22608 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes22608)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes226419 :=  (<-this.FetchPaginatedCallDynamic("fetchFundingHistory", symbol, since, limit, params, 1000))
                    PanicOnError(retRes226419)
                    ch <- retRes226419
                    return nil
            }
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "base", []interface{}{})
                retRes227312 := GetValue(request, "base")
                AppendToArray(&retRes227312, GetValue(market, "baseId"))
                AddElementToObject(request, "quote", []interface{}{})
                retRes227512 := GetValue(request, "quote")
                AppendToArray(&retRes227512, GetValue(market, "quoteId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PrivateTradingPostFullV1FundingPaymentHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "event_time": "1765267200004987902",
            //                "sub_account_id": "2147050003876484",
            //                "instrument": "BTC_USDT_Perp",
            //                "currency": "USDT",
            //                "amount": "-0.004522",
            //                "tx_id": "66625184"
            //            },
            //            ..
            //        ],
            //        "next": ""
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseIncomes(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //            {
    //                "event_time": "1765267200004987902",
    //                "sub_account_id": "2147050003876484",
    //                "instrument": "BTC_USDT_Perp",
    //                "currency": "USDT",
    //                "amount": "-0.004522",
    //                "tx_id": "66625184"
    //            }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "instrument")
    var currencyId interface{} = this.SafeString(income, "currency")
    var timestamp interface{} = this.SafeIntegerProduct(income, "event_time", 0.000001)
    return map[string]interface{} {
        "info": income,
        "symbol": this.SafeSymbol(marketId, market),
        "code": this.SafeCurrencyCode(currencyId),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(income, "tx_id"),
        "amount": this.SafeNumber(income, "amount"),
    }
}
/**
 * @method
 * @name grvt#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://api-docs.grvt.io/trading_api/#order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest item
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23438 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes23438)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "base", []interface{}{})
                retRes235112 := GetValue(request, "base")
                AppendToArray(&retRes235112, GetValue(market, "baseId"))
                AddElementToObject(request, "quote", []interface{}{})
                retRes235312 := GetValue(request, "quote")
                AppendToArray(&retRes235312, GetValue(market, "quoteId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            requestparamsVariable := this.HandleUntilOptionString("end_time", request, params, 1000000);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.NumberToString(Multiply(since, 1000000)))
            }
        
            response:= (<-this.PrivateTradingPostFullV1OrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "order_id": "0x01010105034cddc7000000006621285c",
            //                "sub_account_id": "2147050003876484",
            //                "is_market": false,
            //                "time_in_force": "GOOD_TILL_TIME",
            //                "post_only": false,
            //                "reduce_only": false,
            //                "legs": [
            //                    {
            //                        "instrument": "BTC_USDT_Perp",
            //                        "size": "0.001",
            //                        "limit_price": "90000.0",
            //                        "is_buying_asset": true
            //                    }
            //                ],
            //                "signature": {
            //                    "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
            //                    "r": "0x2d567b0a04525baf0bbd792db3bb3a28c1bcc5e95936f6dc2515a28ad8529313",
            //                    "s": "0x0bc2468d96c819c8de005aa7bebfb58eecb34dd7a1bae1e81e74c7b8bc4cddc7",
            //                    "v": "27",
            //                    "expiration": "1767455222801000000",
            //                    "nonce": "1375879248",
            //                    "chain_id": "0"
            //                },
            //                "metadata": {
            //                    "client_order_id": "1375879248",
            //                    "create_time": "1764863234474424590",
            //                    "trigger": {
            //                        "trigger_type": "UNSPECIFIED",
            //                        "tpsl": {
            //                            "trigger_by": "UNSPECIFIED",
            //                            "trigger_price": "0.0",
            //                            "close_position": false
            //                        }
            //                    },
            //                    "broker": "UNSPECIFIED",
            //                    "is_position_transfer": false,
            //                    "allow_crossing": false
            //                },
            //                "state": {
            //                    "status": "FILLED",
            //                    "reject_reason": "UNSPECIFIED",
            //                    "book_size": [
            //                        "0.0"
            //                    ],
            //                    "traded_size": [
            //                        "0.001"
            //                    ],
            //                    "update_time": "1764945709704912003",
            //                    "avg_fill_price": [
            //                        "90000.0"
            //                    ]
            //                }
            //            },
            //            ...
            //        ],
            //        "next": ""
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api-docs.grvt.io/trading_api/#open-orders
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes24418 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes24418)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
        
            response:= (<-this.PrivateTradingPostFullV1OpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "order_id": "0x0101010503e693410000000069530a7d",
            //                "sub_account_id": "2147050003876484",
            //                "is_market": false,
            //                "time_in_force": "GOOD_TILL_TIME",
            //                "post_only": false,
            //                "reduce_only": false,
            //                "legs": [
            //                    {
            //                        "instrument": "BTC_USDT_Perp",
            //                        "size": "0.002",
            //                        "limit_price": "88123.0",
            //                        "is_buying_asset": true
            //                    }
            //                ],
            //                "signature": {
            //                    "signer": "0x0982ebb82523fd20d1347d59f5a989ed84caa4b5",
            //                    "r": "0x22b13e5bc7c8d6793db9d0adf6a51340437292baf83aa4f89a01a3c0c1fef4a8",
            //                    "s": "0x46ecd483126c388cc933022979a9636670f64af3773d04a84ecbeac423e69341",
            //                    "v": "28",
            //                    "expiration": "1767871961406000000",
            //                    "nonce": "588129369",
            //                    "chain_id": "0"
            //                },
            //                "metadata": {
            //                    "client_order_id": "588129369",
            //                    "create_time": "1765279966899943792",
            //                    "trigger": {
            //                        "trigger_type": "UNSPECIFIED",
            //                        "tpsl": {
            //                            "trigger_by": "UNSPECIFIED",
            //                            "trigger_price": "0.0",
            //                            "close_position": false
            //                        }
            //                    },
            //                    "broker": "UNSPECIFIED",
            //                    "is_position_transfer": false,
            //                    "allow_crossing": false
            //                },
            //                "state": {
            //                    "status": "OPEN",
            //                    "reject_reason": "UNSPECIFIED",
            //                    "book_size": [
            //                        "0.002"
            //                    ],
            //                    "traded_size": [
            //                        "0.0"
            //                    ],
            //                    "update_time": "1765279966899943792",
            //                    "avg_fill_price": [
            //                        "0.0"
            //                    ]
            //                }
            //            }
            //        ]
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api-docs.grvt.io/trading_api/#get-order
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes25228 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes25228)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                params = this.Omit(params, "clientOrderId", "client_order_id")
                AddElementToObject(request, "client_order_id", clientOrderId)
            } else {
                AddElementToObject(request, "order_id", id)
            }
        
            response:= (<-this.PrivateTradingPostFullV1Order(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "order_id": "0x01010105034cddc7000000006621285c",
            //            "sub_account_id": "2147050003876484",
            //            "is_market": false,
            //            "time_in_force": "GOOD_TILL_TIME",
            //            "post_only": false,
            //            "reduce_only": false,
            //            "legs": [
            //                {
            //                    "instrument": "BTC_USDT_Perp",
            //                    "size": "0.001",
            //                    "limit_price": "90000.0",
            //                    "is_buying_asset": true
            //                }
            //            ],
            //            "signature": {
            //                "signer": "0x42c9f56f2c9da534f64b8806d64813b29c62a01d",
            //                "r": "0x2d567b0a04525baf0bbd792db3bb3a28c1bcc5e95936f6dc2515a28ad8529313",
            //                "s": "0x0bc2468d96c819c8de005aa7bebfb58eecb34dd7a1bae1e81e74c7b8bc4cddc7",
            //                "v": "27",
            //                "expiration": "1767455222801000000",
            //                "nonce": "1375879248",
            //                "chain_id": "0"
            //            },
            //            "metadata": {
            //                "client_order_id": "1375879248",
            //                "create_time": "1764863234474424590",
            //                "trigger": {
            //                    "trigger_type": "UNSPECIFIED",
            //                    "tpsl": {
            //                        "trigger_by": "UNSPECIFIED",
            //                        "trigger_price": "0.0",
            //                        "close_position": false
            //                    }
            //                },
            //                "broker": "UNSPECIFIED",
            //                "is_position_transfer": false,
            //                "allow_crossing": false
            //            },
            //            "state": {
            //                "status": "FILLED",
            //                "reject_reason": "UNSPECIFIED",
            //                "book_size": [
            //                    "0.0"
            //                ],
            //                "traded_size": [
            //                    "0.001"
            //                ],
            //                "update_time": "1764945709704912003",
            //                "avg_fill_price": [
            //                    "90000.0"
            //                ]
            //            }
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrders, fetchOpenOrders, fetchOrder, createOrder
    //
    //           {
    //                "order_id": "0x0101010503e693410000000069530a7d",
    //                "sub_account_id": "2147050003876484",
    //                "is_market": false,
    //                "time_in_force": "GOOD_TILL_TIME",
    //                "post_only": false,
    //                "reduce_only": false,
    //                "legs": [
    //                    {
    //                        "instrument": "BTC_USDT_Perp",
    //                        "size": "0.002",
    //                        "limit_price": "88123.0",
    //                        "is_buying_asset": true
    //                    }
    //                ],
    //                "signature": {
    //                    "signer": "0x0982ebb82523fd20d1347d59f5a989ed84caa4b5",
    //                    "r": "0x22b13e5bc7c8d6793db9d0adf6a51340437292baf83aa4f89a01a3c0c1fef4a8",
    //                    "s": "0x46ecd483126c388cc933022979a9636670f64af3773d04a84ecbeac423e69341",
    //                    "v": "28",
    //                    "expiration": "1767871961406000000",
    //                    "nonce": "588129369",
    //                    "chain_id": "0"
    //                },
    //                "metadata": {
    //                    "client_order_id": "588129369",
    //                    "create_time": "1765279966899943792",
    //                    "trigger": {
    //                        "trigger_type": "UNSPECIFIED",
    //                        "tpsl": {
    //                            "trigger_by": "UNSPECIFIED",
    //                            "trigger_price": "0.0",
    //                            "close_position": false
    //                        }
    //                    },
    //                    "broker": "UNSPECIFIED",
    //                    "is_position_transfer": false,
    //                    "allow_crossing": false
    //                },
    //                "state": {
    //                    "status": "OPEN",
    //                    "reject_reason": "UNSPECIFIED",
    //                    "book_size": [
    //                        "0.002"
    //                    ],
    //                    "traded_size": [
    //                        "0.0"
    //                    ],
    //                    "update_time": "1765279966899943792",
    //                    "avg_fill_price": [
    //                        "0.0"
    //                    ]
    //                },
    //                "builder": "0x00",
    //                "builder_fee": "0.0"
    //            }
    //
    // cancelOrder, cancelAllOrders
    //
    //    {
    //        "ack": true
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    if IsTrue(InOp(order, "ack")) {
        return this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": nil,
        })
    }
    var isMarket interface{} = this.SafeString(order, "is_market")
    var orderType interface{} = Ternary(IsTrue(isMarket), "market", "limit")
    var isPostOnly interface{} = this.SafeBool(order, "post_only")
    var isReduceOnly interface{} = this.SafeBool(order, "reduce_only")
    var timeInForceRaw interface{} = this.SafeString(order, "time_in_force")
    var timeInForce interface{} = Ternary(IsTrue(isPostOnly), "PO", this.ParseTimeInForce(timeInForceRaw))
    var size interface{} = nil
    var side interface{} = nil
    var price interface{} = nil
    var filled interface{} = nil
    var avgPrice interface{} = nil
    var legs interface{} = this.SafeList(order, "legs")
    var metadata interface{} = this.SafeDict(order, "metadata", map[string]interface{} {})
    var stateObj interface{} = this.SafeDict(order, "state", map[string]interface{} {})
    var filledAmounts interface{} = this.SafeList(stateObj, "traded_size", []interface{}{})
    var avgPrices interface{} = this.SafeList(stateObj, "avg_fill_price", []interface{}{})
    var primaryOrderIndex interface{} = 0
    var firstLeg interface{} = this.SafeDict(legs, primaryOrderIndex)
    if IsTrue(!IsEqual(firstLeg, nil)) {
        var marketId interface{} = this.SafeString(firstLeg, "instrument")
        market = this.SafeMarket(marketId, market)
        size = this.SafeString(firstLeg, "size")
        side = Ternary(IsTrue(this.SafeString(firstLeg, "is_buying_asset")), "buy", "sell")
        price = this.SafeString(firstLeg, "limit_price")
        filled = this.SafeString(filledAmounts, primaryOrderIndex)
        avgPrice = this.SafeString(avgPrices, primaryOrderIndex)
    }
    var timestamp interface{} = this.SafeIntegerProduct(metadata, "create_time", 0.000001)
    // const triggerDetails = this.safeDict (metadata, 'trigger', {});
    var legsLength interface{} =     GetArrayLength(legs)
    return this.SafeOrder(map[string]interface{} {
        "isMultiLeg": (IsGreaterThan(legsLength, 1)),
        "id": this.SafeString(order, "order_id"),
        "clientOrderId": this.SafeString(metadata, "client_order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimeStamp": nil,
        "lastUpdateTimestamp": this.SafeIntegerProduct(stateObj, "update_time", 0.000001),
        "status": this.ParseOrderStatus(this.SafeString(stateObj, "status")),
        "symbol": GetValue(market, "symbol"),
        "type": orderType,
        "timeInForce": timeInForce,
        "postOnly": isPostOnly,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "average": avgPrice,
        "amount": size,
        "filled": filled,
        "remaining": nil,
        "trades": nil,
        "fees": nil,
        "reduceOnly": isReduceOnly,
        "info": order,
    }, market)
}
func  (this *GrvtCore) ParseTimeInForce(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "GOOD_TILL_TIME": "GTC",
        "IMMEDIATE_OR_CANCEL": "IOC",
        "FILL_OR_KILL": "FOK",
    }
    return this.SafeStringUpper(types, typeVar, typeVar)
}
func  (this *GrvtCore) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PENDING": "pending",
        "OPEN": "open",
        "FILLED": "closed",
        "REJECTED": "rejected",
        "CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name grvt#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://api-docs.grvt.io/trading_api/#cancel-all-orders
 * @param {string} symbol cancel alls open orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27578 := (<-this.LoadMarketsAndSignIn())
            PanicOnError(retRes27578)
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "base", []interface{}{})
                retRes276412 := GetValue(request, "base")
                AppendToArray(&retRes276412, GetValue(market, "baseId"))
                AddElementToObject(request, "quote", []interface{}{})
                retRes276612 := GetValue(request, "quote")
                AppendToArray(&retRes276612, GetValue(market, "quoteId"))
            }
        
            response:= (<-this.PrivateTradingPostFullV1CancelAllOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "ack": true
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrders([]interface{}{result}, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name grvt#cancelOrder
 * @description cancels an open order
 * @see https://api-docs.grvt.io/trading_api/#cancel-order
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *GrvtCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "sub_account_id": this.GetSubAccountId(params),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                params = this.Omit(params, "clientOrderId", "client_order_id")
                AddElementToObject(request, "client_order_id", clientOrderId)
            } else {
                AddElementToObject(request, "order_id", id)
            }
        
            response:= (<-this.PrivateTradingPostFullV1CancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": {
            //            "ack": true
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
func  (this *GrvtCore) InitializeClient(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var buildFee interface{} = this.SafeBool(this.Options, "builderFee", true)
            if !IsTrue(buildFee) {
        
                ch <- false  // skip if builder fee is not enabled
                return nil
            }
            var approvedBuilderFee interface{} = this.SafeBool(this.Options, "approvedBuilderFee", false)
            if IsTrue(approvedBuilderFee) {
        
                ch <- true  // skip if builder fee is already approved
                return nil
            }
        
            results:= (<-promiseAll([]interface{}{this.PrivateTradingPostFullV1GetAuthorizedBuilders(), this.LoadAggregatedAccountSummary()}))
            PanicOnError(results)
            //
            // {
            //     "results": [{
            //         "builder_account_id": "GRVT_MAIN_ACCOUNT_ID_HERE",
            //         "max_futures_fee_rate": 0.001,
            //         "max_spot_fee_rate": 0.0001
            //     }]
            // }
            //
            var currentBuilders interface{} = GetValue(results, 0)
            var result interface{} = this.SafeList(currentBuilders, "results", []interface{}{})
            var length interface{} =     GetArrayLength(result)
            var run interface{} = false
            if IsTrue(IsLessThanOrEqual(length, 0)) {
                run = true
            }
            if IsTrue(run) {
                
                    {
                         func(this *GrvtCore) (ret_ interface{}) {
                		    defer func() {
                                if e := recover(); e != nil {
                                    if e == "break" {
                                        return
                                    }
                                    ret_ = func(this *GrvtCore) interface{} {
                                        // catch block:
                                                    AddElementToObject(this.Options, "builderFee", false) // disable builder fee if an error occurs
                                        return nil
                                    }(this)
                                }
                            }()
                		    // try block:
                                        var defaultFromAccountId interface{} = this.SafeString(this.Options, "userMainAccountId") // this.ethGetAddressFromPrivateKey (this.secret); // this.safeString (this.options, 'userMainAccountId');
                            var request interface{} = map[string]interface{} {
                                "main_account_id": defaultFromAccountId,
                                "builder_account_id": this.SafeString(this.Options, "builder"),
                                "max_futures_fee_rate": this.SafeString(this.Options, "builderRate"),
                                "max_spot_fee_rate": this.SafeString(this.Options, "builderRate"),
                                "signature": this.DefaultSignature(),
                            }
                            request = this.CreateSignedRequest(request, "EIP712_BUILDER_APPROVAL_TYPE")
                
                            retRes285116 := (<-this.PrivateTradingPostFullV1AuthorizeBuilder(this.Extend(request, params)))
                            PanicOnError(retRes285116)
                            //
                            // {
                            //     "result": {
                            //         "ack": "true"
                            //     }
                            // }
                            //
                            AddElementToObject(this.Options, "approvedBuilderFee", true)
                		    return nil
                	    }(this)
                    
                        }
        
                ch <- true
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *GrvtCore) EipDomainData() interface{}  {
    //     GrvtEnv.DEV.value: 327,
    //     GrvtEnv.STAGING.value: 327,
    //     GrvtEnv.TESTNET.value: 326,
    //     GrvtEnv.PROD.value: 325,
    return map[string]interface{} {
        "name": "GRVT Exchange",
        "version": "0",
        "chainId": 325,
    }
}
func  (this *GrvtCore) CreateSignedRequest(request interface{}, structureType interface{}, optionalArgs ...interface{}) interface{}  {
    currencyObj := GetArg(optionalArgs, 0, nil)
    _ = currencyObj
    signerAddress := GetArg(optionalArgs, 1, nil)
    _ = signerAddress
    var messageData interface{} = nil
    if IsTrue(IsEqual(structureType, "EIP712_TRANSFER_TYPE")) {
        messageData = this.EipMessageForTransfer(request, currencyObj)
    } else if IsTrue(IsEqual(structureType, "EIP712_WITHDRAWAL_TYPE")) {
        messageData = this.EipMessageForWithdrawal(request, currencyObj)
    } else if IsTrue(IsTrue(IsEqual(structureType, "EIP712_ORDER_TYPE")) || IsTrue(IsEqual(structureType, "EIP712_ORDER_WITH_BUILDER_TYPE"))) {
        messageData = this.EipMessageForOrder(request, structureType)
    } else if IsTrue(IsEqual(structureType, "EIP712_BUILDER_APPROVAL_TYPE")) {
        messageData = this.EipMessageForBuilderApproval(request)
    }
    var domainData interface{} = this.EipDomainData()
    var definitions interface{} = this.EipDefinitions()
    var ethEncodedMessage interface{} = this.EthEncodeStructuredData(domainData, GetValue(definitions, structureType), messageData)
    var ethEncodedMessageHashed interface{} = Add("0x", this.Hash(ethEncodedMessage, keccak, "hex"))
    var privateKeyWithoutZero interface{} = this.Remove0xPrefix(this.Secret)
    var signature interface{} = Ecdsa(this.Remove0xPrefix(ethEncodedMessageHashed), privateKeyWithoutZero, secp256k1, nil)
    AddElementToObject(GetValue(request, "signature"), "r", this.FormatSignatureRS(GetValue(signature, "r")))
    AddElementToObject(GetValue(request, "signature"), "s", this.FormatSignatureRS(GetValue(signature, "s")))
    AddElementToObject(GetValue(request, "signature"), "v", this.Sum(27, GetValue(signature, "v")))
    AddElementToObject(GetValue(request, "signature"), "signer", Ternary(IsTrue((IsEqual(signerAddress, nil))), this.EthGetAddressFromPrivateKey(Add("0x", privateKeyWithoutZero)), signerAddress))
    return request
}
func  (this *GrvtCore) FormatSignatureRS(value interface{}) interface{}  {
    var padded interface{} = PadStart(value, 64, "0")
    if IsTrue(StartsWith(padded, "0x")) {
        return padded
    } else {
        return Add("0x", padded)
    }
}
func  (this *GrvtCore) DefaultSignature() interface{}  {
    var expiration interface{} = Add(Multiply(this.Milliseconds(), 1000000), Multiply(Multiply(1000000, this.SafeInteger(this.Options, "expirationSeconds", 30)), 1000))
    return map[string]interface{} {
        "signer": "",
        "r": "",
        "s": "",
        "v": 0,
        "expiration": ToString(expiration),
        "nonce": this.Nonce(),
        "chain_id": "325",
    }
}
func  (this *GrvtCore) HandleUntilOptionString(key interface{}, request interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    multiplier := GetArg(optionalArgs, 0, 1)
    _ = multiplier
    var until interface{} = this.SafeInteger2(params, "until", "till")
    if IsTrue(!IsEqual(until, nil)) {
        AddElementToObject(request, key, this.NumberToString(this.ParseToInt(Multiply(until, multiplier))))
        params = this.Omit(params, []interface{}{"until", "till"})
    }
    return []interface{}{request, params}
}
func  (this *GrvtCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    path = this.ImplodeParams(path, params)
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), path)
    var queryString interface{} = ""
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            queryString = this.Urlencode(query)
            url = Add(url, Add("?", queryString))
        }
    } else if IsTrue(IsEqual(method, "POST")) {
        body = this.Json(params)
    }
    var isPrivate interface{} = StartsWith(api, "private")
    if IsTrue(isPrivate) {
        this.CheckRequiredCredentials()
        if IsTrue(!IsEqual(queryString, "")) {
            path = Add(Add(path, "?"), queryString)
        }
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
        if IsTrue(IsEqual(path, "auth/api_key/login")) {
            AddElementToObject(headers, "Cookie", "rm=true;")
        } else {
            var accountId interface{} = this.SafeString(this.Options, "AuthAccountId")
            var cookieValue interface{} = this.SafeString(this.Options, "AuthCookieValue")
            if IsTrue(IsTrue(IsEqual(cookieValue, nil)) || IsTrue(IsEqual(accountId, nil))) {
                panic(AuthenticationError(Add(this.Id, " : at first, you need to authenticate with exchange using signIn() method.")))
            }
            AddElementToObject(headers, "Cookie", cookieValue)
            AddElementToObject(headers, "X-Grvt-Account-Id", accountId)
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *GrvtCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(EndsWith(url, "auth/api_key/login")) {
        var accountId interface{} = this.SafeString2(headers, "X-Grvt-Account-Id", "x-grvt-account-id")
        AddElementToObject(this.Options, "AuthAccountId", accountId)
        var cookie interface{} = this.SafeString2(headers, "Set-Cookie", "set-cookie")
        if IsTrue(!IsEqual(cookie, nil)) {
            var cookieValue interface{} = GetValue(Split(cookie, ";"), 0)
            AddElementToObject(this.Options, "AuthCookieValue", cookieValue)
        }
        if IsTrue(IsTrue(IsEqual(GetValue(this.Options, "AuthCookieValue"), nil)) || IsTrue(IsEqual(GetValue(this.Options, "AuthAccountId"), nil))) {
            panic(AuthenticationError(Add(this.Id, " signIn() failed to receive auth-cookie or account-id")))
        }
    } else {
        var errorCode interface{} = this.SafeString(response, "code")
        if IsTrue(!IsEqual(errorCode, nil)) {
            var feedback interface{} = Add(Add(this.Id, " "), body)
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
            panic(ExchangeError(feedback))
        } else {
            var message interface{} = this.SafeString(response, "message")
            if IsTrue(!IsEqual(message, nil)) {
                var feedback interface{} = Add(Add(this.Id, " "), body)
                this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
                panic(ExchangeError(feedback))
            } else {
                var status interface{} = this.SafeString(response, "status")
                if IsTrue(IsTrue(!IsEqual(status, nil)) && IsTrue(!IsEqual(status, "success"))) {
                    var feedback interface{} = Add(Add(this.Id, " "), body)
                    panic(ExchangeError(feedback))
                }
            }
        }
    }
    return nil
}


func (this *GrvtCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
