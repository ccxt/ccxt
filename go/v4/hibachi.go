package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type hibachi struct {
    Exchange

}

func NewHibachiCore() *hibachi {
    p := &hibachi{}
    setDefaults(p)
    return p
}

func  (this *hibachi) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "hibachi",
        "name": "Hibachi",
        "countries": []interface{}{"US"},
        "rateLimit": 100,
        "userAgent": GetValue(this.UserAgents, "chrome"),
        "certified": false,
        "pro": false,
        "dex": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelWithdraw": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopLossOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": false,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": false,
            "editOrder": true,
            "editOrders": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": false,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTradingLimits": false,
            "fetchTransactions": "emulated",
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "5m": "5min",
            "15m": "15min",
            "1h": "1h",
            "4h": "4h",
            "1d": "1d",
            "1w": "1w",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/7301bbb1-4f27-4167-8a55-75f74b14e973",
            "api": map[string]interface{} {
                "public": "https://data-api.hibachi.xyz",
                "private": "https://api.hibachi.xyz",
            },
            "www": "https://www.hibachi.xyz/",
            "referral": map[string]interface{} {
                "url": "hibachi.xyz/r/ZBL2YFWIHU",
            },
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "market/exchange-info": 1,
                    "market/data/trades": 1,
                    "market/data/prices": 1,
                    "market/data/stats": 1,
                    "market/data/klines": 1,
                    "market/data/orderbook": 1,
                    "market/data/open-interest": 1,
                    "market/data/funding-rates": 1,
                    "exchange/utc-timestamp": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "capital/deposit-info": 1,
                    "capital/history": 1,
                    "trade/account/trading_history": 1,
                    "trade/account/info": 1,
                    "trade/order": 1,
                    "trade/account/trades": 1,
                    "trade/orders": 1,
                },
                "put": map[string]interface{} {
                    "trade/order": 1,
                },
                "delete": map[string]interface{} {
                    "trade/order": 1,
                    "trade/orders": 1,
                },
                "post": map[string]interface{} {
                    "trade/order": 1,
                    "trade/orders": 1,
                    "capital/withdraw": 1,
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": false,
            "accountId": true,
            "privateKey": true,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.00015"),
                "taker": this.ParseNumber("0.00045"),
            },
        },
        "options": map[string]interface{} {},
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "2": BadRequest,
                "3": OrderNotFound,
                "4": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *hibachi) GetAccountId() interface{}  {
    this.CheckRequiredCredentials()
    var id interface{} = this.ParseToInt(this.AccountId)
    return id
}
func  (this *hibachi) ParseMarket(market interface{}) interface{}  {
    var marketId interface{} = this.SafeString(market, "symbol")
    var numericId interface{} = this.SafeNumber(market, "id")
    var marketType interface{} = "swap"
    var baseId interface{} = this.SafeString(market, "underlyingSymbol")
    var quoteId interface{} = this.SafeString(market, "settlementSymbol")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settleId interface{} = this.SafeString(market, "settlementSymbol")
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
    var created interface{} = this.SafeIntegerProduct(market, "marketCreationTimestamp", 1000)
    return map[string]interface{} {
        "id": marketId,
        "numericId": numericId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": marketType,
        "spot": false,
        "margin": false,
        "swap": true,
        "future": false,
        "option": false,
        "active": IsEqual(this.SafeString(market, "status"), "LIVE"),
        "contract": true,
        "linear": true,
        "inverse": false,
        "contractSize": this.ParseNumber("1"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "underlyingDecimals"))),
            "price": Divide(this.ParseNumber(GetValue(this.SafeList(market, "orderbookGranularities"), 0)), 10000),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "minNotional"),
                "max": nil,
            },
        },
        "created": created,
        "info": market,
    }
}
/**
 * @method
 * @name hibachi#fetchMarkets
 * @description retrieves data on all markets for hibachi
 * @see https://api-doc.hibachi.xyz/#183981da-8df5-40a0-a155-da15015dd536
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *hibachi) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarketExchangeInfo(params))
            PanicOnError(response)
            // {
            //     "displayName": "ETH/USDT Perps",
            //     "id": 1,
            //     "maintenanceFactorForPositions": "0.030000",
            //     "marketCloseTimestamp": null,
            //     "marketOpenTimestamp": null,
            //     "minNotional": "1",
            //     "minOrderSize": "0.000000001",
            //     "orderbookGranularities": [
            //         "0.01",
            //         "0.1",
            //         "1",
            //         "10"
            //     ],
            //     "riskFactorForOrders": "0.066667",
            //     "riskFactorForPositions": "0.030000",
            //     "settlementDecimals": 6,
            //     "settlementSymbol": "USDT",
            //     "status": "LIVE",
            //     "stepSize": "0.000000001",
            //     "symbol": "ETH/USDT-P",
            //     "tickSize": "0.000001",
            //     "underlyingDecimals": 9,
            //     "underlyingSymbol": "ETH"
            // },
            var rows interface{} = this.SafeList(response, "futureContracts")
        
            ch <- this.ParseMarkets(rows)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api-doc.hibachi.xyz/#183981da-8df5-40a0-a155-da15015dd536
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *hibachi) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // Hibachi only supports USDT on Arbitrum at this time
            // We don't have an API endpoint to expose this information yet
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var result interface{} = map[string]interface{} {}
            var networks interface{} = map[string]interface{} {}
            var networkId interface{} = "ARBITRUM"
            AddElementToObject(networks, networkId, map[string]interface{} {
            "id": networkId,
            "network": networkId,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "info": map[string]interface{} {},
        })
            var code interface{} = this.SafeCurrencyCode("USDT")
            AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": "USDT",
            "name": "USDT",
            "type": "fiat",
            "code": code,
            "precision": this.ParseNumber("0.000001"),
            "active": true,
            "fee": nil,
            "networks": networks,
            "deposit": true,
            "withdraw": true,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "info": map[string]interface{} {},
        }))
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    // Hibachi only supports USDT on Arbitrum at this time
    var code interface{} = this.SafeCurrencyCode("USDT")
    var account interface{} = this.Account()
    AddElementToObject(account, "total", this.SafeString(response, "balance"))
    AddElementToObject(account, "free", this.SafeString(response, "maximalWithdraw"))
    AddElementToObject(result, code, account)
    return this.SafeBalance(result)
}
/**
 * @method
 * @name hibachi#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-doc.hibachi.xyz/#69aafedb-8274-4e21-bbaf-91dace8b8f31
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *hibachi) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeAccountInfo(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     assets: [ { quantity: '3.000000', symbol: 'USDT' } ],
            //     balance: '3.000000',
            //     maximalWithdraw: '3.000000',
            //     numFreeTransfersRemaining: '100',
            //     positions: [],
            //     totalOrderNotional: '0.000000',
            //     totalPositionNotional: '0.000000',
            //     totalUnrealizedFundingPnl: '0.000000',
            //     totalUnrealizedPnl: '0.000000',
            //     totalUnrealizedTradingPnl: '0.000000',
            //     tradeMakerFeeRate: '0.00000000',
            //     tradeTakerFeeRate: '0.00020000'
            // }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var prices interface{} = this.SafeDict(ticker, "prices")
    var stats interface{} = this.SafeDict(ticker, "stats")
    var bid interface{} = this.SafeNumber(prices, "bidPrice")
    var ask interface{} = this.SafeNumber(prices, "askPrice")
    var last interface{} = this.SafeNumber(prices, "tradePrice")
    var high interface{} = this.SafeNumber(stats, "high24h")
    var low interface{} = this.SafeNumber(stats, "low24h")
    var volume interface{} = this.SafeNumber(stats, "volume24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(nil, market),
        "timestamp": nil,
        "datetime": nil,
        "bid": bid,
        "ask": ask,
        "last": last,
        "high": high,
        "low": low,
        "bidVolume": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": volume,
        "info": ticker,
    }, market)
}
func  (this *hibachi) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // public fetchTrades:
    //      {
    //          "price": "3512.431902",
    //          "quantity": "1.414780098",
    //          "takerSide": "Buy",
    //          "timestamp": 1712692147
    //      }
    //
    // private fetchMyTrades:
    //      {
    //          "askAccountId": 221,
    //          "askOrderId": 589168494921909200,
    //          "bidAccountId": 132,
    //          "bidOrderId": 589168494829895700,
    //          "fee": "0.000477",
    //          "id": 199511136,
    //          "orderType": "MARKET",
    //          "price": "119257.90000",
    //          "quantity": "0.0000200000",
    //          "realizedPnl": "-0.000352",
    //          "side": "Sell",
    //          "symbol": "BTC/USDT-P",
    //          "timestamp": 1752543391
    //      }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeString(trade, "id")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "quantity")
    var timestamp interface{} = this.SafeIntegerProduct(trade, "timestamp", 1000)
    var cost interface{} = Precise.StringMul(price, amount)
    var side interface{} = nil
    var fee interface{} = nil
    var orderType interface{} = nil
    var orderId interface{} = nil
    var takerOrMaker interface{} = nil
    if IsTrue(IsEqual(id, nil)) {
        // public trades
        side = this.SafeStringLower(trade, "takerSide")
        takerOrMaker = "taker"
    } else {
        // private trades
        side = this.SafeStringLower(trade, "side")
        fee = map[string]interface{} {
            "cost": this.SafeString(trade, "fee"),
            "currency": "USDT",
        }
        orderType = this.SafeStringLower(trade, "orderType")
        if IsTrue(IsEqual(side, "buy")) {
            orderId = this.SafeString(trade, "bidOrderId")
        } else {
            orderId = this.SafeString(trade, "askOrderId")
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "order": orderId,
        "takerOrMaker": takerOrMaker,
        "type": orderType,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name hibachi#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-doc.hibachi.xyz/#86a53bc1-d3bb-4b93-8a11-7034d4698caa
 * @param {string} symbol unified market symbol
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (maximum value is 100)
 * @param {object} [params] extra parameters specific to the hibachi api endpoint
 * @returns {object[]} a list of recent [trade structures]
 */
func  (this *hibachi) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5998 := (<-this.LoadMarkets())
            PanicOnError(retRes5998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketDataTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "trades": [
            //         {
            //             "price": "111091.38352",
            //             "quantity": "0.0090090093",
            //             "takerSide": "Buy",
            //             "timestamp": 1752095479
            //         },
            //     ]
            // }
            //
            var trades interface{} = this.SafeList(response, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchTicker
 * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
 * @description fetches a price ticker and the related information for the past 24h
 * @param {string} symbol unified symbol of the market
 * @param {object} [params] extra parameters specific to the hibachi api endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hibachi) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6318 := (<-this.LoadMarkets())
            PanicOnError(retRes6318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var rawPromises interface{} = []interface{}{this.PublicGetMarketDataPrices(this.Extend(request, params)), this.PublicGetMarketDataStats(this.Extend(request, params))}
        
            promises:= (<-promiseAll(rawPromises))
            PanicOnError(promises)
            var pricesResponse interface{} = GetValue(promises, 0)
            // {
            //     "askPrice": "3514.650296",
            //     "bidPrice": "3513.596112",
            //     "fundingRateEstimation": {
            //         "estimatedFundingRate": "0.000001",
            //         "nextFundingTimestamp": 1712707200
            //     },
            //     "markPrice": "3514.288858",
            //     "spotPrice": "3514.715000",
            //     "symbol": "ETH/USDT-P",
            //     "tradePrice": "2372.746570"
            // }
            var statsResponse interface{} = GetValue(promises, 1)
            // {
            //     "high24h": "3819.507827",
            //     "low24h": "3754.474162",
            //     "symbol": "ETH/USDT-P",
            //     "volume24h": "23554.858590416"
            // }
            var ticker interface{} = map[string]interface{} {
                "prices": pricesResponse,
                "stats": statsResponse,
            }
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PENDING": "open",
        "CHILD_PENDING": "open",
        "SCHEDULED_TWAP": "open",
        "PLACED": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "CANCELLED": "canceled",
        "REJECTED": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hibachi) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var status interface{} = this.SafeString(order, "status")
    var typeVar interface{} = this.SafeStringLower(order, "orderType")
    var price interface{} = this.SafeString(order, "price")
    var rawSide interface{} = this.SafeString(order, "side")
    var side interface{} = nil
    if IsTrue(IsEqual(rawSide, "BID")) {
        side = "buy"
    } else if IsTrue(IsEqual(rawSide, "ASK")) {
        side = "sell"
    }
    var amount interface{} = this.SafeString(order, "totalQuantity")
    var remaining interface{} = this.SafeString(order, "availableQuantity")
    var totalQuantity interface{} = this.SafeString(order, "totalQuantity")
    var availableQuantity interface{} = this.SafeString(order, "availableQuantity")
    var filled interface{} = nil
    if IsTrue(IsTrue(!IsEqual(totalQuantity, nil)) && IsTrue(!IsEqual(availableQuantity, nil))) {
        filled = Precise.StringSub(totalQuantity, availableQuantity)
    }
    var timeInForce interface{} = "GTC"
    var orderFlags interface{} = this.SafeValue(order, "orderFlags")
    var postOnly interface{} = false
    var reduceOnly interface{} = false
    if IsTrue(IsEqual(orderFlags, "POST_ONLY")) {
        timeInForce = "PO"
        postOnly = true
    } else if IsTrue(IsEqual(orderFlags, "IOC")) {
        timeInForce = "IOC"
    } else if IsTrue(IsEqual(orderFlags, "REDUCE_ONLY")) {
        reduceOnly = true
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": nil,
        "datetime": nil,
        "timestamp": nil,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": nil,
        "status": this.ParseOrderStatus(status),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": price,
        "average": nil,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "cost": nil,
        "trades": nil,
        "fee": nil,
        "reduceOnly": reduceOnly,
        "postOnly": postOnly,
        "triggerPrice": this.SafeNumber(order, "triggerPrice"),
    }, market)
}
/**
 * @method
 * @name hibachi#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api-doc.hibachi.xyz/#096a8854-b918-4de8-8731-b2a28d26b96d
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7538 := (<-this.LoadMarkets())
            PanicOnError(retRes7538)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "orderId": id,
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchTradingFees
 * @description fetch the trading fee
 * @param params extra parameters
 * @returns {object} a map of market symbols to [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *hibachi) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7748 := (<-this.LoadMarkets())
            PanicOnError(retRes7748)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeAccountInfo(this.Extend(request, params)))
            PanicOnError(response)
            //    {
            //        "tradeMakerFeeRate": "0.00000000",
            //        "tradeTakerFeeRate": "0.00020000"
            //    },
            var makerFeeRate interface{} = this.SafeNumber(response, "tradeMakerFeeRate")
            var takerFeeRate interface{} = this.SafeNumber(response, "tradeTakerFeeRate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": makerFeeRate,
            "taker": takerFeeRate,
            "percentage": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) OrderMessage(market interface{}, nonce interface{}, feeRate interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    var sideInternal interface{} = 0
    if IsTrue(IsEqual(side, "sell")) {
        sideInternal = 0
    } else if IsTrue(IsEqual(side, "buy")) {
        sideInternal = 1
    }
    // Converting them to internal representation:
    // - Quantity: Internal = External * (10^underlyingDecimals)
    // - Price: Internal = External * (2^32) * (10^(settlementDecimals-underlyingDecimals))
    // - FeeRate: Internal = External * (10^8)
    var amountStr interface{} = this.AmountToPrecision(this.SafeString(market, "symbol"), amount)
    var feeRateStr interface{} = this.NumberToString(feeRate)
    var info interface{} = this.SafeDict(market, "info")
    var underlying interface{} = Add("1e", this.SafeString(info, "underlyingDecimals"))
    var settlement interface{} = Add("1e", this.SafeString(info, "settlementDecimals"))
    var one interface{} = "1"
    var feeRateFactor interface{} = "100000000" // 10^8
    var priceFactor interface{} = "4294967296" // 2^32
    var quantityInternal interface{} = Precise.StringDiv(Precise.StringMul(amountStr, underlying), one, 0)
    var feeRateInternal interface{} = Precise.StringDiv(Precise.StringMul(feeRateStr, feeRateFactor), one, 0)
    // Encoding
    var nonce16 interface{} = this.IntToBase16(nonce)
    var noncePadded interface{} = PadStart(nonce16, 16, "0")
    var encodedNonce interface{} = this.Base16ToBinary(noncePadded)
    var numericId interface{} = this.IntToBase16(this.SafeInteger(market, "numericId"))
    var numericIdPadded interface{} = PadStart(numericId, 8, "0")
    var encodedMarketId interface{} = this.Base16ToBinary(numericIdPadded)
    var quantity16 interface{} = this.IntToBase16(this.ParseToInt(quantityInternal))
    var quantityPadded interface{} = PadStart(quantity16, 16, "0")
    var encodedQuantity interface{} = this.Base16ToBinary(quantityPadded)
    var sideInternal16 interface{} = this.IntToBase16(sideInternal)
    var sidePadded interface{} = PadStart(sideInternal16, 8, "0")
    var encodedSide interface{} = this.Base16ToBinary(sidePadded)
    var feeRateInternal16 interface{} = this.IntToBase16(this.ParseToInt(feeRateInternal))
    var feeRatePadded interface{} = PadStart(feeRateInternal16, 16, "0")
    var encodedFeeRate interface{} = this.Base16ToBinary(feeRatePadded)
    var encodedPrice interface{} = this.BinaryConcat()
    if IsTrue(IsEqual(typeVar, "limit")) {
        var priceStr interface{} = this.PriceToPrecision(this.SafeString(market, "symbol"), price)
        var priceInternal interface{} = Precise.StringDiv(Precise.StringDiv(Precise.StringMul(Precise.StringMul(priceStr, priceFactor), settlement), underlying), one, 0)
        var price16 interface{} = this.IntToBase16(this.ParseToInt(priceInternal))
        var pricePadded interface{} = PadStart(price16, 16, "0")
        encodedPrice = this.Base16ToBinary(pricePadded)
    }
    var message interface{} = this.BinaryConcat(encodedNonce, encodedMarketId, encodedQuantity, encodedSide, encodedPrice, encodedFeeRate)
    return message
}
func  (this *hibachi) CreateOrderRequest(nonce interface{}, symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var feeRate interface{} = mathMax(this.SafeNumber(market, "taker"), this.SafeNumber(market, "maker"))
    var sideInternal interface{} = ""
    if IsTrue(IsEqual(side, "sell")) {
        sideInternal = "ASK"
    } else if IsTrue(IsEqual(side, "buy")) {
        sideInternal = "BID"
    }
    var priceInternal interface{} = ""
    if IsTrue(price) {
        priceInternal = this.PriceToPrecision(symbol, price)
    }
    var message interface{} = this.OrderMessage(market, nonce, feeRate, typeVar, side, amount, price)
    var signature interface{} = this.SignMessage(message, this.PrivateKey)
    var request interface{} = map[string]interface{} {
        "symbol": this.SafeString(market, "id"),
        "nonce": nonce,
        "side": sideInternal,
        "orderType": ToUpper(typeVar),
        "quantity": this.AmountToPrecision(symbol, amount),
        "price": priceInternal,
        "signature": signature,
        "maxFeesPercent": this.NumberToString(feeRate),
    }
    var postOnly interface{} = this.IsPostOnly(IsEqual(ToUpper(typeVar), "MARKET"), nil, params)
    var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
    var timeInForce interface{} = this.SafeStringLower(params, "timeInForce")
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    if IsTrue(postOnly) {
        AddElementToObject(request, "orderFlags", "POST_ONLY")
    } else if IsTrue(IsEqual(timeInForce, "ioc")) {
        AddElementToObject(request, "orderFlags", "IOC")
    } else if IsTrue(reduceOnly) {
        AddElementToObject(request, "orderFlags", "REDUCE_ONLY")
    }
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        AddElementToObject(request, "triggerPrice", triggerPrice)
    }
    params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only", "postOnly", "timeInForce", "stopPrice", "triggerPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name hibachi#createOrder
 * @description create a trade order
 * @see https://api-doc.hibachi.xyz/#00f6d5ad-5275-41cb-a1a8-19ed5d142124
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9058 := (<-this.LoadMarkets())
            PanicOnError(retRes9058)
            var nonce interface{} = this.Nonce()
            var request interface{} = this.CreateOrderRequest(nonce, symbol, typeVar, side, amount, price, params)
            AddElementToObject(request, "accountId", this.GetAccountId())
        
            response:= (<-this.PrivatePostTradeOrder(request))
            PanicOnError(response)
        
                //
            // {
            //     "orderId": "578721673790138368"
            // }
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "id": this.SafeString(response, "orderId"),
                "status": "pending",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#createOrders
 * @description *contract only* create a list of trade orders
 * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9318 := (<-this.LoadMarkets())
            PanicOnError(retRes9318)
            var nonce interface{} = this.Nonce()
            var requestOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var symbol interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateOrderRequest(Add(nonce, i), symbol, typeVar, side, amount, price, orderParams)
                AddElementToObject(orderRequest, "action", "place")
                AppendToArray(&requestOrders, orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
                "orders": requestOrders,
            }
        
            response:= (<-this.PrivatePostTradeOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // { "orders": [ { nonce: '1754349993908', orderId: '589642085255349248' } ] }
            //
            var ret interface{} = []interface{}{}
            var responseOrders interface{} = this.SafeList(response, "orders")
            for i := 0; IsLessThan(i, GetArrayLength(responseOrders)); i++ {
                var responseOrder interface{} = GetValue(responseOrders, i)
                AppendToArray(&ret, this.SafeOrder(map[string]interface{} {
                    "info": responseOrder,
                    "id": this.SafeString(responseOrder, "orderId"),
                    "status": "pending",
                }))
            }
        
            ch <- ret
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) EditOrderRequest(nonce interface{}, id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{}  {
    amount := GetArg(optionalArgs, 0, nil)
    _ = amount
    price := GetArg(optionalArgs, 1, nil)
    _ = price
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var feeRate interface{} = mathMax(this.SafeNumber(market, "taker"), this.SafeNumber(market, "maker"))
    var message interface{} = this.OrderMessage(market, nonce, feeRate, typeVar, side, amount, price)
    var signature interface{} = this.SignMessage(message, this.PrivateKey)
    var request interface{} = map[string]interface{} {
        "orderId": id,
        "nonce": nonce,
        "updatedQuantity": this.AmountToPrecision(symbol, amount),
        "updatedPrice": this.PriceToPrecision(symbol, price),
        "maxFeesPercent": this.NumberToString(feeRate),
        "signature": signature,
    }
    return this.Extend(request, params)
}
/**
 * @method
 * @name hibachi#editOrder
 * @description edit a limit order that is not matched
 * @see https://api-doc.hibachi.xyz/#94d2cdaf-1c71-440f-a981-da1112824810
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell', should stay the same with original side
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9988 := (<-this.LoadMarkets())
            PanicOnError(retRes9988)
            var nonce interface{} = this.Nonce()
            var request interface{} = this.EditOrderRequest(nonce, id, symbol, typeVar, side, amount, price, params)
            AddElementToObject(request, "accountId", this.GetAccountId())
        
            retRes10028 := (<-this.PrivatePutTradeOrder(request))
            PanicOnError(retRes10028)
        
                // At this time the response body is empty. A 200 response means the update request is accepted and sent to process
            //
            // {}
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "status": "pending",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#editOrders
 * @description edit a list of trade orders
 * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
 * @param {Array} orders list of orders to edit, each object should contain the parameters required by editOrder, namely id, symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) EditOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10238 := (<-this.LoadMarkets())
            PanicOnError(retRes10238)
            var nonce interface{} = this.Nonce()
            var requestOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var id interface{} = this.SafeString(rawOrder, "id")
                var symbol interface{} = this.SafeString(rawOrder, "symbol")
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.EditOrderRequest(Add(nonce, i), id, symbol, typeVar, side, amount, price, orderParams)
                AddElementToObject(orderRequest, "action", "modify")
                AppendToArray(&requestOrders, orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
                "orders": requestOrders,
            }
        
            response:= (<-this.PrivatePostTradeOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // { "orders": [ { "orderId": "589636801329628160" } ] }
            //
            var ret interface{} = []interface{}{}
            var responseOrders interface{} = this.SafeList(response, "orders")
            for i := 0; IsLessThan(i, GetArrayLength(responseOrders)); i++ {
                var responseOrder interface{} = GetValue(responseOrders, i)
                AppendToArray(&ret, this.SafeOrder(map[string]interface{} {
                    "info": responseOrder,
                    "id": this.SafeString(responseOrder, "orderId"),
                    "status": "pending",
                }))
            }
        
            ch <- ret
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) CancelOrderRequest(id interface{}) interface{}  {
    var bigid interface{} = this.ConvertToBigInt(id)
    var idbase16 interface{} = this.IntToBase16(bigid)
    var idPadded interface{} = PadStart(idbase16, 16, "0")
    var message interface{} = this.Base16ToBinary(idPadded)
    var signature interface{} = this.SignMessage(message, this.PrivateKey)
    return map[string]interface{} {
        "orderId": id,
        "signature": signature,
    }
}
/**
 * @method
 * @name hibachi#cancelOrder
 * @see https://api-doc.hibachi.xyz/#e99c4f48-e610-4b7c-b7f6-1b4bb7af0271
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol is unused
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = this.CancelOrderRequest(id)
            AddElementToObject(request, "accountId", this.GetAccountId())
        
            response:= (<-this.PrivateDeleteTradeOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                // At this time the response body is empty. A 200 response means the cancel request is accepted and sent to cancel
            //
            // {}
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": id,
                "status": "canceled",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#cancelOrders
 * @description cancel multiple orders
 * @see https://api-doc.hibachi.xyz/#c2840b9b-f02c-44ed-937d-dc2819f135b4
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol, unused
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var orders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var orderRequest interface{} = this.CancelOrderRequest(GetValue(ids, i))
                AddElementToObject(orderRequest, "action", "cancel")
                AppendToArray(&orders, orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
                "orders": orders,
            }
        
            response:= (<-this.PrivatePostTradeOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // { "orders": [ { "orderId": "589636801329628160" } ] }
            //
            var ret interface{} = []interface{}{}
            var responseOrders interface{} = this.SafeList(response, "orders")
            for i := 0; IsLessThan(i, GetArrayLength(responseOrders)); i++ {
                var responseOrder interface{} = GetValue(responseOrders, i)
                AppendToArray(&ret, this.SafeOrder(map[string]interface{} {
                    "info": responseOrder,
                    "id": this.SafeString(responseOrder, "orderId"),
                    "status": "canceled",
                }))
            }
        
            ch <- ret
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#cancelAllOrders
 * @see https://api-doc.hibachi.xyz/#8ed24695-016e-49b2-a72d-7511ca921fee
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11458 := (<-this.LoadMarkets())
            PanicOnError(retRes11458)
            var nonce interface{} = this.Nonce()
            var nonce16 interface{} = this.IntToBase16(nonce)
            var noncePadded interface{} = PadStart(nonce16, 16, "0")
            var message interface{} = this.Base16ToBinary(noncePadded)
            var signature interface{} = this.SignMessage(message, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
                "nonce": nonce,
                "signature": signature,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "contractId", this.SafeInteger(market, "numericId"))
            }
        
            response:= (<-this.PrivateDeleteTradeOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                // At this time the response body is empty. A 200 response means the cancel request is accepted and sent to process
            //
            // {}
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) EncodeWithdrawMessage(amount interface{}, maxFees interface{}, address interface{}) interface{}  {
    // Converting them to internal representation:
    // - Quantity: Internal = External * (10^6)
    // - maxFees: Internal = External * (10^6)
    // We only have USDT as our currency as this time
    var USDTAssetId interface{} = 1
    var USDTFactor interface{} = "1000000"
    var amountStr interface{} = this.NumberToString(amount)
    var maxFeesStr interface{} = this.NumberToString(maxFees)
    var one interface{} = "1"
    var quantityInternal interface{} = Precise.StringDiv(Precise.StringMul(amountStr, USDTFactor), one, 0)
    var maxFeesInternal interface{} = Precise.StringDiv(Precise.StringMul(maxFeesStr, USDTFactor), one, 0)
    // Encoding
    var usdtAsset16 interface{} = this.IntToBase16(USDTAssetId)
    var usdtAssetPadded interface{} = PadStart(usdtAsset16, 8, "0")
    var encodedAssetId interface{} = this.Base16ToBinary(usdtAssetPadded)
    var quantity16 interface{} = this.IntToBase16(this.ParseToInt(quantityInternal))
    var quantityPadded interface{} = PadStart(quantity16, 16, "0")
    var encodedQuantity interface{} = this.Base16ToBinary(quantityPadded)
    var maxFees16 interface{} = this.IntToBase16(this.ParseToInt(maxFeesInternal))
    var maxFeesPadded interface{} = PadStart(maxFees16, 16, "0")
    var encodedMaxFees interface{} = this.Base16ToBinary(maxFeesPadded)
    var encodedAddress interface{} = this.Base16ToBinary(address)
    var message interface{} = this.BinaryConcat(encodedAssetId, encodedQuantity, encodedMaxFees, encodedAddress)
    return message
}
/**
 * @method
 * @name hibachi#withdraw
 * @description make a withdrawal
 * @see https://api-doc.hibachi.xyz/#6421625d-3e45-45fa-be9b-d2a0e780c090
 * @param {string} code unified currency code, only support USDT
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hibachi) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var withdrawAddress interface{} = Slice(address, OpNeg(40), nil)
            // Get the withdraw fees
        
            exchangeInfo:= (<-this.PublicGetMarketExchangeInfo(params))
            PanicOnError(exchangeInfo)
            // {
            //      "feeConfig": {
            //          "depositFees": "0.004518",
            //          "tradeMakerFeeRate": "0.00000000",
            //          "tradeTakerFeeRate": "0.00020000",
            //          "transferFeeRate": "0.00010000",
            //          "withdrawalFees": "0.012050"
            //    },
            // }
            var feeConfig interface{} = this.SafeDict(exchangeInfo, "feeConfig")
            var maxFees interface{} = this.SafeNumber(feeConfig, "withdrawalFees")
            // Generate the signature
            var message interface{} = this.EncodeWithdrawMessage(amount, maxFees, withdrawAddress)
            var signature interface{} = this.SignMessage(message, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
                "coin": "USDT",
                "network": "ARBITRUM",
                "withdrawAddress": withdrawAddress,
                "selfWithdrawal": false,
                "quantity": this.NumberToString(amount),
                "maxFees": this.NumberToString(maxFees),
                "signature": signature,
            }
        
            retRes12398 := (<-this.PrivatePostCapitalWithdraw(this.Extend(request, params)))
            PanicOnError(retRes12398)
        
                // At this time the response body is empty. A 200 response means the withdraw request is accepted and sent to process
            //
            // {}
            //
        ch <- map[string]interface{} {
                "info": nil,
                "id": nil,
                "txid": nil,
                "timestamp": this.Milliseconds(),
                "datetime": nil,
                "address": nil,
                "addressFrom": nil,
                "addressTo": withdrawAddress,
                "tag": nil,
                "tagFrom": nil,
                "tagTo": nil,
                "type": "withdrawal",
                "amount": amount,
                "currency": code,
                "status": "pending",
                "fee": map[string]interface{} {
                    "currency": "USDT",
                    "cost": maxFees,
                },
                "network": "ARBITRUM",
                "updated": nil,
                "comment": nil,
                "internal": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *hibachi) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    if IsTrue(IsEqual(GetArrayLength(privateKey), 44)) {
        // For Exchange Managed account, the key length is 44 and we use HMAC to sign the message
        return this.Hmac(message, this.Encode(privateKey), sha256, "hex")
    } else {
        // For Trustless account, the key length is 66 including '0x' and we use ECDSA to sign the message
        var hash interface{} = this.Hash(this.Encode(message), sha256, "hex")
        var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
        var r interface{} = GetValue(signature, "r")
        var s interface{} = GetValue(signature, "s")
        var v interface{} = GetValue(signature, "v")
        return Add(Add(PadStart(r, 64, "0"), PadStart(s, 64, "0")), PadStart(this.IntToBase16(v), 2, "0"))
    }
}
/**
 * @method
 * @name hibachi#fetchOrderBook
 * @description fetches the state of the open orders on the orderbook
 * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
 * @param {string} symbol unified symbol of the market
 * @param {int} [limit] currently unused
 * @param {object} [params] extra parameters to be passed -- see documentation link above
 * @returns {object} A dictionary containg [orderbook information]{@link https://docs.ccxt.com/#/?id=order-book-structure}
 */
func  (this *hibachi) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12988 := (<-this.LoadMarkets())
            PanicOnError(retRes12988)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketDataOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            var formattedResponse interface{} = map[string]interface{} {}
            AddElementToObject(formattedResponse, "ask", this.SafeList(this.SafeDict(response, "ask"), "levels"))
            AddElementToObject(formattedResponse, "bid", this.SafeList(this.SafeDict(response, "bid"), "levels"))
        
                // {
            //     "ask": {
            //         "endPrice": "3512.63",
            //         "levels": [
            //             {
            //                 "price": "3511.93",
            //                 "quantity": "0.284772482"
            //             },
            //             {
            //                 "price": "3512.28",
            //                 "quantity": "0.569544964"
            //             },
            //             {
            //                 "price": "3512.63",
            //                 "quantity": "0.854317446"
            //             }
            //         ],
            //         "startPrice": "3511.93"
            //     },
            //     "bid": {
            //         "endPrice": "3510.87",
            //         "levels": [
            //             {
            //                 "price": "3515.39",
            //                 "quantity": "2.345153070"
            //             },
            //             {
            //                 "price": "3511.22",
            //                 "quantity": "0.284772482"
            //             },
            //             {
            //                 "price": "3510.87",
            //                 "quantity": "0.569544964"
            //             }
            //         ],
            //         "startPrice": "3515.39"
            //     }
            // }
        ch <- this.ParseOrderBook(formattedResponse, symbol, this.Milliseconds(), "bid", "ask", "price", "quantity")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchMyTrades
 * @see https://api-doc.hibachi.xyz/#0adbf143-189f-40e0-afdc-88af4cba3c79
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *hibachi) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13608 := (<-this.LoadMarkets())
            PanicOnError(retRes13608)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeAccountTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "trades": [
            //         {
            //             "askAccountId": 221,
            //             "askOrderId": 589168494921909200,
            //             "bidAccountId": 132,
            //             "bidOrderId": 589168494829895700,
            //             "fee": "0.000477",
            //             "id": 199511136,
            //             "orderType": "MARKET",
            //             "price": "119257.90000",
            //             "quantity": "0.0000200000",
            //             "realizedPnl": "-0.000352",
            //             "side": "Sell",
            //             "symbol": "BTC/USDT-P",
            //             "timestamp": 1752543391
            //         }
            //     ]
            // }
            //
            var trades interface{} = this.SafeList(response, "trades")
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // [
    //     {
    //       "close": "3704.751036",
    //       "high": "3716.530378",
    //       "interval": "1h",
    //       "low": "3699.627883",
    //       "open": "3716.406894",
    //       "timestamp": 1712628000,
    //       "volumeNotional": "1637355.846362"
    //     }
    //   ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeIntegerProduct(ohlcv, "timestamp", 1000), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volumeNotional")}
}
/**
 * @method
 * @name hibachi#fetchOpenOrders
 * @description fetches all current open orders
 * @see https://api-doc.hibachi.xyz/#3243f8a0-086c-44c5-ab8a-71bbb7bab403
 * @param {string} [symbol] unified market symbol to filter by
 * @param {int} [since] milisecond timestamp of the earliest order
 * @param {int} [limit] the maximum number of open orders to return
 * @param {object} [params] extra parameters
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hibachi) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14288 := (<-this.LoadMarkets())
            PanicOnError(retRes14288)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                // [
            //     {
            //         "accountId": 12452,
            //         "availableQuantity": "0.0000230769",
            //         "contractId": 2,
            //         "creationTime": 1752684501,
            //         "orderId": "589205486123876352",
            //         "orderType": "LIMIT",
            //         "price": "130000.00000",
            //         "side": "ASK",
            //         "status": "PLACED",
            //         "symbol": "BTC/USDT-P",
            //         "totalQuantity": "0.0000230769"
            //     },
            //     {
            //         "accountId": 12452,
            //         "availableQuantity": "1.234000000",
            //         "contractId": 1,
            //         "creationTime": 1752240682,
            //         "orderId": "589089141754429441",
            //         "orderType": "LIMIT",
            //         "price": "1.234000",
            //         "side": "BID",
            //         "status": "PLACED",
            //         "symbol": "ETH/USDT-P",
            //         "totalQuantity": "1.234000000"
            //     }
            // ]
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @name hibachi#fetchOHLCV
 * @see  https://api-doc.hibachi.xyz/#4f0eacec-c61e-4d51-afb3-23c51c2c6bac
 * @description fetches historical candlestick data containing the close, high, low, open prices, interval and the volumeNotional
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *hibachi) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14818 := (<-this.LoadMarkets())
            PanicOnError(retRes14818)
            var market interface{} = this.Market(symbol)
            timeframe = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": timeframe,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "fromMs", since)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "toMs", until)
            }
        
            response:= (<-this.PublicGetMarketDataKlines(this.Extend(request, params)))
            PanicOnError(response)
            //
            // [
            //     {
            //       "close": "3704.751036",
            //       "high": "3716.530378",
            //       "interval": "1h",
            //       "low": "3699.627883",
            //       "open": "3716.406894",
            //       "timestamp": 1712628000,
            //       "volumeNotional": "1637355.846362"
            //     }
            //   ]
            //
            var klines interface{} = this.SafeList(response, "klines", []interface{}{})
        
            ch <- this.ParseOHLCVs(klines, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchPositions
 * @description fetch all open positions
 * @see https://api-doc.hibachi.xyz/#69aafedb-8274-4e21-bbaf-91dace8b8f31
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *hibachi) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15248 := (<-this.LoadMarkets())
            PanicOnError(retRes15248)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetTradeAccountInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "assets": [
            //       {
            //         "quantity": "14.130626",
            //         "symbol": "USDT"
            //       }
            //     ],
            //     "balance": "14.186087",
            //     "maximalWithdraw": "4.152340",
            //     "numFreeTransfersRemaining": 96,
            //     "positions": [
            //       {
            //         "direction": "Short",
            //         "entryNotional": "10.302213",
            //         "notionalValue": "10.225008",
            //         "quantity": "0.004310550",
            //         "symbol": "ETH/USDT-P",
            //         "unrealizedFundingPnl": "0.000000",
            //         "unrealizedTradingPnl": "0.077204"
            //       },
            //       {
            //         "direction": "Short",
            //         "entryNotional": "2.000016",
            //         "notionalValue": "1.999390",
            //         "quantity": "0.0000328410",
            //         "symbol": "BTC/USDT-P",
            //         "unrealizedFundingPnl": "0.000000",
            //         "unrealizedTradingPnl": "0.000625"
            //       },
            //       {
            //         "direction": "Short",
            //         "entryNotional": "2.000015",
            //         "notionalValue": "2.022384",
            //         "quantity": "0.01470600",
            //         "symbol": "SOL/USDT-P",
            //         "unrealizedFundingPnl": "0.000000",
            //         "unrealizedTradingPnl": "-0.022369"
            //       }
            //     ],
            //   }
            //
            var data interface{} = this.SafeList(response, "positions", []interface{}{})
        
            ch <- this.ParsePositions(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "direction": "Short",
    //     "entryNotional": "10.302213",
    //     "notionalValue": "10.225008",
    //     "quantity": "0.004310550",
    //     "symbol": "ETH/USDT-P",
    //     "unrealizedFundingPnl": "0.000000",
    //     "unrealizedTradingPnl": "0.077204"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var side interface{} = this.SafeStringLower(position, "direction")
    var quantity interface{} = this.SafeString(position, "quantity")
    var unrealizedFunding interface{} = this.SafeString(position, "unrealizedFundingPnl", "0")
    var unrealizedTrading interface{} = this.SafeString(position, "unrealizedTradingPnl", "0")
    var unrealizedPnl interface{} = Precise.StringAdd(unrealizedFunding, unrealizedTrading)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "entryPrice": this.SafeString(position, "average_entry_price"),
        "markPrice": nil,
        "notional": this.SafeString(position, "notionalValue"),
        "collateral": nil,
        "unrealizedPnl": unrealizedPnl,
        "side": side,
        "contracts": this.ParseNumber(quantity),
        "contractSize": nil,
        "timestamp": nil,
        "datetime": nil,
        "hedged": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "liquidationPrice": nil,
        "marginRatio": nil,
        "marginMode": nil,
        "percentage": nil,
    })
}
func  (this *hibachi) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
    headers = map[string]interface{} {}
    if IsTrue(IsEqual(method, "GET")) {
        var request interface{} = this.Omit(params, this.ExtractParams(path))
        var query interface{} = this.Urlencode(request)
        if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
            url = Add(url, Add("?", query))
        }
    }
    if IsTrue(IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "PUT"))) || IsTrue(IsEqual(method, "DELETE"))) {
        AddElementToObject(headers, "Content-Type", "application/json")
        body = this.Json(params)
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        AddElementToObject(headers, "Authorization", this.ApiKey)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *hibachi) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "status")) {
        //
        //     {"errorCode":4,"message":"Invalid input: Invalid quantity: 0","status":"failed"}
        //
        var status interface{} = this.SafeString(response, "status")
        if IsTrue(IsEqual(status, "failed")) {
            var code interface{} = this.SafeString(response, "errorCode")
            var feedback interface{} = Add(Add(this.Id, " "), body)
            this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
            var message interface{} = this.SafeString(response, "message")
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}
func  (this *hibachi) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "deposit": "transaction",
        "withdrawal": "transaction",
        "transfer-in": "transfer",
        "transfer-out": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *hibachi) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "pending",
        "claimable": "pending",
        "completed": "ok",
        "failed": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hibachi) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var transactionType interface{} = this.SafeString(item, "transactionType")
    var timestamp interface{} = nil
    var typeVar interface{} = nil
    var direction interface{} = nil
    var amount interface{} = nil
    var fee interface{} = nil
    var referenceId interface{} = nil
    var referenceAccount interface{} = nil
    var status interface{} = nil
    if IsTrue(IsEqual(transactionType, nil)) {
        // response from TradeAccountTradingHistory
        timestamp = this.SafeIntegerProduct(item, "timestamp", 1000)
        typeVar = "trade"
        var amountStr interface{} = this.SafeString(item, "realizedPnl")
        if IsTrue(Precise.StringLt(amountStr, "0")) {
            direction = "out"
            amountStr = Precise.StringNeg(amountStr)
        } else {
            direction = "in"
        }
        amount = this.ParseNumber(amountStr)
        fee = map[string]interface{} {
            "currency": "USDT",
            "cost": this.SafeNumber(item, "fee"),
        }
        status = "ok"
    } else {
        // response from CapitalHistory
        timestamp = this.SafeIntegerProduct(item, "timestampSec", 1000)
        amount = this.SafeNumber(item, "quantity")
        direction = Ternary(IsTrue((IsTrue(IsEqual(transactionType, "deposit")) || IsTrue(IsEqual(transactionType, "transfer-in")))), "in", "out")
        typeVar = this.ParseTransactionType(transactionType)
        status = this.ParseTransactionStatus(this.SafeString(item, "status"))
        if IsTrue(IsEqual(transactionType, "transfer-in")) {
            referenceAccount = this.SafeString(item, "srcAccountId")
        } else if IsTrue(IsEqual(transactionType, "transfer-out")) {
            referenceAccount = this.SafeString(item, "receivingAccountId")
        }
        referenceId = this.SafeString(item, "transactionHash")
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "id": this.SafeString(item, "id"),
        "currency": this.Currency("USDT"),
        "account": this.NumberToString(this.AccountId),
        "referenceAccount": referenceAccount,
        "referenceId": referenceId,
        "status": status,
        "amount": amount,
        "before": nil,
        "after": nil,
        "fee": fee,
        "direction": direction,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "type": typeVar,
        "info": item,
    }, currency)
}
/**
 * @method
 * @name hibachi#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *hibachi) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17568 := (<-this.LoadMarkets())
            PanicOnError(retRes17568)
            var currency interface{} = this.Currency("USDT")
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
            var rawPromises interface{} = []interface{}{this.PrivateGetCapitalHistory(this.Extend(request, params)), this.PrivateGetTradeAccountTradingHistory(this.Extend(request, params))}
        
            promises:= (<-promiseAll(rawPromises))
            PanicOnError(promises)
            var responseCapitalHistory interface{} = GetValue(promises, 0)
            //
            // {
            //     "transactions": [
            //         {
            //             "assetId": 1,
            //             "blockNumber": 358396669,
            //             "chain": "Arbitrum",
            //             "etaTsSec": null,
            //             "id": 358396669,
            //             "quantity": "0.999500",
            //             "status": "pending",
            //             "timestampSec": 1752692872,
            //             "token": "USDT",
            //             "transactionHash": "0x408e48881e0ba77d8638e3fe57bc06bdec513ddaa8b672e0aefa7e22e2f18b5e",
            //             "transactionType": "deposit"
            //         },
            //         {
            //             "assetId": 1,
            //             "etaTsSec": null,
            //             "id": 13116,
            //             "instantWithdrawalChain": null,
            //             "instantWithdrawalToken": null,
            //             "isInstantWithdrawal": false,
            //             "quantity": "0.040000",
            //             "status": "completed",
            //             "timestampSec": 1752542708,
            //             "transactionHash": "0xe89cf90b2408d1a273dc9427654145def102d9449e5e2cfc10690ccffc3d7e28",
            //             "transactionType": "withdrawal",
            //             "withdrawalAddress": "0x23625d5fc6a6e32638d908eb4c3a3415e5121f76"
            //         },
            //         {
            //             "assetId": 1,
            //             "id": 167,
            //             "quantity": "10.000000",
            //             "srcAccountId": 175,
            //             "srcAddress": "0xc2f77ce029438a3fdfe68ddee25991a9fb985a86",
            //             "status": "completed",
            //             "timestampSec": 1732224729,
            //             "transactionType": "transfer-in"
            //         },
            //         {
            //             "assetId": 1,
            //             "id": 170,
            //             "quantity": "10.000000",
            //             "receivingAccountId": 175,
            //             "receivingAddress": "0xc2f77ce029438a3fdfe68ddee25991a9fb985a86",
            //             "status": "completed",
            //             "timestampSec": 1732225631,
            //             "transactionType": "transfer-out"
            //         },
            //     ]
            // }
            //
            var rowsCapitalHistory interface{} = this.SafeList(responseCapitalHistory, "transactions")
            var responseTradingHistory interface{} = GetValue(promises, 1)
            //
            // {
            //     "tradingHistory": [
            //         {
            //             "eventType": "MARKET",
            //             "fee": "0.000008",
            //             "priceOrFundingRate": "119687.82481",
            //             "quantity": "0.0000003727",
            //             "realizedPnl": "0.004634",
            //             "side": "Sell",
            //             "symbol": "BTC/USDT-P",
            //             "timestamp": 1752522571
            //         },
            //         {
            //             "eventType": "FundingEvent",
            //             "fee": "0",
            //             "priceOrFundingRate": "0.000203",
            //             "quantity": "0.0000003727",
            //             "realizedPnl": "-0.000009067899008751979",
            //             "side": "Long",
            //             "symbol": "BTC/USDT-P",
            //             "timestamp": 1752508800
            //         },
            //     ]
            // }
            //
            var rowsTradingHistory interface{} = this.SafeList(responseTradingHistory, "tradingHistory")
            var rows interface{} = this.ArrayConcat(rowsCapitalHistory, rowsTradingHistory)
        
            ch <- this.ParseLedger(rows, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchDepositAddress
 * @description fetch deposit address for given currency and chain. currently, we have a single EVM address across multiple EVM chains. Note: This method is currently only supported for trustless accounts
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters for API
 * @param {string} [params.publicKey] your public key, you can get it from UI after creating API key
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *hibachi) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "publicKey": this.SafeString(params, "publicKey"),
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetCapitalDepositInfo(this.Extend(request, params)))
            PanicOnError(response)
        
                // {
            //     "depositAddressEvm": "0x0b95d90b9345dadf1460bd38b9f4bb0d2f4ed788"
            // }
        ch <- map[string]interface{} {
                "info": response,
                "currency": "USDT",
                "network": "ARBITRUM",
                "address": this.SafeString(response, "depositAddressEvm"),
                "tag": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *hibachi) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeIntegerProduct(transaction, "timestampSec", 1000)
    var address interface{} = this.SafeString(transaction, "withdrawalAddress")
    var transactionType interface{} = this.SafeString(transaction, "transactionType")
    if IsTrue(IsTrue(!IsEqual(transactionType, "deposit")) && IsTrue(!IsEqual(transactionType, "withdrawal"))) {
        transactionType = this.ParseTransactionType(transactionType)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "transactionHash"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": "ARBITRUM",
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": transactionType,
        "amount": this.SafeNumber(transaction, "quantity"),
        "currency": "USDT",
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": nil,
    }
}
/**
 * @method
 * @name hibachi#fetchDeposits
 * @description fetch deposits made to account
 * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
 * @param {string} [code] unified currency code
 * @param {int} [since] filter by earliest timestamp (ms)
 * @param {int} [limit] maximum number of deposits to be returned
 * @param {object} [params] extra parameters to be passed to API
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hibachi) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var currency interface{} = this.SafeCurrency(code)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetCapitalHistory(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "transactions": [
            //         {
            //             "assetId": 1,
            //             "blockNumber": 0,
            //             "chain": null,
            //             "etaTsSec": 1752758789,
            //             "id": 42688,
            //             "quantity": "6.130000",
            //             "status": "completed",
            //             "timestampSec": 1752758788,
            //             "token": null,
            //             "transactionHash": "0x8dcd7bd1155b5624fb5e38a1365888f712ec633a57434340e05080c70b0e3bba",
            //             "transactionType": "deposit"
            //         },
            //         {
            //             "assetId": 1,
            //             "etaTsSec": null,
            //             "id": 12993,
            //             "instantWithdrawalChain": null,
            //             "instantWithdrawalToken": null,
            //             "isInstantWithdrawal": false,
            //             "quantity": "0.111930",
            //             "status": "completed",
            //             "timestampSec": 1752387891,
            //             "transactionHash": "0x32ab5fe5b90f6d753bab83523ebc8465eb9daef54580e13cb9ff031d400c5620",
            //             "transactionType": "withdrawal",
            //             "withdrawalAddress": "0x43f15ef2ef2ab5e61e987ee3d652a5872aea8a6c"
            //         },
            //     ]
            // }
            var transactions interface{} = this.SafeList(response, "transactions")
            var deposits interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(transactions)); i++ {
                var transaction interface{} = GetValue(transactions, i)
                if IsTrue(IsEqual(this.SafeString(transaction, "transactionType"), "deposit")) {
                    AppendToArray(&deposits, transaction)
                }
            }
        
            ch <- this.ParseTransactions(deposits, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchWithdrawals
 * @description fetch withdrawals made from account
 * @see https://api-doc.hibachi.xyz/#35125e3f-d154-4bfd-8276-a48bb1c62020
 * @param {string} [code] unified currency code
 * @param {int} [since] filter by earliest timestamp (ms)
 * @param {int} [limit] maximum number of deposits to be returned
 * @param {object} [params] extra parameters to be passed to API
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hibachi) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var currency interface{} = this.SafeCurrency(code)
            var request interface{} = map[string]interface{} {
                "accountId": this.GetAccountId(),
            }
        
            response:= (<-this.PrivateGetCapitalHistory(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "transactions": [
            //         {
            //             "assetId": 1,
            //             "blockNumber": 0,
            //             "chain": null,
            //             "etaTsSec": 1752758789,
            //             "id": 42688,
            //             "quantity": "6.130000",
            //             "status": "completed",
            //             "timestampSec": 1752758788,
            //             "token": null,
            //             "transactionHash": "0x8dcd7bd1155b5624fb5e38a1365888f712ec633a57434340e05080c70b0e3bba",
            //             "transactionType": "deposit"
            //         },
            //         {
            //             "assetId": 1,
            //             "etaTsSec": null,
            //             "id": 12993,
            //             "instantWithdrawalChain": null,
            //             "instantWithdrawalToken": null,
            //             "isInstantWithdrawal": false,
            //             "quantity": "0.111930",
            //             "status": "completed",
            //             "timestampSec": 1752387891,
            //             "transactionHash": "0x32ab5fe5b90f6d753bab83523ebc8465eb9daef54580e13cb9ff031d400c5620",
            //             "transactionType": "withdrawal",
            //             "withdrawalAddress": "0x43f15ef2ef2ab5e61e987ee3d652a5872aea8a6c"
            //         },
            //     ]
            // }
            var transactions interface{} = this.SafeList(response, "transactions")
            var withdrawals interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(transactions)); i++ {
                var transaction interface{} = GetValue(transactions, i)
                if IsTrue(IsEqual(this.SafeString(transaction, "transactionType"), "withdrawal")) {
                    AppendToArray(&withdrawals, transaction)
                }
            }
        
            ch <- this.ParseTransactions(withdrawals, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see http://api-doc.hibachi.xyz/#b5c6a3bc-243d-4d35-b6d4-a74c92495434
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *hibachi) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetExchangeUtcTimestamp(params))
            PanicOnError(response)
        
                //
            //     { "timestampMs":1754077574040 }
            //
        ch <- this.SafeInteger(response, "timestampMs")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchOpenInterest
 * @description retrieves the open interest of a contract trading pair
 * @see https://api-doc.hibachi.xyz/#bc34e8ae-e094-4802-8d56-3efe3a7bad49
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *hibachi) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20538 := (<-this.LoadMarkets())
            PanicOnError(retRes20538)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketDataOpenInterest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   { "totalQuantity" : "2.3299770166" }
            //
            var timestamp interface{} = this.Milliseconds()
        
            ch <- this.SafeOpenInterest(map[string]interface{} {
                "symbol": symbol,
                "openInterestAmount": this.SafeString(response, "totalQuantity"),
                "openInterestValue": nil,
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "info": response,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://api-doc.hibachi.xyz/#bca696ca-b9b2-4072-8864-5d6b8c09807e
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *hibachi) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20838 := (<-this.LoadMarkets())
            PanicOnError(retRes20838)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketDataPrices(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "askPrice": "3514.650296",
            //     "bidPrice": "3513.596112",
            //     "fundingRateEstimation": {
            //         "estimatedFundingRate": "0.000001",
            //         "nextFundingTimestamp": 1712707200
            //     },
            //     "markPrice": "3514.288858",
            //     "spotPrice": "3514.715000",
            //     "symbol": "ETH/USDT-P",
            //     "tradePrice": "2372.746570"
            // }
            //
            var funding interface{} = this.SafeDict(response, "fundingRateEstimation", map[string]interface{} {})
            var timestamp interface{} = this.Milliseconds()
            var nextFundingTimestamp interface{} = this.SafeIntegerProduct(funding, "nextFundingTimestamp", 1000)
        
            ch <- map[string]interface{} {
                "info": funding,
                "symbol": GetValue(market, "symbol"),
                "markPrice": nil,
                "indexPrice": nil,
                "interestRate": this.ParseNumber("0"),
                "estimatedSettlePrice": nil,
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "fundingRate": this.SafeNumber(funding, "estimatedFundingRate"),
                "fundingTimestamp": nextFundingTimestamp,
                "fundingDatetime": this.Iso8601(nextFundingTimestamp),
                "nextFundingRate": nil,
                "nextFundingTimestamp": nil,
                "nextFundingDatetime": nil,
                "previousFundingRate": nil,
                "previousFundingTimestamp": nil,
                "previousFundingDatetime": nil,
                "interval": "8h",
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hibachi#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://api-doc.hibachi.xyz/#4abb30c4-e5c7-4b0f-9ade-790111dbfa47
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *hibachi) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21408 := (<-this.LoadMarkets())
            PanicOnError(retRes21408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketDataFundingRates(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "data": [
            //         {
            //             "contractId": 2,
            //             "fundingTimestamp": 1753488000,
            //             "fundingRate": "0.000137",
            //             "indexPrice": "117623.65010"
            //         }
            //     ]
            // }
            //
            var data interface{} = this.SafeList(response, "data")
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var timestamp interface{} = this.SafeIntegerProduct(entry, "fundingTimestamp", 1000)
                AppendToArray(&rates, map[string]interface{} {
                    "info": entry,
                    "symbol": symbol,
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }


func (this *hibachi) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
