package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitteam struct {
    Exchange

}

func NewBitteamCore() bitteam {
   p := bitteam{}
   setDefaults(&p)
   return p
}

func  (this *bitteam) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitteam",
        "name": "BIT.TEAM",
        "countries": []interface{}{"UK"},
        "version": "v2.0.6",
        "rateLimit": 1,
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "borrowMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "deposit": false,
            "editOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": true,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": true,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": false,
            "repayMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": false,
            "withdraw": false,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "1h": "60",
            "1d": "1D",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/b41b5e0d-98e5-4bd3-8a6e-aeb230a4a135",
            "api": map[string]interface{} {
                "history": "https://history.bit.team",
                "public": "https://bit.team",
                "private": "https://bit.team",
            },
            "www": "https://bit.team/",
            "referral": "https://bit.team/auth/sign-up?ref=bitboy2023",
            "doc": []interface{}{"https://bit.team/trade/api/documentation"},
        },
        "api": map[string]interface{} {
            "history": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/tw/history/{pairName}/{resolution}": 1,
                },
            },
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "trade/api/asset": 1,
                    "trade/api/currencies": 1,
                    "trade/api/orderbooks/{symbol}": 1,
                    "trade/api/orders": 1,
                    "trade/api/pair/{name}": 1,
                    "trade/api/pairs": 1,
                    "trade/api/pairs/precisions": 1,
                    "trade/api/rates": 1,
                    "trade/api/trade/{id}": 1,
                    "trade/api/trades": 1,
                    "trade/api/ccxt/pairs": 1,
                    "trade/api/cmc/assets": 1,
                    "trade/api/cmc/orderbook/{pair}": 1,
                    "trade/api/cmc/summary": 1,
                    "trade/api/cmc/ticker": 1,
                    "trade/api/cmc/trades/{pair}": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "trade/api/ccxt/balance": 1,
                    "trade/api/ccxt/order/{id}": 1,
                    "trade/api/ccxt/ordersOfUser": 1,
                    "trade/api/ccxt/tradesOfUser": 1,
                    "trade/api/transactionsOfUser": 1,
                },
                "post": map[string]interface{} {
                    "trade/api/ccxt/cancel-all-order": 1,
                    "trade/api/ccxt/cancelorder": 1,
                    "trade/api/ccxt/ordercreate": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.002"),
                "maker": this.ParseNumber("0.002"),
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "networksById": map[string]interface{} {
                "Ethereum": "ERC20",
                "ethereum": "ERC20",
                "Tron": "TRC20",
                "tron": "TRC20",
                "Binance": "BSC",
                "binance": "BSC",
                "Binance Smart Chain": "BSC",
                "bscscan": "BSC",
                "Bitcoin": "BTC",
                "bitcoin": "BTC",
                "Litecoin": "LTC",
                "litecoin": "LTC",
                "Polygon": "POLYGON",
                "polygon": "POLYGON",
                "PRIZM": "PRIZM",
                "Decimal": "Decimal",
                "ufobject": "ufobject",
                "tonchain": "tonchain",
            },
            "currenciesValuedInUsd": map[string]interface{} {
                "USDT": true,
                "BUSD": true,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400002": BadSymbol,
                "401000": AuthenticationError,
                "403002": BadRequest,
                "404200": BadSymbol,
            },
            "broad": map[string]interface{} {
                "is not allowed": BadRequest,
                "Insufficient funds": InsufficientFunds,
                "Invalid request params input": BadRequest,
                "must be a number": BadRequest,
                "must be a string": BadRequest,
                "must be of type": BadRequest,
                "must be one of": BadRequest,
                "Order not found": OrderNotFound,
                "Pair with pair name": BadSymbol,
                "pairName": BadSymbol,
                "Service Unavailable": ExchangeNotAvailable,
                "Symbol ": BadSymbol,
            },
        },
    })
}
/**
 * @method
 * @name bitteam#fetchMarkets
 * @description retrieves data on all markets for bitteam
 * @see https://bit.team/trade/api/documentation#/CCXT/getTradeApiCcxtPairs
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitteam) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTradeApiCcxtPairs(params))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 28,
            //             "pairs": [
            //                 {
            //                     "id": 2,
            //                     "name": "eth_usdt",
            //                     "baseAssetId": 2,
            //                     "quoteAssetId": 3,
            //                     "fullName": "ETH USDT",
            //                     "description": "ETH   USDT",
            //                     "lastBuy": 1964.665001,
            //                     "lastSell": 1959.835005,
            //                     "lastPrice": 1964.665001,
            //                     "change24": 1.41,
            //                     "volume24": 28.22627543,
            //                     "volume24USD": 55662.35636401598,
            //                     "active": true,
            //                     "baseStep": 8,
            //                     "quoteStep": 6,
            //                     "status": 1,
            //                     "settings": {
            //                         "limit_usd": "0.1",
            //                         "price_max": "10000000000000",
            //                         "price_min": "1",
            //                         "price_tick": "1",
            //                         "pricescale": 10000,
            //                         "lot_size_max": "1000000000000000",
            //                         "lot_size_min": "1",
            //                         "lot_size_tick": "1",
            //                         "price_view_min": 6,
            //                         "default_slippage": 10,
            //                         "lot_size_view_min": 6
            //                     },
            //                     "updateId": "50620",
            //                     "timeStart": "2021-01-28T09:19:30.706Z",
            //                     "makerFee": 200,
            //                     "takerFee": 200,
            //                     "quoteVolume24": 54921.93404134529,
            //                     "lowPrice24": 1919.355,
            //                     "highPrice24": 1971.204995
            //                 },
            //                 {
            //                     "id": 27,
            //                     "name": "ltc_usdt",
            //                     "baseAssetId": 13,
            //                     "quoteAssetId": 3,
            //                     "fullName": "LTC USDT",
            //                     "description": "This is LTC USDT",
            //                     "lastBuy": 53.14,
            //                     "lastSell": 53.58,
            //                     "lastPrice": 53.58,
            //                     "change24": -6.72,
            //                     "volume24": 0,
            //                     "volume24USD": null,
            //                     "active": true,
            //                     "baseStep": 8,
            //                     "quoteStep": 6,
            //                     "status": 0,
            //                     "settings": {
            //                         "limit_usd": "0.1",
            //                         "price_max": "1000000000000",
            //                         "price_min": "1",
            //                         "price_tick": "1",
            //                         "pricescale": 10000,
            //                         "lot_size_max": "1000000000000",
            //                         "lot_size_min": "1",
            //                         "lot_size_tick": "1",
            //                         "price_view_min": 6,
            //                         "default_slippage": 10,
            //                         "lot_size_view_min": 6
            //                     },
            //                     "updateId": "30",
            //                     "timeStart": "2021-10-13T12:11:05.359Z",
            //                     "makerFee": 200,
            //                     "takerFee": 200,
            //                     "quoteVolume24": 0,
            //                     "lowPrice24": null,
            //                     "highPrice24": null
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var markets interface{} = this.SafeValue(result, "pairs", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "name")
    var numericId interface{} = this.SafeInteger(market, "id")
    var parts interface{} = Split(id, "_")
    var baseId interface{} = this.SafeString(parts, 0)
    var quoteId interface{} = this.SafeString(parts, 1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var active interface{} = this.SafeValue(market, "active")
    var timeStart interface{} = this.SafeString(market, "timeStart")
    var created interface{} = this.Parse8601(timeStart)
    var minCost interface{} = nil
    var currenciesValuedInUsd interface{} = this.SafeValue(this.Options, "currenciesValuedInUsd", map[string]interface{} {})
    var quoteInUsd interface{} = this.SafeBool(currenciesValuedInUsd, quote, false)
    if IsTrue(quoteInUsd) {
        var settings interface{} = this.SafeValue(market, "settings", map[string]interface{} {})
        minCost = this.SafeNumber(settings, "limit_usd")
    }
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "numericId": numericId,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": active,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseStep"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quoteStep"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": minCost,
                "max": nil,
            },
        },
        "created": created,
        "info": market,
    })
}
/**
 * @method
 * @name bitteam#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://bit.team/trade/api/documentation#/PUBLIC/getTradeApiCurrencies
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *bitteam) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTradeApiCurrencies(params))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 24,
            //             "currencies": [
            //                 {
            //                     "txLimits": {
            //                         "minDeposit": "0.0001",
            //                         "minWithdraw": "0.02",
            //                         "maxWithdraw": "10000",
            //                         "withdrawCommissionPercentage": "NaN",
            //                         "withdrawCommissionFixed": "0.005"
            //                     },
            //                     "id": 2,
            //                     "status": 1,
            //                     "symbol": "eth",
            //                     "title": "Ethereum",
            //                     "logoURL": "https://ethereum.org/static/6b935ac0e6194247347855dc3d328e83/34ca5/eth-diamond-black.png",
            //                     "isDiscount": false,
            //                     "address": "https://ethereum.org/",
            //                     "description": "Ethereum ETH",
            //                     "decimals": 18,
            //                     "blockChain": "Ethereum",
            //                     "precision": 8,
            //                     "currentRate": null,
            //                     "active": true,
            //                     "timeStart": "2021-01-28T08:57:41.719Z",
            //                     "type": "crypto",
            //                     "typeNetwork": "internalGW",
            //                     "idSorting": 2,
            //                     "links": [
            //                         {
            //                             "tx": "https://etherscan.io/tx/",
            //                             "address": "https://etherscan.io/address/",
            //                             "blockChain": "Ethereum"
            //                         }
            //                     ]
            //                 },
            //                 {
            //                     "txLimits": {
            //                         "minDeposit": "0.001",
            //                         "minWithdraw": "1",
            //                         "maxWithdraw": "100000",
            //                         "withdrawCommissionPercentage": "NaN",
            //                         "withdrawCommissionFixed": {
            //                             "Tron": "2",
            //                             "Binance": "2",
            //                             "Ethereum": "20"
            //                         }
            //                     },
            //                     "id": 3,
            //                     "status": 1,
            //                     "symbol": "usdt",
            //                     "title": "Tether USD",
            //                     "logoURL": "https://cryptologos.cc/logos/tether-usdt-logo.png?v=010",
            //                     "isDiscount": false,
            //                     "address": "https://tether.to/",
            //                     "description": "Tether USD",
            //                     "decimals": 6,
            //                     "blockChain": "",
            //                     "precision": 6,
            //                     "currentRate": null,
            //                     "active": true,
            //                     "timeStart": "2021-01-28T09:04:17.170Z",
            //                     "type": "crypto",
            //                     "typeNetwork": "internalGW",
            //                     "idSorting": 0,
            //                     "links": [
            //                         {
            //                             "tx": "https://etherscan.io/tx/",
            //                             "address": "https://etherscan.io/address/",
            //                             "blockChain": "Ethereum"
            //                         },
            //                         {
            //                             "tx": "https://tronscan.org/#/transaction/",
            //                             "address": "https://tronscan.org/#/address/",
            //                             "blockChain": "Tron"
            //                         },
            //                         {
            //                             "tx": "https://bscscan.com/tx/",
            //                             "address": "https://bscscan.com/address/",
            //                             "blockChain": "Binance"
            //                         }
            //                     ]
            //                 }
            //             ]
            //         }
            //     }
            //
            var responseResult interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var currencies interface{} = this.SafeValue(responseResult, "currencies", []interface{}{})
            // usding another endpoint to fetch statuses of deposits and withdrawals
        
            statusesResponse:= (<-this.PublicGetTradeApiCmcAssets())
            PanicOnError(statusesResponse)
            //
            //     {
            //         "ZNX": {
            //             "name": "ZeNeX Coin",
            //             "unified_cryptoasset_id": 30,
            //             "withdrawStatus": true,
            //             "depositStatus": true,
            //             "min_withdraw": 0.00001,
            //             "max_withdraw": 10000
            //         },
            //         "USDT": {
            //             "name": "Tether USD",
            //             "unified_cryptoasset_id": 3,
            //             "withdrawStatus": true,
            //             "depositStatus": true,
            //             "min_withdraw": 1,
            //             "max_withdraw": 100000
            //         },
            //     }
            //
            statusesResponse = this.IndexBy(statusesResponse, "unified_cryptoasset_id")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(currency, "symbol")
                var numericId interface{} = this.SafeInteger(currency, "id")
                var code interface{} = this.SafeCurrencyCode(id)
                var active interface{} = this.SafeBool(currency, "active", false)
                var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "precision")))
                var txLimits interface{} = this.SafeValue(currency, "txLimits", map[string]interface{} {})
                var minWithdraw interface{} = this.SafeString(txLimits, "minWithdraw")
                var maxWithdraw interface{} = this.SafeString(txLimits, "maxWithdraw")
                var minDeposit interface{} = this.SafeString(txLimits, "minDeposit")
                var fee interface{} = nil
                var withdrawCommissionFixed interface{} = this.SafeValue(txLimits, "withdrawCommissionFixed", map[string]interface{} {})
                var feesByNetworkId interface{} = map[string]interface{} {}
                var blockChain interface{} = this.SafeString(currency, "blockChain")
                // if only one blockChain
                if IsTrue(IsTrue((!IsEqual(blockChain, nil))) && IsTrue((!IsEqual(blockChain, "")))) {
                    fee = this.ParseNumber(withdrawCommissionFixed)
                    AddElementToObject(feesByNetworkId, blockChain, fee)
                } else {
                    feesByNetworkId = withdrawCommissionFixed
                }
                var statuses interface{} = this.SafeValue(statusesResponse, numericId, map[string]interface{} {})
                var deposit interface{} = this.SafeValue(statuses, "depositStatus")
                var withdraw interface{} = this.SafeValue(statuses, "withdrawStatus")
                var networkIds interface{} = ObjectKeys(feesByNetworkId)
                var networks interface{} = map[string]interface{} {}
                var networkPrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "decimals")))
                var typeRaw interface{} = this.SafeString(currency, "type")
                for j := 0; IsLessThan(j, GetArrayLength(networkIds)); j++ {
                    var networkId interface{} = GetValue(networkIds, j)
                    var networkCode interface{} = this.NetworkIdToCode(networkId, code)
                    var networkFee interface{} = this.SafeNumber(feesByNetworkId, networkId)
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "id": networkId,
            "network": networkCode,
            "deposit": deposit,
            "withdraw": withdraw,
            "active": active,
            "fee": networkFee,
            "precision": networkPrecision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdraw),
                    "max": this.ParseNumber(maxWithdraw),
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minDeposit),
                    "max": nil,
                },
            },
            "info": currency,
        })
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "numericId": numericId,
            "code": code,
            "name": code,
            "info": currency,
            "active": active,
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": fee,
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdraw),
                    "max": this.ParseNumber(maxWithdraw),
                },
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minDeposit),
                    "max": nil,
                },
            },
            "type": typeRaw,
            "networks": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bitteam) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7248 := (<-this.LoadMarkets())
            PanicOnError(retRes7248)
            var market interface{} = this.Market(symbol)
            var resolution interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "pairName": GetValue(market, "id"),
                "resolution": resolution,
            }
        
            response:= (<-this.HistoryGetApiTwHistoryPairNameResolution(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 364,
            //             "data": [
            //                 {
            //                     "t": 1669593600,
            //                     "o": 16211.259266,
            //                     "h": 16476.985001,
            //                     "l": 16023.714999,
            //                     "c": 16430.636894,
            //                     "v": 2.60150368999999
            //                 },
            //                 {
            //                     "t": 1669680000,
            //                     "o": 16430.636894,
            //                     "h": 17065.229582,
            //                     "l": 16346.114155,
            //                     "c": 16882.297736,
            //                     "v": 3.0872548400000115
            //                 },
            //                 ...
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "t": 1669680000,
    //         "o": 16430.636894,
    //         "h": 17065.229582,
    //         "l": 16346.114155,
    //         "c": 16882.297736,
    //         "v": 3.0872548400000115
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name bitteam#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcOrderbookPair
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func  (this *bitteam) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7968 := (<-this.LoadMarkets())
            PanicOnError(retRes7968)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradeApiCmcOrderbookPair(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "timestamp": 1701166703285,
            //         "bids": [
            //             [
            //                 2019.334988,
            //                 0.09048525
            //             ],
            //             [
            //                 1999.860002,
            //                 0.0225
            //             ],
            //             ...
            //         ],
            //         "asks": [
            //             [
            //                 2019.334995,
            //                 0.00899078
            //             ],
            //             [
            //                 2019.335013,
            //                 0.09833052
            //             ],
            //             ...
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
            var orderbook interface{} = this.ParseOrderBook(response, symbol, timestamp)
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of  orde structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @param {string} [params.type] the status of the order - 'active', 'closed', 'cancelled', 'all', 'history' (default 'all')
 * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8478 := (<-this.LoadMarkets())
            PanicOnError(retRes8478)
            var typeVar interface{} = this.SafeString(params, "type", "all")
            var request interface{} = map[string]interface{} {
                "type": typeVar,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetTradeApiCcxtOrdersOfUser(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 3,
            //             "orders": [
            //                 {
            //                     "id": 106733026,
            //                     "orderId": null,
            //                     "userId": 21639,
            //                     "pair": "btc_usdt",
            //                     "pairId": 22,
            //                     "quantity": "0.00001",
            //                     "price": "40",
            //                     "executedPrice": "0",
            //                     "fee": null,
            //                     "orderCid": null,
            //                     "executed": "0",
            //                     "expires": null,
            //                     "baseDecimals": 8,
            //                     "quoteDecimals": 6,
            //                     "timestamp": 1700594804,
            //                     "status": "inactive",
            //                     "side": "buy",
            //                     "type": "limit",
            //                     "createdAt": "2023-11-21T19:26:43.868Z",
            //                     "updatedAt": "2023-11-21T19:26:43.868Z"
            //                 },
            //                 {
            //                     "id": 106733308,
            //                     "orderId": "13074362",
            //                     "userId": 21639,
            //                     "pair": "btc_usdt",
            //                     "pairId": 22,
            //                     "quantity": "0.00001",
            //                     "price": "50000",
            //                     "executedPrice": "37017.495008",
            //                     "fee": {
            //                         "amount": "0.00000002",
            //                         "symbol": "btc",
            //                         "userId": 21639,
            //                         "decimals": 8,
            //                         "symbolId": 11
            //                     },
            //                     "orderCid": null,
            //                     "executed": "0.00001",
            //                     "expires": null,
            //                     "baseDecimals": 8,
            //                     "quoteDecimals": 6,
            //                     "timestamp": 1700594959,
            //                     "status": "executed",
            //                     "side": "buy",
            //                     "type": "limit",
            //                     "createdAt": "2023-11-21T19:29:19.946Z",
            //                     "updatedAt": "2023-11-21T19:29:19.946Z"
            //                 },
            //                 {
            //                     "id": 106734455,
            //                     "orderId": "13248984",
            //                     "userId": 21639,
            //                     "pair": "eth_usdt",
            //                     "pairId": 2,
            //                     "quantity": "0.001",
            //                     "price": "1750",
            //                     "executedPrice": "0",
            //                     "fee": null,
            //                     "orderCid": null,
            //                     "executed": "0",
            //                     "expires": null,
            //                     "baseDecimals": 18,
            //                     "quoteDecimals": 6,
            //                     "timestamp": 1700595523,
            //                     "status": "accepted",
            //                     "side": "buy",
            //                     "type": "limit",
            //                     "createdAt": "2023-11-21T19:38:43.530Z",
            //                     "updatedAt": "2023-11-21T19:38:43.530Z"
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var orders interface{} = this.SafeList(result, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchOrder
 * @description fetches information on an order
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrderId
 * @param {int|string} id order id
 * @param {string} symbol not used by bitteam fetchOrder ()
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} An [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9598 := (<-this.LoadMarkets())
            PanicOnError(retRes9598)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivateGetTradeApiCcxtOrderId(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "id": 106494347,
            //             "orderId": "13214332",
            //             "userId": 15912,
            //             "pair": "eth_usdt",
            //             "pairId": 2,
            //             "quantity": "0.00448598",
            //             "price": "2015.644995",
            //             "executedPrice": "2015.644995",
            //             "fee": {
            //                 "amount": "0",
            //                 "symbol": "eth",
            //                 "userId": 15912,
            //                 "decimals": 18,
            //                 "symbolId": 2,
            //                 "discountAmount": "0",
            //                 "discountSymbol": "btt",
            //                 "discountDecimals": 18,
            //                 "discountSymbolId": 5
            //             },
            //             "orderCid": null,
            //             "executed": "0.00448598",
            //             "expires": null,
            //             "baseDecimals": 18,
            //             "quoteDecimals": 6,
            //             "timestamp": 1700470476,
            //             "status": "executed",
            //             "side": "buy",
            //             "type": "limit",
            //             "stopPrice": null,
            //             "slippage": null
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10218 := (<-this.LoadMarkets())
            PanicOnError(retRes10218)
            var request interface{} = map[string]interface{} {
                "type": "active",
            }
        
                retRes102515 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes102515)
                ch <- retRes102515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of closed order structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {Order[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10408 := (<-this.LoadMarkets())
            PanicOnError(retRes10408)
            var request interface{} = map[string]interface{} {
                "type": "closed",
            }
        
                retRes104415 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes104415)
                ch <- retRes104415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtOrdersofuser
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of canceled order structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10598 := (<-this.LoadMarkets())
            PanicOnError(retRes10598)
            var request interface{} = map[string]interface{} {
                "type": "cancelled",
            }
        
                retRes106315 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes106315)
                ch <- retRes106315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#createOrder
 * @description create a trade order
 * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtOrdercreate
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} an [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10808 := (<-this.LoadMarkets())
            PanicOnError(retRes10808)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pairId": ToString(GetValue(market, "numericId")),
                "type": typeVar,
                "side": side,
                "amount": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
                } else {
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
            }
        
            response:= (<-this.PrivatePostTradeApiCcxtOrdercreate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "id": 106733308,
            //             "userId": 21639,
            //             "quantity": "0.00001",
            //             "pair": "btc_usdt",
            //             "side": "buy",
            //             "price": "50000",
            //             "executed": "0",
            //             "executedPrice": "0",
            //             "status": "created",
            //             "baseDecimals": 8,
            //             "quoteDecimals": 6,
            //             "pairId": 22,
            //             "type": "limit",
            //             "stopPrice": null,
            //             "slippage": null,
            //             "timestamp": "1700594959"
            //         }
            //     }
            //
            var order interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#cancelOrder
 * @description cancels an open order
 * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtCancelorder
 * @param {string} id order id
 * @param {string} symbol not used by bitteam cancelOrder ()
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} An [order structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11348 := (<-this.LoadMarkets())
            PanicOnError(retRes11348)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivatePostTradeApiCcxtCancelorder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "message": "The request to cancel your order was received"
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#cancelAllOrders
 * @description cancel open orders of market
 * @see https://bit.team/trade/api/documentation#/PRIVATE/postTradeApiCcxtCancelallorder
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object[]} a list of [order structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-structure}
 */
func  (this *bitteam) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11618 := (<-this.LoadMarkets())
            PanicOnError(retRes11618)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pairId", ToString(GetValue(market, "numericId")))
            } else {
                AddElementToObject(request, "pairId", "0") // '0' for all markets
            }
        
            response:= (<-this.PrivatePostTradeApiCcxtCancelAllOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "message":"The request to cancel all your orders was received"
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var orders interface{} = []interface{}{result}
        
            ch <- this.ParseOrders(orders, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrders
    //     {
    //         "id": 106733308,
    //         "orderId": "13074362",
    //         "userId": 21639,
    //         "pair": "btc_usdt",
    //         "pairId": 22,
    //         "quantity": "0.00001",
    //         "price": "50000",
    //         "executedPrice": "37017.495008",
    //         "fee": {
    //             "amount": "0.00000002",
    //             "symbol": "btc",
    //             "userId": 21639,
    //             "decimals": 8,
    //             "symbolId": 11
    //         },
    //         "orderCid": null,
    //         "executed": "0.00001",
    //         "expires": null,
    //         "baseDecimals": 8,
    //         "quoteDecimals": 6,
    //         "timestamp": 1700594959,
    //         "status": "executed",
    //         "side": "buy",
    //         "type": "limit",
    //         "createdAt": "2023-11-21T19:29:19.946Z",
    //         "updatedAt": "2023-11-21T19:29:19.946Z"
    //     },
    //
    // fetchOrder
    //     {
    //         "id": 106494347,
    //         "orderId": "13214332",
    //         "userId": 15912,
    //         "pair": "eth_usdt",
    //         "pairId": 2,
    //         "quantity": "0.00448598",
    //         "price": "2015.644995",
    //         "executedPrice": "2015.644995",
    //         "fee": {
    //             "amount": "0",
    //             "symbol": "eth",
    //             "userId": 15912,
    //             "decimals": 18,
    //             "symbolId": 2,
    //             "discountAmount": "0",
    //             "discountSymbol": "btt",
    //             "discountDecimals": 18,
    //             "discountSymbolId": 5
    //         },
    //         "orderCid": null,
    //         "executed": "0.00448598",
    //         "expires": null,
    //         "baseDecimals": 18,
    //         "quoteDecimals": 6,
    //         "timestamp": 1700470476,
    //         "status": "executed",
    //         "side": "buy",
    //         "type": "limit",
    //         "stopPrice": null,
    //         "slippage": null
    //     }
    //
    // createOrder
    //     {
    //         "id": 106733308,
    //         "userId": 21639,
    //         "quantity": "0.00001",
    //         "pair": "btc_usdt",
    //         "side": "buy",
    //         "price": "50000",
    //         "executed": "0",
    //         "executedPrice": "0",
    //         "status": "created",
    //         "baseDecimals": 8,
    //         "quoteDecimals": 6,
    //         "pairId": 22,
    //         "type": "limit",
    //         "stopPrice": null,
    //         "slippage": null,
    //         "timestamp": "1700594959"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var marketId interface{} = this.SafeString(order, "pair")
    market = this.SafeMarket(marketId, market)
    var clientOrderId interface{} = this.SafeString(order, "orderCid")
    var timestamp interface{} = nil
    var createdAt interface{} = this.SafeString(order, "createdAt")
    if IsTrue(!IsEqual(createdAt, nil)) {
        timestamp = this.Parse8601(createdAt)
    } else {
        timestamp = this.SafeTimestamp(order, "timestamp")
    }
    var updatedAt interface{} = this.SafeString(order, "updatedAt")
    var lastUpdateTimestamp interface{} = this.Parse8601(updatedAt)
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "type"))
    var side interface{} = this.SafeString(order, "side")
    var feeRaw interface{} = this.SafeValue(order, "fee")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "quantity")
    var filled interface{} = this.SafeString(order, "executed")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeRaw, nil)) {
        var feeCost interface{} = this.SafeString(feeRaw, "amount")
        var feeCurrencyId interface{} = this.SafeString(feeRaw, "symbol")
        fee = map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": feeCost,
            "rate": nil,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": "GTC",
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString(order, "stopPrice"),
        "average": nil,
        "amount": amount,
        "cost": nil,
        "filled": filled,
        "remaining": nil,
        "fee": fee,
        "trades": nil,
        "info": order,
        "postOnly": false,
    }, market)
}
func  (this *bitteam) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "accepted": "open",
        "executed": "closed",
        "cancelled": "canceled",
        "partiallyCancelled": "canceled",
        "delete": "rejected",
        "inactive": "rejected",
        "executing": "open",
        "created": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitteam) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "market": "market",
        "limit": "limit",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitteam) ParseValueToPricision(valueObject interface{}, valueKey interface{}, preciseObject interface{}, precisionKey interface{}) interface{}  {
    var valueRawString interface{} = this.SafeString(valueObject, valueKey)
    var precisionRawString interface{} = this.SafeString(preciseObject, precisionKey)
    if IsTrue(IsTrue(IsEqual(valueRawString, nil)) || IsTrue(IsEqual(precisionRawString, nil))) {
        return nil
    }
    var precisionString interface{} = this.ParsePrecision(precisionRawString)
    return Precise.StringMul(valueRawString, precisionString)
}
/**
 * @method
 * @name bitteam#fetchTickers
 * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
 * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcSummary
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
 */
func  (this *bitteam) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13688 := (<-this.LoadMarkets())
            PanicOnError(retRes13688)
        
            response:= (<-this.PublicGetTradeApiCmcSummary())
            PanicOnError(response)
            //
            //     [
            //         {
            //             "trading_pairs": "BTC_USDT",
            //             "base_currency": "BTC",
            //             "quote_currency": "USDT",
            //             "last_price": 37669.955001,
            //             "lowest_ask": 37670.055,
            //             "highest_bid": 37669.955,
            //             "base_volume": 6.81156888,
            //             "quote_volume": 257400.516878529,
            //             "price_change_percent_24h": -0.29,
            //             "highest_price_24h": 38389.994463,
            //             "lowest_price_24h": 37574.894999
            //         },
            //         {
            //             "trading_pairs": "BNB_USDT",
            //             "base_currency": "BNB",
            //             "quote_currency": "USDT",
            //             "last_price": 233.525142,
            //             "lowest_ask": 233.675,
            //             "highest_bid": 233.425,
            //             "base_volume": 245.0199339,
            //             "quote_volume": 57356.91823827642,
            //             "price_change_percent_24h": -0.32,
            //             "highest_price_24h": 236.171123,
            //             "lowest_price_24h": 231.634637
            //         },
            //         ...
            //     ]
            //
            var tickers interface{} = []interface{}{}
            if !IsTrue(IsArray(response)) {
                response = []interface{}{}
            }
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var rawTicker interface{} = GetValue(response, i)
                var ticker interface{} = this.ParseTicker(rawTicker)
                AppendToArray(&tickers,ticker)
            }
        
            ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://bit.team/trade/api/documentation#/PUBLIC/getTradeApiPairName
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} a [ticker structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#ticker-structure}
 */
func  (this *bitteam) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14238 := (<-this.LoadMarkets())
            PanicOnError(retRes14238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "name": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradeApiPairName(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "pair": {
            //                 "id": 2,
            //                 "name": "eth_usdt",
            //                 "baseAssetId": 2,
            //                 "quoteAssetId": 3,
            //                 "fullName": "ETH USDT",
            //                 "description": "ETH   USDT",
            //                 "lastBuy": "1976.715012",
            //                 "lastSell": "1971.995006",
            //                 "lastPrice": "1976.715012",
            //                 "change24": "1.02",
            //                 "volume24": 24.0796457,
            //                 "volume24USD": 44282.347995912205,
            //                 "active": true,
            //                 "baseStep": 8,
            //                 "quoteStep": 6,
            //                 "status": 1,
            //                 "settings": {
            //                     "limit_usd": "0.1",
            //                     "price_max": "10000000000000",
            //                     "price_min": "1",
            //                     "price_tick": "1",
            //                     "pricescale": 10000,
            //                     "lot_size_max": "1000000000000000",
            //                     "lot_size_min": "1",
            //                     "lot_size_tick": "1",
            //                     "price_view_min": 6,
            //                     "default_slippage": 10,
            //                     "lot_size_view_min": 6
            //                 },
            //                 "asks": [
            //                     {
            //                     "price": "1976.405003",
            //                     "quantity": "0.0051171",
            //                     "amount": "10.1134620408513"
            //                     },
            //                     {
            //                     "price": "1976.405013",
            //                     "quantity": "0.09001559",
            //                     "amount": "177.90726332415267"
            //                     },
            //                     {
            //                     "price": "2010.704988",
            //                     "quantity": "0.00127892",
            //                     "amount": "2.57153082325296"
            //                     }
            //                 ],
            //                 "bids": [
            //                     {
            //                     "price": "1976.404988",
            //                     "quantity": "0.09875861",
            //                     "amount": "195.18700941194668"
            //                     },
            //                     {
            //                     "price": "1905.472973",
            //                     "quantity": "0.00263591",
            //                     "amount": "5.02265526426043"
            //                     },
            //                     {
            //                     "price": "1904.274973",
            //                     "quantity": "0.09425304",
            //                     "amount": "179.48370520116792"
            //                     }
            //                 ],
            //                 "updateId": "78",
            //                 "timeStart": "2021-01-28T09:19:30.706Z",
            //                 "makerFee": 200,
            //                 "takerFee": 200,
            //                 "quoteVolume24": 49125.1374009045,
            //                 "lowPrice24": 1966.704999,
            //                 "highPrice24": 2080.354997,
            //                 "baseCurrency": {
            //                     "id": 2,
            //                     "status": 1,
            //                     "symbol": "eth",
            //                     "title": "Ethereum",
            //                     "logoURL": "https://ethereum.org/static/6b935ac0e6194247347855dc3d328e83/34ca5/eth-diamond-black.png",
            //                     "isDiscount": false,
            //                     "address": "https://ethereum.org/",
            //                     "description": "Ethereum ETH",
            //                     "decimals": 18,
            //                     "blockChain": "Ethereum",
            //                     "precision": 8,
            //                     "currentRate": null,
            //                     "active": true,
            //                     "timeStart": "2021-01-28T08:57:41.719Z",
            //                     "txLimits": {
            //                         "minDeposit": "100000000000000",
            //                         "maxWithdraw": "10000000000000000000000",
            //                         "minWithdraw": "20000000000000000",
            //                         "withdrawCommissionFixed": "5000000000000000",
            //                         "withdrawCommissionPercentage": "NaN"
            //                     },
            //                     "type": "crypto",
            //                     "typeNetwork": "internalGW",
            //                     "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTVDMCA2LjcxNTczIDYuNzE1NzMgMCAxNSAwVjBDMjMuMjg0MyAwIDMwIDYuNzE1NzMgMzAgMTVWMTVDMzAgMjMuMjg0MyAyMy4yODQzIDMwIDE1IDMwVjMwQzYuNzE1NzMgMzAgMCAyMy4yODQzIDAgMTVWMTVaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNMTQuOTU1NyAxOS45NzM5TDkgMTYuMzUwOUwxNC45NTIxIDI1TDIwLjkxMDkgMTYuMzUwOUwxNC45NTIxIDE5Ljk3MzlIMTQuOTU1N1pNMTUuMDQ0MyA1TDkuMDkwOTUgMTUuMTg1M0wxNS4wNDQzIDE4LjgxNDZMMjEgMTUuMTg5MUwxNS4wNDQzIDVaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
            //                     "idSorting": 2,
            //                     "links": [
            //                         {
            //                             "tx": "https://etherscan.io/tx/",
            //                             "address": "https://etherscan.io/address/",
            //                             "blockChain": "Ethereum"
            //                         }
            //                     ],
            //                     "clientTxLimits": {
            //                         "minDeposit": "0.0001",
            //                         "minWithdraw": "0.02",
            //                         "maxWithdraw": "10000",
            //                         "withdrawCommissionPercentage": "NaN",
            //                         "withdrawCommissionFixed": "0.005"
            //                     }
            //                 },
            //                 "quoteCurrency": {
            //                     "id": 3,
            //                     "status": 1,
            //                     "symbol": "usdt",
            //                     "title": "Tether USD",
            //                     "logoURL": "https://cryptologos.cc/logos/tether-usdt-logo.png?v=010",
            //                     "isDiscount": false,
            //                     "address": "https://tether.to/",
            //                     "description": "Tether USD",
            //                     "decimals": 6,
            //                     "blockChain": "",
            //                     "precision": 6,
            //                     "currentRate": null,
            //                     "active": true,
            //                     "timeStart": "2021-01-28T09:04:17.170Z",
            //                     "txLimits": {
            //                         "minDeposit": "1000",
            //                         "maxWithdraw": "100000000000",
            //                         "minWithdraw": "1000000",
            //                         "withdrawCommissionFixed": {
            //                             "Tron": "2000000",
            //                             "Binance": "2000000000000000000",
            //                             "Ethereum": "20000000"
            //                         },
            //                         "withdrawCommissionPercentage": "NaN"
            //                     },
            //                     "type": "crypto",
            //                     "typeNetwork": "internalGW",
            //                     "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMCAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTVDMCA2LjcxNTczIDYuNzE1NzMgMCAxNSAwVjBDMjMuMjg0MyAwIDMwIDYuNzE1NzMgMzAgMTVWMTVDMzAgMjMuMjg0MyAyMy4yODQzIDMwIDE1IDMwVjMwQzYuNzE1NzMgMzAgMCAyMy4yODQzIDAgMTVWMTVaIiBmaWxsPSIjNkZBNjg4Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjMgN0g3VjExSDEzVjEyLjA2MkM4Ljk5MjAyIDEyLjMxNDYgNiAxMy4zMTAyIDYgMTQuNUM2IDE1LjY4OTggOC45OTIwMiAxNi42ODU0IDEzIDE2LjkzOFYyM0gxN1YxNi45MzhDMjEuMDA4IDE2LjY4NTQgMjQgMTUuNjg5OCAyNCAxNC41QzI0IDEzLjMxMDIgMjEuMDA4IDEyLjMxNDYgMTcgMTIuMDYyVjExSDIzVjdaTTcuNSAxNC41QzcuNSAxMy40NjA2IDkuMzMzMzMgMTIuMzY4IDEzIDEyLjA3NTZWMTUuNUgxN1YxMi4wNzU5QzIwLjkzODQgMTIuMzkyNyAyMi41IDEzLjYzMzkgMjIuNSAxNC41QzIyLjUgMTUuMzIyIDIwLjAwMDggMTUuODA2MSAxNyAxNS45NTI1QzE1LjcwODIgMTYuMDQ2MiAxMy43OTUxIDE1Ljk4MjYgMTMgMTUuOTM5MUM5Ljk5OTIxIDE1Ljc1NTkgNy41IDE1LjE4MDkgNy41IDE0LjVaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
            //                     "idSorting": 0,
            //                     "links": [
            //                         {
            //                             "tx": "https://etherscan.io/tx/",
            //                             "address": "https://etherscan.io/address/",
            //                             "blockChain": "Ethereum"
            //                         },
            //                         {
            //                             "tx": "https://tronscan.org/#/transaction/",
            //                             "address": "https://tronscan.org/#/address/",
            //                             "blockChain": "Tron"
            //                         },
            //                         {
            //                             "tx": "https://bscscan.com/tx/",
            //                             "address": "https://bscscan.com/address/",
            //                             "blockChain": "Binance"
            //                         }
            //                     ],
            //                     "clientTxLimits": {
            //                         "minDeposit": "0.001",
            //                         "minWithdraw": "1",
            //                         "maxWithdraw": "100000",
            //                         "withdrawCommissionPercentage": "NaN",
            //                         "withdrawCommissionFixed": {
            //                             "Tron": "2",
            //                             "Binance": "2",
            //                             "Ethereum": "20"
            //                         }
            //                     }
            //                 },
            //                 "quantities": {
            //                     "asks": "5.58760757",
            //                     "bids": "2226.98663823032198"
            //                 }
            //             }
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var pair interface{} = this.SafeDict(result, "pair", map[string]interface{} {})
        
            ch <- this.ParseTicker(pair, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //     {
    //         "id": 2,
    //         "name": "eth_usdt",
    //         "baseAssetId": 2,
    //         "quoteAssetId": 3,
    //         "fullName": "ETH USDT",
    //         "description": "ETH   USDT",
    //         "lastBuy": "1976.715012",
    //         "lastSell": "1971.995006",
    //         "lastPrice": "1976.715012",
    //         "change24": "1.02",
    //         "volume24": 24.0796457,
    //         "volume24USD": 44282.347995912205,
    //         "active": true,
    //         "baseStep": 8,
    //         "quoteStep": 6,
    //         "status": 1,
    //         "asks": [
    //             {
    //             "price": "1976.405003",
    //             "quantity": "0.0051171",
    //             "amount": "10.1134620408513"
    //             },
    //             {
    //             "price": "1976.405013",
    //             "quantity": "0.09001559",
    //             "amount": "177.90726332415267"
    //             },
    //             {
    //             "price": "2010.704988",
    //             "quantity": "0.00127892",
    //             "amount": "2.57153082325296"
    //             }
    //                ...
    //         ],
    //         "bids": [
    //             {
    //             "price": "1976.404988",
    //             "quantity": "0.09875861",
    //             "amount": "195.18700941194668"
    //             },
    //             {
    //             "price": "1905.472973",
    //             "quantity": "0.00263591",
    //             "amount": "5.02265526426043"
    //             },
    //             {
    //             "price": "1904.274973",
    //             "quantity": "0.09425304",
    //             "amount": "179.48370520116792"
    //             }
    //                ...
    //         ],
    //         "updateId": "78",
    //         "timeStart": "2021-01-28T09:19:30.706Z",
    //         "makerFee": 200,
    //         "takerFee": 200,
    //         "quoteVolume24": 49125.1374009045,
    //         "lowPrice24": 1966.704999,
    //         "highPrice24": 2080.354997,
    //         ...
    //     }
    //
    // fetchTickers
    //     {
    //         "trading_pairs": "BTC_USDT",
    //         "base_currency": "BTC",
    //         "quote_currency": "USDT",
    //         "last_price": 37669.955001,
    //         "lowest_ask": 37670.055,
    //         "highest_bid": 37669.955,
    //         "base_volume": 6.81156888,
    //         "quote_volume": 257400.516878529,
    //         "price_change_percent_24h": -0.29,
    //         "highest_price_24h": 38389.994463,
    //         "lowest_price_24h": 37574.894999
    //     }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeStringLower(ticker, "trading_pairs")
    market = this.SafeMarket(marketId, market)
    var bestBidPrice interface{} = nil
    var bestAskPrice interface{} = nil
    var bestBidVolume interface{} = nil
    var bestAskVolume interface{} = nil
    var bids interface{} = this.SafeValue(ticker, "bids")
    var asks interface{} = this.SafeValue(ticker, "asks")
    if IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(bids, nil))) && IsTrue((IsArray(bids)))) && IsTrue((!IsEqual(asks, nil)))) && IsTrue((IsArray(asks)))) {
        var bestBid interface{} = this.SafeValue(bids, 0, map[string]interface{} {})
        bestBidPrice = this.SafeString(bestBid, "price")
        bestBidVolume = this.SafeString(bestBid, "quantity")
        var bestAsk interface{} = this.SafeValue(asks, 0, map[string]interface{} {})
        bestAskPrice = this.SafeString(bestAsk, "price")
        bestAskVolume = this.SafeString(bestAsk, "quantity")
    } else {
        bestBidPrice = this.SafeString(ticker, "highest_bid")
        bestAskPrice = this.SafeString(ticker, "lowest_ask")
    }
    var baseVolume interface{} = this.SafeString2(ticker, "volume24", "base_volume")
    var quoteVolume interface{} = this.SafeString2(ticker, "quoteVolume24", "quote_volume")
    var high interface{} = this.SafeString2(ticker, "highPrice24", "highest_price_24h")
    var low interface{} = this.SafeString2(ticker, "lowPrice24", "lowest_price_24h")
    var close interface{} = this.SafeString2(ticker, "lastPrice", "last_price")
    var changePcnt interface{} = this.SafeString2(ticker, "change24", "price_change_percent_24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": nil,
        "datetime": nil,
        "open": nil,
        "high": high,
        "low": low,
        "close": close,
        "bid": bestBidPrice,
        "bidVolume": bestBidVolume,
        "ask": bestAskPrice,
        "askVolume": bestAskVolume,
        "vwap": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": changePcnt,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitteam#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://bit.team/trade/api/documentation#/CMC/getTradeApiCmcTradesPair
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#public-trades}
 */
func  (this *bitteam) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes17578 := (<-this.LoadMarkets())
            PanicOnError(retRes17578)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradeApiCmcTradesPair(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "trade_id": 34970337,
            //             "price": 37769.994793,
            //             "base_volume": 0.00119062,
            //             "quote_volume": 44.96971120044166,
            //             "timestamp": 1700827234000,
            //             "type": "buy"
            //         },
            //         {
            //             "trade_id": 34970347,
            //             "price": 37769.634497,
            //             "base_volume": 0.00104009,
            //             "quote_volume": 39.28381914398473,
            //             "timestamp": 1700827248000,
            //             "type": "buy"
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitteam#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtTradesofuser
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
 */
func  (this *bitteam) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17998 := (<-this.LoadMarkets())
            PanicOnError(retRes17998)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pairId", GetValue(market, "numericId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetTradeApiCcxtTradesOfUser(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 3,
            //             "trades": [
            //                 {
            //                     "id": 34880724,
            //                     "tradeId": "4368041",
            //                     "makerOrderId": 106742914,
            //                     "takerOrderId": 106761614,
            //                     "pairId": 2,
            //                     "quantity": "0.00955449",
            //                     "price": "1993.674994",
            //                     "isBuyerMaker": true,
            //                     "baseDecimals": 18,
            //                     "quoteDecimals": 6,
            //                     "side": "sell",
            //                     "timestamp": 1700615250,
            //                     "rewarded": true,
            //                     "makerUserId": 21639,
            //                     "takerUserId": 15913,
            //                     "baseCurrencyId": 2,
            //                     "quoteCurrencyId": 3,
            //                     "feeMaker": {
            //                         "amount": "0.0000191",
            //                         "symbol": "eth",
            //                         "userId": 21639,
            //                         "decimals": 18,
            //                         "symbolId": 2
            //                     },
            //                     "feeTaker": {
            //                         "amount": "0",
            //                         "symbol": "usdt",
            //                         "userId": 15913,
            //                         "decimals": 6,
            //                         "symbolId": 3,
            //                         "discountAmount": "0",
            //                         "discountSymbol": "btt",
            //                         "discountDecimals": 18,
            //                         "discountSymbolId": 5
            //                     },
            //                     "pair": "eth_usdt",
            //                     "createdAt": "2023-11-22T01:07:30.593Z",
            //                     "updatedAt": "2023-11-22T01:10:00.117Z",
            //                     "isCurrentSide": "maker"
            //                 },
            //                 {
            //                     "id": 34875793,
            //                     "tradeId": "4368010",
            //                     "makerOrderId": 106742914,
            //                     "takerOrderId": 106745926,
            //                     "pairId": 2,
            //                     "quantity": "0.0027193",
            //                     "price": "1993.674994",
            //                     "isBuyerMaker": true,
            //                     "baseDecimals": 18,
            //                     "quoteDecimals": 6,
            //                     "side": "sell",
            //                     "timestamp": 1700602983,
            //                     "rewarded": true,
            //                     "makerUserId": 21639,
            //                     "takerUserId": 15912,
            //                     "baseCurrencyId": 2,
            //                     "quoteCurrencyId": 3,
            //                     "feeMaker": {
            //                         "amount": "0.00000543",
            //                         "symbol": "eth",
            //                         "userId": 21639,
            //                         "decimals": 18,
            //                         "symbolId": 2
            //                     },
            //                     "feeTaker": {
            //                         "amount": "0",
            //                         "symbol": "usdt",
            //                         "userId": 15912,
            //                         "decimals": 6,
            //                         "symbolId": 3,
            //                         "discountAmount": "0",
            //                         "discountSymbol": "btt",
            //                         "discountDecimals": 18,
            //                         "discountSymbolId": 5
            //                     },
            //                     "pair": "eth_usdt",
            //                     "createdAt": "2023-11-21T21:43:02.758Z",
            //                     "updatedAt": "2023-11-21T21:45:00.147Z",
            //                     "isCurrentSide": "maker"
            //                 },
            //                 {
            //                     "id": 34871727,
            //                     "tradeId": "3441840",
            //                     "makerOrderId": 106733299,
            //                     "takerOrderId": 106733308,
            //                     "pairId": 22,
            //                     "quantity": "0.00001",
            //                     "price": "37017.495008",
            //                     "isBuyerMaker": false,
            //                     "baseDecimals": 8,
            //                     "quoteDecimals": 6,
            //                     "side": "buy",
            //                     "timestamp": 1700594960,
            //                     "rewarded": true,
            //                     "makerUserId": 15909,
            //                     "takerUserId": 21639,
            //                     "baseCurrencyId": 11,
            //                     "quoteCurrencyId": 3,
            //                     "feeMaker": {
            //                         "amount": "0",
            //                         "symbol": "usdt",
            //                         "userId": 15909,
            //                         "decimals": 6,
            //                         "symbolId": 3,
            //                         "discountAmount": "0",
            //                         "discountSymbol": "btt",
            //                         "discountDecimals": 18,
            //                         "discountSymbolId": 5
            //                     },
            //                     "feeTaker": {
            //                         "amount": "0.00000002",
            //                         "symbol": "btc",
            //                         "userId": 21639,
            //                         "decimals": 8,
            //                         "symbolId": 11
            //                     },
            //                     "pair": "btc_usdt",
            //                     "createdAt": "2023-11-21T19:29:20.092Z",
            //                     "updatedAt": "2023-11-21T19:30:00.159Z"
            //                     "isCurrentSide": "taker"
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var trades interface{} = this.SafeList(result, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //     {
    //         "trade_id": 34970337,
    //         "price": 37769.994793,
    //         "base_volume": 0.00119062,
    //         "quote_volume": 44.96971120044166,
    //         "timestamp": 1700827234000,
    //         "type": "buy"
    //     },
    //
    // fetchMyTrades
    //     {
    //         "id": 34875793,
    //         "tradeId": "4368010",
    //         "makerOrderId": 106742914,
    //         "takerOrderId": 106745926,
    //         "pairId": 2,
    //         "quantity": "0.0027193",
    //         "price": "1993.674994",
    //         "isBuyerMaker": true,
    //         "baseDecimals": 18,
    //         "quoteDecimals": 6,
    //         "side": "sell",
    //         "timestamp": 1700602983,
    //         "rewarded": true,
    //         "makerUserId": 21639,
    //         "takerUserId": 15912,
    //         "baseCurrencyId": 2,
    //         "quoteCurrencyId": 3,
    //         "feeMaker": {
    //             "amount": "0.00000543",
    //             "symbol": "eth",
    //             "userId": 21639,
    //             "decimals": 18,
    //             "symbolId": 2
    //         },
    //         "feeTaker": {
    //             "amount": "0",
    //             "symbol": "usdt",
    //             "userId": 15912,
    //             "decimals": 6,
    //             "symbolId": 3,
    //             "discountAmount": "0",
    //             "discountSymbol": "btt",
    //             "discountDecimals": 18,
    //             "discountSymbolId": 5
    //         },
    //         "pair": "eth_usdt",
    //         "createdAt": "2023-11-21T21:43:02.758Z",
    //         "updatedAt": "2023-11-21T21:45:00.147Z",
    //         "isCurrentSide": "maker"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "pair")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeString2(trade, "id", "trade_id")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString2(trade, "quantity", "base_volume")
    var cost interface{} = this.SafeString(trade, "quote_volume")
    var takerOrMaker interface{} = this.SafeString(trade, "isCurrentSide")
    var timestamp interface{} = this.SafeString(trade, "timestamp")
    if IsTrue(!IsEqual(takerOrMaker, nil)) {
        timestamp = Precise.StringMul(timestamp, "1000")
    }
    // the exchange returns the side of the taker
    var side interface{} = this.SafeString2(trade, "side", "type")
    var feeInfo interface{} = nil
    var order interface{} = nil
    if IsTrue(IsEqual(takerOrMaker, "maker")) {
        if IsTrue(IsEqual(side, "sell")) {
            side = "buy"
        } else if IsTrue(IsEqual(side, "buy")) {
            side = "sell"
        }
        order = this.SafeString(trade, "makerOrderId")
        feeInfo = this.SafeValue(trade, "feeMaker", map[string]interface{} {})
    } else if IsTrue(IsEqual(takerOrMaker, "taker")) {
        order = this.SafeString(trade, "takerOrderId")
        feeInfo = this.SafeValue(trade, "feeTaker", map[string]interface{} {})
    }
    var feeCurrencyId interface{} = this.SafeString(feeInfo, "symbol")
    var feeCost interface{} = this.SafeString(feeInfo, "amount")
    var fee interface{} = map[string]interface{} {
        "currency": this.SafeCurrencyCode(feeCurrencyId),
        "cost": feeCost,
    }
    var intTs interface{} = this.ParseToInt(timestamp)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": order,
        "timestamp": intTs,
        "datetime": this.Iso8601(intTs),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name betteam#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiCcxtBalance
 * @param {object} [params] extra parameters specific to the betteam api endpoint
 * @returns {object} a [balance structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#balance-structure}
 */
func  (this *bitteam) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20648 := (<-this.LoadMarkets())
            PanicOnError(retRes20648)
        
            response:= (<-this.PrivateGetTradeApiCcxtBalance(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseBalance(response interface{}) interface{}  {
    //
    //     {
    //         "ok": true,
    //         "result": {
    //             "free": {
    //                 "USDT": "0",
    //                 "DEL": "0",
    //                 "BTC": "0",
    //                 ...
    //             },
    //                 "used": {
    //                 "USDT": "0",
    //                 "DEL": "0",
    //                 "BTC": "0",
    //                 ...
    //             },
    //             "total": {
    //                 "USDT": "0",
    //                 "DEL": "0",
    //                 "BTC": "0",
    //                 ...
    //             },
    //             "USDT": {
    //                 "free": "0",
    //                 "used": "0",
    //                 "total": "0",
    //             },
    //             "DEL": {
    //                 "free": "0",
    //                 "used": "0",
    //                 "total": "0",
    //             },
    //             "BTC": {
    //                 "free": "0",
    //                 "used": "0",
    //                 "total": "0",
    //             }
    //             ...
    //         }
    //     }
    //
    var timestamp interface{} = this.Milliseconds()
    var balance interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
    var balanceByCurrencies interface{} = this.Omit(result, []interface{}{"free", "used", "total"})
    var rawCurrencyIds interface{} = ObjectKeys(balanceByCurrencies)
    for i := 0; IsLessThan(i, GetArrayLength(rawCurrencyIds)); i++ {
        var rawCurrencyId interface{} = GetValue(rawCurrencyIds, i)
        var currencyBalance interface{} = this.SafeValue(result, rawCurrencyId)
        var free interface{} = this.SafeString(currencyBalance, "free")
        var used interface{} = this.SafeString(currencyBalance, "used")
        var total interface{} = this.SafeString(currencyBalance, "total")
        var currencyCode interface{} = this.SafeCurrencyCode(ToLower(rawCurrencyId))
        AddElementToObject(balance, currencyCode, map[string]interface{} {
    "free": free,
    "used": used,
    "total": total,
})
    }
    return this.SafeBalance(balance)
}
/**
 * @method
 * @name bitteam#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals from external wallets and between CoinList Pro trading account and CoinList wallet
 * @see https://bit.team/trade/api/documentation#/PRIVATE/getTradeApiTransactionsofuser
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal
 * @param {int} [limit] max number of deposit/withdrawals to return (default 10)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @returns {object} a list of [transaction structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#transaction-structure}
 */
func  (this *bitteam) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21488 := (<-this.LoadMarkets())
            PanicOnError(retRes21488)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "numericId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetTradeApiTransactionsOfUser(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "ok": true,
            //         "result": {
            //             "count": 2,
            //             "transactions": [
            //                 {
            //                     "id": 1329686,
            //                     "orderId": "2f060ad5-30f7-4f2b-ac5f-1bb8f5fd34dc",
            //                     "transactionCoreId": "561863",
            //                     "userId": 21639,
            //                     "recipient": "0x9050dfA063D1bE7cA711c750b18D51fDD13e90Ee",
            //                     "sender": "0x6894a93B6fea044584649278621723cac51443Cd",
            //                     "symbolId": 2,
            //                     "CommissionId": 17571,
            //                     "amount": "44000000000000000",
            //                     "params": {},
            //                     "reason": null,
            //                     "timestamp": 1700715341743,
            //                     "status": "approving",
            //                     "statusDescription": null,
            //                     "type": "withdraw",
            //                     "message": null,
            //                     "blockChain": "",
            //                     "before": null,
            //                     "after": null,
            //                     "currency": {
            //                         "symbol": "eth",
            //                         "decimals": 18,
            //                         "blockChain": "Ethereum",
            //                         "links": [
            //                             {
            //                                 "tx": "https://etherscan.io/tx/",
            //                                 "address": "https://etherscan.io/address/",
            //                                 "blockChain": "Ethereum"
            //                             }
            //                         ]
            //                     }
            //                 },
            //                 {
            //                     "id": 1329229,
            //                     "orderId": null,
            //                     "transactionCoreId": "561418",
            //                     "userId": 21639,
            //                     "recipient": "0x7d6a797f2406e06b2f9b41d067df324affa315dd",
            //                     "sender": null,
            //                     "symbolId": 3,
            //                     "CommissionId": null,
            //                     "amount": "100000000",
            //                     "params": {
            //                         "tx_id": "0x2253823c828d838acd983fe6a348fb0e034efe3874b081871d8b80da76ec758b"
            //                     },
            //                     "reason": null,
            //                     "timestamp": 1700594180417,
            //                     "status": "success",
            //                     "statusDescription": null,
            //                     "type": "deposit",
            //                     "message": null,
            //                     "blockChain": "Ethereum",
            //                     "before": 0,
            //                     "after": 100000000,
            //                     "currency": {
            //                         "symbol": "usdt",
            //                         "decimals": 6,
            //                         "blockChain": "",
            //                         "links": [
            //                             {
            //                                 "tx": "https://etherscan.io/tx/",
            //                                 "address": "https://etherscan.io/address/",
            //                                 "blockChain": "Ethereum"
            //                             },
            //                             {
            //                                 "tx": "https://tronscan.org/#/transaction/",
            //                                 "address": "https://tronscan.org/#/address/",
            //                                 "blockChain": "Tron"
            //                             },
            //                             {
            //                                 "tx": "https://bscscan.com/tx/",
            //                                 "address": "https://bscscan.com/address/",
            //                                 "blockChain": "Binance"
            //                             }
            //                         ]
            //                     }
            //                 }
            //             ]
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var transactions interface{} = this.SafeList(result, "transactions", []interface{}{})
        
            ch <- this.ParseTransactions(transactions, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitteam) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": 1329229,
    //         "orderId": null,
    //         "transactionCoreId": "561418",
    //         "userId": 21639,
    //         "recipient": "0x7d6a797f2406e06b2f9b41d067df324affa315dd",
    //         "sender": null,
    //         "symbolId": 3,
    //         "CommissionId": null,
    //         "amount": "100000000",
    //         "params": {
    //             "tx_id": "0x2253823c828d838acd983fe6a348fb0e034efe3874b081871d8b80da76ec758b"
    //         },
    //         "reason": null,
    //         "timestamp": 1700594180417,
    //         "status": "success",
    //         "statusDescription": null,
    //         "type": "deposit",
    //         "message": null,
    //         "blockChain": "Ethereum",
    //         "before": 0,
    //         "after": 100000000,
    //         "currency": {
    //             "symbol": "usdt",
    //             "decimals": 6,
    //             "blockChain": "",
    //             "links": [
    //                 {
    //                     "tx": "https://etherscan.io/tx/",
    //                     "address": "https://etherscan.io/address/",
    //                     "blockChain": "Ethereum"
    //                 },
    //                 {
    //                     "tx": "https://tronscan.org/#/transaction/",
    //                     "address": "https://tronscan.org/#/address/",
    //                     "blockChain": "Tron"
    //                 },
    //                 {
    //                     "tx": "https://bscscan.com/tx/",
    //                     "address": "https://bscscan.com/address/",
    //                     "blockChain": "Binance"
    //                 }
    //             ]
    //         }
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyObject interface{} = this.SafeValue(transaction, "currency")
    var currencyId interface{} = this.SafeString(currencyObject, "symbol")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var id interface{} = this.SafeString(transaction, "id")
    var params interface{} = this.SafeValue(transaction, "params")
    var txid interface{} = this.SafeString(params, "tx_id")
    var timestamp interface{} = this.SafeInteger(transaction, "timestamp")
    var networkId interface{} = this.SafeString(transaction, "blockChain")
    if IsTrue(IsEqual(networkId, nil)) {
        var links interface{} = this.SafeValue(currencyObject, "links", []interface{}{})
        var blockChain interface{} = this.SafeValue(links, 0, map[string]interface{} {})
        networkId = this.SafeString(blockChain, "blockChain")
    }
    var addressFrom interface{} = this.SafeString(transaction, "sender")
    var addressTo interface{} = this.SafeString(transaction, "recipient")
    var tag interface{} = this.SafeString(transaction, "message")
    var typeVar interface{} = this.ParseTransactionType(this.SafeString(transaction, "type"))
    var amount interface{} = this.ParseValueToPricision(transaction, "amount", currencyObject, "decimals")
    var status interface{} = this.ParseTransactionStatus(this.SafeValue(transaction, "status"))
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.NetworkIdToCode(networkId),
        "addressFrom": addressFrom,
        "address": nil,
        "addressTo": addressTo,
        "tagFrom": nil,
        "tag": tag,
        "tagTo": nil,
        "type": typeVar,
        "amount": this.ParseNumber(amount),
        "currency": code,
        "status": status,
        "updated": nil,
        "fee": nil,
        "comment": this.SafeString(transaction, "description"),
        "internal": false,
    }
}
func  (this *bitteam) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "deposit": "deposit",
        "withdraw": "withdrawal",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *bitteam) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "approving": "pending",
        "success": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitteam) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = this.Omit(params, this.ExtractParams(path))
    var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
    var query interface{} = this.Urlencode(request)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(request)
        } else if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
            url = Add(url, Add("?", query))
        }
        var auth interface{} = Add(Add(this.ApiKey, ":"), this.Secret)
        var auth64 interface{} = this.StringToBase64(auth)
        var signature interface{} = Add("Basic ", auth64)
        headers = map[string]interface{} {
            "Authorization": signature,
            "Content-Type": "application/json",
        }
    } else if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
        url = Add(url, Add("?", query))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitteam) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if IsTrue(!IsEqual(code, 200)) {
        if IsTrue(IsEqual(code, 404)) {
            if IsTrue(IsTrue((IsGreaterThanOrEqual(GetIndexOf(url, "/ccxt/order/"), 0))) && IsTrue((IsEqual(method, "GET")))) {
                var parts interface{} = Split(url, "/order/")
                var orderId interface{} = this.SafeString(parts, 1)
                panic(OrderNotFound(Add(Add(Add(this.Id, " order "), orderId), " not found")))
            }
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(url, "/cmc/orderbook/"), 0)) {
                var parts interface{} = Split(url, "/cmc/orderbook/")
                var symbolId interface{} = this.SafeString(parts, 1)
                panic(BadSymbol(Add(Add(Add(this.Id, " symbolId "), symbolId), " not found")))
            }
        }
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString(response, "message")
        var responseCode interface{} = this.SafeString(response, "code")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bitteam) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
