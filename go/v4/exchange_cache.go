package ccxt

// PLEASE DO NOT EDIT THIS FILE MANUALLY UNLESS YOU KNOW WHAT YOU ARE DOING.
// This file provides a minimal Go implementation of the helper caches that
// exist in the JavaScript / C# Web-Socket layers (ArrayCache, ArrayCacheByTimestamp,
// ArrayCacheBySymbolById, ArrayCacheBySymbolBySide).  They satisfy the ArrayCache
// interface declared in exchange.go so that higher-level code can treat them
// uniformly.  The logic is intentionally kept simple – it focuses on correctness
// and type-safety rather than mirroring every micro-optimisation of the JS code.
//
// When the transpiler ports a `pro` exchange it instantiates these caches to
// store streaming Data (trades, ohlcvs, order-books …).  Only two operations
// are required for those flows: Append() and ToArray().  Everything else can be
// added later if/when the need arises.

import "sync"

type Appender interface{ Append(interface{}) }

type CacheType interface {
	*ArrayCache | *ArrayCacheByTimestamp | *ArrayCacheBySymbolById | *ArrayCacheBySymbolBySide | map[string]interface{}

	Append(interface{})
}

type BaseCache struct {
	MaxSize         int           `json:"-"`
	Mu              sync.Mutex    `json:"-"`
	Data            []interface{} `json:"data"`
	allNewUpdates   int           `json:"-"`
	clearAllUpdates bool          `json:"-"`
}

func NewBaseCache(MaxSize int) *BaseCache {
	return &BaseCache{MaxSize: MaxSize, Data: make([]interface{}, 0)}
}

func (c *BaseCache) Clear() {
	c.Mu.Lock()
	defer c.Mu.Unlock()
	c.Data = c.Data[:0]
}

func (c *BaseCache) AppendInternal(item interface{}) {
	// helper (no lock)
	if c.MaxSize > 0 && len(c.Data) >= c.MaxSize {
		// drop the oldest element (behaviour identical to JS shift())
		c.Data = c.Data[1:]
	}
	c.Data = append(c.Data, item)
}

// ArrayCache provides O(1) lookup by symbol+id (for orders / trades).
// It also tracks how many new updates arrived but that part is optional for
// now, we expose only the primitives that the rest of the Go code relies on.

type ArrayCache struct {
	*BaseCache

	Hashmap                  map[string]map[string]interface{} `json:"-"`
	nestedNewUpdates         bool                              `json:"-"`
	newUpdatesBySymbol       map[string]Set                    `json:"-"`
	clearUpdatesBySymbol     map[string]bool                   `json:"-"`
	nestedNewUpdatesBySymbol bool                              `json:"-"`
}

func NewArrayCache(MaxSize interface{}) *ArrayCache {
	size := 0
	switch v := MaxSize.(type) {
	case int:
		size = v
	case int64:
		size = int(v)
	case float64:
		size = int(v)
	}
	return &ArrayCache{
		BaseCache:                NewBaseCache(size),
		Hashmap:                  make(map[string]map[string]interface{}),
		newUpdatesBySymbol:       make(map[string]Set),
		clearUpdatesBySymbol:     make(map[string]bool),
		nestedNewUpdatesBySymbol: false,
	}
}

func (c *ArrayCache) Append(item interface{}) {
	// We expect the incoming item to at least expose a "symbol" field; try to
	// extract it when it is a map[string]interface{} – if not present we still
	// store the item, it just won't participate in Hashmap logic.
	var symbol, id string
	if m, ok := item.(map[string]interface{}); ok {
		if s, ok := m["symbol"].(string); ok {
			symbol = s
		}
		// optional id field
		if ident, ok := m["id"].(string); ok {
			id = ident
		}
	}

	// Basic ring-buffer semantics
	c.Mu.Lock()
	defer c.Mu.Unlock()
	shouldAppend := true
	if symbol != "" && id != "" {
		// keep reference for O(1) updates / de-dupe
		byId := c.Hashmap[symbol]
		if byId == nil {
			byId = make(map[string]interface{})
			c.Hashmap[symbol] = byId
		}
		if old, exists := byId[id]; exists {
			// overwrite in-place (mirror JS behaviour where the reference is
			// kept alive).  Shallow copy for now.
			if om, ok := old.(map[string]interface{}); ok {
				if nm, ok := item.(map[string]interface{}); ok {
					for k, v := range nm {
						om[k] = v
					}
					item = om // keep the original reference in the array
				}
			}
			shouldAppend = false
		} else {
			byId[id] = item
		}
	}

	if c.MaxSize != 0 && c.MaxSize == len(c.Data) && shouldAppend {
		// remove first elem from data
		removed := c.Data[0]
		removedMap, ok := removed.(map[string]interface{})
		if ok {
			removedSymbol, okSym := removedMap["symbol"].(string)
			removedId, okId := removedMap["id"].(string)
			if okSym && okId {
				byId := c.Hashmap[removedSymbol]
				if byId != nil {
					delete(byId, removedId)
					if len(byId) == 0 {
						delete(c.Hashmap, removedSymbol)
					}
				}
			}
		}
		c.Data = append(c.Data[:0], c.Data[1:]...)
		// delete from c.hashMap as well

	}

	if shouldAppend {
		c.AppendInternal(item)
	} else {
		// move to the end of the array to reflect recent update
		for i, v := range c.Data {
			if GetValue(v, "id") == GetValue(item, "id") {
				// remove from current position
				c.Data = append(c.Data[:i], c.Data[i+1:]...)
				// append to the end
				c.Data = append(c.Data, item)
				break
			}
		}
	}

	if c.clearAllUpdates {
		c.clearAllUpdates = false
		c.clearUpdatesBySymbol = make(map[string]bool)
		c.allNewUpdates = 0
		c.newUpdatesBySymbol = make(map[string]Set)
	}

	if _, exists := c.newUpdatesBySymbol[symbol]; !exists {
		c.newUpdatesBySymbol[symbol] = *NewSet()
	}

	if _, exists := c.clearUpdatesBySymbol[symbol]; exists {
		c.clearUpdatesBySymbol[symbol] = false
		c.newUpdatesBySymbol[symbol] = *NewSet()
	}

	idSet := c.newUpdatesBySymbol[symbol]
	beforeSize := idSet.Size()
	idSet.Add(id)
	afterSize := idSet.Size()
	c.allNewUpdates += (afterSize - beforeSize)
}

// func areArraysEqual(a interface{}, b interface{}) bool {
// 	arrA, okA := a.([]interface{})
// 	arrB, okB := b.([]interface{})
// 	if !okA || !okB {
// 		return false
// 	}
// 	if len(arrA) != len(arrB) {
// 		return false
// 	}
// 	for i := range arrA {
// 		// elems can be ints, or map[string]interface{} etc
// 		if !IsEqual(arrA[i], arrB[i]) {
// 			return false
// 		}
// 		// if arrA[i] != arrB[i] {
// 		// 	return false
// 		// }
// 	}
// 	return true
// }

// ToArray implements the ArrayCache interface (defined in exchange.go).
func (c *ArrayCache) ToArray() []interface{} {
	c.Mu.Lock()
	defer c.Mu.Unlock()
	// return a shallow copy to prevent external Mutation
	out := make([]interface{}, len(c.Data))
	copy(out, c.Data)
	return out
}

// The function returns interface{} so the transpiled code that works with
// loosely-typed limits continues to compile.
func (c *ArrayCache) GetLimit(symbol interface{}, limit interface{}) interface{} {
	// if limit != nil {
	// 	return limit
	// }
	// if symbolStr, ok := symbol.(string); ok && symbolStr != "" {
	// 	if byId, exists := c.Hashmap[symbolStr]; exists {
	// 		return len(byId)
	// 	}
	// }
	// return len(c.ToArray())
	var newUpdatesValue interface{} = nil

	if symbol == nil {
		newUpdatesValue = c.allNewUpdates
		c.clearAllUpdates = true
	} else {
		tempNewUpdates, found := c.newUpdatesBySymbol[ToString(symbol)]
		if found && c.nestedNewUpdatesBySymbol {
			newUpdatesValue = tempNewUpdates.Size()
		}
		c.clearUpdatesBySymbol[ToString(symbol)] = true
	}

	if newUpdatesValue == nil {
		return limit
	} else if limit != nil {
		return MathMin(newUpdatesValue, limit)
	} else {
		return newUpdatesValue
	}
}

// removes all items with the given symbol from the cache
func (c *ArrayCache) Remove(symbol string) {
	c.Mu.Lock()
	defer c.Mu.Unlock()

	// Remove from hashmap
	delete(c.Hashmap, symbol)

	// Remove from newUpdatesBySymbol
	delete(c.newUpdatesBySymbol, symbol)

	// Remove from clearUpdatesBySymbol
	delete(c.clearUpdatesBySymbol, symbol)

	// Filter out items with this symbol from Data
	var filteredData []interface{}
	for _, item := range c.Data {
		if m, ok := item.(map[string]interface{}); ok {
			if s, ok := m["symbol"].(string); ok && s == symbol {
				continue // Skip this item
			}
		}
		filteredData = append(filteredData, item)
	}
	c.Data = filteredData
}

// ArrayCacheByTimestamp keeps the most recent N entries identified by their
// first element (timestamp). We just need Append and ToArray.

type ArrayCacheByTimestamp struct {
	*BaseCache
	Hashmap      map[int64]interface{}
	newUpdates   int
	clearUpdates bool
	sizeTracker  *Set
}

func NewArrayCacheByTimestamp(MaxSize interface{}) *ArrayCacheByTimestamp {
	size := 0
	switch v := MaxSize.(type) {
	case int:
		size = v
	case int64:
		size = int(v)
	case float64:
		size = int(v)
	}
	return &ArrayCacheByTimestamp{
		BaseCache:   NewBaseCache(size),
		Hashmap:     make(map[int64]interface{}),
		sizeTracker: NewSet(),
	}
}

func (c *ArrayCacheByTimestamp) Append(item interface{}) {
	var ts int64
	if arr, ok := item.([]interface{}); ok && len(arr) > 0 {
		if v, okCast := arr[0].(int64); okCast {
			ts = v
		} else if vI, okI := arr[0].(int); okI {
			ts = int64(vI)
		} else if vF, okF := arr[0].(float64); okF {
			ts = int64(vF)
		}
	}

	c.Mu.Lock()
	defer c.Mu.Unlock()
	if ts != 0 {
		if _, exists := c.Hashmap[ts]; exists {
			// c.Hashmap[ts] = item // update existing
			// locate and update in Data as well
			// to do use the reference in hashmap instead of searching
			currItem := c.Hashmap[ts].([]interface{})
			for i := range currItem {
				if arr, ok := item.([]interface{}); ok && len(arr) > 0 {
					currItem[i] = arr[i]
				}
			}
			// c.Hashmap[ts] = item
			// for i, v := range c.Data {
			// 	if arr, ok := v.([]interface{}); ok && len(arr) > 0 {
			// 		var ets int64
			// 		if v2, okCast := arr[0].(int64); okCast {
			// 			ets = v2
			// 		} else if vI, okI := arr[0].(int); okI {
			// 			ets = int64(vI)
			// 		}
			// 		if ets == ts {
			// 			c.Data[i] = item
			// 			break
			// 		}
			// 	}
			// }
			return
		} else {
			c.Hashmap[ts] = item
		}
	}

	if c.clearUpdates {
		c.clearUpdates = false
		c.sizeTracker = NewSet()
	}

	c.AppendInternal(item)
	c.sizeTracker.Add(ToString(ts))
	c.newUpdates = c.sizeTracker.Size()
}

func (c *ArrayCacheByTimestamp) ToArray() []interface{} {
	c.Mu.Lock()
	defer c.Mu.Unlock()
	out := make([]interface{}, len(c.Data))
	copy(out, c.Data)
	return out
}

// GetLimit for timestamp cache ignores symbol because entries are not
// symbol-segmented.  It mirrors the same precedence order as ArrayCache.
func (c *ArrayCacheByTimestamp) GetLimit(symbol interface{}, limit interface{}) interface{} {
	c.clearUpdates = true
	if limit == nil {
		return c.newUpdates
	}
	return MathMin(c.newUpdates, limit)
}

// Remove removes all items with the given symbol from the timestamp cache
func (c *ArrayCacheByTimestamp) Remove(symbol string) {
	c.Mu.Lock()
	defer c.Mu.Unlock()

	// Filter out items with this symbol from Data
	var filteredData []interface{}
	for _, item := range c.Data {
		if m, ok := item.(map[string]interface{}); ok {
			if s, ok := m["symbol"].(string); ok && s == symbol {
				continue
			}
		}
		filteredData = append(filteredData, item)
	}
	c.Data = filteredData
}

// ArrayCacheBySymbolById nests two levels: symbol → id.
// It embeds ArrayCache to reuse its logic.

type ArrayCacheBySymbolById struct{ *ArrayCache }

func NewArrayCacheBySymbolById(optionalArgs ...interface{}) *ArrayCacheBySymbolById {
	maxSize := GetArg(optionalArgs, 0, nil)
	cache := &ArrayCacheBySymbolById{NewArrayCache(maxSize)}
	cache.nestedNewUpdatesBySymbol = true
	return cache
}

// GetLimit for nested caches delegates to the inner ArrayCache.
func (c *ArrayCacheBySymbolById) GetLimit(symbol interface{}, limit interface{}) interface{} {
	return c.ArrayCache.GetLimit(symbol, limit)
}

// Remove delegates to the inner ArrayCache
func (c *ArrayCacheBySymbolById) Remove(symbol string) {
	c.ArrayCache.Remove(symbol)
}

// ArrayCacheBySymbolBySide keeps the last update per (symbol, side).

type ArrayCacheBySymbolBySide struct{ *ArrayCache }

func NewArrayCacheBySymbolBySide() *ArrayCacheBySymbolBySide {
	res := &ArrayCacheBySymbolBySide{NewArrayCache(nil)}
	res.nestedNewUpdatesBySymbol = true
	return res
}

// These specialised caches currently rely on ArrayCache.Append which tracks by
// (symbol, id).  For BySide we override Append to key by side instead.
func (c *ArrayCacheBySymbolBySide) Append(item interface{}) {
	var symbol, side string
	if m, ok := item.(map[string]interface{}); ok {
		if s, ok := m["symbol"].(string); ok {
			symbol = s
		}
		if sd, ok := m["side"].(string); ok {
			side = sd
		}
	}

	c.Mu.Lock()
	defer c.Mu.Unlock()
	shouldAppend := true

	// if symbol != "" && side != "" {
	// 	bySide := c.Hashmap[symbol]
	// 	if bySide == nil {
	// 		bySide = make(map[string]interface{})
	// 		c.Hashmap[symbol] = bySide
	// 	}
	// 	bySide[side] = item
	// }

	if _, found := c.Hashmap[symbol]; !found {
		c.Hashmap[symbol] = make(map[string]interface{})
	}

	bySide := c.Hashmap[symbol]

	if _, exists := bySide[side]; exists {
		if om, ok := bySide[side].(map[string]interface{}); ok {
			if nm, ok := item.(map[string]interface{}); ok {
				for k, v := range nm {
					om[k] = v
				}
				item = om
			}
		}
		shouldAppend = false
	} else {
		bySide[side] = item
	}
	if shouldAppend {
		c.AppendInternal(item)
	} else {
		// move to the end of the array to reflect recent update
		for i, v := range c.Data {
			if GetValue(v, "side") == side && GetValue(v, "symbol") == symbol {
				// remove from current position
				c.Data = append(c.Data[:i], c.Data[i+1:]...)
				// append to the end
				c.Data = append(c.Data, item)
				break
			}
		}
	}

	if c.clearAllUpdates {
		c.clearAllUpdates = false
		c.clearUpdatesBySymbol = make(map[string]bool)
		c.allNewUpdates = 0
		c.newUpdatesBySymbol = make(map[string]Set)
	}

	if _, exists := c.newUpdatesBySymbol[symbol]; !exists {
		c.newUpdatesBySymbol[symbol] = *NewSet()
	}

	if _, exists := c.clearUpdatesBySymbol[symbol]; exists {
		c.clearUpdatesBySymbol[symbol] = false
		c.newUpdatesBySymbol[symbol] = *NewSet()
	}

	sideSet := c.newUpdatesBySymbol[symbol]
	beforeSize := sideSet.Size()
	sideSet.Add(side)
	afterSize := sideSet.Size()
	c.allNewUpdates += (afterSize - beforeSize)
}

func (c *ArrayCacheBySymbolBySide) GetLimit(symbol interface{}, limit interface{}) interface{} {
	return c.ArrayCache.GetLimit(symbol, limit)
}

// Remove delegates to the inner ArrayCache
func (c *ArrayCacheBySymbolBySide) Remove(symbol string) {
	c.ArrayCache.Remove(symbol)
}

// implement set for size-tracker and others

type Set struct {
	elements map[string]struct{}
}

func NewSet() *Set {
	return &Set{
		elements: make(map[string]struct{}),
	}
}

func (s *Set) Add(value string) {
	s.elements[value] = struct{}{}
}

func (s *Set) Remove(value string) {
	delete(s.elements, value)
}

func (s *Set) Contains(value string) bool {
	_, found := s.elements[value]
	return found
}

func (s *Set) Size() int {
	return len(s.elements)
}
