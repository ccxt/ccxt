package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type idex struct {
    Exchange

}

func NewIdexCore() idex {
   p := idex{}
   setDefaults(&p)
   return p
}

func  (this *idex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "idex",
        "name": "IDEX",
        "countries": []interface{}{"US"},
        "rateLimit": 1000,
        "version": "v3",
        "pro": true,
        "dex": true,
        "certified": false,
        "requiresWeb3": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": false,
            "fetchWithdrawal": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "6h": "6h",
            "1d": "1d",
        },
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "MATIC": "https://api-sandbox-matic.idex.io",
            },
            "logo": "https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg",
            "api": map[string]interface{} {
                "MATIC": "https://api-matic.idex.io",
            },
            "www": "https://idex.io",
            "doc": []interface{}{"https://api-docs-v3.idex.io/"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "ping": 1,
                    "time": 1,
                    "exchange": 1,
                    "assets": 1,
                    "markets": 1,
                    "tickers": 1,
                    "candles": 1,
                    "trades": 1,
                    "orderbook": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "user": 1,
                    "wallets": 1,
                    "balances": 1,
                    "orders": 0.1,
                    "fills": 0.1,
                    "deposits": 1,
                    "withdrawals": 1,
                    "wsToken": 1,
                },
                "post": map[string]interface{} {
                    "wallets": 1,
                    "orders": 0.1,
                    "orders/test": 0.1,
                    "withdrawals": 1,
                },
                "delete": map[string]interface{} {
                    "orders": 0.1,
                },
            },
        },
        "options": map[string]interface{} {
            "defaultTimeInForce": "gtc",
            "defaultSelfTradePrevention": "cn",
            "network": "MATIC",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": true,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 1000000,
                    "daysBackCanceled": 1,
                    "untilDays": 1000000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "INVALID_ORDER_QUANTITY": InvalidOrder,
                "INSUFFICIENT_FUNDS": InsufficientFunds,
                "SERVICE_UNAVAILABLE": ExchangeNotAvailable,
                "EXCEEDED_RATE_LIMIT": DDoSProtection,
                "INVALID_PARAMETER": BadRequest,
                "WALLET_NOT_ASSOCIATED": InvalidAddress,
                "INVALID_WALLET_SIGNATURE": AuthenticationError,
            },
        },
        "requiredCredentials": map[string]interface{} {
            "walletAddress": true,
            "privateKey": true,
            "apiKey": true,
            "secret": true,
        },
        "precisionMode": TICK_SIZE,
        "paddingMode": PAD_WITH_ZERO,
        "commonCurrencies": map[string]interface{} {},
    })
}
func  (this *idex) PriceToPrecision(symbol interface{}, price interface{}) interface{}  {
    //
    // we override priceToPrecision to fix the following issue
    // https://github.com/ccxt/ccxt/issues/13367
    // {"code":"INVALID_PARAMETER","message":"invalid value provided for request parameter \"price\": all quantities and prices must be below 100 billion, above 0, need to be provided as strings, and always require 4 decimals ending with 4 zeroes"}
    //
    var market interface{} = this.Market(symbol)
    price = this.DecimalToPrecision(price, ROUND, GetValue(GetValue(market, "precision"), "price"), this.PrecisionMode)
    return this.DecimalToPrecision(price, TRUNCATE, GetValue(GetValue(market, "precision"), "quote"), TICK_SIZE, PAD_WITH_ZERO)
}
/**
 * @method
 * @name idex#fetchMarkets
 * @description retrieves data on all markets for idex
 * @see https://api-docs-v3.idex.io/#get-markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *idex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
            //
            //    [
            //        {
            //            "market": "ETH-USDC",
            //            "type": "hybrid",
            //            "status": "activeHybrid",
            //            "baseAsset": "ETH",
            //            "baseAssetPrecision": "8",
            //            "quoteAsset": "USDC",
            //            "quoteAssetPrecision": "8",
            //            "makerFeeRate": "0.0000",
            //            "takerFeeRate": "0.2500",
            //            "takerIdexFeeRate": "0.0500",
            //            "takerLiquidityProviderFeeRate": "0.2000",
            //            "tickSize": "0.01000000"
            //        },
            //    ]
            //
        
            response2:= (<-this.PublicGetExchange())
            PanicOnError(response2)
            //
            //    {
            //        "timeZone": "UTC",
            //        "serverTime": "1654460599952",
            //        "maticDepositContractAddress": "0x3253a7e75539edaeb1db608ce6ef9aa1ac9126b6",
            //        "maticCustodyContractAddress": "0x3bcc4eca0a40358558ca8d1bcd2d1dbde63eb468",
            //        "maticUsdPrice": "0.60",
            //        "gasPrice": "180",
            //        "volume24hUsd": "10015814.46",
            //        "totalVolumeUsd": "1589273533.28",
            //        "totalTrades": "1534904",
            //        "totalValueLockedUsd": "12041929.44",
            //        "idexStakingValueLockedUsd": "20133816.98",
            //        "idexTokenAddress": "0x9Cb74C8032b007466865f060ad2c46145d45553D",
            //        "idexUsdPrice": "0.07",
            //        "idexMarketCapUsd": "48012346.00",
            //        "makerFeeRate": "0.0000",
            //        "takerFeeRate": "0.0025",
            //        "takerIdexFeeRate": "0.0005",
            //        "takerLiquidityProviderFeeRate": "0.0020",
            //        "makerTradeMinimum": "10.00000000",
            //        "takerTradeMinimum": "1.00000000",
            //        "withdrawMinimum": "0.50000000",
            //        "liquidityAdditionMinimum": "0.50000000",
            //        "liquidityRemovalMinimum": "0.40000000",
            //        "blockConfirmationDelay": "64"
            //    }
            //
            var maker interface{} = this.SafeNumber(response2, "makerFeeRate")
            var taker interface{} = this.SafeNumber(response2, "takerFeeRate")
            var makerMin interface{} = this.SafeString(response2, "makerTradeMinimum")
            var takerMin interface{} = this.SafeString(response2, "takerTradeMinimum")
            var minCostETH interface{} = this.ParseNumber(Precise.StringMin(makerMin, takerMin))
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var marketId interface{} = this.SafeString(entry, "market")
                var baseId interface{} = this.SafeString(entry, "baseAsset")
                var quoteId interface{} = this.SafeString(entry, "quoteAsset")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var basePrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "baseAssetPrecision")))
                var quotePrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "quoteAssetPrecision")))
                var status interface{} = this.SafeString(entry, "status")
                var minCost interface{} = nil
                if IsTrue(IsEqual(quote, "ETH")) {
                    minCost = minCostETH
                }
                AppendToArray(&result,map[string]interface{} {
                    "id": marketId,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": (!IsEqual(status, "inactive")),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": taker,
                    "maker": maker,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": basePrecision,
                        "price": this.SafeNumber(entry, "tickSize"),
                        "base": basePrecision,
                        "quote": quotePrecision,
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": basePrecision,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": quotePrecision,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": minCost,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": entry,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs-v3.idex.io/#get-tickers
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *idex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes712714 := (<-this.LoadMarkets())
            PanicOnError(retRes712714)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            // [
            //   {
            //     "market": "DIL-ETH",
            //     "time": 1598367493008,
            //     "open": "0.09695361",
            //     "high": "0.10245881",
            //     "low": "0.09572507",
            //     "close": "0.09917079",
            //     "closeQuantity": "0.71320950",
            //     "baseVolume": "309.17380612",
            //     "quoteVolume": "30.57633981",
            //     "percentChange": "2.28",
            //     "numTrades": 205,
            //     "ask": "0.09910476",
            //     "bid": "0.09688340",
            //     "sequence": 3902
            //   }
            // ]
        
            response:= (<-this.PublicGetTickers(this.Extend(request, params)))
            PanicOnError(response)
            var ticker interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api-docs-v3.idex.io/#get-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *idex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes652889 := (<-this.LoadMarkets())
            PanicOnError(retRes652889)
            // [
            //   {
            //     "market": "DIL-ETH",
            //     "time": 1598367493008,
            //     "open": "0.09695361",
            //     "high": "0.10245881",
            //     "low": "0.09572507",
            //     "close": "0.09917079",
            //     "closeQuantity": "0.71320950",
            //     "baseVolume": "309.17380612",
            //     "quoteVolume": "30.57633981",
            //     "percentChange": "2.28",
            //     "numTrades": 205,
            //     "ask": "0.09910476",
            //     "bid": "0.09688340",
            //     "sequence": 3902
            //   }, ...
            // ]
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
        
            ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //   "market": "DIL-ETH",
    //   "time": 1598367493008,
    //   "open": "0.09695361",
    //   "high": "0.10245881",
    //   "low": "0.09572507",
    //   "close": "0.09917079",
    //   "closeQuantity": "0.71320950",
    //   "baseVolume": "309.17380612",
    //   "quoteVolume": "30.57633981",
    //   "percentChange": "2.28",
    //   "numTrades": 205,
    //   "ask": "0.09910476",
    //   "bid": "0.09688340",
    //   "sequence": 3902
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "market")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(ticker, "time")
    var close interface{} = this.SafeString(ticker, "close")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "percentChange"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "baseVolume"),
        "quoteVolume": this.SafeString(ticker, "quoteVolume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name idex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs-v3.idex.io/#get-candles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *idex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes915989 := (<-this.LoadMarkets())
            PanicOnError(retRes915989)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "interval": timeframe,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
        
            response:= (<-this.PublicGetCandles(this.Extend(request, params)))
            PanicOnError(response)
            if IsTrue(IsArray(response)) {
        
                        // [
                //   {
                //     "start": 1598345580000,
                //     "open": "0.09771286",
                //     "high": "0.09771286",
                //     "low": "0.09771286",
                //     "close": "0.09771286",
                //     "volume": "1.45340410",
                //     "sequence": 3853
                //   }, ...
                // ]
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
                return nil
            } else {
        
                        //  {"nextTime":1595536440000}
        ch <- []interface{}{}
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *idex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //   "start": 1598345580000,
    //   "open": "0.09771286",
    //   "high": "0.09771286",
    //   "low": "0.09771286",
    //   "close": "0.09771286",
    //   "volume": "1.45340410",
    //   "sequence": 3853
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ohlcv, "start")
    var open interface{} = this.SafeNumber(ohlcv, "open")
    var high interface{} = this.SafeNumber(ohlcv, "high")
    var low interface{} = this.SafeNumber(ohlcv, "low")
    var close interface{} = this.SafeNumber(ohlcv, "close")
    var volume interface{} = this.SafeNumber(ohlcv, "volume")
    return []interface{}{timestamp, open, high, low, close, volume}
}
/**
 * @method
 * @name idex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs-v3.idex.io/#get-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *idex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes307414 := (<-this.LoadMarkets())
            PanicOnError(retRes307414)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            // [
            //   {
            //     "fillId": "b5467d00-b13e-3fa9-8216-dd66735550fc",
            //     "price": "0.09771286",
            //     "quantity": "1.45340410",
            //     "quoteQuantity": "0.14201627",
            //     "time": 1598345638994,
            //     "makerSide": "buy",
            //     "sequence": 3853
            //   }, ...
            // ]
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public trades
    //  {
    //      "fillId":"a4883704-850b-3c4b-8588-020b5e4c62f1",
    //      "price":"0.20377008",
    //      "quantity":"47.58448728",
    //      "quoteQuantity":"9.69629509",
    //      "time":1642091300873,
    //      "makerSide":"buy",
    //      "type":"hybrid",        // one of either: "orderBook", "hybrid", or "pool"
    //      "sequence":31876
    //  }
    //
    // private trades
    //  {
    //      "fillId":"83429066-9334-3582-b710-78858b2f0d6b",
    //      "price":"0.20717368",
    //      "quantity":"15.00000000",
    //      "quoteQuantity":"3.10760523",
    //      "orderBookQuantity":"0.00000003",
    //      "orderBookQuoteQuantity":"0.00000001",
    //      "poolQuantity":"14.99999997",
    //      "poolQuoteQuantity":"3.10760522",
    //      "time":1642083351215,
    //      "makerSide":"sell",
    //      "sequence":31795,
    //      "market":"IDEX-USDC",
    //      "orderId":"4fe993f0-747b-11ec-bd08-79d4a0b6e47c",
    //      "side":"buy",
    //      "fee":"0.03749989",
    //      "feeAsset":"IDEX",
    //      "gas":"0.40507261",
    //      "liquidity":"taker",
    //      "type":"hybrid",
    //      "txId":"0x69f6d82a762d12e3201efd0b3e9cc1969351e3c6ea3cf07c47c66bf24a459815",
    //      "txStatus":"mined"
    //  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "fillId")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "quantity")
    var costString interface{} = this.SafeString(trade, "quoteQuantity")
    var timestamp interface{} = this.SafeInteger(trade, "time")
    var marketId interface{} = this.SafeString(trade, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    // this code handles the duality of public vs private trades
    var makerSide interface{} = this.SafeString(trade, "makerSide")
    var oppositeSide interface{} = Ternary(IsTrue((IsEqual(makerSide, "buy"))), "sell", "buy")
    var side interface{} = this.SafeString(trade, "side", oppositeSide)
    var takerOrMaker interface{} = this.SafeString(trade, "liquidity", "taker")
    var feeCostString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "feeAsset")
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": this.SafeCurrencyCode(feeCurrencyId),
        }
    }
    var orderId interface{} = this.SafeString(trade, "orderId")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": orderId,
        "type": "limit",
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name idex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://api-docs-v3.idex.io/#get-api-account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *idex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes26061 := (<-this.LoadMarkets())
            PanicOnError(retRes26061)
            var nonce interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "nonce": nonce,
            }
            var response interface{} = nil
            
        response = (<-this.PrivateGetUser(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "depositEnabled": true,
            //         "orderEnabled": true,
            //         "cancelEnabled": true,
            //         "withdrawEnabled": true,
            //         "totalPortfolioValueUsd": "0.00",
            //         "makerFeeRate": "0.0000",
            //         "takerFeeRate": "0.0025",
            //         "takerIdexFeeRate": "0.0005",
            //         "takerLiquidityProviderFeeRate": "0.0020"
            //     }
            //
            var maker interface{} = this.SafeNumber(response, "makerFeeRate")
            var taker interface{} = this.SafeNumber(response, "takerFeeRate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": maker,
            "taker": taker,
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs-v3.idex.io/#get-order-books
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *idex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes617801 := (<-this.LoadMarkets())
            PanicOnError(retRes617801)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "level": 2,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            // {
            //   "sequence": 36416753,
            //   "bids": [
            //     [ '0.09672815', "8.22284267", 1 ],
            //     [ '0.09672814', "1.83685554", 1 ],
            //     [ '0.09672143', "4.10962617", 1 ],
            //     [ '0.09658884', "4.03863759", 1 ],
            //     [ '0.09653781', "3.35730684", 1 ],
            //     [ '0.09624660', "2.54163586", 1 ],
            //     [ '0.09617490', "1.93065030", 1 ]
            //   ],
            //   "asks": [
            //     [ '0.09910476', "3.22840154", 1 ],
            //     [ '0.09940587', "3.39796593", 1 ],
            //     [ '0.09948189', "4.25088898", 1 ],
            //     [ '0.09958362', "2.42195784", 1 ],
            //     [ '0.09974393', "4.25234367", 1 ],
            //     [ '0.09995250', "3.40192141", 1 ]
            //   ]
            // }
        
            response:= (<-this.PublicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            var nonce interface{} = this.SafeInteger(response, "sequence")
        
            ch <- map[string]interface{} {
                "symbol": symbol,
                "timestamp": nil,
                "datetime": nil,
                "nonce": nonce,
                "bids": this.ParseSide(response, "bids"),
                "asks": this.ParseSide(response, "asks"),
            }
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseSide(book interface{}, side interface{}) interface{}  {
    var bookSide interface{} = this.SafeValue(book, side, []interface{}{})
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bookSide)); i++ {
        var order interface{} = GetValue(bookSide, i)
        var price interface{} = this.SafeNumber(order, 0)
        var amount interface{} = this.SafeNumber(order, 1)
        var orderCount interface{} = this.SafeInteger(order, 2)
        AppendToArray(&result,[]interface{}{price, amount, orderCount})
    }
    var descending interface{} = IsEqual(side, "bids")
    return this.SortBy(result, 0, descending)
}
/**
 * @method
 * @name idex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api-docs-v3.idex.io/#get-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *idex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAssets(params))
            PanicOnError(response)
            //
            //     [
            //        {
            //            "name": "Ethereum",
            //            "symbol": "ETH",
            //            "contractAddress": "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
            //            "assetDecimals": "18",
            //            "exchangeDecimals": "8",
            //            "maticPrice": "3029.38503483"
            //        },
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var name interface{} = this.SafeString(entry, "name")
                var currencyId interface{} = this.SafeString(entry, "symbol")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "exchangeDecimals")))
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "code": code,
            "info": entry,
            "type": nil,
            "name": name,
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": precision,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": precision,
                    "max": nil,
                },
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(entry, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(entry, "quantity"))
        AddElementToObject(account, "free", this.SafeString(entry, "availableForTrade"))
        AddElementToObject(account, "used", this.SafeString(entry, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name idex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-docs-v3.idex.io/#get-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *idex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes59396 := (<-this.LoadMarkets())
            PanicOnError(retRes59396)
            var nonce1 interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "nonce": nonce1,
                "wallet": this.WalletAddress,
            }
            // [
            //   {
            //     "asset": "DIL",
            //     "quantity": "0.00000000",
            //     "availableForTrade": "0.00000000",
            //     "locked": "0.00000000",
            //     "usdValue": null
            //   }, ...
            // ]
            var extendedRequest interface{} = this.Extend(request, params)
            if IsTrue(IsEqual(GetValue(extendedRequest, "wallet"), nil)) {
                panic(BadRequest(Add(this.Id, " fetchBalance() wallet is undefined, set this.walletAddress or \"address\" in params")))
            }
            var response interface{} = nil
            
            {		ret__ := func(this *idex) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *idex) interface{} {
            					// catch block:
                                        if IsTrue(IsInstance(e, InvalidAddress)) {
                        var walletAddress interface{} = GetValue(extendedRequest, "wallet")
            
                        retRes843098 := (<-this.AssociateWallet(walletAddress))
                        PanicOnError(retRes843098)
                        
            response = (<-this.PrivateGetBalances(extendedRequest))
                        PanicOnError(response)
                    } else {
                        panic(e)
                    }
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                            
            response = (<-this.PrivateGetBalances(extendedRequest))
                    PanicOnError(response)
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api-docs-v3.idex.io/#get-fills
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *idex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes796854 := (<-this.LoadMarkets())
            PanicOnError(retRes796854)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "nonce": this.Uuidv1(),
                "wallet": this.WalletAddress,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            // [
            //   {
            //     "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //     "price": "0.09905990",
            //     "quantity": "0.40000000",
            //     "quoteQuantity": "0.03962396",
            //     "time": 1598873478762,
            //     "makerSide": "sell",
            //     "sequence": 5053,
            //     "market": "DIL-ETH",
            //     "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //     "side": "buy",
            //     "fee": "0.00080000",
            //     "feeAsset": "DIL",
            //     "gas": "0.00857497",
            //     "liquidity": "taker",
            //     "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
            //     "txStatus": "mined"
            //   }
            // ]
            var extendedRequest interface{} = this.Extend(request, params)
            if IsTrue(IsEqual(GetValue(extendedRequest, "wallet"), nil)) {
                panic(BadRequest(Add(this.Id, " fetchMyTrades() walletAddress is undefined, set this.walletAddress or \"address\" in params")))
            }
            var response interface{} = nil
            
            {		ret__ := func(this *idex) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *idex) interface{} {
            					// catch block:
                                        if IsTrue(IsInstance(e, InvalidAddress)) {
                        var walletAddress interface{} = GetValue(extendedRequest, "wallet")
            
                        retRes677934 := (<-this.AssociateWallet(walletAddress))
                        PanicOnError(retRes677934)
                        
            response = (<-this.PrivateGetFills(extendedRequest))
                        PanicOnError(response)
                    } else {
                        panic(e)
                    }
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                            
            response = (<-this.PrivateGetFills(extendedRequest))
                    PanicOnError(response)
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api-docs-v3.idex.io/#get-orders
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
                retRes961348 :=  (<-this.FetchOrdersHelper(symbol, nil, nil, this.Extend(request, params)))
                PanicOnError(retRes961348)
                ch <- retRes961348
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api-docs-v3.idex.io/#get-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "closed": false,
            }
        
                retRes879878 :=  (<-this.FetchOrdersHelper(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes879878)
                ch <- retRes879878
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://api-docs-v3.idex.io/#get-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "closed": true,
            }
        
                retRes32529 :=  (<-this.FetchOrdersHelper(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes32529)
                ch <- retRes32529
                return nil
        
            }()
            return ch
        }
func  (this *idex) FetchOrdersHelper(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes882793 := (<-this.LoadMarkets())
            PanicOnError(retRes882793)
            var request interface{} = map[string]interface{} {
                "nonce": this.Uuidv1(),
                "wallet": this.WalletAddress,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            // fetchClosedOrders / fetchOpenOrders
            // [
            //   {
            //     "market": "DIL-ETH",
            //     "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //     "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //     "time": 1598873478650,
            //     "status": "filled",
            //     "type": "limit",
            //     "side": "buy",
            //     "originalQuantity": "0.40000000",
            //     "executedQuantity": "0.40000000",
            //     "cumulativeQuoteQuantity": "0.03962396",
            //     "avgExecutionPrice": "0.09905990",
            //     "price": "1.00000000",
            //     "fills": [
            //       {
            //         "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //         "price": "0.09905990",
            //         "quantity": "0.40000000",
            //         "quoteQuantity": "0.03962396",
            //         "time": 1598873478650,
            //         "makerSide": "sell",
            //         "sequence": 5053,
            //         "fee": "0.00080000",
            //         "feeAsset": "DIL",
            //         "gas": "0.00857497",
            //         "liquidity": "taker",
            //         "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
            //         "txStatus": "mined"
            //       }
            //     ]
            //   }
            // ]
            // fetchOrder
            // { market: "DIL-ETH",
            //   "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //   "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //   "time": 1598873478650,
            //   "status": "filled",
            //   "type": "limit",
            //   "side": "buy",
            //   "originalQuantity": "0.40000000",
            //   "executedQuantity": "0.40000000",
            //   "cumulativeQuoteQuantity": "0.03962396",
            //   "avgExecutionPrice": "0.09905990",
            //   "price": "1.00000000",
            //   "fills":
            //    [ { fillId: "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //        "price": "0.09905990",
            //        "quantity": "0.40000000",
            //        "quoteQuantity": "0.03962396",
            //        "time": 1598873478650,
            //        "makerSide": "sell",
            //        "sequence": 5053,
            //        "fee": "0.00080000",
            //        "feeAsset": "DIL",
            //        "gas": "0.00857497",
            //        "liquidity": "taker",
            //        "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
            //        "txStatus": "mined" } ] }
            if IsTrue(IsArray(response)) {
        
                ch <- this.ParseOrders(response, market, since, limit)
                return nil
            } else {
        
                ch <- this.ParseOrder(response, market)
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *idex) ParseOrderStatus(status interface{}) interface{}  {
    // https://docs.idex.io/#order-states-amp-lifecycle
    var statuses interface{} = map[string]interface{} {
        "active": "open",
        "partiallyFilled": "open",
        "rejected": "canceled",
        "filled": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *idex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "DIL-ETH",
    //         "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
    //         "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
    //         "time": 1598873478650,
    //         "status": "filled",
    //         "type": "limit",
    //         "side": "buy",
    //         "originalQuantity": "0.40000000",
    //         "executedQuantity": "0.40000000",
    //         "cumulativeQuoteQuantity": "0.03962396",
    //         "avgExecutionPrice": "0.09905990",
    //         "price": "1.00000000",
    //         "fills": [
    //             {
    //             "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
    //             "price": "0.09905990",
    //             "quantity": "0.40000000",
    //             "quoteQuantity": "0.03962396",
    //             "time": 1598873478650,
    //             "makerSide": "sell",
    //             "sequence": 5053,
    //             "fee": "0.00080000",
    //             "feeAsset": "DIL",
    //             "gas": "0.00857497",
    //             "liquidity": "taker",
    //             "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
    //             "txStatus": "mined"
    //             }
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "time")
    var fills interface{} = this.SafeValue(order, "fills", []interface{}{})
    var id interface{} = this.SafeString(order, "orderId")
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var marketId interface{} = this.SafeString(order, "market")
    var side interface{} = this.SafeString(order, "side")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var typeVar interface{} = this.SafeString(order, "type")
    var amount interface{} = this.SafeString(order, "originalQuantity")
    var filled interface{} = this.SafeString(order, "executedQuantity")
    var average interface{} = this.SafeString(order, "avgExecutionPrice")
    var price interface{} = this.SafeString(order, "price")
    var rawStatus interface{} = this.SafeString(order, "status")
    var timeInForce interface{} = this.SafeStringUpper(order, "timeInForce")
    var status interface{} = this.ParseOrderStatus(rawStatus)
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": average,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": fills,
    }, market)
}
func  (this *idex) AssociateWallet(walletAddress interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var nonce interface{} = this.Uuidv1()
            var noPrefix interface{} = this.Remove0xPrefix(walletAddress)
            var byteArray interface{} = []interface{}{this.Base16ToBinary(nonce), this.Base16ToBinary(noPrefix)}
            var binary interface{} = this.BinaryConcatArray(byteArray)
            var hash interface{} = this.Hash(binary, keccak, "hex")
            var signature interface{} = this.SignMessageString(hash, this.PrivateKey)
            // {
            //   "address": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //   "totalPortfolioValueUsd": "0.00",
            //   "time": 1598468353626
            // }
            var request interface{} = map[string]interface{} {
                "parameters": map[string]interface{} {
                    "nonce": nonce,
                    "wallet": walletAddress,
                },
                "signature": signature,
            }
        
            result:= (<-this.PrivatePostWallets(request))
            PanicOnError(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#createOrder
 * @description create a trade order, https://docs.idex.io/#create-order
 * @see https://api-docs-v3.idex.io/#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes345552 := (<-this.LoadMarkets())
            PanicOnError(retRes345552)
            var testOrder interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var market interface{} = this.Market(symbol)
            var nonce interface{} = this.Uuidv1()
            var typeEnum interface{} = nil
            var stopLossTypeEnums interface{} = map[string]interface{} {
                "stopLoss": 3,
                "stopLossLimit": 4,
                "takeProfit": 5,
                "takeProfitLimit": 6,
            }
            var triggerPrice interface{} = this.SafeString(params, "triggerPrice", "stopPrice")
            var triggerPriceString interface{} = nil
            if IsTrue(IsTrue((IsEqual(typeVar, "stopLossLimit"))) || IsTrue((IsEqual(typeVar, "takeProfitLimit")))) {
                if IsTrue(IsEqual(triggerPrice, nil)) {
                    panic(BadRequest(Add(Add(Add(this.Id, " createOrder() triggerPrice is a required parameter for "), typeVar), "orders")))
                }
                triggerPriceString = this.PriceToPrecision(symbol, triggerPrice)
            }
            var limitTypeEnums interface{} = map[string]interface{} {
                "limit": 1,
                "limitMaker": 2,
            }
            var priceString interface{} = nil
            var typeLower interface{} = ToLower(typeVar)
            var limitOrder interface{} = IsGreaterThanOrEqual(GetIndexOf(typeLower, "limit"), 0)
            if IsTrue(InOp(limitTypeEnums, typeVar)) {
                typeEnum = GetValue(limitTypeEnums, typeVar)
                priceString = this.PriceToPrecision(symbol, price)
            } else if IsTrue(InOp(stopLossTypeEnums, typeVar)) {
                typeEnum = GetValue(stopLossTypeEnums, typeVar)
                priceString = this.PriceToPrecision(symbol, price)
            } else if IsTrue(IsEqual(typeVar, "market")) {
                typeEnum = 0
            } else {
                panic(BadRequest(Add(Add(Add(this.Id, " "), typeVar), " is not a valid order type")))
            }
            var amountEnum interface{} = 0 // base quantity
            if IsTrue(InOp(params, "quoteOrderQuantity")) {
                if IsTrue(!IsEqual(typeVar, "market")) {
                    panic(NotSupported(Add(Add(Add(this.Id, " createOrder() quoteOrderQuantity is not supported for "), typeVar), " orders, only supported for market orders")))
                }
                amountEnum = 1
                amount = this.SafeNumber(params, "quoteOrderQuantity")
            }
            var sideEnum interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), 0, 1)
            var walletBytes interface{} = this.Remove0xPrefix(this.WalletAddress)
            var network interface{} = this.SafeString(this.Options, "network", "ETH")
            var orderVersion interface{} = this.GetSupportedMapping(network, map[string]interface{} {
                "ETH": 1,
                "BSC": 2,
                "MATIC": 4,
            })
            var amountString interface{} = this.AmountToPrecision(symbol, amount)
            // https://docs.idex.io/#time-in-force
            var timeInForceEnums interface{} = map[string]interface{} {
                "gtc": 0,
                "ioc": 2,
                "fok": 3,
            }
            var defaultTimeInForce interface{} = this.SafeString(this.Options, "defaultTimeInForce", "gtc")
            var timeInForce interface{} = this.SafeString(params, "timeInForce", defaultTimeInForce)
            var timeInForceEnum interface{} = nil
            if IsTrue(InOp(timeInForceEnums, timeInForce)) {
                timeInForceEnum = GetValue(timeInForceEnums, timeInForce)
            } else {
                var allOptions interface{} = ObjectKeys(timeInForceEnums)
                var asString interface{} = Join(allOptions, ", ")
                panic(BadRequest(Add(Add(Add(Add(this.Id, " "), timeInForce), " is not a valid timeInForce, please choose one of "), asString)))
            }
            // https://docs.idex.io/#self-trade-prevention
            var selfTradePreventionEnums interface{} = map[string]interface{} {
                "dc": 0,
                "co": 1,
                "cn": 2,
                "cb": 3,
            }
            var defaultSelfTradePrevention interface{} = this.SafeString(this.Options, "defaultSelfTradePrevention", "cn")
            var selfTradePrevention interface{} = this.SafeString(params, "selfTradePrevention", defaultSelfTradePrevention)
            var selfTradePreventionEnum interface{} = nil
            if IsTrue(InOp(selfTradePreventionEnums, selfTradePrevention)) {
                selfTradePreventionEnum = GetValue(selfTradePreventionEnums, selfTradePrevention)
            } else {
                var allOptions interface{} = ObjectKeys(selfTradePreventionEnums)
                var asString interface{} = Join(allOptions, ", ")
                panic(BadRequest(Add(Add(Add(Add(this.Id, " "), selfTradePrevention), " is not a valid selfTradePrevention, please choose one of "), asString)))
            }
            var byteArray interface{} = []interface{}{this.NumberToBE(orderVersion, 1), this.Base16ToBinary(nonce), this.Base16ToBinary(walletBytes), this.Encode(GetValue(market, "id")), this.NumberToBE(typeEnum, 1), this.NumberToBE(sideEnum, 1), this.Encode(amountString), this.NumberToBE(amountEnum, 1)}
            if IsTrue(limitOrder) {
                var encodedPrice interface{} = this.Encode(priceString)
                AppendToArray(&byteArray,encodedPrice)
            }
            if IsTrue(InOp(stopLossTypeEnums, typeVar)) {
                var encodedPrice interface{} = this.Encode(IsTrue(triggerPriceString) || IsTrue(priceString))
                AppendToArray(&byteArray,encodedPrice)
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AppendToArray(&byteArray,this.Encode(clientOrderId))
            }
            var after interface{} = []interface{}{this.NumberToBE(timeInForceEnum, 1), this.NumberToBE(selfTradePreventionEnum, 1), this.NumberToBE(0, 8)}
            var allBytes interface{} = this.ArrayConcat(byteArray, after)
            var binary interface{} = this.BinaryConcatArray(allBytes)
            var hash interface{} = this.Hash(binary, keccak, "hex")
            var signature interface{} = this.SignMessageString(hash, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "parameters": map[string]interface{} {
                    "nonce": nonce,
                    "market": GetValue(market, "id"),
                    "side": side,
                    "type": typeVar,
                    "wallet": this.WalletAddress,
                    "selfTradePrevention": selfTradePrevention,
                },
                "signature": signature,
            }
            if IsTrue(!IsEqual(typeVar, "market")) {
                AddElementToObject(GetValue(request, "parameters"), "timeInForce", timeInForce)
            }
            if IsTrue(limitOrder) {
                AddElementToObject(GetValue(request, "parameters"), "price", priceString)
            }
            if IsTrue(InOp(stopLossTypeEnums, typeVar)) {
                AddElementToObject(GetValue(request, "parameters"), "stopPrice", IsTrue(triggerPriceString) || IsTrue(priceString))
            }
            if IsTrue(IsEqual(amountEnum, 0)) {
                AddElementToObject(GetValue(request, "parameters"), "quantity", amountString)
            } else {
                AddElementToObject(GetValue(request, "parameters"), "quoteOrderQuantity", amountString)
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(GetValue(request, "parameters"), "clientOrderId", clientOrderId)
            }
            // {
            //   "market": "DIL-ETH",
            //   "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //   "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //   "time": 1598873478650,
            //   "status": "filled",
            //   "type": "limit",
            //   "side": "buy",
            //   "originalQuantity": "0.40000000",
            //   "executedQuantity": "0.40000000",
            //   "cumulativeQuoteQuantity": "0.03962396",
            //   "price": "1.00000000",
            //   "fills": [
            //     {
            //       "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //       "price": "0.09905990",
            //       "quantity": "0.40000000",
            //       "quoteQuantity": "0.03962396",
            //       "time": 1598873478650,
            //       "makerSide": "sell",
            //       "sequence": 5053,
            //       "fee": "0.00080000",
            //       "feeAsset": "DIL",
            //       "gas": "0.00857497",
            //       "liquidity": "taker",
            //       "txStatus": "pending"
            //     }
            //   ],
            //   "avgExecutionPrice": "0.09905990"
            // }
            // we don't use extend here because it is a signed endpoint
            var response interface{} = nil
            if IsTrue(testOrder) {
                
        response = (<-this.PrivatePostOrdersTest(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrders(request))
                PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#withdraw
 * @description make a withdrawal
 * @see https://api-docs-v3.idex.io/#withdraw-funds
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *idex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckRequiredCredentials()
        
            retRes531005 := (<-this.LoadMarkets())
            PanicOnError(retRes531005)
            var nonce interface{} = this.Uuidv1()
            var amountString interface{} = this.CurrencyToPrecision(code, amount)
            var currency interface{} = this.Currency(code)
            var walletBytes interface{} = this.Remove0xPrefix(this.WalletAddress)
            var byteArray interface{} = []interface{}{this.Base16ToBinary(nonce), this.Base16ToBinary(walletBytes), this.Encode(GetValue(currency, "id")), this.Encode(amountString), this.NumberToBE(1, 1)}
            var binary interface{} = this.BinaryConcatArray(byteArray)
            var hash interface{} = this.Hash(binary, keccak, "hex")
            var signature interface{} = this.SignMessageString(hash, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "parameters": map[string]interface{} {
                    "nonce": nonce,
                    "wallet": address,
                    "asset": GetValue(currency, "id"),
                    "quantity": amountString,
                },
                "signature": signature,
            }
        
            response:= (<-this.PrivatePostWithdrawals(request))
            PanicOnError(response)
        
                //
            //     {
            //         "withdrawalId": "a61dcff0-ec4d-11ea-8b83-c78a6ecb3180",
            //         "asset": "ETH",
            //         "assetContractAddress": "0x0000000000000000000000000000000000000000",
            //         "quantity": "0.20000000",
            //         "time": 1598962883190,
            //         "fee": "0.00024000",
            //         "txStatus": "pending",
            //         "txId": null
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#cancelAllOrders
 * @description cancel all open orders
 * @see https://api-docs-v3.idex.io/#cancel-order
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes586902 := (<-this.LoadMarkets())
            PanicOnError(retRes586902)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var nonce interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "parameters": map[string]interface{} {
                    "nonce": nonce,
                    "wallet": this.WalletAddress,
                },
            }
            var walletBytes interface{} = this.Remove0xPrefix(this.WalletAddress)
            var byteArray interface{} = []interface{}{this.Base16ToBinary(nonce), this.Base16ToBinary(walletBytes)}
            if IsTrue(!IsEqual(market, nil)) {
                AppendToArray(&byteArray,this.Encode(GetValue(market, "id")))
                AddElementToObject(GetValue(request, "parameters"), "market", GetValue(market, "id"))
            }
            var binary interface{} = this.BinaryConcatArray(byteArray)
            var hash interface{} = this.Hash(binary, keccak, "hex")
            var signature interface{} = this.SignMessageString(hash, this.PrivateKey)
            AddElementToObject(request, "signature", signature)
            // [ { orderId: "688336f0-ec50-11ea-9842-b332f8a34d0e" } ]
        
            response:= (<-this.PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#cancelOrder
 * @description cancels an open order
 * @see https://api-docs-v3.idex.io/#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *idex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
        
            retRes613755 := (<-this.LoadMarkets())
            PanicOnError(retRes613755)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var nonce interface{} = this.Uuidv1()
            var walletBytes interface{} = this.Remove0xPrefix(this.WalletAddress)
            var byteArray interface{} = []interface{}{this.Base16ToBinary(nonce), this.Base16ToBinary(walletBytes), this.Encode(id)}
            var binary interface{} = this.BinaryConcatArray(byteArray)
            var hash interface{} = this.Hash(binary, keccak, "hex")
            var signature interface{} = this.SignMessageString(hash, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "parameters": map[string]interface{} {
                    "nonce": nonce,
                    "wallet": this.WalletAddress,
                    "orderId": id,
                },
                "signature": signature,
            }
            // [ { orderId: "688336f0-ec50-11ea-9842-b332f8a34d0e" } ]
        
            response:= (<-this.PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
            var canceledOrder interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseOrder(canceledOrder, market)
            return nil
        
            }()
            return ch
        }
func  (this *idex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(!IsEqual(errorCode, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, message)
        panic(ExchangeError(Add(Add(this.Id, " "), message)))
    }
    return nil
}
/**
 * @method
 * @name idex#fetchDeposit
 * @description fetch information on a deposit
 * @see https://api-docs-v3.idex.io/#get-deposits
 * @param {string} id deposit id
 * @param {string} code not used by idex fetchDeposit ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *idex) FetchDeposit(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes120720 := (<-this.LoadMarkets())
            PanicOnError(retRes120720)
            var nonce interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "nonce": nonce,
                "wallet": this.WalletAddress,
                "depositId": id,
            }
        
            response:= (<-this.PrivateGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransaction(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://api-docs-v3.idex.io/#get-deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *idex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            params = this.Extend(map[string]interface{} {
                "method": "privateGetDeposits",
            }, params)
        
                retRes415285 :=  (<-this.FetchTransactionsHelper(code, since, limit, params))
                PanicOnError(retRes415285)
                ch <- retRes415285
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://api-docs-v3.idex.io/#get-ping
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *idex) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetPing(params))
            PanicOnError(response)
        
            ch <- map[string]interface{} {
                "status": "ok",
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api-docs-v3.idex.io/#get-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *idex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //    { serverTime: "1655258263236" }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchWithdrawal
 * @description fetch data on a currency withdrawal via the withdrawal id
 * @see https://api-docs-v3.idex.io/#get-withdrawals
 * @param {string} id withdrawal id
 * @param {string} code not used by idex.fetchWithdrawal
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *idex) FetchWithdrawal(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes508831 := (<-this.LoadMarkets())
            PanicOnError(retRes508831)
            var nonce interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "nonce": nonce,
                "wallet": this.WalletAddress,
                "withdrawalId": id,
            }
        
            response:= (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransaction(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name idex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://api-docs-v3.idex.io/#get-withdrawals
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *idex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            params = this.Extend(map[string]interface{} {
                "method": "privateGetWithdrawals",
            }, params)
        
                retRes839350 :=  (<-this.FetchTransactionsHelper(code, since, limit, params))
                PanicOnError(retRes839350)
                ch <- retRes839350
                return nil
        
            }()
            return ch
        }
func  (this *idex) FetchTransactionsHelper(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes457622 := (<-this.LoadMarkets())
            PanicOnError(retRes457622)
            var nonce interface{} = this.Uuidv1()
            var request interface{} = map[string]interface{} {
                "nonce": nonce,
                "wallet": this.WalletAddress,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "asset", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            // [
            //   {
            //     "depositId": "e9970cc0-eb6b-11ea-9e89-09a5ebc1f98e",
            //     "asset": "ETH",
            //     "quantity": "1.00000000",
            //     "txId": "0xcd4aac3171d7131cc9e795568c67938675185ac17641553ef54c8a7c294c8142",
            //     "txTime": 1598865853000,
            //     "confirmationTime": 1598865930231
            //   }
            // ]
            var method interface{} = GetValue(params, "method")
            params = this.Omit(params, "method")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "privateGetDeposits")) {
                
        response = (<-this.PrivateGetDeposits(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "privateGetWithdrawals")) {
                
        response = (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchTransactionsHelper() not support this method")))
            }
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "mined": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *idex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "depositId": "e9970cc0-eb6b-11ea-9e89-09a5ebc1f98f",
    //         "asset": "ETH",
    //         "quantity": "1.00000000",
    //         "txId": "0xcd4aac3171d7131cc9e795568c67938675185ac17641553ef54c8a7c294c8142",
    //         "txTime": 1598865853000,
    //         "confirmationTime": 1598865930231
    //     }
    //
    // fetchWithdrwalas
    //
    //     {
    //         "withdrawalId": "a62d8760-ec4d-11ea-9fa6-47904c19499b",
    //         "asset": "ETH",
    //         "assetContractAddress": "0x0000000000000000000000000000000000000000",
    //         "quantity": "0.20000000",
    //         "time": 1598962883288,
    //         "fee": "0.00024000",
    //         "txId": "0x305e9cdbaa85ad029f50578d13d31d777c085de573ed5334d95c19116d8c03ce",
    //         "txStatus": "mined"
    //     }
    //
    // withdraw
    //
    //     {
    //         "withdrawalId": "a61dcff0-ec4d-11ea-8b83-c78a6ecb3180",
    //         "asset": "ETH",
    //         "assetContractAddress": "0x0000000000000000000000000000000000000000",
    //         "quantity": "0.20000000",
    //         "time": 1598962883190,
    //         "fee": "0.00024000",
    //         "txStatus": "pending",
    //         "txId": null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var typeVar interface{} = nil
    if IsTrue(InOp(transaction, "depositId")) {
        typeVar = "deposit"
    } else if IsTrue(IsTrue((InOp(transaction, "withdrawId"))) || IsTrue((InOp(transaction, "withdrawalId")))) {
        typeVar = "withdrawal"
    }
    var id interface{} = this.SafeString2(transaction, "depositId", "withdrawId")
    id = this.SafeString(transaction, "withdrawalId", id)
    var code interface{} = this.SafeCurrencyCode(this.SafeString(transaction, "asset"), currency)
    var amount interface{} = this.SafeNumber(transaction, "quantity")
    var txid interface{} = this.SafeString(transaction, "txId")
    var timestamp interface{} = this.SafeInteger2(transaction, "txTime", "time")
    var fee interface{} = nil
    if IsTrue(InOp(transaction, "fee")) {
        fee = map[string]interface{} {
            "cost": this.SafeNumber(transaction, "fee"),
            "currency": "ETH",
        }
    }
    var rawStatus interface{} = this.SafeString(transaction, "txStatus")
    var status interface{} = this.ParseTransactionStatus(rawStatus)
    var updated interface{} = this.SafeInteger(transaction, "confirmationTime")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": nil,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": updated,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
func  (this *idex) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = config
    var hasApiKey interface{} =     (!IsEqual(this.ApiKey, nil))
    var hasSecret interface{} =     (!IsEqual(this.Secret, nil))
    var hasWalletAddress interface{} =     (!IsEqual(this.WalletAddress, nil))
    var hasPrivateKey interface{} =     (!IsEqual(this.PrivateKey, nil))
    var defaultCost interface{} = this.SafeValue(config, "cost", 1)
    var authenticated interface{} = IsTrue(IsTrue(IsTrue(hasApiKey) && IsTrue(hasSecret)) && IsTrue(hasWalletAddress)) && IsTrue(hasPrivateKey)
    return Ternary(IsTrue(authenticated), (Divide(defaultCost, 2)), defaultCost)
}
/**
 * @method
 * @name idex#fetchDepositAddress
 * @description fetch the Polygon address of the wallet
 * @see https://api-docs-v3.idex.io/#get-wallets
 * @param {string} code not used by idex
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *idex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
            AddElementToObject(request, "nonce", this.Uuidv1())
        
            response:= (<-this.PrivateGetWallets(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            address: "0x37A1827CA64C94A26028bDCb43FBDCB0bf6DAf5B",
            //            totalPortfolioValueUsd: "0.00",
            //            time: "1678342148086"
            //        },
            //        {
            //            address: "0x0Ef3456E616552238B0c562d409507Ed6051A7b3",
            //            totalPortfolioValueUsd: "15.90",
            //            time: "1691697811659"
            //        }
            //    ]
            //
        ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
func  (this *idex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [
    //        {
    //            address: "0x37A1827CA64C94A26028bDCb43FBDCB0bf6DAf5B",
    //            totalPortfolioValueUsd: "0.00",
    //            time: "1678342148086"
    //        },
    //        {
    //            address: "0x0Ef3456E616552238B0c562d409507Ed6051A7b3",
    //            totalPortfolioValueUsd: "15.90",
    //            time: "1691697811659"
    //        }
    //    ]
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var length interface{} =     GetArrayLength(depositAddress)
    var entry interface{} = this.SafeDict(depositAddress, Subtract(length, 1))
    var address interface{} = this.SafeString(entry, "address")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": nil,
        "network": "MATIC",
        "address": address,
        "tag": nil,
    }
}
func  (this *idex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var network interface{} = this.SafeString(this.Options, "network", "ETH")
    var version interface{} = this.SafeString(this.Options, "version", "v1")
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), network), "/"), version), "/"), path)
    var keys interface{} = ObjectKeys(params)
    var length interface{} =     GetArrayLength(keys)
    var query interface{} = nil
    if IsTrue(IsGreaterThan(length, 0)) {
        if IsTrue(IsEqual(method, "GET")) {
            query = this.Urlencode(params)
            url = Add(Add(url, "?"), query)
        } else {
            body = this.Json(params)
        }
    }
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    if IsTrue(!IsEqual(this.ApiKey, nil)) {
        AddElementToObject(headers, "IDEX-API-Key", this.ApiKey)
    }
    if IsTrue(IsEqual(api, "private")) {
        var payload interface{} = nil
        if IsTrue(IsEqual(method, "GET")) {
            payload = query
        } else {
            payload = body
        }
        AddElementToObject(headers, "IDEX-HMAC-Signature", this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "hex"))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *idex) Remove0xPrefix(hexData interface{}) interface{}  {
    if IsTrue(IsEqual(Slice(hexData, 0, 2), "0x")) {
        return Slice(hexData, 2, nil)
    } else {
        return hexData
    }
}
func  (this *idex) HashMessage(message interface{}) interface{}  {
    // takes a hex encoded message
    var binaryMessage interface{} = this.Base16ToBinary(this.Remove0xPrefix(message))
    var prefix interface{} = this.Encode(Add("Ethereum Signed Message:\n", GetValue(binaryMessage, "byteLength")))
    return Add("0x", this.Hash(this.BinaryConcat(prefix, binaryMessage), keccak, "hex"))
}
func  (this *idex) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    return map[string]interface{} {
        "r": Add("0x", GetValue(signature, "r")),
        "s": Add("0x", GetValue(signature, "s")),
        "v": Add(27, GetValue(signature, "v")),
    }
}
func  (this *idex) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func  (this *idex) SignMessageString(message interface{}, privateKey interface{}) interface{}  {
    // still takes the input as a hex string
    // same as above but returns a string instead of an object
    var signature interface{} = this.SignMessage(message, privateKey)
    return Add(Add(GetValue(signature, "r"), this.Remove0xPrefix(GetValue(signature, "s"))), this.BinaryToBase16(this.NumberToBE(GetValue(signature, "v"), 1)))
}


func (this *idex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
