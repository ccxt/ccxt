package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type hollaex struct {
    Exchange

}

func NewHollaexCore() hollaex {
   p := hollaex{}
   setDefaults(&p)
   return p
}

func  (this *hollaex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "hollaex",
        "name": "HollaEx",
        "countries": []interface{}{"KR"},
        "rateLimit": 250,
        "version": "v2",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createLimitBuyOrder": true,
            "createLimitSellOrder": true,
            "createMarketBuyOrder": true,
            "createMarketSellOrder": true,
            "createOrder": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": "emulated",
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "1h": "1h",
            "4h": "4h",
            "1d": "1d",
            "1w": "1w",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg",
            "test": map[string]interface{} {
                "rest": "https://api.sandbox.hollaex.com",
            },
            "api": map[string]interface{} {
                "rest": "https://api.hollaex.com",
            },
            "www": "https://hollaex.com",
            "doc": "https://apidocs.hollaex.com",
            "referral": "https://pro.hollaex.com/signup?affiliation_code=QSWA6G",
        },
        "precisionMode": TICK_SIZE,
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "health": 1,
                    "constants": 1,
                    "kit": 1,
                    "tiers": 1,
                    "ticker": 1,
                    "tickers": 1,
                    "orderbook": 1,
                    "orderbooks": 1,
                    "trades": 1,
                    "chart": 1,
                    "charts": 1,
                    "minicharts": 1,
                    "oracle/prices": 1,
                    "quick-trade": 1,
                    "udf/config": 1,
                    "udf/history": 1,
                    "udf/symbols": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "user": 1,
                    "user/balance": 1,
                    "user/deposits": 1,
                    "user/withdrawals": 1,
                    "user/withdrawal/fee": 1,
                    "user/trades": 1,
                    "orders": 1,
                    "order": 1,
                },
                "post": map[string]interface{} {
                    "user/withdrawal": 1,
                    "order": 1,
                },
                "delete": map[string]interface{} {
                    "order/all": 1,
                    "order": 1,
                },
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": 0.001,
                "maker": 0.001,
            },
        },
        "exceptions": map[string]interface{} {
            "broad": map[string]interface{} {
                "Invalid token": AuthenticationError,
                "Order not found": OrderNotFound,
                "Insufficient balance": InsufficientFunds,
                "Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order.": OrderImmediatelyFillable,
            },
            "exact": map[string]interface{} {
                "400": BadRequest,
                "403": AuthenticationError,
                "404": BadRequest,
                "405": BadRequest,
                "410": BadRequest,
                "429": BadRequest,
                "500": NetworkError,
                "503": NetworkError,
            },
        },
        "options": map[string]interface{} {
            "api-expires": this.ParseToInt(Divide(this.Timeout, 1000)),
            "networks": map[string]interface{} {
                "BTC": "btc",
                "ETH": "eth",
                "ERC20": "eth",
                "TRX": "trx",
                "TRC20": "trx",
                "XRP": "xrp",
                "XLM": "xlm",
                "BNB": "bnb",
                "MATIC": "matic",
            },
        },
    })
}
/**
 * @method
 * @name hollaex#fetchMarkets
 * @description retrieves data on all markets for hollaex
 * @see https://apidocs.hollaex.com/#constants
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *hollaex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetConstants(params))
            PanicOnError(response)
            //
            //     {
            //         "coins": {
            //             "xmr": {
            //                 "id": 7,
            //                 "fullname": "Monero",
            //                 "symbol": "xmr",
            //                 "active": true,
            //                 "allow_deposit": true,
            //                 "allow_withdrawal": true,
            //                 "withdrawal_fee": 0.02,
            //                 "min": 0.001,
            //                 "max": 100000,
            //                 "increment_unit": 0.001,
            //                 "deposit_limits": { '1': 0, '2': 0, '3': 0, '4': 0, "5": 0, "6": 0 },
            //                 "withdrawal_limits": { '1': 10, '2': 15, '3': 100, '4': 100, '5': 200, '6': 300, '7': 350, '8': 400, "9": 500, "10": -1 },
            //                 "created_at": "2019-12-09T07:14:02.720Z",
            //                 "updated_at": "2020-01-16T12:12:53.162Z"
            //             },
            //             // ...
            //         },
            //         "pairs": {
            //             "btc-usdt": {
            //                 "id": 2,
            //                 "name": "btc-usdt",
            //                 "pair_base": "btc",
            //                 "pair_2": "usdt",
            //                 "taker_fees": { '1': 0.3, '2': 0.25, '3': 0.2, '4': 0.18, '5': 0.1, '6': 0.09, '7': 0.08, '8': 0.06, "9": 0.04, "10": 0 },
            //                 "maker_fees": { '1': 0.1, '2': 0.08, '3': 0.05, '4': 0.03, '5': 0, '6': 0, '7': 0, '8': 0, "9": 0, "10": 0 },
            //                 "min_size": 0.0001,
            //                 "max_size": 1000,
            //                 "min_price": 100,
            //                 "max_price": 100000,
            //                 "increment_size": 0.0001,
            //                 "increment_price": 0.05,
            //                 "active": true,
            //                 "created_at": "2019-12-09T07:15:54.537Z",
            //                 "updated_at": "2019-12-09T07:15:54.537Z"
            //             },
            //         },
            //         "config": { tiers: 10 },
            //         "status": true
            //     }
            //
            var pairs interface{} = this.SafeValue(response, "pairs", map[string]interface{} {})
            var keys interface{} = ObjectKeys(pairs)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var key interface{} = GetValue(keys, i)
                var market interface{} = GetValue(pairs, key)
                var baseId interface{} = this.SafeString(market, "pair_base")
                var quoteId interface{} = this.SafeString(market, "pair_2")
                var base interface{} = this.CommonCurrencyCode(ToUpper(baseId))
                var quote interface{} = this.CommonCurrencyCode(ToUpper(quoteId))
                AppendToArray(&result,map[string]interface{} {
                    "id": this.SafeString(market, "name"),
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": this.SafeValue(market, "active"),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "increment_size"),
                        "price": this.SafeNumber(market, "increment_price"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_size"),
                            "max": this.SafeNumber(market, "max_size"),
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_price"),
                            "max": this.SafeNumber(market, "max_price"),
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": this.Parse8601(this.SafeString(market, "created_at")),
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://apidocs.hollaex.com/#constants
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *hollaex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetConstants(params))
            PanicOnError(response)
            //
            //     {
            //         "coins":{
            //             "bch":{
            //                 "id":4,
            //                 "fullname":"Bitcoin Cash",
            //                 "symbol":"bch",
            //                 "active":true,
            //                 "verified":true,
            //                 "allow_deposit":true,
            //                 "allow_withdrawal":true,
            //                 "withdrawal_fee":0.0002,
            //                 "min":0.001,
            //                 "max":100000,
            //                 "increment_unit":0.001,
            //                 "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
            //                 "code":"bch",
            //                 "is_public":true,
            //                 "meta":{},
            //                 "estimated_price":null,
            //                 "description":null,
            //                 "type":"blockchain",
            //                 "network":null,
            //                 "standard":null,
            //                 "issuer":"HollaEx",
            //                 "withdrawal_fees":null,
            //                 "created_at":"2019-08-09T10:45:43.367Z",
            //                 "updated_at":"2021-12-13T03:08:32.372Z",
            //                 "created_by":1,
            //                 "owner_id":1
            //             },
            //         },
            //         "network":"https://api.hollaex.network"
            //     }
            //
            var coins interface{} = this.SafeValue(response, "coins", map[string]interface{} {})
            var keys interface{} = ObjectKeys(coins)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var key interface{} = GetValue(keys, i)
                var currency interface{} = GetValue(coins, key)
                var id interface{} = this.SafeString(currency, "symbol")
                var numericId interface{} = this.SafeInteger(currency, "id")
                var code interface{} = this.SafeCurrencyCode(id)
                var name interface{} = this.SafeString(currency, "fullname")
                var depositEnabled interface{} = this.SafeValue(currency, "allow_deposit")
                var withdrawEnabled interface{} = this.SafeValue(currency, "allow_withdrawal")
                var isActive interface{} = this.SafeValue(currency, "active")
                var active interface{} = IsTrue(IsTrue(isActive) && IsTrue(depositEnabled)) && IsTrue(withdrawEnabled)
                var fee interface{} = this.SafeNumber(currency, "withdrawal_fee")
                var withdrawalLimits interface{} = this.SafeValue(currency, "withdrawal_limits", []interface{}{})
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "numericId": numericId,
            "code": code,
            "info": currency,
            "name": name,
            "active": active,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "fee": fee,
            "precision": this.SafeNumber(currency, "increment_unit"),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": this.SafeNumber(currency, "min"),
                    "max": this.SafeNumber(currency, "max"),
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": this.SafeValue(withdrawalLimits, 0),
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOrderBooks
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
 * @see https://apidocs.hollaex.com/#orderbooks
 * @param {string[]|undefined} symbols not used by hollaex fetchOrderBooks ()
 * @param {int} [limit] not used by hollaex fetchOrderBooks ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
 */
func  (this *hollaex) FetchOrderBooks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes5088 := (<-this.LoadMarkets())
            PanicOnError(retRes5088)
        
            response:= (<-this.PublicGetOrderbooks(params))
            PanicOnError(response)
            var result interface{} = map[string]interface{} {}
            var marketIds interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var orderbook interface{} = GetValue(response, marketId)
                var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
                var timestamp interface{} = this.Parse8601(this.SafeString(orderbook, "timestamp"))
                AddElementToObject(result, symbol, this.ParseOrderBook(GetValue(response, marketId), symbol, timestamp))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apidocs.hollaex.com/#orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *hollaex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5338 := (<-this.LoadMarkets())
            PanicOnError(retRes5338)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "btc-usdt": {
            //             "bids": [
            //                 [ 8836.4, 1.022 ],
            //                 [ 8800, 0.0668 ],
            //                 [ 8797.75, 0.2398 ],
            //             ],
            //             "asks": [
            //                 [ 8839.35, 1.5334 ],
            //                 [ 8852.6, 0.0579 ],
            //                 [ 8860.45, 0.1815 ],
            //             ],
            //             "timestamp": "2020-03-03T02:27:25.147Z"
            //         },
            //         "eth-usdt": {},
            //         // ...
            //     }
            //
            var orderbook interface{} = this.SafeValue(response, GetValue(market, "id"))
            var timestamp interface{} = this.Parse8601(this.SafeString(orderbook, "timestamp"))
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidocs.hollaex.com/#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hollaex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5738 := (<-this.LoadMarkets())
            PanicOnError(retRes5738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "open": 8615.55,
            //         "close": 8841.05,
            //         "high": 8921.1,
            //         "low": 8607,
            //         "last": 8841.05,
            //         "volume": 20.2802,
            //         "timestamp": "2020-03-03T03:11:18.964Z"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://apidocs.hollaex.com/#tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hollaex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6038 := (<-this.LoadMarkets())
            PanicOnError(retRes6038)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
        
                //
            //     {
            //         "bch-usdt": {
            //             "time": "2020-03-02T04:29:45.011Z",
            //             "open": 341.65,
            //             "close":337.9,
            //             "high":341.65,
            //             "low":337.3,
            //             "last":337.9,
            //             "volume":0.054,
            //             "symbol":"bch-usdt"
            //         },
            //         // ...
            //     }
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseTickers(tickers interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var result interface{} = map[string]interface{} {}
    var keys interface{} = ObjectKeys(tickers)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        var ticker interface{} = GetValue(tickers, key)
        var marketId interface{} = this.SafeString(ticker, "symbol", key)
        var market interface{} = this.SafeMarket(marketId, nil, "-")
        var symbol interface{} = GetValue(market, "symbol")
        AddElementToObject(result, symbol, this.Extend(this.ParseTicker(ticker, market), params))
    }
    return this.FilterByArrayTickers(result, "symbol", symbols)
}
func  (this *hollaex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "open": 8615.55,
    //         "close": 8841.05,
    //         "high": 8921.1,
    //         "low": 8607,
    //         "last": 8841.05,
    //         "volume": 20.2802,
    //         "timestamp": "2020-03-03T03:11:18.964Z",
    //     }
    //
    // fetchTickers
    //
    //     {
    //         "time": "2020-03-02T04:29:45.011Z",
    //         "open": 341.65,
    //         "close": 337.9,
    //         "high": 341.65,
    //         "low": 337.3,
    //         "last": 337.9,
    //         "volume": 0.054,
    //         "symbol": "bch-usdt"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.Parse8601(this.SafeString2(ticker, "time", "timestamp"))
    var close interface{} = this.SafeString(ticker, "close")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "info": ticker,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": close,
        "last": this.SafeString(ticker, "last", close),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
    }, market)
}
/**
 * @method
 * @name hollaex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidocs.hollaex.com/#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *hollaex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7068 := (<-this.LoadMarkets())
            PanicOnError(retRes7068)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "btc-usdt": [
            //             {
            //                 "size": 0.5,
            //                 "price": 8830,
            //                 "side": "buy",
            //                 "timestamp": "2020-03-03T04:44:33.034Z"
            //             },
            //             // ...
            //         ]
            //     }
            //
            var trades interface{} = this.SafeList(response, GetValue(market, "id"), []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "size": 0.5,
    //         "price": 8830,
    //         "side": "buy",
    //         "timestamp": "2020-03-03T04:44:33.034Z"
    //     }
    //
    // fetchMyTrades (private)
    //  {
    //      "side":"sell",
    //      "symbol":"doge-usdt",
    //      "size":70,
    //      "price":0.147411,
    //      "timestamp":"2022-01-26T17:53:34.650Z",
    //      "order_id":"cba78ecb-4187-4da2-9d2f-c259aa693b5a",
    //      "fee":0.01031877,"fee_coin":"usdt"
    //  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var datetime interface{} = this.SafeString(trade, "timestamp")
    var timestamp interface{} = this.Parse8601(datetime)
    var side interface{} = this.SafeString(trade, "side")
    var orderId interface{} = this.SafeString(trade, "order_id")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "size")
    var feeCostString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": GetValue(market, "quote"),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": nil,
        "timestamp": timestamp,
        "datetime": datetime,
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name hollaex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://apidocs.hollaex.com/#tiers
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *hollaex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7948 := (<-this.LoadMarkets())
            PanicOnError(retRes7948)
        
            response:= (<-this.PublicGetTiers(params))
            PanicOnError(response)
            //
            //     {
            //         "1": {
            //             "id": "1",
            //             "name": "Silver",
            //             "icon": '',
            //             "description": "Your crypto journey starts here! Make your first deposit to start trading, and verify your account to level up!",
            //             "deposit_limit": "0",
            //             "withdrawal_limit": "1000",
            //             "fees": {
            //                 "maker": {
            //                     'eth-btc': "0.1",
            //                     'ada-usdt': "0.1",
            //                     ...
            //                 },
            //                 "taker": {
            //                     'eth-btc': "0.1",
            //                     'ada-usdt': "0.1",
            //                     ...
            //                 }
            //             },
            //             "note": "<ul>\n<li>Login and verify email</li>\n</ul>\n",
            //             "created_at": "2021-03-22T03:51:39.129Z",
            //             "updated_at": "2021-11-01T02:51:56.214Z"
            //         },
            //         ...
            //     }
            //
            var firstTier interface{} = this.SafeValue(response, "1", map[string]interface{} {})
            var fees interface{} = this.SafeValue(firstTier, "fees", map[string]interface{} {})
            var makerFees interface{} = this.SafeValue(fees, "maker", map[string]interface{} {})
            var takerFees interface{} = this.SafeValue(fees, "taker", map[string]interface{} {})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                var market interface{} = this.Market(symbol)
                var makerString interface{} = this.SafeString(makerFees, GetValue(market, "id"))
                var takerString interface{} = this.SafeString(takerFees, GetValue(market, "id"))
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fees,
            "symbol": symbol,
            "maker": this.ParseNumber(Precise.StringDiv(makerString, "100")),
            "taker": this.ParseNumber(Precise.StringDiv(takerString, "100")),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOHLCV
 * @description hollaex has large gaps between candles, so it's recommended to specify since
 * @see https://apidocs.hollaex.com/#chart
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *hollaex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8608 := (<-this.LoadMarkets())
            PanicOnError(retRes8608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var until interface{} = this.SafeInteger(params, "until")
            var end interface{} = this.Seconds()
            if IsTrue(!IsEqual(until, nil)) {
                end = this.ParseToInt(Divide(until, 1000))
            }
            var defaultSpan interface{} = 2592000 // 30 days
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.ParseToInt(Divide(since, 1000)))
            } else {
                AddElementToObject(request, "from", Subtract(end, defaultSpan))
            }
            AddElementToObject(request, "to", end)
            params = this.Omit(params, "until")
        
            response:= (<-this.PublicGetChart(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "time":"2020-03-02T20:00:00.000Z",
            //             "close":8872.1,
            //             "high":8872.1,
            //             "low":8858.6,
            //             "open":8858.6,
            //             "symbol":"btc-usdt",
            //             "volume":1.2922
            //         },
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "time":"2020-03-02T20:00:00.000Z",
    //         "close":8872.1,
    //         "high":8872.1,
    //         "low":8858.6,
    //         "open":8858.6,
    //         "symbol":"btc-usdt",
    //         "volume":1.2922
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "time")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
func  (this *hollaex) ParseBalance(response interface{}) interface{}  {
    var timestamp interface{} = this.Parse8601(this.SafeString(response, "updated_at"))
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var currencyIds interface{} = ObjectKeys(this.Currencies_by_id)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(response, Add(currencyId, "_available")))
        AddElementToObject(account, "total", this.SafeString(response, Add(currencyId, "_balance")))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name hollaex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apidocs.hollaex.com/#get-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *hollaex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9468 := (<-this.LoadMarkets())
            PanicOnError(retRes9468)
        
            response:= (<-this.PrivateGetUserBalance(params))
            PanicOnError(response)
        
                //
            //     {
            //         "updated_at": "2020-03-02T22:27:38.428Z",
            //         "btc_balance": 0,
            //         "btc_pending": 0,
            //         "btc_available": 0,
            //         "eth_balance": 0,
            //         "eth_pending": 0,
            //         "eth_available": 0,
            //         // ...
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOpenOrder
 * @description fetch an open order by it's id
 * @see https://apidocs.hollaex.com/#get-order
 * @param {string} id order id
 * @param {string} symbol not used by hollaex fetchOpenOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9748 := (<-this.LoadMarkets())
            PanicOnError(retRes9748)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateGetOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "id": "string",
            //         "side": "sell",
            //         "symbol": "xht-usdt",
            //         "size": 0.1,
            //         "filled": 0,
            //         "stop": null,
            //         "fee": 0,
            //         "fee_coin": "usdt",
            //         "type": "limit",
            //         "price": 1.09,
            //         "status": "new",
            //         "created_by": 116,
            //         "created_at": "2021-02-17T02:32:38.910Z",
            //         "updated_at": "2021-02-17T02:32:38.910Z",
            //         "User": {
            //             "id": 116,
            //             "email": "fight@club.com",
            //             "username": "narrator",
            //             "exchange_id": 176
            //         }
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://apidocs.hollaex.com/#get-all-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "open": true,
            }
        
                retRes102115 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes102115)
                ch <- retRes102115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://apidocs.hollaex.com/#get-all-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "open": false,
            }
        
                retRes103915 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes103915)
                ch <- retRes103915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://apidocs.hollaex.com/#get-order
 * @param {string} id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10538 := (<-this.LoadMarkets())
            PanicOnError(retRes10538)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateGetOrder(this.Extend(request, params)))
            PanicOnError(response)
            //             {
            //                 "id": "string",
            //                 "side": "sell",
            //                 "symbol": "xht-usdt",
            //                 "size": 0.1,
            //                 "filled": 0,
            //                 "stop": null,
            //                 "fee": 0,
            //                 "fee_coin": "usdt",
            //                 "type": "limit",
            //                 "price": 1.09,
            //                 "status": "new",
            //                 "created_by": 116,
            //                 "created_at": "2021-02-17T02:32:38.910Z",
            //                 "updated_at": "2021-02-17T02:32:38.910Z",
            //                 "User": {
            //                     "id": 116,
            //                     "email": "fight@club.com",
            //                     "username": "narrator",
            //                     "exchange_id": 176
            //                 }
            //             }
            var order interface{} = response
            if IsTrue(IsEqual(order, nil)) {
                panic(OrderNotFound(Add(Add(this.Id, " fetchOrder() could not find order id "), id)))
            }
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://apidocs.hollaex.com/#get-all-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10998 := (<-this.LoadMarkets())
            PanicOnError(retRes10998)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50, max 100
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": "string",
            //                 "side": "sell",
            //                 "symbol": "xht-usdt",
            //                 "size": 0.1,
            //                 "filled": 0,
            //                 "stop": null,
            //                 "fee": 0,
            //                 "fee_coin": "usdt",
            //                 "type": "limit",
            //                 "price": 1.09,
            //                 "status": "new",
            //                 "created_by": 116,
            //                 "created_at": "2021-02-17T02:32:38.910Z",
            //                 "updated_at": "2021-02-17T02:32:38.910Z",
            //                 "User": {
            //                     "id": 116,
            //                     "email": "fight@club.com",
            //                     "username": "narrator",
            //                     "exchange_id": 176
            //                 }
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "new": "open",
        "pfilled": "open",
        "filled": "closed",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hollaex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, fetchOpenOrder, fetchOpenOrders
    //
    //     {
    //          "id":"10644b7e-3c90-4ba9-bc3b-188f3a4e9cfd",
    //          "created_by":140093,
    //          "exchange_id":22,
    //          "side":"buy",
    //          "symbol":"doge-usdt",
    //          "type":"limit",
    //          "price":0.05,
    //          "size":10,
    //          "stop":null,
    //          "filled":0,
    //          "status":"canceled",
    //          "fee":0,
    //          "fee_coin":"doge",
    //          "meta": {                 // optional field only returned for postOnly orders
    //              "post_only":true
    //          },
    //          "fee_structure": {
    //              "maker":0.1,
    //              "taker":0.1
    //          },
    //          "created_at":"2022-05-31T08:14:14.747Z",
    //          "updated_at":"2022-05-31T08:14:23.727Z"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var id interface{} = this.SafeString(order, "id")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var typeVar interface{} = this.SafeString(order, "type")
    var side interface{} = this.SafeString(order, "side")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "size")
    var filled interface{} = this.SafeString(order, "filled")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var meta interface{} = this.SafeValue(order, "meta", map[string]interface{} {})
    var postOnly interface{} = this.SafeBool(meta, "post_only", false)
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString(order, "stop"),
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": nil,
        "trades": nil,
        "fee": nil,
        "info": order,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name hollaex#createOrder
 * @description create a trade order
 * @see https://apidocs.hollaex.com/#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12498 := (<-this.LoadMarkets())
            PanicOnError(retRes12498)
            var market interface{} = this.Market(symbol)
            var convertedAmount interface{} = ParseFloat(this.AmountToPrecision(symbol, amount))
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": side,
                "size": this.NormalizeNumberIfNeeded(convertedAmount),
                "type": typeVar,
            }
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "stop"})
            var meta interface{} = this.SafeValue(params, "meta", map[string]interface{} {})
            var exchangeSpecificParam interface{} = this.SafeBool(meta, "post_only", false)
            var isMarketOrder interface{} = IsEqual(typeVar, "market")
            var postOnly interface{} = this.IsPostOnly(isMarketOrder, exchangeSpecificParam, params)
            if !IsTrue(isMarketOrder) {
                var convertedPrice interface{} = ParseFloat(this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "price", this.NormalizeNumberIfNeeded(convertedPrice))
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop", this.NormalizeNumberIfNeeded(ParseFloat(this.PriceToPrecision(symbol, triggerPrice))))
            }
            if IsTrue(postOnly) {
                AddElementToObject(request, "meta", map[string]interface{} {
            "post_only": true,
        })
            }
            params = this.Omit(params, []interface{}{"postOnly", "timeInForce", "stopPrice", "triggerPrice", "stop"})
        
            response:= (<-this.PrivatePostOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "fee": 0,
            //         "meta": {},
            //         "symbol": "xht-usdt",
            //         "side": "sell",
            //         "size": 0.1,
            //         "type": "limit",
            //         "price": 1,
            //         "fee_structure": {
            //             "maker": 0.2,
            //             "taker": 0.2
            //         },
            //         "fee_coin": "usdt",
            //         "id": "string",
            //         "created_by": 116,
            //         "filled": 0,
            //         "status": "new",
            //         "updated_at": "2021-02-17T03:03:19.231Z",
            //         "created_at": "2021-02-17T03:03:19.231Z",
            //         "stop": null
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#cancelOrder
 * @description cancels an open order
 * @see https://apidocs.hollaex.com/#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13148 := (<-this.LoadMarkets())
            PanicOnError(retRes13148)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateDeleteOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "title": "string",
            //         "symbol": "xht-usdt",
            //         "side": "sell",
            //         "size": 1,
            //         "type": "limit",
            //         "price": 0.1,
            //         "id": "string",
            //         "created_by": 34,
            //         "filled": 0
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://apidocs.hollaex.com/#cancel-all-orders
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hollaex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes13488 := (<-this.LoadMarkets())
            PanicOnError(retRes13488)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            market = this.Market(symbol)
            AddElementToObject(request, "symbol", GetValue(market, "id"))
        
            response:= (<-this.PrivateDeleteOrderAll(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "title": "string",
            //             "symbol": "xht-usdt",
            //             "side": "sell",
            //             "size": 1,
            //             "type": "limit",
            //             "price": 0.1,
            //             "id": "string",
            //             "created_by": 34,
            //             "filled": 0
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://apidocs.hollaex.com/#get-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *hollaex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13848 := (<-this.LoadMarkets())
            PanicOnError(retRes13848)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50, max 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
        
            response:= (<-this.PrivateGetUserTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "side": "buy",
            //                 "symbol": "eth-usdt",
            //                 "size": 0.086,
            //                 "price": 226.19,
            //                 "timestamp": "2020-03-03T08:03:55.459Z",
            //                 "fee": 0.1
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "currency":"usdt",
    //         "address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik",
    //         "network":"trx",
    //         "standard":null,
    //         "is_valid":true,
    //         "created_at":"2021-05-12T02:43:05.446Z"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var tag interface{} = nil
    if IsTrue(!IsEqual(address, nil)) {
        var parts interface{} = Split(address, ":")
        address = this.SafeString(parts, 0)
        tag = this.SafeString(parts, 1)
    }
    this.CheckAddress(address)
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    currency = this.SafeCurrency(currencyId, currency)
    var network interface{} = this.SafeString(depositAddress, "network")
    return map[string]interface{} {
        "info": depositAddress,
        "currency": GetValue(currency, "code"),
        "network": network,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name hollaex#fetchDepositAddresses
 * @description fetch deposit addresses for multiple currencies and chain types
 * @see https://apidocs.hollaex.com/#get-user
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *hollaex) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14668 := (<-this.LoadMarkets())
            PanicOnError(retRes14668)
            var network interface{} = this.SafeString(params, "network")
            params = this.Omit(params, "network")
        
            response:= (<-this.PrivateGetUser(params))
            PanicOnError(response)
            //
            //     {
            //         "id":620,
            //         "email":"igor.kroitor@gmail.com",
            //         "full_name":"",
            //         "gender":false,
            //         "nationality":"",
            //         "dob":null,
            //         "phone_number":"",
            //         "address":{"city":"","address":"","country":"","postal_code":""},
            //         "id_data":{"note":"","type":"","number":"","status":0,"issued_date":"","expiration_date":""},
            //         "bank_account":[],
            //         "crypto_wallet":{},
            //         "verification_level":1,
            //         "email_verified":true,
            //         "otp_enabled":true,
            //         "activated":true,
            //         "username":"igor.kroitor",
            //         "affiliation_code":"QSWA6G",
            //         "settings":{
            //             "chat":{"set_username":false},
            //             "risk":{"popup_warning":false,"order_portfolio_percentage":20},
            //             "audio":{"public_trade":false,"order_completed":true,"order_partially_completed":true},
            //             "language":"en",
            //             "interface":{"theme":"white","order_book_levels":10},
            //             "notification":{"popup_order_completed":true,"popup_order_confirmation":true,"popup_order_partially_filled":true}
            //         },
            //         "affiliation_rate":0,
            //         "network_id":10620,
            //         "discount":0,
            //         "created_at":"2021-03-24T02:37:57.379Z",
            //         "updated_at":"2021-03-24T02:37:57.379Z",
            //         "balance":{
            //             "btc_balance":0,
            //             "btc_available":0,
            //             "eth_balance":0.000914,
            //             "eth_available":0.000914,
            //             "updated_at":"2020-03-04T04:03:27.174Z
            //         "},
            //         "wallet":[
            //             {"currency":"usdt","address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik","network":"trx","standard":null,"is_valid":true,"created_at":"2021-05-12T02:43:05.446Z"},
            //             {"currency":"xrp","address":"rGcSzmuRx8qngPRnrvpCKkP9V4njeCPGCv:286741597","network":"xrp","standard":null,"is_valid":true,"created_at":"2021-05-12T02:49:01.273Z"}
            //         ]
            //     }
            //
            var wallet interface{} = this.SafeValue(response, "wallet", []interface{}{})
            var addresses interface{} = Ternary(IsTrue((IsEqual(network, nil))), wallet, this.FilterBy(wallet, "network", network))
        
            ch <- this.ParseDepositAddresses(addresses, codes)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://apidocs.hollaex.com/#get-deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hollaex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15328 := (<-this.LoadMarkets())
            PanicOnError(retRes15328)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50, max 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
        
            response:= (<-this.PrivateGetUserDeposits(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": 539,
            //                 "amount": 20,
            //                 "fee": 0,
            //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //                 "status": true,
            //                 "dismissed": false,
            //                 "rejected": false,
            //                 "description": "",
            //                 "type": "deposit",
            //                 "currency": "usdt",
            //                 "created_at": "2020-03-03T07:56:36.198Z",
            //                 "updated_at": "2020-03-03T08:00:05.674Z",
            //                 "user_id": 620
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchWithdrawal
 * @description fetch data on a currency withdrawal via the withdrawal id
 * @see https://apidocs.hollaex.com/#get-withdrawals
 * @param {string} id withdrawal id
 * @param {string} code unified currency code of the currency withdrawn, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hollaex) FetchWithdrawal(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15928 := (<-this.LoadMarkets())
            PanicOnError(retRes15928)
            var request interface{} = map[string]interface{} {
                "transaction_id": id,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivateGetUserWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": 539,
            //                 "amount": 20,
            //                 "fee": 0,
            //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //                 "status": true,
            //                 "dismissed": false,
            //                 "rejected": false,
            //                 "description": "",
            //                 "type": "withdrawal",
            //                 "currency": "usdt",
            //                 "created_at": "2020-03-03T07:56:36.198Z",
            //                 "updated_at": "2020-03-03T08:00:05.674Z",
            //                 "user_id": 620
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var transaction interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTransaction(transaction, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hollaex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://apidocs.hollaex.com/#get-withdrawals
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hollaex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16428 := (<-this.LoadMarkets())
            PanicOnError(retRes16428)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 50, max 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
        
            response:= (<-this.PrivateGetUserWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": 539,
            //                 "amount": 20,
            //                 "fee": 0,
            //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //                 "status": true,
            //                 "dismissed": false,
            //                 "rejected": false,
            //                 "description": "",
            //                 "type": "withdrawal",
            //                 "currency": "usdt",
            //                 "created_at": "2020-03-03T07:56:36.198Z",
            //                 "updated_at": "2020-03-03T08:00:05.674Z",
            //                 "user_id": 620
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchWithdrawals, fetchDeposits
    //
    //     {
    //         "id": 539,
    //         "amount": 20,
    //         "fee": 0,
    //         "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
    //         "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
    //         "status": true,
    //         "dismissed": false,
    //         "rejected": false,
    //         "description": "",
    //         "type": "withdrawal",
    //         "currency": "usdt",
    //         "created_at": "2020-03-03T07:56:36.198Z",
    //         "updated_at": "2020-03-03T08:00:05.674Z",
    //         "user_id": 620
    //     }
    //
    // withdraw
    //
    //     {
    //         "message": "Withdrawal request is in the queue and will be processed.",
    //         "transaction_id": "1d1683c3-576a-4d53-8ff5-27c93fd9758a",
    //         "amount": 1,
    //         "currency": "xht",
    //         "fee": 0,
    //         "fee_coin": "xht"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var txid interface{} = this.SafeString(transaction, "transaction_id")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at"))
    var updated interface{} = this.Parse8601(this.SafeString(transaction, "updated_at"))
    var typeVar interface{} = this.SafeString(transaction, "type")
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var address interface{} = this.SafeString(transaction, "address")
    var addressTo interface{} = nil
    var addressFrom interface{} = nil
    var tag interface{} = nil
    var tagTo interface{} = nil
    var tagFrom interface{} = nil
    if IsTrue(!IsEqual(address, nil)) {
        var parts interface{} = Split(address, ":")
        address = this.SafeString(parts, 0)
        tag = this.SafeString(parts, 1)
        addressTo = address
        tagTo = tag
    }
    var currencyId interface{} = this.SafeString(transaction, "currency")
    currency = this.SafeCurrency(currencyId, currency)
    var status interface{} = this.SafeValue(transaction, "status")
    var dismissed interface{} = this.SafeValue(transaction, "dismissed")
    var rejected interface{} = this.SafeValue(transaction, "rejected")
    if IsTrue(status) {
        status = "ok"
    } else if IsTrue(dismissed) {
        status = "canceled"
    } else if IsTrue(rejected) {
        status = "failed"
    } else {
        status = "pending"
    }
    var feeCurrencyId interface{} = this.SafeString(transaction, "fee_coin")
    var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId, currency)
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": feeCurrencyCode,
            "cost": feeCost,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": addressFrom,
        "address": address,
        "addressTo": addressTo,
        "tagFrom": tagFrom,
        "tag": tag,
        "tagTo": tagTo,
        "type": typeVar,
        "amount": amount,
        "currency": GetValue(currency, "code"),
        "status": status,
        "updated": updated,
        "comment": this.SafeString(transaction, "message"),
        "internal": nil,
        "fee": fee,
    }
}
/**
 * @method
 * @name hollaex#withdraw
 * @description make a withdrawal
 * @see https://apidocs.hollaex.com/#withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hollaex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes18058 := (<-this.LoadMarkets())
            PanicOnError(retRes18058)
            var currency interface{} = this.Currency(code)
            if IsTrue(!IsEqual(tag, nil)) {
                address = Add(address, Add(":", tag))
            }
            var network interface{} = this.SafeString(params, "network")
            if IsTrue(IsEqual(network, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a network parameter")))
            }
            params = this.Omit(params, "network")
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
                "network": this.NetworkCodeToId(network, code),
            }
        
            response:= (<-this.PrivatePostUserWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "message": "Withdrawal request is in the queue and will be processed.",
            //         "transaction_id": "1d1683c3-576a-4d53-8ff5-27c93fd9758a",
            //         "amount": 1,
            //         "currency": "xht",
            //         "fee": 0,
            //         "fee_coin": "xht"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    "bch":{
    //        "id":4,
    //        "fullname":"Bitcoin Cash",
    //        "symbol":"bch",
    //        "active":true,
    //        "verified":true,
    //        "allow_deposit":true,
    //        "allow_withdrawal":true,
    //        "withdrawal_fee":0.0001,
    //        "min":0.001,
    //        "max":100000,
    //        "increment_unit":0.001,
    //        "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
    //        "code":"bch",
    //        "is_public":true,
    //        "meta":{},
    //        "estimated_price":null,
    //        "description":null,
    //        "type":"blockchain",
    //        "network":null,
    //        "standard":null,
    //        "issuer":"HollaEx",
    //        "withdrawal_fees":null,
    //        "created_at":"2019-08-09T10:45:43.367Z",
    //        "updated_at":"2021-12-13T03:08:32.372Z",
    //        "created_by":1,
    //        "owner_id":1
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    var allowWithdrawal interface{} = this.SafeValue(fee, "allow_withdrawal")
    if IsTrue(allowWithdrawal) {
        AddElementToObject(result, "withdraw", map[string]interface{} {
    "fee": this.SafeNumber(fee, "withdrawal_fee"),
    "percentage": false,
})
    }
    var withdrawalFees interface{} = this.SafeValue(fee, "withdrawal_fees")
    if IsTrue(!IsEqual(withdrawalFees, nil)) {
        var keys interface{} = ObjectKeys(withdrawalFees)
        var keysLength interface{} =         GetArrayLength(keys)
        for i := 0; IsLessThan(i, keysLength); i++ {
            var key interface{} = GetValue(keys, i)
            var value interface{} = GetValue(withdrawalFees, key)
            var currencyId interface{} = this.SafeString(value, "symbol")
            var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
            var networkCode interface{} = this.NetworkIdToCode(key, currencyCode)
            var networkCodeUpper interface{} = ToUpper(networkCode) // default to the upper case network code
            var withdrawalFee interface{} = this.SafeNumber(value, "value")
            AddElementToObject(GetValue(result, "networks"), networkCodeUpper, map[string]interface{} {
    "deposit": nil,
    "withdraw": withdrawalFee,
})
        }
    }
    return result
}
/**
 * @method
 * @name hollaex#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://apidocs.hollaex.com/#constants
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *hollaex) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetConstants(params))
            PanicOnError(response)
            //
            //     {
            //         "coins":{
            //             "bch":{
            //                 "id":4,
            //                 "fullname":"Bitcoin Cash",
            //                 "symbol":"bch",
            //                 "active":true,
            //                 "verified":true,
            //                 "allow_deposit":true,
            //                 "allow_withdrawal":true,
            //                 "withdrawal_fee":0.0001,
            //                 "min":0.001,
            //                 "max":100000,
            //                 "increment_unit":0.001,
            //                 "logo":"https://bitholla.s3.ap-northeast-2.amazonaws.com/icon/BCH-hollaex-asset-01.svg",
            //                 "code":"bch",
            //                 "is_public":true,
            //                 "meta":{},
            //                 "estimated_price":null,
            //                 "description":null,
            //                 "type":"blockchain",
            //                 "network":null,
            //                 "standard":null,
            //                 "issuer":"HollaEx",
            //                 "withdrawal_fees":null,
            //                 "created_at":"2019-08-09T10:45:43.367Z",
            //                 "updated_at":"2021-12-13T03:08:32.372Z",
            //                 "created_by":1,
            //                 "owner_id":1
            //             },
            //         },
            //         "network":"https://api.hollaex.network"
            //     }
            //
            var coins interface{} = this.SafeDict(response, "coins", map[string]interface{} {})
        
            ch <- this.ParseDepositWithdrawFees(coins, codes, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *hollaex) NormalizeNumberIfNeeded(number interface{}) interface{}  {
    if IsTrue(this.IsRoundNumber(number)) {
        number = ParseInt(number)
    }
    return number
}
func  (this *hollaex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    path = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            path = Add(path, Add("?", this.Urlencode(query)))
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), path)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var defaultExpires interface{} = this.SafeInteger2(this.Options, "api-expires", "expires", this.ParseToInt(Divide(this.Timeout, 1000)))
        var expires interface{} = this.Sum(this.Seconds(), defaultExpires)
        var expiresString interface{} = ToString(expires)
        var auth interface{} = Add(Add(method, path), expiresString)
        headers = map[string]interface{} {
            "api-key": this.ApiKey,
            "api-expires": expiresString,
        }
        if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-type", "application/json")
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                auth = Add(auth, body)
            }
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "api-signature", signature)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *hollaex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    // { "message": "Invalid token" }
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if IsTrue(IsTrue((IsGreaterThanOrEqual(code, 400))) && IsTrue((IsLessThanOrEqual(code, 503)))) {
        //
        //  { "message": "Invalid token" }
        //
        // different errors return the same code eg
        //
        //  { "message":"Error 1001 - Order rejected. Order could not be submitted as this order was set to a post only order." }
        //
        //  { "message":"Error 1001 - POST ONLY order can not be of type market" }
        //
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString(response, "message")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        var status interface{} = ToString(code)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), status, feedback)
    }
    return nil
}


func (this *hollaex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
