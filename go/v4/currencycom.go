package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type currencycom struct {
    Exchange

}

func NewCurrencycomCore() currencycom {
   p := currencycom{}
   setDefaults(&p)
   return p
}

func  (this *currencycom) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "currencycom",
        "name": "Currency.com",
        "countries": []interface{}{"BY"},
        "rateLimit": 100,
        "certified": false,
        "pro": true,
        "version": "v2",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": nil,
            "cancelAllOrders": nil,
            "cancelOrder": true,
            "cancelOrders": nil,
            "createDepositAddress": nil,
            "createLimitOrder": true,
            "createMarketOrder": true,
            "createOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "editOrder": "emulated",
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBidsAsks": nil,
            "fetchBorrowRateHistory": nil,
            "fetchCanceledOrders": nil,
            "fetchClosedOrder": nil,
            "fetchClosedOrders": nil,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": nil,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL2OrderBook": true,
            "fetchLedger": true,
            "fetchLedgerEntry": false,
            "fetchLeverage": true,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrder": nil,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": nil,
            "fetchOrders": nil,
            "fetchOrderTrades": nil,
            "fetchPosition": nil,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": nil,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTradingLimits": nil,
            "fetchTransactionFee": nil,
            "fetchTransactionFees": nil,
            "fetchTransactions": "emulated",
            "fetchTransfers": nil,
            "fetchWithdrawal": nil,
            "fetchWithdrawals": true,
            "reduceMargin": nil,
            "sandbox": true,
            "setLeverage": nil,
            "setMarginMode": nil,
            "setPositionMode": nil,
            "signIn": nil,
            "transfer": nil,
            "withdraw": nil,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "10m": "10m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "1d": "1d",
            "1w": "1w",
        },
        "hostname": "backend.currency.com",
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg",
            "api": map[string]interface{} {
                "public": "https://api-adapter.{hostname}/api",
                "private": "https://api-adapter.{hostname}/api",
                "marketcap": "https://marketcap.{hostname}/api",
            },
            "test": map[string]interface{} {
                "public": "https://demo-api-adapter.{hostname}/api",
                "private": "https://demo-api-adapter.{hostname}/api",
            },
            "www": "https://www.currency.com",
            "referral": "https://currency.com/trading/signup?c=362jaimv&pid=referral",
            "doc": []interface{}{"https://currency.com/api"},
            "fees": "https://currency.com/fees-charges",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/time": 1,
                    "v1/exchangeInfo": 1,
                    "v1/depth": 1,
                    "v1/aggTrades": 1,
                    "v1/klines": 1,
                    "v1/ticker/24hr": 1,
                    "v2/time": 1,
                    "v2/exchangeInfo": 1,
                    "v2/depth": 1,
                    "v2/aggTrades": 1,
                    "v2/klines": 1,
                    "v2/ticker/24hr": 1,
                },
            },
            "marketcap": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/assets": 1,
                    "v1/candles": 1,
                    "v1/orderbook": 1,
                    "v1/summary": 1,
                    "v1/ticker": 1,
                    "v1/token/assets": 1,
                    "v1/token/orderbook": 1,
                    "v1/token/summary": 1,
                    "v1/token/ticker": 1,
                    "v1/token/trades": 1,
                    "v1/token_crypto/OHLC": 1,
                    "v1/token_crypto/assets": 1,
                    "v1/token_crypto/orderbook": 1,
                    "v1/token_crypto/summary": 1,
                    "v1/token_crypto/ticker": 1,
                    "v1/token_crypto/trades": 1,
                    "v1/trades": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/account": 1,
                    "v1/currencies": 1,
                    "v1/deposits": 1,
                    "v1/depositAddress": 1,
                    "v1/ledger": 1,
                    "v1/leverageSettings": 1,
                    "v1/myTrades": 1,
                    "v1/openOrders": 1,
                    "v1/tradingPositions": 1,
                    "v1/tradingPositionsHistory": 1,
                    "v1/transactions": 1,
                    "v1/withdrawals": 1,
                    "v2/account": 1,
                    "v2/currencies": 1,
                    "v2/deposits": 1,
                    "v2/depositAddress": 1,
                    "v2/ledger": 1,
                    "v2/leverageSettings": 1,
                    "v2/myTrades": 1,
                    "v2/openOrders": 1,
                    "v2/tradingPositions": 1,
                    "v2/tradingPositionsHistory": 1,
                    "v2/transactions": 1,
                    "v2/withdrawals": 1,
                    "v2/fetchOrder": 1,
                },
                "post": map[string]interface{} {
                    "v1/order": 1,
                    "v1/updateTradingPosition": 1,
                    "v1/updateTradingOrder": 1,
                    "v1/closeTradingPosition": 1,
                    "v2/order": 1,
                    "v2/updateTradingPosition": 1,
                    "v2/updateTradingOrder": 1,
                    "v2/closeTradingPosition": 1,
                },
                "delete": map[string]interface{} {
                    "v1/order": 1,
                    "v2/order": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.002"),
                "maker": this.ParseNumber("0.002"),
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "defaultTimeInForce": "GTC",
            "warnOnFetchOpenOrdersWithoutSymbol": true,
            "recvWindow": Multiply(5, 1000),
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "parseOrderToPrecision": false,
            "newOrderRespType": map[string]interface{} {
                "market": "FULL",
                "limit": "RESULT",
                "stop": "RESULT",
            },
            "leverage_markets_suffix": "_LEVERAGE",
            "collateralCurrencies": []interface{}{"USD", "EUR", "USDT"},
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": nil,
                        "price": false,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": true,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                    "leverage": true,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
        },
        "exceptions": map[string]interface{} {
            "broad": map[string]interface{} {
                "FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order": InvalidOrder,
                "API key does not exist": AuthenticationError,
                "Order would trigger immediately.": InvalidOrder,
                "Account has insufficient balance for requested action.": InsufficientFunds,
                "Rest API trading is not enabled.": ExchangeNotAvailable,
                "Combination of parameters invalid": BadRequest,
                "Invalid limit price": BadRequest,
                "Only leverage symbol allowed here:": BadSymbol,
                "market data service is not available": ExchangeNotAvailable,
                "your time is ahead of server": InvalidNonce,
                "Can not find account": BadRequest,
                "You mentioned an invalid value for the price parameter": BadRequest,
            },
            "exact": map[string]interface{} {
                "-1000": ExchangeNotAvailable,
                "-1013": InvalidOrder,
                "-1022": AuthenticationError,
                "-1030": InvalidOrder,
                "-1100": InvalidOrder,
                "-1104": ExchangeError,
                "-1025": AuthenticationError,
                "-1128": BadRequest,
                "-2010": ExchangeError,
                "-2011": OrderNotFound,
                "-2013": OrderNotFound,
                "-2014": AuthenticationError,
                "-2015": AuthenticationError,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "ACN": "Accenture",
            "AMC": "AMC Entertainment Holdings",
            "BNS": "Bank of Nova Scotia",
            "CAR": "Avis Budget Group Inc",
            "CLR": "Continental Resources",
            "EDU": "New Oriental Education & Technology Group Inc",
            "ETN": "Eaton",
            "FOX": "Fox Corporation",
            "GM": "General Motors Co",
            "IQ": "iQIYI",
            "OSK": "Oshkosh",
            "PLAY": "Dave & Buster\\'s Entertainment",
        },
    })
}
func  (this *currencycom) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
/**
 * @method
 * @name currencycom#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/timeUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *currencycom) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV2Time(params))
            PanicOnError(response)
        
                //
            //     {
            //         "serverTime": 1590998366609
            //     }
            //
        ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getCurrenciesUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *currencycom) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // requires authentication
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if !IsTrue(this.CheckRequiredCredentials(false)) {
        
                return nil
            }
        
            response:= (<-this.PrivateGetV2Currencies(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "name": "Euro",
            //             "displaySymbol": "EUR.cx",
            //             "precision": "2",
            //             "type": "FIAT",
            //             "minWithdrawal": "90.0",
            //             "maxWithdrawal": "1.0E+8",
            //             "commissionMin": "0.02", // some instruments do not have this property
            //             "commissionPercent": "1.5", // some instruments do not have this property
            //             "minDeposit": "90.0",
            //         },
            //         {
            //             "name": "Bitcoin",
            //             "displaySymbol": "BTC",
            //             "precision": "8",
            //             "type": "CRYPTO", // only a few major currencies have this value, others like USDT have a value of "TOKEN"
            //             "minWithdrawal": "0.00020",
            //             "commissionFixed": "0.00010",
            //             "minDeposit": "0.00010",
            //         },
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "displaySymbol")
                var code interface{} = this.SafeCurrencyCode(id)
                var fee interface{} = this.SafeNumber(currency, "commissionFixed")
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "type": this.SafeStringLower(currency, "type"),
            "name": this.SafeString(currency, "name"),
            "active": nil,
            "deposit": nil,
            "withdraw": nil,
            "fee": fee,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "precision"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "minWithdrawal"),
                    "max": this.SafeNumber(currency, "maxWithdrawal"),
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(currency, "minDeposit"),
                    "max": nil,
                },
            },
            "info": currency,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchMarkets
 * @description retrieves data on all markets for currencycom
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/exchangeInfoUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *currencycom) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV2ExchangeInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": "1645186287261",
            //         "rateLimits": [
            //             { rateLimitType: "REQUEST_WEIGHT", interval: "MINUTE", intervalNum: "1", limit: "1200" },
            //             { rateLimitType: "ORDERS", interval: "SECOND", intervalNum: "1", limit: "10" },
            //             { rateLimitType: "ORDERS", interval: "DAY", intervalNum: "1", limit: "864000" },
            //         ],
            //         "exchangeFilters": [],
            //         "symbols": [
            //             {
            //                 "symbol": "BTC/USDT", // BTC/USDT, BTC/USDT_LEVERAGE
            //                 "name": "Bitcoin / Tether",
            //                 "status": "TRADING", // TRADING, BREAK, HALT
            //                 "baseAsset": "BTC",
            //                 "baseAssetPrecision": "4",
            //                 "quoteAsset": "USDT",
            //                 "quoteAssetId": "USDT", // USDT, USDT_LEVERAGE
            //                 "quotePrecision": "4",
            //                 "orderTypes": [ "LIMIT", "MARKET" ], // LIMIT, MARKET, STOP
            //                 "filters": [
            //                     { filterType: "LOT_SIZE", minQty: "0.0001", maxQty: "100", stepSize: "0.0001", },
            //                     { filterType: "MIN_NOTIONAL", minNotional: "5", },
            //                 ],
            //                 "marketModes": [ "REGULAR" ], // CLOSE_ONLY, LONG_ONLY, REGULAR
            //                 "marketType": "SPOT", // SPOT, LEVERAGE
            //                 "longRate": -0.0684932, // LEVERAGE only
            //                 "shortRate": -0.0684932, // LEVERAGE only
            //                 "swapChargeInterval": 1440, // LEVERAGE only
            //                 "country": "",
            //                 "sector": "",
            //                 "industry": "",
            //                 "tradingHours": "UTC; Mon - 22:00, 22:05 -; Tue - 22:00, 22:05 -; Wed - 22:00, 22:05 -; Thu - 22:00, 22:05 -; Fri - 22:00, 23:01 -; Sat - 22:00, 22:05 -; Sun - 21:00, 22:05 -",
            //                 "tickSize": "0.01",
            //                 "tickValue": "403.4405", // not available in BTC/USDT_LEVERAGE, but available in BTC/USD_LEVERAGE
            //                 "exchangeFee": "0.2", // SPOT only
            //                 "tradingFee": 0.075, // LEVERAGE only
            //                 "makerFee": -0.025, // LEVERAGE only
            //                 "takerFee": 0.06, // LEVERAGE only
            //                 "maxSLGap": 50, // LEVERAGE only
            //                 "minSLGap": 1, // LEVERAGE only
            //                 "maxTPGap": 50, // LEVERAGE only
            //                 "minTPGap": 0.5, // LEVERAGE only
            //                 "assetType": "CRYPTOCURRENCY",
            //             },
            //         ]
            //     }
            //
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes53212 := (<-this.LoadTimeDifference())
                PanicOnError(retRes53212)
            }
            var markets interface{} = this.SafeValue(response, "symbols", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseAsset")
                var quoteId interface{} = this.SafeString(market, "quoteAsset")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                var typeRaw interface{} = this.SafeString(market, "marketType")
                var spot interface{} =         (IsEqual(typeRaw, "SPOT"))
                var futures interface{} = false
                var swap interface{} =         (IsEqual(typeRaw, "LEVERAGE"))
                var typeVar interface{} = Ternary(IsTrue(swap), "swap", "spot")
                var margin interface{} = nil
                if IsTrue(swap) {
                    symbol = Replace(symbol, GetValue(this.Options, "leverage_markets_suffix"), "")
                    symbol = Add(symbol, Add(":", quote))
                }
                var active interface{} = IsEqual(this.SafeString(market, "status"), "TRADING")
                // to set taker & maker fees, we use one from the below data - pairs either have 'exchangeFee' or 'tradingFee', if none of them (rare cases), then they should have 'takerFee & makerFee'
                var exchangeFee interface{} = this.SafeString2(market, "exchangeFee", "tradingFee")
                var makerFee interface{} = this.SafeString(market, "makerFee", exchangeFee)
                var takerFee interface{} = this.SafeString(market, "takerFee", exchangeFee)
                makerFee = Precise.StringDiv(makerFee, "100")
                takerFee = Precise.StringDiv(takerFee, "100")
                var filters interface{} = this.SafeValue(market, "filters", []interface{}{})
                var filtersByType interface{} = this.IndexBy(filters, "filterType")
                var limitPriceMin interface{} = nil
                var limitPriceMax interface{} = nil
                var precisionPrice interface{} = this.SafeNumber(market, "tickSize")
                if IsTrue(InOp(filtersByType, "PRICE_FILTER")) {
                    var filter interface{} = this.SafeValue(filtersByType, "PRICE_FILTER", map[string]interface{} {})
                    precisionPrice = this.SafeNumber(filter, "tickSize")
                    // PRICE_FILTER reports zero values for maxPrice
                    // since they updated filter types in November 2018
                    // https://github.com/ccxt/ccxt/issues/4286
                    // therefore limits['price']['max'] doesn't have any meaningful value except undefined
                    limitPriceMin = this.SafeNumber(filter, "minPrice")
                    var maxPrice interface{} = this.SafeString(filter, "maxPrice")
                    if IsTrue(IsTrue((!IsEqual(maxPrice, nil))) && IsTrue((Precise.StringGt(maxPrice, "0")))) {
                        limitPriceMax = maxPrice
                    }
                }
                var precisionAmount interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetPrecision")))
                var limitAmount interface{} = map[string]interface{} {
                    "min": nil,
                    "max": nil,
                }
                if IsTrue(InOp(filtersByType, "LOT_SIZE")) {
                    var filter interface{} = this.SafeValue(filtersByType, "LOT_SIZE", map[string]interface{} {})
                    precisionAmount = this.SafeNumber(filter, "stepSize")
                    limitAmount = map[string]interface{} {
                        "min": this.SafeNumber(filter, "minQty"),
                        "max": this.SafeNumber(filter, "maxQty"),
                    }
                }
                var limitMarket interface{} = map[string]interface{} {
                    "min": nil,
                    "max": nil,
                }
                if IsTrue(InOp(filtersByType, "MARKET_LOT_SIZE")) {
                    var filter interface{} = this.SafeValue(filtersByType, "MARKET_LOT_SIZE", map[string]interface{} {})
                    limitMarket = map[string]interface{} {
                        "min": this.SafeNumber(filter, "minQty"),
                        "max": this.SafeNumber(filter, "maxQty"),
                    }
                }
                var costMin interface{} = nil
                if IsTrue(InOp(filtersByType, "MIN_NOTIONAL")) {
                    var filter interface{} = this.SafeValue(filtersByType, "MIN_NOTIONAL", map[string]interface{} {})
                    costMin = this.SafeNumber(filter, "minNotional")
                }
                var isContract interface{} = IsTrue(swap) || IsTrue(futures)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": typeVar,
                    "spot": spot,
                    "margin": margin,
                    "swap": swap,
                    "future": futures,
                    "option": false,
                    "active": active,
                    "contract": isContract,
                    "linear": Ternary(IsTrue(isContract), true, nil),
                    "inverse": nil,
                    "taker": this.ParseNumber(takerFee),
                    "maker": this.ParseNumber(makerFee),
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": precisionAmount,
                        "price": precisionPrice,
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": limitAmount,
                        "market": limitMarket,
                        "price": map[string]interface{} {
                            "min": limitPriceMin,
                            "max": this.ParseNumber(limitPriceMax),
                        },
                        "cost": map[string]interface{} {
                            "min": costMin,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/accountUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *currencycom) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivateGetV2Account(params))
            PanicOnError(response)
            //
            //     {
            //         "makerCommission": "0.20",
            //         "takerCommission": "0.20",
            //         "buyerCommission": "0.20",
            //         "sellerCommission": "0.20",
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "canDeposit": true,
            //         "updateTime": "1645266330",
            //         "userId": "644722",
            //         "balances": [
            //             {
            //                 "accountId": "120702016179403605",
            //                 "collateralCurrency": false,
            //                 "asset": "CAKE",
            //                 "free": "3.1",
            //                 "locked": "0.0",
            //                 "default": false,
            //             },
            //             {
            //                 "accountId": "109698017713125316",
            //                 "collateralCurrency": true,
            //                 "asset": "USD",
            //                 "free": "17.58632",
            //                 "locked": "0.0",
            //                 "default": true,
            //             }
            //         ]
            //     }
            //
            var accounts interface{} = this.SafeValue(response, "balances", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
                var account interface{} = GetValue(accounts, i)
                var accountId interface{} = this.SafeString(account, "accountId") // must be string, because the numeric value is far too big for integer, and causes bugs
                var currencyId interface{} = this.SafeString(account, "asset")
                var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
                AppendToArray(&result,map[string]interface{} {
                    "id": accountId,
                    "type": nil,
                    "currency": currencyCode,
                    "info": account,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/accountUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *currencycom) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7298 := (<-this.LoadMarkets())
            PanicOnError(retRes7298)
        
            response:= (<-this.PrivateGetV2Account(params))
            PanicOnError(response)
            //
            //    {
            //        "makerCommission": "0.20",
            //        "takerCommission": "0.20",
            //        "buyerCommission": "0.20",
            //        "sellerCommission": "0.20",
            //        "canTrade": true,
            //        "canWithdraw": true,
            //        "canDeposit": true,
            //        "updateTime": "1645738976",
            //        "userId": "-1924114235",
            //        "balances": []
            //    }
            //
            var makerFee interface{} = this.SafeNumber(response, "makerCommission")
            var takerFee interface{} = this.SafeNumber(response, "takerCommission")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": makerFee,
            "taker": takerFee,
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseBalance(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "makerCommission":0.20,
    //         "takerCommission":0.20,
    //         "buyerCommission":0.20,
    //         "sellerCommission":0.20,
    //         "canTrade":true,
    //         "canWithdraw":true,
    //         "canDeposit":true,
    //         "updateTime":1591056268,
    //         "balances":[
    //             {
    //                 "accountId":5470306579272368,
    //                 "collateralCurrency":true,
    //                 "asset":"ETH",
    //                 "free":0.0,
    //                 "locked":0.0,
    //                 "default":false,
    //             },
    //         ]
    //     }
    //
    typeVar := GetArg(optionalArgs, 0, nil)
    _ = typeVar
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeValue(response, "balances", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "asset")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "free"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name currencycom#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/accountUsingGET
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *currencycom) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8088 := (<-this.LoadMarkets())
            PanicOnError(retRes8088)
        
            response:= (<-this.PrivateGetV2Account(params))
            PanicOnError(response)
        
                //
            //     {
            //         "makerCommission": "0.20",
            //         "takerCommission": "0.20",
            //         "buyerCommission": "0.20",
            //         "sellerCommission": "0.20",
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "canDeposit": true,
            //         "updateTime": "1645266330",
            //         "userId": "644722",
            //         "balances": [
            //             {
            //                 "accountId": "120702016179403605",
            //                 "collateralCurrency": false,
            //                 "asset": "CAKE",
            //                 "free": "1.784",
            //                 "locked": "0.0",
            //                 "default": false,
            //             },
            //             {
            //                 "accountId": "109698017413175316",
            //                 "collateralCurrency": true,
            //                 "asset": "USD",
            //                 "free": "7.58632",
            //                 "locked": "0.0",
            //                 "default": true,
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/depthUsingGET
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *currencycom) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8558 := (<-this.LoadMarkets())
            PanicOnError(retRes8558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000, 5000
            }
        
            response:= (<-this.PublicGetV2Depth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "lastUpdateId":1590999849037,
            //         "asks":[
            //             [0.02495,60.0345],
            //             [0.02496,34.1],
            //             ...
            //         ],
            //         "bids":[
            //             [0.02487,72.4144854],
            //             [0.02486,24.043],
            //             ...
            //         ]
            //     }
            //
            var orderbook interface{} = this.ParseOrderBook(response, symbol)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "symbol":"ETH/BTC",
    //         "priceChange":"0.00030",
    //         "priceChangePercent":"1.21",
    //         "weightedAvgPrice":"0.02481",
    //         "prevClosePrice":"0.02447",
    //         "lastPrice":"0.02477",
    //         "lastQty":"60.0",
    //         "bidPrice":"0.02477",
    //         "askPrice":"0.02484",
    //         "openPrice":"0.02447",
    //         "highPrice":"0.02524",
    //         "lowPrice":"0.02438",
    //         "volume":"11.97",
    //         "quoteVolume":"0.298053",
    //         "openTime":1590969600000,
    //         "closeTime":1591000072693
    //     }
    //
    // fetchTickers
    //
    //     {
    //          "symbol": "SHIB/USD_LEVERAGE",
    //          "weightedAvgPrice": "0.000027595",
    //          "lastPrice": "0.00002737",
    //          "lastQty": "1.11111111E8",
    //          "bidPrice": "0.00002737",
    //          "askPrice": "0.00002782",
    //          "highPrice": "0.00002896",
    //          "lowPrice": "0.00002738",
    //          "volume": "16472160000",
    //          "quoteVolume": "454796.3376",
    //          "openTime": "1645187472000",
    //          "closeTime": "1645273872000",
    //     }
    //
    // ws:marketData.subscribe
    //
    //     {
    //          "symbolName":"TXN",
    //          "bid":139.85,
    //          "bidQty":2500,
    //          "ofr":139.92000000000002,
    //          "ofrQty":2500,
    //          "timestamp":1597850971558
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(ticker, "closeTime", "timestamp")
    var marketId interface{} = this.SafeString2(ticker, "symbol", "symbolName")
    market = this.SafeMarket(marketId, market, "/")
    var last interface{} = this.SafeString(ticker, "lastPrice")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "highPrice"),
        "low": this.SafeString(ticker, "lowPrice"),
        "bid": this.SafeString2(ticker, "bidPrice", "bid"),
        "bidVolume": this.SafeString(ticker, "bidQty"),
        "ask": this.SafeString2(ticker, "askPrice", "ofr"),
        "askVolume": this.SafeString(ticker, "ofrQty"),
        "vwap": this.SafeString(ticker, "weightedAvgPrice"),
        "open": this.SafeString(ticker, "openPrice"),
        "close": last,
        "last": last,
        "previousClose": this.SafeString(ticker, "prevClosePrice"),
        "change": this.SafeString(ticker, "priceChange"),
        "percentage": this.SafeString(ticker, "priceChangePercent"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "quoteVolume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name currencycom#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/ticker_24hrUsingGET
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *currencycom) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9738 := (<-this.LoadMarkets())
            PanicOnError(retRes9738)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetV2Ticker24hr(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "symbol":"ETH/BTC",
            //         "priceChange":"0.00030",
            //         "priceChangePercent":"1.21",
            //         "weightedAvgPrice":"0.02481",
            //         "prevClosePrice":"0.02447",
            //         "lastPrice":"0.02477",
            //         "lastQty":"60.0",
            //         "bidPrice":"0.02477",
            //         "askPrice":"0.02484",
            //         "openPrice":"0.02447",
            //         "highPrice":"0.02524",
            //         "lowPrice":"0.02438",
            //         "volume":"11.97",
            //         "quoteVolume":"0.298053",
            //         "openTime":1590969600000,
            //         "closeTime":1591000072693
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/ticker_24hrUsingGET
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *currencycom) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10128 := (<-this.LoadMarkets())
            PanicOnError(retRes10128)
        
            response:= (<-this.PublicGetV2Ticker24hr(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //              "symbol": "SHIB/USD_LEVERAGE",
            //              "weightedAvgPrice": "0.000027595",
            //              "lastPrice": "0.00002737",
            //              "lastQty": "1.11111111E8",
            //              "bidPrice": "0.00002737",
            //              "askPrice": "0.00002782",
            //              "highPrice": "0.00002896",
            //              "lowPrice": "0.00002738",
            //              "volume": "16472160000",
            //              "quoteVolume": "454796.3376",
            //              "openTime": "1645187472000",
            //              "closeTime": "1645273872000",
            //         }
            //     ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1590971040000,
    //         "0.02454",
    //         "0.02456",
    //         "0.02452",
    //         "0.02456",
    //         249
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name currencycom#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/klinesUsingGET
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *currencycom) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10698 := (<-this.LoadMarkets())
            PanicOnError(retRes10698)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000)) // default 500, max 1000
            }
        
            response:= (<-this.PublicGetV2Klines(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [1590971040000,"0.02454","0.02456","0.02452","0.02456",249],
            //         [1590971100000,"0.02455","0.02457","0.02452","0.02456",300],
            //         [1590971160000,"0.02455","0.02456","0.02453","0.02454",286],
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public aggregate trades)
    //
    //     {
    //         "a":"1658318071",    // Aggregate tradeId
    //         "p":"0.02476",       // Price
    //         "q":"0.0",           // Official doc says: "Quantity (should be ignored)"
    //         "T":"1591001423382", // Epoch timestamp in MS
    //         "m":false            // Was the buyer the maker
    //     }
    //
    // createOrder fills (private)
    //
    //     {
    //         "price": "9807.05",
    //         "qty": "0.01",
    //         "commission": "0",
    //         "commissionAsset": "dUSD"
    //     }
    //
    // fetchMyTrades
    //
    //     {
    //         "symbol": "DOGE/USD",
    //         "id": "116046000",
    //         "orderId": "00000000-0000-0000-0000-000006dbb8ad",
    //         "price": "0.14094",
    //         "qty": "40.0",
    //         "commission": "0.01",
    //         "commissionAsset": "USD",
    //         "time": "1645283022351",
    //         "buyer": false,
    //         "maker": false,
    //         "isBuyer": false,
    //         "isMaker": false
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "T", "time")
    var priceString interface{} = this.SafeString2(trade, "p", "price")
    var amountString interface{} = this.SafeString2(trade, "q", "qty")
    var id interface{} = this.SafeString2(trade, "a", "id")
    var side interface{} = nil
    var orderId interface{} = this.SafeString(trade, "orderId")
    var takerOrMaker interface{} = nil
    if IsTrue(InOp(trade, "m")) {
        side = Ternary(IsTrue(GetValue(trade, "m")), "sell", "buy") // this is reversed intentionally [TODO: needs reason to be mentioned]
        takerOrMaker = "taker" // in public trades, it's always taker
    } else if IsTrue(InOp(trade, "isBuyer")) {
        side = Ternary(IsTrue((GetValue(trade, "isBuyer"))), "buy", "sell") // this is a true side
        takerOrMaker = Ternary(IsTrue(GetValue(trade, "isMaker")), "maker", "taker")
    }
    var fee interface{} = nil
    if IsTrue(InOp(trade, "commission")) {
        fee = map[string]interface{} {
            "cost": this.SafeString(trade, "commission"),
            "currency": this.SafeCurrencyCode(this.SafeString(trade, "commissionAsset")),
        }
    }
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name currencycom#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/aggTradesUsingGET
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *currencycom) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes11828 := (<-this.LoadMarkets())
            PanicOnError(retRes11828)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000)) // default 500, max 1000
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
        
            response:= (<-this.PublicGetV2AggTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //         "a":"1658318071",    // Aggregate tradeId
            //         "p":"0.02476",       // Price
            //         "q":"0.0",           // Official doc says: "Quantity (should be ignored)"
            //         "T":"1591001423382", // Epoch timestamp in MS
            //         "m":false            // Was the buyer the maker
            //     },
            // ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    // limit
    //
    //     {
    //         "symbol": "BTC/USD",
    //         "orderId": "00000000-0000-0000-0000-000006eacaa0",
    //         "transactTime": "1645281669295",
    //         "price": "30000.00000000",
    //         "origQty": "0.0002",     // might not be present for "market" order
    //         "executedQty": "0.0",    // positive for BUY, negative for SELL. This property might not be present in Leverage markets
    //         "margin": 0.1,           // present in leverage markets
    //         "status": "NEW",         // NEW, FILLED, ...
    //         "timeInForce": "GTC",
    //         "type": "LIMIT",         // LIMIT, MARKET
    //         "side": "BUY",
    //         "fills": [               // this field might not be present if there were no fills
    //             {
    //                 "price": "0.14094",
    //                 "qty": "40.0",
    //                 "commission": "0",
    //                 "commissionAsset": "dUSD",
    //             },
    //         ],
    //     }
    //
    // fetchOrder (fetchOpenOrders is an array same structure, with some extra fields)
    //
    //    {
    //        "symbol": "BTC/USD_LEVERAGE",
    //        "accountId": "123456789012345678",
    //        "orderId": "00a01234-0123-54c4-0000-123451234567",
    //        "price": "25779.35",
    //        "status": "MODIFIED",
    //        "type": "LIMIT",
    //        "timeInForceType": "GTC",
    //        "side": "BUY",
    //        "guaranteedStopLoss": false,
    //        "trailingStopLoss": false,
    //        "margin": "0.05",
    //        "takeProfit": "27020.00",
    //        "stopLoss": "24500.35",
    //        "fills": [], // might not be present
    //        "timestamp": "1685958369623",  // "time" in "fetchOpenOrders"
    //        "expireTime": "1686167960000", // "expireTimestamp" in "fetchOpenOrders"
    //        "quantity": "0.00040", // "origQty" in "fetchOpenOrders"
    //        "executedQty": "0.0", // present in "fetchOpenOrders"
    //        "updateTime": "1685958369542", // present in "fetchOpenOrders"
    //        "leverage": true, // present in "fetchOpenOrders"
    //        "working": true // present in "fetchOpenOrders"
    //    }
    //
    // cancelOrder
    //
    //     {
    //         "symbol": "DOGE/USD",
    //         "orderId": "00000000-0000-0003-0000-000006db714c",
    //         "price": "0.13",
    //         "origQty": "30.0",
    //         "executedQty": "0.0",
    //         "status": "CANCELED",
    //         "timeInForce": "GTC",
    //         "type": "LIMIT",
    //         "side": "BUY",
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var id interface{} = this.SafeString(order, "orderId")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString2(order, "origQty", "quantity")
    var filledRaw interface{} = this.SafeString(order, "executedQty")
    var filled interface{} = Precise.StringAbs(filledRaw)
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var timeInForce interface{} = this.ParseOrderTimeInForce(this.SafeString2(order, "timeInForce", "timeInForceType"))
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "type"))
    var side interface{} = this.ParseOrderSide(this.SafeString(order, "side"))
    var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"time", "transactTime", "timestamp"})
    var fills interface{} = this.SafeValue(order, "fills")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": fills,
    }, market)
}
func  (this *currencycom) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "CREATED": "open",
        "MODIFIED": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "PENDING_CANCEL": "canceling",
        "REJECTED": "rejected",
        "EXPIRED": "expired",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *currencycom) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "STOP": "stop",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *currencycom) ParseOrderTimeInForce(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "GTC": "GTC",
        "FOK": "FOK",
        "IOC": "IOC",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *currencycom) ParseOrderSide(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "BUY": "buy",
        "SELL": "sell",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name currencycom#createOrder
 * @description create a trade order
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/orderUsingPOST
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *currencycom) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13748 := (<-this.LoadMarkets())
            PanicOnError(retRes13748)
            var market interface{} = this.Market(symbol)
            var accountId interface{} = nil
            if IsTrue(GetValue(market, "margin")) {
                accountId = this.SafeString(this.Options, "accountId")
                accountId = this.SafeString(params, "accountId", accountId)
                if IsTrue(IsEqual(accountId, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires an accountId parameter or an exchange.options[\\'accountId\\'] option for "), GetValue(market, "type")), " markets")))
                }
            }
            var newOrderRespType interface{} = this.SafeValue(GetValue(this.Options, "newOrderRespType"), typeVar, "RESULT")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "quantity": this.AmountToPrecision(symbol, amount),
                "type": ToUpper(typeVar),
                "side": ToUpper(side),
                "newOrderRespType": newOrderRespType,
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "timeInForce", GetValue(this.Options, "defaultTimeInForce"))
            } else {
                if IsTrue(IsEqual(typeVar, "stop")) {
                    AddElementToObject(request, "type", "STOP")
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                } else if IsTrue(IsEqual(typeVar, "market")) {
                    var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
                    params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice"})
                    if IsTrue(!IsEqual(triggerPrice, nil)) {
                        AddElementToObject(request, "type", "STOP")
                        AddElementToObject(request, "price", this.PriceToPrecision(symbol, triggerPrice))
                    }
                }
            }
        
            response:= (<-this.PrivatePostV2Order(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // limit
            //
            //     {
            //         "symbol": "BTC/USD",
            //         "orderId": "00000000-0000-0000-0000-000006eaaaa0",
            //         "transactTime": "1645281669295",
            //         "price": "30000.00000000",
            //         "origQty": "0.0002",
            //         "executedQty": "0.0",  // positive for BUY, negative for SELL
            //         "status": "NEW",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "side": "BUY",
            //     }
            //
            // market
            //
            //     {
            //         "symbol": "DOGE/USD",
            //         "orderId": "00000000-0000-0000-0000-000006eab8ad",
            //         "transactTime": "1645283022252",
            //         "price": "0.14066000",
            //         "origQty": "40",
            //         "executedQty": "40.0",  // positive for BUY, negative for SELL
            //         "status": "FILLED",
            //         "timeInForce": "FOK",
            //         "type": "MARKET",
            //         "side": "BUY",
            //         "fills": [
            //             {
            //                 "price": "0.14094",
            //                 "qty": "40.0",
            //                 "commission": "0",
            //                 "commissionAsset": "dUSD"
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getOrderUsingGET
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *currencycom) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes14708 := (<-this.LoadMarkets())
            PanicOnError(retRes14708)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "orderId": id,
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetV2FetchOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "accountId": "109698017413125316",
            //        "orderId": "2810f1c5-0079-54c4-0000-000080421601",
            //        "quantity": "20.0",
            //        "price": "0.06",
            //        "timestamp": "1661157503788",
            //        "status": "CREATED",
            //        "type": "LIMIT",
            //        "timeInForceType": "GTC",
            //        "side": "BUY",
            //        "margin": "0.1",
            //        "fills": [ // might not be present
            //             {
            //                 "price": "0.14094",
            //                 "qty": "40.0",
            //                 "commission": "0",
            //                 "commissionAsset": "dUSD"
            //             }
            //        ]
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/openOrdersUsingGET
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *currencycom) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15148 := (<-this.LoadMarkets())
            PanicOnError(retRes15148)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            } else if IsTrue(GetValue(this.Options, "warnOnFetchOpenOrdersWithoutSymbol")) {
                var symbols interface{} = this.Symbols
                var numSymbols interface{} =         GetArrayLength(symbols)
                var fetchOpenOrdersRateLimit interface{} = this.ParseToInt(Divide(numSymbols, 2))
                panic(ExchangeError(Add(Add(Add(Add(Add(this.Id, " fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "), ToString(fetchOpenOrdersRateLimit)), " seconds. Do not call this method frequently to avoid ban. Set "), this.Id), ".options[\"warnOnFetchOpenOrdersWithoutSymbol\"] = false to suppress this warning message.")))
            }
        
            response:= (<-this.PrivateGetV2OpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "DOGE/USD",
            //             "orderId": "00000000-0000-0003-0000-000004bac57a",
            //             "price": "0.13",
            //             "origQty": "39.0",
            //             "executedQty": "0.0",  // positive for BUY, negative for SELL
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "time": "1645284216240",
            //             "updateTime": "1645284216240",
            //             "leverage": false,
            //             "working": true
            //         },
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#cancelOrder
 * @description cancels an open order
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/cancelOrderUsingDELETE
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *currencycom) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes15638 := (<-this.LoadMarkets())
            PanicOnError(retRes15638)
            var market interface{} = this.Market(symbol)
            var origClientOrderId interface{} = this.SafeValue(params, "origClientOrderId")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(IsEqual(origClientOrderId, nil)) {
                AddElementToObject(request, "orderId", id)
            } else {
                AddElementToObject(request, "origClientOrderId", origClientOrderId)
            }
        
            response:= (<-this.PrivateDeleteV2Order(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "symbol": "DOGE/USD",
            //         "orderId": "00000000-0000-0003-0000-000006db764c",
            //         "price": "0.13",
            //         "origQty": "30.0",
            //         "executedQty": "0.0",  // positive for BUY, negative for SELL
            //         "status": "CANCELED",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "side": "BUY",
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/myTradesUsingGET
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *currencycom) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes16088 := (<-this.LoadMarkets())
            PanicOnError(retRes16088)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetV2MyTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "DOGE/USD",
            //             "id": "116046000",
            //             "orderId": "00000000-0000-0000-0000-000006dbb8ad",
            //             "price": "0.14094",
            //             "qty": "40.0",
            //             "commission": "0.01",
            //             "commissionAsset": "USD",
            //             "time": "1645283022351",
            //             "buyer": false,
            //             "maker": false,
            //             "isBuyer": false,
            //             "isMaker": false
            //         },
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getDepositsUsingGET
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *currencycom) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes165015 :=  (<-this.FetchTransactionsByMethod("privateGetV2Deposits", code, since, limit, params))
                PanicOnError(retRes165015)
                ch <- retRes165015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getWithdrawalsUsingGET
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *currencycom) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes166515 :=  (<-this.FetchTransactionsByMethod("privateGetV2Withdrawals", code, since, limit, params))
                PanicOnError(retRes166515)
                ch <- retRes166515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name currencycom#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getTransactionsUsingGET
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *currencycom) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes168015 :=  (<-this.FetchTransactionsByMethod("privateGetV2Transactions", code, since, limit, params))
                PanicOnError(retRes168015)
                ch <- retRes168015
                return nil
        
            }()
            return ch
        }
func  (this *currencycom) FetchTransactionsByMethod(method interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16848 := (<-this.LoadMarkets())
            PanicOnError(retRes16848)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(method, "privateGetV2Deposits")) {
                
        response = (<-this.PrivateGetV2Deposits(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "privateGetV2Withdrawals")) {
                
        response = (<-this.PrivateGetV2Withdrawals(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "privateGetV2Transactions")) {
                
        response = (<-this.PrivateGetV2Transactions(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchTransactionsByMethod() not support this method")))
            }
        
                //
            //    [
            //        {
            //            "id": "616769213",
            //            "balance": "2.088",
            //            "amount": "1.304",   // negative for 'withdrawal'
            //            "currency": "CAKE",
            //            "type": "deposit",
            //            "timestamp": "1645282121023",
            //            "paymentMethod": "BLOCKCHAIN",
            //            "blockchainTransactionHash": "0x57c68c1f2ae74d5eda5a2a00516361d241a5c9e1ee95bf32573523857c38c112",
            //            "status": "PROCESSED",
            //            "commission": "0.14", // this property only exists in withdrawal
            //        },
            //    ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": "616769213",
    //        "balance": "2.088",
    //        "amount": "1.304",   // negative for 'withdrawal'
    //        "currency": "CAKE",
    //        "type": "deposit",
    //        "timestamp": "1645282121023",
    //        "paymentMethod": "BLOCKCHAIN",
    //        "blockchainTransactionHash": "0x57c68c1f2ae74d5eda5a2a00516361d241a5c9e1ee95bf32573523857c38c112",
    //        "status": "PROCESSED",
    //        "commission": "0.14", // this property only exists in withdrawal
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transaction, "timestamp")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var feeCost interface{} = this.SafeString(transaction, "commission")
    var fee interface{} = map[string]interface{} {
        "currency": nil,
        "cost": nil,
        "rate": nil,
    }
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "currency", code)
        AddElementToObject(fee, "cost", feeCost)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "blockchainTransactionHash"),
        "type": this.ParseTransactionType(this.SafeString(transaction, "type")),
        "currency": code,
        "network": nil,
        "amount": this.SafeNumber(transaction, "amount"),
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "state")),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": nil,
        "addressTo": nil,
        "tag": nil,
        "tagFrom": nil,
        "tagTo": nil,
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": fee,
    }
}
func  (this *currencycom) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "APPROVAL": "pending",
        "PROCESSED": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *currencycom) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "deposit": "deposit",
        "withdrawal": "withdrawal",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name currencycom#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getLedgerUsingGET
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *currencycom) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18058 := (<-this.LoadMarkets())
            PanicOnError(retRes18058)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetV2Ledger(this.Extend(request, params)))
            PanicOnError(response)
        
                // in the below example, first item expresses withdrawal/deposit type, second example expresses trade
            //
            // [
            //     {
            //       "id": "619031398",
            //       "balance": "0.0",
            //       "amount": "-1.088",
            //       "currency": "CAKE",
            //       "type": "withdrawal",
            //       "timestamp": "1645460496425",
            //       "commission": "0.13",
            //       "paymentMethod": "BLOCKCHAIN", // present in withdrawal/deposit
            //       "blockchainTransactionHash": "0x400ac905557c3d34638b1c60eba110b3ee0f97f4eb0f7318015ab76e7f16b7d6", // present in withdrawal/deposit
            //       "status": "PROCESSED"
            //     },
            //     {
            //       "id": "619031034",
            //       "balance": "8.17223588",
            //       "amount": "-0.01326294",
            //       "currency": "USD",
            //       "type": "exchange_commission",
            //       "timestamp": "1645460461235",
            //       "commission": "0.01326294",
            //       "status": "PROCESSED"
            //     },
            // ]
            //
        ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "id")
    var amountString interface{} = this.SafeString(item, "amount")
    var amount interface{} = Precise.StringAbs(amountString)
    var timestamp interface{} = this.SafeInteger(item, "timestamp")
    var currencyId interface{} = this.SafeString(item, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var feeCost interface{} = this.SafeString(item, "commission")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    var direction interface{} = Ternary(IsTrue(Precise.StringLt(amountString, "0")), "out", "in")
    return this.SafeLedgerEntry(map[string]interface{} {
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "direction": direction,
        "account": nil,
        "referenceId": this.SafeString(item, "blockchainTransactionHash"),
        "referenceAccount": nil,
        "type": this.ParseLedgerEntryType(this.SafeString(item, "type")),
        "currency": code,
        "amount": amount,
        "before": nil,
        "after": this.SafeString(item, "balance"),
        "status": this.ParseLedgerEntryStatus(this.SafeString(item, "status")),
        "fee": fee,
        "info": item,
    }, currency)
}
func  (this *currencycom) ParseLedgerEntryStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "APPROVAL": "pending",
        "PROCESSED": "ok",
        "CANCELLED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *currencycom) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "deposit": "transaction",
        "withdrawal": "transaction",
        "exchange_commission": "fee",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name currencycom#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/leverageSettingsUsingGET
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *currencycom) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19098 := (<-this.LoadMarkets())
            PanicOnError(retRes19098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetV2LeverageSettings(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "values": [ 1, 2, 5, 10, ],
            //         "value": "10",
            //     }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var leverageValue interface{} = this.SafeInteger(leverage, "value")
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": nil,
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name currencycom#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/getDepositAddressUsingGET
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *currencycom) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19458 := (<-this.LoadMarkets())
            PanicOnError(retRes19458)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivateGetV2DepositAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     { "address":"0x97d64eb014ac779194991e7264f01c74c90327f0" }
            //
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    currency = this.SafeCurrency(nil, currency)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": GetValue(currency, "code"),
        "network": nil,
        "address": address,
        "tag": nil,
    }
}
func  (this *currencycom) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsEqual(path, "historicalTrades")) {
        headers = map[string]interface{} {
            "X-MBX-APIKEY": this.ApiKey,
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var query interface{} = this.Urlencode(this.Extend(map[string]interface{} {
            "timestamp": this.Nonce(),
            "recvWindow": GetValue(this.Options, "recvWindow"),
        }, params))
        var signature interface{} = this.Hmac(this.Encode(query), this.Encode(this.Secret), sha256)
        query = Add(query, Add(Add("&", "signature="), signature))
        headers = map[string]interface{} {
            "X-MBX-APIKEY": this.ApiKey,
        }
        if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
            url = Add(url, Add("?", query))
        } else {
            body = query
            AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
        }
    } else {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    url = this.ImplodeHostname(url)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
/**
 * @method
 * @name currencycom#fetchPositions
 * @description fetch all open positions
 * @see https://apitradedoc.currency.com/swagger-ui.html#/rest-api/tradingPositionsUsingGET
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *currencycom) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20138 := (<-this.LoadMarkets())
            PanicOnError(retRes20138)
        
            response:= (<-this.PrivateGetV2TradingPositions(params))
            PanicOnError(response)
            //
            //    {
            //        "positions": [
            //          {
            //            "accountId": "109698017416453793",
            //            "id": "00a18490-0079-54c4-0000-0000803e73d3",
            //            "instrumentId": "45463225268524228",
            //            "orderId": "00a18490-0079-54c4-0000-0000803e73d2",
            //            "openQuantity": "13.6",
            //            "openPrice": "0.75724",
            //            "closeQuantity": "0.0",
            //            "closePrice": "0",
            //            "rpl": "-0.007723848",
            //            "rplConverted": "0",
            //            "upl": "-0.006664",
            //            "uplConverted": "-0.006664",
            //            "swap": "0",
            //            "swapConverted": "0",
            //            "fee": "-0.007723848",
            //            "dividend": "0",
            //            "margin": "0.2",
            //            "state": "ACTIVE",
            //            "currency": "USD",
            //            "createdTimestamp": "1645473877236",
            //            "openTimestamp": "1645473877193",
            //            "type": "NET",
            //            "cost": "2.0583600",
            //            "symbol": "XRP/USD_LEVERAGE"
            //          }
            //        ]
            //    }
            //
            var data interface{} = this.SafeList(response, "positions", []interface{}{})
        
            ch <- this.ParsePositions(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *currencycom) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "accountId": "109698017416453793",
    //        "id": "00a18490-0079-54c4-0000-0000803e73d3",
    //        "instrumentId": "45463225268524228",
    //        "orderId": "00a18490-0079-54c4-0000-0000803e73d2",
    //        "openQuantity": "13.6",
    //        "openPrice": "0.75724",
    //        "closeQuantity": "0.0",
    //        "closePrice": "0",
    //        "rpl": "-0.007723848",
    //        "rplConverted": "0",
    //        "upl": "-0.006664",
    //        "uplConverted": "-0.006664",
    //        "swap": "0",
    //        "swapConverted": "0",
    //        "fee": "-0.007723848",
    //        "dividend": "0",
    //        "margin": "0.2",
    //        "state": "ACTIVE",
    //        "currency": "USD",
    //        "createdTimestamp": "1645473877236",
    //        "openTimestamp": "1645473877193",
    //        "type": "NET",
    //        "cost": "2.0583600",
    //        "symbol": "XRP/USD_LEVERAGE"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(this.SafeString(position, "symbol"), market)
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(position, "createdTimestamp")
    var quantityRaw interface{} = this.SafeString(position, "openQuantity")
    var side interface{} = Ternary(IsTrue(Precise.StringGt(quantityRaw, "0")), "long", "short")
    var quantity interface{} = Precise.StringAbs(quantityRaw)
    var entryPrice interface{} = this.SafeNumber(position, "openPrice")
    var unrealizedProfit interface{} = this.SafeNumber(position, "upl")
    var marginCoeff interface{} = this.SafeString(position, "margin")
    var leverage interface{} = Precise.StringDiv("1", marginCoeff)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "contracts": this.ParseNumber(quantity),
        "contractSize": nil,
        "entryPrice": entryPrice,
        "collateral": nil,
        "side": side,
        "unrealizedPnl": unrealizedProfit,
        "leverage": leverage,
        "percentage": nil,
        "marginMode": nil,
        "notional": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "liquidationPrice": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": this.ParseNumber(marginCoeff),
        "maintenanceMarginPercentage": nil,
        "marginRatio": nil,
        "id": nil,
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
func  (this *currencycom) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsTrue((IsEqual(httpCode, 418))) || IsTrue((IsEqual(httpCode, 429)))) {
        panic(DDoSProtection(Add(Add(Add(Add(Add(Add(this.Id, " "), ToString(httpCode)), " "), reason), " "), body)))
    }
    // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
    // following block cointains legacy checks against message patterns in "msg" property
    // will switch "code" checks eventually, when we know all of them
    if IsTrue(IsGreaterThanOrEqual(httpCode, 400)) {
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "Price * QTY is zero or less"), 0)) {
            panic(InvalidOrder(Add(Add(this.Id, " order cost = amount * price is zero or less "), body)))
        }
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "LOT_SIZE"), 0)) {
            panic(InvalidOrder(Add(Add(this.Id, " order amount should be evenly divisible by lot size "), body)))
        }
        if IsTrue(IsGreaterThanOrEqual(GetIndexOf(body, "PRICE_FILTER"), 0)) {
            panic(InvalidOrder(Add(Add(this.Id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) "), body)))
        }
    }
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"code":-1128,"msg":"Combination of optional parameters invalid."}
    //
    var errorCode interface{} = this.SafeString(response, "code")
    if IsTrue(IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "0")))) {
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        var message interface{} = this.SafeString(response, "msg")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *currencycom) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
