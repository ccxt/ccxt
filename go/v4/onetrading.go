package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type onetrading struct {
    Exchange

}

func NewOnetradingCore() onetrading {
   p := onetrading{}
   setDefaults(&p)
   return p
}

func  (this *onetrading) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "onetrading",
        "name": "One Trading",
        "countries": []interface{}{"AT"},
        "rateLimit": 300,
        "version": "v1",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": false,
            "createStopOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": false,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1/MINUTES",
            "5m": "5/MINUTES",
            "15m": "15/MINUTES",
            "30m": "30/MINUTES",
            "1h": "1/HOURS",
            "4h": "4/HOURS",
            "1d": "1/DAYS",
            "1w": "1/WEEKS",
            "1M": "1/MONTHS",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/bdbc26fd-02f2-4ca7-9f1e-17333690bb1c",
            "api": map[string]interface{} {
                "public": "https://api.onetrading.com/fast",
                "private": "https://api.onetrading.com/fast",
            },
            "www": "https://onetrading.com/",
            "doc": []interface{}{"https://docs.onetrading.com"},
            "fees": "https://onetrading.com/fees",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"currencies", "candlesticks/{instrument_code}", "fees", "instruments", "order-book/{instrument_code}", "market-ticker", "market-ticker/{instrument_code}", "time"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"account/balances", "account/fees", "account/orders", "account/orders/{order_id}", "account/orders/{order_id}/trades", "account/trades", "account/trades/{trade_id}"},
                "post": []interface{}{"account/orders"},
                "delete": []interface{}{"account/orders", "account/orders/{order_id}", "account/orders/client/{client_id}"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.0015"),
                "maker": this.ParseNumber("0.001"),
                "tiers": []interface{}{map[string]interface{} {
    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.00075")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.00065")}},
    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.00075")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0005")}},
}},
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": false,
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "INVALID_CLIENT_UUID": InvalidOrder,
                "ORDER_NOT_FOUND": OrderNotFound,
                "ONLY_ONE_ERC20_ADDRESS_ALLOWED": InvalidAddress,
                "DEPOSIT_ADDRESS_NOT_USED": InvalidAddress,
                "INVALID_CREDENTIALS": AuthenticationError,
                "MISSING_CREDENTIALS": AuthenticationError,
                "INVALID_APIKEY": AuthenticationError,
                "INVALID_SCOPES": AuthenticationError,
                "INVALID_SUBJECT": AuthenticationError,
                "INVALID_ISSUER": AuthenticationError,
                "INVALID_AUDIENCE": AuthenticationError,
                "INVALID_DEVICE_ID": AuthenticationError,
                "INVALID_IP_RESTRICTION": AuthenticationError,
                "APIKEY_REVOKED": AuthenticationError,
                "APIKEY_EXPIRED": AuthenticationError,
                "SYNCHRONIZER_TOKEN_MISMATCH": AuthenticationError,
                "SESSION_EXPIRED": AuthenticationError,
                "INTERNAL_ERROR": AuthenticationError,
                "CLIENT_IP_BLOCKED": PermissionDenied,
                "MISSING_PERMISSION": PermissionDenied,
                "ILLEGAL_CHARS": BadRequest,
                "UNSUPPORTED_MEDIA_TYPE": BadRequest,
                "ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG": BadRequest,
                "CANDLESTICKS_TIME_RANGE_TOO_BIG": BadRequest,
                "INVALID_INSTRUMENT_CODE": BadRequest,
                "INVALID_ORDER_TYPE": BadRequest,
                "INVALID_UNIT": BadRequest,
                "INVALID_PERIOD": BadRequest,
                "INVALID_TIME": BadRequest,
                "INVALID_DATE": BadRequest,
                "INVALID_CURRENCY": BadRequest,
                "INVALID_AMOUNT": BadRequest,
                "INVALID_PRICE": BadRequest,
                "INVALID_LIMIT": BadRequest,
                "INVALID_QUERY": BadRequest,
                "INVALID_CURSOR": BadRequest,
                "INVALID_ACCOUNT_ID": BadRequest,
                "INVALID_SIDE": InvalidOrder,
                "INVALID_ACCOUNT_HISTORY_FROM_TIME": BadRequest,
                "INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE": BadRequest,
                "INVALID_ACCOUNT_HISTORY_TIME_PERIOD": BadRequest,
                "INVALID_ACCOUNT_HISTORY_TO_TIME": BadRequest,
                "INVALID_CANDLESTICKS_GRANULARITY": BadRequest,
                "INVALID_CANDLESTICKS_UNIT": BadRequest,
                "INVALID_ORDER_BOOK_DEPTH": BadRequest,
                "INVALID_ORDER_BOOK_LEVEL": BadRequest,
                "INVALID_PAGE_CURSOR": BadRequest,
                "INVALID_TIME_RANGE": BadRequest,
                "INVALID_TRADE_ID": BadRequest,
                "INVALID_UI_ACCOUNT_SETTINGS": BadRequest,
                "NEGATIVE_AMOUNT": InvalidOrder,
                "NEGATIVE_PRICE": InvalidOrder,
                "MIN_SIZE_NOT_SATISFIED": InvalidOrder,
                "BAD_AMOUNT_PRECISION": InvalidOrder,
                "BAD_PRICE_PRECISION": InvalidOrder,
                "BAD_TRIGGER_PRICE_PRECISION": InvalidOrder,
                "MAX_OPEN_ORDERS_EXCEEDED": BadRequest,
                "MISSING_PRICE": InvalidOrder,
                "MISSING_ORDER_TYPE": InvalidOrder,
                "MISSING_SIDE": InvalidOrder,
                "MISSING_CANDLESTICKS_PERIOD_PARAM": ArgumentsRequired,
                "MISSING_CANDLESTICKS_UNIT_PARAM": ArgumentsRequired,
                "MISSING_FROM_PARAM": ArgumentsRequired,
                "MISSING_INSTRUMENT_CODE": ArgumentsRequired,
                "MISSING_ORDER_ID": InvalidOrder,
                "MISSING_TO_PARAM": ArgumentsRequired,
                "MISSING_TRADE_ID": ArgumentsRequired,
                "INVALID_ORDER_ID": OrderNotFound,
                "NOT_FOUND": OrderNotFound,
                "INSUFFICIENT_LIQUIDITY": InsufficientFunds,
                "INSUFFICIENT_FUNDS": InsufficientFunds,
                "NO_TRADING": ExchangeNotAvailable,
                "SERVICE_UNAVAILABLE": ExchangeNotAvailable,
                "GATEWAY_TIMEOUT": ExchangeNotAvailable,
                "RATELIMIT": DDoSProtection,
                "CF_RATELIMIT": DDoSProtection,
                "INTERNAL_SERVER_ERROR": ExchangeError,
            },
            "broad": map[string]interface{} {
                "Order not found.": OrderNotFound,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "MIOTA": "IOTA",
        },
        "options": map[string]interface{} {
            "fetchTradingFees": map[string]interface{} {
                "method": "fetchPrivateTradingFees",
            },
            "fiat": []interface{}{"EUR", "CHF"},
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": Divide(1, 12),
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 5000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name onetrading#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.onetrading.com/#time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *onetrading) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "iso": "2020-07-10T05:17:26.716Z",
            //         "epoch_millis": 1594358246716,
            //     }
            //
        ch <- this.SafeInteger(response, "epoch_millis")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.onetrading.com/#currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *onetrading) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencies(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "code":"BEST",
            //             "precision":8
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "code")
                var code interface{} = this.SafeCurrencyCode(id)
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "name": nil,
            "info": currency,
            "active": nil,
            "fee": nil,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "precision"))),
            "withdraw": nil,
            "deposit": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchMarkets
 * @description retrieves data on all markets for onetrading
 * @see https://docs.onetrading.com/#instruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *onetrading) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetInstruments(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "state": "ACTIVE",
            //             "base": { code: "ETH", precision: 8 },
            //             "quote": { code: "CHF", precision: 2 },
            //             "amount_precision": 4,
            //             "market_precision": 2,
            //             "min_size": "10.0"
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) ParseMarket(market interface{}) interface{}  {
    var baseAsset interface{} = this.SafeValue(market, "base", map[string]interface{} {})
    var quoteAsset interface{} = this.SafeValue(market, "quote", map[string]interface{} {})
    var baseId interface{} = this.SafeString(baseAsset, "code")
    var quoteId interface{} = this.SafeString(quoteAsset, "code")
    var id interface{} = Add(Add(baseId, "_"), quoteId)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var state interface{} = this.SafeString(market, "state")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsEqual(state, "ACTIVE")),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount_precision"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "market_precision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_size"),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name onetrading#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.onetrading.com/#fee-groups
 * @see https://docs.onetrading.com/#fees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *onetrading) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var method interface{} = this.SafeString(params, "method")
            params = this.Omit(params, "method")
            if IsTrue(IsEqual(method, nil)) {
                var options interface{} = this.SafeValue(this.Options, "fetchTradingFees", map[string]interface{} {})
                method = this.SafeString(options, "method", "fetchPrivateTradingFees")
            }
            if IsTrue(IsEqual(method, "fetchPrivateTradingFees")) {
        
                    retRes53019 :=  (<-this.FetchPrivateTradingFees(params))
                    PanicOnError(retRes53019)
                    ch <- retRes53019
                    return nil
            } else if IsTrue(IsEqual(method, "fetchPublicTradingFees")) {
        
                    retRes53219 :=  (<-this.FetchPublicTradingFees(params))
                    PanicOnError(retRes53219)
                    ch <- retRes53219
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTradingFees() does not support "), method), ", fetchPrivateTradingFees and fetchPublicTradingFees are supported")))
            }
                return nil
            }()
            return ch
        }
func  (this *onetrading) FetchPublicTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5398 := (<-this.LoadMarkets())
            PanicOnError(retRes5398)
        
            response:= (<-this.PublicGetFees(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "fee_group_id":"default",
            //             "display_text":"The standard fee plan.",
            //             "fee_tiers":[
            //                 {"volume":"0.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.15"},
            //                 {"volume":"100.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.13"},
            //                 {"volume":"250.0","fee_group_id":"default","maker_fee":"0.09","taker_fee":"0.13"},
            //                 {"volume":"1000.0","fee_group_id":"default","maker_fee":"0.075","taker_fee":"0.1"},
            //                 {"volume":"5000.0","fee_group_id":"default","maker_fee":"0.06","taker_fee":"0.09"},
            //                 {"volume":"10000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.075"},
            //                 {"volume":"20000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.065"}
            //             ],
            //             "fee_discount_rate":"25.0",
            //             "minimum_price_value":"0.12"
            //         }
            //     ]
            //
            var first interface{} = this.SafeValue(response, 0, map[string]interface{} {})
            var feeTiers interface{} = this.SafeValue(first, "fee_tiers")
            var tiers interface{} = this.ParseFeeTiers(feeTiers)
            var firstTier interface{} = this.SafeValue(feeTiers, 0, map[string]interface{} {})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": first,
            "symbol": symbol,
            "maker": this.SafeNumber(firstTier, "maker_fee"),
            "taker": this.SafeNumber(firstTier, "taker_fee"),
            "percentage": true,
            "tierBased": true,
            "tiers": tiers,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) FetchPrivateTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5818 := (<-this.LoadMarkets())
            PanicOnError(retRes5818)
        
            response:= (<-this.PrivateGetAccountFees(params))
            PanicOnError(response)
            //
            //     {
            //         "account_id": "ed524d00-820a-11e9-8f1e-69602df16d85",
            //         "running_trading_volume": "0.0",
            //         "fee_group_id": "default",
            //         "collect_fees_in_best": false,
            //         "fee_discount_rate": "25.0",
            //         "minimum_price_value": "0.12",
            //         "fee_tiers": [
            //             { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" },
            //             { "volume": "100.0", "fee_group_id": "default", "maker_fee": "0.09", "taker_fee": "0.1" },
            //             { "volume": "250.0", "fee_group_id": "default", "maker_fee": "0.08", "taker_fee": "0.1" },
            //             { "volume": "1000.0", "fee_group_id": "default", "maker_fee": "0.07", "taker_fee": "0.09" },
            //             { "volume": "5000.0", "fee_group_id": "default", "maker_fee": "0.06", "taker_fee": "0.08" },
            //             { "volume": "10000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.07" },
            //             { "volume": "20000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.06" },
            //             { "volume": "50000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.05" }
            //         ],
            //         "active_fee_tier": { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" }
            //     }
            //
            var activeFeeTier interface{} = this.SafeValue(response, "active_fee_tier", map[string]interface{} {})
            var makerFee interface{} = this.SafeString(activeFeeTier, "maker_fee")
            var takerFee interface{} = this.SafeString(activeFeeTier, "taker_fee")
            makerFee = Precise.StringDiv(makerFee, "100")
            takerFee = Precise.StringDiv(takerFee, "100")
            var feeTiers interface{} = this.SafeValue(response, "fee_tiers")
            var result interface{} = map[string]interface{} {}
            var tiers interface{} = this.ParseFeeTiers(feeTiers)
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.ParseNumber(makerFee),
            "taker": this.ParseNumber(takerFee),
            "percentage": true,
            "tierBased": true,
            "tiers": tiers,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) ParseFeeTiers(feeTiers interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var takerFees interface{} = []interface{}{}
    var makerFees interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(feeTiers)); i++ {
        var tier interface{} = GetValue(feeTiers, i)
        var volume interface{} = this.SafeNumber(tier, "volume")
        var taker interface{} = this.SafeString(tier, "taker_fee")
        var maker interface{} = this.SafeString(tier, "maker_fee")
        maker = Precise.StringDiv(maker, "100")
        taker = Precise.StringDiv(taker, "100")
        AppendToArray(&makerFees,[]interface{}{volume, this.ParseNumber(maker)})
        AppendToArray(&takerFees,[]interface{}{volume, this.ParseNumber(taker)})
    }
    return map[string]interface{} {
        "maker": makerFees,
        "taker": takerFees,
    }
}
func  (this *onetrading) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker, fetchTickers
    //
    //     {
    //         "instrument_code":"BTC_EUR",
    //         "sequence":602562,
    //         "time":"2020-07-10T06:27:34.951Z",
    //         "state":"ACTIVE",
    //         "is_frozen":0,
    //         "quote_volume":"1695555.1783768",
    //         "base_volume":"205.67436",
    //         "last_price":"8143.91",
    //         "best_bid":"8143.71",
    //         "best_ask":"8156.9",
    //         "price_change":"-147.47",
    //         "price_change_percentage":"-1.78",
    //         "high":"8337.45",
    //         "low":"8110.0"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "time"))
    var marketId interface{} = this.SafeString(ticker, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var last interface{} = this.SafeString(ticker, "last_price")
    var percentage interface{} = this.SafeString(ticker, "price_change_percentage")
    var change interface{} = this.SafeString(ticker, "price_change")
    var baseVolume interface{} = this.SafeString(ticker, "base_volume")
    var quoteVolume interface{} = this.SafeString(ticker, "quote_volume")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "best_bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "best_ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name onetrading#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.onetrading.com/#market-ticker-for-instrument
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *onetrading) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7098 := (<-this.LoadMarkets())
            PanicOnError(retRes7098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_code": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketTickerInstrumentCode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "sequence":602562,
            //         "time":"2020-07-10T06:27:34.951Z",
            //         "state":"ACTIVE",
            //         "is_frozen":0,
            //         "quote_volume":"1695555.1783768",
            //         "base_volume":"205.67436",
            //         "last_price":"8143.91",
            //         "best_bid":"8143.71",
            //         "best_ask":"8156.9",
            //         "price_change":"-147.47",
            //         "price_change_percentage":"-1.78",
            //         "high":"8337.45",
            //         "low":"8110.0"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.onetrading.com/#market-ticker
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *onetrading) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7468 := (<-this.LoadMarkets())
            PanicOnError(retRes7468)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetMarketTicker(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "instrument_code":"BTC_EUR",
            //             "sequence":602562,
            //             "time":"2020-07-10T06:27:34.951Z",
            //             "state":"ACTIVE",
            //             "is_frozen":0,
            //             "quote_volume":"1695555.1783768",
            //             "base_volume":"205.67436",
            //             "last_price":"8143.91",
            //             "best_bid":"8143.71",
            //             "best_ask":"8156.9",
            //             "price_change":"-147.47",
            //             "price_change_percentage":"-1.78",
            //             "high":"8337.45",
            //             "low":"8110.0"
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(response, i))
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.onetrading.com/#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *onetrading) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7898 := (<-this.LoadMarkets())
            PanicOnError(retRes7898)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_code": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.PublicGetOrderBookInstrumentCode(this.Extend(request, params)))
            PanicOnError(response)
            //
            // level 1
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "time":"2020-07-10T07:39:06.343Z",
            //         "asks":{
            //             "value":{
            //                 "price":"8145.29",
            //                 "amount":"0.96538",
            //                 "number_of_orders":1
            //             }
            //         },
            //         "bids":{
            //             "value":{
            //                 "price":"8134.0",
            //                 "amount":"1.5978",
            //                 "number_of_orders":5
            //             }
            //         }
            //     }
            //
            // level 2
            //
            //     {
            //         "instrument_code":"BTC_EUR","time":"2020-07-10T07:36:43.538Z",
            //         "asks":[
            //             {"price":"8146.59","amount":"0.89691","number_of_orders":1},
            //             {"price":"8146.89","amount":"1.92062","number_of_orders":1},
            //             {"price":"8169.5","amount":"0.0663","number_of_orders":1},
            //         ],
            //         "bids":[
            //             {"price":"8143.49","amount":"0.01329","number_of_orders":1},
            //             {"price":"8137.01","amount":"5.34748","number_of_orders":1},
            //             {"price":"8137.0","amount":"2.0","number_of_orders":1},
            //         ]
            //     }
            //
            // level 3
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "time":"2020-07-10T07:32:31.525Z",
            //         "bids":[
            //             {"price":"8146.79","amount":"0.01537","order_id":"5d717da1-a8f4-422d-afcc-03cb6ab66825"},
            //             {"price":"8139.32","amount":"3.66009","order_id":"d0715c68-f28d-4cf1-a450-d56cf650e11c"},
            //             {"price":"8137.51","amount":"2.61049","order_id":"085fd6f4-e835-4ca5-9449-a8f165772e60"},
            //         ],
            //         "asks":[
            //             {"price":"8153.49","amount":"0.93384","order_id":"755d3aa3-42b5-46fa-903d-98f42e9ae6c4"},
            //             {"price":"8153.79","amount":"1.80456","order_id":"62034cf3-b70d-45ff-b285-ba6307941e7c"},
            //             {"price":"8167.9","amount":"0.0018","order_id":"036354e0-71cd-492f-94f2-01f7d4b66422"},
            //         ]
            //     }
            //
            var timestamp interface{} = this.Parse8601(this.SafeString(response, "time"))
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount")
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_code":"BTC_EUR",
    //         "granularity":{"unit":"HOURS","period":1},
    //         "high":"9252.65",
    //         "low":"9115.27",
    //         "open":"9250.0",
    //         "close":"9132.35",
    //         "total_amount":"33.85924",
    //         "volume":"311958.9635744",
    //         "time":"2020-05-08T22:59:59.999Z",
    //         "last_sequence":461123
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var granularity interface{} = this.SafeValue(ohlcv, "granularity")
    var unit interface{} = this.SafeString(granularity, "unit")
    var period interface{} = this.SafeString(granularity, "period")
    var units interface{} = map[string]interface{} {
        "MINUTES": "m",
        "HOURS": "h",
        "DAYS": "d",
        "WEEKS": "w",
        "MONTHS": "M",
    }
    var lowercaseUnit interface{} = this.SafeString(units, unit)
    var timeframe interface{} = Add(period, lowercaseUnit)
    var durationInSeconds interface{} = this.ParseTimeframe(timeframe)
    var duration interface{} = Multiply(durationInSeconds, 1000)
    var timestamp interface{} = this.Parse8601(this.SafeString(ohlcv, "time"))
    var alignedTimestamp interface{} = Multiply(duration, this.ParseToInt(Divide(timestamp, duration)))
    var options interface{} = this.SafeValue(this.Options, "fetchOHLCV", map[string]interface{} {})
    var volumeField interface{} = this.SafeString(options, "volume", "total_amount")
    return []interface{}{alignedTimestamp, this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, volumeField)}
}
/**
 * @method
 * @name onetrading#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.onetrading.com/#candlesticks
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *onetrading) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9198 := (<-this.LoadMarkets())
            PanicOnError(retRes9198)
            var market interface{} = this.Market(symbol)
            var periodUnit interface{} = this.SafeString(this.Timeframes, timeframe)
            periodunitVariable := Split(periodUnit, "/");
            period := GetValue(periodunitVariable,0);
            unit := GetValue(periodunitVariable,1)
            var durationInSeconds interface{} = this.ParseTimeframe(timeframe)
            var duration interface{} = Multiply(durationInSeconds, 1000)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 1500
            }
            var request interface{} = map[string]interface{} {
                "instrument_code": GetValue(market, "id"),
                "period": period,
                "unit": unit,
            }
            if IsTrue(IsEqual(since, nil)) {
                var now interface{} = this.Milliseconds()
                AddElementToObject(request, "to", this.Iso8601(now))
                AddElementToObject(request, "from", this.Iso8601(Subtract(now, Multiply(limit, duration))))
            } else {
                AddElementToObject(request, "from", this.Iso8601(since))
                AddElementToObject(request, "to", this.Iso8601(this.Sum(since, Multiply(limit, duration))))
            }
        
            response:= (<-this.PublicGetCandlesticksInstrumentCode(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9252.65","low":"9115.27","open":"9250.0","close":"9132.35","total_amount":"33.85924","volume":"311958.9635744","time":"2020-05-08T22:59:59.999Z","last_sequence":461123},
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9162.49","low":"9040.0","open":"9132.53","close":"9083.69","total_amount":"26.19685","volume":"238553.7812365","time":"2020-05-08T23:59:59.999Z","last_sequence":461376},
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9135.7","low":"9002.59","open":"9055.45","close":"9133.98","total_amount":"26.21919","volume":"238278.8724959","time":"2020-05-09T00:59:59.999Z","last_sequence":461521},
            //     ]
            //
            var ohlcv interface{} = this.SafeList(response, "candlesticks")
        
            ch <- this.ParseOHLCVs(ohlcv, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "instrument_code":"BTC_EUR",
    //         "price":"8137.28",
    //         "amount":"0.22269",
    //         "taker_side":"BUY",
    //         "volume":"1812.0908832",
    //         "time":"2020-07-10T14:44:32.299Z",
    //         "trade_timestamp":1594392272299,
    //         "sequence":603047
    //     }
    //
    // fetchMyTrades, fetchOrder, fetchOpenOrders, fetchClosedOrders trades (private)
    //
    //     {
    //         "fee": {
    //             "fee_amount": "0.0014",
    //             "fee_currency": "BTC",
    //             "fee_percentage": "0.1",
    //             "fee_group_id": "default",
    //             "fee_type": "TAKER",
    //             "running_trading_volume": "0.0"
    //         },
    //         "trade": {
    //             "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
    //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
    //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
    //             "amount": "1.4",
    //             "side": "BUY",
    //             "instrument_code": "BTC_EUR",
    //             "price": "7341.4",
    //             "time": "2019-09-27T15:05:32.564Z",
    //             "sequence": 48670
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var feeInfo interface{} = this.SafeValue(trade, "fee", map[string]interface{} {})
    trade = this.SafeValue(trade, "trade", trade)
    var timestamp interface{} = this.SafeInteger(trade, "trade_timestamp")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(this.SafeString(trade, "time"))
    }
    var side interface{} = this.SafeStringLower2(trade, "side", "taker_side")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var costString interface{} = this.SafeString(trade, "volume")
    var marketId interface{} = this.SafeString(trade, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var feeCostString interface{} = this.SafeString(feeInfo, "fee_amount")
    var takerOrMaker interface{} = nil
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(feeInfo, "fee_currency")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        var feeRateString interface{} = this.SafeString(feeInfo, "fee_percentage")
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
            "rate": feeRateString,
        }
        takerOrMaker = this.SafeStringLower(feeInfo, "fee_type")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString2(trade, "trade_id", "sequence"),
        "order": this.SafeString(trade, "order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *onetrading) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(response, "balances", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "currency_code")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name onetrading#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.onetrading.com/#balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *onetrading) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10618 := (<-this.LoadMarkets())
            PanicOnError(retRes10618)
        
            response:= (<-this.PrivateGetAccountBalances(params))
            PanicOnError(response)
        
                //
            //     {
            //         "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
            //         "balances":[
            //             {
            //                 "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
            //                 "currency_code":"BTC",
            //                 "change":"10.0",
            //                 "available":"10.0",
            //                 "locked":"0.0",
            //                 "sequence":142135994,
            //                 "time":"2020-07-01T10:57:32.959Z"
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "FILLED": "open",
        "FILLED_FULLY": "closed",
        "FILLED_CLOSED": "canceled",
        "FILLED_REJECTED": "rejected",
        "OPEN": "open",
        "REJECTED": "rejected",
        "CLOSED": "canceled",
        "FAILED": "failed",
        "STOP_TRIGGERED": "triggered",
        "DONE": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *onetrading) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
    //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
    //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
    //         "instrument_code": "BTC_EUR",
    //         "time": "2019-08-01T08:00:44.026Z",
    //         "side": "BUY",
    //         "price": "5000",
    //         "amount": "1",
    //         "filled_amount": "0.5",
    //         "type": "LIMIT",
    //         "time_in_force": "GOOD_TILL_CANCELLED"
    //     }
    //
    // fetchOrder, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "order": {
    //             "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
    //             "account_id": "1eb2ad5d-55f1-40b5-bc92-7dc05869e905",
    //             "instrument_code": "BTC_EUR",
    //             "amount": "1234.5678",
    //             "filled_amount": "1234.5678",
    //             "side": "BUY",
    //             "type": "LIMIT",
    //             "status": "OPEN",
    //             "sequence": 123456789,
    //             "price": "1234.5678",
    //             "average_price": "1234.5678",
    //             "reason": "INSUFFICIENT_FUNDS",
    //             "time": "2019-08-24T14:15:22Z",
    //             "time_in_force": "GOOD_TILL_CANCELLED",
    //             "time_last_updated": "2019-08-24T14:15:22Z",
    //             "expire_after": "2019-08-24T14:15:22Z",
    //             "is_post_only": false,
    //             "time_triggered": "2019-08-24T14:15:22Z",
    //             "trigger_price": "1234.5678"
    //         },
    //         "trades": [
    //             {
    //                 "fee": {
    //                     "fee_amount": "0.0014",
    //                     "fee_currency": "BTC",
    //                     "fee_percentage": "0.1",
    //                     "fee_group_id": "default",
    //                     "fee_type": "TAKER",
    //                     "running_trading_volume": "0.0"
    //                 },
    //                 "trade": {
    //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
    //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
    //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
    //                     "amount": "1.4",
    //                     "side": "BUY",
    //                     "instrument_code": "BTC_EUR",
    //                     "price": "7341.4",
    //                     "time": "2019-09-27T15:05:32.564Z",
    //                     "sequence": 48670
    //                 }
    //             }
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var rawOrder interface{} = this.SafeValue(order, "order", order)
    var id interface{} = this.SafeString(rawOrder, "order_id")
    var clientOrderId interface{} = this.SafeString(rawOrder, "client_id")
    var timestamp interface{} = this.Parse8601(this.SafeString(rawOrder, "time"))
    var rawStatus interface{} = this.ParseOrderStatus(this.SafeString(rawOrder, "status"))
    var status interface{} = this.ParseOrderStatus(rawStatus)
    var marketId interface{} = this.SafeString(rawOrder, "instrument_code")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var price interface{} = this.SafeString(rawOrder, "price")
    var amount interface{} = this.SafeString(rawOrder, "amount")
    var filled interface{} = this.SafeString(rawOrder, "filled_amount")
    var side interface{} = this.SafeStringLower(rawOrder, "side")
    var typeVar interface{} = this.SafeStringLower(rawOrder, "type")
    var timeInForce interface{} = this.ParseTimeInForce(this.SafeString(rawOrder, "time_in_force"))
    var postOnly interface{} = this.SafeValue(rawOrder, "is_post_only")
    var rawTrades interface{} = this.SafeValue(order, "trades", []interface{}{})
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": this.ParseOrderType(typeVar),
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": this.SafeNumber(rawOrder, "trigger_price"),
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "trades": rawTrades,
    }, market)
}
func  (this *onetrading) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "booked": "limit",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *onetrading) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "GOOD_TILL_CANCELLED": "GTC",
        "GOOD_TILL_TIME": "GTT",
        "IMMEDIATE_OR_CANCELLED": "IOC",
        "FILL_OR_KILL": "FOK",
    }
    return this.SafeString(timeInForces, timeInForce, timeInForce)
}
/**
 * @method
 * @name onetrading#createOrder
 * @description create a trade order
 * @see https://docs.onetrading.com/#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] onetrading only does stop limit orders and does not do stop market
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12388 := (<-this.LoadMarkets())
            PanicOnError(retRes12388)
            var market interface{} = this.Market(symbol)
            var uppercaseType interface{} = ToUpper(typeVar)
            var request interface{} = map[string]interface{} {
                "instrument_code": GetValue(market, "id"),
                "type": uppercaseType,
                "side": ToUpper(side),
                "amount": this.AmountToPrecision(symbol, amount),
            }
            var priceIsRequired interface{} = false
            if IsTrue(IsTrue(IsEqual(uppercaseType, "LIMIT")) || IsTrue(IsEqual(uppercaseType, "STOP"))) {
                priceIsRequired = true
            }
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "trigger_price", "stopPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                if IsTrue(IsEqual(uppercaseType, "MARKET")) {
                    panic(BadRequest(Add(this.Id, " createOrder() cannot place stop market orders, only stop limit")))
                }
                AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "type", "STOP")
                params = this.Omit(params, []interface{}{"triggerPrice", "trigger_price", "stopPrice"})
            } else if IsTrue(IsEqual(uppercaseType, "STOP")) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a triggerPrice param for "), typeVar), " orders")))
            }
            if IsTrue(priceIsRequired) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_id", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId", "client_id"})
            }
            var timeInForce interface{} = this.SafeString2(params, "timeInForce", "time_in_force", "GOOD_TILL_CANCELLED")
            params = this.Omit(params, "timeInForce")
            AddElementToObject(request, "time_in_force", timeInForce)
        
            response:= (<-this.PrivatePostAccountOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
            //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
            //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //         "instrument_code": "BTC_EUR",
            //         "time": "2019-08-01T08:00:44.026Z",
            //         "side": "BUY",
            //         "price": "5000",
            //         "amount": "1",
            //         "filled_amount": "0.5",
            //         "type": "LIMIT",
            //         "time_in_force": "GOOD_TILL_CANCELLED"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#cancelOrder
 * @description cancels an open order
 * @see https://docs.onetrading.com/#close-order-by-order-id
 * @param {string} id order id
 * @param {string} symbol not used by bitmex cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13098 := (<-this.LoadMarkets())
            PanicOnError(retRes13098)
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_id")
            params = this.Omit(params, []interface{}{"clientOrderId", "client_id"})
            var method interface{} = "privateDeleteAccountOrdersOrderId"
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                method = "privateDeleteAccountOrdersClientClientId"
                AddElementToObject(request, "client_id", clientOrderId)
            } else {
                AddElementToObject(request, "order_id", id)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(method, "privateDeleteAccountOrdersOrderId")) {
                
        response = (<-this.PrivateDeleteAccountOrdersOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateDeleteAccountOrdersClientClientId(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // responds with an empty body
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.onetrading.com/#close-all-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13428 := (<-this.LoadMarkets())
            PanicOnError(retRes13428)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "instrument_code", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateDeleteAccountOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
            //     ]
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#cancelOrders
 * @description cancel multiple orders
 * @see https://docs.onetrading.com/#close-all-orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13688 := (<-this.LoadMarkets())
            PanicOnError(retRes13688)
            var request interface{} = map[string]interface{} {
                "ids": Join(ids, ","),
            }
        
            response:= (<-this.PrivateDeleteAccountOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
            //     ]
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.onetrading.com/#get-order
 * @param {string} id the order id
 * @param {string} symbol not used by onetrading fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13928 := (<-this.LoadMarkets())
            PanicOnError(retRes13928)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateGetAccountOrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "order": {
            //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //             "time_last_updated": "2019-09-27T15:05:35.096Z",
            //             "sequence": 48782,
            //             "price": "7349.2",
            //             "filled_amount": "100.0",
            //             "status": "FILLED_FULLY",
            //             "amount": "100.0",
            //             "instrument_code": "BTC_EUR",
            //             "side": "BUY",
            //             "time": "2019-09-27T15:05:32.063Z",
            //             "type": "MARKET"
            //         },
            //         "trades": [
            //             {
            //                 "fee": {
            //                     "fee_amount": "0.0014",
            //                     "fee_currency": "BTC",
            //                     "fee_percentage": "0.1",
            //                     "fee_group_id": "default",
            //                     "fee_type": "TAKER",
            //                     "running_trading_volume": "0.0"
            //                 },
            //                 "trade": {
            //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
            //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //                     "amount": "1.4",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "7341.4",
            //                     "time": "2019-09-27T15:05:32.564Z",
            //                     "sequence": 48670
            //                 }
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.onetrading.com/#get-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14538 := (<-this.LoadMarkets())
            PanicOnError(retRes14538)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_code", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                var to interface{} = this.SafeString(params, "to")
                if IsTrue(IsEqual(to, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a \"to\" iso8601 string param with the since argument is specified, max range is 100 days")))
                }
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "max_page_size", limit)
            }
        
            response:= (<-this.PrivateGetAccountOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "order_history": [
            //             {
            //                 "order": {
            //                     "trigger_price": "12089.88",
            //                     "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:02:31.663Z",
            //                     "side": "SELL",
            //                     "price": "10159.76",
            //                     "average_price": "10159.76",
            //                     "amount": "0.2",
            //                     "filled_amount": "0.2",
            //                     "type": "STOP",
            //                     "sequence": 8,
            //                     "status": "FILLED_FULLY"
            //                 },
            //                 "trades": [
            //                     {
            //                         "fee": {
            //                             "fee_amount": "0.4188869",
            //                             "fee_currency": "USDT",
            //                             "fee_percentage": "0.1",
            //                             "fee_group_id": "default",
            //                             "fee_type": "TAKER",
            //                             "running_trading_volume": "0.0"
            //                         },
            //                         "trade": {
            //                             "trade_id": "ec82896f-fd1b-4cbb-89df-a9da85ccbb4b",
            //                             "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
            //                             "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                             "amount": "0.2",
            //                             "side": "SELL",
            //                             "instrument_code": "BTC_USDT",
            //                             "price": "10159.76",
            //                             "time": "2019-08-23T10:02:32.663Z",
            //                             "sequence": 9
            //                         }
            //                     }
            //                 ]
            //             },
            //             {
            //                 "order": {
            //                     "order_id": "5151a99e-f414-418f-8cf1-2568d0a63ea5",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:01:36.773Z",
            //                     "side": "SELL",
            //                     "price": "12289.88",
            //                     "amount": "0.5",
            //                     "filled_amount": "0.0",
            //                     "type": "LIMIT",
            //                     "sequence": 7,
            //                     "status": "OPEN"
            //                 },
            //                 "trades": []
            //             },
            //             {
            //                 "order": {
            //                     "order_id": "ac80d857-75e1-4733-9070-fd4288395fdc",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:01:25.031Z",
            //                     "side": "SELL",
            //                     "price": "11089.88",
            //                     "amount": "0.1",
            //                     "filled_amount": "0.0",
            //                     "type": "LIMIT",
            //                     "sequence": 6,
            //                     "status": "OPEN"
            //                 },
            //                 "trades": []
            //             }
            //         ],
            //         "max_page_size": 100
            //     }
            //
            var orderHistory interface{} = this.SafeList(response, "order_history", []interface{}{})
        
            ch <- this.ParseOrders(orderHistory, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.onetrading.com/#get-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *onetrading) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "with_cancelled_and_rejected": true,
            }
        
                retRes157815 :=  (<-this.FetchOpenOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes157815)
                ch <- retRes157815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.onetrading.com/#trades-for-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *onetrading) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15948 := (<-this.LoadMarkets())
            PanicOnError(retRes15948)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "max_page_size", limit)
            }
        
            response:= (<-this.PrivateGetAccountOrdersOrderIdTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "trade_history": [
            //             {
            //                 "trade": {
            //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
            //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                     "amount": "1234.5678",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "1234.5678",
            //                     "time": "2019-08-24T14:15:22Z",
            //                     "price_tick_sequence": 0,
            //                     "sequence": 123456789
            //                 },
            //                 "fee": {
            //                     "fee_amount": "1234.5678",
            //                     "fee_percentage": "1234.5678",
            //                     "fee_group_id": "default",
            //                     "running_trading_volume": "1234.5678",
            //                     "fee_currency": "BTC",
            //                     "fee_type": "TAKER"
            //                 }
            //             }
            //         ],
            //         "max_page_size": 0,
            //         "cursor": "string"
            //     }
            //
            var tradeHistory interface{} = this.SafeValue(response, "trade_history", []interface{}{})
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            ch <- this.ParseTrades(tradeHistory, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name onetrading#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.onetrading.com/#all-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *onetrading) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16548 := (<-this.LoadMarkets())
            PanicOnError(retRes16548)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_code", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                var to interface{} = this.SafeString(params, "to")
                if IsTrue(IsEqual(to, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a \"to\" iso8601 string param with the since argument is specified, max range is 100 days")))
                }
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "max_page_size", limit)
            }
        
            response:= (<-this.PrivateGetAccountTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "trade_history": [
            //             {
            //                 "trade": {
            //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
            //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                     "amount": "1234.5678",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "1234.5678",
            //                     "time": "2019-08-24T14:15:22Z",
            //                     "price_tick_sequence": 0,
            //                     "sequence": 123456789
            //                 },
            //                 "fee": {
            //                     "fee_amount": "1234.5678",
            //                     "fee_percentage": "1234.5678",
            //                     "fee_group_id": "default",
            //                     "running_trading_volume": "1234.5678",
            //                     "fee_currency": "BTC",
            //                     "fee_type": "TAKER"
            //                 }
            //             }
            //         ],
            //         "max_page_size": 0,
            //         "cursor": "string"
            //     }
            //
            var tradeHistory interface{} = this.SafeList(response, "trade_history", []interface{}{})
        
            ch <- this.ParseTrades(tradeHistory, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *onetrading) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.Version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        headers = map[string]interface{} {
            "Accept": "application/json",
            "Authorization": Add("Bearer ", this.ApiKey),
        }
        if IsTrue(IsEqual(method, "POST")) {
            body = this.Json(query)
            AddElementToObject(headers, "Content-Type", "application/json")
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *onetrading) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {"error":"MISSING_FROM_PARAM"}
    //     {"error":"MISSING_TO_PARAM"}
    //     {"error":"CANDLESTICKS_TIME_RANGE_TOO_BIG"}
    //
    var message interface{} = this.SafeString(response, "error")
    if IsTrue(!IsEqual(message, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *onetrading) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
